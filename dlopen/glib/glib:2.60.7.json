{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gmodule/gmodule-ar.c": "/* GMODULE - GLIB wrapper code for dynamic module loading\n * Copyright (C) 1998, 2000 Tim Janik\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/* \n * MT safe\n */\n\n/* because we are compatible with archive format only since AIX 4.3 */\n\n#define __AR_BIG__\n\n#include \"config.h\"\n\n#include <ar.h>\n#include <stdlib.h>\n\n#include <dlfcn.h>\n\n/* --- functions --- */\nstatic gchar*\nfetch_dlerror (gboolean replace_null)\n{\n  gchar *msg = dlerror ();\n\n  /* make sure we always return an error message != NULL, if\n   * expected to do so. */\n\n  if (!msg && replace_null)\n    return \"unknown dl-error\";\n\n  return msg;\n}\n\nstatic gchar* _g_module_get_member(const gchar* file_name)\n{\n  gchar* member = NULL;\n  struct fl_hdr file_header;\n  struct ar_hdr ar_header;\n  long first_member;\n  long name_len;\n  int fd;\n\n  fd = open(file_name, O_RDONLY);\n  if (fd == -1)\n    return NULL;\n\n  if (read(fd, (void*)&file_header, FL_HSZ) != FL_HSZ)\n    goto exit;\n\n  if (strncmp(file_header.fl_magic, AIAMAGBIG, SAIAMAG) != 0)\n    goto exit;\n\n  /* read first archive file member header */\n\n  first_member = atol(file_header.fl_fstmoff);\n\n  if (lseek(fd, first_member, SEEK_SET) != first_member)\n    goto exit;\n\n  if (read(fd, (void*)&ar_header, AR_HSZ - 2) != AR_HSZ - 2)\n    goto exit;\n\n  /* read member name */\n\n  name_len = atol(ar_header.ar_namlen);\n\n  member = g_malloc(name_len+1);\n  if (!member)\n    goto exit;\n\n  if (read(fd, (void*)member, name_len) != name_len)\n    {\n      g_free(member);\n      member = NULL;\n      goto exit;\n    }\n\n  member[name_len] = 0;\n\nexit:\n  close(fd);\n\n  return member;\n}\n\nstatic gpointer\n_g_module_open (const gchar *file_name,\n\t\tgboolean     bind_lazy,\n\t\tgboolean     bind_local)\n{\n  gpointer handle;\n  gchar* member;\n  gchar* full_name;\n\n  /* extract name of first member of archive */\n\n  member = _g_module_get_member (file_name);\n  if (member != NULL)\n    {\n      full_name = g_strconcat (file_name, \"(\", member, \")\", NULL);\n      g_free (member);\n    }\n  else\n    full_name = g_strdup (file_name);\n  \n  handle = dlopen (full_name, \n\t\t   (bind_local ? RTLD_LOCAL : RTLD_GLOBAL) | RTLD_MEMBER | (bind_lazy ? RTLD_LAZY : RTLD_NOW));\n\n  g_free (full_name);\n\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic gpointer\n_g_module_self (void)\n{\n  gpointer handle;\n\n  handle = dlopen (NULL, RTLD_GLOBAL | RTLD_LAZY);\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic void\n_g_module_close (gpointer handle,\n\t\t gboolean is_unref)\n{\n  /* are there any systems out there that have dlopen()/dlclose()\n   * without a reference count implementation?\n   */\n  is_unref |= 1;\n  \n  if (is_unref)\n    {\n      if (dlclose (handle) != 0)\n\tg_module_set_error (fetch_dlerror (TRUE));\n    }\n}\n\nstatic gpointer\n_g_module_symbol (gpointer     handle,\n\t\t  const gchar *symbol_name)\n{\n  gpointer p;\n  \n  p = dlsym (handle, symbol_name);\n  if (!p)\n    g_module_set_error (fetch_dlerror (FALSE));\n  \n  return p;\n}\n\nstatic gchar*\n_g_module_build_path (const gchar *directory,\n\t\t      const gchar *module_name)\n{\n  if (directory && *directory) {\n    if (strncmp (module_name, \"lib\", 3) == 0)\n      return g_strconcat (directory, \"/\", module_name, NULL);\n    else\n      return g_strconcat (directory, \"/lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n  } else if (strncmp (module_name, \"lib\", 3) == 0)\n    return g_strdup (module_name);\n  else\n    return g_strconcat (\"lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gmodule/gmodule.c": "/* GMODULE - GLIB wrapper code for dynamic module loading\n * Copyright (C) 1998 Tim Janik\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * Modified by the GLib Team and others 1997-2000.  See the AUTHORS\n * file for a list of people on the GLib Team.  See the ChangeLog\n * files for a list of changes.  These files are distributed with\n * GLib at ftp://ftp.gtk.org/pub/gtk/. \n */\n\n/* \n * MT safe\n */\n\n#include \"config.h\"\n\n#include \"glib.h\"\n#include \"gmodule.h\"\n\n#include <errno.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#ifdef G_OS_UNIX\n#include <unistd.h>\n#endif\n#ifdef G_OS_WIN32\n#include <io.h>\t\t/* For open() and close() prototypes. */\n#endif\n\n#include \"gmoduleconf.h\"\n#include \"gstdio.h\"\n\n/**\n * SECTION:modules\n * @title: Dynamic Loading of Modules\n * @short_description: portable method for dynamically loading 'plug-ins'\n *\n * These functions provide a portable way to dynamically load object files\n * (commonly known as 'plug-ins'). The current implementation supports all\n * systems that provide an implementation of dlopen() (e.g. Linux/Sun), as\n * well as Windows platforms via DLLs.\n *\n * A program which wants to use these functions must be linked to the\n * libraries output by the command `pkg-config --libs gmodule-2.0`.\n *\n * To use them you must first determine whether dynamic loading\n * is supported on the platform by calling g_module_supported().\n * If it is, you can open a module with g_module_open(),\n * find the module's symbols (e.g. function names) with g_module_symbol(),\n * and later close the module with g_module_close().\n * g_module_name() will return the file name of a currently opened module.\n *\n * If any of the above functions fail, the error status can be found with\n * g_module_error().\n *\n * The #GModule implementation features reference counting for opened modules,\n * and supports hook functions within a module which are called when the\n * module is loaded and unloaded (see #GModuleCheckInit and #GModuleUnload).\n *\n * If your module introduces static data to common subsystems in the running\n * program, e.g. through calling\n * `g_quark_from_static_string (\"my-module-stuff\")`,\n * it must ensure that it is never unloaded, by calling g_module_make_resident().\n *\n * Example: Calling a function defined in a GModule\n * |[<!-- language=\"C\" --> \n * // the function signature for 'say_hello'\n * typedef void (* SayHelloFunc) (const char *message);\n *\n * gboolean\n * just_say_hello (const char *filename, GError **error)\n * {\n *   SayHelloFunc  say_hello;\n *   GModule      *module;\n *\n *   module = g_module_open (filename, G_MODULE_BIND_LAZY);\n *   if (!module)\n *     {\n *       g_set_error (error, FOO_ERROR, FOO_ERROR_BLAH,\n *                    \"%s\", g_module_error ());\n *       return FALSE;\n *     }\n *\n *   if (!g_module_symbol (module, \"say_hello\", (gpointer *)&say_hello))\n *     {\n *       g_set_error (error, SAY_ERROR, SAY_ERROR_OPEN,\n *                    \"%s: %s\", filename, g_module_error ());\n *       if (!g_module_close (module))\n *         g_warning (\"%s: %s\", filename, g_module_error ());\n *       return FALSE;\n *     }\n *\n *   if (say_hello == NULL)\n *     {\n *       g_set_error (error, SAY_ERROR, SAY_ERROR_OPEN,\n *                    \"symbol say_hello is NULL\");\n *       if (!g_module_close (module))\n *         g_warning (\"%s: %s\", filename, g_module_error ());\n *       return FALSE;\n *     }\n *\n *   // call our function in the module\n *   say_hello (\"Hello world!\");\n *\n *   if (!g_module_close (module))\n *     g_warning (\"%s: %s\", filename, g_module_error ());\n *   return TRUE;\n *  }\n * ]|\n */\n\n/**\n * GModule:\n *\n * The #GModule struct is an opaque data structure to represent a\n * [dynamically-loaded module][glib-Dynamic-Loading-of-Modules].\n * It should only be accessed via the following functions.\n */\n\n/**\n * GModuleCheckInit:\n * @module: the #GModule corresponding to the module which has just been loaded\n *\n * Specifies the type of the module initialization function.\n * If a module contains a function named g_module_check_init() it is called\n * automatically when the module is loaded. It is passed the #GModule structure\n * and should return %NULL on success or a string describing the initialization\n * error.\n *\n * Returns: %NULL on success, or a string describing the initialization error\n */\n\n/**\n * GModuleUnload:\n * @module: the #GModule about to be unloaded\n *\n * Specifies the type of the module function called when it is unloaded.\n * If a module contains a function named g_module_unload() it is called\n * automatically when the module is unloaded.\n * It is passed the #GModule structure.\n */\n\n/**\n * G_MODULE_SUFFIX:\n *\n * Expands to the proper shared library suffix for the current platform\n * without the leading dot. For most Unices and Linux this is \"so\", and\n * for Windows this is \"dll\".\n */\n\n/**\n * G_MODULE_EXPORT:\n *\n * Used to declare functions exported by libraries or modules.\n *\n * When compiling for Windows, it marks the symbol as `dllexport`.\n *\n * When compiling for Linux and Unices, it marks the symbol as having `default`\n * visibility. This is no-op unless the code is being compiled with a\n * non-default\n * [visibility flag](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#index-fvisibility-1260)\n * such as `hidden`.\n */\n\n/**\n * G_MODULE_IMPORT:\n *\n * Used to declare functions imported from modules.\n */\n\n/* We maintain a list of modules, so we can reference count them.\n * That's needed because some platforms don't support references counts on\n * modules. Also, the module for the program itself is kept seperately for\n * faster access and because it has special semantics.\n */\n\n\n/* --- structures --- */\nstruct _GModule\n{\n  gchar\t*file_name;\n  gpointer handle;\n  guint ref_count : 31;\n  guint is_resident : 1;\n  GModuleUnload unload;\n  GModule *next;\n};\n\n\n/* --- prototypes --- */\nstatic gpointer\t\t_g_module_open\t\t(const gchar\t*file_name,\n\t\t\t\t\t\t gboolean\t bind_lazy,\n\t\t\t\t\t\t gboolean\t bind_local);\nstatic void\t\t_g_module_close\t\t(gpointer\t handle,\n\t\t\t\t\t\t gboolean\t is_unref);\nstatic gpointer\t\t_g_module_self\t\t(void);\nstatic gpointer\t\t_g_module_symbol\t(gpointer\t handle,\n\t\t\t\t\t\t const gchar\t*symbol_name);\nstatic gchar*\t\t_g_module_build_path\t(const gchar\t*directory,\n\t\t\t\t\t\t const gchar\t*module_name);\nstatic inline void\tg_module_set_error\t(const gchar\t*error);\nstatic inline GModule*\tg_module_find_by_handle (gpointer\t handle);\nstatic inline GModule*\tg_module_find_by_name\t(const gchar\t*name);\n\n\n/* --- variables --- */\nstatic GModule\t     *modules = NULL;\nstatic GModule\t     *main_module = NULL;\nstatic GPrivate       module_error_private = G_PRIVATE_INIT (g_free);\nstatic gboolean\t      module_debug_initialized = FALSE;\nstatic guint\t      module_debug_flags = 0;\n\n\n/* --- inline functions --- */\nstatic inline GModule*\ng_module_find_by_handle (gpointer handle)\n{\n  GModule *module;\n  GModule *retval = NULL;\n  \n  if (main_module && main_module->handle == handle)\n    retval = main_module;\n  else\n    for (module = modules; module; module = module->next)\n      if (handle == module->handle)\n\t{\n\t  retval = module;\n\t  break;\n\t}\n\n  return retval;\n}\n\nstatic inline GModule*\ng_module_find_by_name (const gchar *name)\n{\n  GModule *module;\n  GModule *retval = NULL;\n  \n  for (module = modules; module; module = module->next)\n    if (strcmp (name, module->file_name) == 0)\n\t{\n\t  retval = module;\n\t  break;\n\t}\n\n  return retval;\n}\n\nstatic inline void\ng_module_set_error_unduped (gchar *error)\n{\n  g_private_replace (&module_error_private, error);\n  errno = 0;\n}\n\nstatic inline void\ng_module_set_error (const gchar *error)\n{\n  g_module_set_error_unduped (g_strdup (error));\n}\n\n\n/* --- include platform specifc code --- */\n#define\tSUPPORT_OR_RETURN(rv)\t{ g_module_set_error (NULL); }\n#if\t(G_MODULE_IMPL == G_MODULE_IMPL_DL)\n#include \"gmodule-dl.c\"\n#elif\t(G_MODULE_IMPL == G_MODULE_IMPL_WIN32)\n#include \"gmodule-win32.c\"\n#elif\t(G_MODULE_IMPL == G_MODULE_IMPL_DYLD)\n#include \"gmodule-dyld.c\"\n#elif\t(G_MODULE_IMPL == G_MODULE_IMPL_AR)\n#include \"gmodule-ar.c\"\n#else\n#undef\tSUPPORT_OR_RETURN\n#define\tSUPPORT_OR_RETURN(rv)\t{ g_module_set_error (\"dynamic modules are \" \\\n                                              \"not supported by this system\"); return rv; }\nstatic gpointer\n_g_module_open (const gchar\t*file_name,\n\t\tgboolean\t bind_lazy,\n\t\tgboolean\t bind_local)\n{\n  return NULL;\n}\nstatic void\n_g_module_close\t(gpointer\t handle,\n\t\t gboolean\t is_unref)\n{\n}\nstatic gpointer\n_g_module_self (void)\n{\n  return NULL;\n}\nstatic gpointer\n_g_module_symbol (gpointer\t handle,\n\t\t  const gchar\t*symbol_name)\n{\n  return NULL;\n}\nstatic gchar*\n_g_module_build_path (const gchar *directory,\n\t\t      const gchar *module_name)\n{\n  return NULL;\n}\n#endif\t/* no implementation */\n\n/* --- functions --- */\n\n/**\n * g_module_supported:\n *\n * Checks if modules are supported on the current platform.\n *\n * Returns: %TRUE if modules are supported\n */\ngboolean\ng_module_supported (void)\n{\n  SUPPORT_OR_RETURN (FALSE);\n  \n  return TRUE;\n}\n\nstatic gchar*\nparse_libtool_archive (const gchar* libtool_name)\n{\n  const guint TOKEN_DLNAME = G_TOKEN_LAST + 1;\n  const guint TOKEN_INSTALLED = G_TOKEN_LAST + 2;\n  const guint TOKEN_LIBDIR = G_TOKEN_LAST + 3;\n  gchar *lt_dlname = NULL;\n  gboolean lt_installed = TRUE;\n  gchar *lt_libdir = NULL;\n  gchar *name;\n  GTokenType token;\n  GScanner *scanner;\n  \n  int fd = g_open (libtool_name, O_RDONLY, 0);\n  if (fd < 0)\n    {\n      gchar *display_libtool_name = g_filename_display_name (libtool_name);\n      g_module_set_error_unduped (g_strdup_printf (\"failed to open libtool archive \\\"%s\\\"\", display_libtool_name));\n      g_free (display_libtool_name);\n      return NULL;\n    }\n  /* search libtool's dlname specification  */\n  scanner = g_scanner_new (NULL);\n  g_scanner_input_file (scanner, fd);\n  scanner->config->symbol_2_token = TRUE;\n  g_scanner_scope_add_symbol (scanner, 0, \"dlname\", \n\t\t\t      GUINT_TO_POINTER (TOKEN_DLNAME));\n  g_scanner_scope_add_symbol (scanner, 0, \"installed\", \n\t\t\t      GUINT_TO_POINTER (TOKEN_INSTALLED));\n  g_scanner_scope_add_symbol (scanner, 0, \"libdir\", \n\t\t\t      GUINT_TO_POINTER (TOKEN_LIBDIR));\n  while (!g_scanner_eof (scanner))\n    {\n      token = g_scanner_get_next_token (scanner);\n      if (token == TOKEN_DLNAME || token == TOKEN_INSTALLED || \n\t  token == TOKEN_LIBDIR)\n\t{\n\t  if (g_scanner_get_next_token (scanner) != '=' ||\n\t      g_scanner_get_next_token (scanner) != \n\t      (token == TOKEN_INSTALLED ? \n\t       G_TOKEN_IDENTIFIER : G_TOKEN_STRING))\n\t    {\n\t      gchar *display_libtool_name = g_filename_display_name (libtool_name);\n\t      g_module_set_error_unduped (g_strdup_printf (\"unable to parse libtool archive \\\"%s\\\"\", display_libtool_name));\n\t      g_free (display_libtool_name);\n\n\t      g_free (lt_dlname);\n\t      g_free (lt_libdir);\n\t      g_scanner_destroy (scanner);\n\t      close (fd);\n\n\t      return NULL;\n\t    }\n\t  else\n\t    {\n\t      if (token == TOKEN_DLNAME)\n\t\t{\n\t\t  g_free (lt_dlname);\n\t\t  lt_dlname = g_strdup (scanner->value.v_string);\n\t\t}\n\t      else if (token == TOKEN_INSTALLED)\n\t\tlt_installed = \n\t\t  strcmp (scanner->value.v_identifier, \"yes\") == 0;\n\t      else /* token == TOKEN_LIBDIR */\n\t\t{\n\t\t  g_free (lt_libdir);\n\t\t  lt_libdir = g_strdup (scanner->value.v_string);\n\t\t}\n\t    }\n\t}      \n    }\n\n  if (!lt_installed)\n    {\n      gchar *dir = g_path_get_dirname (libtool_name);\n      g_free (lt_libdir);\n      lt_libdir = g_strconcat (dir, G_DIR_SEPARATOR_S \".libs\", NULL);\n      g_free (dir);\n    }\n\n  name = g_strconcat (lt_libdir, G_DIR_SEPARATOR_S, lt_dlname, NULL);\n  \n  g_free (lt_dlname);\n  g_free (lt_libdir);\n  g_scanner_destroy (scanner);\n  close (fd);\n\n  return name;\n}\n\nstatic inline gboolean\nstr_check_suffix (const gchar* string,\n\t\t  const gchar* suffix)\n{\n  gsize string_len = strlen (string);    \n  gsize suffix_len = strlen (suffix);    \n\n  return string_len >= suffix_len && \n    strcmp (string + string_len - suffix_len, suffix) == 0;\n}\n\nenum\n{\n  G_MODULE_DEBUG_RESIDENT_MODULES = 1 << 0,\n  G_MODULE_DEBUG_BIND_NOW_MODULES = 1 << 1\n};\n\nstatic void\n_g_module_debug_init (void)\n{\n  const GDebugKey keys[] = {\n    { \"resident-modules\", G_MODULE_DEBUG_RESIDENT_MODULES },\n    { \"bind-now-modules\", G_MODULE_DEBUG_BIND_NOW_MODULES }\n  };\n  const gchar *env;\n\n  env = g_getenv (\"G_DEBUG\");\n\n  module_debug_flags =\n    !env ? 0 : g_parse_debug_string (env, keys, G_N_ELEMENTS (keys));\n\n  module_debug_initialized = TRUE;\n}\n\nstatic GRecMutex g_module_global_lock;\n\n/**\n * g_module_open:\n * @file_name: (nullable): the name of the file containing the module, or %NULL\n *     to obtain a #GModule representing the main program itself\n * @flags: the flags used for opening the module. This can be the\n *     logical OR of any of the #GModuleFlags\n *\n * Opens a module. If the module has already been opened,\n * its reference count is incremented.\n *\n * First of all g_module_open() tries to open @file_name as a module.\n * If that fails and @file_name has the \".la\"-suffix (and is a libtool\n * archive) it tries to open the corresponding module. If that fails\n * and it doesn't have the proper module suffix for the platform\n * (#G_MODULE_SUFFIX), this suffix will be appended and the corresponding\n * module will be opended. If that fails and @file_name doesn't have the\n * \".la\"-suffix, this suffix is appended and g_module_open() tries to open\n * the corresponding module. If eventually that fails as well, %NULL is\n * returned.\n *\n * Returns: a #GModule on success, or %NULL on failure\n */\nGModule*\ng_module_open (const gchar    *file_name,\n\t       GModuleFlags    flags)\n{\n  GModule *module;\n  gpointer handle = NULL;\n  gchar *name = NULL;\n  \n  SUPPORT_OR_RETURN (NULL);\n  \n  g_rec_mutex_lock (&g_module_global_lock);\n\n  if (G_UNLIKELY (!module_debug_initialized))\n    _g_module_debug_init ();\n\n  if (module_debug_flags & G_MODULE_DEBUG_BIND_NOW_MODULES)\n    flags &= ~G_MODULE_BIND_LAZY;\n\n  if (!file_name)\n    {      \n      if (!main_module)\n\t{\n\t  handle = _g_module_self ();\n/* On Android 64 bit, RTLD_DEFAULT is (void *)0x0\n * so it always fails to create main_module if file_name is NULL */\n#if !defined(__BIONIC__) || !defined(__LP64__)\n\t  if (handle)\n#endif\n\t    {\n\t      main_module = g_new (GModule, 1);\n\t      main_module->file_name = NULL;\n\t      main_module->handle = handle;\n\t      main_module->ref_count = 1;\n\t      main_module->is_resident = TRUE;\n\t      main_module->unload = NULL;\n\t      main_module->next = NULL;\n\t    }\n\t}\n      else\n\tmain_module->ref_count++;\n\n      g_rec_mutex_unlock (&g_module_global_lock);\n      return main_module;\n    }\n  \n  /* we first search the module list by name */\n  module = g_module_find_by_name (file_name);\n  if (module)\n    {\n      module->ref_count++;\n      \n      g_rec_mutex_unlock (&g_module_global_lock);\n      return module;\n    }\n\n  /* check whether we have a readable file right away */\n  if (g_file_test (file_name, G_FILE_TEST_IS_REGULAR))\n    name = g_strdup (file_name);\n  /* try completing file name with standard library suffix */\n  if (!name)\n    {\n      name = g_strconcat (file_name, \".\" G_MODULE_SUFFIX, NULL);\n      if (!g_file_test (name, G_FILE_TEST_IS_REGULAR))\n\t{\n\t  g_free (name);\n\t  name = NULL;\n\t}\n    }\n  /* try completing by appending libtool suffix */\n  if (!name)\n    {\n      name = g_strconcat (file_name, \".la\", NULL);\n      if (!g_file_test (name, G_FILE_TEST_IS_REGULAR))\n\t{\n\t  g_free (name);\n\t  name = NULL;\n\t}\n    }\n  /* we can't access() the file, lets hope the platform backends finds\n   * it via library paths\n   */\n  if (!name)\n    {\n      gchar *dot = strrchr (file_name, '.');\n      gchar *slash = strrchr (file_name, G_DIR_SEPARATOR);\n      \n      /* make sure the name has a suffix */\n      if (!dot || dot < slash)\n\tname = g_strconcat (file_name, \".\" G_MODULE_SUFFIX, NULL);\n      else\n\tname = g_strdup (file_name);\n    }\n\n  /* ok, try loading the module */\n  if (name)\n    {\n      /* if it's a libtool archive, figure library file to load */\n      if (str_check_suffix (name, \".la\")) /* libtool archive? */\n\t{\n\t  gchar *real_name = parse_libtool_archive (name);\n\n\t  /* real_name might be NULL, but then module error is already set */\n\t  if (real_name)\n\t    {\n\t      g_free (name);\n\t      name = real_name;\n            }\n\t}\n      if (name)\n\thandle = _g_module_open (name, (flags & G_MODULE_BIND_LAZY) != 0,\n\t\t\t(flags & G_MODULE_BIND_LOCAL) != 0);\n    }\n  else\n    {\n      gchar *display_file_name = g_filename_display_name (file_name);\n      g_module_set_error_unduped (g_strdup_printf (\"unable to access file \\\"%s\\\"\", display_file_name));\n      g_free (display_file_name);\n    }\n  g_free (name);\n\n  if (handle)\n    {\n      gchar *saved_error;\n      GModuleCheckInit check_init;\n      const gchar *check_failed = NULL;\n      \n      /* search the module list by handle, since file names are not unique */\n      module = g_module_find_by_handle (handle);\n      if (module)\n\t{\n\t  _g_module_close (module->handle, TRUE);\n\t  module->ref_count++;\n\t  g_module_set_error (NULL);\n\t  \n\t  g_rec_mutex_unlock (&g_module_global_lock);\n\t  return module;\n\t}\n      \n      saved_error = g_strdup (g_module_error ());\n      g_module_set_error (NULL);\n      \n      module = g_new (GModule, 1);\n      module->file_name = g_strdup (file_name);\n      module->handle = handle;\n      module->ref_count = 1;\n      module->is_resident = FALSE;\n      module->unload = NULL;\n      module->next = modules;\n      modules = module;\n      \n      /* check initialization */\n      if (g_module_symbol (module, \"g_module_check_init\", (gpointer) &check_init) && check_init != NULL)\n\tcheck_failed = check_init (module);\n      \n      /* we don't call unload() if the initialization check failed. */\n      if (!check_failed)\n\tg_module_symbol (module, \"g_module_unload\", (gpointer) &module->unload);\n      \n      if (check_failed)\n\t{\n\t  gchar *error;\n\n\t  error = g_strconcat (\"GModule (\", file_name, \") \",\n                               \"initialization check failed: \",\n                               check_failed, NULL);\n\t  g_module_close (module);\n\t  module = NULL;\n\t  g_module_set_error (error);\n\t  g_free (error);\n\t}\n      else\n\tg_module_set_error (saved_error);\n\n      g_free (saved_error);\n    }\n\n  if (module != NULL &&\n      (module_debug_flags & G_MODULE_DEBUG_RESIDENT_MODULES))\n    g_module_make_resident (module);\n\n  g_rec_mutex_unlock (&g_module_global_lock);\n  return module;\n}\n\n/**\n * g_module_close:\n * @module: a #GModule to close\n *\n * Closes a module.\n *\n * Returns: %TRUE on success\n */\ngboolean\ng_module_close (GModule *module)\n{\n  SUPPORT_OR_RETURN (FALSE);\n  \n  g_return_val_if_fail (module != NULL, FALSE);\n  g_return_val_if_fail (module->ref_count > 0, FALSE);\n  \n  g_rec_mutex_lock (&g_module_global_lock);\n\n  module->ref_count--;\n  \n  if (!module->ref_count && !module->is_resident && module->unload)\n    {\n      GModuleUnload unload;\n\n      unload = module->unload;\n      module->unload = NULL;\n      unload (module);\n    }\n\n  if (!module->ref_count && !module->is_resident)\n    {\n      GModule *last;\n      GModule *node;\n      \n      last = NULL;\n      \n      node = modules;\n      while (node)\n\t{\n\t  if (node == module)\n\t    {\n\t      if (last)\n\t\tlast->next = node->next;\n\t      else\n\t\tmodules = node->next;\n\t      break;\n\t    }\n\t  last = node;\n\t  node = last->next;\n\t}\n      module->next = NULL;\n      \n      _g_module_close (module->handle, FALSE);\n      g_free (module->file_name);\n      g_free (module);\n    }\n  \n  g_rec_mutex_unlock (&g_module_global_lock);\n  return g_module_error() == NULL;\n}\n\n/**\n * g_module_make_resident:\n * @module: a #GModule to make permanently resident\n *\n * Ensures that a module will never be unloaded.\n * Any future g_module_close() calls on the module will be ignored.\n */\nvoid\ng_module_make_resident (GModule *module)\n{\n  g_return_if_fail (module != NULL);\n\n  module->is_resident = TRUE;\n}\n\n/**\n * g_module_error:\n *\n * Gets a string describing the last module error.\n *\n * Returns: a string describing the last module error\n */\nconst gchar *\ng_module_error (void)\n{\n  return g_private_get (&module_error_private);\n}\n\n/**\n * g_module_symbol:\n * @module: a #GModule\n * @symbol_name: the name of the symbol to find\n * @symbol: (out): returns the pointer to the symbol value\n *\n * Gets a symbol pointer from a module, such as one exported\n * by #G_MODULE_EXPORT. Note that a valid symbol can be %NULL.\n *\n * Returns: %TRUE on success\n */\ngboolean\ng_module_symbol (GModule     *module,\n                 const gchar *symbol_name,\n                 gpointer    *symbol)\n{\n  const gchar *module_error;\n\n  if (symbol)\n    *symbol = NULL;\n  SUPPORT_OR_RETURN (FALSE);\n  \n  g_return_val_if_fail (module != NULL, FALSE);\n  g_return_val_if_fail (symbol_name != NULL, FALSE);\n  g_return_val_if_fail (symbol != NULL, FALSE);\n  \n  g_rec_mutex_lock (&g_module_global_lock);\n\n#ifdef\tG_MODULE_NEED_USCORE\n  {\n    gchar *name;\n\n    name = g_strconcat (\"_\", symbol_name, NULL);\n    *symbol = _g_module_symbol (module->handle, name);\n    g_free (name);\n  }\n#else\t/* !G_MODULE_NEED_USCORE */\n  *symbol = _g_module_symbol (module->handle, symbol_name);\n#endif\t/* !G_MODULE_NEED_USCORE */\n  \n  module_error = g_module_error ();\n  if (module_error)\n    {\n      gchar *error;\n\n      error = g_strconcat (\"'\", symbol_name, \"': \", module_error, NULL);\n      g_module_set_error (error);\n      g_free (error);\n      *symbol = NULL;\n    }\n  \n  g_rec_mutex_unlock (&g_module_global_lock);\n  return !module_error;\n}\n\n/**\n * g_module_name:\n * @module: a #GModule\n *\n * Returns the filename that the module was opened with.\n *\n * If @module refers to the application itself, \"main\" is returned.\n *\n * Returns: (transfer none): the filename of the module\n */\nconst gchar *\ng_module_name (GModule *module)\n{\n  g_return_val_if_fail (module != NULL, NULL);\n  \n  if (module == main_module)\n    return \"main\";\n  \n  return module->file_name;\n}\n\n/**\n * g_module_build_path:\n * @directory: (nullable): the directory where the module is. This can be\n *     %NULL or the empty string to indicate that the standard platform-specific\n *     directories will be used, though that is not recommended\n * @module_name: the name of the module\n *\n * A portable way to build the filename of a module. The platform-specific\n * prefix and suffix are added to the filename, if needed, and the result\n * is added to the directory, using the correct separator character.\n *\n * The directory should specify the directory where the module can be found.\n * It can be %NULL or an empty string to indicate that the module is in a\n * standard platform-specific directory, though this is not recommended\n * since the wrong module may be found.\n *\n * For example, calling g_module_build_path() on a Linux system with a\n * @directory of `/lib` and a @module_name of \"mylibrary\" will return\n * `/lib/libmylibrary.so`. On a Windows system, using `\\Windows` as the\n * directory it will return `\\Windows\\mylibrary.dll`.\n *\n * Returns: the complete path of the module, including the standard library\n *     prefix and suffix. This should be freed when no longer needed\n */\ngchar *\ng_module_build_path (const gchar *directory,\n                     const gchar *module_name)\n{\n  g_return_val_if_fail (module_name != NULL, NULL);\n  \n  return _g_module_build_path (directory, module_name);\n}\n\n\n#ifdef G_OS_WIN32\n\n/* Binary compatibility versions. Not for newly compiled code. */\n\n_GLIB_EXTERN GModule *    g_module_open_utf8 (const gchar  *file_name,\n                                              GModuleFlags  flags);\n\n_GLIB_EXTERN const gchar *g_module_name_utf8 (GModule      *module);\n\nGModule*\ng_module_open_utf8 (const gchar    *file_name,\n                    GModuleFlags    flags)\n{\n  return g_module_open (file_name, flags);\n}\n\nconst gchar *\ng_module_name_utf8 (GModule *module)\n{\n  return g_module_name (module);\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gmodule/meson.build": "gmoduleconf_conf = configuration_data()\n\ng_module_need_uscore = 0\ng_module_broken_rtld_global = 0\ng_module_have_dlerror = 0\n\nlibdl_dep = [ ]\ng_module_lib_args = [ ]\ng_module_impl = ''\n\ndlopen_dlsym_test_code = '''\n#include <dlfcn.h>\nint glib_underscore_test (void) { return 42; }\nint main (int argc, char ** argv) {\n  void *f1 = (void*)0, *f2 = (void*)0, *handle;\n  handle = dlopen ((void*)0, 0);\n  if (handle) {\n    f1 = dlsym (handle, \"glib_underscore_test\");\n    f2 = dlsym (handle, \"_glib_underscore_test\");\n  }\n  return (!f2 || f1);\n}'''\n\n# On Windows force native WIN32 shared lib loader\nif host_system == 'windows'\n  g_module_impl = 'G_MODULE_IMPL_WIN32'\n# Force native AIX library loader\n# dlopen() filepath must be of the form /path/libname.a(libname.so)\nelif host_system == 'aix'\n  g_module_impl = 'G_MODULE_IMPL_AR'\nelif cc.links(dlopen_dlsym_test_code, name : 'dlopen() and dlsym() in system libraries')\n  g_module_impl = 'G_MODULE_IMPL_DL'\n# NSLinkModule (dyld) in system libraries (Darwin)\nelif cc.has_function('NSLinkModule')\n  g_module_impl = 'G_MODULE_IMPL_DYLD'\n  g_module_need_uscore = 1\nelif cc.links(dlopen_dlsym_test_code, args : '-ldl', name : 'dlopen() and dlsym() in libdl')\n  g_module_impl = 'G_MODULE_IMPL_DL'\n  libdl_dep = cc.find_library('dl')\n  g_module_lib_args = '-ldl'\nendif\n\n# additional checks for G_MODULE_IMPL_DL\nif g_module_impl == 'G_MODULE_IMPL_DL'\n  # FIXME: check for OSF1/5.0 RTLD_GLOBAL brokenness (is this still relevant?)\n\n  # Check whether we need preceding underscores\n  if cc.get_id() == 'msvc'\n    message('Building for MSVC: assuming that symbols are prefixed with underscore')\n    g_module_need_uscore = 1\n  elif meson.has_exe_wrapper()\n    # FIXME: communicate result via stdout instead of return value, so non-0 return is not printed in bold red\n    rres = cc.run(dlopen_dlsym_test_code,\n                  args : g_module_lib_args,\n                  name : 'dlsym() preceding underscores')\n    if host_system == 'windows' or rres.returncode() == 0\n      g_module_need_uscore = 1\n    endif\n  else\n    message('Cross-compiling: assuming that symbols aren\\'t prefixed with underscore')\n    g_module_need_uscore = 0\n  endif\n\n  if cc.has_function('dlerror', args : g_module_lib_args)\n    g_module_have_dlerror = 1\n  endif\nendif\n\n# Done, have we got an implementation?\nif g_module_impl == ''\n  g_module_impl = '0'\n  message('WARNING: No suitable GModule implementation found!')\nendif\n\ngmoduleconf_conf.set('G_MODULE_IMPL', g_module_impl)\ngmoduleconf_conf.set('G_MODULE_SUPPORTED', g_module_impl != '0')\ngmoduleconf_conf.set('G_MODULE_HAVE_DLERROR', g_module_have_dlerror)\ngmoduleconf_conf.set('G_MODULE_NEED_USCORE', g_module_need_uscore)\ngmoduleconf_conf.set('G_MODULE_BROKEN_RTLD_GLOBAL', g_module_broken_rtld_global)\n\ngmoduleconf_h = configure_file(input : 'gmoduleconf.h.in',\n                               output : 'gmoduleconf.h',\n                               configuration : gmoduleconf_conf)\n\ninstall_headers(['gmodule.h'], subdir : 'glib-2.0')\n\ngmodule_sources = ['gmodule.c']\nif host_system == 'windows'\n  gmodule_win_rc = configure_file(\n    input: 'gmodule.rc.in',\n    output: 'gmodule.rc',\n    configuration: glibconfig_conf,\n  )\n  gmodule_win_res = windows.compile_resources(gmodule_win_rc)\n  gmodule_sources += [gmodule_win_res]\nendif\n\nlibgmodule = library('gmodule-2.0',\n  sources : gmodule_sources,\n  version : library_version,\n  soversion : soversion,\n  darwin_versions : darwin_versions,\n  install : true,\n  include_directories : [configinc, gmoduleinc],\n  dependencies : [libdl_dep, libglib_dep],\n  c_args : ['-DG_LOG_DOMAIN=\"GModule\"', '-DG_DISABLE_DEPRECATED'] + glib_hidden_visibility_args,\n  link_args : [glib_link_flags],\n)\n\nsupported_var = 'gmodule_supported=@0@'.format(g_module_impl != '0')\n\npkg.generate(libgmodule,\n  libraries : [thread_dep],\n  requires : ['glib-2.0'],\n  version : glib_version,\n  variables : [supported_var],\n  install_dir : glib_pkgconfigreldir,\n  filebase : 'gmodule-no-export-2.0',\n  name : 'GModule',\n  description : 'Dynamic module loader for GLib',\n)\n\npkg.generate(libraries : [libgmodule, export_dynamic_ldflags],\n  requires : ['glib-2.0'],\n  version : glib_version,\n  variables : [supported_var],\n  install_dir : glib_pkgconfigreldir,\n  filebase : 'gmodule-export-2.0',\n  name : 'GModule',\n  description : 'Dynamic module loader for GLib',\n)\n\npkg.generate(libraries : [libgmodule, export_dynamic_ldflags],\n  requires : ['glib-2.0'],\n  version : glib_version,\n  variables : [supported_var],\n  install_dir : glib_pkgconfigreldir,\n  filebase : 'gmodule-2.0',\n  name : 'GModule',\n  description : 'Dynamic module loader for GLib',\n)\n\nlibgmodule_dep = declare_dependency(link_with : libgmodule,\n  include_directories : [gmoduleinc],\n  dependencies : [libglib_dep])\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gmodule/gmodule-dl.c": "/* GMODULE - GLIB wrapper code for dynamic module loading\n * Copyright (C) 1998, 2000 Tim Janik\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * Modified by the GLib Team and others 1997-2000.  See the AUTHORS\n * file for a list of people on the GLib Team.  See the ChangeLog\n * files for a list of changes.  These files are distributed with\n * GLib at ftp://ftp.gtk.org/pub/gtk/. \n */\n\n/* \n * MT safe\n */\n#include \"config.h\"\n\n#include <dlfcn.h>\n\n/* Perl includes <nlist.h> and <link.h> instead of <dlfcn.h> on some systmes? */\n\n\n/* dlerror() is not implemented on all systems\n */\n#ifndef\tG_MODULE_HAVE_DLERROR\n#  ifdef __NetBSD__\n#    define dlerror()\tg_strerror (errno)\n#  else /* !__NetBSD__ */\n/* could we rely on errno's state here? */\n#    define dlerror()\t\"unknown dl-error\"\n#  endif /* !__NetBSD__ */\n#endif\t/* G_MODULE_HAVE_DLERROR */\n\n/* some flags are missing on some systems, so we provide\n * harmless defaults.\n * The Perl sources say, RTLD_LAZY needs to be defined as (1),\n * at least for Solaris 1.\n *\n * Mandatory:\n * RTLD_LAZY   - resolve undefined symbols as code from the dynamic library\n *\t\t is executed.\n * RTLD_NOW    - resolve all undefined symbols before dlopen returns, and fail\n *\t\t if this cannot be done.\n * Optionally:\n * RTLD_GLOBAL - the external symbols defined in the library will be made\n *\t\t available to subsequently loaded libraries.\n */\n#ifndef\tHAVE_RTLD_LAZY\n#define\tRTLD_LAZY\t1\n#endif\t/* RTLD_LAZY */\n#ifndef\tHAVE_RTLD_NOW\n#define\tRTLD_NOW\t0\n#endif\t/* RTLD_NOW */\n/* some systems (OSF1 V5.0) have broken RTLD_GLOBAL linkage */\n#ifdef G_MODULE_BROKEN_RTLD_GLOBAL\n#undef\tRTLD_GLOBAL\n#undef\tHAVE_RTLD_GLOBAL\n#endif /* G_MODULE_BROKEN_RTLD_GLOBAL */\n#ifndef\tHAVE_RTLD_GLOBAL\n#define\tRTLD_GLOBAL\t0\n#endif\t/* RTLD_GLOBAL */\n\n\n/* --- functions --- */\nstatic gchar*\nfetch_dlerror (gboolean replace_null)\n{\n  gchar *msg = dlerror ();\n\n  /* make sure we always return an error message != NULL, if\n   * expected to do so. */\n\n  if (!msg && replace_null)\n    return \"unknown dl-error\";\n\n  return msg;\n}\n\nstatic gpointer\n_g_module_open (const gchar *file_name,\n\t\tgboolean     bind_lazy,\n\t\tgboolean     bind_local)\n{\n  gpointer handle;\n  \n  handle = dlopen (file_name,\n\t\t   (bind_local ? 0 : RTLD_GLOBAL) | (bind_lazy ? RTLD_LAZY : RTLD_NOW));\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic gpointer\n_g_module_self (void)\n{\n  gpointer handle;\n  \n  /* to query symbols from the program itself, special link options\n   * are required on some systems.\n   */\n\n  /* On Android 32 bit (i.e. not __LP64__), dlopen(NULL)\n   * does not work reliable and generally no symbols are found\n   * at all. RTLD_DEFAULT works though.\n   * On Android 64 bit, dlopen(NULL) seems to work but dlsym(handle)\n   * always returns 'undefined symbol'. Only if RTLD_DEFAULT or \n   * NULL is given, dlsym returns an appropriate pointer.\n   */\n#if defined(__BIONIC__)\n  handle = RTLD_DEFAULT;\n#else\n  handle = dlopen (NULL, RTLD_GLOBAL | RTLD_LAZY);\n#endif\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic void\n_g_module_close (gpointer handle,\n\t\t gboolean is_unref)\n{\n  /* are there any systems out there that have dlopen()/dlclose()\n   * without a reference count implementation?\n   *\n   * See above for the Android special case\n   */\n#if defined(__BIONIC__)\n  is_unref = (handle != RTLD_DEFAULT);\n#else\n  is_unref |= 1;\n#endif\n\n  if (is_unref)\n    {\n      if (dlclose (handle) != 0)\n\tg_module_set_error (fetch_dlerror (TRUE));\n    }\n}\n\nstatic gpointer\n_g_module_symbol (gpointer     handle,\n\t\t  const gchar *symbol_name)\n{\n  gpointer p;\n  gchar *msg;\n\n  fetch_dlerror (FALSE);\n  p = dlsym (handle, symbol_name);\n  msg = fetch_dlerror (FALSE);\n  if (msg)\n    g_module_set_error (msg);\n  \n  return p;\n}\n\nstatic gchar*\n_g_module_build_path (const gchar *directory,\n\t\t      const gchar *module_name)\n{\n  if (directory && *directory) {\n    if (strncmp (module_name, \"lib\", 3) == 0)\n      return g_strconcat (directory, \"/\", module_name, NULL);\n    else\n      return g_strconcat (directory, \"/lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n  } else if (strncmp (module_name, \"lib\", 3) == 0)\n    return g_strdup (module_name);\n  else\n    return g_strconcat (\"lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/gdbusconnection.c": "/* GDBus - GLib D-Bus Library\n *\n * Copyright (C) 2008-2010 Red Hat, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General\n * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.\n *\n * Author: David Zeuthen <davidz@redhat.com>\n */\n\n/*\n * TODO for GDBus:\n *\n * - would be nice to expose GDBusAuthMechanism and an extension point\n *\n * - Need to rewrite GDBusAuth and rework GDBusAuthMechanism. In particular\n *   the mechanism VFuncs need to be able to set an error.\n *\n * - Need to document other mechanisms/sources for determining the D-Bus\n *   address of a well-known bus.\n *\n *   - e.g. on Win32 we need code like from here\n *\n *     http://cgit.freedesktop.org/~david/gdbus-standalone/tree/gdbus/gdbusaddress.c#n900\n *\n *     that was never copied over here because it originally was copy-paste\n *     from the GPLv2 / AFL 2.1 libdbus sources.\n *\n *   - on OS X we need to look in launchd for the address\n *\n *     https://bugs.freedesktop.org/show_bug.cgi?id=14259\n *\n *   - on X11 we need to look in a X11 property on the X server\n *     - (we can also just use dbus-launch(1) from the D-Bus\n *        distribution)\n *\n *   - (ideally) this requires D-Bus spec work because none of\n *     this has never really been specced out properly (except\n *     the X11 bits)\n *\n * - Related to the above, we also need to be able to launch a message bus\n *   instance.... Since we don't want to write our own bus daemon we should\n *   launch dbus-daemon(1) (thus: Win32 and OS X need to bundle it)\n *\n * - probably want a G_DBUS_NONCE_TCP_TMPDIR environment variable\n *   to specify where the nonce is stored. This will allow people to use\n *   G_DBUS_NONCE_TCP_TMPDIR=/mnt/secure.company.server/dbus-nonce-dir\n *   to easily achieve secure RPC via nonce-tcp.\n *\n * - need to expose an extension point for resolving D-Bus address and\n *   turning them into GIOStream objects. This will allow us to implement\n *   e.g. X11 D-Bus transports without dlopen()'ing or linking against\n *   libX11 from libgio.\n *   - see g_dbus_address_connect() in gdbusaddress.c\n *\n * - would be cute to use kernel-specific APIs to resolve fds for\n *   debug output when using G_DBUS_DEBUG=message, e.g. in addition to\n *\n *     fd 21: dev=8:1,mode=0100644,ino=1171231,uid=0,gid=0,rdev=0:0,size=234,atime=1273070640,mtime=1267126160,ctime=1267126160\n *\n *   maybe we can show more information about what fd 21 really is.\n *   Ryan suggests looking in /proc/self/fd for clues / symlinks!\n *   Initial experiments on Linux 2.6 suggests that the symlink looks\n *   like this:\n *\n *    3 -> /proc/18068/fd\n *\n *   e.g. not of much use.\n *\n *  - GDBus High-Level docs\n *    - Proxy: properties, signals...\n *    - Connection: IOStream based, ::close, connection setup steps\n *                  mainloop integration, threading\n *    - Differences from libdbus (extend \"Migrating from\")\n *      - the message handling thread\n *      - Using GVariant instead of GValue\n *    - Explain why the high-level API is a good thing and what\n *      kind of pitfalls it avoids\n *      - Export objects before claiming names\n *    - Talk about auto-starting services (cf. GBusNameWatcherFlags)\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"gdbusauth.h\"\n#include \"gdbusutils.h\"\n#include \"gdbusaddress.h\"\n#include \"gdbusmessage.h\"\n#include \"gdbusconnection.h\"\n#include \"gdbuserror.h\"\n#include \"gioenumtypes.h\"\n#include \"gdbusintrospection.h\"\n#include \"gdbusmethodinvocation.h\"\n#include \"gdbusprivate.h\"\n#include \"gdbusauthobserver.h\"\n#include \"ginitable.h\"\n#include \"gasyncinitable.h\"\n#include \"giostream.h\"\n#include \"gasyncresult.h\"\n#include \"gtask.h\"\n\n#ifdef G_OS_UNIX\n#include \"gunixconnection.h\"\n#include \"gunixfdmessage.h\"\n#endif\n\n#include \"glibintl.h\"\n\n/**\n * SECTION:gdbusconnection\n * @short_description: D-Bus Connections\n * @include: gio/gio.h\n *\n * The #GDBusConnection type is used for D-Bus connections to remote\n * peers such as a message buses. It is a low-level API that offers a\n * lot of flexibility. For instance, it lets you establish a connection\n * over any transport that can by represented as an #GIOStream.\n *\n * This class is rarely used directly in D-Bus clients. If you are writing\n * a D-Bus client, it is often easier to use the g_bus_own_name(),\n * g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.\n *\n * As an exception to the usual GLib rule that a particular object must not\n * be used by two threads at the same time, #GDBusConnection's methods may be\n * called from any thread. This is so that g_bus_get() and g_bus_get_sync()\n * can safely return the same #GDBusConnection when called from any thread.\n *\n * Most of the ways to obtain a #GDBusConnection automatically initialize it\n * (i.e. connect to D-Bus): for instance, g_dbus_connection_new() and\n * g_bus_get(), and the synchronous versions of those methods, give you an\n * initialized connection. Language bindings for GIO should use\n * g_initable_new() or g_async_initable_new_async(), which also initialize the\n * connection.\n *\n * If you construct an uninitialized #GDBusConnection, such as via\n * g_object_new(), you must initialize it via g_initable_init() or\n * g_async_initable_init_async() before using its methods or properties.\n * Calling methods or accessing properties on a #GDBusConnection that has not\n * completed initialization successfully is considered to be invalid, and leads\n * to undefined behaviour. In particular, if initialization fails with a\n * #GError, the only valid thing you can do with that #GDBusConnection is to\n * free it with g_object_unref().\n *\n * ## An example D-Bus server # {#gdbus-server}\n *\n * Here is an example for a D-Bus server:\n * [gdbus-example-server.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)\n *\n * ## An example for exporting a subtree # {#gdbus-subtree-server}\n *\n * Here is an example for exporting a subtree:\n * [gdbus-example-subtree.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)\n *\n * ## An example for file descriptor passing # {#gdbus-unix-fd-client}\n *\n * Here is an example for passing UNIX file descriptors:\n * [gdbus-unix-fd-client.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)\n *\n * ## An example for exporting a GObject # {#gdbus-export}\n *\n * Here is an example for exporting a #GObject:\n * [gdbus-example-export.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)\n */\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct _GDBusConnectionClass GDBusConnectionClass;\n\n/**\n * GDBusConnectionClass:\n * @closed: Signal class handler for the #GDBusConnection::closed signal.\n *\n * Class structure for #GDBusConnection.\n *\n * Since: 2.26\n */\nstruct _GDBusConnectionClass\n{\n  /*< private >*/\n  GObjectClass parent_class;\n\n  /*< public >*/\n  /* Signals */\n  void (*closed) (GDBusConnection *connection,\n                  gboolean         remote_peer_vanished,\n                  GError          *error);\n};\n\nG_LOCK_DEFINE_STATIC (message_bus_lock);\n\nstatic GWeakRef the_session_bus;\nstatic GWeakRef the_system_bus;\n\n/* Extra pseudo-member of GDBusSendMessageFlags.\n * Set by initable_init() to indicate that despite not being initialized yet,\n * enough of the only-valid-after-init members are set that we can send a\n * message, and we're being called from its thread, so no memory barrier is\n * required before accessing them.\n */\n#define SEND_MESSAGE_FLAGS_INITIALIZING (1u << 31)\n\n/* Same as SEND_MESSAGE_FLAGS_INITIALIZING, but in GDBusCallFlags */\n#define CALL_FLAGS_INITIALIZING (1u << 31)\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GDestroyNotify              callback;\n  gpointer                    user_data;\n  GMainContext               *context;\n} CallDestroyNotifyData;\n\nstatic gboolean\ncall_destroy_notify_data_in_idle (gpointer user_data)\n{\n  CallDestroyNotifyData *data = user_data;\n  data->callback (data->user_data);\n  return FALSE;\n}\n\nstatic void\ncall_destroy_notify_data_free (CallDestroyNotifyData *data)\n{\n  if (data->context != NULL)\n    g_main_context_unref (data->context);\n  g_free (data);\n}\n\n/*\n * call_destroy_notify: <internal>\n * @context: (nullable): A #GMainContext or %NULL.\n * @callback: (nullable): A #GDestroyNotify or %NULL.\n * @user_data: Data to pass to @callback.\n *\n * Schedules @callback to run in @context.\n */\nstatic void\ncall_destroy_notify (GMainContext  *context,\n                     GDestroyNotify callback,\n                     gpointer       user_data)\n{\n  GSource *idle_source;\n  CallDestroyNotifyData *data;\n\n  if (callback == NULL)\n    goto out;\n\n  data = g_new0 (CallDestroyNotifyData, 1);\n  data->callback = callback;\n  data->user_data = user_data;\n  data->context = context;\n  if (data->context != NULL)\n    g_main_context_ref (data->context);\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         call_destroy_notify_data_in_idle,\n                         data,\n                         (GDestroyNotify) call_destroy_notify_data_free);\n  g_source_set_name (idle_source, \"[gio] call_destroy_notify_data_in_idle\");\n  g_source_attach (idle_source, data->context);\n  g_source_unref (idle_source);\n\n out:\n  ;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic gboolean\n_g_strv_has_string (const gchar* const *haystack,\n                    const gchar        *needle)\n{\n  guint n;\n\n  for (n = 0; haystack != NULL && haystack[n] != NULL; n++)\n    {\n      if (g_strcmp0 (haystack[n], needle) == 0)\n        return TRUE;\n    }\n  return FALSE;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n#ifdef G_OS_WIN32\n#define CONNECTION_ENSURE_LOCK(obj) do { ; } while (FALSE)\n#else\n// TODO: for some reason this doesn't work on Windows\n#define CONNECTION_ENSURE_LOCK(obj) do {                                \\\n    if (G_UNLIKELY (g_mutex_trylock(&(obj)->lock)))                     \\\n      {                                                                 \\\n        g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \\\n                             \"CONNECTION_ENSURE_LOCK: GDBusConnection object lock is not locked\"); \\\n      }                                                                 \\\n  } while (FALSE)\n#endif\n\n#define CONNECTION_LOCK(obj) do {                                       \\\n    g_mutex_lock (&(obj)->lock);                                        \\\n  } while (FALSE)\n\n#define CONNECTION_UNLOCK(obj) do {                                     \\\n    g_mutex_unlock (&(obj)->lock);                                      \\\n  } while (FALSE)\n\n/* Flags in connection->atomic_flags */\nenum {\n    FLAG_INITIALIZED = 1 << 0,\n    FLAG_EXIT_ON_CLOSE = 1 << 1,\n    FLAG_CLOSED = 1 << 2\n};\n\n/**\n * GDBusConnection:\n *\n * The #GDBusConnection structure contains only private data and\n * should only be accessed using the provided API.\n *\n * Since: 2.26\n */\nstruct _GDBusConnection\n{\n  /*< private >*/\n  GObject parent_instance;\n\n  /* ------------------------------------------------------------------------ */\n  /* -- General object state ------------------------------------------------ */\n  /* ------------------------------------------------------------------------ */\n\n  /* General-purpose lock for most fields */\n  GMutex lock;\n\n  /* A lock used in the init() method of the GInitable interface - see comments\n   * in initable_init() for why a separate lock is needed.\n   *\n   * If you need both @lock and @init_lock, you must take @init_lock first.\n   */\n  GMutex init_lock;\n\n  /* Set (by loading the contents of /var/lib/dbus/machine-id) the first time\n   * someone calls org.freedesktop.DBus.Peer.GetMachineId(). Protected by @lock.\n   */\n  gchar *machine_id;\n\n  /* The underlying stream used for communication\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GIOStream *stream;\n\n  /* The object used for authentication (if any).\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GDBusAuth *auth;\n\n  /* Last serial used. Protected by @lock. */\n  guint32 last_serial;\n\n  /* The object used to send/receive messages.\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GDBusWorker *worker;\n\n  /* If connected to a message bus, this contains the unique name assigned to\n   * us by the bus (e.g. \":1.42\").\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  gchar *bus_unique_name;\n\n  /* The GUID returned by the other side if we authenticed as a client or\n   * the GUID to use if authenticating as a server.\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  gchar *guid;\n\n  /* FLAG_INITIALIZED is set exactly when initable_init() has finished running.\n   * Inspect @initialization_error to see whether it succeeded or failed.\n   *\n   * FLAG_EXIT_ON_CLOSE is the exit-on-close property.\n   *\n   * FLAG_CLOSED is the closed property. It may be read at any time, but\n   * may only be written while holding @lock.\n   */\n  volatile gint atomic_flags;\n\n  /* If the connection could not be established during initable_init(),\n   * this GError will be set.\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GError *initialization_error;\n\n  /* The result of g_main_context_ref_thread_default() when the object\n   * was created (the GObject _init() function) - this is used for delivery\n   * of the :closed GObject signal.\n   *\n   * Only set in the GObject init function, so no locks are needed.\n   */\n  GMainContext *main_context_at_construction;\n\n  /* Read-only construct properties, no locks needed */\n  gchar *address;\n  GDBusConnectionFlags flags;\n\n  /* Map used for managing method replies, protected by @lock */\n  GHashTable *map_method_serial_to_task;  /* guint32 -> GTask* */\n\n  /* Maps used for managing signal subscription, protected by @lock */\n  GHashTable *map_rule_to_signal_data;                      /* match rule (gchar*)    -> SignalData */\n  GHashTable *map_id_to_signal_data;                        /* id (guint)             -> SignalData */\n  GHashTable *map_sender_unique_name_to_signal_data_array;  /* unique sender (gchar*) -> GPtrArray* of SignalData */\n\n  /* Maps used for managing exported objects and subtrees,\n   * protected by @lock\n   */\n  GHashTable *map_object_path_to_eo;  /* gchar* -> ExportedObject* */\n  GHashTable *map_id_to_ei;           /* guint  -> ExportedInterface* */\n  GHashTable *map_object_path_to_es;  /* gchar* -> ExportedSubtree* */\n  GHashTable *map_id_to_es;           /* guint  -> ExportedSubtree* */\n\n  /* Map used for storing last used serials for each thread, protected by @lock */\n  GHashTable *map_thread_to_last_serial;\n\n  /* Structure used for message filters, protected by @lock */\n  GPtrArray *filters;\n\n  /* Capabilities negotiated during authentication\n   * Read-only after initable_init(), so it may be read without holding a\n   * lock, if you check for initialization first.\n   */\n  GDBusCapabilityFlags capabilities;\n\n  /* Protected by @init_lock */\n  GDBusAuthObserver *authentication_observer;\n\n  /* Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GCredentials *credentials;\n\n  /* set to TRUE when finalizing */\n  gboolean finalizing;\n};\n\ntypedef struct ExportedObject ExportedObject;\nstatic void exported_object_free (ExportedObject *eo);\n\ntypedef struct ExportedSubtree ExportedSubtree;\nstatic void exported_subtree_free (ExportedSubtree *es);\n\nenum\n{\n  CLOSED_SIGNAL,\n  LAST_SIGNAL,\n};\n\nenum\n{\n  PROP_0,\n  PROP_STREAM,\n  PROP_ADDRESS,\n  PROP_FLAGS,\n  PROP_GUID,\n  PROP_UNIQUE_NAME,\n  PROP_CLOSED,\n  PROP_EXIT_ON_CLOSE,\n  PROP_CAPABILITY_FLAGS,\n  PROP_AUTHENTICATION_OBSERVER,\n};\n\nstatic void distribute_signals (GDBusConnection  *connection,\n                                GDBusMessage     *message);\n\nstatic void distribute_method_call (GDBusConnection  *connection,\n                                    GDBusMessage     *message);\n\nstatic gboolean handle_generic_unlocked (GDBusConnection *connection,\n                                         GDBusMessage    *message);\n\n\nstatic void purge_all_signal_subscriptions (GDBusConnection *connection);\nstatic void purge_all_filters (GDBusConnection *connection);\n\nstatic void schedule_method_call (GDBusConnection            *connection,\n                                  GDBusMessage               *message,\n                                  guint                       registration_id,\n                                  guint                       subtree_registration_id,\n                                  const GDBusInterfaceInfo   *interface_info,\n                                  const GDBusMethodInfo      *method_info,\n                                  const GDBusPropertyInfo    *property_info,\n                                  GVariant                   *parameters,\n                                  const GDBusInterfaceVTable *vtable,\n                                  GMainContext               *main_context,\n                                  gpointer                    user_data);\n\n#define _G_ENSURE_LOCK(name) do {                                       \\\n    if (G_UNLIKELY (G_TRYLOCK(name)))                                   \\\n      {                                                                 \\\n        g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \\\n                             \"_G_ENSURE_LOCK: Lock '\" #name \"' is not locked\"); \\\n      }                                                                 \\\n  } while (FALSE)                                                       \\\n\nstatic guint signals[LAST_SIGNAL] = { 0 };\n\nstatic void initable_iface_init       (GInitableIface      *initable_iface);\nstatic void async_initable_iface_init (GAsyncInitableIface *async_initable_iface);\n\nG_DEFINE_TYPE_WITH_CODE (GDBusConnection, g_dbus_connection, G_TYPE_OBJECT,\n                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE, initable_iface_init)\n                         G_IMPLEMENT_INTERFACE (G_TYPE_ASYNC_INITABLE, async_initable_iface_init)\n                         );\n\n/*\n * Check that all members of @connection that can only be accessed after\n * the connection is initialized can safely be accessed. If not,\n * log a critical warning. This function is a memory barrier.\n *\n * Returns: %TRUE if initialized\n */\nstatic gboolean\ncheck_initialized (GDBusConnection *connection)\n{\n  /* The access to @atomic_flags isn't conditional, so that this function\n   * provides a memory barrier for thread-safety even if checks are disabled.\n   * (If you don't want this stricter guarantee, you can call\n   * g_return_if_fail (check_initialized (c)).)\n   *\n   * This isn't strictly necessary now that we've decided use of an\n   * uninitialized GDBusConnection is undefined behaviour, but it seems\n   * better to be as deterministic as is feasible.\n   *\n   * (Anything that could suffer a crash from seeing undefined values\n   * must have a race condition - thread A initializes the connection while\n   * thread B calls a method without initialization, hoping that thread A will\n   * win the race - so its behaviour is undefined anyway.)\n   */\n  gint flags = g_atomic_int_get (&connection->atomic_flags);\n\n  g_return_val_if_fail (flags & FLAG_INITIALIZED, FALSE);\n\n  /* We can safely access this, due to the memory barrier above */\n  g_return_val_if_fail (connection->initialization_error == NULL, FALSE);\n\n  return TRUE;\n}\n\ntypedef enum {\n    MAY_BE_UNINITIALIZED = (1<<1)\n} CheckUnclosedFlags;\n\n/*\n * Check the same thing as check_initialized(), and also that the\n * connection is not closed. If the connection is uninitialized,\n * raise a critical warning (it's programmer error); if it's closed,\n * raise a recoverable GError (it's a runtime error).\n *\n * This function is a memory barrier.\n *\n * Returns: %TRUE if initialized and not closed\n */\nstatic gboolean\ncheck_unclosed (GDBusConnection     *connection,\n                CheckUnclosedFlags   check,\n                GError             **error)\n{\n  /* check_initialized() is effectively inlined, so we don't waste time\n   * doing two memory barriers\n   */\n  gint flags = g_atomic_int_get (&connection->atomic_flags);\n\n  if (!(check & MAY_BE_UNINITIALIZED))\n    {\n      g_return_val_if_fail (flags & FLAG_INITIALIZED, FALSE);\n      g_return_val_if_fail (connection->initialization_error == NULL, FALSE);\n    }\n\n  if (flags & FLAG_CLOSED)\n    {\n      g_set_error_literal (error,\n                           G_IO_ERROR,\n                           G_IO_ERROR_CLOSED,\n                           _(\"The connection is closed\"));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic GHashTable *alive_connections = NULL;\n\nstatic void\ng_dbus_connection_dispose (GObject *object)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (object);\n\n  G_LOCK (message_bus_lock);\n  CONNECTION_LOCK (connection);\n  if (connection->worker != NULL)\n    {\n      _g_dbus_worker_stop (connection->worker);\n      connection->worker = NULL;\n      if (alive_connections != NULL)\n        g_warn_if_fail (g_hash_table_remove (alive_connections, connection));\n    }\n  else\n    {\n      if (alive_connections != NULL)\n        g_warn_if_fail (!g_hash_table_contains (alive_connections, connection));\n    }\n  CONNECTION_UNLOCK (connection);\n  G_UNLOCK (message_bus_lock);\n\n  if (G_OBJECT_CLASS (g_dbus_connection_parent_class)->dispose != NULL)\n    G_OBJECT_CLASS (g_dbus_connection_parent_class)->dispose (object);\n}\n\nstatic void\ng_dbus_connection_finalize (GObject *object)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (object);\n\n  connection->finalizing = TRUE;\n\n  purge_all_signal_subscriptions (connection);\n\n  purge_all_filters (connection);\n  g_ptr_array_unref (connection->filters);\n\n  if (connection->authentication_observer != NULL)\n    g_object_unref (connection->authentication_observer);\n\n  if (connection->auth != NULL)\n    g_object_unref (connection->auth);\n\n  if (connection->credentials)\n    g_object_unref (connection->credentials);\n\n  if (connection->stream != NULL)\n    {\n      g_object_unref (connection->stream);\n      connection->stream = NULL;\n    }\n\n  g_free (connection->address);\n\n  g_free (connection->guid);\n  g_free (connection->bus_unique_name);\n\n  if (connection->initialization_error != NULL)\n    g_error_free (connection->initialization_error);\n\n  g_hash_table_unref (connection->map_method_serial_to_task);\n\n  g_hash_table_unref (connection->map_rule_to_signal_data);\n  g_hash_table_unref (connection->map_id_to_signal_data);\n  g_hash_table_unref (connection->map_sender_unique_name_to_signal_data_array);\n\n  g_hash_table_unref (connection->map_id_to_ei);\n  g_hash_table_unref (connection->map_object_path_to_eo);\n  g_hash_table_unref (connection->map_id_to_es);\n  g_hash_table_unref (connection->map_object_path_to_es);\n\n  g_hash_table_unref (connection->map_thread_to_last_serial);\n\n  g_main_context_unref (connection->main_context_at_construction);\n\n  g_free (connection->machine_id);\n\n  g_mutex_clear (&connection->init_lock);\n  g_mutex_clear (&connection->lock);\n\n  G_OBJECT_CLASS (g_dbus_connection_parent_class)->finalize (object);\n}\n\n/* called in any user thread, with the connection's lock not held */\nstatic void\ng_dbus_connection_get_property (GObject    *object,\n                                guint       prop_id,\n                                GValue     *value,\n                                GParamSpec *pspec)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (object);\n\n  switch (prop_id)\n    {\n    case PROP_STREAM:\n      g_value_set_object (value, g_dbus_connection_get_stream (connection));\n      break;\n\n    case PROP_GUID:\n      g_value_set_string (value, g_dbus_connection_get_guid (connection));\n      break;\n\n    case PROP_UNIQUE_NAME:\n      g_value_set_string (value, g_dbus_connection_get_unique_name (connection));\n      break;\n\n    case PROP_CLOSED:\n      g_value_set_boolean (value, g_dbus_connection_is_closed (connection));\n      break;\n\n    case PROP_EXIT_ON_CLOSE:\n      g_value_set_boolean (value, g_dbus_connection_get_exit_on_close (connection));\n      break;\n\n    case PROP_CAPABILITY_FLAGS:\n      g_value_set_flags (value, g_dbus_connection_get_capabilities (connection));\n      break;\n\n    case PROP_FLAGS:\n      g_value_set_flags (value, g_dbus_connection_get_flags (connection));\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\n/* called in any user thread, with the connection's lock not held */\nstatic void\ng_dbus_connection_set_property (GObject      *object,\n                                guint         prop_id,\n                                const GValue *value,\n                                GParamSpec   *pspec)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (object);\n\n  switch (prop_id)\n    {\n    case PROP_STREAM:\n      connection->stream = g_value_dup_object (value);\n      break;\n\n    case PROP_GUID:\n      connection->guid = g_value_dup_string (value);\n      break;\n\n    case PROP_ADDRESS:\n      connection->address = g_value_dup_string (value);\n      break;\n\n    case PROP_FLAGS:\n      connection->flags = g_value_get_flags (value);\n      break;\n\n    case PROP_EXIT_ON_CLOSE:\n      g_dbus_connection_set_exit_on_close (connection, g_value_get_boolean (value));\n      break;\n\n    case PROP_AUTHENTICATION_OBSERVER:\n      connection->authentication_observer = g_value_dup_object (value);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\n/* Base-class implementation of GDBusConnection::closed.\n *\n * Called in a user thread, by the main context that was thread-default when\n * the object was constructed.\n */\nstatic void\ng_dbus_connection_real_closed (GDBusConnection *connection,\n                               gboolean         remote_peer_vanished,\n                               GError          *error)\n{\n  gint flags = g_atomic_int_get (&connection->atomic_flags);\n\n  /* Because atomic int access is a memory barrier, we can safely read\n   * initialization_error without a lock, as long as we do it afterwards.\n   */\n  if (remote_peer_vanished &&\n      (flags & FLAG_EXIT_ON_CLOSE) != 0 &&\n      (flags & FLAG_INITIALIZED) != 0 &&\n      connection->initialization_error == NULL)\n    {\n      raise (SIGTERM);\n    }\n}\n\nstatic void\ng_dbus_connection_class_init (GDBusConnectionClass *klass)\n{\n  GObjectClass *gobject_class;\n\n  gobject_class = G_OBJECT_CLASS (klass);\n\n  gobject_class->finalize     = g_dbus_connection_finalize;\n  gobject_class->dispose      = g_dbus_connection_dispose;\n  gobject_class->set_property = g_dbus_connection_set_property;\n  gobject_class->get_property = g_dbus_connection_get_property;\n\n  klass->closed = g_dbus_connection_real_closed;\n\n  /**\n   * GDBusConnection:stream:\n   *\n   * The underlying #GIOStream used for I/O.\n   *\n   * If this is passed on construction and is a #GSocketConnection,\n   * then the corresponding #GSocket will be put into non-blocking mode.\n   *\n   * While the #GDBusConnection is active, it will interact with this\n   * stream from a worker thread, so it is not safe to interact with\n   * the stream directly.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_STREAM,\n                                   g_param_spec_object (\"stream\",\n                                                        P_(\"IO Stream\"),\n                                                        P_(\"The underlying streams used for I/O\"),\n                                                        G_TYPE_IO_STREAM,\n                                                        G_PARAM_READABLE |\n                                                        G_PARAM_WRITABLE |\n                                                        G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:address:\n   *\n   * A D-Bus address specifying potential endpoints that can be used\n   * when establishing the connection.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_ADDRESS,\n                                   g_param_spec_string (\"address\",\n                                                        P_(\"Address\"),\n                                                        P_(\"D-Bus address specifying potential socket endpoints\"),\n                                                        NULL,\n                                                        G_PARAM_WRITABLE |\n                                                        G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:flags:\n   *\n   * Flags from the #GDBusConnectionFlags enumeration.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_FLAGS,\n                                   g_param_spec_flags (\"flags\",\n                                                       P_(\"Flags\"),\n                                                       P_(\"Flags\"),\n                                                       G_TYPE_DBUS_CONNECTION_FLAGS,\n                                                       G_DBUS_CONNECTION_FLAGS_NONE,\n                                                       G_PARAM_READABLE |\n                                                       G_PARAM_WRITABLE |\n                                                       G_PARAM_CONSTRUCT_ONLY |\n                                                       G_PARAM_STATIC_NAME |\n                                                       G_PARAM_STATIC_BLURB |\n                                                       G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:guid:\n   *\n   * The GUID of the peer performing the role of server when\n   * authenticating.\n   *\n   * If you are constructing a #GDBusConnection and pass\n   * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the\n   * #GDBusConnection:flags property then you MUST also set this\n   * property to a valid guid.\n   *\n   * If you are constructing a #GDBusConnection and pass\n   * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the\n   * #GDBusConnection:flags property you will be able to read the GUID\n   * of the other peer here after the connection has been successfully\n   * initialized.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_GUID,\n                                   g_param_spec_string (\"guid\",\n                                                        P_(\"GUID\"),\n                                                        P_(\"GUID of the server peer\"),\n                                                        NULL,\n                                                        G_PARAM_READABLE |\n                                                        G_PARAM_WRITABLE |\n                                                        G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:unique-name:\n   *\n   * The unique name as assigned by the message bus or %NULL if the\n   * connection is not open or not a message bus connection.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_UNIQUE_NAME,\n                                   g_param_spec_string (\"unique-name\",\n                                                        P_(\"unique-name\"),\n                                                        P_(\"Unique name of bus connection\"),\n                                                        NULL,\n                                                        G_PARAM_READABLE |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:closed:\n   *\n   * A boolean specifying whether the connection has been closed.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_CLOSED,\n                                   g_param_spec_boolean (\"closed\",\n                                                         P_(\"Closed\"),\n                                                         P_(\"Whether the connection is closed\"),\n                                                         FALSE,\n                                                         G_PARAM_READABLE |\n                                                         G_PARAM_STATIC_NAME |\n                                                         G_PARAM_STATIC_BLURB |\n                                                         G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:exit-on-close:\n   *\n   * A boolean specifying whether the process will be terminated (by\n   * calling `raise(SIGTERM)`) if the connection is closed by the\n   * remote peer.\n   *\n   * Note that #GDBusConnection objects returned by g_bus_get_finish()\n   * and g_bus_get_sync() will (usually) have this property set to %TRUE.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_EXIT_ON_CLOSE,\n                                   g_param_spec_boolean (\"exit-on-close\",\n                                                         P_(\"Exit on close\"),\n                                                         P_(\"Whether the process is terminated when the connection is closed\"),\n                                                         FALSE,\n                                                         G_PARAM_READABLE |\n                                                         G_PARAM_WRITABLE |\n                                                         G_PARAM_STATIC_NAME |\n                                                         G_PARAM_STATIC_BLURB |\n                                                         G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:capabilities:\n   *\n   * Flags from the #GDBusCapabilityFlags enumeration\n   * representing connection features negotiated with the other peer.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_CAPABILITY_FLAGS,\n                                   g_param_spec_flags (\"capabilities\",\n                                                       P_(\"Capabilities\"),\n                                                       P_(\"Capabilities\"),\n                                                       G_TYPE_DBUS_CAPABILITY_FLAGS,\n                                                       G_DBUS_CAPABILITY_FLAGS_NONE,\n                                                       G_PARAM_READABLE |\n                                                       G_PARAM_STATIC_NAME |\n                                                       G_PARAM_STATIC_BLURB |\n                                                       G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:authentication-observer:\n   *\n   * A #GDBusAuthObserver object to assist in the authentication process or %NULL.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_AUTHENTICATION_OBSERVER,\n                                   g_param_spec_object (\"authentication-observer\",\n                                                        P_(\"Authentication Observer\"),\n                                                        P_(\"Object used to assist in the authentication process\"),\n                                                        G_TYPE_DBUS_AUTH_OBSERVER,\n                                                        G_PARAM_WRITABLE |\n                                                        G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection::closed:\n   * @connection: the #GDBusConnection emitting the signal\n   * @remote_peer_vanished: %TRUE if @connection is closed because the\n   *     remote peer closed its end of the connection\n   * @error: (nullable): a #GError with more details about the event or %NULL\n   *\n   * Emitted when the connection is closed.\n   *\n   * The cause of this event can be\n   *\n   * - If g_dbus_connection_close() is called. In this case\n   *   @remote_peer_vanished is set to %FALSE and @error is %NULL.\n   *\n   * - If the remote peer closes the connection. In this case\n   *   @remote_peer_vanished is set to %TRUE and @error is set.\n   *\n   * - If the remote peer sends invalid or malformed data. In this\n   *   case @remote_peer_vanished is set to %FALSE and @error is set.\n   *\n   * Upon receiving this signal, you should give up your reference to\n   * @connection. You are guaranteed that this signal is emitted only\n   * once.\n   *\n   * Since: 2.26\n   */\n  signals[CLOSED_SIGNAL] = g_signal_new (I_(\"closed\"),\n                                         G_TYPE_DBUS_CONNECTION,\n                                         G_SIGNAL_RUN_LAST,\n                                         G_STRUCT_OFFSET (GDBusConnectionClass, closed),\n                                         NULL,\n                                         NULL,\n                                         NULL,\n                                         G_TYPE_NONE,\n                                         2,\n                                         G_TYPE_BOOLEAN,\n                                         G_TYPE_ERROR);\n}\n\nstatic void\ng_dbus_connection_init (GDBusConnection *connection)\n{\n  g_mutex_init (&connection->lock);\n  g_mutex_init (&connection->init_lock);\n\n  connection->map_method_serial_to_task = g_hash_table_new (g_direct_hash, g_direct_equal);\n\n  connection->map_rule_to_signal_data = g_hash_table_new (g_str_hash,\n                                                          g_str_equal);\n  connection->map_id_to_signal_data = g_hash_table_new (g_direct_hash,\n                                                        g_direct_equal);\n  connection->map_sender_unique_name_to_signal_data_array = g_hash_table_new_full (g_str_hash,\n                                                                                   g_str_equal,\n                                                                                   g_free,\n                                                                                   (GDestroyNotify) g_ptr_array_unref);\n\n  connection->map_object_path_to_eo = g_hash_table_new_full (g_str_hash,\n                                                             g_str_equal,\n                                                             NULL,\n                                                             (GDestroyNotify) exported_object_free);\n\n  connection->map_id_to_ei = g_hash_table_new (g_direct_hash,\n                                               g_direct_equal);\n\n  connection->map_object_path_to_es = g_hash_table_new_full (g_str_hash,\n                                                             g_str_equal,\n                                                             NULL,\n                                                             (GDestroyNotify) exported_subtree_free);\n\n  connection->map_id_to_es = g_hash_table_new (g_direct_hash,\n                                               g_direct_equal);\n\n  connection->map_thread_to_last_serial = g_hash_table_new (g_direct_hash,\n                                                            g_direct_equal);\n\n  connection->main_context_at_construction = g_main_context_ref_thread_default ();\n\n  connection->filters = g_ptr_array_new ();\n}\n\n/**\n * g_dbus_connection_get_stream:\n * @connection: a #GDBusConnection\n *\n * Gets the underlying stream used for IO.\n *\n * While the #GDBusConnection is active, it will interact with this\n * stream from a worker thread, so it is not safe to interact with\n * the stream directly.\n *\n * Returns: (transfer none): the stream used for IO\n *\n * Since: 2.26\n */\nGIOStream *\ng_dbus_connection_get_stream (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return NULL;\n\n  return connection->stream;\n}\n\n/**\n * g_dbus_connection_start_message_processing:\n * @connection: a #GDBusConnection\n *\n * If @connection was created with\n * %G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method\n * starts processing messages. Does nothing on if @connection wasn't\n * created with this flag or if the method has already been called.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_start_message_processing (GDBusConnection *connection)\n{\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return;\n\n  g_assert (connection->worker != NULL);\n  _g_dbus_worker_unfreeze (connection->worker);\n}\n\n/**\n * g_dbus_connection_is_closed:\n * @connection: a #GDBusConnection\n *\n * Gets whether @connection is closed.\n *\n * Returns: %TRUE if the connection is closed, %FALSE otherwise\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_is_closed (GDBusConnection *connection)\n{\n  gint flags;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n\n  flags = g_atomic_int_get (&connection->atomic_flags);\n\n  return (flags & FLAG_CLOSED) ? TRUE : FALSE;\n}\n\n/**\n * g_dbus_connection_get_capabilities:\n * @connection: a #GDBusConnection\n *\n * Gets the capabilities negotiated with the remote peer\n *\n * Returns: zero or more flags from the #GDBusCapabilityFlags enumeration\n *\n * Since: 2.26\n */\nGDBusCapabilityFlags\ng_dbus_connection_get_capabilities (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), G_DBUS_CAPABILITY_FLAGS_NONE);\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return G_DBUS_CAPABILITY_FLAGS_NONE;\n\n  return connection->capabilities;\n}\n\n/**\n * g_dbus_connection_get_flags:\n * @connection: a #GDBusConnection\n *\n * Gets the flags used to construct this connection\n *\n * Returns: zero or more flags from the #GDBusConnectionFlags enumeration\n *\n * Since: 2.60\n */\nGDBusConnectionFlags\ng_dbus_connection_get_flags (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), G_DBUS_CONNECTION_FLAGS_NONE);\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return G_DBUS_CONNECTION_FLAGS_NONE;\n\n  return connection->flags;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called in a temporary thread without holding locks. */\nstatic void\nflush_in_thread_func (GTask         *task,\n                      gpointer       source_object,\n                      gpointer       task_data,\n                      GCancellable  *cancellable)\n{\n  GError *error = NULL;\n\n  if (g_dbus_connection_flush_sync (source_object,\n                                    cancellable,\n                                    &error))\n    g_task_return_boolean (task, TRUE);\n  else\n    g_task_return_error (task, error);\n}\n\n/**\n * g_dbus_connection_flush:\n * @connection: a #GDBusConnection\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the\n *     request is satisfied or %NULL if you don't care about the result\n * @user_data: The data to pass to @callback\n *\n * Asynchronously flushes @connection, that is, writes all queued\n * outgoing message to the transport and then flushes the transport\n * (using g_output_stream_flush_async()). This is useful in programs\n * that wants to emit a D-Bus signal and then exit immediately. Without\n * flushing the connection, there is no guaranteed that the message has\n * been sent to the networking buffers in the OS kernel.\n *\n * This is an asynchronous method. When the operation is finished,\n * @callback will be invoked in the\n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from. You can\n * then call g_dbus_connection_flush_finish() to get the result of the\n * operation. See g_dbus_connection_flush_sync() for the synchronous\n * version.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_flush (GDBusConnection     *connection,\n                         GCancellable        *cancellable,\n                         GAsyncReadyCallback  callback,\n                         gpointer             user_data)\n{\n  GTask *task;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n\n  task = g_task_new (connection, cancellable, callback, user_data);\n  g_task_set_source_tag (task, g_dbus_connection_flush);\n  g_task_run_in_thread (task, flush_in_thread_func);\n  g_object_unref (task);\n}\n\n/**\n * g_dbus_connection_flush_finish:\n * @connection: a #GDBusConnection\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed\n *     to g_dbus_connection_flush()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_flush().\n *\n * Returns: %TRUE if the operation succeeded, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_flush_finish (GDBusConnection  *connection,\n                                GAsyncResult     *res,\n                                GError          **error)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (g_task_is_valid (res, connection), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  return g_task_propagate_boolean (G_TASK (res), error);\n}\n\n/**\n * g_dbus_connection_flush_sync:\n * @connection: a #GDBusConnection\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously flushes @connection. The calling thread is blocked\n * until this is done. See g_dbus_connection_flush() for the\n * asynchronous version of this method and more details about what it\n * does.\n *\n * Returns: %TRUE if the operation succeeded, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_flush_sync (GDBusConnection  *connection,\n                              GCancellable     *cancellable,\n                              GError          **error)\n{\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  ret = FALSE;\n\n  /* This is only a best-effort attempt to see whether the connection is\n   * closed, so it doesn't need the lock. If the connection closes just\n   * after this check, but before scheduling the flush operation, the\n   * result will be more or less the same as if the connection closed while\n   * the flush operation was pending - it'll fail with either CLOSED or\n   * CANCELLED.\n   */\n  if (!check_unclosed (connection, 0, error))\n    goto out;\n\n  g_assert (connection->worker != NULL);\n\n  ret = _g_dbus_worker_flush_sync (connection->worker,\n                                   cancellable,\n                                   error);\n\n out:\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GDBusConnection *connection;\n  GError *error;\n  gboolean remote_peer_vanished;\n} EmitClosedData;\n\nstatic void\nemit_closed_data_free (EmitClosedData *data)\n{\n  g_object_unref (data->connection);\n  if (data->error != NULL)\n    g_error_free (data->error);\n  g_free (data);\n}\n\n/* Called in a user thread that has acquired the main context that was\n * thread-default when the object was constructed\n */\nstatic gboolean\nemit_closed_in_idle (gpointer user_data)\n{\n  EmitClosedData *data = user_data;\n  gboolean result;\n\n  g_object_notify (G_OBJECT (data->connection), \"closed\");\n  g_signal_emit (data->connection,\n                 signals[CLOSED_SIGNAL],\n                 0,\n                 data->remote_peer_vanished,\n                 data->error,\n                 &result);\n  return FALSE;\n}\n\n/* Can be called from any thread, must hold lock.\n * FLAG_CLOSED must already have been set.\n */\nstatic void\nschedule_closed_unlocked (GDBusConnection *connection,\n                          gboolean         remote_peer_vanished,\n                          GError          *error)\n{\n  GSource *idle_source;\n  EmitClosedData *data;\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  data = g_new0 (EmitClosedData, 1);\n  data->connection = g_object_ref (connection);\n  data->remote_peer_vanished = remote_peer_vanished;\n  data->error = error != NULL ? g_error_copy (error) : NULL;\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         emit_closed_in_idle,\n                         data,\n                         (GDestroyNotify) emit_closed_data_free);\n  g_source_set_name (idle_source, \"[gio] emit_closed_in_idle\");\n  g_source_attach (idle_source, connection->main_context_at_construction);\n  g_source_unref (idle_source);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_close:\n * @connection: a #GDBusConnection\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the request is\n *     satisfied or %NULL if you don't care about the result\n * @user_data: The data to pass to @callback\n *\n * Closes @connection. Note that this never causes the process to\n * exit (this might only happen if the other end of a shared message\n * bus connection disconnects, see #GDBusConnection:exit-on-close).\n *\n * Once the connection is closed, operations such as sending a message\n * will return with the error %G_IO_ERROR_CLOSED. Closing a connection\n * will not automatically flush the connection so queued messages may\n * be lost. Use g_dbus_connection_flush() if you need such guarantees.\n *\n * If @connection is already closed, this method fails with\n * %G_IO_ERROR_CLOSED.\n *\n * When @connection has been closed, the #GDBusConnection::closed\n * signal is emitted in the\n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread that @connection was constructed in.\n *\n * This is an asynchronous method. When the operation is finished,\n * @callback will be invoked in the \n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from. You can\n * then call g_dbus_connection_close_finish() to get the result of the\n * operation. See g_dbus_connection_close_sync() for the synchronous\n * version.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_close (GDBusConnection     *connection,\n                         GCancellable        *cancellable,\n                         GAsyncReadyCallback  callback,\n                         gpointer             user_data)\n{\n  GTask *task;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return;\n\n  g_assert (connection->worker != NULL);\n\n  task = g_task_new (connection, cancellable, callback, user_data);\n  g_task_set_source_tag (task, g_dbus_connection_close);\n  _g_dbus_worker_close (connection->worker, task);\n  g_object_unref (task);\n}\n\n/**\n * g_dbus_connection_close_finish:\n * @connection: a #GDBusConnection\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed\n *     to g_dbus_connection_close()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_close().\n *\n * Returns: %TRUE if the operation succeeded, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_close_finish (GDBusConnection  *connection,\n                                GAsyncResult     *res,\n                                GError          **error)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (g_task_is_valid (res, connection), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  return g_task_propagate_boolean (G_TASK (res), error);\n}\n\ntypedef struct {\n    GMainLoop *loop;\n    GAsyncResult *result;\n} SyncCloseData;\n\n/* Can be called by any thread, without the connection lock */\nstatic void\nsync_close_cb (GObject *source_object,\n               GAsyncResult *res,\n               gpointer user_data)\n{\n  SyncCloseData *data = user_data;\n\n  data->result = g_object_ref (res);\n  g_main_loop_quit (data->loop);\n}\n\n/**\n * g_dbus_connection_close_sync:\n * @connection: a #GDBusConnection\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously closes @connection. The calling thread is blocked\n * until this is done. See g_dbus_connection_close() for the\n * asynchronous version of this method and more details about what it\n * does.\n *\n * Returns: %TRUE if the operation succeeded, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_close_sync (GDBusConnection  *connection,\n                              GCancellable     *cancellable,\n                              GError          **error)\n{\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  ret = FALSE;\n\n  if (check_unclosed (connection, 0, error))\n    {\n      GMainContext *context;\n      SyncCloseData data;\n\n      context = g_main_context_new ();\n      g_main_context_push_thread_default (context);\n      data.loop = g_main_loop_new (context, TRUE);\n      data.result = NULL;\n\n      g_dbus_connection_close (connection, cancellable, sync_close_cb, &data);\n      g_main_loop_run (data.loop);\n      ret = g_dbus_connection_close_finish (connection, data.result, error);\n\n      g_object_unref (data.result);\n      g_main_loop_unref (data.loop);\n      g_main_context_pop_thread_default (context);\n      g_main_context_unref (context);\n    }\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_get_last_serial:\n * @connection: a #GDBusConnection\n *\n * Retrieves the last serial number assigned to a #GDBusMessage on\n * the current thread. This includes messages sent via both low-level\n * API such as g_dbus_connection_send_message() as well as\n * high-level API such as g_dbus_connection_emit_signal(),\n * g_dbus_connection_call() or g_dbus_proxy_call().\n *\n * Returns: the last used serial or zero when no message has been sent\n *     within the current thread\n *\n * Since: 2.34\n */\nguint32\ng_dbus_connection_get_last_serial (GDBusConnection *connection)\n{\n  guint32 ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n\n  CONNECTION_LOCK (connection);\n  ret = GPOINTER_TO_UINT (g_hash_table_lookup (connection->map_thread_to_last_serial,\n                                               g_thread_self ()));\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Can be called by any thread, with the connection lock held */\nstatic gboolean\ng_dbus_connection_send_message_unlocked (GDBusConnection   *connection,\n                                         GDBusMessage      *message,\n                                         GDBusSendMessageFlags flags,\n                                         volatile guint32  *out_serial,\n                                         GError           **error)\n{\n  guchar *blob;\n  gsize blob_size;\n  guint32 serial_to_use;\n  gboolean ret;\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (G_IS_DBUS_MESSAGE (message), FALSE);\n\n  /* TODO: check all necessary headers are present */\n\n  ret = FALSE;\n  blob = NULL;\n\n  if (out_serial != NULL)\n    *out_serial = 0;\n\n  /* If we're in initable_init(), don't check for being initialized, to avoid\n   * chicken-and-egg problems. initable_init() is responsible for setting up\n   * our prerequisites (mainly connection->worker), and only calling us\n   * from its own thread (so no memory barrier is needed).\n   */\n  if (!check_unclosed (connection,\n                       (flags & SEND_MESSAGE_FLAGS_INITIALIZING) ? MAY_BE_UNINITIALIZED : 0,\n                       error))\n    goto out;\n\n  blob = g_dbus_message_to_blob (message,\n                                 &blob_size,\n                                 connection->capabilities,\n                                 error);\n  if (blob == NULL)\n    goto out;\n\n  if (flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL)\n    serial_to_use = g_dbus_message_get_serial (message);\n  else\n    serial_to_use = ++connection->last_serial; /* TODO: handle overflow */\n\n  switch (blob[0])\n    {\n    case 'l':\n      ((guint32 *) blob)[2] = GUINT32_TO_LE (serial_to_use);\n      break;\n    case 'B':\n      ((guint32 *) blob)[2] = GUINT32_TO_BE (serial_to_use);\n      break;\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n#if 0\n  g_printerr (\"Writing message of %\" G_GSIZE_FORMAT \" bytes (serial %d) on %p:\\n\",\n              blob_size, serial_to_use, connection);\n  g_printerr (\"----\\n\");\n  hexdump (blob, blob_size);\n  g_printerr (\"----\\n\");\n#endif\n\n  /* TODO: use connection->auth to encode the blob */\n\n  if (out_serial != NULL)\n    *out_serial = serial_to_use;\n\n  /* store used serial for the current thread */\n  /* TODO: watch the thread disposal and remove associated record\n   *       from hashtable\n   *  - see https://bugzilla.gnome.org/show_bug.cgi?id=676825#c7\n   */\n  g_hash_table_replace (connection->map_thread_to_last_serial,\n                        g_thread_self (),\n                        GUINT_TO_POINTER (serial_to_use));\n\n  if (!(flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL))\n    g_dbus_message_set_serial (message, serial_to_use);\n\n  g_dbus_message_lock (message);\n  _g_dbus_worker_send_message (connection->worker,\n                               message,\n                               (gchar*) blob,\n                               blob_size);\n  blob = NULL; /* since _g_dbus_worker_send_message() steals the blob */\n\n  ret = TRUE;\n\n out:\n  g_free (blob);\n\n  return ret;\n}\n\n/**\n * g_dbus_connection_send_message:\n * @connection: a #GDBusConnection\n * @message: a #GDBusMessage\n * @flags: flags affecting how the message is sent\n * @out_serial: (out) (optional): return location for serial number assigned\n *     to @message when sending it or %NULL\n * @error: Return location for error or %NULL\n *\n * Asynchronously sends @message to the peer represented by @connection.\n *\n * Unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number\n * will be assigned by @connection and set on @message via\n * g_dbus_message_set_serial(). If @out_serial is not %NULL, then the\n * serial number used will be written to this location prior to\n * submitting the message to the underlying transport.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @message is not well-formed,\n * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]\n * for an example of how to use this low-level API to send and receive\n * UNIX file descriptors.\n *\n * Note that @message must be unlocked, unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.\n *\n * Returns: %TRUE if the message was well-formed and queued for\n *     transmission, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_send_message (GDBusConnection        *connection,\n                                GDBusMessage           *message,\n                                GDBusSendMessageFlags   flags,\n                                volatile guint32       *out_serial,\n                                GError                **error)\n{\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (G_IS_DBUS_MESSAGE (message), FALSE);\n  g_return_val_if_fail ((flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL) || !g_dbus_message_get_locked (message), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  CONNECTION_LOCK (connection);\n  ret = g_dbus_connection_send_message_unlocked (connection, message, flags, out_serial, error);\n  CONNECTION_UNLOCK (connection);\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  guint32 serial;\n\n  gulong cancellable_handler_id;\n\n  GSource *timeout_source;\n\n  gboolean delivered;\n} SendMessageData;\n\n/* Can be called from any thread with or without lock held */\nstatic void\nsend_message_data_free (SendMessageData *data)\n{\n  g_assert (data->timeout_source == NULL);\n  g_assert (data->cancellable_handler_id == 0);\n\n  g_slice_free (SendMessageData, data);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* can be called from any thread with lock held; @task is (transfer full) */\nstatic void\nsend_message_with_reply_cleanup (GTask *task, gboolean remove)\n{\n  GDBusConnection *connection = g_task_get_source_object (task);\n  SendMessageData *data = g_task_get_task_data (task);\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  g_assert (!data->delivered);\n\n  data->delivered = TRUE;\n\n  if (data->timeout_source != NULL)\n    {\n      g_source_destroy (data->timeout_source);\n      data->timeout_source = NULL;\n    }\n  if (data->cancellable_handler_id > 0)\n    {\n      g_cancellable_disconnect (g_task_get_cancellable (task), data->cancellable_handler_id);\n      data->cancellable_handler_id = 0;\n    }\n\n  if (remove)\n    {\n      gboolean removed = g_hash_table_remove (connection->map_method_serial_to_task,\n                                              GUINT_TO_POINTER (data->serial));\n      g_warn_if_fail (removed);\n    }\n\n  g_object_unref (task);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called from GDBus worker thread with lock held; @task is (transfer full). */\nstatic void\nsend_message_data_deliver_reply_unlocked (GTask           *task,\n                                          GDBusMessage    *reply)\n{\n  SendMessageData *data = g_task_get_task_data (task);\n\n  if (data->delivered)\n    goto out;\n\n  g_task_return_pointer (task, g_object_ref (reply), g_object_unref);\n\n  send_message_with_reply_cleanup (task, TRUE);\n\n out:\n  ;\n}\n\n/* Called from a user thread, lock is not held */\nstatic void\nsend_message_data_deliver_error (GTask      *task,\n                                 GQuark      domain,\n                                 gint        code,\n                                 const char *message)\n{\n  GDBusConnection *connection = g_task_get_source_object (task);\n  SendMessageData *data = g_task_get_task_data (task);\n\n  CONNECTION_LOCK (connection);\n  if (data->delivered)\n    {\n      CONNECTION_UNLOCK (connection);\n      return;\n    }\n\n  g_object_ref (task);\n  send_message_with_reply_cleanup (task, TRUE);\n  CONNECTION_UNLOCK (connection);\n\n  g_task_return_new_error (task, domain, code, \"%s\", message);\n  g_object_unref (task);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called from a user thread, lock is not held; @task is (transfer full) */\nstatic gboolean\nsend_message_with_reply_cancelled_idle_cb (gpointer user_data)\n{\n  GTask *task = user_data;\n\n  send_message_data_deliver_error (task, G_IO_ERROR, G_IO_ERROR_CANCELLED,\n                                   _(\"Operation was cancelled\"));\n  return FALSE;\n}\n\n/* Can be called from any thread with or without lock held */\nstatic void\nsend_message_with_reply_cancelled_cb (GCancellable *cancellable,\n                                      gpointer      user_data)\n{\n  GTask *task = user_data;\n  GSource *idle_source;\n\n  /* postpone cancellation to idle handler since we may be called directly\n   * via g_cancellable_connect() (e.g. holding lock)\n   */\n  idle_source = g_idle_source_new ();\n  g_source_set_name (idle_source, \"[gio] send_message_with_reply_cancelled_idle_cb\");\n  g_task_attach_source (task, idle_source, send_message_with_reply_cancelled_idle_cb);\n  g_source_unref (idle_source);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called from a user thread, lock is not held; @task is (transfer full) */\nstatic gboolean\nsend_message_with_reply_timeout_cb (gpointer user_data)\n{\n  GTask *task = user_data;\n\n  send_message_data_deliver_error (task, G_IO_ERROR, G_IO_ERROR_TIMED_OUT,\n                                   _(\"Timeout was reached\"));\n  return FALSE;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called from a user thread, connection's lock is held */\nstatic void\ng_dbus_connection_send_message_with_reply_unlocked (GDBusConnection     *connection,\n                                                    GDBusMessage        *message,\n                                                    GDBusSendMessageFlags flags,\n                                                    gint                 timeout_msec,\n                                                    volatile guint32    *out_serial,\n                                                    GCancellable        *cancellable,\n                                                    GAsyncReadyCallback  callback,\n                                                    gpointer             user_data)\n{\n  GTask *task;\n  SendMessageData *data;\n  GError *error = NULL;\n  volatile guint32 serial;\n\n  if (out_serial == NULL)\n    out_serial = &serial;\n\n  if (timeout_msec == -1)\n    timeout_msec = 25 * 1000;\n\n  data = g_slice_new0 (SendMessageData);\n  task = g_task_new (connection, cancellable, callback, user_data);\n  g_task_set_source_tag (task,\n                         g_dbus_connection_send_message_with_reply_unlocked);\n  g_task_set_task_data (task, data, (GDestroyNotify) send_message_data_free);\n\n  if (g_task_return_error_if_cancelled (task))\n    {\n      g_object_unref (task);\n      return;\n    }\n\n  if (!g_dbus_connection_send_message_unlocked (connection, message, flags, out_serial, &error))\n    {\n      g_task_return_error (task, error);\n      g_object_unref (task);\n      return;\n    }\n  data->serial = *out_serial;\n\n  if (cancellable != NULL)\n    {\n      data->cancellable_handler_id = g_cancellable_connect (cancellable,\n                                                            G_CALLBACK (send_message_with_reply_cancelled_cb),\n                                                            g_object_ref (task),\n                                                            g_object_unref);\n    }\n\n  if (timeout_msec != G_MAXINT)\n    {\n      data->timeout_source = g_timeout_source_new (timeout_msec);\n      g_task_attach_source (task, data->timeout_source,\n                            (GSourceFunc) send_message_with_reply_timeout_cb);\n      g_source_unref (data->timeout_source);\n    }\n\n  g_hash_table_insert (connection->map_method_serial_to_task,\n                       GUINT_TO_POINTER (*out_serial),\n                       g_steal_pointer (&task));\n}\n\n/**\n * g_dbus_connection_send_message_with_reply:\n * @connection: a #GDBusConnection\n * @message: a #GDBusMessage\n * @flags: flags affecting how the message is sent\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @out_serial: (out) (optional): return location for serial number assigned\n *     to @message when sending it or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the request\n *     is satisfied or %NULL if you don't care about the result\n * @user_data: The data to pass to @callback\n *\n * Asynchronously sends @message to the peer represented by @connection.\n *\n * Unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number\n * will be assigned by @connection and set on @message via\n * g_dbus_message_set_serial(). If @out_serial is not %NULL, then the\n * serial number used will be written to this location prior to\n * submitting the message to the underlying transport.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will\n * fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,\n * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * This is an asynchronous method. When the operation is finished, @callback\n * will be invoked in the \n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from. You can then call\n * g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.\n * See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.\n *\n * Note that @message must be unlocked, unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.\n *\n * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]\n * for an example of how to use this low-level API to send and receive\n * UNIX file descriptors.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_send_message_with_reply (GDBusConnection       *connection,\n                                           GDBusMessage          *message,\n                                           GDBusSendMessageFlags  flags,\n                                           gint                   timeout_msec,\n                                           volatile guint32      *out_serial,\n                                           GCancellable          *cancellable,\n                                           GAsyncReadyCallback    callback,\n                                           gpointer               user_data)\n{\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n  g_return_if_fail (G_IS_DBUS_MESSAGE (message));\n  g_return_if_fail ((flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL) || !g_dbus_message_get_locked (message));\n  g_return_if_fail (timeout_msec >= 0 || timeout_msec == -1);\n\n  CONNECTION_LOCK (connection);\n  g_dbus_connection_send_message_with_reply_unlocked (connection,\n                                                      message,\n                                                      flags,\n                                                      timeout_msec,\n                                                      out_serial,\n                                                      cancellable,\n                                                      callback,\n                                                      user_data);\n  CONNECTION_UNLOCK (connection);\n}\n\n/**\n * g_dbus_connection_send_message_with_reply_finish:\n * @connection: a #GDBusConnection\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n *     g_dbus_connection_send_message_with_reply()\n * @error: teturn location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_send_message_with_reply().\n *\n * Note that @error is only set if a local in-process error\n * occurred. That is to say that the returned #GDBusMessage object may\n * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use\n * g_dbus_message_to_gerror() to transcode this to a #GError.\n *\n * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]\n * for an example of how to use this low-level API to send and receive\n * UNIX file descriptors.\n *\n * Returns: (transfer full): a locked #GDBusMessage or %NULL if @error is set\n *\n * Since: 2.26\n */\nGDBusMessage *\ng_dbus_connection_send_message_with_reply_finish (GDBusConnection  *connection,\n                                                  GAsyncResult     *res,\n                                                  GError          **error)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  g_return_val_if_fail (g_task_is_valid (res, connection), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  return g_task_propagate_pointer (G_TASK (res), error);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GAsyncResult *res;\n  GMainContext *context;\n  GMainLoop *loop;\n} SendMessageSyncData;\n\n/* Called from a user thread, lock is not held */\nstatic void\nsend_message_with_reply_sync_cb (GDBusConnection *connection,\n                                 GAsyncResult    *res,\n                                 gpointer         user_data)\n{\n  SendMessageSyncData *data = user_data;\n  data->res = g_object_ref (res);\n  g_main_loop_quit (data->loop);\n}\n\n/**\n * g_dbus_connection_send_message_with_reply_sync:\n * @connection: a #GDBusConnection\n * @message: a #GDBusMessage\n * @flags: flags affecting how the message is sent.\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @out_serial: (out) (optional): return location for serial number\n *     assigned to @message when sending it or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously sends @message to the peer represented by @connection\n * and blocks the calling thread until a reply is received or the\n * timeout is reached. See g_dbus_connection_send_message_with_reply()\n * for the asynchronous version of this method.\n *\n * Unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number\n * will be assigned by @connection and set on @message via\n * g_dbus_message_set_serial(). If @out_serial is not %NULL, then the\n * serial number used will be written to this location prior to\n * submitting the message to the underlying transport.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will\n * fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,\n * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * Note that @error is only set if a local in-process error\n * occurred. That is to say that the returned #GDBusMessage object may\n * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use\n * g_dbus_message_to_gerror() to transcode this to a #GError.\n *\n * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]\n * for an example of how to use this low-level API to send and receive\n * UNIX file descriptors.\n *\n * Note that @message must be unlocked, unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.\n *\n * Returns: (transfer full): a locked #GDBusMessage that is the reply\n *     to @message or %NULL if @error is set\n *\n * Since: 2.26\n */\nGDBusMessage *\ng_dbus_connection_send_message_with_reply_sync (GDBusConnection        *connection,\n                                                GDBusMessage           *message,\n                                                GDBusSendMessageFlags   flags,\n                                                gint                    timeout_msec,\n                                                volatile guint32       *out_serial,\n                                                GCancellable           *cancellable,\n                                                GError                **error)\n{\n  SendMessageSyncData data;\n  GDBusMessage *reply;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  g_return_val_if_fail (G_IS_DBUS_MESSAGE (message), NULL);\n  g_return_val_if_fail ((flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL) || !g_dbus_message_get_locked (message), NULL);\n  g_return_val_if_fail (timeout_msec >= 0 || timeout_msec == -1, NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  data.res = NULL;\n  data.context = g_main_context_new ();\n  data.loop = g_main_loop_new (data.context, FALSE);\n\n  g_main_context_push_thread_default (data.context);\n\n  g_dbus_connection_send_message_with_reply (connection,\n                                             message,\n                                             flags,\n                                             timeout_msec,\n                                             out_serial,\n                                             cancellable,\n                                             (GAsyncReadyCallback) send_message_with_reply_sync_cb,\n                                             &data);\n  g_main_loop_run (data.loop);\n  reply = g_dbus_connection_send_message_with_reply_finish (connection,\n                                                            data.res,\n                                                            error);\n\n  g_main_context_pop_thread_default (data.context);\n\n  g_main_context_unref (data.context);\n  g_main_loop_unref (data.loop);\n  if (data.res)\n    g_object_unref (data.res);\n\n  return reply;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  guint                       id;\n  guint                       ref_count;\n  GDBusMessageFilterFunction  filter_function;\n  gpointer                    user_data;\n  GDestroyNotify              user_data_free_func;\n  GMainContext               *context;\n} FilterData;\n\n/* requires CONNECTION_LOCK */\nstatic FilterData **\ncopy_filter_list (GPtrArray *filters)\n{\n  FilterData **copy;\n  guint n;\n\n  copy = g_new (FilterData *, filters->len + 1);\n  for (n = 0; n < filters->len; n++)\n    {\n      copy[n] = filters->pdata[n];\n      copy[n]->ref_count++;\n    }\n  copy[n] = NULL;\n\n  return copy;\n}\n\n/* requires CONNECTION_LOCK */\nstatic void\nfree_filter_list (FilterData **filters)\n{\n  guint n;\n\n  for (n = 0; filters[n]; n++)\n    {\n      filters[n]->ref_count--;\n      if (filters[n]->ref_count == 0)\n        {\n          call_destroy_notify (filters[n]->context,\n                               filters[n]->user_data_free_func,\n                               filters[n]->user_data);\n          g_main_context_unref (filters[n]->context);\n          g_free (filters[n]);\n        }\n    }\n  g_free (filters);\n}\n\n/* Called in GDBusWorker's thread - we must not block - with no lock held */\nstatic void\non_worker_message_received (GDBusWorker  *worker,\n                            GDBusMessage *message,\n                            gpointer      user_data)\n{\n  GDBusConnection *connection;\n  FilterData **filters;\n  guint n;\n  gboolean alive;\n\n  G_LOCK (message_bus_lock);\n  alive = g_hash_table_contains (alive_connections, user_data);\n  if (!alive)\n    {\n      G_UNLOCK (message_bus_lock);\n      return;\n    }\n  connection = G_DBUS_CONNECTION (user_data);\n  g_object_ref (connection);\n  G_UNLOCK (message_bus_lock);\n\n  //g_debug (\"in on_worker_message_received\");\n\n  g_object_ref (message);\n  g_dbus_message_lock (message);\n\n  //g_debug (\"boo ref_count = %d %p %p\", G_OBJECT (connection)->ref_count, connection, connection->worker);\n\n  /* First collect the set of callback functions */\n  CONNECTION_LOCK (connection);\n  filters = copy_filter_list (connection->filters);\n  CONNECTION_UNLOCK (connection);\n\n  /* then call the filters in order (without holding the lock) */\n  for (n = 0; filters[n]; n++)\n    {\n      message = filters[n]->filter_function (connection,\n                                             message,\n                                             TRUE,\n                                             filters[n]->user_data);\n      if (message == NULL)\n        break;\n      g_dbus_message_lock (message);\n    }\n\n  CONNECTION_LOCK (connection);\n  free_filter_list (filters);\n  CONNECTION_UNLOCK (connection);\n\n  /* Standard dispatch unless the filter ate the message - no need to\n   * do anything if the message was altered\n   */\n  if (message != NULL)\n    {\n      GDBusMessageType message_type;\n\n      message_type = g_dbus_message_get_message_type (message);\n      if (message_type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN || message_type == G_DBUS_MESSAGE_TYPE_ERROR)\n        {\n          guint32 reply_serial;\n          GTask *task;\n\n          reply_serial = g_dbus_message_get_reply_serial (message);\n          CONNECTION_LOCK (connection);\n          task = g_hash_table_lookup (connection->map_method_serial_to_task,\n                                      GUINT_TO_POINTER (reply_serial));\n          if (task != NULL)\n            {\n              /* This removes @task from @map_method_serial_to_task. */\n              //g_debug (\"delivering reply/error for serial %d for %p\", reply_serial, connection);\n              send_message_data_deliver_reply_unlocked (task, message);\n            }\n          else\n            {\n              //g_debug (\"message reply/error for serial %d but no SendMessageData found for %p\", reply_serial, connection);\n            }\n          CONNECTION_UNLOCK (connection);\n        }\n      else if (message_type == G_DBUS_MESSAGE_TYPE_SIGNAL)\n        {\n          CONNECTION_LOCK (connection);\n          distribute_signals (connection, message);\n          CONNECTION_UNLOCK (connection);\n        }\n      else if (message_type == G_DBUS_MESSAGE_TYPE_METHOD_CALL)\n        {\n          CONNECTION_LOCK (connection);\n          distribute_method_call (connection, message);\n          CONNECTION_UNLOCK (connection);\n        }\n    }\n\n  if (message != NULL)\n    g_object_unref (message);\n  g_object_unref (connection);\n}\n\n/* Called in GDBusWorker's thread, lock is not held */\nstatic GDBusMessage *\non_worker_message_about_to_be_sent (GDBusWorker  *worker,\n                                    GDBusMessage *message,\n                                    gpointer      user_data)\n{\n  GDBusConnection *connection;\n  FilterData **filters;\n  guint n;\n  gboolean alive;\n\n  G_LOCK (message_bus_lock);\n  alive = g_hash_table_contains (alive_connections, user_data);\n  if (!alive)\n    {\n      G_UNLOCK (message_bus_lock);\n      return message;\n    }\n  connection = G_DBUS_CONNECTION (user_data);\n  g_object_ref (connection);\n  G_UNLOCK (message_bus_lock);\n\n  //g_debug (\"in on_worker_message_about_to_be_sent\");\n\n  /* First collect the set of callback functions */\n  CONNECTION_LOCK (connection);\n  filters = copy_filter_list (connection->filters);\n  CONNECTION_UNLOCK (connection);\n\n  /* then call the filters in order (without holding the lock) */\n  for (n = 0; filters[n]; n++)\n    {\n      g_dbus_message_lock (message);\n      message = filters[n]->filter_function (connection,\n                                             message,\n                                             FALSE,\n                                             filters[n]->user_data);\n      if (message == NULL)\n        break;\n    }\n\n  CONNECTION_LOCK (connection);\n  free_filter_list (filters);\n  CONNECTION_UNLOCK (connection);\n\n  g_object_unref (connection);\n\n  return message;\n}\n\n/* called with connection lock held, in GDBusWorker thread */\nstatic gboolean\ncancel_method_on_close (gpointer key, gpointer value, gpointer user_data)\n{\n  GTask *task = value;\n  SendMessageData *data = g_task_get_task_data (task);\n\n  if (data->delivered)\n    return FALSE;\n\n  g_task_return_new_error (task,\n                           G_IO_ERROR,\n                           G_IO_ERROR_CLOSED,\n                           _(\"The connection is closed\"));\n\n  /* Ask send_message_with_reply_cleanup not to remove the element from the\n   * hash table - we're in the middle of a foreach; that would be unsafe.\n   * Instead, return TRUE from this function so that it gets removed safely.\n   */\n  send_message_with_reply_cleanup (task, FALSE);\n  return TRUE;\n}\n\n/* Called in GDBusWorker's thread - we must not block - without lock held */\nstatic void\non_worker_closed (GDBusWorker *worker,\n                  gboolean     remote_peer_vanished,\n                  GError      *error,\n                  gpointer     user_data)\n{\n  GDBusConnection *connection;\n  gboolean alive;\n  guint old_atomic_flags;\n\n  G_LOCK (message_bus_lock);\n  alive = g_hash_table_contains (alive_connections, user_data);\n  if (!alive)\n    {\n      G_UNLOCK (message_bus_lock);\n      return;\n    }\n  connection = G_DBUS_CONNECTION (user_data);\n  g_object_ref (connection);\n  G_UNLOCK (message_bus_lock);\n\n  //g_debug (\"in on_worker_closed: %s\", error->message);\n\n  CONNECTION_LOCK (connection);\n  /* Even though this is atomic, we do it inside the lock to avoid breaking\n   * assumptions in remove_match_rule(). We'd need the lock in a moment\n   * anyway, so, no loss.\n   */\n  old_atomic_flags = g_atomic_int_or (&connection->atomic_flags, FLAG_CLOSED);\n\n  if (!(old_atomic_flags & FLAG_CLOSED))\n    {\n      g_hash_table_foreach_remove (connection->map_method_serial_to_task, cancel_method_on_close, NULL);\n      schedule_closed_unlocked (connection, remote_peer_vanished, error);\n    }\n  CONNECTION_UNLOCK (connection);\n\n  g_object_unref (connection);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Determines the biggest set of capabilities we can support on this\n * connection.\n *\n * Called with the init_lock held.\n */\nstatic GDBusCapabilityFlags\nget_offered_capabilities_max (GDBusConnection *connection)\n{\n      GDBusCapabilityFlags ret;\n      ret = G_DBUS_CAPABILITY_FLAGS_NONE;\n#ifdef G_OS_UNIX\n      if (G_IS_UNIX_CONNECTION (connection->stream))\n        ret |= G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING;\n#endif\n      return ret;\n}\n\n/* Called in a user thread, lock is not held */\nstatic gboolean\ninitable_init (GInitable     *initable,\n               GCancellable  *cancellable,\n               GError       **error)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (initable);\n  gboolean ret;\n\n  /* This method needs to be idempotent to work with the singleton\n   * pattern. See the docs for g_initable_init(). We implement this by\n   * locking.\n   *\n   * Unfortunately we can't use the main lock since the on_worker_*()\n   * callbacks above needs the lock during initialization (for message\n   * bus connections we do a synchronous Hello() call on the bus).\n   */\n  g_mutex_lock (&connection->init_lock);\n\n  ret = FALSE;\n\n  /* Make this a no-op if we're already initialized (successfully or\n   * unsuccessfully)\n   */\n  if ((g_atomic_int_get (&connection->atomic_flags) & FLAG_INITIALIZED))\n    {\n      ret = (connection->initialization_error == NULL);\n      goto out;\n    }\n\n  /* Because of init_lock, we can't get here twice in different threads */\n  g_assert (connection->initialization_error == NULL);\n\n  /* The user can pass multiple (but mutally exclusive) construct\n   * properties:\n   *\n   *  - stream (of type GIOStream)\n   *  - address (of type gchar*)\n   *\n   * At the end of the day we end up with a non-NULL GIOStream\n   * object in connection->stream.\n   */\n  if (connection->address != NULL)\n    {\n      g_assert (connection->stream == NULL);\n\n      if ((connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER) ||\n          (connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS))\n        {\n          g_set_error_literal (&connection->initialization_error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_INVALID_ARGUMENT,\n                               _(\"Unsupported flags encountered when constructing a client-side connection\"));\n          goto out;\n        }\n\n      connection->stream = g_dbus_address_get_stream_sync (connection->address,\n                                                           NULL, /* TODO: out_guid */\n                                                           cancellable,\n                                                           &connection->initialization_error);\n      if (connection->stream == NULL)\n        goto out;\n    }\n  else if (connection->stream != NULL)\n    {\n      /* nothing to do */\n    }\n  else\n    {\n      g_assert_not_reached ();\n    }\n\n  /* Authenticate the connection */\n  if (connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER)\n    {\n      g_assert (!(connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT));\n      g_assert (connection->guid != NULL);\n      connection->auth = _g_dbus_auth_new (connection->stream);\n      if (!_g_dbus_auth_run_server (connection->auth,\n                                    connection->authentication_observer,\n                                    connection->guid,\n                                    (connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS),\n                                    get_offered_capabilities_max (connection),\n                                    &connection->capabilities,\n                                    &connection->credentials,\n                                    cancellable,\n                                    &connection->initialization_error))\n        goto out;\n    }\n  else if (connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT)\n    {\n      g_assert (!(connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER));\n      g_assert (connection->guid == NULL);\n      connection->auth = _g_dbus_auth_new (connection->stream);\n      connection->guid = _g_dbus_auth_run_client (connection->auth,\n                                                  connection->authentication_observer,\n                                                  get_offered_capabilities_max (connection),\n                                                  &connection->capabilities,\n                                                  cancellable,\n                                                  &connection->initialization_error);\n      if (connection->guid == NULL)\n        goto out;\n    }\n\n  if (connection->authentication_observer != NULL)\n    {\n      g_object_unref (connection->authentication_observer);\n      connection->authentication_observer = NULL;\n    }\n\n  //g_output_stream_flush (G_SOCKET_CONNECTION (connection->stream)\n\n  //g_debug (\"haz unix fd passing powers: %d\", connection->capabilities & G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING);\n\n#ifdef G_OS_UNIX\n  /* We want all IO operations to be non-blocking since they happen in\n   * the worker thread which is shared by _all_ connections.\n   */\n  if (G_IS_SOCKET_CONNECTION (connection->stream))\n    {\n      g_socket_set_blocking (g_socket_connection_get_socket (G_SOCKET_CONNECTION (connection->stream)), FALSE);\n    }\n#endif\n\n  G_LOCK (message_bus_lock);\n  if (alive_connections == NULL)\n    alive_connections = g_hash_table_new (g_direct_hash, g_direct_equal);\n  g_hash_table_add (alive_connections, connection);\n  G_UNLOCK (message_bus_lock);\n\n  connection->worker = _g_dbus_worker_new (connection->stream,\n                                           connection->capabilities,\n                                           ((connection->flags & G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING) != 0),\n                                           on_worker_message_received,\n                                           on_worker_message_about_to_be_sent,\n                                           on_worker_closed,\n                                           connection);\n\n  /* if a bus connection, call org.freedesktop.DBus.Hello - this is how we're getting a name */\n  if (connection->flags & G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION)\n    {\n      GVariant *hello_result;\n\n      /* we could lift this restriction by adding code in gdbusprivate.c */\n      if (connection->flags & G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING)\n        {\n          g_set_error_literal (&connection->initialization_error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_FAILED,\n                               \"Cannot use DELAY_MESSAGE_PROCESSING with MESSAGE_BUS_CONNECTION\");\n          goto out;\n        }\n\n      hello_result = g_dbus_connection_call_sync (connection,\n                                                  \"org.freedesktop.DBus\", /* name */\n                                                  \"/org/freedesktop/DBus\", /* path */\n                                                  \"org.freedesktop.DBus\", /* interface */\n                                                  \"Hello\",\n                                                  NULL, /* parameters */\n                                                  G_VARIANT_TYPE (\"(s)\"),\n                                                  CALL_FLAGS_INITIALIZING,\n                                                  -1,\n                                                  NULL, /* TODO: cancellable */\n                                                  &connection->initialization_error);\n      if (hello_result == NULL)\n        goto out;\n\n      g_variant_get (hello_result, \"(s)\", &connection->bus_unique_name);\n      g_variant_unref (hello_result);\n      //g_debug (\"unique name is '%s'\", connection->bus_unique_name);\n    }\n\n  ret = TRUE;\n out:\n  if (!ret)\n    {\n      g_assert (connection->initialization_error != NULL);\n      g_propagate_error (error, g_error_copy (connection->initialization_error));\n    }\n\n  g_atomic_int_or (&connection->atomic_flags, FLAG_INITIALIZED);\n  g_mutex_unlock (&connection->init_lock);\n\n  return ret;\n}\n\nstatic void\ninitable_iface_init (GInitableIface *initable_iface)\n{\n  initable_iface->init = initable_init;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic void\nasync_initable_iface_init (GAsyncInitableIface *async_initable_iface)\n{\n  /* Use default */\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_new:\n * @stream: a #GIOStream\n * @guid: (nullable): the GUID to use if a authenticating as a server or %NULL\n * @flags: flags describing how to make the connection\n * @observer: (nullable): a #GDBusAuthObserver or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: a #GAsyncReadyCallback to call when the request is satisfied\n * @user_data: the data to pass to @callback\n *\n * Asynchronously sets up a D-Bus connection for exchanging D-Bus messages\n * with the end represented by @stream.\n *\n * If @stream is a #GSocketConnection, then the corresponding #GSocket\n * will be put into non-blocking mode.\n *\n * The D-Bus connection will interact with @stream from a worker thread.\n * As a result, the caller should not interact with @stream after this\n * method has been called, except by calling g_object_unref() on it.\n *\n * If @observer is not %NULL it may be used to control the\n * authentication process.\n *\n * When the operation is finished, @callback will be invoked. You can\n * then call g_dbus_connection_new_finish() to get the result of the\n * operation.\n *\n * This is a asynchronous failable constructor. See\n * g_dbus_connection_new_sync() for the synchronous\n * version.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_new (GIOStream            *stream,\n                       const gchar          *guid,\n                       GDBusConnectionFlags  flags,\n                       GDBusAuthObserver    *observer,\n                       GCancellable         *cancellable,\n                       GAsyncReadyCallback   callback,\n                       gpointer              user_data)\n{\n  _g_dbus_initialize ();\n\n  g_return_if_fail (G_IS_IO_STREAM (stream));\n\n  g_async_initable_new_async (G_TYPE_DBUS_CONNECTION,\n                              G_PRIORITY_DEFAULT,\n                              cancellable,\n                              callback,\n                              user_data,\n                              \"stream\", stream,\n                              \"guid\", guid,\n                              \"flags\", flags,\n                              \"authentication-observer\", observer,\n                              NULL);\n}\n\n/**\n * g_dbus_connection_new_finish:\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback\n *     passed to g_dbus_connection_new().\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_new().\n *\n * Returns: a #GDBusConnection or %NULL if @error is set. Free\n *     with g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_dbus_connection_new_finish (GAsyncResult  *res,\n                              GError       **error)\n{\n  GObject *object;\n  GObject *source_object;\n\n  g_return_val_if_fail (G_IS_ASYNC_RESULT (res), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  source_object = g_async_result_get_source_object (res);\n  g_assert (source_object != NULL);\n  object = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object),\n                                        res,\n                                        error);\n  g_object_unref (source_object);\n  if (object != NULL)\n    return G_DBUS_CONNECTION (object);\n  else\n    return NULL;\n}\n\n/**\n * g_dbus_connection_new_sync:\n * @stream: a #GIOStream\n * @guid: (nullable): the GUID to use if a authenticating as a server or %NULL\n * @flags: flags describing how to make the connection\n * @observer: (nullable): a #GDBusAuthObserver or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously sets up a D-Bus connection for exchanging D-Bus messages\n * with the end represented by @stream.\n *\n * If @stream is a #GSocketConnection, then the corresponding #GSocket\n * will be put into non-blocking mode.\n *\n * The D-Bus connection will interact with @stream from a worker thread.\n * As a result, the caller should not interact with @stream after this\n * method has been called, except by calling g_object_unref() on it.\n *\n * If @observer is not %NULL it may be used to control the\n * authentication process.\n *\n * This is a synchronous failable constructor. See\n * g_dbus_connection_new() for the asynchronous version.\n *\n * Returns: a #GDBusConnection or %NULL if @error is set. Free with g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_dbus_connection_new_sync (GIOStream             *stream,\n                            const gchar           *guid,\n                            GDBusConnectionFlags   flags,\n                            GDBusAuthObserver     *observer,\n                            GCancellable          *cancellable,\n                            GError               **error)\n{\n  _g_dbus_initialize ();\n  g_return_val_if_fail (G_IS_IO_STREAM (stream), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n  return g_initable_new (G_TYPE_DBUS_CONNECTION,\n                         cancellable,\n                         error,\n                         \"stream\", stream,\n                         \"guid\", guid,\n                         \"flags\", flags,\n                         \"authentication-observer\", observer,\n                         NULL);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_new_for_address:\n * @address: a D-Bus address\n * @flags: flags describing how to make the connection\n * @observer: (nullable): a #GDBusAuthObserver or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: a #GAsyncReadyCallback to call when the request is satisfied\n * @user_data: the data to pass to @callback\n *\n * Asynchronously connects and sets up a D-Bus client connection for\n * exchanging D-Bus messages with an endpoint specified by @address\n * which must be in the\n * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).\n *\n * This constructor can only be used to initiate client-side\n * connections - use g_dbus_connection_new() if you need to act as the\n * server. In particular, @flags cannot contain the\n * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or\n * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.\n *\n * When the operation is finished, @callback will be invoked. You can\n * then call g_dbus_connection_new_finish() to get the result of the\n * operation.\n *\n * If @observer is not %NULL it may be used to control the\n * authentication process.\n *\n * This is a asynchronous failable constructor. See\n * g_dbus_connection_new_for_address_sync() for the synchronous\n * version.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_new_for_address (const gchar          *address,\n                                   GDBusConnectionFlags  flags,\n                                   GDBusAuthObserver    *observer,\n                                   GCancellable         *cancellable,\n                                   GAsyncReadyCallback   callback,\n                                   gpointer              user_data)\n{\n  _g_dbus_initialize ();\n\n  g_return_if_fail (address != NULL);\n\n  g_async_initable_new_async (G_TYPE_DBUS_CONNECTION,\n                              G_PRIORITY_DEFAULT,\n                              cancellable,\n                              callback,\n                              user_data,\n                              \"address\", address,\n                              \"flags\", flags,\n                              \"authentication-observer\", observer,\n                              NULL);\n}\n\n/**\n * g_dbus_connection_new_for_address_finish:\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed\n *     to g_dbus_connection_new()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_new_for_address().\n *\n * Returns: a #GDBusConnection or %NULL if @error is set. Free with\n *     g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_dbus_connection_new_for_address_finish (GAsyncResult  *res,\n                                          GError       **error)\n{\n  GObject *object;\n  GObject *source_object;\n\n  g_return_val_if_fail (G_IS_ASYNC_RESULT (res), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  source_object = g_async_result_get_source_object (res);\n  g_assert (source_object != NULL);\n  object = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object),\n                                        res,\n                                        error);\n  g_object_unref (source_object);\n  if (object != NULL)\n    return G_DBUS_CONNECTION (object);\n  else\n    return NULL;\n}\n\n/**\n * g_dbus_connection_new_for_address_sync:\n * @address: a D-Bus address\n * @flags: flags describing how to make the connection\n * @observer: (nullable): a #GDBusAuthObserver or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously connects and sets up a D-Bus client connection for\n * exchanging D-Bus messages with an endpoint specified by @address\n * which must be in the\n * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).\n *\n * This constructor can only be used to initiate client-side\n * connections - use g_dbus_connection_new_sync() if you need to act\n * as the server. In particular, @flags cannot contain the\n * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or\n * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.\n *\n * This is a synchronous failable constructor. See\n * g_dbus_connection_new_for_address() for the asynchronous version.\n *\n * If @observer is not %NULL it may be used to control the\n * authentication process.\n *\n * Returns: a #GDBusConnection or %NULL if @error is set. Free with\n *     g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_dbus_connection_new_for_address_sync (const gchar           *address,\n                                        GDBusConnectionFlags   flags,\n                                        GDBusAuthObserver     *observer,\n                                        GCancellable          *cancellable,\n                                        GError               **error)\n{\n  _g_dbus_initialize ();\n\n  g_return_val_if_fail (address != NULL, NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n  return g_initable_new (G_TYPE_DBUS_CONNECTION,\n                         cancellable,\n                         error,\n                         \"address\", address,\n                         \"flags\", flags,\n                         \"authentication-observer\", observer,\n                         NULL);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_set_exit_on_close:\n * @connection: a #GDBusConnection\n * @exit_on_close: whether the process should be terminated\n *     when @connection is closed by the remote peer\n *\n * Sets whether the process should be terminated when @connection is\n * closed by the remote peer. See #GDBusConnection:exit-on-close for\n * more details.\n *\n * Note that this function should be used with care. Most modern UNIX\n * desktops tie the notion of a user session the session bus, and expect\n * all of a users applications to quit when their bus connection goes away.\n * If you are setting @exit_on_close to %FALSE for the shared session\n * bus connection, you should make sure that your application exits\n * when the user session ends.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_set_exit_on_close (GDBusConnection *connection,\n                                     gboolean         exit_on_close)\n{\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n\n  if (exit_on_close)\n    g_atomic_int_or (&connection->atomic_flags, FLAG_EXIT_ON_CLOSE);\n  else\n    g_atomic_int_and (&connection->atomic_flags, ~FLAG_EXIT_ON_CLOSE);\n\n}\n\n/**\n * g_dbus_connection_get_exit_on_close:\n * @connection: a #GDBusConnection\n *\n * Gets whether the process is terminated when @connection is\n * closed by the remote peer. See\n * #GDBusConnection:exit-on-close for more details.\n *\n * Returns: whether the process is terminated when @connection is\n *     closed by the remote peer\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_get_exit_on_close (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n\n  if (g_atomic_int_get (&connection->atomic_flags) & FLAG_EXIT_ON_CLOSE)\n    return TRUE;\n  else\n    return FALSE;\n}\n\n/**\n * g_dbus_connection_get_guid:\n * @connection: a #GDBusConnection\n *\n * The GUID of the peer performing the role of server when\n * authenticating. See #GDBusConnection:guid for more details.\n *\n * Returns: The GUID. Do not free this string, it is owned by\n *     @connection.\n *\n * Since: 2.26\n */\nconst gchar *\ng_dbus_connection_get_guid (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  return connection->guid;\n}\n\n/**\n * g_dbus_connection_get_unique_name:\n * @connection: a #GDBusConnection\n *\n * Gets the unique name of @connection as assigned by the message\n * bus. This can also be used to figure out if @connection is a\n * message bus connection.\n *\n * Returns: (nullable): the unique name or %NULL if @connection is not a message\n *     bus connection. Do not free this string, it is owned by\n *     @connection.\n *\n * Since: 2.26\n */\nconst gchar *\ng_dbus_connection_get_unique_name (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return NULL;\n\n  return connection->bus_unique_name;\n}\n\n/**\n * g_dbus_connection_get_peer_credentials:\n * @connection: a #GDBusConnection\n *\n * Gets the credentials of the authenticated peer. This will always\n * return %NULL unless @connection acted as a server\n * (e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)\n * when set up and the client passed credentials as part of the\n * authentication process.\n *\n * In a message bus setup, the message bus is always the server and\n * each application is a client. So this method will always return\n * %NULL for message bus clients.\n *\n * Returns: (transfer none) (nullable): a #GCredentials or %NULL if not\n *     available. Do not free this object, it is owned by @connection.\n *\n * Since: 2.26\n */\nGCredentials *\ng_dbus_connection_get_peer_credentials (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return NULL;\n\n  return connection->credentials;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic volatile guint _global_filter_id = 1;\n\n/**\n * g_dbus_connection_add_filter:\n * @connection: a #GDBusConnection\n * @filter_function: a filter function\n * @user_data: user data to pass to @filter_function\n * @user_data_free_func: function to free @user_data with when filter\n *     is removed or %NULL\n *\n * Adds a message filter. Filters are handlers that are run on all\n * incoming and outgoing messages, prior to standard dispatch. Filters\n * are run in the order that they were added.  The same handler can be\n * added as a filter more than once, in which case it will be run more\n * than once.  Filters added during a filter callback won't be run on\n * the message being processed. Filter functions are allowed to modify\n * and even drop messages.\n *\n * Note that filters are run in a dedicated message handling thread so\n * they can't block and, generally, can't do anything but signal a\n * worker thread. Also note that filters are rarely needed - use API\n * such as g_dbus_connection_send_message_with_reply(),\n * g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.\n *\n * If a filter consumes an incoming message the message is not\n * dispatched anywhere else - not even the standard dispatch machinery\n * (that API such as g_dbus_connection_signal_subscribe() and\n * g_dbus_connection_send_message_with_reply() relies on) will see the\n * message. Similarly, if a filter consumes an outgoing message, the\n * message will not be sent to the other peer.\n *\n * If @user_data_free_func is non-%NULL, it will be called (in the\n * thread-default main context of the thread you are calling this\n * method from) at some point after @user_data is no longer\n * needed. (It is not guaranteed to be called synchronously when the\n * filter is removed, and may be called after @connection has been\n * destroyed.)\n *\n * Returns: a filter identifier that can be used with\n *     g_dbus_connection_remove_filter()\n *\n * Since: 2.26\n */\nguint\ng_dbus_connection_add_filter (GDBusConnection            *connection,\n                              GDBusMessageFilterFunction  filter_function,\n                              gpointer                    user_data,\n                              GDestroyNotify              user_data_free_func)\n{\n  FilterData *data;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n  g_return_val_if_fail (filter_function != NULL, 0);\n  g_return_val_if_fail (check_initialized (connection), 0);\n\n  CONNECTION_LOCK (connection);\n  data = g_new0 (FilterData, 1);\n  data->id = g_atomic_int_add (&_global_filter_id, 1); /* TODO: overflow etc. */\n  data->ref_count = 1;\n  data->filter_function = filter_function;\n  data->user_data = user_data;\n  data->user_data_free_func = user_data_free_func;\n  data->context = g_main_context_ref_thread_default ();\n  g_ptr_array_add (connection->filters, data);\n  CONNECTION_UNLOCK (connection);\n\n  return data->id;\n}\n\n/* only called from finalize(), removes all filters */\nstatic void\npurge_all_filters (GDBusConnection *connection)\n{\n  guint n;\n  for (n = 0; n < connection->filters->len; n++)\n    {\n      FilterData *data = connection->filters->pdata[n];\n\n      call_destroy_notify (data->context,\n                           data->user_data_free_func,\n                           data->user_data);\n      g_main_context_unref (data->context);\n      g_free (data);\n    }\n}\n\n/**\n * g_dbus_connection_remove_filter:\n * @connection: a #GDBusConnection\n * @filter_id: an identifier obtained from g_dbus_connection_add_filter()\n *\n * Removes a filter.\n *\n * Note that since filters run in a different thread, there is a race\n * condition where it is possible that the filter will be running even\n * after calling g_dbus_connection_remove_filter(), so you cannot just\n * free data that the filter might be using. Instead, you should pass\n * a #GDestroyNotify to g_dbus_connection_add_filter(), which will be\n * called when it is guaranteed that the data is no longer needed.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_remove_filter (GDBusConnection *connection,\n                                 guint            filter_id)\n{\n  guint n;\n  gboolean found;\n  FilterData *to_destroy;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n  g_return_if_fail (check_initialized (connection));\n\n  CONNECTION_LOCK (connection);\n  found = FALSE;\n  to_destroy = NULL;\n  for (n = 0; n < connection->filters->len; n++)\n    {\n      FilterData *data = connection->filters->pdata[n];\n      if (data->id == filter_id)\n        {\n          found = TRUE;\n          g_ptr_array_remove_index (connection->filters, n);\n          data->ref_count--;\n          if (data->ref_count == 0)\n            to_destroy = data;\n          break;\n        }\n    }\n  CONNECTION_UNLOCK (connection);\n\n  /* do free without holding lock */\n  if (to_destroy != NULL)\n    {\n      if (to_destroy->user_data_free_func != NULL)\n        to_destroy->user_data_free_func (to_destroy->user_data);\n      g_main_context_unref (to_destroy->context);\n      g_free (to_destroy);\n    }\n  else if (!found)\n    {\n      g_warning (\"g_dbus_connection_remove_filter: No filter found for filter_id %d\", filter_id);\n    }\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  gchar *rule;\n  gchar *sender;\n  gchar *sender_unique_name; /* if sender is unique or org.freedesktop.DBus, then that name... otherwise blank */\n  gchar *interface_name;\n  gchar *member;\n  gchar *object_path;\n  gchar *arg0;\n  GDBusSignalFlags flags;\n  GArray *subscribers;\n} SignalData;\n\ntypedef struct\n{\n  GDBusSignalCallback callback;\n  gpointer user_data;\n  GDestroyNotify user_data_free_func;\n  guint id;\n  GMainContext *context;\n} SignalSubscriber;\n\nstatic void\nsignal_data_free (SignalData *signal_data)\n{\n  g_free (signal_data->rule);\n  g_free (signal_data->sender);\n  g_free (signal_data->sender_unique_name);\n  g_free (signal_data->interface_name);\n  g_free (signal_data->member);\n  g_free (signal_data->object_path);\n  g_free (signal_data->arg0);\n  g_array_free (signal_data->subscribers, TRUE);\n  g_free (signal_data);\n}\n\nstatic gchar *\nargs_to_rule (const gchar      *sender,\n              const gchar      *interface_name,\n              const gchar      *member,\n              const gchar      *object_path,\n              const gchar      *arg0,\n              GDBusSignalFlags  flags)\n{\n  GString *rule;\n\n  rule = g_string_new (\"type='signal'\");\n  if (flags & G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE)\n    g_string_prepend_c (rule, '-');\n  if (sender != NULL)\n    g_string_append_printf (rule, \",sender='%s'\", sender);\n  if (interface_name != NULL)\n    g_string_append_printf (rule, \",interface='%s'\", interface_name);\n  if (member != NULL)\n    g_string_append_printf (rule, \",member='%s'\", member);\n  if (object_path != NULL)\n    g_string_append_printf (rule, \",path='%s'\", object_path);\n\n  if (arg0 != NULL)\n    {\n      if (flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH)\n        g_string_append_printf (rule, \",arg0path='%s'\", arg0);\n      else if (flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE)\n        g_string_append_printf (rule, \",arg0namespace='%s'\", arg0);\n      else\n        g_string_append_printf (rule, \",arg0='%s'\", arg0);\n    }\n\n  return g_string_free (rule, FALSE);\n}\n\nstatic volatile guint _global_subscriber_id = 1;\nstatic volatile guint _global_registration_id = 1;\nstatic volatile guint _global_subtree_registration_id = 1;\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called in a user thread, lock is held */\nstatic void\nadd_match_rule (GDBusConnection *connection,\n                const gchar     *match_rule)\n{\n  GError *error;\n  GDBusMessage *message;\n\n  if (match_rule[0] == '-')\n    return;\n\n  message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", /* name */\n                                            \"/org/freedesktop/DBus\", /* path */\n                                            \"org.freedesktop.DBus\", /* interface */\n                                            \"AddMatch\");\n  g_dbus_message_set_body (message, g_variant_new (\"(s)\", match_rule));\n  error = NULL;\n  if (!g_dbus_connection_send_message_unlocked (connection,\n                                                message,\n                                                G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                NULL,\n                                                &error))\n    {\n      g_critical (\"Error while sending AddMatch() message: %s\", error->message);\n      g_error_free (error);\n    }\n  g_object_unref (message);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called in a user thread, lock is held */\nstatic void\nremove_match_rule (GDBusConnection *connection,\n                   const gchar     *match_rule)\n{\n  GError *error;\n  GDBusMessage *message;\n\n  if (match_rule[0] == '-')\n    return;\n\n  message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", /* name */\n                                            \"/org/freedesktop/DBus\", /* path */\n                                            \"org.freedesktop.DBus\", /* interface */\n                                            \"RemoveMatch\");\n  g_dbus_message_set_body (message, g_variant_new (\"(s)\", match_rule));\n\n  error = NULL;\n  if (!g_dbus_connection_send_message_unlocked (connection,\n                                                message,\n                                                G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                NULL,\n                                                &error))\n    {\n      /* If we could get G_IO_ERROR_CLOSED here, it wouldn't be reasonable to\n       * critical; but we're holding the lock, and our caller checked whether\n       * we were already closed, so we can't get that error.\n       */\n      g_critical (\"Error while sending RemoveMatch() message: %s\", error->message);\n      g_error_free (error);\n    }\n  g_object_unref (message);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic gboolean\nis_signal_data_for_name_lost_or_acquired (SignalData *signal_data)\n{\n  return g_strcmp0 (signal_data->sender_unique_name, \"org.freedesktop.DBus\") == 0 &&\n         g_strcmp0 (signal_data->interface_name, \"org.freedesktop.DBus\") == 0 &&\n         g_strcmp0 (signal_data->object_path, \"/org/freedesktop/DBus\") == 0 &&\n         (g_strcmp0 (signal_data->member, \"NameLost\") == 0 ||\n          g_strcmp0 (signal_data->member, \"NameAcquired\") == 0);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_signal_subscribe:\n * @connection: a #GDBusConnection\n * @sender: (nullable): sender name to match on (unique or well-known name)\n *     or %NULL to listen from all senders\n * @interface_name: (nullable): D-Bus interface name to match on or %NULL to\n *     match on all interfaces\n * @member: (nullable): D-Bus signal name to match on or %NULL to match on\n *     all signals\n * @object_path: (nullable): object path to match on or %NULL to match on\n *     all object paths\n * @arg0: (nullable): contents of first string argument to match on or %NULL\n *     to match on all kinds of arguments\n * @flags: #GDBusSignalFlags describing how arg0 is used in subscribing to the\n *     signal\n * @callback: callback to invoke when there is a signal matching the requested data\n * @user_data: user data to pass to @callback\n * @user_data_free_func: (nullable): function to free @user_data with when\n *     subscription is removed or %NULL\n *\n * Subscribes to signals on @connection and invokes @callback with a whenever\n * the signal is received. Note that @callback will be invoked in the \n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from.\n *\n * If @connection is not a message bus connection, @sender must be\n * %NULL.\n *\n * If @sender is a well-known name note that @callback is invoked with\n * the unique name for the owner of @sender, not the well-known name\n * as one would expect. This is because the message bus rewrites the\n * name. As such, to avoid certain race conditions, users should be\n * tracking the name owner of the well-known name and use that when\n * processing the received signal.\n *\n * If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or\n * %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is\n * interpreted as part of a namespace or path.  The first argument\n * of a signal is matched against that part as specified by D-Bus.\n *\n * If @user_data_free_func is non-%NULL, it will be called (in the\n * thread-default main context of the thread you are calling this\n * method from) at some point after @user_data is no longer\n * needed. (It is not guaranteed to be called synchronously when the\n * signal is unsubscribed from, and may be called after @connection\n * has been destroyed.)\n *\n * The returned subscription identifier is an opaque value which is guaranteed\n * to never be zero.\n *\n * This function can never fail.\n *\n * Returns: a subscription identifier that can be used with g_dbus_connection_signal_unsubscribe()\n *\n * Since: 2.26\n */\nguint\ng_dbus_connection_signal_subscribe (GDBusConnection     *connection,\n                                    const gchar         *sender,\n                                    const gchar         *interface_name,\n                                    const gchar         *member,\n                                    const gchar         *object_path,\n                                    const gchar         *arg0,\n                                    GDBusSignalFlags     flags,\n                                    GDBusSignalCallback  callback,\n                                    gpointer             user_data,\n                                    GDestroyNotify       user_data_free_func)\n{\n  gchar *rule;\n  SignalData *signal_data;\n  SignalSubscriber subscriber;\n  GPtrArray *signal_data_array;\n  const gchar *sender_unique_name;\n\n  /* Right now we abort if AddMatch() fails since it can only fail with the bus being in\n   * an OOM condition. We might want to change that but that would involve making\n   * g_dbus_connection_signal_subscribe() asynchronous and having the call sites\n   * handle that. And there's really no sensible way of handling this short of retrying\n   * to add the match rule... and then there's the little thing that, hey, maybe there's\n   * a reason the bus in an OOM condition.\n   *\n   * Doable, but not really sure it's worth it...\n   */\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n  g_return_val_if_fail (sender == NULL || (g_dbus_is_name (sender) && (connection->flags & G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION)), 0);\n  g_return_val_if_fail (interface_name == NULL || g_dbus_is_interface_name (interface_name), 0);\n  g_return_val_if_fail (member == NULL || g_dbus_is_member_name (member), 0);\n  g_return_val_if_fail (object_path == NULL || g_variant_is_object_path (object_path), 0);\n  g_return_val_if_fail (callback != NULL, 0);\n  g_return_val_if_fail (check_initialized (connection), 0);\n  g_return_val_if_fail (!((flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH) && (flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE)), 0);\n  g_return_val_if_fail (!(arg0 == NULL && (flags & (G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH | G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE))), 0);\n\n  CONNECTION_LOCK (connection);\n\n  /* If G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE was specified, we will end up\n   * with a '-' character to prefix the rule (which will otherwise be\n   * normal).\n   *\n   * This allows us to hash the rule and do our lifecycle tracking in\n   * the usual way, but the '-' prevents the match rule from ever\n   * actually being send to the bus (either for add or remove).\n   */\n  rule = args_to_rule (sender, interface_name, member, object_path, arg0, flags);\n\n  if (sender != NULL && (g_dbus_is_unique_name (sender) || g_strcmp0 (sender, \"org.freedesktop.DBus\") == 0))\n    sender_unique_name = sender;\n  else\n    sender_unique_name = \"\";\n\n  subscriber.callback = callback;\n  subscriber.user_data = user_data;\n  subscriber.user_data_free_func = user_data_free_func;\n  subscriber.id = g_atomic_int_add (&_global_subscriber_id, 1); /* TODO: overflow etc. */\n  subscriber.context = g_main_context_ref_thread_default ();\n\n  /* see if we've already have this rule */\n  signal_data = g_hash_table_lookup (connection->map_rule_to_signal_data, rule);\n  if (signal_data != NULL)\n    {\n      g_array_append_val (signal_data->subscribers, subscriber);\n      g_free (rule);\n      goto out;\n    }\n\n  signal_data = g_new0 (SignalData, 1);\n  signal_data->rule                  = rule;\n  signal_data->sender                = g_strdup (sender);\n  signal_data->sender_unique_name    = g_strdup (sender_unique_name);\n  signal_data->interface_name        = g_strdup (interface_name);\n  signal_data->member                = g_strdup (member);\n  signal_data->object_path           = g_strdup (object_path);\n  signal_data->arg0                  = g_strdup (arg0);\n  signal_data->flags                 = flags;\n  signal_data->subscribers           = g_array_new (FALSE, FALSE, sizeof (SignalSubscriber));\n  g_array_append_val (signal_data->subscribers, subscriber);\n\n  g_hash_table_insert (connection->map_rule_to_signal_data,\n                       signal_data->rule,\n                       signal_data);\n\n  /* Add the match rule to the bus...\n   *\n   * Avoid adding match rules for NameLost and NameAcquired messages - the bus will\n   * always send such messages to us.\n   */\n  if (connection->flags & G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION)\n    {\n      if (!is_signal_data_for_name_lost_or_acquired (signal_data))\n        add_match_rule (connection, signal_data->rule);\n    }\n\n  signal_data_array = g_hash_table_lookup (connection->map_sender_unique_name_to_signal_data_array,\n                                           signal_data->sender_unique_name);\n  if (signal_data_array == NULL)\n    {\n      signal_data_array = g_ptr_array_new ();\n      g_hash_table_insert (connection->map_sender_unique_name_to_signal_data_array,\n                           g_strdup (signal_data->sender_unique_name),\n                           signal_data_array);\n    }\n  g_ptr_array_add (signal_data_array, signal_data);\n\n out:\n  g_hash_table_insert (connection->map_id_to_signal_data,\n                       GUINT_TO_POINTER (subscriber.id),\n                       signal_data);\n\n  CONNECTION_UNLOCK (connection);\n\n  return subscriber.id;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* called in any thread */\n/* must hold lock when calling this (except if connection->finalizing is TRUE) */\nstatic void\nunsubscribe_id_internal (GDBusConnection *connection,\n                         guint            subscription_id,\n                         GArray          *out_removed_subscribers)\n{\n  SignalData *signal_data;\n  GPtrArray *signal_data_array;\n  guint n;\n\n  signal_data = g_hash_table_lookup (connection->map_id_to_signal_data,\n                                     GUINT_TO_POINTER (subscription_id));\n  if (signal_data == NULL)\n    {\n      /* Don't warn here, we may have thrown all subscriptions out when the connection was closed */\n      goto out;\n    }\n\n  for (n = 0; n < signal_data->subscribers->len; n++)\n    {\n      SignalSubscriber *subscriber;\n\n      subscriber = &(g_array_index (signal_data->subscribers, SignalSubscriber, n));\n      if (subscriber->id != subscription_id)\n        continue;\n\n      g_warn_if_fail (g_hash_table_remove (connection->map_id_to_signal_data,\n                                           GUINT_TO_POINTER (subscription_id)));\n      g_array_append_val (out_removed_subscribers, *subscriber);\n      g_array_remove_index (signal_data->subscribers, n);\n\n      if (signal_data->subscribers->len == 0)\n        {\n          g_warn_if_fail (g_hash_table_remove (connection->map_rule_to_signal_data, signal_data->rule));\n\n          signal_data_array = g_hash_table_lookup (connection->map_sender_unique_name_to_signal_data_array,\n                                                   signal_data->sender_unique_name);\n          g_warn_if_fail (signal_data_array != NULL);\n          g_warn_if_fail (g_ptr_array_remove (signal_data_array, signal_data));\n\n          if (signal_data_array->len == 0)\n            {\n              g_warn_if_fail (g_hash_table_remove (connection->map_sender_unique_name_to_signal_data_array,\n                                                   signal_data->sender_unique_name));\n            }\n\n          /* remove the match rule from the bus unless NameLost or NameAcquired (see subscribe()) */\n          if ((connection->flags & G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION) &&\n              !is_signal_data_for_name_lost_or_acquired (signal_data) &&\n              !g_dbus_connection_is_closed (connection) &&\n              !connection->finalizing)\n            {\n              /* The check for g_dbus_connection_is_closed() means that\n               * sending the RemoveMatch message can't fail with\n               * G_IO_ERROR_CLOSED, because we're holding the lock,\n               * so on_worker_closed() can't happen between the check we just\n               * did, and releasing the lock later.\n               */\n              remove_match_rule (connection, signal_data->rule);\n            }\n\n          signal_data_free (signal_data);\n        }\n\n      goto out;\n    }\n\n  g_assert_not_reached ();\n\n out:\n  ;\n}\n\n/**\n * g_dbus_connection_signal_unsubscribe:\n * @connection: a #GDBusConnection\n * @subscription_id: a subscription id obtained from\n *     g_dbus_connection_signal_subscribe()\n *\n * Unsubscribes from signals.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_signal_unsubscribe (GDBusConnection *connection,\n                                      guint            subscription_id)\n{\n  GArray *subscribers;\n  guint n;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n  g_return_if_fail (check_initialized (connection));\n\n  subscribers = g_array_new (FALSE, FALSE, sizeof (SignalSubscriber));\n\n  CONNECTION_LOCK (connection);\n  unsubscribe_id_internal (connection,\n                           subscription_id,\n                           subscribers);\n  CONNECTION_UNLOCK (connection);\n\n  /* invariant */\n  g_assert (subscribers->len == 0 || subscribers->len == 1);\n\n  /* call GDestroyNotify without lock held */\n  for (n = 0; n < subscribers->len; n++)\n    {\n      SignalSubscriber *subscriber;\n      subscriber = &(g_array_index (subscribers, SignalSubscriber, n));\n      call_destroy_notify (subscriber->context,\n                           subscriber->user_data_free_func,\n                           subscriber->user_data);\n      g_main_context_unref (subscriber->context);\n    }\n\n  g_array_free (subscribers, TRUE);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  guint                subscription_id;\n  GDBusSignalCallback  callback;\n  gpointer             user_data;\n  GDBusMessage        *message;\n  GDBusConnection     *connection;\n  const gchar         *sender;\n  const gchar         *path;\n  const gchar         *interface;\n  const gchar         *member;\n} SignalInstance;\n\n/* called on delivery thread (e.g. where g_dbus_connection_signal_subscribe() was called) with\n * no locks held\n */\nstatic gboolean\nemit_signal_instance_in_idle_cb (gpointer data)\n{\n  SignalInstance *signal_instance = data;\n  GVariant *parameters;\n  gboolean has_subscription;\n\n  parameters = g_dbus_message_get_body (signal_instance->message);\n  if (parameters == NULL)\n    {\n      parameters = g_variant_new (\"()\");\n      g_variant_ref_sink (parameters);\n    }\n  else\n    {\n      g_variant_ref_sink (parameters);\n    }\n\n#if 0\n  g_print (\"in emit_signal_instance_in_idle_cb (id=%d sender=%s path=%s interface=%s member=%s params=%s)\\n\",\n           signal_instance->subscription_id,\n           signal_instance->sender,\n           signal_instance->path,\n           signal_instance->interface,\n           signal_instance->member,\n           g_variant_print (parameters, TRUE));\n#endif\n\n  /* Careful here, don't do the callback if we no longer has the subscription */\n  CONNECTION_LOCK (signal_instance->connection);\n  has_subscription = FALSE;\n  if (g_hash_table_lookup (signal_instance->connection->map_id_to_signal_data,\n                           GUINT_TO_POINTER (signal_instance->subscription_id)) != NULL)\n    has_subscription = TRUE;\n  CONNECTION_UNLOCK (signal_instance->connection);\n\n  if (has_subscription)\n    signal_instance->callback (signal_instance->connection,\n                               signal_instance->sender,\n                               signal_instance->path,\n                               signal_instance->interface,\n                               signal_instance->member,\n                               parameters,\n                               signal_instance->user_data);\n\n  g_variant_unref (parameters);\n\n  return FALSE;\n}\n\nstatic void\nsignal_instance_free (SignalInstance *signal_instance)\n{\n  g_object_unref (signal_instance->message);\n  g_object_unref (signal_instance->connection);\n  g_free (signal_instance);\n}\n\nstatic gboolean\nnamespace_rule_matches (const gchar *namespace,\n                        const gchar *name)\n{\n  gint len_namespace;\n  gint len_name;\n\n  len_namespace = strlen (namespace);\n  len_name = strlen (name);\n\n  if (len_name < len_namespace)\n    return FALSE;\n\n  if (memcmp (namespace, name, len_namespace) != 0)\n    return FALSE;\n\n  return len_namespace == len_name || name[len_namespace] == '.';\n}\n\nstatic gboolean\npath_rule_matches (const gchar *path_a,\n                   const gchar *path_b)\n{\n  gint len_a, len_b;\n\n  len_a = strlen (path_a);\n  len_b = strlen (path_b);\n\n  if (len_a < len_b && (len_a == 0 || path_a[len_a - 1] != '/'))\n    return FALSE;\n\n  if (len_b < len_a && (len_b == 0 || path_b[len_b - 1] != '/'))\n    return FALSE;\n\n  return memcmp (path_a, path_b, MIN (len_a, len_b)) == 0;\n}\n\n/* called in GDBusWorker thread WITH lock held */\nstatic void\nschedule_callbacks (GDBusConnection *connection,\n                    GPtrArray       *signal_data_array,\n                    GDBusMessage    *message,\n                    const gchar     *sender)\n{\n  guint n, m;\n  const gchar *interface;\n  const gchar *member;\n  const gchar *path;\n  const gchar *arg0;\n\n  interface = NULL;\n  member = NULL;\n  path = NULL;\n  arg0 = NULL;\n\n  interface = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  path = g_dbus_message_get_path (message);\n  arg0 = g_dbus_message_get_arg0 (message);\n\n#if 0\n  g_print (\"In schedule_callbacks:\\n\"\n           \"  sender    = '%s'\\n\"\n           \"  interface = '%s'\\n\"\n           \"  member    = '%s'\\n\"\n           \"  path      = '%s'\\n\"\n           \"  arg0      = '%s'\\n\",\n           sender,\n           interface,\n           member,\n           path,\n           arg0);\n#endif\n\n  /* TODO: if this is slow, then we can change signal_data_array into\n   *       map_object_path_to_signal_data_array or something.\n   */\n  for (n = 0; n < signal_data_array->len; n++)\n    {\n      SignalData *signal_data = signal_data_array->pdata[n];\n\n      if (signal_data->interface_name != NULL && g_strcmp0 (signal_data->interface_name, interface) != 0)\n        continue;\n\n      if (signal_data->member != NULL && g_strcmp0 (signal_data->member, member) != 0)\n        continue;\n\n      if (signal_data->object_path != NULL && g_strcmp0 (signal_data->object_path, path) != 0)\n        continue;\n\n      if (signal_data->arg0 != NULL)\n        {\n          if (arg0 == NULL)\n            continue;\n\n          if (signal_data->flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE)\n            {\n              if (!namespace_rule_matches (signal_data->arg0, arg0))\n                continue;\n            }\n          else if (signal_data->flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH)\n            {\n              if (!path_rule_matches (signal_data->arg0, arg0))\n                continue;\n            }\n          else if (!g_str_equal (signal_data->arg0, arg0))\n            continue;\n        }\n\n      for (m = 0; m < signal_data->subscribers->len; m++)\n        {\n          SignalSubscriber *subscriber;\n          GSource *idle_source;\n          SignalInstance *signal_instance;\n\n          subscriber = &(g_array_index (signal_data->subscribers, SignalSubscriber, m));\n\n          signal_instance = g_new0 (SignalInstance, 1);\n          signal_instance->subscription_id = subscriber->id;\n          signal_instance->callback = subscriber->callback;\n          signal_instance->user_data = subscriber->user_data;\n          signal_instance->message = g_object_ref (message);\n          signal_instance->connection = g_object_ref (connection);\n          signal_instance->sender = sender;\n          signal_instance->path = path;\n          signal_instance->interface = interface;\n          signal_instance->member = member;\n\n          idle_source = g_idle_source_new ();\n          g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n          g_source_set_callback (idle_source,\n                                 emit_signal_instance_in_idle_cb,\n                                 signal_instance,\n                                 (GDestroyNotify) signal_instance_free);\n          g_source_set_name (idle_source, \"[gio] emit_signal_instance_in_idle_cb\");\n          g_source_attach (idle_source, subscriber->context);\n          g_source_unref (idle_source);\n        }\n    }\n}\n\n/* called in GDBusWorker thread with lock held */\nstatic void\ndistribute_signals (GDBusConnection *connection,\n                    GDBusMessage    *message)\n{\n  GPtrArray *signal_data_array;\n  const gchar *sender;\n\n  sender = g_dbus_message_get_sender (message);\n\n  if (G_UNLIKELY (_g_dbus_debug_signal ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Signal:\\n\"\n               \" <<<< RECEIVED SIGNAL %s.%s\\n\"\n               \"      on object %s\\n\"\n               \"      sent by name %s\\n\",\n               g_dbus_message_get_interface (message),\n               g_dbus_message_get_member (message),\n               g_dbus_message_get_path (message),\n               sender != NULL ? sender : \"(none)\");\n      _g_dbus_debug_print_unlock ();\n    }\n\n  /* collect subscribers that match on sender */\n  if (sender != NULL)\n    {\n      signal_data_array = g_hash_table_lookup (connection->map_sender_unique_name_to_signal_data_array, sender);\n      if (signal_data_array != NULL)\n        schedule_callbacks (connection, signal_data_array, message, sender);\n    }\n\n  /* collect subscribers not matching on sender */\n  signal_data_array = g_hash_table_lookup (connection->map_sender_unique_name_to_signal_data_array, \"\");\n  if (signal_data_array != NULL)\n    schedule_callbacks (connection, signal_data_array, message, sender);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* only called from finalize(), removes all subscriptions */\nstatic void\npurge_all_signal_subscriptions (GDBusConnection *connection)\n{\n  GHashTableIter iter;\n  gpointer key;\n  GArray *ids;\n  GArray *subscribers;\n  guint n;\n\n  ids = g_array_new (FALSE, FALSE, sizeof (guint));\n  g_hash_table_iter_init (&iter, connection->map_id_to_signal_data);\n  while (g_hash_table_iter_next (&iter, &key, NULL))\n    {\n      guint subscription_id = GPOINTER_TO_UINT (key);\n      g_array_append_val (ids, subscription_id);\n    }\n\n  subscribers = g_array_new (FALSE, FALSE, sizeof (SignalSubscriber));\n  for (n = 0; n < ids->len; n++)\n    {\n      guint subscription_id = g_array_index (ids, guint, n);\n      unsubscribe_id_internal (connection,\n                               subscription_id,\n                               subscribers);\n    }\n  g_array_free (ids, TRUE);\n\n  /* call GDestroyNotify without lock held */\n  for (n = 0; n < subscribers->len; n++)\n    {\n      SignalSubscriber *subscriber;\n      subscriber = &(g_array_index (subscribers, SignalSubscriber, n));\n      call_destroy_notify (subscriber->context,\n                           subscriber->user_data_free_func,\n                           subscriber->user_data);\n      g_main_context_unref (subscriber->context);\n    }\n\n  g_array_free (subscribers, TRUE);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic GDBusInterfaceVTable *\n_g_dbus_interface_vtable_copy (const GDBusInterfaceVTable *vtable)\n{\n  /* Don't waste memory by copying padding - remember to update this\n   * when changing struct _GDBusInterfaceVTable in gdbusconnection.h\n   */\n  return g_memdup ((gconstpointer) vtable, 3 * sizeof (gpointer));\n}\n\nstatic void\n_g_dbus_interface_vtable_free (GDBusInterfaceVTable *vtable)\n{\n  g_free (vtable);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic GDBusSubtreeVTable *\n_g_dbus_subtree_vtable_copy (const GDBusSubtreeVTable *vtable)\n{\n  /* Don't waste memory by copying padding - remember to update this\n   * when changing struct _GDBusSubtreeVTable in gdbusconnection.h\n   */\n  return g_memdup ((gconstpointer) vtable, 3 * sizeof (gpointer));\n}\n\nstatic void\n_g_dbus_subtree_vtable_free (GDBusSubtreeVTable *vtable)\n{\n  g_free (vtable);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstruct ExportedObject\n{\n  gchar *object_path;\n  GDBusConnection *connection;\n\n  /* maps gchar* -> ExportedInterface* */\n  GHashTable *map_if_name_to_ei;\n};\n\n/* only called with lock held */\nstatic void\nexported_object_free (ExportedObject *eo)\n{\n  g_free (eo->object_path);\n  g_hash_table_unref (eo->map_if_name_to_ei);\n  g_free (eo);\n}\n\ntypedef struct\n{\n  ExportedObject *eo;\n\n  guint                       id;\n  gchar                      *interface_name;\n  GDBusInterfaceVTable       *vtable;\n  GDBusInterfaceInfo         *interface_info;\n\n  GMainContext               *context;\n  gpointer                    user_data;\n  GDestroyNotify              user_data_free_func;\n} ExportedInterface;\n\n/* called with lock held */\nstatic void\nexported_interface_free (ExportedInterface *ei)\n{\n  g_dbus_interface_info_cache_release (ei->interface_info);\n  g_dbus_interface_info_unref ((GDBusInterfaceInfo *) ei->interface_info);\n\n  call_destroy_notify (ei->context,\n                       ei->user_data_free_func,\n                       ei->user_data);\n\n  g_main_context_unref (ei->context);\n\n  g_free (ei->interface_name);\n  _g_dbus_interface_vtable_free (ei->vtable);\n  g_free (ei);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Convenience function to check if @registration_id (if not zero) or\n * @subtree_registration_id (if not zero) has been unregistered. If\n * so, returns %TRUE.\n *\n * May be called by any thread. Caller must *not* hold lock.\n */\nstatic gboolean\nhas_object_been_unregistered (GDBusConnection  *connection,\n                              guint             registration_id,\n                              guint             subtree_registration_id)\n{\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n\n  ret = FALSE;\n\n  CONNECTION_LOCK (connection);\n  if (registration_id != 0 && g_hash_table_lookup (connection->map_id_to_ei,\n                                                   GUINT_TO_POINTER (registration_id)) == NULL)\n    {\n      ret = TRUE;\n    }\n  else if (subtree_registration_id != 0 && g_hash_table_lookup (connection->map_id_to_es,\n                                                                GUINT_TO_POINTER (subtree_registration_id)) == NULL)\n    {\n      ret = TRUE;\n    }\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GDBusConnection *connection;\n  GDBusMessage *message;\n  gpointer user_data;\n  const gchar *property_name;\n  const GDBusInterfaceVTable *vtable;\n  GDBusInterfaceInfo *interface_info;\n  const GDBusPropertyInfo *property_info;\n  guint registration_id;\n  guint subtree_registration_id;\n} PropertyData;\n\nstatic void\nproperty_data_free (PropertyData *data)\n{\n  g_object_unref (data->connection);\n  g_object_unref (data->message);\n  g_free (data);\n}\n\n/* called in thread where object was registered - no locks held */\nstatic gboolean\ninvoke_get_property_in_idle_cb (gpointer _data)\n{\n  PropertyData *data = _data;\n  GVariant *value;\n  GError *error;\n  GDBusMessage *reply;\n\n  if (has_object_been_unregistered (data->connection,\n                                    data->registration_id,\n                                    data->subtree_registration_id))\n    {\n      reply = g_dbus_message_new_method_error (data->message,\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"No such interface \u201corg.freedesktop.DBus.Properties\u201d on object at path %s\"),\n                                               g_dbus_message_get_path (data->message));\n      g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      goto out;\n    }\n\n  error = NULL;\n  value = data->vtable->get_property (data->connection,\n                                      g_dbus_message_get_sender (data->message),\n                                      g_dbus_message_get_path (data->message),\n                                      data->interface_info->name,\n                                      data->property_name,\n                                      &error,\n                                      data->user_data);\n\n\n  if (value != NULL)\n    {\n      g_assert_no_error (error);\n\n      g_variant_take_ref (value);\n      reply = g_dbus_message_new_method_reply (data->message);\n      g_dbus_message_set_body (reply, g_variant_new (\"(v)\", value));\n      g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_variant_unref (value);\n      g_object_unref (reply);\n    }\n  else\n    {\n      gchar *dbus_error_name;\n      g_assert (error != NULL);\n      dbus_error_name = g_dbus_error_encode_gerror (error);\n      reply = g_dbus_message_new_method_error_literal (data->message,\n                                                       dbus_error_name,\n                                                       error->message);\n      g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_free (dbus_error_name);\n      g_error_free (error);\n      g_object_unref (reply);\n    }\n\n out:\n  return FALSE;\n}\n\n/* called in thread where object was registered - no locks held */\nstatic gboolean\ninvoke_set_property_in_idle_cb (gpointer _data)\n{\n  PropertyData *data = _data;\n  GError *error;\n  GDBusMessage *reply;\n  GVariant *value;\n\n  error = NULL;\n  value = NULL;\n\n  g_variant_get (g_dbus_message_get_body (data->message),\n                 \"(ssv)\",\n                 NULL,\n                 NULL,\n                 &value);\n\n  if (!data->vtable->set_property (data->connection,\n                                   g_dbus_message_get_sender (data->message),\n                                   g_dbus_message_get_path (data->message),\n                                   data->interface_info->name,\n                                   data->property_name,\n                                   value,\n                                   &error,\n                                   data->user_data))\n    {\n      gchar *dbus_error_name;\n      g_assert (error != NULL);\n      dbus_error_name = g_dbus_error_encode_gerror (error);\n      reply = g_dbus_message_new_method_error_literal (data->message,\n                                                       dbus_error_name,\n                                                       error->message);\n      g_free (dbus_error_name);\n      g_error_free (error);\n    }\n  else\n    {\n      reply = g_dbus_message_new_method_reply (data->message);\n    }\n\n  g_assert (reply != NULL);\n  g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n  g_variant_unref (value);\n\n  return FALSE;\n}\n\n/* called in any thread with connection's lock held */\nstatic gboolean\nvalidate_and_maybe_schedule_property_getset (GDBusConnection            *connection,\n                                             GDBusMessage               *message,\n                                             guint                       registration_id,\n                                             guint                       subtree_registration_id,\n                                             gboolean                    is_get,\n                                             GDBusInterfaceInfo         *interface_info,\n                                             const GDBusInterfaceVTable *vtable,\n                                             GMainContext               *main_context,\n                                             gpointer                    user_data)\n{\n  gboolean handled;\n  const char *interface_name;\n  const char *property_name;\n  const GDBusPropertyInfo *property_info;\n  GSource *idle_source;\n  PropertyData *property_data;\n  GDBusMessage *reply;\n\n  handled = FALSE;\n\n  if (is_get)\n    g_variant_get (g_dbus_message_get_body (message),\n                   \"(&s&s)\",\n                   &interface_name,\n                   &property_name);\n  else\n    g_variant_get (g_dbus_message_get_body (message),\n                   \"(&s&sv)\",\n                   &interface_name,\n                   &property_name,\n                   NULL);\n\n  if (vtable == NULL)\n    goto out;\n\n  /* Check that the property exists - if not fail with org.freedesktop.DBus.Error.InvalidArgs\n   */\n  property_info = NULL;\n\n  /* TODO: the cost of this is O(n) - it might be worth caching the result */\n  property_info = g_dbus_interface_info_lookup_property (interface_info, property_name);\n  if (property_info == NULL)\n    {\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"No such property \u201c%s\u201d\"),\n                                               property_name);\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  if (is_get && !(property_info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE))\n    {\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"Property \u201c%s\u201d is not readable\"),\n                                               property_name);\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n  else if (!is_get && !(property_info->flags & G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE))\n    {\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"Property \u201c%s\u201d is not writable\"),\n                                               property_name);\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  if (!is_get)\n    {\n      GVariant *value;\n\n      /* Fail with org.freedesktop.DBus.Error.InvalidArgs if the type\n       * of the given value is wrong\n       */\n      g_variant_get_child (g_dbus_message_get_body (message), 2, \"v\", &value);\n      if (g_strcmp0 (g_variant_get_type_string (value), property_info->signature) != 0)\n        {\n          reply = g_dbus_message_new_method_error (message,\n                                                   \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                                   _(\"Error setting property \u201c%s\u201d: Expected type \u201c%s\u201d but got \u201c%s\u201d\"),\n                                                   property_name, property_info->signature,\n                                                   g_variant_get_type_string (value));\n          g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n          g_variant_unref (value);\n          g_object_unref (reply);\n          handled = TRUE;\n          goto out;\n        }\n\n      g_variant_unref (value);\n    }\n\n  /* If the vtable pointer for get_property() resp. set_property() is\n   * NULL then dispatch the call via the method_call() handler.\n   */\n  if (is_get)\n    {\n      if (vtable->get_property == NULL)\n        {\n          schedule_method_call (connection, message, registration_id, subtree_registration_id,\n                                interface_info, NULL, property_info, g_dbus_message_get_body (message),\n                                vtable, main_context, user_data);\n          handled = TRUE;\n          goto out;\n        }\n    }\n  else\n    {\n      if (vtable->set_property == NULL)\n        {\n          schedule_method_call (connection, message, registration_id, subtree_registration_id,\n                                interface_info, NULL, property_info, g_dbus_message_get_body (message),\n                                vtable, main_context, user_data);\n          handled = TRUE;\n          goto out;\n        }\n    }\n\n  /* ok, got the property info - call user code in an idle handler */\n  property_data = g_new0 (PropertyData, 1);\n  property_data->connection = g_object_ref (connection);\n  property_data->message = g_object_ref (message);\n  property_data->user_data = user_data;\n  property_data->property_name = property_name;\n  property_data->vtable = vtable;\n  property_data->interface_info = interface_info;\n  property_data->property_info = property_info;\n  property_data->registration_id = registration_id;\n  property_data->subtree_registration_id = subtree_registration_id;\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         is_get ? invoke_get_property_in_idle_cb : invoke_set_property_in_idle_cb,\n                         property_data,\n                         (GDestroyNotify) property_data_free);\n  if (is_get)\n    g_source_set_name (idle_source, \"[gio] invoke_get_property_in_idle_cb\");\n  else\n    g_source_set_name (idle_source, \"[gio] invoke_set_property_in_idle_cb\");\n  g_source_attach (idle_source, main_context);\n  g_source_unref (idle_source);\n\n  handled = TRUE;\n\n out:\n  return handled;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nhandle_getset_property (GDBusConnection *connection,\n                        ExportedObject  *eo,\n                        GDBusMessage    *message,\n                        gboolean         is_get)\n{\n  ExportedInterface *ei;\n  gboolean handled;\n  const char *interface_name;\n  const char *property_name;\n\n  handled = FALSE;\n\n  if (is_get)\n    g_variant_get (g_dbus_message_get_body (message),\n                   \"(&s&s)\",\n                   &interface_name,\n                   &property_name);\n  else\n    g_variant_get (g_dbus_message_get_body (message),\n                   \"(&s&sv)\",\n                   &interface_name,\n                   &property_name,\n                   NULL);\n\n  /* Fail with org.freedesktop.DBus.Error.InvalidArgs if there is\n   * no such interface registered\n   */\n  ei = g_hash_table_lookup (eo->map_if_name_to_ei, interface_name);\n  if (ei == NULL)\n    {\n      GDBusMessage *reply;\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"No such interface \u201c%s\u201d\"),\n                                               interface_name);\n      g_dbus_connection_send_message_unlocked (eo->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  handled = validate_and_maybe_schedule_property_getset (eo->connection,\n                                                         message,\n                                                         ei->id,\n                                                         0,\n                                                         is_get,\n                                                         ei->interface_info,\n                                                         ei->vtable,\n                                                         ei->context,\n                                                         ei->user_data);\n out:\n  return handled;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GDBusConnection *connection;\n  GDBusMessage *message;\n  gpointer user_data;\n  const GDBusInterfaceVTable *vtable;\n  GDBusInterfaceInfo *interface_info;\n  guint registration_id;\n  guint subtree_registration_id;\n} PropertyGetAllData;\n\nstatic void\nproperty_get_all_data_free (PropertyData *data)\n{\n  g_object_unref (data->connection);\n  g_object_unref (data->message);\n  g_free (data);\n}\n\n/* called in thread where object was registered - no locks held */\nstatic gboolean\ninvoke_get_all_properties_in_idle_cb (gpointer _data)\n{\n  PropertyGetAllData *data = _data;\n  GVariantBuilder builder;\n  GDBusMessage *reply;\n  guint n;\n\n  if (has_object_been_unregistered (data->connection,\n                                    data->registration_id,\n                                    data->subtree_registration_id))\n    {\n      reply = g_dbus_message_new_method_error (data->message,\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"No such interface \u201corg.freedesktop.DBus.Properties\u201d on object at path %s\"),\n                                               g_dbus_message_get_path (data->message));\n      g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      goto out;\n    }\n\n  /* TODO: Right now we never fail this call - we just omit values if\n   *       a get_property() call is failing.\n   *\n   *       We could fail the whole call if just a single get_property() call\n   *       returns an error. We need clarification in the D-Bus spec about this.\n   */\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"(a{sv})\"));\n  g_variant_builder_open (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n  for (n = 0; data->interface_info->properties != NULL && data->interface_info->properties[n] != NULL; n++)\n    {\n      const GDBusPropertyInfo *property_info = data->interface_info->properties[n];\n      GVariant *value;\n\n      if (!(property_info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE))\n        continue;\n\n      value = data->vtable->get_property (data->connection,\n                                          g_dbus_message_get_sender (data->message),\n                                          g_dbus_message_get_path (data->message),\n                                          data->interface_info->name,\n                                          property_info->name,\n                                          NULL,\n                                          data->user_data);\n\n      if (value == NULL)\n        continue;\n\n      g_variant_take_ref (value);\n      g_variant_builder_add (&builder,\n                             \"{sv}\",\n                             property_info->name,\n                             value);\n      g_variant_unref (value);\n    }\n  g_variant_builder_close (&builder);\n\n  reply = g_dbus_message_new_method_reply (data->message);\n  g_dbus_message_set_body (reply, g_variant_builder_end (&builder));\n  g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n\n out:\n  return FALSE;\n}\n\nstatic gboolean\ninterface_has_readable_properties (GDBusInterfaceInfo *interface_info)\n{\n  gint i;\n\n  if (!interface_info->properties)\n    return FALSE;\n\n  for (i = 0; interface_info->properties[i]; i++)\n    if (interface_info->properties[i]->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)\n      return TRUE;\n\n  return FALSE;\n}\n\n/* called in any thread with connection's lock held */\nstatic gboolean\nvalidate_and_maybe_schedule_property_get_all (GDBusConnection            *connection,\n                                              GDBusMessage               *message,\n                                              guint                       registration_id,\n                                              guint                       subtree_registration_id,\n                                              GDBusInterfaceInfo         *interface_info,\n                                              const GDBusInterfaceVTable *vtable,\n                                              GMainContext               *main_context,\n                                              gpointer                    user_data)\n{\n  gboolean handled;\n  GSource *idle_source;\n  PropertyGetAllData *property_get_all_data;\n\n  handled = FALSE;\n\n  if (vtable == NULL)\n    goto out;\n\n  /* If the vtable pointer for get_property() is NULL but we have a\n   * non-zero number of readable properties, then dispatch the call via\n   * the method_call() handler.\n   */\n  if (vtable->get_property == NULL && interface_has_readable_properties (interface_info))\n    {\n      schedule_method_call (connection, message, registration_id, subtree_registration_id,\n                            interface_info, NULL, NULL, g_dbus_message_get_body (message),\n                            vtable, main_context, user_data);\n      handled = TRUE;\n      goto out;\n    }\n\n  /* ok, got the property info - call user in an idle handler */\n  property_get_all_data = g_new0 (PropertyGetAllData, 1);\n  property_get_all_data->connection = g_object_ref (connection);\n  property_get_all_data->message = g_object_ref (message);\n  property_get_all_data->user_data = user_data;\n  property_get_all_data->vtable = vtable;\n  property_get_all_data->interface_info = interface_info;\n  property_get_all_data->registration_id = registration_id;\n  property_get_all_data->subtree_registration_id = subtree_registration_id;\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         invoke_get_all_properties_in_idle_cb,\n                         property_get_all_data,\n                         (GDestroyNotify) property_get_all_data_free);\n  g_source_set_name (idle_source, \"[gio] invoke_get_all_properties_in_idle_cb\");\n  g_source_attach (idle_source, main_context);\n  g_source_unref (idle_source);\n\n  handled = TRUE;\n\n out:\n  return handled;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nhandle_get_all_properties (GDBusConnection *connection,\n                           ExportedObject  *eo,\n                           GDBusMessage    *message)\n{\n  ExportedInterface *ei;\n  gboolean handled;\n  const char *interface_name;\n\n  handled = FALSE;\n\n  g_variant_get (g_dbus_message_get_body (message),\n                 \"(&s)\",\n                 &interface_name);\n\n  /* Fail with org.freedesktop.DBus.Error.InvalidArgs if there is\n   * no such interface registered\n   */\n  ei = g_hash_table_lookup (eo->map_if_name_to_ei, interface_name);\n  if (ei == NULL)\n    {\n      GDBusMessage *reply;\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"No such interface \u201c%s\u201d\"),\n                                               interface_name);\n      g_dbus_connection_send_message_unlocked (eo->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  handled = validate_and_maybe_schedule_property_get_all (eo->connection,\n                                                          message,\n                                                          ei->id,\n                                                          0,\n                                                          ei->interface_info,\n                                                          ei->vtable,\n                                                          ei->context,\n                                                          ei->user_data);\n out:\n  return handled;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic const gchar introspect_header[] =\n  \"<!DOCTYPE node PUBLIC \\\"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\\\"\\n\"\n  \"                      \\\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\\\">\\n\"\n  \"<!-- GDBus \" PACKAGE_VERSION \" -->\\n\"\n  \"<node>\\n\";\n\nstatic const gchar introspect_tail[] =\n  \"</node>\\n\";\n\nstatic const gchar introspect_properties_interface[] =\n  \"  <interface name=\\\"org.freedesktop.DBus.Properties\\\">\\n\"\n  \"    <method name=\\\"Get\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"interface_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"property_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"v\\\" name=\\\"value\\\" direction=\\\"out\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"    <method name=\\\"GetAll\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"interface_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"a{sv}\\\" name=\\\"properties\\\" direction=\\\"out\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"    <method name=\\\"Set\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"interface_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"property_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"v\\\" name=\\\"value\\\" direction=\\\"in\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"    <signal name=\\\"PropertiesChanged\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"interface_name\\\"/>\\n\"\n  \"      <arg type=\\\"a{sv}\\\" name=\\\"changed_properties\\\"/>\\n\"\n  \"      <arg type=\\\"as\\\" name=\\\"invalidated_properties\\\"/>\\n\"\n  \"    </signal>\\n\"\n  \"  </interface>\\n\";\n\nstatic const gchar introspect_introspectable_interface[] =\n  \"  <interface name=\\\"org.freedesktop.DBus.Introspectable\\\">\\n\"\n  \"    <method name=\\\"Introspect\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"xml_data\\\" direction=\\\"out\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"  </interface>\\n\"\n  \"  <interface name=\\\"org.freedesktop.DBus.Peer\\\">\\n\"\n  \"    <method name=\\\"Ping\\\"/>\\n\"\n  \"    <method name=\\\"GetMachineId\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"machine_uuid\\\" direction=\\\"out\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"  </interface>\\n\";\n\nstatic void\nintrospect_append_header (GString *s)\n{\n  g_string_append (s, introspect_header);\n}\n\nstatic void\nmaybe_add_path (const gchar *path, gsize path_len, const gchar *object_path, GHashTable *set)\n{\n  if (g_str_has_prefix (object_path, path) && strlen (object_path) > path_len && object_path[path_len-1] == '/')\n    {\n      const gchar *begin;\n      const gchar *end;\n      gchar *s;\n\n      begin = object_path + path_len;\n      end = strchr (begin, '/');\n      if (end != NULL)\n        s = g_strndup (begin, end - begin);\n      else\n        s = g_strdup (begin);\n\n      if (!g_hash_table_contains (set, s))\n        g_hash_table_add (set, s);\n      else\n        g_free (s);\n    }\n}\n\n/* TODO: we want a nicer public interface for this */\n/* called in any thread with connection's lock held */\nstatic gchar **\ng_dbus_connection_list_registered_unlocked (GDBusConnection *connection,\n                                            const gchar     *path)\n{\n  GPtrArray *p;\n  gchar **ret;\n  GHashTableIter hash_iter;\n  const gchar *object_path;\n  gsize path_len;\n  GHashTable *set;\n  GList *keys;\n  GList *l;\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  path_len = strlen (path);\n  if (path_len > 1)\n    path_len++;\n\n  set = g_hash_table_new (g_str_hash, g_str_equal);\n\n  g_hash_table_iter_init (&hash_iter, connection->map_object_path_to_eo);\n  while (g_hash_table_iter_next (&hash_iter, (gpointer) &object_path, NULL))\n    maybe_add_path (path, path_len, object_path, set);\n\n  g_hash_table_iter_init (&hash_iter, connection->map_object_path_to_es);\n  while (g_hash_table_iter_next (&hash_iter, (gpointer) &object_path, NULL))\n    maybe_add_path (path, path_len, object_path, set);\n\n  p = g_ptr_array_new ();\n  keys = g_hash_table_get_keys (set);\n  for (l = keys; l != NULL; l = l->next)\n    g_ptr_array_add (p, l->data);\n  g_hash_table_unref (set);\n  g_list_free (keys);\n\n  g_ptr_array_add (p, NULL);\n  ret = (gchar **) g_ptr_array_free (p, FALSE);\n  return ret;\n}\n\n/* called in any thread with connection's lock not held */\nstatic gchar **\ng_dbus_connection_list_registered (GDBusConnection *connection,\n                                   const gchar     *path)\n{\n  gchar **ret;\n  CONNECTION_LOCK (connection);\n  ret = g_dbus_connection_list_registered_unlocked (connection, path);\n  CONNECTION_UNLOCK (connection);\n  return ret;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nhandle_introspect (GDBusConnection *connection,\n                   ExportedObject  *eo,\n                   GDBusMessage    *message)\n{\n  guint n;\n  GString *s;\n  GDBusMessage *reply;\n  GHashTableIter hash_iter;\n  ExportedInterface *ei;\n  gchar **registered;\n\n  /* first the header with the standard interfaces */\n  s = g_string_sized_new (sizeof (introspect_header) +\n                          sizeof (introspect_properties_interface) +\n                          sizeof (introspect_introspectable_interface) +\n                          sizeof (introspect_tail));\n  introspect_append_header (s);\n  if (!g_hash_table_lookup (eo->map_if_name_to_ei,\n                            \"org.freedesktop.DBus.Properties\"))\n    g_string_append (s, introspect_properties_interface);\n\n  if (!g_hash_table_lookup (eo->map_if_name_to_ei,\n                            \"org.freedesktop.DBus.Introspectable\"))\n    g_string_append (s, introspect_introspectable_interface);\n\n  /* then include the registered interfaces */\n  g_hash_table_iter_init (&hash_iter, eo->map_if_name_to_ei);\n  while (g_hash_table_iter_next (&hash_iter, NULL, (gpointer) &ei))\n    g_dbus_interface_info_generate_xml (ei->interface_info, 2, s);\n\n  /* finally include nodes registered below us */\n  registered = g_dbus_connection_list_registered_unlocked (connection, eo->object_path);\n  for (n = 0; registered != NULL && registered[n] != NULL; n++)\n    g_string_append_printf (s, \"  <node name=\\\"%s\\\"/>\\n\", registered[n]);\n  g_strfreev (registered);\n  g_string_append (s, introspect_tail);\n\n  reply = g_dbus_message_new_method_reply (message);\n  g_dbus_message_set_body (reply, g_variant_new (\"(s)\", s->str));\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n  g_string_free (s, TRUE);\n\n  return TRUE;\n}\n\n/* called in thread where object was registered - no locks held */\nstatic gboolean\ncall_in_idle_cb (gpointer user_data)\n{\n  GDBusMethodInvocation *invocation = G_DBUS_METHOD_INVOCATION (user_data);\n  GDBusInterfaceVTable *vtable;\n  guint registration_id;\n  guint subtree_registration_id;\n\n  registration_id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (invocation), \"g-dbus-registration-id\"));\n  subtree_registration_id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (invocation), \"g-dbus-subtree-registration-id\"));\n\n  if (has_object_been_unregistered (g_dbus_method_invocation_get_connection (invocation),\n                                    registration_id,\n                                    subtree_registration_id))\n    {\n      GDBusMessage *reply;\n      reply = g_dbus_message_new_method_error (g_dbus_method_invocation_get_message (invocation),\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"No such interface \u201c%s\u201d on object at path %s\"),\n                                               g_dbus_method_invocation_get_interface_name (invocation),\n                                               g_dbus_method_invocation_get_object_path (invocation));\n      g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      goto out;\n    }\n\n  vtable = g_object_get_data (G_OBJECT (invocation), \"g-dbus-interface-vtable\");\n  g_assert (vtable != NULL && vtable->method_call != NULL);\n\n  vtable->method_call (g_dbus_method_invocation_get_connection (invocation),\n                       g_dbus_method_invocation_get_sender (invocation),\n                       g_dbus_method_invocation_get_object_path (invocation),\n                       g_dbus_method_invocation_get_interface_name (invocation),\n                       g_dbus_method_invocation_get_method_name (invocation),\n                       g_dbus_method_invocation_get_parameters (invocation),\n                       g_object_ref (invocation),\n                       g_dbus_method_invocation_get_user_data (invocation));\n\n out:\n  return FALSE;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic void\nschedule_method_call (GDBusConnection            *connection,\n                      GDBusMessage               *message,\n                      guint                       registration_id,\n                      guint                       subtree_registration_id,\n                      const GDBusInterfaceInfo   *interface_info,\n                      const GDBusMethodInfo      *method_info,\n                      const GDBusPropertyInfo    *property_info,\n                      GVariant                   *parameters,\n                      const GDBusInterfaceVTable *vtable,\n                      GMainContext               *main_context,\n                      gpointer                    user_data)\n{\n  GDBusMethodInvocation *invocation;\n  GSource *idle_source;\n\n  invocation = _g_dbus_method_invocation_new (g_dbus_message_get_sender (message),\n                                              g_dbus_message_get_path (message),\n                                              g_dbus_message_get_interface (message),\n                                              g_dbus_message_get_member (message),\n                                              method_info,\n                                              property_info,\n                                              connection,\n                                              message,\n                                              parameters,\n                                              user_data);\n\n  /* TODO: would be nicer with a real MethodData like we already\n   * have PropertyData and PropertyGetAllData... */\n  g_object_set_data (G_OBJECT (invocation), \"g-dbus-interface-vtable\", (gpointer) vtable);\n  g_object_set_data (G_OBJECT (invocation), \"g-dbus-registration-id\", GUINT_TO_POINTER (registration_id));\n  g_object_set_data (G_OBJECT (invocation), \"g-dbus-subtree-registration-id\", GUINT_TO_POINTER (subtree_registration_id));\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         call_in_idle_cb,\n                         invocation,\n                         g_object_unref);\n  g_source_set_name (idle_source, \"[gio, \" __FILE__ \"] call_in_idle_cb\");\n  g_source_attach (idle_source, main_context);\n  g_source_unref (idle_source);\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nvalidate_and_maybe_schedule_method_call (GDBusConnection            *connection,\n                                         GDBusMessage               *message,\n                                         guint                       registration_id,\n                                         guint                       subtree_registration_id,\n                                         GDBusInterfaceInfo         *interface_info,\n                                         const GDBusInterfaceVTable *vtable,\n                                         GMainContext               *main_context,\n                                         gpointer                    user_data)\n{\n  GDBusMethodInfo *method_info;\n  GDBusMessage *reply;\n  GVariant *parameters;\n  gboolean handled;\n  GVariantType *in_type;\n\n  handled = FALSE;\n\n  /* TODO: the cost of this is O(n) - it might be worth caching the result */\n  method_info = g_dbus_interface_info_lookup_method (interface_info, g_dbus_message_get_member (message));\n\n  /* if the method doesn't exist, return the org.freedesktop.DBus.Error.UnknownMethod\n   * error to the caller\n   */\n  if (method_info == NULL)\n    {\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"No such method \u201c%s\u201d\"),\n                                               g_dbus_message_get_member (message));\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  parameters = g_dbus_message_get_body (message);\n  if (parameters == NULL)\n    {\n      parameters = g_variant_new (\"()\");\n      g_variant_ref_sink (parameters);\n    }\n  else\n    {\n      g_variant_ref (parameters);\n    }\n\n  /* Check that the incoming args are of the right type - if they are not, return\n   * the org.freedesktop.DBus.Error.InvalidArgs error to the caller\n   */\n  in_type = _g_dbus_compute_complete_signature (method_info->in_args);\n  if (!g_variant_is_of_type (parameters, in_type))\n    {\n      gchar *type_string;\n\n      type_string = g_variant_type_dup_string (in_type);\n\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"Type of message, \u201c%s\u201d, does not match expected type \u201c%s\u201d\"),\n                                               g_variant_get_type_string (parameters),\n                                               type_string);\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_variant_type_free (in_type);\n      g_variant_unref (parameters);\n      g_object_unref (reply);\n      g_free (type_string);\n      handled = TRUE;\n      goto out;\n    }\n  g_variant_type_free (in_type);\n\n  /* schedule the call in idle */\n  schedule_method_call (connection, message, registration_id, subtree_registration_id,\n                        interface_info, method_info, NULL, parameters,\n                        vtable, main_context, user_data);\n  g_variant_unref (parameters);\n  handled = TRUE;\n\n out:\n  return handled;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nobj_message_func (GDBusConnection *connection,\n                  ExportedObject  *eo,\n                  GDBusMessage    *message)\n{\n  const gchar *interface_name;\n  const gchar *member;\n  const gchar *signature;\n  gboolean handled;\n\n  handled = FALSE;\n\n  interface_name = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  signature = g_dbus_message_get_signature (message);\n\n  /* see if we have an interface for handling this call */\n  if (interface_name != NULL)\n    {\n      ExportedInterface *ei;\n      ei = g_hash_table_lookup (eo->map_if_name_to_ei, interface_name);\n      if (ei != NULL)\n        {\n          /* we do - invoke the handler in idle in the right thread */\n\n          /* handle no vtable or handler being present */\n          if (ei->vtable == NULL || ei->vtable->method_call == NULL)\n            goto out;\n\n          handled = validate_and_maybe_schedule_method_call (connection,\n                                                             message,\n                                                             ei->id,\n                                                             0,\n                                                             ei->interface_info,\n                                                             ei->vtable,\n                                                             ei->context,\n                                                             ei->user_data);\n          goto out;\n        }\n    }\n\n  if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Introspectable\") == 0 &&\n      g_strcmp0 (member, \"Introspect\") == 0 &&\n      g_strcmp0 (signature, \"\") == 0)\n    {\n      handled = handle_introspect (connection, eo, message);\n      goto out;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Properties\") == 0 &&\n           g_strcmp0 (member, \"Get\") == 0 &&\n           g_strcmp0 (signature, \"ss\") == 0)\n    {\n      handled = handle_getset_property (connection, eo, message, TRUE);\n      goto out;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Properties\") == 0 &&\n           g_strcmp0 (member, \"Set\") == 0 &&\n           g_strcmp0 (signature, \"ssv\") == 0)\n    {\n      handled = handle_getset_property (connection, eo, message, FALSE);\n      goto out;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Properties\") == 0 &&\n           g_strcmp0 (member, \"GetAll\") == 0 &&\n           g_strcmp0 (signature, \"s\") == 0)\n    {\n      handled = handle_get_all_properties (connection, eo, message);\n      goto out;\n    }\n\n out:\n  return handled;\n}\n\n/**\n * g_dbus_connection_register_object:\n * @connection: a #GDBusConnection\n * @object_path: the object path to register at\n * @interface_info: introspection data for the interface\n * @vtable: (nullable): a #GDBusInterfaceVTable to call into or %NULL\n * @user_data: (nullable): data to pass to functions in @vtable\n * @user_data_free_func: function to call when the object path is unregistered\n * @error: return location for error or %NULL\n *\n * Registers callbacks for exported objects at @object_path with the\n * D-Bus interface that is described in @interface_info.\n *\n * Calls to functions in @vtable (and @user_data_free_func) will happen\n * in the \n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from.\n *\n * Note that all #GVariant values passed to functions in @vtable will match\n * the signature given in @interface_info - if a remote caller passes\n * incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`\n * is returned to the remote caller.\n *\n * Additionally, if the remote caller attempts to invoke methods or\n * access properties not mentioned in @interface_info the\n * `org.freedesktop.DBus.Error.UnknownMethod` resp.\n * `org.freedesktop.DBus.Error.InvalidArgs` errors\n * are returned to the caller.\n *\n * It is considered a programming error if the\n * #GDBusInterfaceGetPropertyFunc function in @vtable returns a\n * #GVariant of incorrect type.\n *\n * If an existing callback is already registered at @object_path and\n * @interface_name, then @error is set to #G_IO_ERROR_EXISTS.\n *\n * GDBus automatically implements the standard D-Bus interfaces\n * org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable\n * and org.freedesktop.Peer, so you don't have to implement those for the\n * objects you export. You can implement org.freedesktop.DBus.Properties\n * yourself, e.g. to handle getting and setting of properties asynchronously.\n *\n * Note that the reference count on @interface_info will be\n * incremented by 1 (unless allocated statically, e.g. if the\n * reference count is -1, see g_dbus_interface_info_ref()) for as long\n * as the object is exported. Also note that @vtable will be copied.\n *\n * See this [server][gdbus-server] for an example of how to use this method.\n *\n * Returns: 0 if @error is set, otherwise a registration id (never 0)\n *     that can be used with g_dbus_connection_unregister_object()\n *\n * Since: 2.26\n */\nguint\ng_dbus_connection_register_object (GDBusConnection             *connection,\n                                   const gchar                 *object_path,\n                                   GDBusInterfaceInfo          *interface_info,\n                                   const GDBusInterfaceVTable  *vtable,\n                                   gpointer                     user_data,\n                                   GDestroyNotify               user_data_free_func,\n                                   GError                     **error)\n{\n  ExportedObject *eo;\n  ExportedInterface *ei;\n  guint ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n  g_return_val_if_fail (object_path != NULL && g_variant_is_object_path (object_path), 0);\n  g_return_val_if_fail (interface_info != NULL, 0);\n  g_return_val_if_fail (g_dbus_is_interface_name (interface_info->name), 0);\n  g_return_val_if_fail (error == NULL || *error == NULL, 0);\n  g_return_val_if_fail (check_initialized (connection), 0);\n\n  ret = 0;\n\n  CONNECTION_LOCK (connection);\n\n  eo = g_hash_table_lookup (connection->map_object_path_to_eo, object_path);\n  if (eo == NULL)\n    {\n      eo = g_new0 (ExportedObject, 1);\n      eo->object_path = g_strdup (object_path);\n      eo->connection = connection;\n      eo->map_if_name_to_ei = g_hash_table_new_full (g_str_hash,\n                                                     g_str_equal,\n                                                     NULL,\n                                                     (GDestroyNotify) exported_interface_free);\n      g_hash_table_insert (connection->map_object_path_to_eo, eo->object_path, eo);\n    }\n\n  ei = g_hash_table_lookup (eo->map_if_name_to_ei, interface_info->name);\n  if (ei != NULL)\n    {\n      g_set_error (error,\n                   G_IO_ERROR,\n                   G_IO_ERROR_EXISTS,\n                   _(\"An object is already exported for the interface %s at %s\"),\n                   interface_info->name,\n                   object_path);\n      goto out;\n    }\n\n  ei = g_new0 (ExportedInterface, 1);\n  ei->id = g_atomic_int_add (&_global_registration_id, 1); /* TODO: overflow etc. */\n  ei->eo = eo;\n  ei->user_data = user_data;\n  ei->user_data_free_func = user_data_free_func;\n  ei->vtable = _g_dbus_interface_vtable_copy (vtable);\n  ei->interface_info = g_dbus_interface_info_ref (interface_info);\n  g_dbus_interface_info_cache_build (ei->interface_info);\n  ei->interface_name = g_strdup (interface_info->name);\n  ei->context = g_main_context_ref_thread_default ();\n\n  g_hash_table_insert (eo->map_if_name_to_ei,\n                       (gpointer) ei->interface_name,\n                       ei);\n  g_hash_table_insert (connection->map_id_to_ei,\n                       GUINT_TO_POINTER (ei->id),\n                       ei);\n\n  ret = ei->id;\n\n out:\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/**\n * g_dbus_connection_unregister_object:\n * @connection: a #GDBusConnection\n * @registration_id: a registration id obtained from\n *     g_dbus_connection_register_object()\n *\n * Unregisters an object.\n *\n * Returns: %TRUE if the object was unregistered, %FALSE otherwise\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_unregister_object (GDBusConnection *connection,\n                                     guint            registration_id)\n{\n  ExportedInterface *ei;\n  ExportedObject *eo;\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (check_initialized (connection), FALSE);\n\n  ret = FALSE;\n\n  CONNECTION_LOCK (connection);\n\n  ei = g_hash_table_lookup (connection->map_id_to_ei,\n                            GUINT_TO_POINTER (registration_id));\n  if (ei == NULL)\n    goto out;\n\n  eo = ei->eo;\n\n  g_warn_if_fail (g_hash_table_remove (connection->map_id_to_ei, GUINT_TO_POINTER (ei->id)));\n  g_warn_if_fail (g_hash_table_remove (eo->map_if_name_to_ei, ei->interface_name));\n  /* unregister object path if we have no more exported interfaces */\n  if (g_hash_table_size (eo->map_if_name_to_ei) == 0)\n    g_warn_if_fail (g_hash_table_remove (connection->map_object_path_to_eo,\n                                         eo->object_path));\n\n  ret = TRUE;\n\n out:\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\ntypedef struct {\n  GClosure *method_call_closure;\n  GClosure *get_property_closure;\n  GClosure *set_property_closure;\n} RegisterObjectData;\n\nstatic RegisterObjectData *\nregister_object_data_new (GClosure *method_call_closure,\n                          GClosure *get_property_closure,\n                          GClosure *set_property_closure)\n{\n  RegisterObjectData *data;\n\n  data = g_new0 (RegisterObjectData, 1);\n\n  if (method_call_closure != NULL)\n    {\n      data->method_call_closure = g_closure_ref (method_call_closure);\n      g_closure_sink (method_call_closure);\n      if (G_CLOSURE_NEEDS_MARSHAL (method_call_closure))\n        g_closure_set_marshal (method_call_closure, g_cclosure_marshal_generic);\n    }\n\n  if (get_property_closure != NULL)\n    {\n      data->get_property_closure = g_closure_ref (get_property_closure);\n      g_closure_sink (get_property_closure);\n      if (G_CLOSURE_NEEDS_MARSHAL (get_property_closure))\n        g_closure_set_marshal (get_property_closure, g_cclosure_marshal_generic);\n    }\n\n  if (set_property_closure != NULL)\n    {\n      data->set_property_closure = g_closure_ref (set_property_closure);\n      g_closure_sink (set_property_closure);\n      if (G_CLOSURE_NEEDS_MARSHAL (set_property_closure))\n        g_closure_set_marshal (set_property_closure, g_cclosure_marshal_generic);\n    }\n\n  return data;\n}\n\nstatic void\nregister_object_free_func (gpointer user_data)\n{\n  RegisterObjectData *data = user_data;\n\n  g_clear_pointer (&data->method_call_closure, g_closure_unref);\n  g_clear_pointer (&data->get_property_closure, g_closure_unref);\n  g_clear_pointer (&data->set_property_closure, g_closure_unref);\n\n  g_free (data);\n}\n\nstatic void\nregister_with_closures_on_method_call (GDBusConnection       *connection,\n                                       const gchar           *sender,\n                                       const gchar           *object_path,\n                                       const gchar           *interface_name,\n                                       const gchar           *method_name,\n                                       GVariant              *parameters,\n                                       GDBusMethodInvocation *invocation,\n                                       gpointer               user_data)\n{\n  RegisterObjectData *data = user_data;\n  GValue params[] = { G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT };\n\n  g_value_init (&params[0], G_TYPE_DBUS_CONNECTION);\n  g_value_set_object (&params[0], connection);\n\n  g_value_init (&params[1], G_TYPE_STRING);\n  g_value_set_string (&params[1], sender);\n\n  g_value_init (&params[2], G_TYPE_STRING);\n  g_value_set_string (&params[2], object_path);\n\n  g_value_init (&params[3], G_TYPE_STRING);\n  g_value_set_string (&params[3], interface_name);\n\n  g_value_init (&params[4], G_TYPE_STRING);\n  g_value_set_string (&params[4], method_name);\n\n  g_value_init (&params[5], G_TYPE_VARIANT);\n  g_value_set_variant (&params[5], parameters);\n\n  g_value_init (&params[6], G_TYPE_DBUS_METHOD_INVOCATION);\n  g_value_set_object (&params[6], invocation);\n\n  g_closure_invoke (data->method_call_closure, NULL, G_N_ELEMENTS (params), params, NULL);\n\n  g_value_unset (params + 0);\n  g_value_unset (params + 1);\n  g_value_unset (params + 2);\n  g_value_unset (params + 3);\n  g_value_unset (params + 4);\n  g_value_unset (params + 5);\n  g_value_unset (params + 6);\n}\n\nstatic GVariant *\nregister_with_closures_on_get_property (GDBusConnection *connection,\n                                        const gchar     *sender,\n                                        const gchar     *object_path,\n                                        const gchar     *interface_name,\n                                        const gchar     *property_name,\n                                        GError         **error,\n                                        gpointer         user_data)\n{\n  RegisterObjectData *data = user_data;\n  GValue params[] = { G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT };\n  GValue result_value = G_VALUE_INIT;\n  GVariant *result;\n\n  g_value_init (&params[0], G_TYPE_DBUS_CONNECTION);\n  g_value_set_object (&params[0], connection);\n\n  g_value_init (&params[1], G_TYPE_STRING);\n  g_value_set_string (&params[1], sender);\n\n  g_value_init (&params[2], G_TYPE_STRING);\n  g_value_set_string (&params[2], object_path);\n\n  g_value_init (&params[3], G_TYPE_STRING);\n  g_value_set_string (&params[3], interface_name);\n\n  g_value_init (&params[4], G_TYPE_STRING);\n  g_value_set_string (&params[4], property_name);\n\n  g_value_init (&result_value, G_TYPE_VARIANT);\n\n  g_closure_invoke (data->get_property_closure, &result_value, G_N_ELEMENTS (params), params, NULL);\n\n  result = g_value_get_variant (&result_value);\n  if (result)\n    g_variant_ref (result);\n\n  g_value_unset (params + 0);\n  g_value_unset (params + 1);\n  g_value_unset (params + 2);\n  g_value_unset (params + 3);\n  g_value_unset (params + 4);\n  g_value_unset (&result_value);\n\n  if (!result)\n    g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_FAILED,\n                 _(\"Unable to retrieve property %s.%s\"),\n                 interface_name, property_name);\n\n  return result;\n}\n\nstatic gboolean\nregister_with_closures_on_set_property (GDBusConnection *connection,\n                                        const gchar     *sender,\n                                        const gchar     *object_path,\n                                        const gchar     *interface_name,\n                                        const gchar     *property_name,\n                                        GVariant        *value,\n                                        GError         **error,\n                                        gpointer         user_data)\n{\n  RegisterObjectData *data = user_data;\n  GValue params[] = { G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT };\n  GValue result_value = G_VALUE_INIT;\n  gboolean result;\n\n  g_value_init (&params[0], G_TYPE_DBUS_CONNECTION);\n  g_value_set_object (&params[0], connection);\n\n  g_value_init (&params[1], G_TYPE_STRING);\n  g_value_set_string (&params[1], sender);\n\n  g_value_init (&params[2], G_TYPE_STRING);\n  g_value_set_string (&params[2], object_path);\n\n  g_value_init (&params[3], G_TYPE_STRING);\n  g_value_set_string (&params[3], interface_name);\n\n  g_value_init (&params[4], G_TYPE_STRING);\n  g_value_set_string (&params[4], property_name);\n\n  g_value_init (&params[5], G_TYPE_VARIANT);\n  g_value_set_variant (&params[5], value);\n\n  g_value_init (&result_value, G_TYPE_BOOLEAN);\n\n  g_closure_invoke (data->set_property_closure, &result_value, G_N_ELEMENTS (params), params, NULL);\n\n  result = g_value_get_boolean (&result_value);\n\n  g_value_unset (params + 0);\n  g_value_unset (params + 1);\n  g_value_unset (params + 2);\n  g_value_unset (params + 3);\n  g_value_unset (params + 4);\n  g_value_unset (params + 5);\n  g_value_unset (&result_value);\n\n  if (!result)\n    g_set_error (error,\n                 G_DBUS_ERROR, G_DBUS_ERROR_FAILED,\n                 _(\"Unable to set property %s.%s\"),\n                 interface_name, property_name);\n\n  return result;\n}\n\n/**\n * g_dbus_connection_register_object_with_closures: (rename-to g_dbus_connection_register_object)\n * @connection: A #GDBusConnection.\n * @object_path: The object path to register at.\n * @interface_info: Introspection data for the interface.\n * @method_call_closure: (nullable): #GClosure for handling incoming method calls.\n * @get_property_closure: (nullable): #GClosure for getting a property.\n * @set_property_closure: (nullable): #GClosure for setting a property.\n * @error: Return location for error or %NULL.\n *\n * Version of g_dbus_connection_register_object() using closures instead of a\n * #GDBusInterfaceVTable for easier binding in other languages.\n *\n * Returns: 0 if @error is set, otherwise a registration id (never 0)\n * that can be used with g_dbus_connection_unregister_object() .\n *\n * Since: 2.46\n */\nguint\ng_dbus_connection_register_object_with_closures (GDBusConnection     *connection,\n                                                 const gchar         *object_path,\n                                                 GDBusInterfaceInfo  *interface_info,\n                                                 GClosure            *method_call_closure,\n                                                 GClosure            *get_property_closure,\n                                                 GClosure            *set_property_closure,\n                                                 GError             **error)\n{\n  RegisterObjectData *data;\n  GDBusInterfaceVTable vtable =\n    {\n      method_call_closure != NULL  ? register_with_closures_on_method_call  : NULL,\n      get_property_closure != NULL ? register_with_closures_on_get_property : NULL,\n      set_property_closure != NULL ? register_with_closures_on_set_property : NULL\n    };\n\n  data = register_object_data_new (method_call_closure, get_property_closure, set_property_closure);\n\n  return g_dbus_connection_register_object (connection,\n                                            object_path,\n                                            interface_info,\n                                            &vtable,\n                                            data,\n                                            register_object_free_func,\n                                            error);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_emit_signal:\n * @connection: a #GDBusConnection\n * @destination_bus_name: (nullable): the unique bus name for the destination\n *     for the signal or %NULL to emit to all listeners\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to emit a signal on\n * @signal_name: the name of the signal to emit\n * @parameters: (nullable): a #GVariant tuple with parameters for the signal\n *              or %NULL if not passing parameters\n * @error: Return location for error or %NULL\n *\n * Emits a signal.\n *\n * If the parameters GVariant is floating, it is consumed.\n *\n * This can only fail if @parameters is not compatible with the D-Bus protocol\n * (%G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed\n * (%G_IO_ERROR_CLOSED).\n *\n * Returns: %TRUE unless @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_emit_signal (GDBusConnection  *connection,\n                               const gchar      *destination_bus_name,\n                               const gchar      *object_path,\n                               const gchar      *interface_name,\n                               const gchar      *signal_name,\n                               GVariant         *parameters,\n                               GError          **error)\n{\n  GDBusMessage *message;\n  gboolean ret;\n\n  message = NULL;\n  ret = FALSE;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (destination_bus_name == NULL || g_dbus_is_name (destination_bus_name), FALSE);\n  g_return_val_if_fail (object_path != NULL && g_variant_is_object_path (object_path), FALSE);\n  g_return_val_if_fail (interface_name != NULL && g_dbus_is_interface_name (interface_name), FALSE);\n  g_return_val_if_fail (signal_name != NULL && g_dbus_is_member_name (signal_name), FALSE);\n  g_return_val_if_fail (parameters == NULL || g_variant_is_of_type (parameters, G_VARIANT_TYPE_TUPLE), FALSE);\n  g_return_val_if_fail (check_initialized (connection), FALSE);\n\n  if (G_UNLIKELY (_g_dbus_debug_emission ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Emission:\\n\"\n               \" >>>> SIGNAL EMISSION %s.%s()\\n\"\n               \"      on object %s\\n\"\n               \"      destination %s\\n\",\n               interface_name, signal_name,\n               object_path,\n               destination_bus_name != NULL ? destination_bus_name : \"(none)\");\n      _g_dbus_debug_print_unlock ();\n    }\n\n  message = g_dbus_message_new_signal (object_path,\n                                       interface_name,\n                                       signal_name);\n\n  if (destination_bus_name != NULL)\n    g_dbus_message_set_header (message,\n                               G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION,\n                               g_variant_new_string (destination_bus_name));\n\n  if (parameters != NULL)\n    g_dbus_message_set_body (message, parameters);\n\n  ret = g_dbus_connection_send_message (connection, message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, error);\n  g_object_unref (message);\n\n  return ret;\n}\n\nstatic void\nadd_call_flags (GDBusMessage           *message,\n                         GDBusCallFlags  flags)\n{\n  GDBusMessageFlags msg_flags = 0;\n\n  if (flags & G_DBUS_CALL_FLAGS_NO_AUTO_START)\n    msg_flags |= G_DBUS_MESSAGE_FLAGS_NO_AUTO_START;\n  if (flags & G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)\n    msg_flags |= G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION;\n  if (msg_flags)\n    g_dbus_message_set_flags (message, msg_flags);\n}\n\nstatic GVariant *\ndecode_method_reply (GDBusMessage        *reply,\n                     const gchar         *method_name,\n                     const GVariantType  *reply_type,\n                     GUnixFDList        **out_fd_list,\n                     GError             **error)\n{\n  GVariant *result;\n\n  result = NULL;\n  switch (g_dbus_message_get_message_type (reply))\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n      result = g_dbus_message_get_body (reply);\n      if (result == NULL)\n        {\n          result = g_variant_new (\"()\");\n          g_variant_ref_sink (result);\n        }\n      else\n        {\n          g_variant_ref (result);\n        }\n\n      if (!g_variant_is_of_type (result, reply_type))\n        {\n          gchar *type_string = g_variant_type_dup_string (reply_type);\n\n          g_set_error (error,\n                       G_IO_ERROR,\n                       G_IO_ERROR_INVALID_ARGUMENT,\n                       _(\"Method \u201c%s\u201d returned type \u201c%s\u201d, but expected \u201c%s\u201d\"),\n                       method_name, g_variant_get_type_string (result), type_string);\n\n          g_variant_unref (result);\n          g_free (type_string);\n          result = NULL;\n        }\n\n#ifdef G_OS_UNIX\n      if (result != NULL)\n        {\n          if (out_fd_list != NULL)\n            {\n              *out_fd_list = g_dbus_message_get_unix_fd_list (reply);\n              if (*out_fd_list != NULL)\n                g_object_ref (*out_fd_list);\n            }\n        }\n#endif\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n      g_dbus_message_to_gerror (reply, error);\n      break;\n\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  return result;\n}\n\n\ntypedef struct\n{\n  GVariantType *reply_type;\n  gchar *method_name; /* for error message */\n\n  GUnixFDList *fd_list;\n} CallState;\n\nstatic void\ncall_state_free (CallState *state)\n{\n  g_variant_type_free (state->reply_type);\n  g_free (state->method_name);\n\n  if (state->fd_list != NULL)\n    g_object_unref (state->fd_list);\n  g_slice_free (CallState, state);\n}\n\n/* called in any thread, with the connection's lock not held */\nstatic void\ng_dbus_connection_call_done (GObject      *source,\n                             GAsyncResult *result,\n                             gpointer      user_data)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (source);\n  GTask *task = user_data;\n  CallState *state = g_task_get_task_data (task);\n  GError *error = NULL;\n  GDBusMessage *reply;\n  GVariant *value = NULL;\n\n  reply = g_dbus_connection_send_message_with_reply_finish (connection,\n                                                            result,\n                                                            &error);\n\n  if (G_UNLIKELY (_g_dbus_debug_call ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Call:\\n\"\n               \" <<<< ASYNC COMPLETE %s() (serial %d)\\n\"\n               \"      \",\n               state->method_name,\n               g_dbus_message_get_reply_serial (reply));\n      if (reply != NULL)\n        {\n          g_print (\"SUCCESS\\n\");\n        }\n      else\n        {\n          g_print (\"FAILED: %s\\n\",\n                   error->message);\n        }\n      _g_dbus_debug_print_unlock ();\n    }\n\n  if (reply != NULL)\n    value = decode_method_reply (reply, state->method_name, state->reply_type, &state->fd_list, &error);\n\n  if (error != NULL)\n    g_task_return_error (task, error);\n  else\n    g_task_return_pointer (task, value, (GDestroyNotify) g_variant_unref);\n\n  g_clear_object (&reply);\n  g_object_unref (task);\n}\n\n/* called in any thread, with the connection's lock not held */\nstatic void\ng_dbus_connection_call_internal (GDBusConnection        *connection,\n                                 const gchar            *bus_name,\n                                 const gchar            *object_path,\n                                 const gchar            *interface_name,\n                                 const gchar            *method_name,\n                                 GVariant               *parameters,\n                                 const GVariantType     *reply_type,\n                                 GDBusCallFlags          flags,\n                                 gint                    timeout_msec,\n                                 GUnixFDList            *fd_list,\n                                 GCancellable           *cancellable,\n                                 GAsyncReadyCallback     callback,\n                                 gpointer                user_data)\n{\n  GDBusMessage *message;\n  guint32 serial;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n  g_return_if_fail (bus_name == NULL || g_dbus_is_name (bus_name));\n  g_return_if_fail (object_path != NULL && g_variant_is_object_path (object_path));\n  g_return_if_fail (interface_name != NULL && g_dbus_is_interface_name (interface_name));\n  g_return_if_fail (method_name != NULL && g_dbus_is_member_name (method_name));\n  g_return_if_fail (timeout_msec >= 0 || timeout_msec == -1);\n  g_return_if_fail ((parameters == NULL) || g_variant_is_of_type (parameters, G_VARIANT_TYPE_TUPLE));\n  g_return_if_fail (check_initialized (connection));\n#ifdef G_OS_UNIX\n  g_return_if_fail (fd_list == NULL || G_IS_UNIX_FD_LIST (fd_list));\n#else\n  g_return_if_fail (fd_list == NULL);\n#endif\n\n  message = g_dbus_message_new_method_call (bus_name,\n                                            object_path,\n                                            interface_name,\n                                            method_name);\n  add_call_flags (message, flags);\n  if (parameters != NULL)\n    g_dbus_message_set_body (message, parameters);\n\n#ifdef G_OS_UNIX\n  if (fd_list != NULL)\n    g_dbus_message_set_unix_fd_list (message, fd_list);\n#endif\n\n  /* If the user has no callback then we can just send the message with\n   * the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set and skip all\n   * the logic for processing the reply.  If the service sends the reply\n   * anyway then it will just be ignored.\n   */\n  if (callback != NULL)\n    {\n      CallState *state;\n      GTask *task;\n\n      state = g_slice_new0 (CallState);\n      state->method_name = g_strjoin (\".\", interface_name, method_name, NULL);\n\n      if (reply_type == NULL)\n        reply_type = G_VARIANT_TYPE_ANY;\n\n      state->reply_type = g_variant_type_copy (reply_type);\n\n      task = g_task_new (connection, cancellable, callback, user_data);\n      g_task_set_source_tag (task, g_dbus_connection_call_internal);\n      g_task_set_task_data (task, state, (GDestroyNotify) call_state_free);\n\n      g_dbus_connection_send_message_with_reply (connection,\n                                                 message,\n                                                 G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                 timeout_msec,\n                                                 &serial,\n                                                 cancellable,\n                                                 g_dbus_connection_call_done,\n                                                 task);\n    }\n  else\n    {\n      GDBusMessageFlags flags;\n\n      flags = g_dbus_message_get_flags (message);\n      flags |= G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED;\n      g_dbus_message_set_flags (message, flags);\n\n      g_dbus_connection_send_message (connection,\n                                      message,\n                                      G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                      &serial, NULL);\n    }\n\n  if (G_UNLIKELY (_g_dbus_debug_call ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Call:\\n\"\n               \" >>>> ASYNC %s.%s()\\n\"\n               \"      on object %s\\n\"\n               \"      owned by name %s (serial %d)\\n\",\n               interface_name,\n               method_name,\n               object_path,\n               bus_name != NULL ? bus_name : \"(none)\",\n               serial);\n      _g_dbus_debug_print_unlock ();\n    }\n\n  if (message != NULL)\n    g_object_unref (message);\n}\n\n/* called in any thread, with the connection's lock not held */\nstatic GVariant *\ng_dbus_connection_call_finish_internal (GDBusConnection  *connection,\n                                        GUnixFDList     **out_fd_list,\n                                        GAsyncResult     *res,\n                                        GError          **error)\n{\n  GTask *task;\n  CallState *state;\n  GVariant *ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  g_return_val_if_fail (g_task_is_valid (res, connection), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  task = G_TASK (res);\n  state = g_task_get_task_data (task);\n\n  ret = g_task_propagate_pointer (task, error);\n  if (!ret)\n    return NULL;\n\n  if (out_fd_list != NULL)\n    *out_fd_list = state->fd_list != NULL ? g_object_ref (state->fd_list) : NULL;\n  return ret;\n}\n\n/* called in any user thread, with the connection's lock not held */\nstatic GVariant *\ng_dbus_connection_call_sync_internal (GDBusConnection         *connection,\n                                      const gchar             *bus_name,\n                                      const gchar             *object_path,\n                                      const gchar             *interface_name,\n                                      const gchar             *method_name,\n                                      GVariant                *parameters,\n                                      const GVariantType      *reply_type,\n                                      GDBusCallFlags           flags,\n                                      gint                     timeout_msec,\n                                      GUnixFDList             *fd_list,\n                                      GUnixFDList            **out_fd_list,\n                                      GCancellable            *cancellable,\n                                      GError                 **error)\n{\n  GDBusMessage *message;\n  GDBusMessage *reply;\n  GVariant *result;\n  GError *local_error;\n  GDBusSendMessageFlags send_flags;\n\n  message = NULL;\n  reply = NULL;\n  result = NULL;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  g_return_val_if_fail (bus_name == NULL || g_dbus_is_name (bus_name), NULL);\n  g_return_val_if_fail (object_path != NULL && g_variant_is_object_path (object_path), NULL);\n  g_return_val_if_fail (interface_name != NULL && g_dbus_is_interface_name (interface_name), NULL);\n  g_return_val_if_fail (method_name != NULL && g_dbus_is_member_name (method_name), NULL);\n  g_return_val_if_fail (timeout_msec >= 0 || timeout_msec == -1, NULL);\n  g_return_val_if_fail ((parameters == NULL) || g_variant_is_of_type (parameters, G_VARIANT_TYPE_TUPLE), NULL);\n#ifdef G_OS_UNIX\n  g_return_val_if_fail (fd_list == NULL || G_IS_UNIX_FD_LIST (fd_list), NULL);\n#else\n  g_return_val_if_fail (fd_list == NULL, NULL);\n#endif\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  if (!(flags & CALL_FLAGS_INITIALIZING))\n    g_return_val_if_fail (check_initialized (connection), FALSE);\n\n  if (reply_type == NULL)\n    reply_type = G_VARIANT_TYPE_ANY;\n\n  message = g_dbus_message_new_method_call (bus_name,\n                                            object_path,\n                                            interface_name,\n                                            method_name);\n  add_call_flags (message, flags);\n  if (parameters != NULL)\n    g_dbus_message_set_body (message, parameters);\n\n#ifdef G_OS_UNIX\n  if (fd_list != NULL)\n    g_dbus_message_set_unix_fd_list (message, fd_list);\n#endif\n\n  if (G_UNLIKELY (_g_dbus_debug_call ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Call:\\n\"\n               \" >>>> SYNC %s.%s()\\n\"\n               \"      on object %s\\n\"\n               \"      owned by name %s\\n\",\n               interface_name,\n               method_name,\n               object_path,\n               bus_name != NULL ? bus_name : \"(none)\");\n      _g_dbus_debug_print_unlock ();\n    }\n\n  local_error = NULL;\n\n  send_flags = G_DBUS_SEND_MESSAGE_FLAGS_NONE;\n\n  /* translate from one flavour of flags to another... */\n  if (flags & CALL_FLAGS_INITIALIZING)\n    send_flags |= SEND_MESSAGE_FLAGS_INITIALIZING;\n\n  reply = g_dbus_connection_send_message_with_reply_sync (connection,\n                                                          message,\n                                                          send_flags,\n                                                          timeout_msec,\n                                                          NULL, /* volatile guint32 *out_serial */\n                                                          cancellable,\n                                                          &local_error);\n\n  if (G_UNLIKELY (_g_dbus_debug_call ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Call:\\n\"\n               \" <<<< SYNC COMPLETE %s.%s()\\n\"\n               \"      \",\n               interface_name,\n               method_name);\n      if (reply != NULL)\n        {\n          g_print (\"SUCCESS\\n\");\n        }\n      else\n        {\n          g_print (\"FAILED: %s\\n\",\n                   local_error->message);\n        }\n      _g_dbus_debug_print_unlock ();\n    }\n\n  if (reply == NULL)\n    {\n      if (error != NULL)\n        *error = local_error;\n      else\n        g_error_free (local_error);\n      goto out;\n    }\n\n  result = decode_method_reply (reply, method_name, reply_type, out_fd_list, error);\n\n out:\n  if (message != NULL)\n    g_object_unref (message);\n  if (reply != NULL)\n    g_object_unref (reply);\n\n  return result;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_call:\n * @connection: a #GDBusConnection\n * @bus_name: (nullable): a unique or well-known bus name or %NULL if\n *     @connection is not a message bus connection\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to invoke method on\n * @method_name: the name of the method to invoke\n * @parameters: (nullable): a #GVariant tuple with parameters for the method\n *     or %NULL if not passing parameters\n * @reply_type: (nullable): the expected type of the reply (which will be a\n *     tuple), or %NULL\n * @flags: flags from the #GDBusCallFlags enumeration\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the request\n *     is satisfied or %NULL if you don't care about the result of the\n *     method invocation\n * @user_data: the data to pass to @callback\n *\n * Asynchronously invokes the @method_name method on the\n * @interface_name D-Bus interface on the remote object at\n * @object_path owned by @bus_name.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will\n * fail with %G_IO_ERROR_CANCELLED. If @parameters contains a value\n * not compatible with the D-Bus protocol, the operation fails with\n * %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * If @reply_type is non-%NULL then the reply will be checked for having this type and an\n * error will be raised if it does not match.  Said another way, if you give a @reply_type\n * then any non-%NULL return value will be of this type. Unless it\u2019s\n * %G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple containing one or more\n * values.\n *\n * If the @parameters #GVariant is floating, it is consumed. This allows\n * convenient 'inline' use of g_variant_new(), e.g.:\n * |[<!-- language=\"C\" -->\n *  g_dbus_connection_call (connection,\n *                          \"org.freedesktop.StringThings\",\n *                          \"/org/freedesktop/StringThings\",\n *                          \"org.freedesktop.StringThings\",\n *                          \"TwoStrings\",\n *                          g_variant_new (\"(ss)\",\n *                                         \"Thing One\",\n *                                         \"Thing Two\"),\n *                          NULL,\n *                          G_DBUS_CALL_FLAGS_NONE,\n *                          -1,\n *                          NULL,\n *                          (GAsyncReadyCallback) two_strings_done,\n *                          NULL);\n * ]|\n *\n * This is an asynchronous method. When the operation is finished,\n * @callback will be invoked in the\n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from. You can then call\n * g_dbus_connection_call_finish() to get the result of the operation.\n * See g_dbus_connection_call_sync() for the synchronous version of this\n * function.\n *\n * If @callback is %NULL then the D-Bus method call message will be sent with\n * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_call (GDBusConnection     *connection,\n                        const gchar         *bus_name,\n                        const gchar         *object_path,\n                        const gchar         *interface_name,\n                        const gchar         *method_name,\n                        GVariant            *parameters,\n                        const GVariantType  *reply_type,\n                        GDBusCallFlags       flags,\n                        gint                 timeout_msec,\n                        GCancellable        *cancellable,\n                        GAsyncReadyCallback  callback,\n                        gpointer             user_data)\n{\n  g_dbus_connection_call_internal (connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, NULL, cancellable, callback, user_data);\n}\n\n/**\n * g_dbus_connection_call_finish:\n * @connection: a #GDBusConnection\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_call()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_call().\n *\n * Returns: %NULL if @error is set. Otherwise a #GVariant tuple with\n *     return values. Free with g_variant_unref().\n *\n * Since: 2.26\n */\nGVariant *\ng_dbus_connection_call_finish (GDBusConnection  *connection,\n                               GAsyncResult     *res,\n                               GError          **error)\n{\n  return g_dbus_connection_call_finish_internal (connection, NULL, res, error);\n}\n\n/**\n * g_dbus_connection_call_sync:\n * @connection: a #GDBusConnection\n * @bus_name: (nullable): a unique or well-known bus name or %NULL if\n *     @connection is not a message bus connection\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to invoke method on\n * @method_name: the name of the method to invoke\n * @parameters: (nullable): a #GVariant tuple with parameters for the method\n *     or %NULL if not passing parameters\n * @reply_type: (nullable): the expected type of the reply, or %NULL\n * @flags: flags from the #GDBusCallFlags enumeration\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously invokes the @method_name method on the\n * @interface_name D-Bus interface on the remote object at\n * @object_path owned by @bus_name.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @cancellable is canceled, the\n * operation will fail with %G_IO_ERROR_CANCELLED. If @parameters\n * contains a value not compatible with the D-Bus protocol, the operation\n * fails with %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * If @reply_type is non-%NULL then the reply will be checked for having\n * this type and an error will be raised if it does not match.  Said\n * another way, if you give a @reply_type then any non-%NULL return\n * value will be of this type.\n *\n * If the @parameters #GVariant is floating, it is consumed.\n * This allows convenient 'inline' use of g_variant_new(), e.g.:\n * |[<!-- language=\"C\" -->\n *  g_dbus_connection_call_sync (connection,\n *                               \"org.freedesktop.StringThings\",\n *                               \"/org/freedesktop/StringThings\",\n *                               \"org.freedesktop.StringThings\",\n *                               \"TwoStrings\",\n *                               g_variant_new (\"(ss)\",\n *                                              \"Thing One\",\n *                                              \"Thing Two\"),\n *                               NULL,\n *                               G_DBUS_CALL_FLAGS_NONE,\n *                               -1,\n *                               NULL,\n *                               &error);\n * ]|\n *\n * The calling thread is blocked until a reply is received. See\n * g_dbus_connection_call() for the asynchronous version of\n * this method.\n *\n * Returns: %NULL if @error is set. Otherwise a #GVariant tuple with\n *     return values. Free with g_variant_unref().\n *\n * Since: 2.26\n */\nGVariant *\ng_dbus_connection_call_sync (GDBusConnection     *connection,\n                             const gchar         *bus_name,\n                             const gchar         *object_path,\n                             const gchar         *interface_name,\n                             const gchar         *method_name,\n                             GVariant            *parameters,\n                             const GVariantType  *reply_type,\n                             GDBusCallFlags       flags,\n                             gint                 timeout_msec,\n                             GCancellable        *cancellable,\n                             GError             **error)\n{\n  return g_dbus_connection_call_sync_internal (connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, NULL, NULL, cancellable, error);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n#ifdef G_OS_UNIX\n\n/**\n * g_dbus_connection_call_with_unix_fd_list:\n * @connection: a #GDBusConnection\n * @bus_name: (nullable): a unique or well-known bus name or %NULL if\n *     @connection is not a message bus connection\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to invoke method on\n * @method_name: the name of the method to invoke\n * @parameters: (nullable): a #GVariant tuple with parameters for the method\n *     or %NULL if not passing parameters\n * @reply_type: (nullable): the expected type of the reply, or %NULL\n * @flags: flags from the #GDBusCallFlags enumeration\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @fd_list: (nullable): a #GUnixFDList or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the request is\n *     satisfied or %NULL if you don't * care about the result of the\n *     method invocation\n * @user_data: The data to pass to @callback.\n *\n * Like g_dbus_connection_call() but also takes a #GUnixFDList object.\n *\n * This method is only available on UNIX.\n *\n * Since: 2.30\n */\nvoid\ng_dbus_connection_call_with_unix_fd_list (GDBusConnection     *connection,\n                                          const gchar         *bus_name,\n                                          const gchar         *object_path,\n                                          const gchar         *interface_name,\n                                          const gchar         *method_name,\n                                          GVariant            *parameters,\n                                          const GVariantType  *reply_type,\n                                          GDBusCallFlags       flags,\n                                          gint                 timeout_msec,\n                                          GUnixFDList         *fd_list,\n                                          GCancellable        *cancellable,\n                                          GAsyncReadyCallback  callback,\n                                          gpointer             user_data)\n{\n  g_dbus_connection_call_internal (connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, cancellable, callback, user_data);\n}\n\n/**\n * g_dbus_connection_call_with_unix_fd_list_finish:\n * @connection: a #GDBusConnection\n * @out_fd_list: (out) (optional): return location for a #GUnixFDList or %NULL\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n *     g_dbus_connection_call_with_unix_fd_list()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_call_with_unix_fd_list().\n *\n * Returns: %NULL if @error is set. Otherwise a #GVariant tuple with\n *     return values. Free with g_variant_unref().\n *\n * Since: 2.30\n */\nGVariant *\ng_dbus_connection_call_with_unix_fd_list_finish (GDBusConnection  *connection,\n                                                 GUnixFDList     **out_fd_list,\n                                                 GAsyncResult     *res,\n                                                 GError          **error)\n{\n  return g_dbus_connection_call_finish_internal (connection, out_fd_list, res, error);\n}\n\n/**\n * g_dbus_connection_call_with_unix_fd_list_sync:\n * @connection: a #GDBusConnection\n * @bus_name: (nullable): a unique or well-known bus name or %NULL\n *     if @connection is not a message bus connection\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to invoke method on\n * @method_name: the name of the method to invoke\n * @parameters: (nullable): a #GVariant tuple with parameters for\n *     the method or %NULL if not passing parameters\n * @reply_type: (nullable): the expected type of the reply, or %NULL\n * @flags: flags from the #GDBusCallFlags enumeration\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @fd_list: (nullable): a #GUnixFDList or %NULL\n * @out_fd_list: (out) (optional): return location for a #GUnixFDList or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Like g_dbus_connection_call_sync() but also takes and returns #GUnixFDList objects.\n *\n * This method is only available on UNIX.\n *\n * Returns: %NULL if @error is set. Otherwise a #GVariant tuple with\n *     return values. Free with g_variant_unref().\n *\n * Since: 2.30\n */\nGVariant *\ng_dbus_connection_call_with_unix_fd_list_sync (GDBusConnection     *connection,\n                                               const gchar         *bus_name,\n                                               const gchar         *object_path,\n                                               const gchar         *interface_name,\n                                               const gchar         *method_name,\n                                               GVariant            *parameters,\n                                               const GVariantType  *reply_type,\n                                               GDBusCallFlags       flags,\n                                               gint                 timeout_msec,\n                                               GUnixFDList         *fd_list,\n                                               GUnixFDList        **out_fd_list,\n                                               GCancellable        *cancellable,\n                                               GError             **error)\n{\n  return g_dbus_connection_call_sync_internal (connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, out_fd_list, cancellable, error);\n}\n\n#endif /* G_OS_UNIX */\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstruct ExportedSubtree\n{\n  guint                     id;\n  gchar                    *object_path;\n  GDBusConnection          *connection;\n  GDBusSubtreeVTable       *vtable;\n  GDBusSubtreeFlags         flags;\n\n  GMainContext             *context;\n  gpointer                  user_data;\n  GDestroyNotify            user_data_free_func;\n};\n\nstatic void\nexported_subtree_free (ExportedSubtree *es)\n{\n  call_destroy_notify (es->context,\n                       es->user_data_free_func,\n                       es->user_data);\n\n  g_main_context_unref (es->context);\n\n  _g_dbus_subtree_vtable_free (es->vtable);\n  g_free (es->object_path);\n  g_free (es);\n}\n\n/* called without lock held in the thread where the caller registered\n * the subtree\n */\nstatic gboolean\nhandle_subtree_introspect (GDBusConnection *connection,\n                           ExportedSubtree *es,\n                           GDBusMessage    *message)\n{\n  GString *s;\n  gboolean handled;\n  GDBusMessage *reply;\n  gchar **children;\n  gboolean is_root;\n  const gchar *sender;\n  const gchar *requested_object_path;\n  const gchar *requested_node;\n  GDBusInterfaceInfo **interfaces;\n  guint n;\n  gchar **subnode_paths;\n  gboolean has_properties_interface;\n  gboolean has_introspectable_interface;\n\n  handled = FALSE;\n\n  requested_object_path = g_dbus_message_get_path (message);\n  sender = g_dbus_message_get_sender (message);\n  is_root = (g_strcmp0 (requested_object_path, es->object_path) == 0);\n\n  s = g_string_new (NULL);\n  introspect_append_header (s);\n\n  /* Strictly we don't need the children in dynamic mode, but we avoid the\n   * conditionals to preserve code clarity\n   */\n  children = es->vtable->enumerate (es->connection,\n                                    sender,\n                                    es->object_path,\n                                    es->user_data);\n\n  if (!is_root)\n    {\n      requested_node = strrchr (requested_object_path, '/') + 1;\n\n      /* Assert existence of object if we are not dynamic */\n      if (!(es->flags & G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES) &&\n          !_g_strv_has_string ((const gchar * const *) children, requested_node))\n        goto out;\n    }\n  else\n    {\n      requested_node = NULL;\n    }\n\n  interfaces = es->vtable->introspect (es->connection,\n                                       sender,\n                                       es->object_path,\n                                       requested_node,\n                                       es->user_data);\n  if (interfaces != NULL)\n    {\n      has_properties_interface = FALSE;\n      has_introspectable_interface = FALSE;\n\n      for (n = 0; interfaces[n] != NULL; n++)\n        {\n          if (strcmp (interfaces[n]->name, \"org.freedesktop.DBus.Properties\") == 0)\n            has_properties_interface = TRUE;\n          else if (strcmp (interfaces[n]->name, \"org.freedesktop.DBus.Introspectable\") == 0)\n            has_introspectable_interface = TRUE;\n        }\n      if (!has_properties_interface)\n        g_string_append (s, introspect_properties_interface);\n      if (!has_introspectable_interface)\n        g_string_append (s, introspect_introspectable_interface);\n\n      for (n = 0; interfaces[n] != NULL; n++)\n        {\n          g_dbus_interface_info_generate_xml (interfaces[n], 2, s);\n          g_dbus_interface_info_unref (interfaces[n]);\n        }\n      g_free (interfaces);\n    }\n\n  /* then include <node> entries from the Subtree for the root */\n  if (is_root)\n    {\n      for (n = 0; children != NULL && children[n] != NULL; n++)\n        g_string_append_printf (s, \"  <node name=\\\"%s\\\"/>\\n\", children[n]);\n    }\n\n  /* finally include nodes registered below us */\n  subnode_paths = g_dbus_connection_list_registered (es->connection, requested_object_path);\n  for (n = 0; subnode_paths != NULL && subnode_paths[n] != NULL; n++)\n    g_string_append_printf (s, \"  <node name=\\\"%s\\\"/>\\n\", subnode_paths[n]);\n  g_strfreev (subnode_paths);\n\n  g_string_append (s, \"</node>\\n\");\n\n  reply = g_dbus_message_new_method_reply (message);\n  g_dbus_message_set_body (reply, g_variant_new (\"(s)\", s->str));\n  g_dbus_connection_send_message (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n\n  handled = TRUE;\n\n out:\n  g_string_free (s, TRUE);\n  g_strfreev (children);\n  return handled;\n}\n\n/* called without lock held in the thread where the caller registered\n * the subtree\n */\nstatic gboolean\nhandle_subtree_method_invocation (GDBusConnection *connection,\n                                  ExportedSubtree *es,\n                                  GDBusMessage    *message)\n{\n  gboolean handled;\n  const gchar *sender;\n  const gchar *interface_name;\n  const gchar *member;\n  const gchar *signature;\n  const gchar *requested_object_path;\n  const gchar *requested_node;\n  gboolean is_root;\n  GDBusInterfaceInfo *interface_info;\n  const GDBusInterfaceVTable *interface_vtable;\n  gpointer interface_user_data;\n  guint n;\n  GDBusInterfaceInfo **interfaces;\n  gboolean is_property_get;\n  gboolean is_property_set;\n  gboolean is_property_get_all;\n\n  handled = FALSE;\n  interfaces = NULL;\n\n  requested_object_path = g_dbus_message_get_path (message);\n  sender = g_dbus_message_get_sender (message);\n  interface_name = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  signature = g_dbus_message_get_signature (message);\n  is_root = (g_strcmp0 (requested_object_path, es->object_path) == 0);\n\n  is_property_get = FALSE;\n  is_property_set = FALSE;\n  is_property_get_all = FALSE;\n  if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Properties\") == 0)\n    {\n      if (g_strcmp0 (member, \"Get\") == 0 && g_strcmp0 (signature, \"ss\") == 0)\n        is_property_get = TRUE;\n      else if (g_strcmp0 (member, \"Set\") == 0 && g_strcmp0 (signature, \"ssv\") == 0)\n        is_property_set = TRUE;\n      else if (g_strcmp0 (member, \"GetAll\") == 0 && g_strcmp0 (signature, \"s\") == 0)\n        is_property_get_all = TRUE;\n    }\n\n  if (!is_root)\n    {\n      requested_node = strrchr (requested_object_path, '/') + 1;\n\n      if (~es->flags & G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES)\n        {\n          /* We don't want to dispatch to unenumerated\n           * nodes, so ensure that the child exists.\n           */\n          gchar **children;\n          gboolean exists;\n\n          children = es->vtable->enumerate (es->connection,\n                                            sender,\n                                            es->object_path,\n                                            es->user_data);\n\n          exists = _g_strv_has_string ((const gchar * const *) children, requested_node);\n          g_strfreev (children);\n\n          if (!exists)\n            goto out;\n        }\n    }\n  else\n    {\n      requested_node = NULL;\n    }\n\n  /* get introspection data for the node */\n  interfaces = es->vtable->introspect (es->connection,\n                                       sender,\n                                       requested_object_path,\n                                       requested_node,\n                                       es->user_data);\n\n  if (interfaces == NULL)\n    goto out;\n\n  interface_info = NULL;\n  for (n = 0; interfaces[n] != NULL; n++)\n    {\n      if (g_strcmp0 (interfaces[n]->name, interface_name) == 0)\n        interface_info = interfaces[n];\n    }\n\n  /* dispatch the call if the user wants to handle it */\n  if (interface_info != NULL)\n    {\n      /* figure out where to dispatch the method call */\n      interface_user_data = NULL;\n      interface_vtable = es->vtable->dispatch (es->connection,\n                                               sender,\n                                               es->object_path,\n                                               interface_name,\n                                               requested_node,\n                                               &interface_user_data,\n                                               es->user_data);\n      if (interface_vtable == NULL)\n        goto out;\n\n      CONNECTION_LOCK (connection);\n      handled = validate_and_maybe_schedule_method_call (es->connection,\n                                                         message,\n                                                         0,\n                                                         es->id,\n                                                         interface_info,\n                                                         interface_vtable,\n                                                         es->context,\n                                                         interface_user_data);\n      CONNECTION_UNLOCK (connection);\n    }\n  /* handle org.freedesktop.DBus.Properties interface if not explicitly handled */\n  else if (is_property_get || is_property_set || is_property_get_all)\n    {\n      if (is_property_get)\n        g_variant_get (g_dbus_message_get_body (message), \"(&s&s)\", &interface_name, NULL);\n      else if (is_property_set)\n        g_variant_get (g_dbus_message_get_body (message), \"(&s&sv)\", &interface_name, NULL, NULL);\n      else if (is_property_get_all)\n        g_variant_get (g_dbus_message_get_body (message), \"(&s)\", &interface_name, NULL, NULL);\n      else\n        g_assert_not_reached ();\n\n      /* see if the object supports this interface at all */\n      for (n = 0; interfaces[n] != NULL; n++)\n        {\n          if (g_strcmp0 (interfaces[n]->name, interface_name) == 0)\n            interface_info = interfaces[n];\n        }\n\n      /* Fail with org.freedesktop.DBus.Error.InvalidArgs if the user-code\n       * claims it won't support the interface\n       */\n      if (interface_info == NULL)\n        {\n          GDBusMessage *reply;\n          reply = g_dbus_message_new_method_error (message,\n                                                   \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                                   _(\"No such interface \u201c%s\u201d\"),\n                                                   interface_name);\n          g_dbus_connection_send_message (es->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n          g_object_unref (reply);\n          handled = TRUE;\n          goto out;\n        }\n\n      /* figure out where to dispatch the property get/set/getall calls */\n      interface_user_data = NULL;\n      interface_vtable = es->vtable->dispatch (es->connection,\n                                               sender,\n                                               es->object_path,\n                                               interface_name,\n                                               requested_node,\n                                               &interface_user_data,\n                                               es->user_data);\n      if (interface_vtable == NULL)\n        {\n          g_warning (\"The subtree introspection function indicates that '%s' \"\n                     \"is a valid interface name, but calling the dispatch \"\n                     \"function on that interface gave us NULL\", interface_name);\n          goto out;\n        }\n\n      if (is_property_get || is_property_set)\n        {\n          CONNECTION_LOCK (connection);\n          handled = validate_and_maybe_schedule_property_getset (es->connection,\n                                                                 message,\n                                                                 0,\n                                                                 es->id,\n                                                                 is_property_get,\n                                                                 interface_info,\n                                                                 interface_vtable,\n                                                                 es->context,\n                                                                 interface_user_data);\n          CONNECTION_UNLOCK (connection);\n        }\n      else if (is_property_get_all)\n        {\n          CONNECTION_LOCK (connection);\n          handled = validate_and_maybe_schedule_property_get_all (es->connection,\n                                                                  message,\n                                                                  0,\n                                                                  es->id,\n                                                                  interface_info,\n                                                                  interface_vtable,\n                                                                  es->context,\n                                                                  interface_user_data);\n          CONNECTION_UNLOCK (connection);\n        }\n    }\n\n out:\n  if (interfaces != NULL)\n    {\n      for (n = 0; interfaces[n] != NULL; n++)\n        g_dbus_interface_info_unref (interfaces[n]);\n      g_free (interfaces);\n    }\n\n  return handled;\n}\n\ntypedef struct\n{\n  GDBusMessage *message;\n  ExportedSubtree *es;\n} SubtreeDeferredData;\n\nstatic void\nsubtree_deferred_data_free (SubtreeDeferredData *data)\n{\n  g_object_unref (data->message);\n  g_free (data);\n}\n\n/* called without lock held in the thread where the caller registered the subtree */\nstatic gboolean\nprocess_subtree_vtable_message_in_idle_cb (gpointer _data)\n{\n  SubtreeDeferredData *data = _data;\n  gboolean handled;\n\n  handled = FALSE;\n\n  if (g_strcmp0 (g_dbus_message_get_interface (data->message), \"org.freedesktop.DBus.Introspectable\") == 0 &&\n      g_strcmp0 (g_dbus_message_get_member (data->message), \"Introspect\") == 0 &&\n      g_strcmp0 (g_dbus_message_get_signature (data->message), \"\") == 0)\n    handled = handle_subtree_introspect (data->es->connection,\n                                         data->es,\n                                         data->message);\n  else\n    handled = handle_subtree_method_invocation (data->es->connection,\n                                                data->es,\n                                                data->message);\n\n  if (!handled)\n    {\n      CONNECTION_LOCK (data->es->connection);\n      handled = handle_generic_unlocked (data->es->connection, data->message);\n      CONNECTION_UNLOCK (data->es->connection);\n    }\n\n  /* if we couldn't handle the request, just bail with the UnknownMethod error */\n  if (!handled)\n    {\n      GDBusMessage *reply;\n      reply = g_dbus_message_new_method_error (data->message,\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"Method \u201c%s\u201d on interface \u201c%s\u201d with signature \u201c%s\u201d does not exist\"),\n                                               g_dbus_message_get_member (data->message),\n                                               g_dbus_message_get_interface (data->message),\n                                               g_dbus_message_get_signature (data->message));\n      g_dbus_connection_send_message (data->es->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n    }\n\n  return FALSE;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nsubtree_message_func (GDBusConnection *connection,\n                      ExportedSubtree *es,\n                      GDBusMessage    *message)\n{\n  GSource *idle_source;\n  SubtreeDeferredData *data;\n\n  data = g_new0 (SubtreeDeferredData, 1);\n  data->message = g_object_ref (message);\n  data->es = es;\n\n  /* defer this call to an idle handler in the right thread */\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_HIGH);\n  g_source_set_callback (idle_source,\n                         process_subtree_vtable_message_in_idle_cb,\n                         data,\n                         (GDestroyNotify) subtree_deferred_data_free);\n  g_source_set_name (idle_source, \"[gio] process_subtree_vtable_message_in_idle_cb\");\n  g_source_attach (idle_source, es->context);\n  g_source_unref (idle_source);\n\n  /* since we own the entire subtree, handlers for objects not in the subtree have been\n   * tried already by libdbus-1 - so we just need to ensure that we're always going\n   * to reply to the message\n   */\n  return TRUE;\n}\n\n/**\n * g_dbus_connection_register_subtree:\n * @connection: a #GDBusConnection\n * @object_path: the object path to register the subtree at\n * @vtable: a #GDBusSubtreeVTable to enumerate, introspect and\n *     dispatch nodes in the subtree\n * @flags: flags used to fine tune the behavior of the subtree\n * @user_data: data to pass to functions in @vtable\n * @user_data_free_func: function to call when the subtree is unregistered\n * @error: return location for error or %NULL\n *\n * Registers a whole subtree of dynamic objects.\n *\n * The @enumerate and @introspection functions in @vtable are used to\n * convey, to remote callers, what nodes exist in the subtree rooted\n * by @object_path.\n *\n * When handling remote calls into any node in the subtree, first the\n * @enumerate function is used to check if the node exists. If the node exists\n * or the #G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set\n * the @introspection function is used to check if the node supports the\n * requested method. If so, the @dispatch function is used to determine\n * where to dispatch the call. The collected #GDBusInterfaceVTable and\n * #gpointer will be used to call into the interface vtable for processing\n * the request.\n *\n * All calls into user-provided code will be invoked in the\n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from.\n *\n * If an existing subtree is already registered at @object_path or\n * then @error is set to #G_IO_ERROR_EXISTS.\n *\n * Note that it is valid to register regular objects (using\n * g_dbus_connection_register_object()) in a subtree registered with\n * g_dbus_connection_register_subtree() - if so, the subtree handler\n * is tried as the last resort. One way to think about a subtree\n * handler is to consider it a fallback handler for object paths not\n * registered via g_dbus_connection_register_object() or other bindings.\n *\n * Note that @vtable will be copied so you cannot change it after\n * registration.\n *\n * See this [server][gdbus-subtree-server] for an example of how to use\n * this method.\n *\n * Returns: 0 if @error is set, otherwise a subtree registration id (never 0)\n * that can be used with g_dbus_connection_unregister_subtree() .\n *\n * Since: 2.26\n */\nguint\ng_dbus_connection_register_subtree (GDBusConnection           *connection,\n                                    const gchar               *object_path,\n                                    const GDBusSubtreeVTable  *vtable,\n                                    GDBusSubtreeFlags          flags,\n                                    gpointer                   user_data,\n                                    GDestroyNotify             user_data_free_func,\n                                    GError                   **error)\n{\n  guint ret;\n  ExportedSubtree *es;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n  g_return_val_if_fail (object_path != NULL && g_variant_is_object_path (object_path), 0);\n  g_return_val_if_fail (vtable != NULL, 0);\n  g_return_val_if_fail (error == NULL || *error == NULL, 0);\n  g_return_val_if_fail (check_initialized (connection), 0);\n\n  ret = 0;\n\n  CONNECTION_LOCK (connection);\n\n  es = g_hash_table_lookup (connection->map_object_path_to_es, object_path);\n  if (es != NULL)\n    {\n      g_set_error (error,\n                   G_IO_ERROR,\n                   G_IO_ERROR_EXISTS,\n                   _(\"A subtree is already exported for %s\"),\n                   object_path);\n      goto out;\n    }\n\n  es = g_new0 (ExportedSubtree, 1);\n  es->object_path = g_strdup (object_path);\n  es->connection = connection;\n\n  es->vtable = _g_dbus_subtree_vtable_copy (vtable);\n  es->flags = flags;\n  es->id = g_atomic_int_add (&_global_subtree_registration_id, 1); /* TODO: overflow etc. */\n  es->user_data = user_data;\n  es->user_data_free_func = user_data_free_func;\n  es->context = g_main_context_ref_thread_default ();\n\n  g_hash_table_insert (connection->map_object_path_to_es, es->object_path, es);\n  g_hash_table_insert (connection->map_id_to_es,\n                       GUINT_TO_POINTER (es->id),\n                       es);\n\n  ret = es->id;\n\n out:\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_unregister_subtree:\n * @connection: a #GDBusConnection\n * @registration_id: a subtree registration id obtained from\n *     g_dbus_connection_register_subtree()\n *\n * Unregisters a subtree.\n *\n * Returns: %TRUE if the subtree was unregistered, %FALSE otherwise\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_unregister_subtree (GDBusConnection *connection,\n                                      guint            registration_id)\n{\n  ExportedSubtree *es;\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (check_initialized (connection), FALSE);\n\n  ret = FALSE;\n\n  CONNECTION_LOCK (connection);\n\n  es = g_hash_table_lookup (connection->map_id_to_es,\n                            GUINT_TO_POINTER (registration_id));\n  if (es == NULL)\n    goto out;\n\n  g_warn_if_fail (g_hash_table_remove (connection->map_id_to_es, GUINT_TO_POINTER (es->id)));\n  g_warn_if_fail (g_hash_table_remove (connection->map_object_path_to_es, es->object_path));\n\n  ret = TRUE;\n\n out:\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* may be called in any thread, with connection's lock held */\nstatic void\nhandle_generic_ping_unlocked (GDBusConnection *connection,\n                              const gchar     *object_path,\n                              GDBusMessage    *message)\n{\n  GDBusMessage *reply;\n  reply = g_dbus_message_new_method_reply (message);\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n}\n\n/* may be called in any thread, with connection's lock held */\nstatic void\nhandle_generic_get_machine_id_unlocked (GDBusConnection *connection,\n                                        const gchar     *object_path,\n                                        GDBusMessage    *message)\n{\n  GDBusMessage *reply;\n\n  reply = NULL;\n  if (connection->machine_id == NULL)\n    {\n      GError *error;\n\n      error = NULL;\n      connection->machine_id = _g_dbus_get_machine_id (&error);\n      if (connection->machine_id == NULL)\n        {\n          reply = g_dbus_message_new_method_error_literal (message,\n                                                           \"org.freedesktop.DBus.Error.Failed\",\n                                                           error->message);\n          g_error_free (error);\n        }\n    }\n\n  if (reply == NULL)\n    {\n      reply = g_dbus_message_new_method_reply (message);\n      g_dbus_message_set_body (reply, g_variant_new (\"(s)\", connection->machine_id));\n    }\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n}\n\n/* may be called in any thread, with connection's lock held */\nstatic void\nhandle_generic_introspect_unlocked (GDBusConnection *connection,\n                                    const gchar     *object_path,\n                                    GDBusMessage    *message)\n{\n  guint n;\n  GString *s;\n  gchar **registered;\n  GDBusMessage *reply;\n\n  /* first the header */\n  s = g_string_new (NULL);\n  introspect_append_header (s);\n\n  registered = g_dbus_connection_list_registered_unlocked (connection, object_path);\n  for (n = 0; registered != NULL && registered[n] != NULL; n++)\n      g_string_append_printf (s, \"  <node name=\\\"%s\\\"/>\\n\", registered[n]);\n  g_strfreev (registered);\n  g_string_append (s, \"</node>\\n\");\n\n  reply = g_dbus_message_new_method_reply (message);\n  g_dbus_message_set_body (reply, g_variant_new (\"(s)\", s->str));\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n  g_string_free (s, TRUE);\n}\n\n/* may be called in any thread, with connection's lock held */\nstatic gboolean\nhandle_generic_unlocked (GDBusConnection *connection,\n                         GDBusMessage    *message)\n{\n  gboolean handled;\n  const gchar *interface_name;\n  const gchar *member;\n  const gchar *signature;\n  const gchar *path;\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  handled = FALSE;\n\n  interface_name = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  signature = g_dbus_message_get_signature (message);\n  path = g_dbus_message_get_path (message);\n\n  if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Introspectable\") == 0 &&\n      g_strcmp0 (member, \"Introspect\") == 0 &&\n      g_strcmp0 (signature, \"\") == 0)\n    {\n      handle_generic_introspect_unlocked (connection, path, message);\n      handled = TRUE;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Peer\") == 0 &&\n           g_strcmp0 (member, \"Ping\") == 0 &&\n           g_strcmp0 (signature, \"\") == 0)\n    {\n      handle_generic_ping_unlocked (connection, path, message);\n      handled = TRUE;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Peer\") == 0 &&\n           g_strcmp0 (member, \"GetMachineId\") == 0 &&\n           g_strcmp0 (signature, \"\") == 0)\n    {\n      handle_generic_get_machine_id_unlocked (connection, path, message);\n      handled = TRUE;\n    }\n\n  return handled;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic void\ndistribute_method_call (GDBusConnection *connection,\n                        GDBusMessage    *message)\n{\n  GDBusMessage *reply;\n  ExportedObject *eo;\n  ExportedSubtree *es;\n  const gchar *object_path;\n  const gchar *interface_name;\n  const gchar *member;\n  const gchar *path;\n  gchar *subtree_path;\n  gchar *needle;\n\n  g_assert (g_dbus_message_get_message_type (message) == G_DBUS_MESSAGE_TYPE_METHOD_CALL);\n\n  interface_name = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  path = g_dbus_message_get_path (message);\n  subtree_path = g_strdup (path);\n  needle = strrchr (subtree_path, '/');\n  if (needle != NULL && needle != subtree_path)\n    {\n      *needle = '\\0';\n    }\n  else\n    {\n      g_free (subtree_path);\n      subtree_path = NULL;\n    }\n\n\n  if (G_UNLIKELY (_g_dbus_debug_incoming ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Incoming:\\n\"\n               \" <<<< METHOD INVOCATION %s.%s()\\n\"\n               \"      on object %s\\n\"\n               \"      invoked by name %s\\n\"\n               \"      serial %d\\n\",\n               interface_name, member,\n               path,\n               g_dbus_message_get_sender (message) != NULL ? g_dbus_message_get_sender (message) : \"(none)\",\n               g_dbus_message_get_serial (message));\n      _g_dbus_debug_print_unlock ();\n    }\n\n  object_path = g_dbus_message_get_path (message);\n  g_assert (object_path != NULL);\n\n  eo = g_hash_table_lookup (connection->map_object_path_to_eo, object_path);\n  if (eo != NULL)\n    {\n      if (obj_message_func (connection, eo, message))\n        goto out;\n    }\n\n  es = g_hash_table_lookup (connection->map_object_path_to_es, object_path);\n  if (es != NULL)\n    {\n      if (subtree_message_func (connection, es, message))\n        goto out;\n    }\n\n  if (subtree_path != NULL)\n    {\n      es = g_hash_table_lookup (connection->map_object_path_to_es, subtree_path);\n      if (es != NULL)\n        {\n          if (subtree_message_func (connection, es, message))\n            goto out;\n        }\n    }\n\n  if (handle_generic_unlocked (connection, message))\n    goto out;\n\n  /* if we end up here, the message has not been not handled - so return an error saying this */\n  reply = g_dbus_message_new_method_error (message,\n                                           \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                           _(\"No such interface \u201c%s\u201d on object at path %s\"),\n                                           interface_name,\n                                           object_path);\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n\n out:\n  g_free (subtree_path);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called in any user thread, with the message_bus_lock held. */\nstatic GWeakRef *\nmessage_bus_get_singleton (GBusType   bus_type,\n                           GError   **error)\n{\n  GWeakRef *ret;\n  const gchar *starter_bus;\n\n  ret = NULL;\n\n  switch (bus_type)\n    {\n    case G_BUS_TYPE_SESSION:\n      ret = &the_session_bus;\n      break;\n\n    case G_BUS_TYPE_SYSTEM:\n      ret = &the_system_bus;\n      break;\n\n    case G_BUS_TYPE_STARTER:\n      starter_bus = g_getenv (\"DBUS_STARTER_BUS_TYPE\");\n      if (g_strcmp0 (starter_bus, \"session\") == 0)\n        {\n          ret = message_bus_get_singleton (G_BUS_TYPE_SESSION, error);\n          goto out;\n        }\n      else if (g_strcmp0 (starter_bus, \"system\") == 0)\n        {\n          ret = message_bus_get_singleton (G_BUS_TYPE_SYSTEM, error);\n          goto out;\n        }\n      else\n        {\n          if (starter_bus != NULL)\n            {\n              g_set_error (error,\n                           G_IO_ERROR,\n                           G_IO_ERROR_INVALID_ARGUMENT,\n                           _(\"Cannot determine bus address from DBUS_STARTER_BUS_TYPE environment variable\"\n                             \" \u2014 unknown value \u201c%s\u201d\"),\n                           starter_bus);\n            }\n          else\n            {\n              g_set_error_literal (error,\n                                   G_IO_ERROR,\n                                   G_IO_ERROR_INVALID_ARGUMENT,\n                                   _(\"Cannot determine bus address because the DBUS_STARTER_BUS_TYPE environment \"\n                                     \"variable is not set\"));\n            }\n        }\n      break;\n\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n out:\n  return ret;\n}\n\n/* Called in any user thread, without holding locks. */\nstatic GDBusConnection *\nget_uninitialized_connection (GBusType       bus_type,\n                              GCancellable  *cancellable,\n                              GError       **error)\n{\n  GWeakRef *singleton;\n  GDBusConnection *ret;\n\n  ret = NULL;\n\n  G_LOCK (message_bus_lock);\n  singleton = message_bus_get_singleton (bus_type, error);\n  if (singleton == NULL)\n    goto out;\n\n  ret = g_weak_ref_get (singleton);\n\n  if (ret == NULL)\n    {\n      gchar *address;\n      address = g_dbus_address_get_for_bus_sync (bus_type, cancellable, error);\n      if (address == NULL)\n        goto out;\n      ret = g_object_new (G_TYPE_DBUS_CONNECTION,\n                          \"address\", address,\n                          \"flags\", G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT |\n                                   G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,\n                          \"exit-on-close\", TRUE,\n                          NULL);\n\n      g_weak_ref_set (singleton, ret);\n      g_free (address);\n    }\n\n  g_assert (ret != NULL);\n\n out:\n  G_UNLOCK (message_bus_lock);\n  return ret;\n}\n\n/* May be called from any thread. Must not hold message_bus_lock. */\nGDBusConnection *\n_g_bus_get_singleton_if_exists (GBusType bus_type)\n{\n  GWeakRef *singleton;\n  GDBusConnection *ret = NULL;\n\n  G_LOCK (message_bus_lock);\n  singleton = message_bus_get_singleton (bus_type, NULL);\n  if (singleton == NULL)\n    goto out;\n\n  ret = g_weak_ref_get (singleton);\n\n out:\n  G_UNLOCK (message_bus_lock);\n  return ret;\n}\n\n/* May be called from any thread. Must not hold message_bus_lock. */\nvoid\n_g_bus_forget_singleton (GBusType bus_type)\n{\n  GWeakRef *singleton;\n\n  G_LOCK (message_bus_lock);\n\n  singleton = message_bus_get_singleton (bus_type, NULL);\n\n  if (singleton != NULL)\n    g_weak_ref_set (singleton, NULL);\n\n  G_UNLOCK (message_bus_lock);\n}\n\n/**\n * g_bus_get_sync:\n * @bus_type: a #GBusType\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously connects to the message bus specified by @bus_type.\n * Note that the returned object may shared with other callers,\n * e.g. if two separate parts of a process calls this function with\n * the same @bus_type, they will share the same object.\n *\n * This is a synchronous failable function. See g_bus_get() and\n * g_bus_get_finish() for the asynchronous version.\n *\n * The returned object is a singleton, that is, shared with other\n * callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the\n * event that you need a private message bus connection, use\n * g_dbus_address_get_for_bus_sync() and\n * g_dbus_connection_new_for_address().\n *\n * Note that the returned #GDBusConnection object will (usually) have\n * the #GDBusConnection:exit-on-close property set to %TRUE.\n *\n * Returns: (transfer full): a #GDBusConnection or %NULL if @error is set.\n *     Free with g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_bus_get_sync (GBusType       bus_type,\n                GCancellable  *cancellable,\n                GError       **error)\n{\n  GDBusConnection *connection;\n\n  _g_dbus_initialize ();\n\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  connection = get_uninitialized_connection (bus_type, cancellable, error);\n  if (connection == NULL)\n    goto out;\n\n  if (!g_initable_init (G_INITABLE (connection), cancellable, error))\n    {\n      g_object_unref (connection);\n      connection = NULL;\n    }\n\n out:\n  return connection;\n}\n\nstatic void\nbus_get_async_initable_cb (GObject      *source_object,\n                           GAsyncResult *res,\n                           gpointer      user_data)\n{\n  GTask *task = user_data;\n  GError *error = NULL;\n\n  if (!g_async_initable_init_finish (G_ASYNC_INITABLE (source_object),\n                                     res,\n                                     &error))\n    {\n      g_assert (error != NULL);\n      g_task_return_error (task, error);\n      g_object_unref (source_object);\n    }\n  else\n    {\n      g_task_return_pointer (task, source_object, g_object_unref);\n    }\n  g_object_unref (task);\n}\n\n/**\n * g_bus_get:\n * @bus_type: a #GBusType\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: a #GAsyncReadyCallback to call when the request is satisfied\n * @user_data: the data to pass to @callback\n *\n * Asynchronously connects to the message bus specified by @bus_type.\n *\n * When the operation is finished, @callback will be invoked. You can\n * then call g_bus_get_finish() to get the result of the operation.\n *\n * This is a asynchronous failable function. See g_bus_get_sync() for\n * the synchronous version.\n *\n * Since: 2.26\n */\nvoid\ng_bus_get (GBusType             bus_type,\n           GCancellable        *cancellable,\n           GAsyncReadyCallback  callback,\n           gpointer             user_data)\n{\n  GDBusConnection *connection;\n  GTask *task;\n  GError *error = NULL;\n\n  _g_dbus_initialize ();\n\n  task = g_task_new (NULL, cancellable, callback, user_data);\n  g_task_set_source_tag (task, g_bus_get);\n\n  connection = get_uninitialized_connection (bus_type, cancellable, &error);\n  if (connection == NULL)\n    {\n      g_assert (error != NULL);\n      g_task_return_error (task, error);\n      g_object_unref (task);\n    }\n  else\n    {\n      g_async_initable_init_async (G_ASYNC_INITABLE (connection),\n                                   G_PRIORITY_DEFAULT,\n                                   cancellable,\n                                   bus_get_async_initable_cb,\n                                   task);\n    }\n}\n\n/**\n * g_bus_get_finish:\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed\n *     to g_bus_get()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_bus_get().\n *\n * The returned object is a singleton, that is, shared with other\n * callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the\n * event that you need a private message bus connection, use\n * g_dbus_address_get_for_bus_sync() and\n * g_dbus_connection_new_for_address().\n *\n * Note that the returned #GDBusConnection object will (usually) have\n * the #GDBusConnection:exit-on-close property set to %TRUE.\n *\n * Returns: (transfer full): a #GDBusConnection or %NULL if @error is set.\n *     Free with g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_bus_get_finish (GAsyncResult  *res,\n                  GError       **error)\n{\n  g_return_val_if_fail (g_task_is_valid (res, NULL), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  return g_task_propagate_pointer (G_TASK (res), error);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/tests/utf8.txt",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/glib/tests/markups/fail-41.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/glib/tests/markups/fail-3.expected",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/glib/tests/markups/fail-2.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/glib/tests/markups/fail-52.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/glib/tests/markups/fail-41.expected",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/glib/tests/markups/fail-50.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/glib/tests/markups/fail-3.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/glib/tests/markups/fail-53.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/empty-key.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/bad-header.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/uri-mismatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/huge-chunk-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/valid-no-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/no-text-data.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/header-only.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/mtime-zero.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/valid.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/header-and-chunk-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/gio/tests/thumbnails/overlong-value.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/docs/reference/glib/mainloop-states.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/docs/reference/glib/mainloop-states.gif",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/docs/reference/glib/file-name-encodings.sxd",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/docs/reference/glib/file-name-encodings.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/docs/reference/gio/menu-model.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/docs/reference/gio/menu-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/docs/reference/gio/gvfs-overview.odg",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/docs/reference/gio/gvfs-overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.60.7-3usphrddp4sem3aqebivdghijeh6zeki/spack-src/docs/reference/gobject/images/glue.png"
    ],
    "total_files": 1859
}