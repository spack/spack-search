{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/ChangeLog.pre-2-2": "Fri Dec 20 10:45:29 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* === Released 2.2.0 ===\n\n\t* INSTALL.in: --enable-included-printf, not --enable-trio.\n\t(Matthias Clasen)\n\nFri Dec 20 09:52:15 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* INSTALL.in: Document --enable-trio, --disable-mempools,\n\t--enable-debug. Include docs on cross compilation.\n\n\t* NEWS: Update.\n\n\t* configure.in: Version 2.2.0, interface age 0.\n\nFri Dec 20 09:37:27 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* gthread/gthread-impl.c (g_thread_init): Call g_main_thread_init()\n\tafter setting g_threads_got_initialized. (#101624, \n\tAlceste Scalas, Sebastian Wilhelmi)\n\nWed Dec 18 16:19:08 2002  Manish Singh  <yosh@gimp.org>\n\n\t* glib/gtypes.h: new endian asm for ia64 and x86_64, general\n\treorg and clean up. New implementation of GUINT16_SWAP_LE_BE_CONSTANT()\n\tthat should optimize better. (#101318)\n\n2002-12-17  Tor Lillqvist  <tml@iki.fi>\n\n\tImprovement based on suggestion by Thorsten Maerz:\n\n\t* glib/giowin32.c (struct _GIOWin32Channel): Don't need thread_handle.\n\n\t(create_thread): We can close thread handle right away, it isn't\n\tused for anything.\n\n\t(read_thread, select_thread): Thus, don't close it here.\n\n\tFix #57690, partial fix for #57689:\n\t\n\t* glib/giowin32.c (g_io_win32_set_flags): Don't set the GError,\n\tinstead call g_warning().\n\n\t(g_io_win32_fd_get_flags_internal): New function, sets the\n\tis_readable, is_writeable and is_seekable flags based on the\n\tactual access modes of the underlying Win32 HANDLE, by trying\n\tWin32 ReadFile() and WriteFile() of zero bytes, and\n\tPeekNamedPipe(). Should work for disk files and pipes. For devices\n\t(consoles) unfortunately not.\n\n\t(g_io_win32_fd_get_flags): Don't set the\n\tG_IO_FLAG_IS_{READ,WRITE}ABLE flags, g_io_channel_get_flags()\n\talready does. Call g_io_win32_fd_get_flags_internal() to set the\n\tis_* flags.\n\n\t(g_io_win32_msg_get_flags, g_io_win32_sock_get_flags): Splice the\n\tgeneric g_io_win32_get_flags() into these specific functions, as\n\tthey need to do different things. Not implemented yet, though.\n\n\t(g_io_channel_win32_new_fd_internal): New function, to avoid\n\tduplicate fstat() calls. Most code from g_io_channel_win32_new_fd() \n\tmoved here. Call g_io_win32_fd_get_flags_internal() to set the\n\tis_* flags.\n\n\t(g_io_channel_win32_new_fd, g_io_channel_unix_new): Call\n\tg_io_channel_win32_new_fd_internal().\n\n\t(g_io_win32_no_seek): Remove. Don't set is_seekable for those\n\tchannel types.\n\nMon Dec 16 17:31:50 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* === Released 2.1.5 ===\n\n\t* configure.in: Version 2.1.5, interface age 2.\n\n\t* NEWS: Updated.\n\nMon Dec 16 14:58:33 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Add a hack to mostly deal with\n\tproblems in support of -pthread and -lpthread;\n\tpass -lpthread (for linux) or -Wc,-pthread (for\n\tother platforms) to libtool when linking libgthread. \n\t(#100697)\n\n2002-12-16  Tor Lillqvist  <tml@iki.fi>\n\n\t* glib/gspawn-win32.c (do_spawn): Fix potential heap\n\tcorruption. Sometimes called g_free() on string literal.\n\nSun Dec 15 19:51:58 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* m4macros/glib-gettext.m4: AC_SUBST() DATADIRNAME, not \n\tDATADIR.\n\nSun Dec 15 19:22:58 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* m4macros/glib-gettext.m4: Restore a missing AC_SUBST()\n\tfor DATADIRNAME. (Found by Kjartan Maraas)\n\nSun Dec 15 11:24:29 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* m4macros/glib-gettext.m4: Actually set INTLLIBS\n\twhen needed. (Reported by Tor Lillqvist)\n\n2002-12-15  Tor Lillqvist  <tml@iki.fi>\n\n\t* glib/glib.def: Add g_rand_init.\n\n\t* config.h.win32.in: Slight update to match what is currently\n\tproduced by configure.\n\nSat Dec 14 21:24:04 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gutils.c (g_get_any_init): HP-UX 10 xshares the\n\tsame non-posix getpwuid_r signature as AIX. \n\t(#100756, Kai Poitschke)\n\nSat Dec 14 21:10:57 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gthread.h: Mark the contents of the strucures\n\tin this file /*< private >*/\n\n\t* glib/gthread.[ch]: Rename the 'write' field of the\n\tstructure to 'have_writer' to avoid any possible\n\tconflict with system headers. (#90549, Morten Welinder)\n\nSat Dec 14 20:11:41 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/libcharset/{localcharset.[ch] libcharset-glib.patch}\n\tglib/gutf8.c: Break _g_locale_charset() into two pieces \n\t- a fast \"raw\" piece, and a slow \"unalias pieces\". \n\tAlways call the \"raw\" piece, and call the unalias bit\n\tif it changes. Use a per-thread cache. (#79529)\n\n2002-12-15  Matthias Clasen  <maclas@gmx.de>\n\n\t* configure.in: Set TRIO_LIBS when building with trio.\n\n\t* glib-2.0.pc.in (Libs): Add @TRIO_LIBS@.\n\n\t* glib/trio/Makefile.am (libtrio_la_LIBADD): Use @TRIO_LIBS@.\n\n\t* glib/trio/glibtrio.h: New file, redefining all trio symbols to\n\tfall into the _G/_g_ private glib namespace.\n\n\t* glib/trio/Makefile.am (libtrio_la_SOURCES): Add glibtrio.h\n\n\t* glib/trio/trionan.c: \n\t* glib/trio/triostr.c: \n\t* glib/trio/trio.c: Include glibtrio.h\n\n\t* glib/gprintfint.h: \n\t* glib/trio/trionan.c: \n\t* glib/trio/triostr.c: \n\t* glib/trio/trio.c: Include glibtrio.h\n\nFri Dec 13 17:10:21 2002  Manish Singh  <yosh@gimp.org>\n\n\t* glib/gscanner.c (g_scanner_unexp_token): Fix typo. Missing '%'\n\tin my last commit.\n\nThu Dec 12 23:08:29 2002  Owen Taylor  <otaylor@redhat.com>\n\n\tFixes from Johannes Stezenbach\n\n\t* configure.in: When adding extra libraries to $LIBS for\n\ttests, always put them at the front, since that's how\n\tthey'll be used in the actual Makefiles.\n\n\t* configure.in: Add a couple of missing ','s in AC_LINK_IFELSE()\n\n\t* m4macros/glib-gettext.m4: Remove a stray setting of $LIBS.\n\nThu Dec 12 20:46:26 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Allow not setting glib_cv_long_long_format\n\twhen cross-compiling since we assume other things that\n\twill cause us to pull in Trio anyways.\n\n\t* configure.in: long_long_format is always ll for trio.\n\t\n\t* configure.in: Error out if --disable-trio is specified\n\tbut the C library doesn't have the necessary features.\n\n2002-12-13  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/trio/Makefile.am (libtrio_la_LIBADD): Add -lm for pow().\n\n\t* tests/string-test.c: Add a test for positional parameters in\n\tg_snprintf().\n\nThu Dec 12 14:58:55 2002  Manish Singh  <yosh@gimp.org>\n\n\t* configure.in: pull in trio if host printf doesn't have a known\n\tway of printing 64-bit ints.\n\n\t* glib/gmacros.h: remove extra whitespace at the end\n\n\t* glib/gscanner.c (g_scanner_unexp_token): use G_GUINT64_FORMAT\n\tinstead of hardcoding \"%llu\"\n\n\t* tests/testglib.c: remove obsolete conditionals using G_HAVE_GINT64,\n\twe always have it now.\n\n\t* tests/type-test.c: same as above, and for G_G[U]INT64_FORMAT as\n\twell.\n\nThu Dec 12 13:52:58 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* m4macros/glib-gettext.m4: AC_PREREQ(2.53) here; convinces\n\tDebian's wrappers to use the right autoconf for atk, etc.\n\t(Reported by Jody Goldberg)\n\n2002-12-11  Tor Lillqvist  <tml@iki.fi>\n\n\t* glib/gtimer.c (g_timer_elapsed): Fix off-by-one error. (#100853)\n\n\t* glib/gfileutils.c (g_file_test): Bypass extra test for root on\n\tWin32.\n\n\t* glib/glib.def: Add g_{get,set}_application_name.\n\nWed Dec 11 17:53:34 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* === Released 2.1.4 ===\n\n\t* NEWS: Updates.\n\nWed Dec 11 17:49:15 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* m4macros/glib-gettext.m4: Unset \n\tac_cv_func_bind_textdomain_codeset before calling\n\tAC_CHECK_FUNCS(bind_textdomain_codeset) again.\n\n\t* configure.in: Remove duplicate call to\n\tAC_CHECK_FUNCS(bind_textdomain_codeset)\n\n2002-12-11  Pauli Virtanen <pauli.virtanen@hut.fi>\n\n\t* configure.in: Added \"fi\" to ALL_LINGUAS.\n\nWed Dec 11 17:00:20 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* acglib.m4 (ac_compile): Add GLIB_ASSERT_SET() as\n\ta helper for adding \"must be set when cross-compiling\"\n\terrors.\n\n\t* configure.in: For all cached variables without defaults,\n\terror out if they aren't set.\n\nWed Dec 11 15:52:01 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Also assume AC_LINK_IFELSE() is\n\tOK when cross-compiling for the libs checks, and for\n\tthe sched_get_priority_min() check.\n\n\t* configure.in: Add cached value glib_cv_use_pid_surrogate.\n\t\nWed Dec 11 15:10:25 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Factor out repeated thread test into\n\ta m4_define(); when cross-compiling, assume that \n\tAC_LINK_IFELSE() is good enough for thinking that\n\t-pthread[s] is OK. (More of #58786)\n\n\t* m4macros/glib-gettext.m4: Fix typo. (Manish Singh)\n\nWed Dec 11 14:28:50 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Version 2.1.4, interface age 1.\n\n\t* m4macros/glib-gettext.m4: Major rewrite; remove leftovers\n\tfrom building intl/, prefer libintl if both libc and libintl \n\thave dgettext and libintl also has bind_textdomain_codeset().\n\t(#70627)\n\n\t* configure.in acinclude.m4: Use an include to avoid having \n\tto duplicate the gettext macros between glib-gettext.m4\n\tand acinclude.m4.\n\n\t* m4macros/glib-gettext.m4: Do some tricks so that configure.in \n\tcan use macros under hidden names, but aclocal will still \n\tfind them when installed.\n\n\t* m4macros/glib-gettext.m4: Add AM_GLIB_DEFINE_LOCALEDIR\n\tto encapsulate install location of catalog files.\n\n\t* m4macros/glib-gettext.m4 (AM_GLIB_DEFINE_LOCALEDIR):\n\tFix bug where if --prefix wasn't set on the configure line,\n\tGLib would look for translations in NONE/share/locale.\n\nWed Dec 11 11:11:44 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/grand.c: Include string.h, supress a warning.\n\n2002-12-10  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib/grand.c (g_rand_int_range): Improve generation of\n\tpseudo-random integers. (#99720, Morten Welinder <terra@diku.dk>)\n\n\t* README.in, docs/reference/glib/running.sgml,\n\tdocs/reference/glib/tmpl/random_numbers.sgml,\n\tdocs/reference/glib/changes.sgml: Added notes about the new\n\talgorithm.\n\n2002-12-09  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: use 0 instead of $defattr, as it isn't defined\n\tanymore on platforms using -pthread and linux, where this is used,\n\tonly uses 0 anyway and not \"pthread_attr_default\".\n\nSun Dec  8 23:36:12 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gfileutils.c (g_file_test): Guard against\n\tthe POSIX allowed behavior where access (file, X_OK)\n\tsucceeds for uid==0 when no executable bits are set.\n\n\t* glib/gfileutils.c (g_file_test): Add doc notes\n\tabout the possibility of race conditions, and the\n\tfact that EXISTS and IS_EXECUTABLE give results\n\tfor the real uid not the effective user ID.\n\t(#81854, Morten Welinder.)\n\nFri Dec  6 14:34:42 2002  Owen Taylor  <otaylor@redhat.com>\n\n\tAvoid literal UTF-8. (Allow it to build with \n\tIRIX cc, #72757, Tomas Ogren)\n\n\t* tests/patterntest.c (main): Convert literal \n\tiso-8859-1 high bit characters in tests to\n\tstring escapes.\n\n\t* glib/gunichartable.h glib/gen-unicode-tables.pl:\n\tUse hex \\xMN escapes rather than literal UTF-8\n\tfor casefold tables.\n\n\t* configure.in: AC_PREREQ(2.53). needed for recent\n\tGLIB_SIZEOF() changes.\n\nFri Dec  6 12:40:00 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/libcharset/Makefile.am (EXTRA_DIST): Don't\n\tdistribute ref-add/del.sed., fixing problem with\n\tsrcdir != destdir. (#99813, Phuc LeHong)\n\nFri Dec  6 12:31:30 2002  Owen Taylor  <otaylor@redhat.com>\n \n \t* configure.in: chmod 0755 scripts in AC_OUTPUT(), since \n \tinstall -c won't necessarily do that. (#74376, Martin\n\tGansser, Joshua Weage)\n \nThu Dec  5 16:05:55 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Use AC_LINK_IFELSE(), not AC_TRY_RUN()\n\tfor va_copy(), __va_copy() checks.\n\n\t* configure.in: When there is a reasonable default,\n\tprovide that in the 3rd argument of AC_TRY_RUN(),\n\tinstead of just leaving the 3rd argument empty.\n\n2002-12-05  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gstrfuncs.c (g_strncasecmp): Break long deprecation\n\tinfo into two paragraphs.\n\nThu Dec  5 15:43:46 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Fix multiple problems with the programs\n\tin the argument of AC_TRY_RUN() having preprocessor\n\tdefines not in the first column.\n\nThu Dec  5 15:24:14 2002  Owen Taylor  <otaylor@redhat.com>\n\n\tStart of fixes for cross-compilation. Based on\n\tpatches from Dimi Shahbaz, Dan Kegel, Johannes Stezenbach,\n\tAmy Lin. (#58786)\n\n\t* configure.in: Don't run the Digital-Unix 4 -std1 check\n\twhen cross_compiling.\n\n\t* configure.in: Use AC_TRY_COMPILE() rather than \n\tAC_TRY_RUN() for inline checks. (Daniel Egger)\n\n\t* configure.in: use AC_CHECK_SIZEOF rather than\n\tGLIB_SIZEOF for size_t. Remove unused checks for\n\tsize of ptrdiff_t/intmax_t.\n\n\t* acglib.m4: Resync GLIB_SIZEOF of to the current\n\tAC_CHECK_SIZEOF, which handles cross-compilation.\n\n\t* acglib.m4: Remove no longer needed GLIB_SYSDEFS(),\n\tadd GLIB_CHECK_VALUE() as a wrapper around the\n\tamazing _AC_COMPUTE_INT() autoconf 2.5x internal.\n\n\t* configure.in: Redo the POLL* value checks in a\n\tcross-compilation friendly way.\n\nThu Dec  5 15:28:37 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gtimer.c: Include glibconfig.h early so\n\tthat we include <windows.h> when needed.\n\n\t* glib/gstrfuncs.c: Fix typo.\n\nTue Dec  3 21:10:28 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Add 3rd argument to remaining AC_DEFINES(),\n\tso we can get rid of acconfig.h. (#76334, Daniel Egger)\n\n\t* acconfig.h: Removed.\n\nTue Dec  3 20:22:27 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/*.c: Patch from Sven Neumann to make the\n\tinclude order consistent. (#71704)\n\n2002-12-03  Matthias Clasen  <maclas@gmx.de>\n\n\t* configure.in: Check that strlcpy behaves as per the OpenBSD \n\tman page before wrapping it.  (#53933)\n\n2002-12-03  Frederic Crozat  <fcrozat@mandrakesoft.com>\n\n\t* glib/gunicollate.c: (g_utf8_collate_key):\n\tFix typo from previous commit\n\nTue Dec  3 01:05:00 2002  James M. Cape  <jcape@ignore-your.tv>\n\n\t* glib/gunicollate.c (g_utf8_collate, g_utf8_collate_key):\n\tCheck for NULL before doing anything.\n\nMon Dec  2 16:34:13 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* === Released 2.1.3 ===\n\n\t* NEWS: Updated.\n\n\t[ Unmerged change from stable from May 16 ]\n\n\t* autogen.sh: Remove check for GNU gettext, since it\n\twas causing problems for Solaris CVS builds.\n\t(#81885, Hidetoshi Tajima.)\n\nTue Nov 26 09:51:43 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gstrfuncs.c (g_strchomp): Avoid non-ANSI pointer\n\tcomparison. (#54344, Morten Welinder)\n\n\t* tests/strfunc-test.c (main): Add tests for strchomp().\n\n2002-11-30  Ole Laursen  <olau@hardworking.dk>\n\n\t* configure.in: Added \"da\" to ALL_LINGUAS.\n\n2002-11-29  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gstrfuncs.c (g_ascii_strtoull): It is a 2.2 addition.\n\n\t* glib/gtimer.c (g_time_val_add): Adjust to changed parameter names.\n\n\t* glib/gutils.c (g_get_application_name): Mark as 2.2. addition.\n\n\t* glib/gstrfuncs.c (g_ascii_strtoull): Mark as 2.0.7 addition. \n\n2002-11-28  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gutils.c:\n\t* glib/gtree.c: \n\t* glib/gstring.c: \n\t* glib/gstrfuncs.c: \n\t* glib/giochannel.c: Move some docs inline, and add deprecation\n\tinformation. To see the list of affected functions, grep for\n\t\"Deprecated:\". \n\n\t* configure.in: Fix the definitions around printf: either we use\n\tsystem printf in which case HAVE_VASPRINTF, HAVE_C99_VSNPRINTF and\n\tHAVE_UNIX98_PRINTF have already been determined by earlier tests,\n\tor we use the included printf, in which case we know that these\n\tthree can be defined as 1.  (#99826)\n\n\t* glib/gutf8.c (g_utf8_strreverse): \n\t* glib/gstrfuncs.c (g_str_has_suffix): \n\t(g_str_has_prefix): \n\t* glib/gprintf.c (g_printf): \n\t(g_fprintf): \n\t(g_sprintf): \n\t(g_vprintf): \n\t(g_vfprintf): \n\t(g_vsprintf): \n\t* glib/gmarkup.c (g_markup_parse_context_get_element): \n\tMark as 2.2 API additions.\n\n\t* configure.in: Fix the gtk-doc version check.\n\n2002-11-27  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gmessages.h: Use G_LIKELY without surrounding parentheses \n\tin g_assert() and g_return_[val]_if_fail() so that we always trigger\n\tthe gcc warning about \"assignment used as truth value\".\n\n\t* glib/gmacros.h: Always put parentheses in G_LIKELY and G_UNLIKELY.\n\n2002-11-26  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gmessages.h: Only use G_LIKELY in g_assert() and \n\tg_return_[val]_if_fail() if it is actually doing something.\n\n2002-11-26  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib/grand.c, gthread/gthread-impl.c, tests/rand-test.c: \n\tChanged the seeding algorithm. Old behaviour can be achived by\n\tsetting envvar G_RANDOM_VERSION to \"2.0\". (#99262)\n\n\t* docs/reference/glib/glib-docs.sgml,\n\tdocs/reference/glib/Makefile.am: Renamed\n\tdocs/reference/glib/changes-2.0.sgml to\n\tdocs/reference/glib/changes.sgml and added section for changes\n\tfrom 2.0 to 2.2 (Also corrected 1.0 to 1.2).\n\n\t* README.in, docs/reference/glib/running.sgml,\n\tdocs/reference/glib/tmpl/random_numbers.sgml,\n\tdocs/reference/glib/changes.sgml: Added notes about the new\n\tseeding algorithm.\n\n\t* configure.in: Make CPPFLAGS, not CFLAGS, include\n\tG_THREAD_CFLAGS. CFLAGS is used while linking too and thus GLib\n\tprograms would link to the threads library on some platforms. Also\n\tfixed a bug manifesting through this change. (#77981)\n\n2002-11-26  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gmacros.h: Fix the non-gcc-3.x definitions of G_LIKELY \n\tand G_UNLIKELY.  (Reported by Dan Mills)\n\n2002-11-25  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gfileutils.c (g_build_path): \n\t(g_build_filename): Document that the varargs must be \n\tNULL-terminated. (#99510)\n\n\t* glib/gmessages.h (g_assert): \n\t(g_return_if_fail): \n\t(g_return_val_if_fail): Remove the (no longer effective) empty\n\tif-branch.\n\n\t* glib/gmacros.h: Change the definition of G_LIKELY, so that\n\tg_return_if_fail() and friends still trigger a gcc warning if\n\tthe expr is an assignment. \n\n2002-11-23  Matthias Clasen  <maclas@gmx.de>\n\n\t* configure.in: Generate docs/reference/*/version.xml.\n\n\t* glib/gdir.h: Add Copyright notice.\n\n2002-11-22  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Fixed typo: PTHREAD_PRIO_MIN ->\n\tPTHREAD_PRIO_MAX. (Laurent Vivier, #99293)\n\nFri Nov 22 09:39:09 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gmacros.h: Remove broken G_HIDDEN_SYMBOL\n\tdefinition which wasn't supposed to be committed\n\tat all.\n\nThu Nov 21 16:19:21 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/ghash.c: Patch from Morten Welinder to \n\tmake ghash.c properly obey DISABLE_MEM_POOLS. (#96600)\n\nThu Nov 21 14:09:44 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gmacros.h: Add G_GNUC_DEPRECATED. (Tom Tromey,\n\t#87969)\n\n2002-11-21  Tor Lillqvist  <tml@iki.fi>\n\n\t* config.h.win32.in: Update to match what is currently produced by\n\tautotools.\n\n\t* configure.in: Remove superfluous spaces on two shell variable\n\tassignment lines. Don't define HAVE_GOOD_PRINTF as 0 if we don't\n\thave a good printf, it is tested with #ifdef.\n\n\t* glib/glib.def: Add new functions.\n\n\t* glib/Makefile.am: If !HAVE_GOOD_PRINTF, add libtrio.la to LIBADD\n\tand DEPENDENCIES.\n\n\t* glib/glib.rc.in\n\t* gmodule/gmodule.rc.in\n\t* gobject/gobject.rc.in\n\t* gthread/gthread.rc.in\n\t* {glib,gmodule,gobject,gthread}/makefile.{mingw,msc}.in:\n\tHardcode 2.0 in the names, as that is what Makefile.am does.\n\n2002-11-21  Matthias Clasen  <maclas@gmx.de>\n\n\tInclude a printf implementation supporting C99 snprintf and SUS\n\tpositional parameters:  (#79488)\n\t\n\t* glib/gstrfuncs.c:\n\t* glib/gspawn-win32.c:\n\t* glib/gscanner.c:\n\t* glib/gconvert.c: \n\t* glib/gbacktrace.c: Use _g_printf wrappers. \n\n\t* glib/gutils.c (g_vsnprintf): Simplify, since we can assume C99\n\tsnprintf semantics now.\n\n\t* glib/gmessages.c (printf_string_upper_bound): No longer needed,\n\tsince we can assume C99 snprintf semantics now.\n\t(g_logv): Simplify.\n\t\n\t* acinclude.m4 (AC_FUNC_PRINTF_UNIX98): New macro to check wether\n\tprintf supports SUS positional parameters.\n\n\t* configure.in: New option --enable-included-printf to force\n\tcompilation of trio; otherwise trio is compiled if the system\n\tprintf misses either C99 snprintf semantics of SUS positional \n\tparameters.\n\n\t* glib/Makefile.am (SUBDIRS): Conditionally compile trio.\n\t(libglib_2_0_la_SOURCES): Add gprintf.c and gprintfint.h.\n\t(glibsubinclude_HEADERS): Add gprintf.h.\n\n\t* glib/gprintfint.h: New private wrapping either system printf\n\tor trio printf variants in _g_printf wrappers for use inside glib.\n\n\t* glib/gprintf.h: New public header declaring g_printf variants.\n\t* glib/gprintf.c: Corresponding implementations.\n\n\t* glib/trio/*: New directory, containing the trio-1.9 sources. \n\n2002-11-20  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gmessages.h (g_return_if_fail): \n\t(g_return_val_if_fail): Use G_LIKELY.  (#69022)\n\n\t* glib/gmacros.h (G_LIKELY): \n\t(G_UNLIKELY): New macros for hinting the compiler about the\n\texpected result of expressions. For gcc 3.x, define these\n\tusing __builtin_expect.  (#69022)\n\nTue Nov 19 14:38:18 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gstrfuncs.c (g_ascii_strtoull): Fix \n\tstrtull/strtoull type in docs (#99012, Morten\n\tWelinder.) Add copyright information for code\n\ttaken from GNU libc.\n\n2002-11-18  Tor Lillqvist  <tml@iki.fi>\n\n\t* glib/gspawn-win32.c (do_spawn_with_pipes): Do handle\n\tG_SPAWN_DO_NOT_REAP_CHILD after all, similarily as on Unix. If the\n\tflag is not set, don't call DuplicateHandle() on the handle\n\treturned by the helper process, and set the \"child pid\" returned\n\tto the called to zero. Close the handle to the helper process in\n\tall cases.\n\n\t* glib/gspawn.c (g_spawn_async_with_pipes): Document Windows\n\tbehaviour of G_SPAWN_DO_NOT_REAP_CHILD.\n\n2002-11-18  Tor Lillqvist  <tml@iki.fi>\n\n\t[Win32] Fix the asynchronous g_spawn* to return the process handle\n\tof the started program properly. (Note: not the process id. The\n\tspawn*() functions in the C runtime return the created process's\n\thandle. There doesn't seem to be any way to get the process id of\n\ta child process if you have the handle. But then, the process\n\thandle usually is more useful anyway.)\n\n\t* glib/gspawn-win32-helper.c (WinMain): If the spawning of the\n\tchild process succeeded, and if asynchronous spawn (P_NOWAIT),\n\twrite the result handle up to the parent process, waiting to read\n\tit in do_spawn_with_pipes().\n\n\t* glib/gspawn-win32.c (do_spawn): Use return value from spawning\n\tthe helper. If it is -1 the helper wasn't found or couldn't be run\n\tfor some reason. Otherwise it is the helper's process handle.\n\n\t(g_spawn_async_with_pipes): Pass the child_pid parameter on to\n\tdo_spawn_with_pipes().\n\n\t(do_spawn_with_pipes): Take also a child_pid parameter. If\n\tdo_spawn() returned -1, fail immediately. Otherwise make the\n\thandle passed to us by the helper process into a handle valid in\n\tthis process by calling DuplicateHandle().\n\n2002-11-17  Tor Lillqvist  <tml@iki.fi>\n\n\t* glib/gspawn-win32.c (g_spawn_async_with_pipes): Ignore the\n\tG_SPAWN_DO_NOT_REAP_CHILD flag, can't be meaninfully implemented\n\ton Windows, at least not now. Always pass dont_wait as TRUE to\n\tdo_spawn_with_pipes(). The semantics of the dont_wait parameter is\n\tvery different from the semantics of the intermediate_child\n\tparameter to fork_exec_with_pipes() in the Unix version. This\n\tfixes a serious bug, g_spawn_async() in fact behaved\n\tsynchronously.\n\n\t(do_spawn_with_pipes, do_spawn): Rename from\n\tfork_exec_with_pipes() and do_exec(), those names were from the\n\tUnix bersion, and misleading.\n\n\t(close_and_invalidate): Don't try to close invalid fds.\n\n\t* glib/gspawn.c (g_spawn_async_with_pipes): Add warning about\n\tWindows behaviour. There is no fork(), so the child_setup()\n\tfunction is in fact called in the parent.\n\t\n\t* glib/gspawn-win32-helper.c (WinMain): Insert spaces in argv\n\tdebugging output.\n\n\t* tests/spawn-test-win32-gui.c: New file. Test program to be\n\tlinked as a GUI application. Behaves differently depending on how\n\tinvoked (by spawn-test).\n\n\t* tests/spawn-test.c (run_tests): On Win32, run the\n\tspawn-test-win32-gui program, too, in several ways, synchronously\n\tand asynchronously.\n\n\t* tests/Makefile.am: Corresponding change.\n\nFri Nov  8 19:44:20 2002  Soeren Sandmann  <sandmann@daimi.au.dk>\n\n\t* docs/reference/glib/tmpl/arrays.sgml:\n\t* docs/reference/glib/tmpl/arrays_byte.sgml:\n\t* docs/reference/glib/tmpl/arrays_pointer.sgml:\n\t* docs/reference/glib/tmpl/date.sgml:\n\t* docs/reference/glib/tmpl/linked_lists_double.sgml:\n\t* docs/reference/glib/tmpl/linked_lists_single.sgml:\n\t* docs/reference/glib/tmpl/main.sgml:\n\t* docs/reference/glib/tmpl/queue.sgml:\n\t* docs/reference/glib/tmpl/random_numbers.sgml:\n\t* docs/reference/glib/tmpl/relations.sgml:\n\t* docs/reference/glib/tmpl/scanner.sgml:\n\t* docs/reference/gobject/tmpl/gtype.sgml:\n\t* docs/reference/gobject/tmpl/value_arrays.sgml glib/garray.h:\n\t* glib/gdate.h glib/giochannel.h glib/glist.h glib/gmain.c:\n\t* glib/gmain.h glib/gqueue.c glib/gqueue.h glib/grand.c glib/grand.h:\n\t* glib/grel.h glib/gslist.h glib/gtimer.h gobject/gvaluearray.h:\n\n\tTrivial s/foo/foo_/ fixes to make <glib.h> includable with\n\t-Wshadow without warnings (#91680)\n\nThu Nov  7 19:32:26 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gutils.[ch] (g_set/get_application_name): \n\tPatch from Havoc Pennington to add functions for \n\tsetting and getting a human readable application\n\tname.\n\n\t* configure.in: Up to version 2.1.3, since we'll\n\tneed to depend on last addition for GTK+.\n\n2002-11-06  Tor Lillqvist  <tml@iki.fi>\n\n\t* glib/glib.def: Add g_main_thread_init.\n\n2002-11-06  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gstrfuncs.c (g_str_has_suffix): \n\t(g_str_has_prefix): Minor doc markup fix.\n\nMon Nov  4 10:45:48 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Add -DG_DISABLE_CAST_CHECKS for \n\teverything but --enable-debug.\n\n\t* configure.in: Require pkg-config 0.14. (#97553)\n\nMon Nov  4 14:41:48 2002  Owen Taylor  <otaylor@redhat.com>\n \n \t* glib/gbsearcharray.c: Include config.h\n \tso DISABLE_MEMPOOLS actually has an effect.\n \t(#96437, Morten Welinder)\n \n \t* tests/uri-test.c: Include <config.h>\n\n2002-11-03  Dmitry G. Mastrukov  <dmitry@taurussoft.org>\n\n\t* configure.in: Added Belarusian to ALL_LINGUAS\n\n2002-11-02  Daniel Elstner  <daniel.elstner@gmx.net>\n\n\t* glib/giochannel.c (g_io_channel_write_chars): Fix left_len\n\tcalculation in the from UTF-8 to UTF-8 case: left_len should\n\tbe the number of bytes left in the input buffer rather than\n\tchannel->write_buf. (#96373)\n\n2002-10-27  Tor Lillqvist  <tml@iki.fi>\n\n\t* configure.in (G_MODULE_LDFLAGS): Don't set on Win32, only causes\n\ttrouble.\n\t\n\t* glib/gmain.c (g_poll): Fix for bug reported by Herman Bloggs\n\t(http://mail.gnome.org/archives/gtk-devel-list/2002-October/msg00101.html)\n\tand others. We waited for events only for GPollFDs whose events\n\tfield had G_IO_IN set. We need to wait also for events for\n\tGPollFDs that have just G_IO_OUT set. Non-blocking sockets in the\n\tprocess of being connect()ed are one such case. Also silence a\n\tcouple of gcc warnings.\n\nFri Oct 18 13:41:30 2002  Manish Singh  <yosh@gimp.org>\n\n\t* glib/giochannel.c (g_io_channel_read_line_backend): avoid\n\tcreating negative values out of unsigned values using MAX,\n\tcheck to see if the result would be positive before doing\n\tthe calculation.\n\nTue Oct 15 15:28:47 2002  Manish Singh  <yosh@gimp.org>\n\n\t* tests/iochannel-test.c: use gsize instead of int where appropriate\n        (64-bit cleanliness fix). Removed leftover line_term cruft.\n\nTue Oct 15 15:07:45 2002  Manish Singh  <yosh@gimp.org>\n\n\t* gmodule/Makefile.am gobject/Makefile.am gthread/Makefile.am:\n\tadd -DG_DISABLED_DEPRECATED\n\n\t* tests/gio-test.c tests/mainloop-test.c tests/string-test.c\n\ttests/testglib.c test/tree-test.c tests/unicode-collate.c\n\ttests/unicode-normalize.c: Deprecation cleanup\n\nMon Oct 14 15:51:05 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gdate.c (g_date_fill_parse_tokens): Fix a memory\n\tleak. (#94550, Sebastian Rittau)\n\nMon Oct 14 15:36:11 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gcompletion.[ch] (g_completion_complete): Make\n\tprefix argument const. (#91662, Gustavo Carneiro) \n\nMon Oct 14 15:32:14 2002  Owen Taylor  <otaylor@redhat.com>\n \n \t* tests/mainloop-test.c (adder_response): Fix a minor memory\n \tleak.\n \nSat Oct 12 21:30:41 2002  Tim Janik  <timj@gtk.org>\n\n\t* merged up from glib-2-0:\n\n        * glib/gstrfuncs.c (g_ascii_strtod): fix comment.\n        (g_ascii_strtoull): new function, acting like strtoull(3) in the C\n        locale.\n\n        * glib/gscanner.[hc]: fix 32bit issues with integer parsing and\n        support storing 64bit values in GTokenValue by\n        using g_ascii_strtoull().\n\nSat Oct 12 12:34:22 2002  Soeren Sandmann  <sandmann@daimi.au.dk>\n\n\t* glib/gtree.c (g_tree_search), glib/gspawn.c\n\t(g_spawn_async_with_pipes): \n\n\tDocumentation fixes: #71778, Owen Taylor; #85095, Bill Janssen,\n\tOwen Taylor. \n\nThu Oct 10 23:27:02 2002  Tim Janik  <timj@gtk.org>\n\n        * glib/gscanner.c (g_scanner_msg_handler): if input_name is NULL,\n        print out \"<memory>\" instead of completely skipping input specification\n        and thusly loosing error line information.\n\nSun Sep 29 12:15:44 2002  Manish Singh  <yosh@gimp.org>\n\n\t* tests/mainloop-test.c: use gsize instead of int where appropriate\n\t(64-bit cleanliness fix)\n\n2002-09-29  Tor Lillqvist  <tml@iki.fi>\n\n\t* configure.in: Instead of forcing -fnative-struct into CFLAGS\n\twhen using gcc for Win32, check for gcc version 3.x which uses\n\t-mms-bitfields instead. Also check if either of these switches is\n\tactually available at all, and warn if not. Thanks to Soren\n\tAndersen for the inspiration.\n\n\t* HACKING: Say we require autoconf 2.52 as that is what\n\tconfigure.in does.\n\n2002-09-23  Arvind Samptur <arvind.samptur@wipro.com>\n\t* glib/gspawn.c (fork_exec_with_pipes) : when the child fails\n\twe need to reap it to avoid a zombie. This would\n\thappen in case of g_spawn_sync. Fixes #92658\n\n2002-09-20  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gscanner.c (g_scanner_msg_handler): Don't print\n\tscanner->input_name when it is NULL.  (#93752)\n\n2002-09-06  Havoc Pennington  <hp@redhat.com>\n\n\t* autogen.sh: automake 1.4\n\n2002-09-01  Soeren Sandmann  <sandmann@daimi.au.dk>\n\n\t* docs/reference/glib/tmpl/datalist.sgml, glib/gmain.c:\n\n\tDocumentation fixes: (#75255, Martin Schulze; #76104, Daryll Strauss)\n\n2002-08-26  Tor Lillqvist  <tml@iki.fi>\n\n\t* configure.in (G_LIBS_EXTRA): Don't link with -lwsock32 on\n\tCygwin (#91696, Masahiro Sakai).\n\nTue Aug 20 16:01:03 2002  HideToshi Tajima  <hidetoshi.tajima@sun.com>\n\n\t* glib/gconvert.c (strdup_len): validate 'len' argument properly\n\tfor the case that input string is not null-terminated. (#91222)\n\n2002-08-10  Gustavo Noronha Silva  <kov@debian.org>\n\n\t* configure.in: added pt_BR to ALL_LINGUAS\n\n2002-08-07  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gmarkup.c (g_markup_parse_context_get_element): \n\tUse g_return_val_if_fail, no g_return_if_fail.\n\n2002-08-06  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib/gthread.c: Set the normal PID surrogate priority according\n\tto getpid() to avoid errors for niced processes. (#86116)\n\n\t* gthread/gthread-impl.c, gthread/gthread-posix.c,\n\tgthread/gthread-solaris.c: Do the same for the posix/dce\n\timplementation. Solaris still needs to set priority of the main\n\tthread, because all unbound threads will schedule according to\n\tthat value and it defaults to 0 (the minimal value). \n\n\t* glib/gmain.c: Factor out g_main_context_init_pipe from\n\tg_main_context_new to initialize the wakeup pipe of a\n\tcontext. Call that function from g_main_context_new if threads are\n\tinitialized and for all contexts when threads are initialized\n\tin g_main_thread_init. (#86872) \n\n\t* gthread/gthread-impl.c: Call g_main_thread_init. (#86872) \n\nThu Jul 25 14:23:15 2002  Owen Taylor  <otaylor@redhat.com>\n\n \t* glib/gfileutils.c: Clarify the behavior of g_build_path()\n \tfor empty elements and for leading and trailing copies\n \tof the separator in the docs.\n \n \t* glib/gfileutils.c: Fix problems with leading elements\n \tconsisting only of \"/\" characters. (#85928, Guillaume Chazarain)\n \n \t* tests/strfunc-test.c (main): Add more test cases\n \tfor g_build_filename().\n \n2002-07-26  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gunicode.h: \n\t* glib/gutf8.c (g_utf8_strreverse): New function to revert\n\ta utf8 string.\n\t* glib/gpattern.c (g_utf8_reverse): Gone, replaced by \n\tg_utf8_strreverse.  (#87725)\n\nThu Jul 25 20:57:20 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/giochannel.c (g_io_channel_read_line): Fix \n\tdocs for @str_return to conform to the main docs\n\tand the implementation as to whether the terminator\n\tis included. (#87964, Jacob Berkman)\n\nThu Jul 25 19:52:41 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/guniprop.c (real_tolower): Handle the \n\tend of the string properly when max_len is set.\n\t(#88545, Morten Welinder.) Rename the next_t\n\tvariable to next_type to make cc-mode happy.\n\n\t* glib/gconvert.c (g_iconv_open): Fix missing\n\tlabel from previous commit.\n\nThu Jul 25 19:41:03 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/giochannel.c (g_io_channel_get_flags): Fix \n\tincorrect return value in g_return_val_if_fail \n\t(#85545, David L. Cooper II)\n\nThu Jul 25 19:12:43 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/giochannel.c (g_io_channel_set_encoding): Clarify\n\tthat only one of the conditions listed in the docs\n\tneed to be true, not all of them. (#87176,\n\tSebastian Rittau)\n\n\t* glib/giochannel.c (g_io_channel_read_line): Fix \n\tdescription of the return value. (#87754, Manuel Clos)\n\nThu Jul 25 19:02:53 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gmain.c (g_timeout_add): Remove reference\n\tin the docs to @notify parameter. (#87768,\n\tManuel Clos)\n\nThu Jul 25 17:57:07 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gconvert.c (g_iconv_open): Document the\n\t(GIConv)-1 return value on failure. (#87559, \n\tJarek Dukat)\n\n\t* glib/gconvert.c (g_iconv_open): Fix potential\n\tproblems with the assumption that (GIConv)(iconv_t)-1\n\tis the same as (GIConv)-1.\n\t\n2002-07-15  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gmarkup.h: \n\t* glib/gmarkup.c (g_markup_parse_context_get_element): New\n\tfunction to get the currently open element.  (#70448)\n\n2002-07-04  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* tests/*.c: Added #undef G_DISABLE_ASSERT and #undef G_LOG_DOMAIN\n\tthroughout the files, which didn't already have them. (#87312)\n\n2002-07-03  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n        * configure.in: Made the thread flags determination tests first\n\tcheck for the canonical form -pthread[s], then for other\n\tpossibilities. Also recognize some more platforms. Modeled after\n\tpatch from Miroslaw Dobrzanski-Neumann <mne@mosaic-ag.com>\n\t(#77981).\n\t\n\t* configure.in: Fixed bugs in posix thread priority\n\tresolution. Also added AIX priorities. Fix from\n\tLaurent Vivier <Laurent.Vivier@bull.net>. (#82599)\n\t\n\t* gthread/gthread-solaris.c: Use thr_min_stack() instead of\n\tsysconf (_SC_THREAD_STACK_MIN). if stack_size is 0 on entry to\n\tg_thread_create_solaris_impl, also pass 0 to thr_create. Otherwise\n\tthe stack might be to small for any nontrivial thread. Discovered\n\ton intel-solaris by Rajkumar Sivasamy <rajkumar.siva@wipro.com>.\n\n2002-07-03  Anders Carlsson  <andersca@gnu.org>\n\n\t* configure.in: Add a forgotten trailing ` in the \n\tGLIB_BINARY_AGE expression. Also fixup LT_CURRENT.\n\n2002-07-02  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Set binary age to 0 to make it compile.\n\n\t* configure.in: Improve checks for dce/posix threads to also do\n\tthe right thing, if the thread functions are not declared in\n\tpthread.h. Idea from Miroslaw Dobrzanski-Neumann\n\t<mne@mosaic-ag.com> in #77981.\n\n2002-07-01  Anders Carlsson  <andersca@gnu.org>\n\n\t* configure.in: Up version to 2.1.0.\n\n2002-07-01  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib/garray.h: Add parenthesis to protect macro\n\targument. Spotted by Sam Couter <sam@topic.com.au>. (#86826)\n\n2002-06-28  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib/gmessages.h (g_assert, g_assert_not_reached,\n\tg_return_if_fail, g_return_val_if_fail): In case of\n\tG_DISABLE_ASSERT replace \"G_STMT_START{ }G_STMT_END\" with\n\t\"G_STMT_START{ (void)0; }G_STMT_END\", because the former chokes\n\tgcc prior to 3.0. (#86664)\n\n2002-06-26  Yanko Kaneti <yaneti@declera.com>\n\n\t* configure.in: (ALL_LINGUAS) Added Bulgarian (bg).\n\nThu Jun 13 16:12:04 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gmain.c (struct _GTimeoutSource): Make \n\tinterval unsigned to match g_timeout_source_new().\n\t(#82624, Tim Janik.)\n\n\t* glib/gmain.c (g_timeout_prepare): Add some\n\textra gymnastics to avoid signed/unisgned integer\n\toverflows.\n\nThu Jun 13 15:57:46 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* INSTALL.in: Add a note about the deficiency\n\tof Tru64 iconv. (#81699, Manuel Op de Coul)\n\nTue Jun 11 17:03:39 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* tests/patterntest.c (test_compilation)\n\t* glib/gmem.c (profiler_try_realloc): A couple\n\tof 64-bit printf format fix from George Lebl.\n\t(#82817)\n\n\t* glib/gconvert.c (open_converter): Fix gsize/gint\n\tmixup for g_iconv() arguments. (#83270,\n\tDavid L. Cooper II)\n\n2002-06-03  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gwin32.c (g_win32_get_package_installation_directory):\n\tReplace homegrown \"hash\" entity by standard ISO entity \"num\".\n\n2002-05-26  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gmain.c: Remove references to nonexisting functions \n\tg_source_set_callback_closure(), g_source_poll(), g_source_add()\n\tfrom docs.\n\n\t* glib/gdir.c (g_dir_open): Typo fix in docs.\n\n\t* glib/gasyncqueue.c (g_async_queue_lock):\n\t(g_async_queue_unref_and_unlock): Fix markup to avoid erroneous \n\t<link>s in docs.\n\n\t* glib/gwin32.c: Escape #'s leading to erroneous <link>s in docs.\n\n\t* glib/gtree.c: Replace some occurances of Gtree by GTree in docs.\n\n\t* glib/gstring.c (g_string_insert_unichar): Typo fix in docs.\n\n2002-05-23  Havoc Pennington  <hp@redhat.com>\n\n\t* glib/gspawn.c (fork_exec_with_pipes): on success, close the\n\tpipes from the child. Fix from Tim.\n\n2002-05-22  jacob berkman  <jacob@ximian.com>\n\n\t* m4macros/glib-gettext.m4 (AM_GLIB_WITH_NLS): fix tyop\n\nWed May 22 15:40:47 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* README.in: Remove notes about now-fixed-bugs.\n\n\t* m4macros/glib-gettext.m4 acinclude.m4: Get rid\n\tof AC_MSG_NOTICE() usage, since some broken systems\n\t(Hi Debian!) might not be using autoconf-2.5x for\n\tdownstream packages even though we require it for\n\tglib itself.\n\n\t* INSTALL.in: Add a note about installing extra\n\tconverters for Solaris.\n\n\t* glib/gutils.h (g_bit_nth_msf): Fix termination\n\tcondition. (#82582, Paolo Molaro)\n \nTue May 21 15:51:17 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: $with_libiconv, not $with_iconv.\n\nMon May 20 18:02:46 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Move iconv tests before gettext\n\tchecks. (#81999)\n\n\t* m4macros/glib-gettext.m4 acinclude.m4: If we can't\n\tlink to gettext, try adding in -liconv. (#80076,\n\tBoyd Lynn Gerber)\n\n\t* m4macros/glib-gettext.m4 acinclude.m4: Suppress\n\twarnings about xgettext not being GNU gettext when\n\tlibintl wasn't found at all. \n\t(#79016, Andrew P. Lentvorski, Jr.)\n\t \n2002-05-21  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gmarkup.c (g_markup_parse_context_parse): Added\n\tproper support for CDATA sections.\n\n2002-05-20  jacob berkman  <jacob@ximian.com>\n\n\t* glib/gdir.c: include sys/types.h before dirent.h to build on\n\tdarwin (fixes #72859)\n\nMon May 20 15:35:59 2002  Owen Taylor  <otaylor@redhat.com>\n \n \t* glib/gfileutils.c (get_contents_regfile): Fix double\n \tclose of file descriptor on error. (#82139, Wayne Schuller)\n \n \t* glib/gspawn.c (close_and_invalidate): Don't close\n \tfd's that have already been closed. (Fix from Michael\n \tMeeks, #81959)\n \n \t* glib/giochannel.c (g_io_channel_close): If not flushing,\n \tdump the contents of the write buffers, so we won't try\n \tto write them to an invalid fd later. (Patch from Ron Steinke,\n \tfixing #78290, Andreas Persenius.)\n \n2002-05-18  Matthias Clasen  <maclas@gmx.de>\n\n\t* tests/markups/fail-36.gmarkup: \n\t* tests/markups/fail-35.gmarkup: \n\t* tests/markups/valid-8.gmarkup: \n\t* tests/markups/valid-7.gmarkup: \n\t* tests/markups/valid-6.gmarkup: \n\t* tests/markups/valid-5.gmarkup: New testcases.\n\n\t* tests/markup-test.c (passthrough_handler): \n\t(text_handler): Don't ignore the text_len parameter.\n\n\t* glib/gmarkup.c (find_current_text_end): Don't hang on embedded\n\tnuls.  (#81977)\n\t(g_markup_parse_context_parse): Fix passthrough handling to\n\tcorrectly skip processing instructions, comments, doctype\n\tdeclarations and CDATA marked sections.  (#81977)\n\nSat May 18 00:21:51 2002  Tim Janik  <timj@gtk.org>\n\n\t[merged from stable]\n\n        * glib/gscanner.c (g_scanner_unexp_token): fix missing cases for\n        expected_token.\n\n2002-05-17  Tor Lillqvist  <tml@iki.fi>\n\n\t* config.h.win32.in: Match new additions in a configure-produced\n\tconfig.h.\n\n\t* glibconfig.h.win32.in: gssize and gsize as in a\n\tconfigure-produced glibconfig.h.\n\n\t* glib/glib.def: Add new functions.\n\nThu May 16 12:24:00 2002  Owen Taylor  <otaylor@redhat.com>\n \n \t* acinclude.m4 m4macros/glib-gettext.m4: Incorporate \n \tAM_LC_MESSAGES, AM_PATH_PROG_WITH_TEST as AM_GLIB_* to avoid \n \tdependencies on gettext m4 files. (#81885, Hidetoshi Tajima.)\n\t\n2002-05-14  Alex Larsson <alexl@redhat.com>\n\t\n\t* glib/gstrfuncs.c: \n\t* glib/gstrfuncs.h:\n\tNew functions g_str_has_suffix and g_str_has_prefix.\n\t\n\t* tests/string-test.c: (main):\n\tTest the new functions.\n\nMon May 13 23:20:00 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* autogen.sh (have_gettext): Add a check for GNU gettext.\n\t(Pointed out by Dan Winship in #59386.)\n\nMon May 13 11:55:33 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in acglib.m4: If sizeof(int) == sizeof(long)\n\trun compilation tests to determine which way gsize should\n\tbe defined. (#74413, reported by Miroslaw Dobrzanski-Neumann)\n\nMon May 13 11:42:23 2002  Owen Taylor  <otaylor@redhat.com>\n \n        * glib/libcharset/*: Update from libcharset CVS.\n \tIncludes additional encodings for Solaris (#80396,\n\tQingjiang Yuan)\n \n \t* configure.in: Add getc_unlocked to CHECK_FUNCS().\n \n \t* glib/gmessages.c (strdup_convert): If\n \tg_convert_with_fallback() fails, print the error\n \tmessage to stderr the first time, then return\n \tthe original string. (#78197)\n \n2002-05-10  Naba Kumar  <kh_naba@users.sourceforge.net>\n\n\t* configure.in: Added \"hi\" to ALL_LINGUAS.\n\n2002-05-08  Michael Natterer  <mitch@gimp.org>\n\n\t* configure.in: fixed yesterdays fix for cross compiling: simply\n\tcheck the variable \"cross_compiling\" which gets set by autoconf.\n\n2002-05-07  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gmarkup.c (unescape_text): Report unfinished entity\n\treferences as errors rather than running into an assert.  (#80441)\n\n2002-05-07  Michael Natterer  <mitch@gimp.org>\n\n\t* configure.in: added a new conditional CROSS_COMPILING which\n\tindicates ($build != $host). If it is set, look for\n\tglib-genmarshal in PATH. Error out if it was not found.\n\nTue May  7 11:24:22 2002  Owen Taylor  <otaylor@redhat.com>\n\n\tFixes for #79347, Ron Arts.\n\n\t* glib/gqsort.c (g_qsort_with_data): Handle 0 elements,\n\tdon't g_return_if_fail().\n\n\t* tests/qsort-test.c (main): Add a 0 element test.\n\n\t* glib/garray.c (g_[ptr_]array_sort_with[_data]): \n\tRemove invalid assertions that array->pdata != NULL ..\n\tit's NULL for 0 elements which is a valid case.\n\nMon May  6 16:00:41 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gbacktrace.h: Exclude OSF from alpha definition\n\tof G_BREAKPOINT(), since the assembler apparently\n\tdoesn't support bpt. (#77852, Gareth Pierce) [from stable]\n\nMon May  6 11:48:08 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t[ merged from stable ]\n \n \t* Makefile.am (EXTRA_DIST): Add ChangeLog.pre-2-0 (#78641)\n \n \t* m4macros/glib-2.0.m4: save CFLAGS/LIBS properly when\n \tcompiling \"what went wrong\" test case. (#79330)\n \n \t* m4macros/glib-2.0.m4: Remove reference to editing\n \tpkg-config script. (From Jim Gettys)\n \n \t* configure.in: (Look for dyld interfaces before dlopen()\n \tsince OS X can have both. Patch from Jacob Berkman, \n \t#80438)\n\t\n2002-05-01  jacob berkman  <jacob@ximian.com>\n\n\t* configure.in: fix typo on 64-bit printf formatting string\n\tconfigure message (fixes #80389)\n\n2002-04-29  Pablo Saratxaga  <pablo@mandrakesoft.com>\n\n\t* configure.in: Added Vietnamese (vi) to ALL_LINGUAS\n\n2002-04-19  Tor Lillqvist  <tml@iki.fi>\n\n\t* glib/gspawn.c (g_spawn_command_line_sync): Add Windows-specific\n\tnote to the gtk-doc comment.\n\n\t* glib/gspawn-win32.c: Remove the copy-pasted gtk-doc comment\n\tblocks. It's enough to have them in gspawn.c.\n\n2002-04-18  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* gthread/gthread-impl.c (g_thread_init): Fixed typo. (#78985)\n\n2002-04-13  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib/gthreadpool.c (g_thread_pool_thread_proxy): Unlock the pool\n\tfor all threads leaving it. (#78348)\n\n2002-04-11  Matthias Clasen  <maclas@gmx.de>\n\n\t* tests/patterntest.c: Remove manual UTF-8 -> Latin1 conversion for\n\tstuff fed to g_print.\n\n2002-04-08  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* tests/gio-test.c, tests/markup-test.c: Use gsize instead of\n\tgint. From Miroslaw Dobrzanski-Neumann\n\t<mne@mosaic-ag.com>. (#77982)\n\t\n2002-04-08  Stanislav Brabec  <utx@penguin.cz> \n\n        * cs.po: Added Czech (cs) to ALL_LINGUAS.\n\n2002-03-31  Hasbullah Bin Pit <sebol@ikhlas.com>\n\n\t* configure.in: Added Malay (ms)to ALL_LINGUAS.\n\n2002-03-29  Tor Lillqvist  <tml@iki.fi>\n\n\t* glib/glib.def: Add g_convert_init.\n\nThu Mar 28 18:25:14 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* Released 2.0.1\n\n\t* configure.in: Version 2.0.1, interface, binary age 1.\n\nThu Mar 28 18:22:53 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* README: Remove warning about g_print, etc, encoding.\n\n\t* NEWS: Updates.\n\n\t* glib/gmessages.c (g_log_default_handler): Use %lu\n\t(plus a cast) when printing out pid_t arguments.\n\t(#76770, Morten Welinder)\n\n\t* glib/gstrfuncs.c (g_strdup_vprintf): Check the\n\tresult of vasprintf(), return NULL on failure.\n\t(#76802, Akira Tagoh)\n\n\t* tests/testglib.c (TEST): Supress a warning with\n\tsome GCC versions. \n\nThu Mar 28 20:31:51 2002  Tim Janik  <timj@gtk.org>\n\n\t* glib/gmessages.c:\n\t(g_print): \n\t(g_printerr): convert prtinf() strings to local charset\n\twhen writing them to stdout or stderr.\n\nWed Mar 27 18:42:22 2002  Tim Janik  <timj@gtk.org>\n\n\t* gmessages.[hc]:\n\tmajor cleanups. introduced _g_log_fallback_handler() to handle\n\trecursive messages which really doesn't call any GLib functions.\n\tthis allowes the default handler to use normal GLib functions and\n\talso fixes user supplied log level handlers.\n\tfixed locking issues, based on a patch from Sebastian Willhelmi,\n\tattached to #74356. translate log messages from UTF-8, based\n\ton the same patch. save fatal and recursion flags across flag\n\tloop. use new integer format code from above patch.\n\tmove GLib functions out of locked mutex state to avoid deadlocks.\n\tmove the level prefix and filedescriptor logic into mklevel_prefix().\n\tmove _g_debug_init() into a place where we can figure and handle\n\trecursion.\n\nMon Mar 25 18:13:06 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gtypes.h (GUINT*_SWAP_LE_BE_X86): Remove __const__\n\tqualifier from __asm__ statements... GCC since at least\n\t2.96 has assumed no side effects automaticaly, and gcc-3.1\n\twill warn about this usage. (#73308, Cody Russell)\n\nFri Mar 22 17:59:27 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gmem.c (g_mem_chunk_reset): Fix problem where\n\tif g_mem_chunk_reset() is called on an alloc-only\n\tmemchunk, then a useles GTree was created.\n\nWed Mar 20 18:20:21 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gconvert.c (open_converter): Try to work around segfaults\n\ton Solaris if NULL is passed for outbuf... supposedly gchar\n\t*outbuf = NULL... &outbuf works. (#74336, Lauri Alanko)\n\nWed Mar 20 11:17:32 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/gfileutils.c (get_contents_regfile): Close the\n\tfile descriptor. (#75507, Matthias Clasen)\n\nWed Mar 20 11:00:59 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* configure.in: Use $PKG_CONFIG, not pkg-config.\n\t(LEE Sau Dan, #75572)\n\n2002-03-20  Sven Neumann  <sven@gimp.org>\n\n\t* glib/ghash.c (g_hash_table_resize): avoid repeated call of \n\tg_spaced_primes_closest() by moving it out of the CLAMP macro \n\t(spotted by Salmaso Raffaele).\n\n2002-03-17  Tor Lillqvist  <tml@iki.fi>\n\n\t* README.win32: Add MSVC-specific text by Hans Breuer.\n\n2002-03-16  Tor Lillqvist  <tml@iki.fi>\n\n\t* glib/giowin32.c: Some debugging output formatting changes. The\n\tfollowing changes fix a problem with buffered GIOChannels, noticed\n\twith the help of Owen's test program, thanks! (#59969)\n\t(g_io_win32_prepare): Return value that takes the buffer condition\n\tinto account, like g_io_unix_prepare() does.\n\t(g_io_win32_check): Ditto, like g_io_unix_check().\n\t(g_io_win32_dispatch): Ditto, like g_io_unix_dispatch().\n\nThu Mar 14 17:37:45 2002  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib/giochannel.c (g_io_channel_write_chars): Fix some\n\tgsize/gint mismatches. (#74422, Miroslaw Dobrzanski-Neumann)\n\n2002-03-14  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib/gmessages.c: Fixed threading issues brought up by\n\t#74577. Make g_log_find_domain, g_log_domain_new,\n\tg_log_domain_check_free and g_log_domain_get_handler require being\n\tcalled with g_messages_lock held and remove all internal locking\n\tin them. Then added proper locking to g_log_set_handler,\n\tg_log_remove_handler and g_logv. Problem spotted by Miroslaw\n\tDobrzanski-Neumann <mne@mosaic-ag.com>. (#74577)\n\n2002-03-13  Erwann Chenede  <erwann.chenede@sun.com>\n        * glib/gconvert.c \n\t  glib/gen-unicode-tables.pl\n\t  glib/gunidecomp.h : fixed cast/type problems to \n\t  avoid warnings (with forte compiler) (#73898)\n\t\n2002-03-12  Alexander Larsson  <alla@lysator.liu.se>\n\n\t* glib/gconvert.c:\n\tCache getenv(\"G_BROKEN_FILENAMES\") in have_broken_filenames() and\n\tuse instead. Add g_convert_init() that calls have_broken_filenames()\n\n\t* gthread/gthread-impl.c:\n\tHave g_thread_init call g_convert_init.\n\n2002-03-11  Matthias Clasen  <maclas@gmx.de>\n\n\t* glib/gstrfuncs.c (g_strtod): \n\t(g_ascii_strtod): \n\t(g_ascii_dtostr): \n\t(g_ascii_formatd): Doc formatting fixes.\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/configure.ac": "# Process this file with autoconf to produce a configure script.\nAC_PREREQ([2.62])\n\ndnl ***********************************\ndnl *** include special GLib macros ***\ndnl ***********************************\n\nm4_define(glib_configure_ac)\n\n#\n# The following version number definitions apply to GLib, GModule, GObject,\n# GThread and GIO as a whole, so if changes occurred in any of them, they are\n# all treated with the same interface and binary age.\n#\n# Making releases:\n#   glib_micro_version += 1;\n#   glib_interface_age += 1;\n#   glib_binary_age += 1;\n# if any functions have been added, set glib_interface_age to 0.\n# if backwards compatibility has been broken,\n# set glib_binary_age _and_ glib_interface_age to 0.\n#\n# remember to add a GLIB_VERSION_2_xx macro every time the minor version is\n# bumped, as well as the GLIB_DEPRECATED_IN and GLIB_AVAILABLE_IN macros\n# for that version - see gversion.h for further information.\n#\n# in easier to understand terms:\n#\n# <mclasen> on the stable branch, interface age == micro\n# <mclasen> on the unstable (ie master), interface age = 0\n\nm4_define([glib_major_version], [2])\nm4_define([glib_minor_version], [58])\nm4_define([glib_micro_version], [3])\nm4_define([glib_interface_age], [3])\nm4_define([glib_binary_age],\n          [m4_eval(100 * glib_minor_version + glib_micro_version)])\nm4_define([glib_version],\n          [glib_major_version.glib_minor_version.glib_micro_version])\n\n# libtool version related macros\nm4_define([glib_lt_release], [glib_major_version.glib_minor_version])\nm4_define([glib_lt_current],\n          [m4_eval(100 * glib_minor_version + glib_micro_version - glib_interface_age)])\nm4_define([glib_lt_revision], [glib_interface_age])\nm4_define([glib_lt_age], [m4_eval(glib_binary_age - glib_interface_age)])\nm4_define([glib_lt_current_minus_age],\n          [m4_eval(glib_lt_current - glib_lt_age)])\n\n# if the minor version number is odd, then we want debugging.  Otherwise\n# we only want minimal debugging support.\nm4_define([glib_debug_default],\n          [m4_if(m4_eval(glib_minor_version % 2), [1], [yes], [minimum])])dnl\n\n\nAC_INIT(glib, [glib_version],\n        [https://gitlab.gnome.org/GNOME/glib/issues/new])\n\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_SRCDIR([glib/glib.h])\nAC_CONFIG_MACRO_DIR([m4macros])\n\n# Save this value here, since automake will set cflags later\ncflags_set=${CFLAGS:+set}\n\nAM_INIT_AUTOMAKE([1.13.3 -Wno-portability no-define no-dist-gzip dist-xz tar-ustar subdir-objects])\nAM_MAINTAINER_MODE([enable])\n\n# Support silent build rules. Disable\n# by either passing --disable-silent-rules to configure or passing V=1\n# to make\nAM_SILENT_RULES([yes])\n\nGLIB_MAJOR_VERSION=glib_major_version\nGLIB_MINOR_VERSION=glib_minor_version\nGLIB_MICRO_VERSION=glib_micro_version\nGLIB_INTERFACE_AGE=glib_interface_age\nGLIB_BINARY_AGE=glib_binary_age\nGLIB_VERSION=glib_version\n\nAC_SUBST(GLIB_MAJOR_VERSION)\nAC_SUBST(GLIB_MINOR_VERSION)\nAC_SUBST(GLIB_MICRO_VERSION)\nAC_SUBST(GLIB_VERSION)\nAC_SUBST(GLIB_INTERFACE_AGE)\nAC_SUBST(GLIB_BINARY_AGE)\n\nAC_DEFINE(GLIB_MAJOR_VERSION, [glib_major_version],\n\t  [Define to the GLIB major version])\nAC_DEFINE(GLIB_MINOR_VERSION, [glib_minor_version],\n\t  [Define to the GLIB minor version])\nAC_DEFINE(GLIB_MICRO_VERSION, [glib_micro_version],\n\t  [Define to the GLIB micro version])\nAC_DEFINE(GLIB_INTERFACE_AGE, [glib_interface_age],\n\t  [Define to the GLIB interface age])\nAC_DEFINE(GLIB_BINARY_AGE, [glib_binary_age],\n\t  [Define to the GLIB binary age])\n\n# libtool versioning\nLT_RELEASE=glib_lt_release\nLT_CURRENT=glib_lt_current\nLT_REVISION=glib_lt_revision\nLT_AGE=glib_lt_age\nLT_CURRENT_MINUS_AGE=glib_lt_current_minus_age\nAC_SUBST(LT_RELEASE)\nAC_SUBST(LT_CURRENT)\nAC_SUBST(LT_REVISION)\nAC_SUBST(LT_AGE)\nAC_SUBST(LT_CURRENT_MINUS_AGE)\n\ndnl Checks for programs.\nAC_PROG_CC\nAC_PROG_CPP\nAC_USE_SYSTEM_EXTENSIONS\n\nAM_CONDITIONAL(HAVE_GCC, [test \"$GCC\" = \"yes\"])\n\nAC_CANONICAL_HOST\n\ndnl\n\nAC_MSG_CHECKING([for Win32])\nLIB_EXE_MACHINE_FLAG=X86\ncase \"$host\" in\n  *-*-mingw*)\n    glib_native_win32=yes\n    glib_pid_type='void *'\n    glib_pid_format='p'\n    glib_pollfd_format='%#x'\n    glib_dir_separator='\\\\\\\\'\n    glib_searchpath_separator=';'\n    glib_cv_stack_grows=no\n    # Unfortunately the mingw implementations of C99-style snprintf and vsnprintf\n    # don't seem to be quite good enough, at least not in mingw-runtime-3.14.\n    # (Sorry, I don't know exactly what is the problem, but it is related to\n    # floating point formatting and decimal point vs. comma.)\n    # The simple tests in AC_FUNC_VSNPRINTF_C99 and AC_FUNC_SNPRINTF_C99 aren't\n    # rigorous enough to notice, though.\n    # So preset the autoconf cache variables.\n    ac_cv_func_vsnprintf_c99=no\n    ac_cv_func_snprintf_c99=no\n    case \"$host\" in\n    x86_64-*-*)\n      LIB_EXE_MACHINE_FLAG=X64\n      glib_pollfd_format='%#llx'\n      ;;\n    esac\n\n    AC_DEFINE([_WIN32_WINNT], [0x0601], [Target the Windows 7 API])\n    ;;\n  *)\n    glib_native_win32=no\n    glib_pid_type=int\n    glib_pid_format='i'\n    glib_pollfd_format='%d'\n    glib_dir_separator='/'\n    glib_searchpath_separator=':'\n    ;;\nesac\ncase $host in\n  *-*-linux*)\n    glib_os_linux=yes\n    ;;\nesac\n\nAC_MSG_RESULT([$glib_native_win32])\n\nAC_MSG_CHECKING([for the Android])\ncase $host in\n  *android*)\n    glib_native_android=\"yes\"\n    ;;\n  *)\n    glib_native_android=\"no\"\n    ;;\nesac\nAC_MSG_RESULT([$glib_native_android])\n\nAC_SUBST(LIB_EXE_MACHINE_FLAG)\n\nglib_have_carbon=no\nAC_MSG_CHECKING([for Mac OS X Carbon support])\nAC_TRY_CPP([\n#include <Carbon/Carbon.h>\n#include <CoreServices/CoreServices.h>\n], glib_have_carbon=yes)\n\nAC_MSG_RESULT([$glib_have_carbon])\n\nglib_have_cocoa=no\nAC_MSG_CHECKING([for Mac OS X Cocoa support])\nAC_TRY_CPP([\n#include <Cocoa/Cocoa.h>\n#ifdef GNUSTEP_BASE_VERSION\n#error \"Detected GNUstep, not Cocoa\"\n#endif\n], glib_have_cocoa=yes)\n\nAC_MSG_RESULT([$glib_have_cocoa])\n\nAM_CONDITIONAL(OS_WIN32, [test \"$glib_native_win32\" = \"yes\"])\nAM_CONDITIONAL(OS_WIN32_X64, [test \"$LIB_EXE_MACHINE_FLAG\" = \"X64\"])\nAM_CONDITIONAL(OS_UNIX, [test \"$glib_native_win32\" != \"yes\"])\nAM_CONDITIONAL(OS_LINUX, [test \"$glib_os_linux\" = \"yes\"])\nAM_CONDITIONAL(OS_CARBON, [test \"$glib_have_carbon\" = \"yes\"])\nAM_CONDITIONAL(OS_COCOA, [test \"$glib_have_cocoa\" = \"yes\"])\n\nAS_IF([test \"$glib_native_win32\" = \"yes\"], [\n  AC_CHECK_TOOL(WINDRES, windres, no)\n  if test \"$WINDRES\" = no; then\n    AC_MSG_ERROR([*** Could not find an implementation of windres in your PATH.])\n  fi\n  AC_CHECK_TOOL(NM, nm, no)\n  if test \"$NM\" = no; then\n    AC_MSG_ERROR([*** Could not find an implementation of nm in your PATH.])\n  fi\n  AC_CHECK_TOOL(RANLIB, ranlib, :)\n  AC_CHECK_TOOL(DLLTOOL, dlltool, :)\n  AC_CHECK_PROG(ms_librarian, [lib.exe], [yes], [no])\n])\nAM_CONDITIONAL(MS_LIB_AVAILABLE, [test x$ms_librarian = xyes])\n\nAS_IF([test \"x$glib_have_carbon\" = \"xyes\"], [\n  AC_DEFINE(HAVE_CARBON, 1, [define to 1 if Carbon is available])\n  CARBON_LIBS=\"-Wl,-framework,Carbon\"\n  LDFLAGS=\"$LDFLAGS $CARBON_LIBS\"\n], [CARBON_LIBS=\"\"])\n\nAC_SUBST([CARBON_LIBS])\nac_cv_have_os_x_9_or_later=\"no\"\nAS_IF([test \"x$glib_have_cocoa\" = \"xyes\"], [\n  AC_DEFINE(HAVE_COCOA, 1, [define to 1 if Cocoa is available])\n  COCOA_LIBS=\"-Wl,-framework,Foundation -Wl,-framework,AppKit\"\n  LDFLAGS=\"$LDFLAGS $COCOA_LIBS\"\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <AvailabilityMacros.h>\n#if MAC_OS_X_VERSION_MIN_REQUIRED < 1090\n#error Compiling for minimum OS X version before 10.9\n#endif\n  ]])],[ac_cv_have_os_x_9_or_later=\"yes\"])\n], [COCOA_LIBS=\"\"])\nAM_CONDITIONAL([MAC_OS_X_9], [test \"x$ac_cv_have_os_x_9_or_later\" = xyes])\nAC_SUBST([COCOA_LIBS])\n\ndnl declare --enable-* args and collect ac_help strings\nAC_ARG_ENABLE(debug,\n              AS_HELP_STRING([--enable-debug=@<:@no/minimum/yes@:>@],\n                             [turn on debugging @<:@default=glib_debug_default@:>@]),,\n              enable_debug=glib_debug_default)\n\nGLIB_TESTS\n\ndnl location to install runtime libraries, e.g. ../../lib to install\ndnl to /lib if libdir is /usr/lib\nAC_ARG_WITH(runtime-libdir,\n           [AS_HELP_STRING([--with-runtime-libdir=RELPATH],\n                           [install runtime libraries relative to libdir])],\n           [],\n\t   [with_runtime_libdir=\"\"])\nGLIB_RUNTIME_LIBDIR=\"$with_runtime_libdir\"\nAC_SUBST(GLIB_RUNTIME_LIBDIR)\nAM_CONDITIONAL(HAVE_GLIB_RUNTIME_LIBDIR, [test \"x$with_runtime_libdir\" != \"x\"])\n\ndnl Check for a working C++ compiler, but do not bail out, if none is found.\nAC_CHECK_TOOLS(CXX, [$CCC c++ g++ gcc CC cxx cc++ cl], [gcc])\nAC_LANG_SAVE\nAC_LANG_CPLUSPLUS\nAC_TRY_COMPILE(,[class a { int b; } c;], ,CXX=)\nAM_CONDITIONAL(HAVE_CXX, [test \"$CXX\" != \"\"])\nAC_LANG_RESTORE\n\nAM_PROG_CC_C_O\nAC_PROG_INSTALL\n\nAC_SYS_LARGEFILE\n\nPKG_PROG_PKG_CONFIG(0.16)\n\nif test \"x$enable_debug\" = \"xyes\"; then\n  if test \"x$cflags_set\" != \"x\" ; then\n      case \" $CFLAGS \" in\n      *[[\\ \\\t]]-g[[\\ \\\t]]*) ;;\n      *) CFLAGS=\"$CFLAGS -g\" ;;\n      esac\n  fi\n  GLIB_DEBUG_FLAGS=\"-DG_ENABLE_DEBUG\"\nelse\n  GLIB_DEBUG_FLAGS=\"-DG_DISABLE_CAST_CHECKS\"\n\n  if test \"x$enable_debug\" = \"xno\"; then\n    GLIB_DEBUG_FLAGS=\"$GLIB_DEBUG_FLAGS -DG_DISABLE_ASSERT -DG_DISABLE_CHECKS\"\n  fi\nfi\n\n# Ensure MSVC-compatible struct packing convention is used when\n# compiling for Win32 with gcc.\n# What flag to depends on gcc version: gcc3 uses \"-mms-bitfields\", while\n# gcc2 uses \"-fnative-struct\".\nif test x\"$glib_native_win32\" = xyes; then\n  if test x\"$GCC\" = xyes; then\n    msnative_struct=''\n    AC_MSG_CHECKING([how to get MSVC-compatible struct packing])\n    if test -z \"$ac_cv_prog_CC\"; then\n      our_gcc=\"$CC\"\n    else\n      our_gcc=\"$ac_cv_prog_CC\"\n    fi\n    case `$our_gcc --version | sed -e 's,\\..*,.,' -e q` in\n      2.)\n\tif $our_gcc -v --help 2>/dev/null | grep fnative-struct >/dev/null; then\n\t  msnative_struct='-fnative-struct'\n\tfi\n\t;;\n      *)\n\tif $our_gcc -v --help 2>/dev/null | grep ms-bitfields >/dev/null; then\n\t  msnative_struct='-mms-bitfields'\n\tfi\n\t;;\n    esac\n    if test x\"$msnative_struct\" = x ; then\n      AC_MSG_RESULT([no way])\n      AC_MSG_WARN([produced libraries might be incompatible with MSVC-compiled code])\n    else\n      CFLAGS=\"$CFLAGS $msnative_struct\"\n      AC_MSG_RESULT([${msnative_struct}])\n    fi\n  fi\nfi\nGLIB_EXTRA_CFLAGS=\"${msnative_struct}\"\nAC_SUBST(GLIB_EXTRA_CFLAGS)\n\nAC_EXEEXT\n\nAC_PROG_AWK\n\n# option to specify python interpreter to use; this just sets $PYTHON, so that\n# we will fallback to reading $PYTHON if --with-python is not given, and\n# python.m4 will get the expected input\nAC_ARG_WITH(python,\n            AS_HELP_STRING([--with-python=PATH],\n                           [Path to Python interpreter; searches $PATH if only a program name is given; if not given, searches for a few standard names such as \"python3\" or \"python2\"]),\n            [PYTHON=\"$withval\"], [])\nif test x\"$PYTHON\" = xyes; then\n  AC_MSG_ERROR([--with-python option requires a path or program argument])\nfi\nAM_PATH_PYTHON(2.7,,PYTHON=\"python2.7\")\n\n\ndnl ***********************\ndnl *** Tests for iconv ***\ndnl ***********************\ndnl\ndnl We do this before the gettext checks, to avoid distortion\n\ndnl On Windows we use a native implementation\n\nAS_IF([ test x\"$glib_native_win32\" = xyes], [\n  with_libiconv=native\n], [\n  AC_ARG_WITH(libiconv,\n\t      [AS_HELP_STRING([--with-libiconv=@<:@no/gnu/native@:>@],\n\t\t\t      [use the libiconv library])],,\n\t      [with_libiconv=maybe])\n\n  found_iconv=no\n  case $with_libiconv in\n    maybe)\n      # Check in the C library first\n      AC_CHECK_FUNC(iconv_open, [with_libiconv=no; found_iconv=yes])\n      # Check if we have GNU libiconv\n      if test $found_iconv = \"no\"; then\n\tAC_CHECK_LIB(iconv, libiconv_open, [with_libiconv=gnu; found_iconv=yes])\n      fi\n      # Check if we have a iconv in -liconv, possibly from vendor\n      if test $found_iconv = \"no\"; then\n\tAC_CHECK_LIB(iconv, iconv_open, [with_libiconv=native; found_iconv=yes])\n      fi\n      ;;\n    no)\n      AC_CHECK_FUNC(iconv_open, [with_libiconv=no; found_iconv=yes])\n      ;;\n    gnu|yes)\n      AC_CHECK_LIB(iconv, libiconv_open, [with_libiconv=gnu; found_iconv=yes])\n      ;;\n    native)\n      AC_CHECK_LIB(iconv, iconv_open, [with_libiconv=native; found_iconv=yes])\n      ;;\n  esac\n\n  if test \"x$found_iconv\" = \"xno\" ; then\n     AC_MSG_ERROR([*** No iconv() implementation found in C library or libiconv])\n  fi\n])\n\ndnl\ndnl zlib support\ndnl\nPKG_CHECK_MODULES([ZLIB], [zlib], [found_zlib=yes], [found_zlib=no])\nAS_IF([test \"x$found_zlib\" = \"xno\"], [\n  AC_CHECK_LIB(z, inflate, [AC_CHECK_HEADER(zlib.h, found_zlib=yes)])\n  if test \"x$found_zlib\" = \"xno\" ; then\n    AC_MSG_ERROR([*** Working zlib library and headers not found ***])\n  fi\n  ZLIB_LIBS='-lz'\n  AC_SUBST(ZLIB_LIBS)\n])\n\nPKG_CHECK_MODULES(LIBFFI, [libffi >= 3.0.0])\nAC_SUBST(LIBFFI_CFLAGS)\nAC_SUBST(LIBFFI_LIBS)\n\ndnl\ndnl gettext support\ndnl\n\nALL_LINGUAS=\"`grep -v '^#' \"$srcdir/po/LINGUAS\" | tr '\\n' ' '`\"\nAC_SUBST([CONFIG_STATUS_DEPENDENCIES],['$(top_srcdir)/po/LINGUAS'])\nGLIB_GNU_GETTEXT\n\nif test \"$gt_cv_have_gettext\" != \"yes\" ; then\n  AC_MSG_ERROR([\n*** You must have either have gettext support in your C library, or use the\n*** GNU gettext library. (http://www.gnu.org/software/gettext/gettext.html)\n])\nfi\n\nLIBS=\"$INTLLIBS $LIBS\"\n\nGETTEXT_PACKAGE=glib20\nAC_SUBST(GETTEXT_PACKAGE)\nAC_DEFINE_UNQUOTED(GETTEXT_PACKAGE, [\"$GETTEXT_PACKAGE\"], \n  [Define the gettext package to be used])\n\nGLIB_DEFINE_LOCALEDIR(GLIB_LOCALE_DIR)\n\ndnl\ndnl Now we are done with gettext checks, figure out ICONV_LIBS\ndnl\n\nAS_IF([test x\"$glib_native_win32\" != xyes], [\n  if test x$with_libiconv != xno ; then\n    case \" $INTLLIBS \" in\n    *[[\\ \\\t]]-liconv[[\\ \\\t]]*) ;;\n    *) ICONV_LIBS=\"-liconv\" ;;\n    esac\n  fi\n])\nAC_SUBST(ICONV_LIBS)\n\ncase $with_libiconv in\n  gnu)\n    AC_DEFINE(USE_LIBICONV_GNU, 1, [Using GNU libiconv])\n    ;;\n  native)\n    AC_DEFINE(USE_LIBICONV_NATIVE, 1, [Using a native implementation of iconv in a separate library])\n    ;;\nesac\n\ndnl Initialize libtool\nLT_PREREQ([2.2])\nLT_INIT([disable-static win32-dll])\ndnl when using libtool 2.x create libtool early, because it's used in configure\nm4_ifdef([LT_OUTPUT], [LT_OUTPUT])\n\n\nAS_IF([test \"$glib_native_win32\" = \"yes\"], [\n  if test x$enable_static = xyes -a x$enable_shared = xyes; then\n    AC_MSG_ERROR([Can not build both shared and static at the same time on Windows.])\n  fi\n  if test x$enable_static = xyes; then\n    glib_win32_static_compilation=yes\n    GLIB_WIN32_STATIC_COMPILATION_DEFINE=\"#define GLIB_STATIC_COMPILATION 1\n#define GOBJECT_STATIC_COMPILATION 1\"\n    AC_SUBST(GLIB_WIN32_STATIC_COMPILATION_DEFINE)\n  fi\n])\nAM_CONDITIONAL(OS_WIN32_AND_DLL_COMPILATION, [test x$glib_native_win32 = xyes -a x$glib_win32_static_compilation != xyes])\n\n# Checks for library functions.\nAC_CHECK_FUNCS(mmap posix_memalign memalign valloc fsync pipe2 issetugid)\nAC_CHECK_FUNCS(timegm gmtime_r posix_spawn)\nAC_FUNC_STRERROR_R()\n\nAC_CHECK_SIZEOF(char)\nAC_CHECK_SIZEOF(short)\nAC_CHECK_SIZEOF(long)\nAC_CHECK_SIZEOF(int)\nAC_CHECK_SIZEOF(void *)\nAC_CHECK_SIZEOF(long long)\n\nAC_CACHE_CHECK([for sig_atomic_t], ac_cv_type_sig_atomic_t,\n  [AC_TRY_LINK([#include <signal.h>\n     #include <sys/types.h>\n     sig_atomic_t val = 42;],\n    [return val == 42 ? 0 : 1],\n   ac_cv_type_sig_atomic_t=yes,\n   ac_cv_type_sig_atomic_t=no)])\nif test x$ac_cv_type_sig_atomic_t = xyes; then\n   AC_DEFINE(HAVE_SIG_ATOMIC_T, 1,\n     [Define if you have the 'sig_atomic_t' type.])\nfi\n\nif test x$ac_cv_sizeof_long = x8 || test x$ac_cv_sizeof_long_long = x8 ; then\n  :\nelse\n  AC_MSG_ERROR([\n*** GLib requires a 64 bit type. You might want to consider\n*** using the GNU C compiler.\n])\nfi\n\nAS_IF([test x$ac_cv_sizeof_long_long = x8], [\n\t# long long is a 64 bit integer.\n\tAC_MSG_CHECKING(for format to printf and scanf a guint64)\n\tAC_CACHE_VAL(glib_cv_long_long_format,[\n\t\tfor format in ll q; do\n\t\t  AC_TRY_RUN([#include <stdio.h>  \n\t\t\tint main()\n\t\t\t{\n\t\t\t  long long b, a = -0x3AFAFAFAFAFAFAFALL;\n\t\t\t  char buffer[1000];\n\t\t\t  sprintf (buffer, \"%${format}u\", a);\n  \t\t\t  sscanf (buffer, \"%${format}u\", &b);\n\t\t\t  exit (b!=a);\n\t\t\t}\n\t\t\t],\n\t\t\t[glib_cv_long_long_format=${format}\n\t\t\tbreak],\n\t\t\t[],[:])\n\t\tdone])\n\tAS_IF([ test -n \"$glib_cv_long_long_format\"], [\n\t  AC_MSG_RESULT(%${glib_cv_long_long_format}u)\n\t], [AC_MSG_RESULT(none)])\n])\n\ndnl\ndnl check in which direction the stack grows\ndnl\nAC_CACHE_CHECK([for growing stack pointer],glib_cv_stack_grows,[\n        AC_TRY_RUN([\n\tvolatile int *a = 0, *b = 0;\n\tvoid f (int i) { volatile int x = 5; if (i == 0) b = &x; else f (i - 1); }\n\tint main () { volatile int y = 7; a = &y; f (100); return b > a ? 0 : 1; }\n       \t],\n\tglib_cv_stack_grows=yes\n        ,\n\tglib_cv_stack_grows=no\n        ,)\n])\n\n# check for flavours of varargs macros\nAC_MSG_CHECKING(for ISO C99 varargs macros in C)\nAC_TRY_COMPILE([],[\nint a(int p1, int p2, int p3);\n#define call_a(...) a(1,__VA_ARGS__)\ncall_a(2,3);\n],g_have_iso_c_varargs=yes,g_have_iso_c_varargs=no)\nAC_MSG_RESULT($g_have_iso_c_varargs)\n\nAC_MSG_CHECKING(for ISO C99 varargs macros in C++)\nAS_IF([test \"$CXX\" = \"\"], [\ndnl No C++ compiler\n  g_have_iso_cxx_varargs=no\nelse\n  AC_LANG_CPLUSPLUS\n  AC_TRY_COMPILE([],[\nint a(int p1, int p2, int p3);\n#define call_a(...) a(1,__VA_ARGS__)\ncall_a(2,3);\n],g_have_iso_cxx_varargs=yes,g_have_iso_cxx_varargs=no)\n  AC_LANG_C\n])\nAC_MSG_RESULT($g_have_iso_cxx_varargs)\n\nAC_MSG_CHECKING(for GNUC varargs macros)\nAC_TRY_COMPILE([],[\nint a(int p1, int p2, int p3);\n#define call_a(params...) a(1,params)\ncall_a(2,3);\n],g_have_gnuc_varargs=yes,g_have_gnuc_varargs=no)\nAC_MSG_RESULT($g_have_gnuc_varargs)\n\n# check for GNUC visibility support\nAC_MSG_CHECKING(for GNUC visibility attribute)\nGLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[\nvoid\n__attribute__ ((visibility (\"hidden\")))\n     f_hidden (void)\n{\n}\nvoid\n__attribute__ ((visibility (\"internal\")))\n     f_internal (void)\n{\n}\nvoid\n__attribute__ ((visibility (\"protected\")))\n     f_protected (void)\n{\n}\nvoid\n__attribute__ ((visibility (\"default\")))\n     f_default (void)\n{\n}\nint main (void)\n{\n\tf_hidden();\n\tf_internal();\n\tf_protected();\n\tf_default();\n\treturn 0;\n}\n]])],g_have_gnuc_visibility=yes,g_have_gnuc_visibility=no)\nAC_MSG_RESULT($g_have_gnuc_visibility)\nAM_CONDITIONAL(HAVE_GNUC_VISIBILITY, [test x$g_have_gnuc_visibility = xyes])\n\nAC_MSG_CHECKING([whether using Sun Studio C compiler])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#if defined(__SUNPRO_C) || (__SUNPRO_C >= 0x550)\n#else\n# include \"error: this is not Sun Studio.\"\n#endif\n]], [[]])], [ g_have_sunstudio_visibility=yes ], [ g_have_sunstudio_visibility=no ])\nAC_MSG_RESULT($g_have_sunstudio_visibility)\nAM_CONDITIONAL(HAVE_SUNSTUDIO_VISIBILITY, [test x$g_have_sunstudio_visibility = xyes])\n\n# check for bytesex stuff\nAC_C_BIGENDIAN\nif test x$ac_cv_c_bigendian = xuniversal ; then\n  AC_MSG_ERROR([Universal builds not supported: see https://bugzilla.gnome.org/show_bug.cgi?id=742548])\nfi\n\n\n# check for header files\nAC_CHECK_HEADERS([sys/param.h sys/resource.h mach/mach_time.h])\nAC_CHECK_HEADERS([sys/select.h stdint.h inttypes.h sched.h malloc.h])\nAC_CHECK_HEADERS([sys/vfs.h sys/vmount.h sys/statfs.h sys/statvfs.h sys/filio.h sys/auxv.h])\nAC_CHECK_HEADERS([mntent.h sys/mnttab.h sys/vfstab.h sys/mntctl.h fstab.h])\nAC_CHECK_HEADERS([linux/magic.h])\nAC_CHECK_HEADERS([termios.h])\nAC_CHECK_HEADERS([alloca.h])\nAC_CHECK_HEADERS([spawn.h])\n\n# Some versions of MSC lack these\nAC_CHECK_HEADERS([dirent.h sys/time.h])\n\n# We don't care about this, but we need to keep including it in\n# glibconfig.h for backward compatibility\nAC_CHECK_HEADERS([values.h])\n\nAC_CHECK_HEADERS([sys/mount.h sys/sysctl.h], [], [],\n[#if HAVE_SYS_PARAM_H\n #include <sys/param.h>\n #endif\n])\nAC_CHECK_FUNCS(sysctlbyname)\n\nAC_HEADER_MAJOR\nAS_IF([test \"$ac_cv_header_sys_types_h_makedev\" = \"yes\"],\n      [AC_DEFINE([MAJOR_IN_TYPES], [1], [Define to 1 if `major', `minor', and `makedev' are declared in <sys/types.h>.])])\nAC_CHECK_HEADERS([xlocale.h])\n\n# check for structure fields\nAC_CHECK_MEMBERS([struct stat.st_mtimensec, struct stat.st_mtim.tv_nsec, struct stat.st_atimensec, struct stat.st_atim.tv_nsec, struct stat.st_ctimensec, struct stat.st_ctim.tv_nsec, struct stat.st_birthtime, struct stat.st_birthtimensec, struct stat.st_birthtim, struct stat.st_birthtim.tv_nsec])\nAC_CHECK_MEMBERS([struct stat.st_blksize, struct stat.st_blocks, struct statfs.f_fstypename, struct statfs.f_bavail],,, [#include <sys/types.h>\n#include <sys/stat.h>\n#ifdef G_OS_UNIX\n#include <unistd.h>\n#endif\n#ifdef HAVE_SYS_STATFS_H\n#include <sys/statfs.h>\n#endif\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#ifdef HAVE_SYS_MOUNT_H\n#include <sys/mount.h>\n#endif])\n# struct statvfs.f_basetype is available on Solaris but not for Linux. \nAC_CHECK_MEMBERS([struct statvfs.f_basetype],,, [#include <sys/statvfs.h>])\nAC_CHECK_MEMBERS([struct statvfs.f_fstypename],,, [#include <sys/statvfs.h>])\nAC_CHECK_MEMBERS([struct tm.tm_gmtoff, struct tm.__tm_gmtoff],,,[#include <time.h>])\n\nAC_STRUCT_DIRENT_D_TYPE\n\n# Checks for libcharset\nAM_LANGINFO_CODESET\ngl_GLIBC21\nAC_ARG_WITH(charsetalias-dir,\n            AS_HELP_STRING([--with-charsetalias-dir=DIR], [directory for charset.alias file [LIBDIR]]),\n           [],\n           [with_charsetalias_dir='${libdir}'])\nGLIB_CHARSETALIAS_DIR=$with_charsetalias_dir\nAC_SUBST(GLIB_CHARSETALIAS_DIR)\n\n# check additional type sizes\nAC_CHECK_SIZEOF(size_t)\n\ndnl Try to figure out whether gsize should be long or int\nAC_MSG_CHECKING([for the appropriate definition for size_t])\n\ncase $ac_cv_sizeof_size_t in\n  $ac_cv_sizeof_short) \n      glib_size_type=short\n      ;;\n  $ac_cv_sizeof_int) \n      glib_size_type=int\n      ;;\n  $ac_cv_sizeof_long) \n      glib_size_type=long\n      ;;\n  $ac_cv_sizeof_long_long)\n      glib_size_type='long long'\n      ;;\n  *)  AC_MSG_ERROR([No type matching size_t in size])\n      ;;\nesac\n\ndnl If int/long are the same size, we see which one produces\ndnl warnings when used in the location as size_t. (This matters\ndnl on AIX with xlc)\ndnl\nAS_IF([test $ac_cv_sizeof_size_t = $ac_cv_sizeof_int &&\n       test $ac_cv_sizeof_size_t = $ac_cv_sizeof_long], [\n  GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[\n#if defined(_AIX) && !defined(__GNUC__)\n#pragma options langlvl=stdc89\n#endif\n#include <stddef.h> \nint main ()\n{\n  size_t s = 1;\n  unsigned int *size_int = &s;\n  return (int)*size_int;\n}\n    ]])],glib_size_type=int,\n      [GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[\n#if defined(_AIX) && !defined(__GNUC__)\n#pragma options langlvl=stdc89\n#endif\n#include <stddef.h> \nint main ()\n{\n   size_t s = 1;\n   unsigned long *size_long = &s;\n   return (int)*size_long;\n}\n        ]])],glib_size_type=long)])\n])\n\nAC_MSG_RESULT(unsigned $glib_size_type)\n\nAC_CHECK_SIZEOF(ssize_t)\n\ndnl Try to figure out whether gssize should be long or int\nAC_MSG_CHECKING([for the appropriate definition for ssize_t])\n\ncase $ac_cv_sizeof_ssize_t in\n  $ac_cv_sizeof_short) \n      glib_ssize_type=short\n      ;;\n  $ac_cv_sizeof_int) \n      glib_ssize_type=int\n      ;;\n  $ac_cv_sizeof_long) \n      glib_ssize_type=long\n      ;;\n  $ac_cv_sizeof_long_long)\n      glib_ssize_type='long long'\n      ;;\n  *)  AC_MSG_ERROR([No type matching ssize_t in size])\n      ;;\nesac\n\ndnl If int/long are the same size, we see which one produces\ndnl warnings when used in the location as ssize_t. (This matters\ndnl on Android where ssize_t is long and size_t is unsigned int)\ndnl\nAS_IF([test $ac_cv_sizeof_ssize_t = $ac_cv_sizeof_int &&\n       test $ac_cv_sizeof_ssize_t = $ac_cv_sizeof_long], [\n  GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[\n#if defined(_AIX) && !defined(__GNUC__)\n#pragma options langlvl=stdc89\n#endif\n#include <stddef.h>\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <sys/types.h>\nint main ()\n{\n  ssize_t s = 1;\n  int *size_int = &s;\n  return (int)*size_int;\n}\n    ]])],glib_ssize_type=int,\n      [GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[\n#if defined(_AIX) && !defined(__GNUC__)\n#pragma options langlvl=stdc89\n#endif\n#include <stddef.h> \n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <sys/types.h>\nint main ()\n{\n   ssize_t s = 1;\n   long *size_long = &s;\n   return (int)*size_long;\n}\n        ]])],glib_ssize_type=long)])\n])\n\nAC_MSG_RESULT($glib_ssize_type)\n\ndnl Some platforms (Apple) hard-code int64_t to long long instead of\ndnl using long on 64-bit architectures. This can cause type mismatch\ndnl warnings when trying to interface with code using the standard\ndnl library type. Test for the warnings and set gint64 to whichever\ndnl works.\ndnl\nAS_IF([test $ac_cv_sizeof_long_long = $ac_cv_sizeof_long], [\n  GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[\n#if defined(_AIX) && !defined(__GNUC__)\n#pragma options langlvl=stdc99\n#endif\n#include <stdint.h>\n#include <stdio.h>\nint main ()\n{\n  int64_t i1 = 1;\n  long *i2 = &i1;\n  return 1;\n}\n    ]])],[ glib_cv_int64_t=long ],\n      [GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[\n#if defined(_AIX) && !defined(__GNUC__)\n#pragma options langlvl=stdc99\n#endif\n#include <stdint.h>\n#include <stdio.h>\nint main ()\n{\n  int64_t i1 = 1;\n  long long *i2 = &i1;\n  return 1;\n}\n        ]])],[ glib_cv_int64_t=long_long ])])\n])\n\n# Check for some functions\nAC_CHECK_FUNCS(lstat strsignal vsnprintf stpcpy strcasecmp strncasecmp poll vasprintf setenv unsetenv getc_unlocked readlink symlink fdwalk mkostemp link)\nAC_CHECK_FUNCS(lchmod lchown fchmod fchown utimes getresuid)\nAC_CHECK_FUNCS(getmntent_r setmntent endmntent hasmntopt getfsstat getvfsstat fallocate)\ncase $host_os in aix*) ac_cv_func_splice=no ;; esac # AIX splice() is something else\nAC_CHECK_FUNCS(splice)\nAC_CHECK_FUNCS(prlimit)\n\n# To avoid finding a compatibility unusable statfs, which typically\n# successfully compiles, but warns to use the newer statvfs interface:\nAS_IF([test $ac_cv_header_sys_statvfs_h = yes], [AC_CHECK_FUNCS([statvfs])])\nAS_IF([test $ac_cv_header_sys_statfs_h  = yes -o $ac_cv_header_sys_mount_h = yes], [AC_CHECK_FUNCS([statfs])])\n\nAC_MSG_CHECKING([whether to use statfs or statvfs])\n# Some systems have both statfs and statvfs, pick the most \"native\" for these\nAS_IF([test x$ac_cv_func_statfs = xyes && test x$ac_cv_func_statvfs = xyes],\n   [\n   # on solaris and irix, statfs doesn't even have the f_bavail field\n   AS_IF([test x$ac_cv_member_struct_statfs_f_bavail = xno],\n      [ac_cv_func_statfs=no],\n   # else, at least on linux, statfs is the actual syscall\n      [ac_cv_func_statvfs=no])\n   ])\n\nAS_IF([test x$ac_cv_func_statfs = xyes],\n      [\n         AC_DEFINE([USE_STATFS], [1], [Define to use statfs()])\n         AC_MSG_RESULT([statfs])\n      ],\n      [test x$ac_cv_func_statvfs = xyes],\n      [\n         AC_DEFINE([USE_STATVFS], [1], [Define to use statvfs()])\n         AC_MSG_RESULT([statvfs])\n      ],\n      [  AC_MSG_RESULT([neither])])\n\nAC_CHECK_HEADERS(crt_externs.h)\nAC_CHECK_FUNCS(_NSGetEnviron)\n\nAC_CHECK_FUNCS(newlocale uselocale strtod_l strtoll_l strtoull_l)\n\n# Internet address families\nif test $glib_native_win32 = yes; then\n  glib_inet_includes=[\"\n#include <winsock2.h>\n  \"]\nelse\n  glib_inet_includes=[\"\n#include <sys/types.h>\n#include <sys/socket.h>\n  \"]\nfi\n\nglib_failed=false\nGLIB_CHECK_VALUE(AF_INET, $glib_inet_includes, glib_failed=true)\nGLIB_CHECK_VALUE(AF_INET6, $glib_inet_includes, glib_failed=true)\n# winsock defines this even though it doesn't support it\nGLIB_CHECK_VALUE(AF_UNIX, $glib_inet_includes, glib_failed=true)\nif $glib_failed ; then\n  AC_MSG_ERROR([Could not determine values for AF_INET* constants])\nfi\n\nglib_failed=false\nGLIB_CHECK_VALUE(MSG_PEEK, $glib_inet_includes, glib_failed=true)\nGLIB_CHECK_VALUE(MSG_OOB, $glib_inet_includes, glib_failed=true)\nGLIB_CHECK_VALUE(MSG_DONTROUTE, $glib_inet_includes, glib_failed=true)\nif $glib_failed ; then\n  AC_MSG_ERROR([Could not determine values for MSG_* constants])\nfi\n\nAC_CHECK_FUNCS(endservent if_nametoindex if_indextoname sendmmsg recvmmsg)\n\nAC_MSG_CHECKING([for SIOCGIFADDR])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n    [[\n        #include <sys/ioctl.h>\n        #include <net/if.h>\n    ]],\n    [[\n        struct ifreq ifr;\n        ioctl(0, SIOCGIFADDR, &ifr);\n    ]])], [\n        AC_MSG_RESULT(yes)\n        AC_DEFINE(HAVE_SIOCGIFADDR, 1, [SIOCGIFADDR is available])\n    ], [\n        AC_MSG_RESULT(no)\n])\n\n# See https://bugzilla.gnome.org/show_bug.cgi?id=740791\nAS_IF([test $glib_native_android = yes], [\n  AC_MSG_CHECKING([if ip_mreq_source.imr_interface has s_addr member])\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n      [[\n          #include <netinet/in.h>\n      ]],\n      [[\n          struct ip_mreq_source mc_req_src;\n          mc_req_src.imr_interface.s_addr = 0;\n      ]])], [\n          AC_MSG_RESULT(yes)\n      ], [\n          AC_MSG_RESULT(no)\n          AC_DEFINE(BROKEN_IP_MREQ_SOURCE_STRUCT, 1, [struct ip_mreq_source definition is broken on Android NDK <= r16])\n  ])])\n\nAS_IF([test $glib_native_win32 = yes], [\n  # <wspiapi.h> in the Windows SDK and in mingw-w64 has wrappers for\n  # inline workarounds for getaddrinfo, getnameinfo and freeaddrinfo if\n  # they aren't present at run-time (on Windows 2000).\n  AC_CHECK_HEADER([wspiapi.h], [WSPIAPI_INCLUDE=\"#include <wspiapi.h>\"])\n  AC_SUBST(WSPIAPI_INCLUDE)\n], [\n  # Android does not have C_IN in public headers, we define it wherever necessary\n  AS_IF([test $glib_native_android != yes], [\n    AC_MSG_CHECKING([if arpa/nameser_compat.h is needed])\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <sys/types.h>\n                                        #include <arpa/nameser.h>],\n                                       [int qclass = C_IN;])],\n                      [AC_MSG_RESULT([no])],\n                      [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <sys/types.h>\n                                                           #include <arpa/nameser.h>\n                                                           #include <arpa/nameser_compat.h>],\n                                                          [int qclass = C_IN;])],\n                                         [AC_MSG_RESULT([yes])\n                                          NAMESER_COMPAT_INCLUDE=\"#include <arpa/nameser_compat.h>\"],\n                                         [AC_MSG_ERROR([could not compile test program either way])])])])\n  AC_SUBST(NAMESER_COMPAT_INCLUDE)\n\n  # We can't just use AC_CHECK_FUNC/AC_CHECK_LIB here. Bug 586150\n  NETWORK_LIBS=\"\"\n  AC_MSG_CHECKING([for res_query])\n  AC_TRY_LINK([#include <sys/types.h>\n\t       #include <netinet/in.h>\n\t       #include <arpa/nameser.h>\n\t       #include <resolv.h>\n              ],[\n\t       res_query(\"test\", 0, 0, (void *)0, 0);\n              ],[AC_MSG_RESULT([yes])],\n              [save_libs=\"$LIBS\"\n               LIBS=\"-lresolv $LIBS\"\n               AC_TRY_LINK([#include <sys/types.h>\n\t\t\t    #include <netinet/in.h>\n\t\t\t    #include <arpa/nameser.h>\n\t\t\t    #include <resolv.h>\n\t\t\t   ],[\n\t\t\t    res_query(\"test\", 0, 0, (void *)0, 0);\n\t\t\t   ],[AC_MSG_RESULT([in -lresolv])\n                              NETWORK_LIBS=\"-lresolv $NETWORK_LIBS\"],\n                           [LIBS=\"-lbind $save_libs\"\n                            AC_TRY_LINK([#include <resolv.h>],\n                                        [res_query(\"test\", 0, 0, (void *)0, 0);],\n                                        [AC_MSG_RESULT([in -lbind])\n                                         NETWORK_LIBS=\"-lbind $NETWORK_LIBS\"],\n                                        [AC_MSG_ERROR(not found)])])\n               LIBS=\"$save_libs\"])\n  AC_CHECK_FUNC(socket, :, AC_CHECK_LIB(socket, socket,\n\t\t\t\t        [NETWORK_LIBS=\"-lsocket $NETWORK_LIBS\"],\n\t\t\t\t        [AC_MSG_ERROR(Could not find socket())]))\n  save_libs=\"$LIBS\"\n  LIBS=\"$LIBS $NETWORK_LIBS\"\n\n  AC_MSG_CHECKING([for res_init])\n  AC_TRY_LINK([#include <sys/types.h>\n\t       #include <netinet/in.h>\n\t       #include <arpa/nameser.h>\n\t       #include <resolv.h>\n              ],[\n\t       res_init();\n              ],[AC_MSG_RESULT([yes])\n\t         AC_DEFINE(HAVE_RES_INIT, 1, [Define to 1 if you have the 'res_init' function.])\n\t      ],[AC_MSG_RESULT([no])])\n\n  AC_MSG_CHECKING([for res_nclose])\n  AC_TRY_LINK([#include <sys/types.h>\n\t       #include <netinet/in.h>\n\t       #include <arpa/nameser.h>\n\t       #include <resolv.h>\n              ],[\n               struct __res_state res;\n\t       res_nclose(&res);\n              ],[AC_MSG_RESULT([yes])\n\t         AC_DEFINE(HAVE_RES_NCLOSE, 1, [Define to 1 if you have the 'res_nclose' function.])\n\t      ],[AC_MSG_RESULT([no])])\n\n  AC_MSG_CHECKING([for res_ndestroy])\n  AC_TRY_LINK([#include <sys/types.h>\n\t       #include <netinet/in.h>\n\t       #include <arpa/nameser.h>\n\t       #include <resolv.h>\n              ],[\n               struct __res_state res;\n\t       res_ndestroy(&res);\n              ],[AC_MSG_RESULT([yes])\n\t         AC_DEFINE(HAVE_RES_NDESTROY, 1, [Define to 1 if you have the 'res_ndestroy' function.])\n\t      ],[AC_MSG_RESULT([no])])\n\n  AC_MSG_CHECKING([for res_ninit])\n  AC_TRY_LINK([#include <sys/types.h>\n\t       #include <netinet/in.h>\n\t       #include <arpa/nameser.h>\n\t       #include <resolv.h>\n              ],[\n               struct __res_state res;\n\t       res_ninit(&res);\n              ],[AC_MSG_RESULT([yes])\n\t         AC_DEFINE(HAVE_RES_NINIT, 1, [Define to 1 if you have the 'res_ninit' function.])\n\t      ],[AC_MSG_RESULT([no])])\n\n  AC_MSG_CHECKING([for res_nquery])\n  AC_TRY_LINK([#include <sys/types.h>\n\t       #include <netinet/in.h>\n\t       #include <arpa/nameser.h>\n\t       #include <resolv.h>\n              ],[\n               struct __res_state res;\n\t       res_nquery(&res, \"test\", 0, 0, (void *)0, 0);\n              ],[AC_MSG_RESULT([yes])\n\t         AC_DEFINE(HAVE_RES_NQUERY, 1, [Define to 1 if you have the 'res_nquery' function.])\n\t      ],[AC_MSG_RESULT([no])])\n  LIBS=\"$save_libs\"\n])\nAC_SUBST(NETWORK_LIBS)\n\nAC_CHECK_HEADER([linux/netlink.h],\n\t\t[AC_DEFINE(HAVE_NETLINK, 1, [We have AF_NETLINK sockets])],,\n\t\t[#include <sys/socket.h>])\nAM_CONDITIONAL(HAVE_NETLINK, [test \"$ac_cv_header_linux_netlink_h\" = \"yes\"])\n\nAC_CHECK_TYPE([struct ip_mreqn], [\n              AC_DEFINE(HAVE_IP_MREQN,, [Define if we have struct ip_mreqn])],,\n              [#include <netinet/in.h>])\n\ncase $host in\n  *-*-solaris* )\n     AC_DEFINE(_XOPEN_SOURCE_EXTENDED, 1, Needed to get declarations for msg_control and msg_controllen on Solaris)\n     AC_DEFINE(_XOPEN_SOURCE,          2, Needed to get declarations for msg_control and msg_controllen on Solaris)\n     AC_DEFINE(__EXTENSIONS__,         1, Needed to get declarations for msg_control and msg_controllen on Solaris)\n     ;;\nesac\n\ndnl\ndnl if statfs() takes 2 arguments (Posix) or 4 (Solaris)\ndnl\nAS_IF([test \"$ac_cv_func_statfs\" = yes], [\n  AC_MSG_CHECKING([number of arguments to statfs()])\n  AC_TRY_COMPILE([#include <unistd.h>\n  #ifdef HAVE_SYS_PARAM_H\n  #include <sys/param.h>\n  #endif\n  #ifdef HAVE_SYS_VFS_H\n  #include <sys/vfs.h>\n  #endif\n  #ifdef HAVE_SYS_MOUNT_H\n  #include <sys/mount.h>\n  #endif\n  #ifdef HAVE_SYS_STATFS_H\n  #include <sys/statfs.h>\n  #endif], [struct statfs st;\n  statfs(\"/\", &st);],[\n    AC_MSG_RESULT([2])\n    AC_DEFINE(STATFS_ARGS, 2, [Number of arguments to statfs()])],[\n    AC_TRY_COMPILE([#include <unistd.h>\n  #ifdef HAVE_SYS_PARAM_H\n  #include <sys/param.h>\n  #endif\n  #ifdef HAVE_SYS_VFS_H\n  #include <sys/vfs.h>\n  #endif\n  #ifdef HAVE_SYS_MOUNT_H\n  #include <sys/mount.h>\n  #endif\n  #ifdef HAVE_SYS_STATFS_H\n  #include <sys/statfs.h>\n  #endif], [struct statfs st;\n  statfs(\"/\", &st, sizeof (st), 0);],[\n      AC_MSG_RESULT([4])\n      AC_DEFINE(STATFS_ARGS, 4, [Number of arguments to statfs()])],[\n      AC_MSG_RESULT(unknown)\n      AC_MSG_ERROR([unable to determine number of arguments to statfs()])])])\n])\n\ndnl\ndnl open takes O_DIRECTORY as an option\ndnl\nAC_MSG_CHECKING([open() option O_DIRECTORY])\nAC_TRY_COMPILE([#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>],\n[open(0, O_DIRECTORY, 0);],[\n\tAC_MSG_RESULT([yes])\n\tAC_DEFINE(HAVE_OPEN_O_DIRECTORY, 1, [open option O_DIRECTORY])],[\n\tAC_MSG_RESULT([no])])\n\n#\n# Check whether to use an included printf\n#\nAC_FUNC_VSNPRINTF_C99\nAC_FUNC_PRINTF_UNIX98\n\nAC_ARG_ENABLE(included-printf,\n              [AS_HELP_STRING([--enable-included-printf],\n                              [use included printf [default=auto]])],\n              enable_included_printf=\"$enableval\")\n\nneed_included_printf=no\nif test \"x$enable_included_printf\" = \"xyes\" ; then\n  need_included_printf=yes\nfi\nif test \"$ac_cv_func_vsnprintf_c99\" != \"yes\" ; then\n  need_included_printf=yes\nfi\nif test \"$ac_cv_func_printf_unix98\" != \"yes\" ; then\n  need_included_printf=yes\nfi\nif test \"x$ac_cv_sizeof_long_long\" = \"x8\" &&\n   test -z \"$glib_cv_long_long_format\" ; then\n  need_included_printf=yes\nfi\n\nif test \"x$enable_included_printf\" = \"xno\" && \n   test \"x$need_included_printf\" = \"xyes\" ; then\n  AC_MSG_ERROR([\n*** Your C library's printf doesn't appear to have the features that\n*** GLib needs, but you specified --enable-included-printf=no.])\nfi\n\nenable_included_printf=$need_included_printf\n\nAM_CONDITIONAL(HAVE_GOOD_PRINTF, test \"$enable_included_printf\" != \"yes\")\nAS_IF([test \"$enable_included_printf\" != \"yes\"], [\n  AC_DEFINE(HAVE_GOOD_PRINTF,1,[define to use system printf])\n], [\n  if test -z \"$glib_cv_long_long_format\" ; then\n    glib_cv_long_long_format=\"ll\"\n  fi\n  AC_DEFINE(HAVE_VASPRINTF,1)\n])\n\n# Checks needed for gnulib vasnprintf\nbh_C_SIGNED\njm_AC_TYPE_LONG_LONG\ngt_TYPE_LONGDOUBLE\ngt_TYPE_WCHAR_T\ngt_TYPE_WINT_T\nAC_TYPE_SIZE_T\nAC_CHECK_TYPES(ptrdiff_t)\njm_AC_TYPE_INTMAX_T\nAC_CHECK_FUNCS([snprintf strnlen wcslen wcsnlen mbrtowc wcrtomb])\nAC_FUNC_SNPRINTF_C99\n\ndnl Check for nl_langinfo and CODESET\nAC_LANG_SAVE\nAC_LANG_C\nAC_CACHE_CHECK([for nl_langinfo (CODESET)],glib_cv_langinfo_codeset,[\n        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <langinfo.h>],\n                       [char *codeset = nl_langinfo (CODESET);])],\n                [glib_cv_langinfo_codeset=yes],\n                [glib_cv_langinfo_codeset=no])])\nif test x$glib_cv_langinfo_codeset = xyes; then\n  AC_DEFINE(HAVE_CODESET,1,[Have nl_langinfo (CODESET)])\nfi\n\ndnl Check for nl_langinfo and LC_TIME parts that are needed in gdatetime.c\nAC_CACHE_CHECK([for nl_langinfo (PM_STR)],glib_cv_langinfo_time,[\n        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <langinfo.h>],\n                 [char *str;\n                 str = nl_langinfo (PM_STR);\n                 str = nl_langinfo (D_T_FMT);\n                 str = nl_langinfo (D_FMT);\n                 str = nl_langinfo (T_FMT);\n                 str = nl_langinfo (T_FMT_AMPM);\n                 str = nl_langinfo (MON_1);\n                 str = nl_langinfo (ABMON_12);\n                 str = nl_langinfo (DAY_1);\n                 str = nl_langinfo (ABDAY_7);])],\n                [glib_cv_langinfo_time=yes],\n                [glib_cv_langinfo_time=no])])\nif test x$glib_cv_langinfo_time = xyes; then\n  AC_DEFINE(HAVE_LANGINFO_TIME,1,[Have nl_langinfo (PM_STR)])\nfi\n\ndnl Check for nl_langinfo and _NL_CTYPE_OUTDIGITn_MB\nAC_CACHE_CHECK([for nl_langinfo (_NL_CTYPE_OUTDIGITn_MB)], glib_cv_langinfo_outdigit,[\n        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <langinfo.h>],\n                [char *str;\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT1_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT2_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT3_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT4_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT5_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT6_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT7_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT8_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT9_MB);])],\n                [glib_cv_langinfo_outdigit=yes],\n                [glib_cv_langinfo_outdigit=no])])\nif test x$glib_cv_langinfo_outdigit = xyes; then\n  AC_DEFINE(HAVE_LANGINFO_OUTDIGIT,1,[Have nl_langinfo (_NL_CTYPE_OUTDIGITn_MB)])\nfi\n\ndnl Check for nl_langinfo and ALTMON_n\nAC_CACHE_CHECK([for nl_langinfo (ALTMON_n)], glib_cv_langinfo_altmon,[\n        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <langinfo.h>],\n                [char *str;\n                 str = nl_langinfo (ALTMON_1);\n                 str = nl_langinfo (ALTMON_2);\n                 str = nl_langinfo (ALTMON_3);\n                 str = nl_langinfo (ALTMON_4);\n                 str = nl_langinfo (ALTMON_5);\n                 str = nl_langinfo (ALTMON_6);\n                 str = nl_langinfo (ALTMON_7);\n                 str = nl_langinfo (ALTMON_8);\n                 str = nl_langinfo (ALTMON_9);\n                 str = nl_langinfo (ALTMON_10);\n                 str = nl_langinfo (ALTMON_11);\n                 str = nl_langinfo (ALTMON_12);])],\n                [glib_cv_langinfo_altmon=yes],\n                [glib_cv_langinfo_altmon=no])])\nif test x$glib_cv_langinfo_altmon = xyes; then\n  AC_DEFINE(HAVE_LANGINFO_ALTMON,1,[Have nl_langinfo (ALTMON_n)])\nfi\n\ndnl Check for nl_langinfo and _NL_ABALTMON_n\nAC_CACHE_CHECK([for nl_langinfo (_NL_ABALTMON_n)], glib_cv_langinfo_abaltmon,[\n        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <langinfo.h>],\n                [char *str;\n                 str = nl_langinfo (_NL_ABALTMON_1);\n                 str = nl_langinfo (_NL_ABALTMON_2);\n                 str = nl_langinfo (_NL_ABALTMON_3);\n                 str = nl_langinfo (_NL_ABALTMON_4);\n                 str = nl_langinfo (_NL_ABALTMON_5);\n                 str = nl_langinfo (_NL_ABALTMON_6);\n                 str = nl_langinfo (_NL_ABALTMON_7);\n                 str = nl_langinfo (_NL_ABALTMON_8);\n                 str = nl_langinfo (_NL_ABALTMON_9);\n                 str = nl_langinfo (_NL_ABALTMON_10);\n                 str = nl_langinfo (_NL_ABALTMON_11);\n                 str = nl_langinfo (_NL_ABALTMON_12);])],\n                [glib_cv_langinfo_abaltmon=yes],\n                [glib_cv_langinfo_abaltmon=no])])\nif test x$glib_cv_langinfo_abaltmon = xyes; then\n  AC_DEFINE(HAVE_LANGINFO_ABALTMON,1,[Have nl_langinfo (_NL_ABALTMON_n)])\nfi\nAC_LANG_RESTORE\n\n\ndnl ****************************************\ndnl *** strlcpy/strlcat                  ***\ndnl ****************************************\n# Check for strlcpy\nAC_CACHE_CHECK([for OpenBSD strlcpy/strlcat],glib_cv_have_strlcpy,[\nAC_TRY_RUN([#include <stdlib.h>\n#include <string.h>\nint main() {\n  char p[10];\n  (void) strlcpy (p, \"hi\", 10);\n  if (strlcat (p, \"bye\", 0) != 3) \n    return 1;\n  return 0;\n}], glib_cv_have_strlcpy=yes, \n    glib_cv_have_strlcpy=no,\n    glib_cv_have_strlcpy=no)])\nif test \"$glib_cv_have_strlcpy\" = \"yes\"; then\n    AC_DEFINE(HAVE_STRLCPY,1,[Have functions strlcpy and strlcat])\nfi\n  \n\ndnl **********************\ndnl *** va_copy checks ***\ndnl **********************\ndnl we currently check for all three va_copy possibilities, so we get\ndnl all results in config.log for bug reports.\nAC_CACHE_CHECK([for an implementation of va_copy()],glib_cv_va_copy,[\n\tAC_LINK_IFELSE([AC_LANG_SOURCE([[#include <stdarg.h>\n#include <stdlib.h>\n\tvoid f (int i, ...) {\n\tva_list args1, args2;\n\tva_start (args1, i);\n\tva_copy (args2, args1);\n\tif (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)\n\t  exit (1);\n\tva_end (args1); va_end (args2);\n\t}\n\tint main() {\n\t  f (0, 42);\n\t  return 0;\n\t}]])],\n\t[glib_cv_va_copy=yes],\n\t[glib_cv_va_copy=no])\n])\nAC_CACHE_CHECK([for an implementation of __va_copy()],glib_cv___va_copy,[\n\tAC_LINK_IFELSE([AC_LANG_SOURCE([[#include <stdarg.h>\n#include <stdlib.h>\n\tvoid f (int i, ...) {\n\tva_list args1, args2;\n\tva_start (args1, i);\n\t__va_copy (args2, args1);\n\tif (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)\n\t  exit (1);\n\tva_end (args1); va_end (args2);\n\t}\n\tint main() {\n\t  f (0, 42);\n\t  return 0;\n\t}]])],\n\t[glib_cv___va_copy=yes],\n\t[glib_cv___va_copy=no])\n])\n\nif test \"x$glib_cv_va_copy\" = \"xyes\"; then\n  g_va_copy_func=va_copy\nelse if test \"x$glib_cv___va_copy\" = \"xyes\"; then\n  g_va_copy_func=__va_copy\nfi\nfi\n\nif test -n \"$g_va_copy_func\"; then\n  AC_DEFINE_UNQUOTED(G_VA_COPY,$g_va_copy_func,[A 'va_copy' style function])\nfi\n\nAC_CACHE_CHECK([whether va_lists can be copied by value],glib_cv_va_val_copy,[\n\tAC_TRY_RUN([#include <stdarg.h>\n#include <stdlib.h> \n\tvoid f (int i, ...) {\n\tva_list args1, args2;\n\tva_start (args1, i);\n\targs2 = args1;\n\tif (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)\n\t  exit (1);\n\tva_end (args1); va_end (args2);\n\t}\n\tint main() {\n\t  f (0, 42);\n\t  return 0;\n\t}],\n\t[glib_cv_va_val_copy=yes],\n\t[glib_cv_va_val_copy=no],\n\t[glib_cv_va_val_copy=yes])\n])\n\nAS_IF([ test \"x$glib_cv_va_val_copy\" = \"xno\"], [\n  AC_DEFINE(G_VA_COPY_AS_ARRAY,1, ['va_lists' cannot be copies as values])\n])\n\ndnl ***********************\ndnl *** g_module checks ***\ndnl ***********************\nG_MODULE_LIBS=\nG_MODULE_LIBS_EXTRA=\nG_MODULE_PLUGIN_LIBS=\nif test x\"$glib_native_win32\" = xyes; then\n  dnl No use for this on Win32\n  G_MODULE_LDFLAGS=\nelse\n  export SED\n  eval G_MODULE_LDFLAGS=$export_dynamic_flag_spec\nfi\ndnl G_MODULE_IMPL= don't reset, so cmd-line can override\nG_MODULE_NEED_USCORE=0\nG_MODULE_BROKEN_RTLD_GLOBAL=0\nG_MODULE_HAVE_DLERROR=0\ndnl *** force native WIN32 shared lib loader \nif test -z \"$G_MODULE_IMPL\"; then\n  case \"$host\" in\n  *-*-mingw*|*-*-cygwin*) G_MODULE_IMPL=G_MODULE_IMPL_WIN32 ;;\n  esac\nfi\ndnl *** force native AIX library loader\ndnl *** dlopen() filepath must be of the form /path/libname.a(libname.so)\nif test -z \"$G_MODULE_IMPL\"; then\n  case \"$host\" in\n  *-*-aix*) G_MODULE_IMPL=G_MODULE_IMPL_AR ;;\n  esac\nfi\ndnl *** dlopen() and dlsym() in system libraries\nAS_IF([ test -z \"$G_MODULE_IMPL\"], [\n\tAC_CHECK_FUNC(dlopen,\n\t\t      [AC_CHECK_FUNC(dlsym,\n\t\t\t             [G_MODULE_IMPL=G_MODULE_IMPL_DL],[])],\n\t\t      [])\n])\ndnl *** NSLinkModule (dyld) in system libraries (Darwin)\nAS_IF([ test -z \"$G_MODULE_IMPL\" ], [\n \tAC_CHECK_FUNC(NSLinkModule,\n\t\t      [G_MODULE_IMPL=G_MODULE_IMPL_DYLD\n\t\t       G_MODULE_NEED_USCORE=1],\n\t\t      [])\n])\ndnl *** dlopen() and dlsym() in libdl\nAS_IF([ test -z \"$G_MODULE_IMPL\"], [\n\tAC_CHECK_LIB(dl, dlopen,\n\t\t     [AC_CHECK_LIB(dl, dlsym,\n\t\t\t           [G_MODULE_LIBS=-ldl\n\t\t                   G_MODULE_IMPL=G_MODULE_IMPL_DL],[])],\n\t\t     [])\n])\ndnl *** additional checks for G_MODULE_IMPL_DL\nAS_IF([ test \"$G_MODULE_IMPL\" = \"G_MODULE_IMPL_DL\" ], [\n\tLIBS_orig=\"$LIBS\"\n\tLDFLAGS_orig=\"$LDFLAGS\"\n\tLIBS=\"$G_MODULE_LIBS $LIBS\"\n\tLDFLAGS=\"$LDFLAGS $G_MODULE_LDFLAGS\"\ndnl *** check for OSF1/5.0 RTLD_GLOBAL brokenness\n\techo \"void glib_plugin_test(void) { }\" > plugin.c\n\t${SHELL} ./libtool --mode=compile --tag=CC ${CC} ${CFLAGS} \\\n\t\t${CPPFLAGS} -c -o plugin.lo plugin.c >/dev/null 2>&1\n\t${SHELL} ./libtool --mode=link --tag=CC ${CC} ${CFLAGS} \\\n\t\t${LDFLAGS} -module -o plugin.la -export-dynamic \\\n\t\t-shrext \".o\" -avoid-version plugin.lo \\\n\t\t-rpath /dont/care >/dev/null 2>&1\n\tAC_CACHE_CHECK([for RTLD_GLOBAL brokenness],\n\t\tglib_cv_rtldglobal_broken,[\n\t\tAC_TRY_RUN([\n#include <dlfcn.h>\n#ifndef RTLD_GLOBAL\n#  define RTLD_GLOBAL 0\n#endif\n#ifndef RTLD_LAZY\n#  define RTLD_LAZY 0\n#endif\nint glib_plugin_test;\nint main () {\n    void *handle, *global, *local;\n    global = &glib_plugin_test;\n    handle = dlopen (\"./$objdir/plugin.o\", RTLD_GLOBAL | RTLD_LAZY);\n    if (!handle) return 0;\n    local = dlsym (handle, \"glib_plugin_test\");\n    return global == local;\n}                       ],\n\t\t\t[glib_cv_rtldglobal_broken=no],\n\t\t\t[glib_cv_rtldglobal_broken=yes],\n\t\t\t[glib_cv_rtldglobal_broken=no])\n\t\trm -f plugin.c plugin.o plugin.lo plugin.la ${objdir}/plugin.*\n\t\trmdir ${objdir} 2>/dev/null\n\t])\n\tif test \"x$glib_cv_rtldglobal_broken\" = \"xyes\"; then\n  \t\tG_MODULE_BROKEN_RTLD_GLOBAL=1\n\telse\n  \t\tG_MODULE_BROKEN_RTLD_GLOBAL=0\n\tfi\ndnl *** check whether we need preceeding underscores\n\tAC_CACHE_CHECK([for preceeding underscore in symbols],\n\t\tglib_cv_uscore,[\n\t\tAC_TRY_RUN([#include <dlfcn.h>\n                int glib_underscore_test (void) { return 42; }\n\t\tint main() {\n\t\t  void *f1 = (void*)0, *f2 = (void*)0, *handle;\n\t\t  handle = dlopen ((void*)0, 0);\n\t\t  if (handle) {\n\t\t    f1 = dlsym (handle, \"glib_underscore_test\");\n\t\t    f2 = dlsym (handle, \"_glib_underscore_test\");\n\t\t  } return (!f2 || f1);\n\t\t}],\n\t\t\t[glib_cv_uscore=yes],\n\t\t\t[glib_cv_uscore=no],\n\t\t\t[])\n\t\trm -f plugin.c plugin.$ac_objext plugin.lo\n\t])\n        GLIB_ASSERT_SET(glib_cv_uscore)\n\tif test \"x$glib_cv_uscore\" = \"xyes\"; then\n  \t\tG_MODULE_NEED_USCORE=1\n\telse\n  \t\tG_MODULE_NEED_USCORE=0\n\tfi\n\n        AC_CHECK_DECL([RTLD_LAZY],\n                      [AC_DEFINE(HAVE_RTLD_LAZY, 1, [Define to 1 if RTLD_LAZY is available])],\n                      [], [[#include <dlfcn.h>]])\n        AC_CHECK_DECL([RTLD_NOW],\n                      [AC_DEFINE(HAVE_RTLD_NOW, 1, [Define to 1 if RTLD_NOW is available])],\n                      [], [[#include <dlfcn.h>]])\n        AC_CHECK_DECL([RTLD_GLOBAL],\n                      [AC_DEFINE(HAVE_RTLD_GLOBAL, 1, [Define to 1 if RTLD_GLOBAL is available])],\n                      [], [[#include <dlfcn.h>]])\n\n\tLDFLAGS=\"$LDFLAGS_orig\"\ndnl *** check for having dlerror()\n\tAC_CHECK_FUNC(dlerror,\n\t\t[G_MODULE_HAVE_DLERROR=1],\n\t\t[G_MODULE_HAVE_DLERROR=0])\n\tLIBS=\"$LIBS_orig\"\n])\ndnl *** done, have we got an implementation?\nif test -z \"$G_MODULE_IMPL\"; then\n\tG_MODULE_IMPL=0\n        G_MODULE_SUPPORTED=false\nelse\n        G_MODULE_SUPPORTED=true\nfi\n\nAC_MSG_CHECKING(for the suffix of module shared libraries)\nexport SED\nmodule=yes eval std_shrext=$shrext_cmds\n# chop the initial dot\nglib_gmodule_suffix=`echo $std_shrext | sed 's/^\\.//'`\nAC_MSG_RESULT(.$glib_gmodule_suffix)\n# any reason it may fail?\nif test \"x$glib_gmodule_suffix\" = x; then\n\tAC_MSG_ERROR(Cannot determine shared library suffix from libtool)\nfi\n \nAC_SUBST(G_MODULE_SUPPORTED)\nAC_SUBST(G_MODULE_IMPL)\nAC_SUBST(G_MODULE_LIBS)\nAC_SUBST(G_MODULE_LIBS_EXTRA)\nAC_SUBST(G_MODULE_PLUGIN_LIBS)\nAC_SUBST(G_MODULE_LDFLAGS)\nAC_SUBST(G_MODULE_HAVE_DLERROR)\nAC_SUBST(G_MODULE_BROKEN_RTLD_GLOBAL)\nAC_SUBST(G_MODULE_NEED_USCORE)\nAC_SUBST(GLIB_DEBUG_FLAGS)\n\ndnl **********************\ndnl *** g_spawn checks ***\ndnl **********************\n\nAC_MSG_CHECKING(for gspawn implementation)\ncase \"$host\" in\n  *-*-mingw*)\n    g_spawn_impl=win32\n    ;;\n  *)\n    g_spawn_impl=unix\n    ;;    \nesac\nAC_MSG_RESULT($g_spawn_impl)\nAM_CONDITIONAL(G_SPAWN_WIN32, [test \"$g_spawn_impl\" = \"win32\"])\n\ndnl *************************\ndnl *** GIOChannel checks ***\ndnl *************************\n\nAC_MSG_CHECKING(for GIOChannel implementation)\ncase \"$host\" in\n  *-*-mingw*)\n    g_io_channel_impl=win32\n    ;;\n  *)\n    g_io_channel_impl=unix\n    ;;    \nesac\nAC_MSG_RESULT($g_io_channel_impl)\nAM_CONDITIONAL(G_IO_CHANNEL_WIN32, [test \"$g_io_channel_impl\" = \"win32\"])\n\ndnl *********************************\ndnl *** Directory for GIO modules ***\ndnl *********************************\n\nAC_ARG_WITH(gio-module-dir,\n           [AS_HELP_STRING([--with-gio-module-dir=DIR],\n                           [load gio modules from this directory [LIBDIR/gio/modules]])],\n           [],\n\t   [with_gio_module_dir='${libdir}/gio/modules'])\nGIO_MODULE_DIR=$with_gio_module_dir\nAC_SUBST(GIO_MODULE_DIR)\n\ndnl **********************************\ndnl *** Check for libselinux (GIO) ***\ndnl **********************************\nAC_ARG_ENABLE(selinux,\n              AS_HELP_STRING([--disable-selinux],\n                             [build without selinux support]))\nmsg_selinux=no\nSELINUX_LIBS=\nAS_IF([ test \"x$enable_selinux\" != \"xno\"], [\n\n AC_CHECK_LIB(selinux, is_selinux_enabled,\n   [AC_CHECK_HEADERS(selinux/selinux.h,\n     [AC_CHECK_LIB(selinux, lgetfilecon_raw, \n       [AC_DEFINE(HAVE_SELINUX, 1, [Define to 1 if libselinux is available])\n        SELINUX_LIBS=\"-lselinux\"\n        msg_selinux=yes])\n     ])\n   ])\n])\nAC_SUBST(SELINUX_LIBS)\n\ndnl *****************************\ndnl ** Check for inotify (GIO) **\ndnl *****************************\ninotify_support=no\nAC_CHECK_HEADERS([sys/inotify.h],\n[\n  AC_CHECK_FUNCS(inotify_init1, [inotify_support=yes], [inotify_support=no])\n])\n\nAM_CONDITIONAL(HAVE_INOTIFY, [test \"$inotify_support\" = \"yes\"])\n\ndnl ****************************\ndnl ** Check for kqueue (GIO) **\ndnl ****************************\nkqueue_support=no\nAC_CHECK_HEADERS([sys/event.h],\n[\n\tAC_CHECK_FUNCS(kqueue kevent, [kqueue_support=yes])\n])\n\nAM_CONDITIONAL(HAVE_KQUEUE, [test \"$kqueue_support\" = \"yes\"])\n\ndnl ****************************\ndnl *** Checks for FAM (GIO) ***\ndnl ****************************\n\nshould_disable_fam=no\n\nAC_ARG_ENABLE(fam,\n              AS_HELP_STRING([--disable-fam],\n                             [don't use fam for file system monitoring]),\n                         [\n                                if test \"x$enable_fam\" = \"xno\"; then\n                                        should_disable_fam=yes\n                                fi\n                         ]\n                         )\nfam_support=no\nFAM_LIBS=\nif test \"x$should_disable_fam\" = \"xno\"; then\nAC_CHECK_LIB(fam, FAMOpen,\n  [AC_CHECK_HEADERS(fam.h,\n    [AC_CHECK_LIB(fam, FAMNoExists,\n     \t\t  AC_DEFINE(HAVE_FAM_NO_EXISTS, [], [Define if we have FAMNoExists in fam]))\n     FAM_LIBS=\"-lfam\"]\n     fam_support=yes,\n    AC_MSG_WARN(*** FAM support will not be built (header files not found) ***))],\n  AC_MSG_WARN(*** FAM support will not be built (FAM library not found) ***))\nAC_SUBST(FAM_LIBS)\nfi\nAM_CONDITIONAL(HAVE_FAM, [test \"$fam_support\" = \"yes\"])\n\n\ndnl *****************************\ndnl *** Check for xattr (GIO) ***\ndnl *****************************\nAC_ARG_ENABLE(xattr,\n              AS_HELP_STRING([--disable-xattr], [build without xattr support]))\nmsg_xattr=no\nXATTR_LIBS=\nAS_IF([ test \"x$enable_xattr\" != \"xno\"], [\n\ndnl either glibc or libattr can provide xattr support\n\ndnl for both of them, we check for getxattr being in\ndnl the library and a valid xattr header.\n\ndnl try glibc\n AC_CHECK_LIB(c, getxattr,\n   [AC_CHECK_HEADERS(sys/xattr.h,\n     [AC_DEFINE(HAVE_XATTR, 1, [Define to 1 if xattr is available])\n      msg_xattr=yes])\n   ])\n\n  AS_IF([ test \"x$msg_xattr\" != \"xyes\"], [\ndnl   failure. try libattr\n   AC_CHECK_LIB(attr, getxattr,\n      [AC_CHECK_HEADERS(attr/xattr.h,\n       [AC_DEFINE(HAVE_XATTR, 1, [Define to 1 if xattr is available])\n        XATTR_LIBS=\"-lattr\"\n        msg_xattr=yes])\n      ])\n  ])\n\n  AS_IF([ test \"x$msg_xattr\" = \"xyes\"], [\n    AC_MSG_CHECKING([for XATTR_NOFOLLOW])\n    AC_TRY_COMPILE([\n      #include <stdio.h>\n      #ifdef HAVE_SYS_TYPES_H\n      #include <sys/types.h>\n      #endif\n      #ifdef HAVE_SYS_XATTR_H\n      #include <sys/xattr.h>\n      #elif HAVE_ATTR_XATTR_H\n      #include <attr/xattr.h>\n      #endif\n    ],\n    [ssize_t len = getxattr(\"\", \"\", NULL, 0, 0, XATTR_NOFOLLOW);],\n    [\n      AC_DEFINE([HAVE_XATTR_NOFOLLOW], [1], [Define to 1 if xattr API uses XATTR_NOFOLLOW])\n      AC_MSG_RESULT([yes])\n    ],\n    [AC_MSG_RESULT([no])]\n    )\n  ])\n])\nAC_SUBST(XATTR_LIBS)\n\ndnl ************************\ndnl *** check for libelf ***\ndnl ************************\nAC_ARG_ENABLE(libelf,\n              AS_HELP_STRING([--disable-libelf], [build without libelf support]))\nAS_IF([ test \"x$enable_libelf\" != \"xno\"],[\nPKG_CHECK_MODULES([LIBELF], [libelf >= 0.8.12], [have_libelf=yes], [have_libelf=maybe])\nAS_IF([ test $have_libelf = maybe ], [\n  glib_save_LIBS=$LIBS\n  AC_CHECK_LIB([elf], [elf_begin], [:], [have_libelf=no])\n  AC_CHECK_LIB([elf], [elf_getshdrstrndx], [:], [have_libelf=no])\n  AC_CHECK_LIB([elf], [elf_getshdrnum], [:], [have_libelf=no])\n  AC_CHECK_HEADER([libelf.h], [:], [have_libelf=no])\n  LIBS=$glib_save_LIBS\n\n  if test $have_libelf != no; then\n    LIBELF_LIBS=-lelf\n    have_libelf=yes\n  fi\n])\n])\n\nif test x$have_libelf = xyes; then\n  AC_DEFINE(HAVE_LIBELF, 1, [Define if libelf is available])\nfi\n\ndnl ************************\ndnl *** check for libmount ***\ndnl ************************\n\ndnl The fallback code doesn't really implement the same behaviors - e.g.\ndnl so on linux we want to require libmount unless specifically disabled\ndnl\nenable_libmount_default=${glib_os_linux:-no}\nAC_ARG_ENABLE(libmount,\n              [AS_HELP_STRING([--enable-libmount],\n                              [build with libmount support [default for Linux]])],,\n              [enable_libmount=$enable_libmount_default])\nAS_IF([ test \"x$enable_libmount\" = \"xyes\"],[\nPKG_CHECK_MODULES([LIBMOUNT], [mount >= 2.23], [have_libmount=yes], [have_libmount=no])\nif test $have_libmount = no ; then\n   AC_MSG_ERROR([*** Could not find libmount])\nfi\n])\n\nif test x$have_libmount = xyes; then\n  LIBMOUNT_REQUIRES=\"mount >= 2.23\"\n  AC_DEFINE(HAVE_LIBMOUNT, 1, [Define if libmount is available])\nelse\n  LIBMOUNT_REQUIRES=\"\"\nfi\nAM_CONDITIONAL(HAVE_LIBMOUNT, [test x$have_libmount = xyes])\nAC_SUBST([LIBMOUNT_REQUIRES])\n\ndnl ****************************************\ndnl *** platform dependent source checks ***\ndnl ****************************************\n\nAC_MSG_CHECKING([whether to compile timeloop])\ncase \"$host\" in\n  *-*-cygwin*|*-*-mingw*|*-*-minix)\n    enable_timeloop=no\n    ;;\n  *)\n    enable_timeloop=yes\n    ;;    \nesac\nAC_MSG_RESULT($enable_timeloop)\nAM_CONDITIONAL(ENABLE_TIMELOOP, test x$enable_timeloop = xyes)\n\nAC_MSG_CHECKING([if building for some Win32 platform])\ncase \"$host\" in\n  *-*-mingw*|*-*-cygwin*)\n    platform_win32=yes\n    ;;\n  *)\n    platform_win32=no\n    ;;\nesac\nAC_MSG_RESULT($platform_win32)\nAM_CONDITIONAL(PLATFORM_WIN32, test x$platform_win32 = xyes)\n\ndnl ***********************\ndnl *** g_thread checks ***\ndnl ***********************\n\nAC_ARG_WITH(threads,\n           [AS_HELP_STRING([--with-threads=@<:@posix/win32@:>@],\n                           [specify a thread implementation to use])],\n           [],\n           [with_threads=yes])\n\ndnl error and warning message\ndnl *************************\n\nTHREAD_NO_IMPLEMENTATION=\"No thread implementation found.\"\n\nFLAG_DOES_NOT_WORK=\"I can't find the MACRO to enable thread safety on your\n                platform (normally it's \"_REENTRANT\"). I'll not use any flag on\n                compilation now, but then your programs might not work.\n                Please provide information on how it is done on your system.\"\n\nLIBS_NOT_FOUND_1=\"I can't find the libraries for the thread implementation\n                 \"\n\nLIBS_NOT_FOUND_2=\". Please choose another thread implementation or\n                  provide information on your thread implementation.\"\n\nFUNC_NO_GETPWUID_R=\"the 'g_get_(user_name|real_name|home_dir|tmp_dir)'\n\t\tfunctions will not be MT-safe during their first call because\n\t\tthere is no working 'getpwuid_r' on your system.\"\n\nFUNC_NO_LOCALTIME_R=\"the 'g_date_set_time' function will not be MT-safe\n\t\tbecause there is no 'localtime_r' on your system.\"\n\nAIX_COMPILE_INFO=\"AIX's C compiler needs to be called by a different name, when\n\t\tlinking threaded applications. As GLib cannot do that \n\t\tautomatically, you will get an linking error every time you are\n\t\tnot using the right compiler. In that case you have to relink \n\t\twith the right compiler. Ususally just '_r' is appended \n\t\tto the compiler name.\"\n\ndnl determination of thread implementation\ndnl ***************************************\n\nAC_MSG_CHECKING(for thread implementation)\n\nhave_threads=no\nAS_IF([ test \"x$with_threads\" = xyes || test \"x$with_threads\" = xposix], [\n        AS_IF([ test \"x$have_threads\" = xno], [\n                AC_TRY_COMPILE([#include <pthread.h>],\n\t\t\t[pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;],\n\t\t\thave_threads=posix)\n\t])\n\t# Tru64Unix requires -pthread to find pthread.h. See #103020\n\tif test \"x$have_threads\" = xno; then\n\t\tglib_save_CPPFLAGS=\"$CPPFLAGS\"\n\t\tCPPFLAGS=\"$CPPFLAGS -pthread\"\n\t\tAC_TRY_COMPILE([#include <pthread.h>],\n\t\t       [pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;],\n\t\t       have_threads=posix)\n\t\tCPPFLAGS=\"$glib_save_CPPFLAGS\"\n        fi\n])\nif test \"x$with_threads\" = xyes || test \"x$with_threads\" = xwin32; then\n        case $host in\n                *-*-mingw*)\n                have_threads=win32\n                ;;\n        esac\nfi\n\nif test \"x$have_threads\" = xno; then\n        AC_MSG_RESULT(none available)\n        AC_MSG_ERROR($THREAD_NO_IMPLEMENTATION)\nelse\n        AC_MSG_RESULT($have_threads)\nfi\n\n\ndnl determination of G_THREAD_CFLAGS\ndnl ********************************\n\nG_THREAD_LIBS=\nG_THREAD_LIBS_EXTRA=\nG_THREAD_CFLAGS=\n\ndnl\ndnl Test program for basic POSIX threads functionality\ndnl\nm4_define([glib_thread_test],[\n#include <pthread.h> \nint check_me = 0;\nvoid* func(void* data) {check_me = 42; return &check_me;}\nint main()\n { pthread_t t; \n   void *ret;\n   pthread_create (&t, $1, func, 0);\n   pthread_join (t, &ret);\n   return (check_me != 42 || ret != &check_me);\n}])\n\nAS_IF([ test x\"$have_threads\" = xposix], [\n  # First we test for posix, whether -pthread or -pthreads do the trick as \n  # both CPPFLAG and LIBS. \n  # One of them does for most gcc versions and some other platforms/compilers\n  # too and could be considered as the canonical way to go. \n  case $host in\n    *-*-cygwin*|*-*-darwin*)\n       # skip cygwin and darwin -pthread or -pthreads test\n       ;;\n    *-solaris*)\n      # These compiler/linker flags work with both Sun Studio and gcc\n      # Sun Studio expands -mt to -D_REENTRANT and -lthread\n      # gcc expands -pthreads to -D_REENTRANT -D_PTHREADS -lpthread\n      G_THREAD_CFLAGS=\"-D_REENTRANT -D_PTHREADS\"\n      G_THREAD_LIBS=\"-lpthread -lthread\"\n      ;;\n    *)\n      for flag in pthread pthreads mt; do\n        glib_save_CFLAGS=\"$CFLAGS\"\n        CFLAGS=\"$CFLAGS -$flag\"\n        AC_TRY_RUN(glib_thread_test(0),\n                   glib_flag_works=yes,\n                   glib_flag_works=no,\n                   [AC_LINK_IFELSE([AC_LANG_SOURCE(glib_thread_test(0))],\n                                   glib_flag_works=yes,\n                                   glib_flag_works=no)])\n        CFLAGS=\"$glib_save_CFLAGS\"\n        if test $glib_flag_works = yes ; then\n           G_THREAD_CFLAGS=-$flag\n        G_THREAD_LIBS=-$flag\n        break;\n        fi\n      done\n       ;;\n  esac\n])\n\nAS_IF([ test x\"$G_THREAD_CFLAGS\" = x], [\n\n  # The canonical -pthread[s] does not work. Try something different.\n\n  case $host in\n\t*-aix*)\n\t\tif test x\"$GCC\" = xyes; then\n\t\t\t# GCC 3.0 and above needs -pthread. \n\t\t\t# Should be coverd by the case above.\n\t\t\t# GCC 2.x and below needs -mthreads\n\t\t\tG_THREAD_CFLAGS=\"-mthreads\"\t\t\n\t\t\tG_THREAD_LIBS=$G_THREAD_CFLAGS\n\t\telse \n\t\t\t# We are probably using the aix compiler. Normaly a \n\t\t\t# program would have to be compiled with the _r variant\n\t\t\t# of the corresponding compiler, but we as GLib cannot \n\t\t\t# do that: but the good news is that for compiling the\n\t\t\t# only difference is the added -D_THREAD_SAFE compile \n\t\t\t# option. This is according to the \"C for AIX User's \n\t\t\t# Guide\".\n\t\t\tG_THREAD_CFLAGS=\"-D_THREAD_SAFE\"\n\t\tfi\n\t\t;;\n\t*-sysv5uw7*) # UnixWare 7 \n\t\t# We are not using gcc with -pthread. Catched above.\n\t\tG_THREAD_CFLAGS=\"-Kthread\"\n\t\tG_THREAD_LIBS=$G_THREAD_CFLAGS\n\t\t;;\n\t*-mingw*)\n\t\t# No flag needed when using MSVCRT.DLL\n\t\tG_THREAD_CFLAGS=\"\"\n\t\t;;\n\t*)\n\t\tG_THREAD_CFLAGS=\"-D_REENTRANT\" # good default guess otherwise\n\t\t;;\n  esac\n])\n\n# if we are not finding the localtime_r function, then we probably are\n# not using the proper multithread flag\n\nglib_save_CPPFLAGS=\"$CPPFLAGS\"\nCPPFLAGS=\"$CPPFLAGS $G_THREAD_CFLAGS\"\n\n# First we test, whether localtime_r is declared in time.h\n# directly. Then we test whether a macro localtime_r exists, in\n# which case localtime_r in the test program is replaced and thus\n# if we still find localtime_r in the output, it is not defined as \n# a macro.\n\nAC_EGREP_CPP([[^a-zA-Z1-9_]localtime_r[^a-zA-Z1-9_]], [#include <time.h>], ,\n  [AC_EGREP_CPP([[^a-zA-Z1-9_]localtime_r[^a-zA-Z1-9_]], [#include <time.h> \n\t\t\t\t\t\t\t   localtime_r(a,b)],\n  \t\t   AC_MSG_WARN($FLAG_DOES_NOT_WORK))])\n\nCPPFLAGS=\"$glib_save_CPPFLAGS\"\n\nAC_MSG_CHECKING(thread related cflags)\nAC_MSG_RESULT($G_THREAD_CFLAGS)\nCPPFLAGS=\"$CPPFLAGS $G_THREAD_CFLAGS\"\n\ndnl determination of G_THREAD_LIBS\ndnl ******************************\n\nAS_IF([test x$have_threads = xposix], [\n\t  glib_save_CPPFLAGS=\"$CPPFLAGS\"\n\t  CPPFLAGS=\"$CPPFLAGS $GTHREAD_COMPILE_IMPL_DEFINES\"\n          AS_IF([ test x\"$G_THREAD_LIBS\" = x ], [\n            case $host in\n              *-aix*)\n                # We are not using gcc (would have set G_THREAD_LIBS) and thus \n                # probably using the aix compiler.\n\t\tAC_MSG_WARN($AIX_COMPILE_INFO)\n                ;;\n              *)\n                G_THREAD_LIBS=error\n\t        glib_save_LIBS=\"$LIBS\"\n\t        for thread_lib in \"\" pthread pthread32 pthreads thread; do\n\t\t\tif test x\"$thread_lib\" = x; then\n\t\t\t\tadd_thread_lib=\"\"\n\t\t\t\tIN=\"\"\n\t\t\telse\n\t\t\t\tadd_thread_lib=\"-l$thread_lib\"\n\t\t\t\tIN=\" in -l$thread_lib\"\n\t\t\tfi\n\t\t\tif test x\"$have_threads\" = xposix; then\n\t\t\t\tdefattr=0\n\t\t\telse\n\t\t\t\tdefattr=pthread_attr_default\n\t\t\tfi\n\t\t\t\n\t\t\tLIBS=\"$add_thread_lib $glib_save_LIBS\"\n\t\t\t\n\t\t\tAC_MSG_CHECKING(for pthread_create/pthread_join$IN)\n\t\t\tAC_TRY_RUN(glib_thread_test($defattr),\n                                   glib_result=yes,\n                                   glib_result=no,\n                                   [AC_LINK_IFELSE([AC_LANG_SOURCE(glib_thread_test($defattr))],\n                                                   glib_result=yes,\n                                                   glib_result=no)])\n                        AC_MSG_RESULT($glib_result)\n\t\t\t\n                        if test \"$glib_result\" = \"yes\" ; then\n\t\t\t  G_THREAD_LIBS=\"$add_thread_lib\"\n                          break\n                        fi\n\t\tdone\n\t\tif test \"x$G_THREAD_LIBS\" = xerror; then\n\t\t  AC_MSG_ERROR($LIBS_NOT_FOUND_1$have_threads$LIBS_NOT_FOUND_2)\n\t\tfi \n\t\tLIBS=\"$glib_save_LIBS\"\n                ;;\n            esac\n\t  ])\n\n\t  g_threads_impl=\"POSIX\"\n          AC_DEFINE([THREADS_POSIX], [1], [Use pthreads])\n\t  AC_SUBST(GTHREAD_COMPILE_IMPL_DEFINES)\n          CPPFLAGS=\"$glib_save_CPPFLAGS\"\n], [test x$have_threads = xwin32], [\n           AC_DEFINE([THREADS_WIN32], [1], [Use w32 threads])\n\t   g_threads_impl=\"WIN32\"\n], [\n\t   g_threads_impl=\"NONE\"\n           G_THREAD_LIBS=error\n])\nAM_CONDITIONAL(THREADS_POSIX, [test \"$g_threads_impl\" = \"POSIX\"])\nAM_CONDITIONAL(THREADS_WIN32, [test \"$g_threads_impl\" = \"WIN32\"])\n\nif test \"x$G_THREAD_LIBS\" = xerror; then\n        AC_MSG_ERROR($LIBS_NOT_FOUND_1$have_threads$LIBS_NOT_FOUND_2)\nfi\n\nAC_MSG_CHECKING(thread related libraries)\nAC_MSG_RESULT($G_THREAD_LIBS)\n\ndnl check for mt safe function variants and some posix functions\ndnl ************************************************************\n\nglib_save_LIBS=\"$LIBS\"\n# we are not doing the following for now, as this might require glib \n# to always be linked with the thread libs on some platforms. \n# LIBS=\"$LIBS $G_THREAD_LIBS\"\nAC_CHECK_FUNCS(localtime_r gmtime_r getpwuid_r getgrgid_r)\n\nLIBS=\"$G_THREAD_LIBS $LIBS\"\nAS_IF([ test x\"$have_threads\" = xposix], [\n        glib_save_CPPFLAGS=\"$CPPFLAGS\"\n        CPPFLAGS=\"$CPPFLAGS $GTHREAD_COMPILE_IMPL_DEFINES\"\n        # This is not AC_CHECK_FUNC to also work with function\n        # name mangling in header files.\n        AC_MSG_CHECKING(for pthread_attr_setstacksize)\n        AC_LINK_IFELSE(\n            [AC_LANG_PROGRAM(\n                [#include <pthread.h>],\n                [pthread_attr_t t; pthread_attr_setstacksize(&t,0)])],\n            [AC_MSG_RESULT(yes)\n             AC_DEFINE(HAVE_PTHREAD_ATTR_SETSTACKSIZE,1,\n                [Have function pthread_attr_setstacksize])],\n            [AC_MSG_RESULT(no)])\n        AC_MSG_CHECKING(for pthread_condattr_setclock)\n        AC_LINK_IFELSE(\n            [AC_LANG_PROGRAM(\n                [#include <pthread.h>],\n                [pthread_condattr_t a; pthread_condattr_setclock(&a,0)])],\n            [AC_MSG_RESULT(yes)\n             AC_DEFINE(HAVE_PTHREAD_CONDATTR_SETCLOCK,1,\n                [Have function pthread_condattr_setclock])],\n            [AC_MSG_RESULT(no)])\n        AC_MSG_CHECKING(for pthread_cond_timedwait_relative_np)\n        AC_LINK_IFELSE(\n            [AC_LANG_PROGRAM(\n                [#include <pthread.h>],\n                [pthread_cond_timedwait_relative_np(NULL, NULL, NULL)])],\n            [AC_MSG_RESULT(yes)\n             AC_DEFINE(HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP,1,\n                [Have function pthread_cond_timedwait_relative_np])],\n            [AC_MSG_RESULT(no)])\n        dnl Sets thread names on OS X 10.6, iOS 3.2 (and higher)\n        AC_MSG_CHECKING(for pthread_setname_np(const char*))\n        AC_LINK_IFELSE(\n            [AC_LANG_PROGRAM(\n                [#include <pthread.h>],\n                [pthread_setname_np(\"example\")])],\n            [AC_MSG_RESULT(yes)\n             AC_DEFINE(HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID,1,\n                [Have function pthread_setname_np(const char*)])],\n            [AC_MSG_RESULT(no)])\n        dnl Sets thread names on Solaris 11.3 & higher\n        AC_MSG_CHECKING(for pthread_setname_np(pthread_t, const char*))\n        AC_LINK_IFELSE(\n            [AC_LANG_PROGRAM(\n                [#include <pthread.h>],\n                [pthread_setname_np(pthread_self(), \"example\")])],\n            [AC_MSG_RESULT(yes)\n             AC_DEFINE(HAVE_PTHREAD_SETNAME_NP_WITH_TID,1,\n                [Have function pthread_setname_np(pthread_t, const char*)])],\n            [AC_MSG_RESULT(no)])\n        AC_MSG_CHECKING(for pthread_getname_np(pthread_t, name, len))\n        AC_LINK_IFELSE(\n            [AC_LANG_PROGRAM(\n                [#include <pthread.h>],\n                [[char name[16]; pthread_getname_np(pthread_self(), name, 16);]])],\n            [AC_MSG_RESULT(yes)\n             AC_DEFINE(HAVE_PTHREAD_GETNAME_NP,1,\n                [Have function pthread_getname_np(pthread_t, name, len)])],\n            [AC_MSG_RESULT(no)])\n        CPPFLAGS=\"$glib_save_CPPFLAGS\"\n])\n\nLIBS=\"$glib_save_LIBS\"\n\n# now spit out all the warnings.\nif test \"$ac_cv_func_getpwuid_r\" != \"yes\"; then\n\tAC_MSG_WARN($FUNC_NO_GETPWUID_R)\nfi\nif test \"$ac_cv_func_localtime_r\" != \"yes\"; then\n\tAC_MSG_WARN($FUNC_NO_LOCALTIME_R)\nfi\n\n#\n# Hack to deal with:\n# \n#  a) GCC < 3.3 for Linux doesn't include -lpthread when\n#     building shared libraries with linux.\n#  b) FreeBSD doesn't do this either.\n#\ncase $host in\n  *android*)\n    G_THREAD_LIBS_FOR_GTHREAD=\"$G_THREAD_LIBS\"\n    ;;\n  *-*-freebsd*|*-*-linux*)\n    G_THREAD_LIBS_FOR_GTHREAD=\"`echo $G_THREAD_LIBS | sed s/-pthread/-lpthread/`\"\n    ;;\n  *)\n    G_THREAD_LIBS_FOR_GTHREAD=\"$G_THREAD_LIBS\"\n    ;;\nesac\n\nAC_SUBST(G_THREAD_CFLAGS)\nAC_SUBST(G_THREAD_LIBS)\nAC_SUBST(G_THREAD_LIBS_FOR_GTHREAD)\nAC_SUBST(G_THREAD_LIBS_EXTRA)\n\nAC_CHECK_FUNCS(clock_gettime, [], [\n  AC_CHECK_LIB(rt, clock_gettime, [\n    G_THREAD_LIBS=\"$G_THREAD_LIBS -lrt\"\n    G_THREAD_LIBS_FOR_GTHREAD=\"$G_THREAD_LIBS_FOR_GTHREAD -lrt\"\n  ])\n])\n\n\ndnl ************************\ndnl *** g_atomic_* tests ***\ndnl ************************\n\ndnl We need to decide at configure time if GLib will use real atomic\ndnl operations (\"lock free\") or emulated ones with a mutex.  This is\ndnl because we must put this information in glibconfig.h so we know if\ndnl it is safe or not to inline using compiler intrinsics directly from\ndnl the header.\ndnl\ndnl We also publish the information via G_ATOMIC_LOCK_FREE in case the\ndnl user is interested in knowing if they can use the atomic ops across\ndnl processes.\ndnl\ndnl We can currently support the atomic ops natively when building GLib\ndnl with recent versions of GCC or MSVC.  MSVC doesn't run ./configure,\ndnl so we skip that case here and define G_ATOMIC_LOCK_FREE exactly when\ndnl we are using GCC (and not mingw*).\ndnl\ndnl Note that the atomic ops are only available with GCC on x86 when\ndnl using -march=i486 or higher.  If we detect that the atomic ops are\ndnl not available but would be available given the right flags, we want\ndnl to abort and advise the user to fix their CFLAGS.  It's better to do\ndnl that then to silently fall back on emulated atomic ops just because\ndnl the user had the wrong build environment.\n\ndnl We may add other compilers here in the future...\n\nAC_CACHE_CHECK([for lock-free atomic intrinsics], glib_cv_g_atomic_lock_free, [\n  case $host in\n    *-*-mingw*)\n      glib_cv_g_atomic_lock_free=yes\n      ;;\n    *)\n      AC_TRY_LINK([],\n                     [volatile int atomic = 2;\\\n                      __sync_bool_compare_and_swap (&atomic, 2, 3);],\n                     [glib_cv_g_atomic_lock_free=yes],\n                     [glib_cv_g_atomic_lock_free=no])\n      if test \"$glib_cv_g_atomic_lock_free\" = \"no\"; then\n        SAVE_CFLAGS=\"${CFLAGS}\"\n        CFLAGS=\"-march=i486\"\n        AC_TRY_LINK([],\n                       [volatile int atomic = 2;\\\n                        __sync_bool_compare_and_swap (&atomic, 2, 3);],\n                       [AC_MSG_ERROR([GLib must be built with -march=i486 or later.])],\n                       [])\n        CFLAGS=\"${SAVE_CFLAGS}\"\n      fi\n      ;;\n  esac])\n\n\ncase $host in\n  *-*-mingw*)\n    ;;\n  *)\n    # Some compilers support atomic operations but do not define\n    # __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4, like clang\n    if test x\"$glib_cv_g_atomic_lock_free\" = xyes; then\n      AC_TRY_LINK([],\n                     [__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4;],\n                     [],\n                     [AC_DEFINE(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4, 1, [ compiler supports atomic operations])])\n    fi\n    ;;\n esac\n\ndnl We need a more robust approach here...\ncase $host_cpu in\n  i?86|x86_64|s390|s390x|arm*|crisv32*|etrax*)\n    glib_memory_barrier_needed=no\n    ;;\n  sparc*|alpha*|powerpc*|ia64)\n    glib_memory_barrier_needed=yes\n    ;;\n  *)\n    glib_memory_barrier_needed=yes\n    ;;\nesac\n\ndnl ************************\ndnl ** Check for futex(2) **\ndnl ************************\nAC_CACHE_CHECK(for futex(2) system call,\n    glib_cv_futex,AC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n],[\n  syscall (__NR_futex, NULL, FUTEX_WAKE, FUTEX_WAIT);\n])],glib_cv_futex=yes,glib_cv_futex=no))\nif test x\"$glib_cv_futex\" = xyes; then\n  AC_DEFINE(HAVE_FUTEX, 1, [we have the futex(2) system call])\nfi\n\nAC_CACHE_CHECK(for eventfd(2) system call,\n    glib_cv_eventfd,AC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#include <sys/eventfd.h>\n#include <unistd.h>\n],[\n  eventfd (0, EFD_CLOEXEC);\n])],glib_cv_eventfd=yes,glib_cv_eventfd=no))\nif test x\"$glib_cv_eventfd\" = x\"yes\"; then\n  AC_DEFINE(HAVE_EVENTFD, 1, [we have the eventfd(2) system call])\nfi\nAM_CONDITIONAL(HAVE_EVENTFD, [test \"$glib_cv_eventfd\" = \"yes\"])\n\ndnl ****************************************\ndnl *** GLib POLL* compatibility defines ***\ndnl ****************************************\n\nglib_poll_includes=[\"\n#include <sys/types.h>\n#include <poll.h>\n\"]\n\nAS_IF([ test $ac_cv_header_sys_types_h = yes &&\n   test $ac_cv_func_poll = yes ], [\n  glib_failed=false\n  GLIB_CHECK_VALUE(POLLIN, $glib_poll_includes, glib_failed=true)\n  GLIB_CHECK_VALUE(POLLOUT, $glib_poll_includes, glib_failed=true)\n  GLIB_CHECK_VALUE(POLLPRI, $glib_poll_includes, glib_failed=true)\n  GLIB_CHECK_VALUE(POLLERR, $glib_poll_includes, glib_failed=true)\n  GLIB_CHECK_VALUE(POLLHUP, $glib_poll_includes, glib_failed=true)\n  GLIB_CHECK_VALUE(POLLNVAL, $glib_poll_includes, glib_failed=true)\n  if $glib_failed ; then\n    AC_MSG_ERROR([Could not determine values for POLL* constants])\n  fi\n], [\n  glib_cv_value_POLLIN=1\n  glib_cv_value_POLLOUT=4\n  glib_cv_value_POLLPRI=2\n  glib_cv_value_POLLERR=8\n  glib_cv_value_POLLHUP=16\n  glib_cv_value_POLLNVAL=32\n])\n\nAC_MSG_CHECKING([for broken poll])\nAC_RUN_IFELSE([AC_LANG_SOURCE([[\n\t#include <stdlib.h>\n\t#include <fcntl.h>\n\t#include <poll.h>\n\tint main(void) {\n\t  struct pollfd fds[1];\n\t  int fd;\n\t  fd = open(\"/dev/null\", 1);\n\t  fds[0].fd = fd;\n\t  fds[0].events = POLLIN;\n\t  fds[0].revents = 0;\n\t  if (poll(fds, 1, 0) < 0 || (fds[0].revents & POLLNVAL) != 0) {\n\t\texit(1);  /* Does not work for devices -- fail */\n\t  }\n\t  exit(0);\n\t}]])],\n  [broken_poll=no],\n  [broken_poll=yes\n   AC_DEFINE(BROKEN_POLL,1,[poll doesn't work on devices])],\n  [broken_poll=\"no (cross compiling)\"])\nAC_MSG_RESULT($broken_poll)\n\ndnl *********************\ndnl *** GRegex checks ***\ndnl *********************\n\nPCRE_REQUIRED_VERSION=8.31\n\n# Check if we should use the internal or the system-supplied pcre\nAC_ARG_WITH(pcre,\n            [AS_HELP_STRING([--with-pcre=@<:@internal/system@:>@],\n                            [whether to use system PCRE [default=system]])],\n            [],\n            [with_pcre=system])\n\nAM_CONDITIONAL(USE_SYSTEM_PCRE, [test \"x$with_pcre\" = xsystem])\n\nAS_IF([ test \"x$with_pcre\" = xsystem], [\n  PKG_CHECK_MODULES(PCRE,\n                    libpcre >= $PCRE_REQUIRED_VERSION)\n  AC_CACHE_CHECK([for Unicode support in PCRE],glib_cv_pcre_has_unicode,[\n                  glib_save_CFLAGS=\"$CFLAGS\"\n                  glib_save_LIBS=\"$LIBS\"\n                  CFLAGS=\"$CFLAGS $PCRE_CFLAGS\" LIBS=\"$PCRE_LIBS\"\n                  AC_TRY_RUN([#include <pcre.h>\n                              int main () {\n                                int support;\n                                pcre_config (PCRE_CONFIG_UTF8, &support);\n                                if (!support)\n                                  return 1;\n                                pcre_config (PCRE_CONFIG_UNICODE_PROPERTIES, &support);\n                                if (!support)\n                                  return 1;\n                                return 0;\n                              }],\n                  glib_cv_pcre_has_unicode=yes,\n                  glib_cv_pcre_has_unicode=no,\n                  glib_cv_pcre_has_unicode=yes)\n                  CFLAGS=\"$glib_save_CFLAGS\"\n                  LIBS=\"$glib_save_LIBS\"\n      ])\n  if test \"$glib_cv_pcre_has_unicode\" = \"no\"; then\n    AC_MSG_ERROR([*** The system-supplied PCRE does not support Unicode properties or UTF-8.])\n  fi\n  AC_SUBST(PCRE_CFLAGS)\n  AC_SUBST(PCRE_LIBS)\n  AC_DEFINE(USE_SYSTEM_PCRE, [], [using the system-supplied PCRE library])\n  PCRE_REQUIRES=libpcre\n  AC_SUBST(PCRE_REQUIRES)\n], [\n  # If using gcc 4 pass -Wno-pointer-sign when compiling the internal PCRE\n  AS_IF([ test x\"$GCC\" = xyes], [\n    AC_MSG_CHECKING([whether compiler understands -Wno-pointer-sign])\n    save_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$CFLAGS -Wno-pointer-sign\"\n    AC_TRY_COMPILE([],[],[PCRE_WARN_CFLAGS=\"$PCRE_WARN_CFLAGS -Wno-pointer-sign\"\n                          AC_MSG_RESULT(yes)],[AC_MSG_RESULT(no)])\n    CFLAGS=\"$save_CFLAGS\"\n  ])\n])\nAC_SUBST(PCRE_WARN_CFLAGS)\n\ndnl **********************\ndnl *** Win32 API libs ***\ndnl **********************\n\ncase $host in\n  *-*-cygwin*)\n\tG_LIBS_EXTRA=\"-luser32 -lkernel32\"\n    ;;\n  *-*-mingw*)\n\tG_LIBS_EXTRA=\"-lws2_32 -lole32 -lwinmm -lshlwapi\"\n    ;;\n  *)\n\tG_LIBS_EXTRA=\"\"\n    ;;\nesac\nAC_SUBST(G_LIBS_EXTRA)\n\ndnl If the system doesn't define EILSEQ, we should define EILSEQ ourselves\ndnl since we need it for g_iconv()\n\nAC_MSG_CHECKING([for EILSEQ])\nAC_TRY_COMPILE([\n#include <errno.h>\n],\n[\nint error = EILSEQ;\n], have_eilseq=yes, have_eilseq=no);\nAC_MSG_RESULT($have_eilseq)\n\ndnl Add a conditional we can use when cross-compiling, so we avoid running\ndnl binaries\nAM_CONDITIONAL(CROSS_COMPILING, test $cross_compiling = yes)\n\ndnl **************************\ndnl *** Checks for gtk-doc ***\ndnl **************************\n# gtkdocize greps for ^GTK_DOC_CHECK and parses it, so you need to have\n# it on it's own line.\nm4_ifdef([GTK_DOC_CHECK], [\nGTK_DOC_CHECK([1.20], [--flavour no-tmpl])\n],[\nAM_CONDITIONAL([ENABLE_GTK_DOC],[false])\n])\n\nAC_ARG_ENABLE(man,\n              [AS_HELP_STRING([--enable-man],\n                              [generate man pages [default=auto]])],,\n              enable_man=maybe)\n\nAS_IF([test \"$enable_man\" != no], [\n  AC_PATH_PROG([XSLTPROC], [xsltproc])\n  AS_IF([test -z \"$XSLTPROC\"], [\n    AS_IF([test \"$enable_man\" = yes], [\n      AC_MSG_ERROR([xsltproc is required for --enable-man])\n    ])\n    enable_man=no\n  ])\n])\n\nAS_IF([ test \"$enable_man\" != no ], [\n  dnl check for DocBook DTD in the local catalog\n  JH_CHECK_XML_CATALOG([-//OASIS//DTD DocBook XML V4.1.2//EN],\n     [DocBook XML DTD V4.1.2], [have_docbook_dtd=yes], [have_docbook_dtd=no])\n  AS_IF([test \"$have_docbook_dtd\" != yes], [\n    AS_IF([test \"$enable_man\" = yes ], [\n      AC_MSG_ERROR([DocBook DTD is required for --enable-man])\n    ])\n    enable_man=no\n  ])\n])\n\nAS_IF([test \"$enable_man\" != no], [\n  dnl check for DocBook XSL stylesheets in the local catalog\n  JH_CHECK_XML_CATALOG([http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl],\n     [DocBook XSL Stylesheets], [have_docbook_style=yes],[have_docbook_style=no])\n  AS_IF([ test \"$have_docbook_style\" != yes ], [\n    AS_IF([ test \"$enable_man\" = yes ], [\n      AC_MSG_ERROR([DocBook XSL Stylesheets are required for --enable-man])\n    ])\n    enable_man=no\n  ])\n])\n\nAM_CONDITIONAL(ENABLE_MAN, test \"$enable_man\" != no)\n\nAC_MSG_CHECKING([whether to generate man pages])\nAS_IF([ test \"$enable_man\" != no ], [\n  AC_MSG_RESULT([yes])\n], [\n  AC_MSG_RESULT([no])\n])\n\ndnl\ndnl Tracing\ndnl\n\nAC_ARG_ENABLE([dtrace],\n             [AS_HELP_STRING([--enable-dtrace],\n                              [include tracing support for dtrace])])\nhave_dtrace=no\nAC_MSG_CHECKING([whether to include dtrace tracing support])\nAS_IF([ test \"x$enable_dtrace\" != xno], [\n  if test x$glib_have_carbon = xyes; then\n    AC_MSG_RESULT([no (not yet compatible with MacOS dtrace)])\n  else \n    AC_MSG_RESULT([yes])\n    AC_CHECK_PROGS(DTRACE, dtrace)\n    if test -z \"$DTRACE\"; then\n      if test \"x$enable_dtrace\" = xyes; then\n        AC_MSG_ERROR([dtrace not found])\n      fi\n    else\n      AC_CHECK_HEADER([sys/sdt.h],have_dtrace=yes,\n                      [if test \"x$enable_dtrace\" = xyes; then\n                        AC_MSG_ERROR([dtrace support needs sys/sdt.h header])\n                       fi])\n    fi\n  fi\n], [\n  AC_MSG_RESULT([no])\n])\nif test \"x$have_dtrace\" = xyes; then\n  AC_DEFINE([HAVE_DTRACE], [1], [Define to 1 if using dtrace probes.])\nfi\nAM_CONDITIONAL([ENABLE_DTRACE], [test x$have_dtrace = xyes ])\n\nAC_MSG_CHECKING([whether to include systemtap tracing support])\nAC_ARG_ENABLE([systemtap],\n             [AS_HELP_STRING([--enable-systemtap],\n                              [include tracing support for systemtap])])\nhave_systemtap=no\nif test \"x$enable_systemtap\" != xno -a \"x$have_dtrace\" = xyes; then\n  have_systemtap=yes\nfi\nAC_MSG_RESULT(${have_systemtap})\n\nAM_CONDITIONAL([ENABLE_SYSTEMTAP], [test x$have_systemtap = xyes])\n\nAC_ARG_WITH([tapset-install-dir],\n            AS_HELP_STRING([--with-tapset-install-dir=DIR],\n                            [path where systemtap tapsets are installed [DATADIR/systemtap/tapset/HOST_CPU]]),\n            [if test \"x${withval}\" = x; then\n\t       ABS_TAPSET_DIR=\"\\$(datadir)/systemtap/tapset/${host_cpu}\"\n\t     else\n\t       ABS_TAPSET_DIR=\"${withval}\"\n\t      fi],\n\t    [ABS_TAPSET_DIR=\"\\$(datadir)/systemtap/tapset/${host_cpu}\"])\nAC_SUBST(ABS_TAPSET_DIR)\n\ndnl ************************************\ndnl *** Enable lcov coverage reports ***\ndnl ************************************\n\nAC_ARG_ENABLE(coverage,\n  AS_HELP_STRING([--enable-coverage],\n\t\t [enable coverage testing with gcov]),\n  [use_gcov=$enableval], [use_gcov=no])\n\nAS_IF([ test \"x$use_gcov\" = \"xyes\"], [\n  dnl we need gcc:\n  if test \"$GCC\" != \"yes\"; then\n    AC_MSG_ERROR([GCC is required for --enable-coverage])\n  fi\n\n  dnl Check if ccache is being used\n  AC_CHECK_PROG(SHTOOL, shtool, shtool)\n  case `$SHTOOL path $CC` in\n    *ccache*[)] gcc_ccache=yes;;\n    *[)] gcc_ccache=no;;\n  esac\n\n  if test \"$gcc_ccache\" = \"yes\" && (test -z \"$CCACHE_DISABLE\" || test \"$CCACHE_DISABLE\" != \"1\"); then\n    AC_MSG_ERROR([ccache must be disabled when --enable-coverage option is used. You can disable ccache by setting environment variable CCACHE_DISABLE=1.])\n  fi\n\n  ltp_version_list=\"1.6 1.7 1.8 1.9 1.10 1.12\"\n  AC_CHECK_PROG(LTP, lcov, lcov)\n  AC_CHECK_PROG(LTP_GENHTML, genhtml, genhtml)\n\n  AS_IF([ test \"$LTP\" ], [\n    AC_CACHE_CHECK([for ltp version], glib_cv_ltp_version, [\n      glib_cv_ltp_version=invalid\n      ltp_version=`$LTP -v 2>/dev/null | $SED -e 's/^.* //'`\n      for ltp_check_version in $ltp_version_list; do\n        if test \"$ltp_version\" = \"$ltp_check_version\"; then\n          glib_cv_ltp_version=\"$ltp_check_version (ok)\"\n        fi\n      done\n    ])\n  ], [\n    ltp_msg=\"To enable code coverage reporting you must have one of the following LTP versions installed: $ltp_version_list\"\n    AC_MSG_ERROR([$ltp_msg])\n  ])\n\n  case $glib_cv_ltp_version in\n    \"\"|invalid[)]\n      ltp_msg=\"You must have one of the following versions of LTP: $ltp_version_list (found: $ltp_version).\"\n      AC_MSG_ERROR([$ltp_msg])\n      LTP=\"exit 0;\"\n      ;;\n  esac\n\n  if test -z \"$LTP_GENHTML\"; then\n    AC_MSG_ERROR([Could not find genhtml from the LTP package])\n  fi\n\n  dnl Remove all optimization flags from CFLAGS\n  changequote({,})\n  CFLAGS=`echo \"$CFLAGS\" | $SED -e 's/-O[0-9]*//g'`\n  changequote([,])\n\n  dnl Add the special gcc flags\n  CFLAGS=\"$CFLAGS -O0 -fprofile-arcs -ftest-coverage\"\n  LDFLAGS=\"$LDFLAGS -lgcov\"\n])\n\ndnl *******************************\ndnl *** Disable strict aliasing ***\ndnl *******************************\ndnl See https://bugzilla.gnome.org/show_bug.cgi?id=791622\nAS_IF([test \"${GCC}\" = \"yes\"],[\n  CFLAGS=\"$CFLAGS -fno-strict-aliasing\"\n])\n\ndnl ******************************\ndnl *** output the whole stuff ***\ndnl ******************************\n\ndnl this section will only be run if config.status is invoked with no\ndnl arguments, or with \"glib/glibconfig.h\" as an argument.\nAC_CONFIG_COMMANDS([glib/glibconfig.h],\n[\n\toutfile=glib/glibconfig.h-tmp\n\tcat > $outfile <<\\_______EOF\n/* glibconfig.h\n *\n * This is a generated file.  Please modify 'configure.ac'\n */\n\n#ifndef __GLIBCONFIG_H__\n#define __GLIBCONFIG_H__\n\n#include <glib/gmacros.h>\n\n_______EOF\n\n\techo '#include <limits.h>' >> $outfile\n\techo '#include <float.h>' >> $outfile\n\tif test x$glib_values_h = xyes; then\n\t  echo '#include <values.h>' >> $outfile\n\tfi\n\tif test \"$glib_header_alloca_h\" = \"yes\"; then\n\t  echo '#define GLIB_HAVE_ALLOCA_H' >> $outfile\n\tfi\n\tif test x$glib_included_printf != xyes; then\n          echo \"\n/* Specifies that GLib's g_print*() functions wrap the\n * system printf functions.  This is useful to know, for example,\n * when using glibc's register_printf_function().\n */\" >> $outfile\n\t  echo '#define GLIB_USING_SYSTEM_PRINTF' >> $outfile\n\tfi\n\n\tcat >> $outfile <<_______EOF\n\nG_BEGIN_DECLS\n\n#define G_MINFLOAT\tFLT_MIN\n#define G_MAXFLOAT\tFLT_MAX\n#define G_MINDOUBLE\tDBL_MIN\n#define G_MAXDOUBLE\tDBL_MAX\n#define G_MINSHORT\tSHRT_MIN\n#define G_MAXSHORT\tSHRT_MAX\n#define G_MAXUSHORT\tUSHRT_MAX\n#define G_MININT\tINT_MIN\n#define G_MAXINT\tINT_MAX\n#define G_MAXUINT\tUINT_MAX\n#define G_MINLONG\tLONG_MIN\n#define G_MAXLONG\tLONG_MAX\n#define G_MAXULONG\tULONG_MAX\n\n_______EOF\n\n\n\t### this should always be true in a modern C/C++ compiler\n\t### and is statically asserted by glib-init.c\n\tcat >>$outfile <<_______EOF\ntypedef signed char gint8;\ntypedef unsigned char guint8;\n_______EOF\n\n\n\tif test -n \"$gint16\"; then\n\t  cat >>$outfile <<_______EOF\ntypedef signed $gint16 gint16;\ntypedef unsigned $gint16 guint16;\n#define G_GINT16_MODIFIER $gint16_modifier\n#define G_GINT16_FORMAT $gint16_format\n#define G_GUINT16_FORMAT $guint16_format\n_______EOF\n\tfi\n\n\n\tif test -n \"$gint32\"; then\n\t  cat >>$outfile <<_______EOF\ntypedef signed $gint32 gint32;\ntypedef unsigned $gint32 guint32;\n#define G_GINT32_MODIFIER $gint32_modifier\n#define G_GINT32_FORMAT $gint32_format\n#define G_GUINT32_FORMAT $guint32_format\n_______EOF\n\tfi\n\n\tcat >>$outfile <<_______EOF\n#define G_HAVE_GINT64 1          /* deprecated, always true */\n\n${glib_extension}typedef signed $gint64 gint64;\n${glib_extension}typedef unsigned $gint64 guint64;\n\n#define G_GINT64_CONSTANT(val)\t$gint64_constant\n#define G_GUINT64_CONSTANT(val)\t$guint64_constant\n_______EOF\n\n\tif test x$gint64_format != x ; then\n\t  cat >>$outfile <<_______EOF\n#define G_GINT64_MODIFIER $gint64_modifier\n#define G_GINT64_FORMAT $gint64_format\n#define G_GUINT64_FORMAT $guint64_format\n_______EOF\n        else\n\t  cat >>$outfile <<_______EOF\n#undef G_GINT64_MODIFIER\n#undef G_GINT64_FORMAT\n#undef G_GUINT64_FORMAT\n_______EOF\n        fi           \n\n        cat >>$outfile <<_______EOF\n\n#define GLIB_SIZEOF_VOID_P $glib_void_p\n#define GLIB_SIZEOF_LONG   $glib_long\n#define GLIB_SIZEOF_SIZE_T $glib_size_t\n#define GLIB_SIZEOF_SSIZE_T $glib_ssize_t\n\n_______EOF\n\n        cat >>$outfile <<_______EOF\ntypedef signed $glib_ssize_type_define gssize;\ntypedef unsigned $glib_size_type_define gsize;\n#define G_GSIZE_MODIFIER $gsize_modifier\n#define G_GSSIZE_MODIFIER $gssize_modifier\n#define G_GSIZE_FORMAT $gsize_format\n#define G_GSSIZE_FORMAT $gssize_format\n\n#define G_MAXSIZE\tG_MAXU$glib_msize_type\n#define G_MINSSIZE\tG_MIN$glib_mssize_type\n#define G_MAXSSIZE\tG_MAX$glib_mssize_type\n\ntypedef gint64 goffset;\n#define G_MINOFFSET\tG_MININT64\n#define G_MAXOFFSET\tG_MAXINT64\n\n#define G_GOFFSET_MODIFIER      G_GINT64_MODIFIER\n#define G_GOFFSET_FORMAT        G_GINT64_FORMAT\n#define G_GOFFSET_CONSTANT(val) G_GINT64_CONSTANT(val)\n\n#define G_POLLFD_FORMAT $g_pollfd_format\n\n_______EOF\n\n\tif test -z \"$glib_unknown_void_p\"; then\n\t  cat >>$outfile <<_______EOF\n\n#define GPOINTER_TO_INT(p)\t((gint)  ${glib_gpi_cast} (p))\n#define GPOINTER_TO_UINT(p)\t((guint) ${glib_gpui_cast} (p))\n\n#define GINT_TO_POINTER(i)\t((gpointer) ${glib_gpi_cast} (i))\n#define GUINT_TO_POINTER(u)\t((gpointer) ${glib_gpui_cast} (u))\n\ntypedef signed $glib_intptr_type_define gintptr;\ntypedef unsigned $glib_intptr_type_define guintptr;\n\n#define G_GINTPTR_MODIFIER      $gintptr_modifier\n#define G_GINTPTR_FORMAT        $gintptr_format\n#define G_GUINTPTR_FORMAT       $guintptr_format\n_______EOF\n\telse\n\t  echo '#error SIZEOF_VOID_P unknown - This should never happen' >>$outfile\n\tfi\n\n\n\n\tcat >>$outfile <<_______EOF\n#ifndef G_DISABLE_DEPRECATED\n#define g_ATEXIT(proc)\t(atexit (proc))\n#define g_memmove(dest,src,len) G_STMT_START { memmove ((dest), (src), (len)); } G_STMT_END\n#endif\n$glib_defines\n$glib_os\n$glib_static_compilation\n\n$glib_vacopy\n\n_______EOF\n\n\tif test x$g_have_iso_c_varargs = xyes ; then\n\t\tcat >>$outfile <<_______EOF\n#ifndef __cplusplus\n# define G_HAVE_ISO_VARARGS 1\n#endif\n_______EOF\n\tfi\n\tif test x$g_have_iso_cxx_varargs = xyes ; then\n\t\tcat >>$outfile <<_______EOF\n#ifdef __cplusplus\n# define G_HAVE_ISO_VARARGS 1\n#endif\n_______EOF\n\tfi\n\tif test x$g_have_gnuc_varargs = xyes ; then\n\t\tcat >>$outfile <<_______EOF\n\n/* gcc-2.95.x supports both gnu style and ISO varargs, but if -ansi\n * is passed ISO vararg support is turned off, and there is no work\n * around to turn it on, so we unconditionally turn it off.\n */\n#if __GNUC__ == 2 && __GNUC_MINOR__ == 95\n#  undef G_HAVE_ISO_VARARGS\n#endif\n\n#define G_HAVE_GNUC_VARARGS 1\n_______EOF\n\tfi\n\n\tcase x$g_stack_grows in\n\txyes) echo \"#define G_HAVE_GROWING_STACK 1\" >>$outfile ;;\n\t*)    echo \"#define G_HAVE_GROWING_STACK 0\" >>$outfile ;;\n\tesac\n\n\n\techo >>$outfile\n\tif test x$g_have_eilseq = xno; then\n\t\tcat >>$outfile <<_______EOF\n#ifndef EILSEQ\n/* On some pre-C99 systems, EILSEQ is not defined.\n * The correspondence between this and the corresponding definition\n * in libiconv is essential.\n */\n#  define EILSEQ ENOENT\n#endif\n_______EOF\n\n\tfi\n\n\tif test x$g_have_gnuc_visibility = xyes; then\n\t\tcat >>$outfile <<_______EOF\n#define G_HAVE_GNUC_VISIBILITY 1\n_______EOF\n\tfi\n\t\tcat >>$outfile <<_______EOF\n#if defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590)\n#define G_GNUC_INTERNAL __attribute__((visibility(\"hidden\")))\n#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)\n#define G_GNUC_INTERNAL __hidden\n#elif defined (__GNUC__) && defined (G_HAVE_GNUC_VISIBILITY)\n#define G_GNUC_INTERNAL __attribute__((visibility(\"hidden\")))\n#else\n#define G_GNUC_INTERNAL\n#endif \n_______EOF\n\n\techo >>$outfile\n\tcat >>$outfile <<_______EOF\n#define G_THREADS_ENABLED\n#define G_THREADS_IMPL_$g_threads_impl_def\n_______EOF\n\n\tif test x\"$g_memory_barrier_needed\" != xno; then\n\t  echo >>$outfile\n\t  echo \"#define G_ATOMIC_OP_MEMORY_BARRIER_NEEDED 1\" >>$outfile\n\tfi\n\tif test x\"$g_atomic_lock_free\" = xyes; then\n          echo >>$outfile\n          echo \"#define G_ATOMIC_LOCK_FREE\" >>$outfile\n        fi\n\techo >>$outfile\n\tg_bit_sizes=\"16 32 64\"\n\tfor bits in $g_bit_sizes; do\n\t  cat >>$outfile <<_______EOF\n#define GINT${bits}_TO_${g_bs_native}(val)\t((gint${bits}) (val))\n#define GUINT${bits}_TO_${g_bs_native}(val)\t((guint${bits}) (val))\n#define GINT${bits}_TO_${g_bs_alien}(val)\t((gint${bits}) GUINT${bits}_SWAP_LE_BE (val))\n#define GUINT${bits}_TO_${g_bs_alien}(val)\t(GUINT${bits}_SWAP_LE_BE (val))\n_______EOF\n\tdone\n\n\tcat >>$outfile <<_______EOF\n#define GLONG_TO_LE(val)\t((glong) GINT${glongbits}_TO_LE (val))\n#define GULONG_TO_LE(val)\t((gulong) GUINT${glongbits}_TO_LE (val))\n#define GLONG_TO_BE(val)\t((glong) GINT${glongbits}_TO_BE (val))\n#define GULONG_TO_BE(val)\t((gulong) GUINT${glongbits}_TO_BE (val))\n#define GINT_TO_LE(val)\t\t((gint) GINT${gintbits}_TO_LE (val))\n#define GUINT_TO_LE(val)\t((guint) GUINT${gintbits}_TO_LE (val))\n#define GINT_TO_BE(val)\t\t((gint) GINT${gintbits}_TO_BE (val))\n#define GUINT_TO_BE(val)\t((guint) GUINT${gintbits}_TO_BE (val))\n#define GSIZE_TO_LE(val)\t((gsize) GUINT${gsizebits}_TO_LE (val))\n#define GSSIZE_TO_LE(val)\t((gssize) GINT${gssizebits}_TO_LE (val))\n#define GSIZE_TO_BE(val)\t((gsize) GUINT${gsizebits}_TO_BE (val))\n#define GSSIZE_TO_BE(val)\t((gssize) GINT${gssizebits}_TO_BE (val))\n#define G_BYTE_ORDER $g_byte_order\n\n#define GLIB_SYSDEF_POLLIN =$g_pollin\n#define GLIB_SYSDEF_POLLOUT =$g_pollout\n#define GLIB_SYSDEF_POLLPRI =$g_pollpri\n#define GLIB_SYSDEF_POLLHUP =$g_pollhup\n#define GLIB_SYSDEF_POLLERR =$g_pollerr\n#define GLIB_SYSDEF_POLLNVAL =$g_pollnval\n\n#define G_MODULE_SUFFIX \"$g_module_suffix\"\n\ntypedef $g_pid_type GPid;\n#define G_PID_FORMAT $g_pid_format\n\n#define GLIB_SYSDEF_AF_UNIX $g_af_unix\n#define GLIB_SYSDEF_AF_INET $g_af_inet\n#define GLIB_SYSDEF_AF_INET6 $g_af_inet6\n\n#define GLIB_SYSDEF_MSG_OOB $g_msg_oob\n#define GLIB_SYSDEF_MSG_PEEK $g_msg_peek\n#define GLIB_SYSDEF_MSG_DONTROUTE $g_msg_dontroute\n\n#define G_DIR_SEPARATOR '$g_dir_separator'\n#define G_DIR_SEPARATOR_S \"$g_dir_separator\"\n#define G_SEARCHPATH_SEPARATOR '$g_searchpath_separator'\n#define G_SEARCHPATH_SEPARATOR_S \"$g_searchpath_separator\"\n\nG_END_DECLS\n\n#endif /* __GLIBCONFIG_H__ */\n_______EOF\n\n\n\tif cmp -s $outfile glib/glibconfig.h; then\n\t  AC_MSG_NOTICE([glib/glibconfig.h is unchanged])\n\t  rm -f $outfile\n\telse\n\t  mv $outfile glib/glibconfig.h\n\tfi\n],[\n\n# Note that if two cases are the same, case goes with the first one.\n# Note also that this is inside an AC_OUTPUT_COMMAND.  We do not depend\n# on variable expansion in case labels.  Look at the generated config.status\n# for a hint.\n\nif test x$ac_cv_header_alloca_h = xyes ; then\n  glib_header_alloca_h=yes\nfi\n\nif test x$enable_included_printf = xyes ; then\n  glib_included_printf=yes\nfi\n\ncase 2 in\n$ac_cv_sizeof_short)\t\t\n  gint16=short\n  gint16_modifier='\"h\"'\n  gint16_format='\"hi\"'\n  guint16_format='\"hu\"'\n  ;;\n$ac_cv_sizeof_int)\t\t\n  gint16=int\n  gint16_modifier='\"\"'\n  gint16_format='\"i\"'\n  guint16_format='\"u\"'\n  ;;\nesac\ncase 4 in\n$ac_cv_sizeof_short)\t\t\n  gint32=short\n  gint32_modifier='\"h\"'\n  gint32_format='\"hi\"'\n  guint32_format='\"hu\"'\n  ;;\n$ac_cv_sizeof_int)\t\t\n  gint32=int\n  gint32_modifier='\"\"'\n  gint32_format='\"i\"'\n  guint32_format='\"u\"'\n  ;;\n$ac_cv_sizeof_long)\t\t\n  gint32=long\n  gint32_modifier='\"l\"'\n  gint32_format='\"li\"'\n  guint32_format='\"lu\"'\n  ;;\nesac\ncase 8 in\n$ac_cv_sizeof_int)\n  gint64=int\n  gint64_modifier='\"\"'\n  gint64_format='\"i\"'\n  guint64_format='\"u\"'\n  glib_extension=\n  gint64_constant='(val)'\n  guint64_constant='(val)'\n  ;;\n$ac_cv_sizeof_long)\n  if test \"x$glib_cv_int64_t\" = \"xlong_long\"; then\n    gint64='long long'\n    if test -n \"$glib_cv_long_long_format\"; then\n      gint64_modifier='\"'$glib_cv_long_long_format'\"'\n      gint64_format='\"'$glib_cv_long_long_format'i\"'\n      guint64_format='\"'$glib_cv_long_long_format'u\"'\n    fi\n    glib_extension='G_GNUC_EXTENSION '\n    gint64_constant='(G_GNUC_EXTENSION (val##LL))'\n    guint64_constant='(G_GNUC_EXTENSION (val##ULL))'\n  else\n    gint64=long\n    gint64_modifier='\"l\"'\n    gint64_format='\"li\"'\n    guint64_format='\"lu\"'\n    glib_extension=\n    gint64_constant='(val##L)'\n    guint64_constant='(val##UL)'\n  fi\n  ;;\n$ac_cv_sizeof_long_long)\n  gint64='long long'\n  if test -n \"$glib_cv_long_long_format\"; then\n    gint64_modifier='\"'$glib_cv_long_long_format'\"'\n    gint64_format='\"'$glib_cv_long_long_format'i\"'\n    guint64_format='\"'$glib_cv_long_long_format'u\"'\n  fi\n  glib_extension='G_GNUC_EXTENSION '\n  gint64_constant='(G_GNUC_EXTENSION (val##LL))'\n  guint64_constant='(G_GNUC_EXTENSION (val##ULL))'\n  ;;\nesac\nglib_size_t=$ac_cv_sizeof_size_t\nglib_ssize_t=$ac_cv_sizeof_ssize_t\nglib_size_type_define=\"$glib_size_type\"\nglib_ssize_type_define=\"$glib_ssize_type\"\nglib_void_p=$ac_cv_sizeof_void_p\nglib_long=$ac_cv_sizeof_long\n\ncase \"$glib_size_type\" in\nshort)\n  gsize_modifier='\"h\"'\n  gsize_format='\"hu\"'\n  glib_msize_type='SHRT'\n  ;;\nint)\n  gsize_modifier='\"\"'\n  gsize_format='\"u\"'\n  glib_msize_type='INT'\n  ;;\nlong)\n  gsize_modifier='\"l\"'\n  gsize_format='\"lu\"'\n  glib_msize_type='LONG'\n  ;;\n\"long long\")\n  gsize_modifier='\"ll\"'\n  gsize_format='\"llu\"'\n  glib_msize_type='INT64'\n  ;;\nesac\n\ncase \"$glib_ssize_type\" in\nshort)\n  gssize_modifier='\"h\"'\n  gssize_format='\"hi\"'\n  glib_mssize_type='SHRT'\n  ;;\nint)\n  gssize_modifier='\"\"'\n  gssize_format='\"i\"'\n  glib_mssize_type='INT'\n  ;;\nlong)\n  gssize_modifier='\"l\"'\n  gssize_format='\"li\"'\n  glib_mssize_type='LONG'\n  ;;\n\"long long\")\n  gssize_modifier='\"ll\"'\n  gssize_format='\"lli\"'\n  glib_mssize_type='INT64'\n  ;;\nesac\n\ngintbits=`expr $ac_cv_sizeof_int \\* 8`\nglongbits=`expr $ac_cv_sizeof_long \\* 8`\ngsizebits=`expr $ac_cv_sizeof_size_t \\* 8`\ngssizebits=`expr $ac_cv_sizeof_ssize_t \\* 8`\n\ncase $ac_cv_sizeof_void_p in\n$ac_cv_sizeof_int)\n  glib_intptr_type_define=int\n  gintptr_modifier='\"\"'\n  gintptr_format='\"i\"'\n  guintptr_format='\"u\"'\n  glib_gpi_cast='(gint)'\n  glib_gpui_cast='(guint)'\n  ;;\n$ac_cv_sizeof_long)\n  glib_intptr_type_define=long\n  gintptr_modifier='\"l\"'\n  gintptr_format='\"li\"'\n  guintptr_format='\"lu\"'\n  glib_gpi_cast='(glong)'\n  glib_gpui_cast='(gulong)'\n  ;;\n$ac_cv_sizeof_long_long)\n  glib_intptr_type_define='long long'\n  gintptr_modifier='\"ll\"'\n  gintptr_format='\"lli\"'\n  guintptr_format='\"llu\"'\n  glib_gpi_cast='(gint64)'\n  glib_gpui_cast='(guint64)'\n  ;;\n*)\n  glib_unknown_void_p=yes\n  ;;\nesac\n\n\nglib_defines=\"\n#define GLIB_MAJOR_VERSION $GLIB_MAJOR_VERSION\n#define GLIB_MINOR_VERSION $GLIB_MINOR_VERSION\n#define GLIB_MICRO_VERSION $GLIB_MICRO_VERSION\n\"\n\ncase xyes in\nx$glib_cv_va_copy)\tglib_vacopy='#define G_VA_COPY\tva_copy' ;;\nx$glib_cv___va_copy)\tglib_vacopy='#define G_VA_COPY\t__va_copy' ;;\n*)\t\t\tglib_vacopy=''\nesac\n\nif test x$glib_cv_va_val_copy = xno; then\n  glib_vacopy=\"\\$glib_vacopy\n#define G_VA_COPY_AS_ARRAY 1\"\nfi\n\ng_have_gnuc_varargs=$g_have_gnuc_varargs\ng_have_iso_c_varargs=$g_have_iso_c_varargs\ng_have_iso_cxx_varargs=$g_have_iso_cxx_varargs\n\ng_have_gnuc_visibility=$g_have_gnuc_visibility\ng_have_sunstudio_visibility=$g_have_sunstudio_visibility\n\nif test x$ac_cv_c_bigendian = xyes; then\n  g_byte_order=G_BIG_ENDIAN\n  g_bs_native=BE\n  g_bs_alien=LE\nelse\n  g_byte_order=G_LITTLE_ENDIAN\n  g_bs_native=LE\n  g_bs_alien=BE\nfi\n\ng_pollin=$glib_cv_value_POLLIN\ng_pollout=$glib_cv_value_POLLOUT\ng_pollpri=$glib_cv_value_POLLPRI\ng_pollhup=$glib_cv_value_POLLHUP\ng_pollerr=$glib_cv_value_POLLERR\ng_pollnval=$glib_cv_value_POLLNVAL\n\n# If a family is not found on the system, define that family to\n# a negative value, picking a different one for each undefined\n# family (-1 for AF_UNIX, -2 for the next one, -3 ...)\n# This is needed because glib-mkenums doesn't handle optional\n# values in enums, and thus we have to have all existing values\n# defined in the enum.\nif test \"x$glib_cv_value_AF_UNIX\" != \"x\"; then\n  g_af_unix=$glib_cv_value_AF_UNIX\nelse\n  g_af_unix=-1\nfi\ng_af_inet=$glib_cv_value_AF_INET\ng_af_inet6=$glib_cv_value_AF_INET6\n\ng_msg_peek=$glib_cv_value_MSG_PEEK\ng_msg_oob=$glib_cv_value_MSG_OOB\ng_msg_dontroute=$glib_cv_value_MSG_DONTROUTE\n\ng_stack_grows=$glib_cv_stack_grows\n\ng_have_eilseq=$have_eilseq\n\ng_threads_impl_def=$g_threads_impl\n\ng_atomic_lock_free=\"$glib_cv_g_atomic_lock_free\"\ng_memory_barrier_needed=\"$glib_memory_barrier_needed\"\ng_gcc_atomic_ops=\"$glib_cv_gcc_has_builtin_atomic_operations\"\n\ng_module_suffix=\"$glib_gmodule_suffix\"\ng_dir_separator=\"$glib_dir_separator\"\ng_searchpath_separator=\"$glib_searchpath_separator\"\n\ng_pid_type=\"$glib_pid_type\"\ng_pid_format=\"\\\"$glib_pid_format\\\"\"\ng_pollfd_format=\"\\\"$glib_pollfd_format\\\"\"\n\ncase $host in\n  *-*-cygwin*)\n    glib_os=\"#define G_OS_UNIX\n#define G_PLATFORM_WIN32\n#define G_WITH_CYGWIN\"\n    ;;\n  *-*-mingw*)\n    glib_os=\"#define G_OS_WIN32\n#define G_PLATFORM_WIN32\"\n    ;;\n  *)\n    glib_os=\"#define G_OS_UNIX\"\n    ;;\nesac\nglib_static_compilation=\"\"\nif test x$glib_win32_static_compilation = xyes; then\n  glib_static_compilation=\"#define GLIB_STATIC_COMPILATION 1\n#define GOBJECT_STATIC_COMPILATION 1\"\nfi\n])\n\n# Redo enough to get guint32 and guint64 for the alignment checks below\ncase 4 in\n$ac_cv_sizeof_short)\n  gint32=short\n  ;;\n$ac_cv_sizeof_int)\n  gint32=int\n  ;;\n$ac_cv_sizeof_long)\n  gint32=long\n  ;;\nesac\ncase 8 in\n$ac_cv_sizeof_int)\n  gint64=int\n  ;;\n$ac_cv_sizeof_long)\n  gint64=long\n  ;;\n$ac_cv_sizeof_long_long)\n  gint64='long long'\n  ;;\nesac\n\nAC_CHECK_TYPE([guint32],,,[typedef unsigned $gint32 guint32;])\nAC_CHECK_ALIGNOF([guint32], [AC_INCLUDES_DEFAULT\ntypedef unsigned $gint32 guint32;])\nAC_CHECK_TYPE([guint64],,,[typedef unsigned $gint64 guint64;])\nAC_CHECK_ALIGNOF([guint64], [AC_INCLUDES_DEFAULT\ntypedef unsigned $gint64 guint64;])\nAC_CHECK_TYPE([unsigned long])\nAC_CHECK_ALIGNOF([unsigned long])\n\n# Check for libdbus1 - Optional - is only used in the GDBus test cases\n#\n# 1.2.14 required for dbus_message_set_serial\nPKG_CHECK_MODULES(DBUS1,\n     dbus-1 >= 1.2.14,\n     [AC_DEFINE(HAVE_DBUS1, 1, [Define if dbus-1 is available]) have_dbus1=yes],\n     have_dbus1=no)\nAC_SUBST(DBUS1_CFLAGS)\nAC_SUBST(DBUS1_LIBS)\nAM_CONDITIONAL(HAVE_DBUS1, [test \"x$have_dbus1\" = \"xyes\"])\n\nAC_CHECK_PROGS([DBUS_DAEMON], [dbus-daemon])\nAM_CONDITIONAL([HAVE_DBUS_DAEMON], [test x$DBUS_DAEMON = xdbus-daemon ])\n\n# Check whether MSVC toolset is explicitly set\nAM_CONDITIONAL(MSVC_BASE_NO_TOOLSET_SET, [test x$MSVC_BASE_TOOLSET = x])\nAM_CONDITIONAL(MSVC_NO_TOOLSET_SET, [test x$MSVC_TOOLSET = x])\n\ndnl\ndnl Check for -Bsymbolic-functions linker flag used to avoid\ndnl intra-library PLT jumps, if available.\ndnl\n\nAC_ARG_ENABLE(Bsymbolic,\n              [AS_HELP_STRING([--disable-Bsymbolic],\n                              [avoid linking with -Bsymbolic])],,\n              [SAVED_LDFLAGS=\"${LDFLAGS}\" SAVED_LIBS=\"${LIBS}\"\n               AC_MSG_CHECKING([for -Bsymbolic-functions linker flag])\n               LDFLAGS=-Wl,-Bsymbolic-functions\n               LIBS=\n               AC_TRY_LINK([], [return 0],\n                           AC_MSG_RESULT(yes)\n                           enable_Bsymbolic=yes,\n                           AC_MSG_RESULT(no)\n                           enable_Bsymbolic=no)\n               LDFLAGS=\"${SAVED_LDFLAGS}\" LIBS=\"${SAVED_LIBS}\"])\n\nif test \"x${enable_Bsymbolic}\" = \"xyes\"; then\n  GLIB_LINK_FLAGS=-Wl,-Bsymbolic-functions\nfi\n\ndnl\ndnl Check for -z,nodelete linker flag: the type system assumes that\ndnl libgobject stays loaded for the lifetime of the process.\ndnl Since ld.bfd does not treat wrong -z options as fatal by default,\ndnl we also try to check for the --fatal-warnings linker flag if\ndnl auto-detecting.\ndnl\n\nSAVED_CFLAGS=\"${CFLAGS}\" SAVED_LDFLAGS=\"${LDFLAGS}\" SAVED_LIBS=\"${LIBS}\"\nAC_MSG_CHECKING([for --fatal-warnings linker flag])\nCFLAGS=\"${SAVED_CFLAGS} ${shared_flag:- -shared}\"\nLDFLAGS=-Wl,--fatal-warnings\nLIBS=\nAC_TRY_LINK([], [return 0],\n            AC_MSG_RESULT(yes)\n            [ldflags_fatal=-Wl,--fatal-warnings],\n            AC_MSG_RESULT(no)\n            ldflags_fatal=)\n\nAC_MSG_CHECKING([for -z,nodelete linker flag])\nLDFLAGS=\"$ldflags_fatal -Wl,-z,nodelete\"\nAC_TRY_LINK([], [return 0],\n            AC_MSG_RESULT(yes)\n            enable_znodelete=yes,\n            AC_MSG_RESULT(no)\n            enable_znodelete=no)\nCFLAGS=\"${SAVED_CFLAGS}\" LDFLAGS=\"${SAVED_LDFLAGS}\" LIBS=\"${SAVED_LIBS}\"\n\nif test \"x${enable_znodelete}\" = \"xyes\"; then\n  GLIB_LINK_FLAGS=\"$GLIB_LINK_FLAGS -Wl,-z,nodelete\"\nfi\n\nAC_SUBST(GLIB_LINK_FLAGS)\n\ndnl\ndnl Check for -fvisibility=hidden to determine if we can do GNU-style\ndnl visibility attributes for symbol export control\ndnl\nGLIB_HIDDEN_VISIBILITY_CFLAGS=\"\"\ncase \"$host\" in\n  *-*-mingw*)\n    dnl on mingw32 we do -fvisibility=hidden and __declspec(dllexport)\n    AC_DEFINE([_GLIB_EXTERN], [__attribute__((visibility(\"default\"))) __declspec(dllexport) extern],\n              [defines how to decorate public symbols while building])\n    CFLAGS=\"${CFLAGS} -fvisibility=hidden\"\n    ;;\n  *)\n    dnl on other compilers, check if we can do -fvisibility=hidden\n    SAVED_CFLAGS=\"${CFLAGS}\"\n    CFLAGS=\"-fvisibility=hidden\"\n    AC_MSG_CHECKING([for -fvisibility=hidden compiler flag])\n    AC_TRY_COMPILE([], [return 0],\n                   AC_MSG_RESULT(yes)\n                   enable_fvisibility_hidden=yes,\n                   AC_MSG_RESULT(no)\n                   enable_fvisibility_hidden=no)\n    CFLAGS=\"${SAVED_CFLAGS}\"\n\n    AS_IF([test \"${enable_fvisibility_hidden}\" = \"yes\"], [\n      AC_DEFINE([_GLIB_EXTERN], [__attribute__((visibility(\"default\"))) extern],\n                [defines how to decorate public symbols while building])\n      GLIB_HIDDEN_VISIBILITY_CFLAGS=\"-fvisibility=hidden\"\n    ])\n    ;;\nesac\nAC_SUBST(GLIB_HIDDEN_VISIBILITY_CFLAGS)\n\ndnl Compiler flags; macro originates from systemd\ndnl See https://bugzilla.gnome.org/show_bug.cgi?id=608953\nAC_ARG_ENABLE(compile-warnings,\n              [AS_HELP_STRING([--disable-compile-warnings],\n                              [Don't use builtin compiler warnings])],,\n\t\t\t      enable_compile_warnings=yes)\nAS_IF([test \"x$enable_compile_warnings\" != xno], [\n  CC_CHECK_FLAGS_APPEND([GLIB_WARN_CFLAGS], [CFLAGS], [\\\n   -Wall -Wstrict-prototypes -Wduplicated-branches -Wmisleading-indentation \\\n   -Wno-bad-function-cast \\\n   -Werror=declaration-after-statement \\\n   -Werror=missing-prototypes -Werror=implicit-function-declaration \\\n   -Werror=pointer-arith -Werror=init-self \\\n   -Werror=format=2 -Werror=missing-include-dirs])\n])\nAC_SUBST(GLIB_WARN_CFLAGS)\n\n#\n# Define variables corresponding to the correct include paths to use for\n# in-tree building.\n#\n\n# for config.h:\nconfig_h_INCLUDES='-I$(top_builddir)'\nAC_SUBST(config_h_INCLUDES)\n\n# glib:\n#   config.h\n#   $(top_builddir)/glib: for glibconfig.h\n#   $(top_srcdir)/glib:   for glib.h\n#   $(top_srcdir):        for everything\nglib_INCLUDES='$(config_h_INCLUDES) -I$(top_builddir)/glib -I$(top_srcdir)/glib -I$(top_srcdir)'\nAC_SUBST(glib_INCLUDES)\n\n# gobject:\n#   same as glib\ngobject_INCLUDES='$(glib_INCLUDES)'\nAC_SUBST(gobject_INCLUDES)\n\n# gmodule:\n#   glib includes\n#   $(top_srcdir)/gmodule: for gmodule.h\ngmodule_INCLUDES='$(glib_INCLUDES) -I$(top_srcdir)/gmodule'\nAC_SUBST(gmodule_INCLUDES)\n\n# gio:\n#   same as gmodule\ngio_INCLUDES='$(gmodule_INCLUDES)'\nAC_SUBST(gio_INCLUDES)\n\n\nAC_CONFIG_FILES([\nglib-2.0.pc\ngmodule-2.0.pc\ngmodule-export-2.0.pc\ngmodule-no-export-2.0.pc\ngthread-2.0.pc\ngobject-2.0.pc\ngio-2.0.pc\ngio-unix-2.0.pc\ngio-windows-2.0.pc\nglib-gettextize\nMakefile\nbuild/Makefile\nbuild/win32/Makefile\nbuild/win32/dirent/Makefile\nglib/Makefile\nglib/libcharset/Makefile\nglib/gnulib/Makefile\nglib/pcre/Makefile\nglib/update-pcre/Makefile\nglib/tests/Makefile\ngmodule/Makefile\ngmodule/gmoduleconf.h\ngobject/Makefile\ngobject/glib-genmarshal\ngobject/glib-mkenums\ngobject/tests/Makefile\ngthread/Makefile\ngio/Makefile\ngio/gdbus-2.0/codegen/Makefile\ngio/gdbus-2.0/codegen/config.py\ngio/gnetworking.h\ngio/xdgmime/Makefile\ngio/inotify/Makefile\ngio/kqueue/Makefile\ngio/fam/Makefile\ngio/win32/Makefile\ngio/tests/Makefile\ngio/tests/gdbus-object-manager-example/Makefile\ngio/tests/services/Makefile\ngio/tests/services/org.gtk.GDBus.Examples.ObjectManager.service\ngio/tests/modules/Makefile\npo/Makefile.in\ndocs/Makefile\ndocs/reference/Makefile\ndocs/reference/glib/Makefile\ndocs/reference/glib/version.xml\ndocs/reference/gobject/Makefile\ndocs/reference/gobject/version.xml\ndocs/reference/gio/Makefile\ndocs/reference/gio/version.xml\ntests/Makefile\ntests/gobject/Makefile\ntests/refcount/Makefile\nm4macros/Makefile\nsubprojects/Makefile\n])\n\n# We need this command because the configure script will not preserve\n# the same attributes of the template files\nAC_CONFIG_COMMANDS([chmod-scripts],\n[chmod 0755 glib-gettextize\nchmod 0755 gobject/glib-genmarshal\nchmod 0755 gobject/glib-mkenums])\n\n# we want to invoke this macro solely so that the config.status script\n# and automake generated makefiles know about these generated files.\n# They are only needed to distcheck the package\nif false; then\n  AC_CONFIG_FILES([\n    INSTALL\n    glib/glib.rc\n    gmodule/gmodule.rc\n    gobject/gobject.rc\n    gthread/gthread.rc\n    gio/gio.rc\n  ])\nfi\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/ChangeLog.pre-1-2": "Sun Feb 21 22:11:51 CST 1999  Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.2.0\n\n\t* AUTHORS: updated\n\nWed Feb 24 00:08:42 CST 1999 Shawn T. Amundson <amundson@gtk.org>\n\n\t* *.[ch]: inserted additional note to look for ChangeLog and\n\t  AUTHORS file for a log of modifications.\n\nSun Feb 21 14:01:00 1999  Dr Mike <drmike@redhat.com>\n\n\t* Made specfile generated, tweaked slightly\n\t\nThu Feb 18 08:24:12 1999  Tim Janik  <timj@gtk.org>\n\n\t* gmem.c (g_realloc): plugged a memory leak, reported by Koen D'Hondt\n\t<ripley@xs4all.nl> on 15 Oct 1998. allocate inital block from realloc.\n\n1999-02-17  Elliot Lee  <sopwith@redhat.com>\n\n\t* glib.spec: Do --enable-debug=no for the .rpm's.\n\nWed Feb 17 17:04:06 1999  Tor Lillqvist  <tml@iki.fi>\n\n\t* config.h.win32: Must define HAVE_PTHREAD_GETSPECIFIC_POSIX.\n\nTue Feb 16 14:08:59 CST 1999 Shawn T. Amundson <amundson@gtk.org>\n\n\t* NEWS\n\t  README\n\t  INSTALL\n\t  config.h.win32\n\t  configure.in\n\t  glib.spec\n\t  glibconfig.h.win32\n\t  docs/glib-config.1: version=1.1.16 \n\n\t* Released GLib 1.1.16\n\n1999-02-15  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib.h, glibconfig.h.win32, configure.in: Changed signature of\n\tall g_static_mutex_* functions to take a pointer rather than the\n\tstruct itself. This is not an issue at the moment, because those\n\tfuncs are really macros, but is it un'G'ish and might fall on our\n\tfeet in the future.\n\nMon Feb 15 07:45:54 1999  Tim Janik  <timj@gtk.org>\n\n\t* configure.in (--enable-debug): default to yes for development trees.\n\nMon Feb 15 06:18:58 1999  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: return guints instead of gints for g_hash_table_size\n\tand g_hash_table_foreach_remove.\n\nWed Feb 10 12:01:42 1999  Tim Janik  <timj@gtk.org>\n\n\t* configure.in: don't reset G_MODULE_IMPL, so it can be overridden\n\tfrom the command line.\n\n1999-02-10  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib.h: s/G_LOCK_DECLARE/G_LOCK_DEFINE/ throuhout glib. Added\n\tG_LOCK_EXTERN macro to declare a lock externally.\n\nWed Feb 10 06:20:30 1999  Tim Janik  <timj@gtk.org>\n\n\t* gmutex.c (g_static_private_set): invoke destroy notifier when\n\toverwriting values, initialize new array fields with NULL.\n\t(g_static_private_free_data): do not skip destroy notification for\n\tdata == NULL.\n\n\t* gutils.c (g_direct_equal): compare pointer values directly instead\n\tof just their guint values which is a loosing conversion for\n\tsizeof(gpointer)==8 systems.\n\t(g_get_any_init): restructured code so we don't use endless loops like\n\twhile (1), which boil down to an ugly alias for goto.\n\tstrip ,.* from the real name.\n\nFebruary 9, 1999 sopwith@redhat.com\n\n\t. glist.c, gnode.c, gslist.c: allocate pools of 128 items instead\n\tof 1024 items.\n\n1999-02-08  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in, acconfig.h: Changed the test for getpwuid_r to\n\texclude those systems (i.e. IRIX), that set ENOSYS after the call.\n\tTest, if pthread_getspecific is posix like or something different,\n\tas on PCThreads.\t\n\nSun Feb  7 21:56:00 1999  Owen Taylor  <otaylor@redhat.com>\n\n\t* gmem.c (g_mem_profile): Copy all elements\n\tof the allocations[] array, including the last.\n\t(Pointed out by \"Matthew W. Samsonoff\" <mws7323@osfmail.isc.rit.edu>)\n\t\n1999-02-05  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Make the error message in case of a broken thread\n\tsystem a bit more informative.\n\n\t* gutils.c (g_get_any_init): Changed the error logic again, now\n\tonly leaving the memory doubling loop, when success is reached or\n\twhen the user isn't found or when the buffer is 32k big,\n\tadditionally now getpwuid will be run, if getpwuid_r didn't work\n\tout properly. A warning is issued however.\n\nThu Feb 04 20:42:24 1999  Tor Lillqvist  <tml@iki.fi>\n\n\t* glibconfig.h.win32 config.h.win32: Update GLIB_MICRO_VERSION.\n\n1999-02-04  Christopher Blizzard  <blizzard@redhat.com>\n\n\t* glib.spec (Packager): Change my email address\n\nThu Feb  4 01:45:01 PST 1999 Shawn T. Amundson <amundson@gtk.org>\n\n\t* ChangeLog\n\t  NEWS\n\t  README\n\t  configure.in\n\t  glib.spec\n\t  docs/glib-config.1: version=1.1.15\n\n\t* Released GLib 1.1.15\n\nTue Feb 02 00:08:54 1999  Tor Lillqvist  <tml@iki.fi>\n\n\t* gmessages.c (g_log_default_handler): (Win32:) Don't call\n \tensure_stdout_valid (which would open an unneeded console window)\n \tif we're calling a logging function.  Define ensure_stdout_valid\n \tas an empty macro on Unix.\n\n\t* gutils.c (g_get_any_init): (Win32:) Trust HOME first if defined,\n\tthen try HOMEDRIVE and HOMEPATH.\n\nMon Feb  1 19:04:28 1999  Owen Taylor  <otaylor@redhat.com>\n\n\t* gmain.c (g_main_iterate): Release the main_loop\n\t lock around calls to prepare() and check() so\n\t that we are not holding the main loop lock\n\t over user code.\n\n1999-01-30  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Moved the check for MT safe function variants\n\tafter the determination of the MT cflags and use them there.\n\n1999-01-29  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Fixed typo. Now HPUX 11 thread system detection\n\tshould work.\n\n\t* gutils.c (g_get_any_init): Changed initial bufsize to 64. Should\n\tsolve some problems out there.\n\nWed Jan 27 23:21:50 CST 1999 Shawn T. Amundson <amundson@gtk.org>\n\n\t* INSTALL\n\t  NEWS\n\t  README\n\t  configure.in\n\t  glib.spec\n\t  docs/glib-config.1: version=1.1.14\n\n\t* Released GLib 1.1.14\n\n1999-01-28  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Simplified configure.in test for posix threads,\n\tsystems, that provide /usr/include/pthread.h should also have the\n\tposix thread library. This is to avoid writing down all the tests\n\ttwice. New test for thread system on HPUX 11. Info from Matt\n\tNottingham <matt@sar.dera.gov.uk>.\n\nWed Jan 27 20:39:49 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* acinclude.m4: Xsed isn't valid here, don't use it\n\n\t* ltmain.sh\n\t* ltconfig: better file magic regexp for Linux libs\n\n\t* gmodule/Makefile.am: arg, noinst_LTLIBRARIES doesn't make shared\n\tlibs, revert my previous change to this file\n\n\t* docs/texinfo.tex: add it so automake doesn't whine\n\nWed Jan 27 01:57:19 1999  Tim Janik  <timj@gtk.org>\n\n\t* configure.in (G_MODULE_HAVE_DLERROR): applied patch from Andrej\n\tBorsenkow <borsenkow.msk@sni.de> to also check for dlsym() in system\n\tlibraries and -ldl, to catch systems that provide dlopen() in libc\n\tand dlsym() in libdl. this is at least the case for Reliant UNIX\n\t5.44 (labeling itself as SINIX).\n\nTue Jan 26 13:39:22 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* configure.in: don't use backquotes in warning text\n\n1999-01-26  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* gdate.c (g_date_set_time): Removed the #warning about MT\n\tunsafety without localtime_r.\n\n\t* configure.in: Moved it here.\n\nMon Jan 25 10:07:53 1999  Raph Levien  <raph@gimp.org>\n\n\t* configure.in: (#define G_THREADS_IMPL...) Changed the #define,\n\tadding the G_THREADS_IMPL_ prefix to $g_threads_impl_def because\n\tit looked wrong to me and was breaking gimp compile.\n\nMon Jan 25 15:34:43 1999  Timur Bakeyev <mc@bat.ru>\n\n\t* configure.in, gstrfuncs.c: Inverted logic of NO_SYS_SYGLIST_DECL -\n\tnow it's normal (see 1999-01-19 Josh MacDonald). Also, remove from\n\t#include <signal.h> wrapper NO_SYS_SYGLIST - *sys_syglist[] declara-\n\ttion hides there.\n\n1999-01-25  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Do not use the thread libs, when searching for\n\tsome functions, as this might require glib to always be linked\n\twith the thread libs on some platforms.\n\n\t* gutils.c (g_get_any_init): Don't set errno to zero and use it\n\tonly as the error code, if the function returned a value less\n\t0. It might happen, that the call succeeds, even though the errno\n\tis set during the call (i.e. it first looks for a passwd file,\n\twhich is not found). Submitted by Michael Natterer\n\t<mitschel@cs.tu-berlin.de>. BTW: Sorry for all the mess with that\n\t`getpwuid_r' change, but it had to be done once.\n\nSun Jan 24 10:33:30 1999  Tim Janik  <timj@gtk.org>\n\n\t* gutils.c (g_get_any_init): reverted raja's changes, since they leaked\n\ta struct passwd contents buffer and for the rest mostly substituted a\n\twhile loop with a bunch of gotos.\n\trestored the getpwuid() code to what we had after my recent clean ups\n\t(\"Sat Jan 23 02:14:28 1999 Tim Janik\"), module yosh's recent changes.\n\tto feature solaris behaviour of directly returning errno, we don't\n\tmodify error anymore if it's > 0 and simply reset errno.\n\tdon't reset g_home_dir for !NATIVE_WIN32 && !NATIVE_WIN32.\n\n1999-01-24  Raja R Harinath  <harinath@cs.umn.edu>\n\n\t* gutils.c \n\t(g_get_any_init) [HAVE_GETPWUID_R && HAVE_GETPWUID_R_POSIX]: \n\tHopefully got the error handling for `getpwuid_r' right.\n\t(g_get_any_init) [HAVE_GETPWUID_R && !HAVE_GETPWUID_R_POSIX]:\n\tFix typo (change `pw == NULL' to `pw != NULL').\n\t\nSun Jan 24 00:36:22 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* ghash.c:\n\t- Revert previous \"fix\" (which really just did things a\n\t  different way).\n\t- (g_hash_table_remove): Don't need to support multiple values\n\t  for a single key.\n\n\t* tests/hash-test.c:\n\tAdd test where hash function always returns a single value.\n\tAdd beginnings of tests for g_hash_table_foreach[_remove] and\n\tg_hash_table_remove.\n\nSat Jan 23 20:40:06 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* gutils.c: removed the #warning about MT without getpwuid_r\n\n\t* configure.in: and moved it here\n\nSat Jan 23 22:45:59 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* ghash.c (g_hash_table_lookup_node, g_hash_table_lookup,\n\t\t   g_hash_table_insert, g_hash_table_remove,\n\t\t   g_hash_table_lookup_extended):\n\t  - Fixed bug that overwrote nodes in hash buckets instead of\n\t    adding them to the hash bucket node list.\n\t    Hash tables now work as advertised.\n\n\t(g_hash_table_resize):\n\t  - Use g_new0 instead of manual init.\n\t  - Space out code a bit for readability.\n\n\t(g_hash_nodes_destroy):\n\t  - Replaced \"if (!hash_node) return;\" with\n\t    \"if (hash_node) {do stuff}\".\n\t    Testing takes up less code space than explicit call to\n\t    'return' before end of function.  (look at gcc -S)\n\n\tUpdated module header copyright to 1999.\n\tNew module macro G_HASH_BUCKET for (table,key)->bucket lookups.\n\n\t* tests/hash-test.c:\n\t- Add two new tests, one with strings as the keys and values, and\n\t  one with ints as the keys and values.  Tests indirect (strings)\n\t  and direct (ints) hashing.\n\t- Cleanup unused junk left over from testglib.c.\n\t- Converted a g_print call to g_assert_not_reached.\n\t- Updated copyright to 1999.\n\n\t* testglib.c, tests/string-test.c:\n\t- Init 'tmp_string' var to NULL, silencing uninit-var warning.\n\n1999-01-23  Raja R Harinath  <harinath@cs.umn.edu>\n\n\t* gutils.c (g_get_any_init) [HAVE_GETPWUID_R]:\n\tRewrite not to look at `errno' if library call succeeds, since\n\t`errno' is not reset to 0.\n\t\nSat Jan 23 16:17:04 1999  Tor Lillqvist  <tml@iki.fi>\n\n\t* glibconfig.h.win32: Update the magic values for\n\tpthread_mutex_t size and initializer bytes to match the\n\tlatest version of pthreads for Win32.\n\nSat Jan 23 02:14:28 1999  Tim Janik  <timj@gtk.org>\n\n\t* gutils.c (g_get_any_init): cleaned up the errno mess for\n\tGETPWUID. we especially don't want to g_error() out here!\n\tthe warning for G_THREADS_ENABLED and !HAVE_GETPWUID_R isn't\n\tgcc related.\n\tif !HAVE_PWD_H and !NATIVE_WIN32, g_free the home dir before\n\tresetting it to NULL, why are we doing this anyways?\n\treordered code a bit so we always provide defaults (except\n\tfor g_home_dir).\n\nThu Jan 21 12:40:11 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* tests/{Makefile.am, string-test.c, strfunc-test.c}:\n\tSeparate string and strfunc tests, working towards goal of\n\thaving separate test for each of the GLib modules.\n\tAdd a couple GString length tests.\n\nThu Jan 21 09:36:05 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* configure.in:\n\tUse AC_PREREQ not AC_REQUIRE for autoconf version test.\n\n1999-01-21  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* gutils.c (g_get_any_init): Changed error handling again, as the\n\terror is not always set in errno, it is the return value on some\n\tsystems. What an evil world.\n\nThu Jan 21 05:35:20 1999  Tor Lillqvist  <tml@iki.fi>\n\n\t* gstrfuncs.c: Include signal.h only when the signal names will be\n\tneeded.\n\nWed Jan 20 22:09:59 EST 1999 Mandrake <mandrake@mandrake.net>\n\n\t* configure.in / Makefile.am : made some adjustments for automake 1.4\n\tand autoconf 2.13 (per suggestions made by  Raja R Harinath\n\t<harinath@cs.umn.edu>)\n\nWed Jan 20 20:33:14 EST 1999 Mandrake <mandrake@mandrake.net>\n\n\t* autogen.sh: automake 1.4 and libtool 1.2d notices.\n\t(maybe I'll write an actual test for automake 1.4 later)\n\nWed Jan 20 15:05:25 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* HACKING: new file\n\n\t* Makefile.am: since we require automake 1.4 now, ditch the build\n\ttop-level first and just use SUBDIRS\n\n\t* gmodule/Makefile.am: use noinst_LTLIBRARIES instead of overriding\n\tthe install rule\n\nWed Jan 20 16:16:01 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* gutils.c (g_get_any_init):\n\tRevert previous patch, move error value set line down to proper\n\tplace.  Caught by Elliot Lee <sopwith@redhat.com>.\n\nWed Jan 20 20:48:58 GMT 1999  Adam D. Moss  <adam@gimp.org>\n\n\t* gutils.c (g_get_any_init): All gtk apps were broken\n\there on my setup.  I changed the error to a warning to at\n\tleast get things limping.\n\n1999-01-20  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* gutils.c (g_get_any_init): Use getpwuid_r with the right\n\tsignature, if available.\n\n\t* configure.in, acconfig.h: Test for existance of getpwuid_r and\n\tits signature.\n\nTue Jan 19 20:52:43 1999  Tor Lillqvist  <tml@iki.fi>\n\t\n\t* Makefile.am (EXTRA_DIST): Add new Win32 files.\n\n\t* README.win32: Describe the conditional compilation macros.\n\n\t* makefile.lcc: Removed.\n\n1999-01-19  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Moved test for localtime_r and rand_r to a place\n\tafter the determination of the G_THREAD_LIBS and use them for\n\tfinding those functions, necessary on systems with a different C\n\tlibrary libc_r for threaded progs, like FreeBSD 2.2.x. Info from\n\tTimur Bakeyev <mc@bat.ru>.\n\nTue Jan 19 00:44:24 1999  Josh MacDonald  <jmacd@axis.hip.berkeley.edu>\n\n\t* gstrfuncs.c (g_strsignal): The \"extern char* sys_siglist\"\n\tdeclaration breaks systems with different declarations, like\n\tmine (FreeBSD).  So, I added a configuration variable to decide\n\twhether the declaration is neccesary.  Change also appears on\n\tline 275 of configure.in.\n\nSun Jan 17 17:13:54 CST 1999 Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.1.13\n\n\t* README:\n\t  INSTALL:\n\t  docs/glib-config: ver=1.1.13\n\nMon Jan 18 00:02:46 1999  Tim Janik  <timj@gtk.org>\n\n\t* NEWS: updates for 1.1.13.\n\nSun Jan 17 17:15:59 1999  Tim Janik  <timj@gtk.org>\n\n\t* gtree.c (g_tree_traverse): removed assertion about rtree->root being\n\tNULL, so this function can be applied to unpopulated trees as well, fix\n\tprovided by Simon Kagedal <sika8225@csd.uu.se>.\n\nSun Jan 17 11:17:19 1999 Christopher Blizzard  <blizzard@appliedtheory.com>\n\n\t* glib.spec: add packager address\n\nSun Jan 17 11:10:05 1999 Christopher Blizzard  <blizzard@appliedtheory.com>\n\n\t* glib.spec: increment version number to 1.1.13\n\nSun Jan 17 16:14:03 1999  Tim Janik  <timj@gtk.org>\n\n\t* glib.h (g_error): if !defined (G_LOG_DOMAIN) define G_LOG_DOMAIN as\n\t((gchar*) 0) instead of ((void*) 0) to silence egcs C++ mode, reported\n\tby Seth Alves <alves@hungry.com>.\n\nSun Jan 17 14:13:52 1999  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: added a define G_HOOK_DEFERRED_DESTROY, to substitute a noop\n\tGHookList.hook_destroy function.\n\n\t* ghook.c (g_hook_destroy_link): don't really call hook_destroy if it\n\tis G_HOOK_DEFERRED_DESTROY. for the case where we invoke hook->destroy()\n\twe now clean up the hook completely afterwards, i.e. data, func and\n\tdestroy are immediately set to NULL and hook_free can't play with that\n\tvalues anymore.\n\n\t* gmain.c (g_source_add): set hook_destroy to G_HOOK_DEFERRED_DESTROY,\n\tinstead of using an ugly _noop() hack, this is to avoid an uneccessary\n\tfunction invocation. set hook_free to g_source_destroy_func, this way\n\twe always invoke the destroy notifiers for user_data and source_data\n\tafter execution of dispatch(). thus, g_source_destroy_func() will always\n\tbe called within the main_loop lock (this wasn't really assured\n\tbefore), and can release and reaquire the look around destroy notifier\n\tinvocation.\n\nSun Jan 17 11:01:40 1999  Tor Lillqvist  <tml@iki.fi>\n\n\t* config.h.win32 glibconfig.h.win32: Increment version number here\n \talso.\n\nSun Jan 17 05:12:17 1999  Tim Janik  <timj@gtk.org>\n\n\t* configure.in: incremented version number to 1.1.13, bin age 0,\n\tinterface age 0.\n\n\t* glib.h: added hook_destroy member to struct _GHookList.\n\n\t* ghook.c (g_hook_destroy_link): if the hook_list defines a hook_destroy\n\tfunction, use that to marshal hook destruction notifiers.\n\n\t* gmain.c: removed g_source_free_func and added g_source_destroy_func,\n\twhich marshalls the user_data and source_data destructors of sources\n\toutside of the main_loop lock.\n\tremoved GIdleData struct since its sole member callback can be passed\n\tas source_data directly.\n\tadded a gboolean return value to all g_source_remove* functions,\n\tindicating whether the source could be removed, because these functions\n\tdon't issue warnings upon unseccessful removals themselves. this way at\n\tleast the caller gets a chance to warn upon failing removals.\n\t(g_main_iterate): set in_check_or_prepare around calls to check() or\n\tprepare().\n\t(g_main_pending): simply return FALSE if called from within check() or\n\tprepare().\n\t(g_main_iteration): issue a warning if called from within check() or\n\tprepare() and bail out with FALSE.\n\t(g_main_run): likewise.\n\t(g_source_remove_by_funcs_user_data): new function to remove sources by\n\tuser data and function table.\n\t(g_idle_remove_by_data): new function to really remove idles only, since\n\tg_source_remove_by_user_data would remove timeouts or other sources as\n\twell.\n\n1999-01-16  Tor Lillqvist  <tml@iki.fi>\n\n\t* Merge in current Win32 version:\n\n\t* README.win32: More text.\n\n\t* config.h.win32 glibconfig.h.win32: Update to match the\n\tcorresponding generated files on Unix.\n\n\t* makefile.msc: Update with new source files, and gthread\n \tlibrary. Use the compiler flag -MD instead of using -D_DLL and\n\t/nodefaultlib:libc msvcrt.lib in the link phase.\n\n\t* glib.def: Update to include new functions, drop removed ones.\n\n\t* glib.h: Add comments about main loop and polling on Win32. (In\n\tgeneral, it's only for the GIMP's use.) Add Win32 IO Channel\n\tfunctions. Remove the obsoleted old IO Channel stuff (which was\n\tin #if 0 already).\n\n\t* giowin32.c: New file.\n\n\t* gmain.c: Include config.h, conditionalize <sys/time.h>\n \tinclusion.  Add g_poll implementation for Win32 (only for the\n \tGIMP's needs for now, it's hard or even impossible to be as clean\n \tand generic as on Unix). Implement g_get_current_time on Win32. If\n \tthreads aren't supported, don't try to wake up main thread's\n \tloop. On Win32, use a semaphore and not a pipe to wake up the main\n \tloop.\n\n\t* gmessages.c: On Win32, allocate a console window if the standard\n\toutput handle is invalid before writing to stdout, and reopen stdout\n\tto that console window.\n\n\t* giochannel.c: Conditionalize unistd.h inclusion. Some indentation\n\tcleanup.\n\n\t* gstrfuncs.c: Include <signal.h>.\n\n\t* gutils.c: On Win32, also check the HOMEDRIVE and HOMEPATH\n\tenvironment variables.\n\nSun Jan 17 01:06:38 1999 Timur Bakeyev <mc@bat.ru>\n\n\t* configure.in: Add support for FreeBSD 2.2.x macro _THREAD_SAFE.\n\nWed Jan 13 11:27:24 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* glib.h: don't use inline for !__GNUC__ case with g_warning,\n\tg_error, and g_message wrappers since some compilers throw\n\taway arguments in this case\n\nTue Jan 12 21:59:14 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* acinclude.m4\n\t* ltconfig\n\t* ltmain.sh: upgrade to libtool 1.2d (with fixes for irix6 and osf)\n\n\t* testglib.c: removed unused cruft\n\nTue Jan 12 09:57:06 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* gdate.c: #warning isn't portable, check for gcc\n\n1999-01-12  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n        * gdate.c: Include config.h to get HAVE_LOCALTIME_R macro.\n\n        * configure.in: Moved function check back to the place, they've\n        been before.\n\n1999-01-11  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* gstrfuncs.c:\n\tDo not use vasprintf.\n\n\t* configure.in, glib.h, testglib.c, tests/.cvsignore,\n\t  tests/Makefile.am, tests/alloca-test.c:\n\tDo not use alloca.\n\n1999-01-11  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Test for localtime_r only after including the\n\tright MT enabling CFLAGS (i.e. -D_REENTRANT on most systems).\n\n\t* configure.in: Find right thread system on DG/UX. Thanks to Marc\n\tJ. Fraioli <fraioli@dg-rtp.dg.com> for hint. Finally removed the\n\tstuff for -fstack-check, that didnt work anyway.\n\n\t* gdate.c (g_date_set_time): Emit warning, if no localtime_r\n\tfunction is available on thread enabled systems. Define ptm only,\n\tif really needed, and assert on it.\n\nSat Jan  9 15:08:44 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* testglib.c:\n\tMake all aux functions static.\n\n\t* tests/Makefile.am, tests/dirname-test.c, tests/type-test.c:\n\tNew tests dirname-test and type-test, from testglib.\n\nSat Jan  9 13:53:00 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* configure.in:\n\tAdd checks for vasprintf, localtime_r.\n\n\t* gdate.c (g_date_set_time):\n\tUse localtime if localtime_r is not available.\n\n\t* gstrfuncs.c (g_strdup_vprintf):\n\tUse glibc vasprintf if possible; it's a bit faster than using\n\tGLib routines, and makes output code a bit smaller.\n\n\t* acconfig.h:\n\tRemove HAVE_VSNPRINTF and HAVE_VPRINTF.  autoheader picks these\n\tup automatically and puts them in config.h.in.\n\nThu Jan  7 15:14:08 1999  Owen Taylor  <otaylor@redhat.com>\n\n\t* gmain.c (g_source_free_func): Call the source-specific\n\tfree function when the hook is freed not when it\n\tis destroyed; this fixes a bug where a timeout destroyed\n\tfrom itself would access already freed data.\n\n1999-01-07  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* gutils.c (g_get_any_init): Here we must replace getpwuid by\n\tgetpwuid_r, but as I do not know how for now, I just made a FIXME\n\tnote ;-)\n\n\t* gdate.c (g_date_set_time): localtime --> localtime_r to make it\n\tthread safe.\n\n\t* configure.in: We do not need to check for broken solaris mutex\n\tintitializer any longer. Provide a macro to show the used thread\n\timplementation. Not nice, but this is needed until thread support\n\tis completed here inside glib.\n\nTue Jan  5 12:23:52 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* configure.in: ditch whitespace before GLIB_SYSDEFS #includes,\n\tthe # needs to be in column 1\n\n\t* gthread/testgthread.c: cleanups\n\n\t* tests/node-test.c: #include unistd.h for exit()\n\n1999-01-04  Andrew T. Veliath  <andrewtv@usa.net>\n\n\t* glib.h (g_array_insert_val): fix macro to be shorthand of\n\tg_array_insert_vals.\n\nMon Jan  4 15:35:29 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* acglib.m4: some echos interpret \\n's and some don't. Deal with\n\taccordingly.\n\nMon Jan  4 20:58:50 1999  Tim Janik  <timj@gtk.org>\n\n\t* gscanner.c: eliminated extraneous \"register\" qualifiers in variable\n\tdeclarations.\n\n\t* gmain.c: #undef events and revents which may have been defined in\n \tsys/poll.h for SVR3,4 compatibility on some AIX systems. fix been\n\tprovided by Philippe Defert <Philippe.Defert@cern.ch>.\n\nMon Jan  4 14:38:11 1999  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: adjusted the g_strdup_a, g_strndup_a and g_strconcat3_a macros\n\tso their arguments get only evaluated once. changed g_strconcat3_a to\n\thave the same semantics as g_strconcat, i.e. if a certain argument is\n \tNULL, the rest of the parameter list is skipped.\n\n\t* tests/alloca-test.c: removed #if/#endif G_HAVE_ALLOCA, we need to be\n \table to compile on all systems. added test for g_strconcat() semantics.\n\n\t* we need a alloca() replacement for !G_HAVE_ALLOCA rsn!\n\nMon Jan  4 02:58:13 CST 1999 Shawn T. Amundson <amundson@gtk.org>\n\n        * Released GLib 1.1.12\n\n        * INSTALL:\n          NEWS:\n          README:\n          configure.in:\n\t  glib.spec:\n          docs/glib-config.1: version=1.1.12\n\n\t* tests/Makefile.am: fixed so it works properly with\n\t  builddir and srcdir.\n\nSun Jan  3 01:38:14 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* tests/Makefile.am:\n\tadd array-test.c, tree-test.c\n\n\t* tests/array-test.c, tests/tree-test.c:\n\tNew module, tests array family\n\n\t* tests/hash-test.c, tests/list-test.c, tests/slist-test.c,\n\t  tests/string-test.c, tests/node-test.c:\n\tClean out cruft left over from testglib.\n\nSat Jan  2 22:42:25 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* Makefile.am, configure.in, tests/*:\n\tAdded 'make check' tests, based on testglib code.\n\nSat Jan  2 19:52:45 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* glib.h, testglib.c:\n\tAdded g_alloca, g_new_a, g_new0_a macros.\n\nSat Jan  2 16:45:44 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* testglib.c: Added g_strdup_printf check.\n\nFri Jan  1 21:58:40 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* glib.h:\n\t(g_strdup_a, g_strndup_a): Handle NULL strings like g_strdup.\n\ts/g_strconcat_a/g_strconcat3_a/ to reflect fixed number of args\n\n\t* testglib.c:\n\tAdded g_strdup, g_strconcat checks.\n\tAdded str==NULL checks for alloca string macros.\n\ts/g_strconcat_a/g_strconcat3_a/\n\nFri Jan  1 18:30:41 PST 1999 Manish Singh <yosh@gimp.org>\n\n\t* testglib.c: made the alloca tests follow the testglib style\n\n\t* Makefile.am: minor cleanups, mostly cosmetic\n\nFri Jan  1 20:43:19 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* glib.h: added g_strndup_a macro\n\n\t* testglib.c:\n\tAdded tests for new alloca-based string routines.\n\tReformatted a couple strings.\n\nSat Jan  2 02:20:59 1999  Tim Janik  <timj@gtk.org>\n\n\t* ghook.c:\n\t(g_hook_list_invoke):\n\t(g_hook_list_invoke_check):\n\t(g_hook_list_marshal_check):\n\t(g_hook_list_marshal): avoid unneccessary extra hook referencing (the\n\texplicit hook referencing became unneccessarry with my changes from\n\tMon Dec 21 21:48:29 1998).\n\n\t* gmain.c (g_main_iterate): fixed reference counting leaks with\n \tpremature loop aborts.\n\nFri Jan  1 22:47:44 1999  Tim Janik  <timj@gtk.org>\n\n\t* gscanner.c (g_scanner_unexp_token): handle G_TOKEN_IDENTIFIER_NULL\n\tas G_TOKEN_IDENTIFIER.\n\nFri Jan  1 17:09:19 EST 1999  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* configure.in, glib.h:\n\tAdded two new alloca-based function macros, g_strdup_a and\n\tg_strconcat_a.\tThese are stack-based and much faster than\n\ttheir g_malloc-based counterparts.  Kudos to Ulrich Drepper\n\tfor help on this one.\n\nWed Dec 30 18:24:57 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n        * Released GLib 1.1.11\n\n        * INSTALL:\n          NEWS:\n          README:\n          configure.in:\n          docs/glib-config.1: version=1.1.11\n\n1998-12-30  Raja R Harinath  <harinath@cs.umn.edu>\n\n\t* glib.h (G[U]INT64_FROM_{LE,BE}):\n\tDefine to G[U]INT64_TO_{LE,BE}, not G[U]INT32_TO_{LE,BE}.\n\nFri Dec 25 19:56:33 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* acglib.m4\n\t* configure.in: provide defaults for POLL sysdefs, simple enums\n\tdon't work with bitwise logic. Reported by Daniel Skarda\n\t<0rfelyus@atrey.karlin.mff.cuni.cz>\n\nWed Dec 23 00:43:25 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* INSTALL:\n\t  NEWS:\n\t  README:\n\t  configure.in:\n\t  docs/glib-config.1: version=1.1.10\n\nWed Dec 23 04:18:11 1998  George Lebl  <jirka@5z.com>\n\n\t* gmain.c: (g_get_current_time) don't cast to timeval since\n\t  timeval is for some reason not always a struct of longs, weird\n\nTue Dec 22 10:32:11 1998  Tim Janik  <timj@gtk.org>\n\n\t* ghook.c (g_hook_first_valid): fixed buglet that could cause bogus\n\twarnings.\n\nMon Dec 21 21:48:29 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gmain.c: there was a reference count race for hooks during invocation\n\tloops. since all (known) hook loop implementations, do currently start\n\tout with g_hook_first_valid() and iterate with g_hook_next_valid(),\n\tg_hook_first_valid() will now return a referenced hook, and\n\tg_hook_next_valid() will \"eat\" that, and eventually transfer it to\n\tthe next hook. <sigh> unfortunately this requires g_hook_next_valid()\n \tto take the hook_list as additional argument.\n\n\t* gmain.c (g_main_iterate): adjusted callers of g_hook_next_valid().\n\nMon Dec 21 03:48:04 1998  Tim Janik  <timj@gtk.org>\n\n\t* gmain.c (g_main_iterate): default initialize source_timeout with -1\n\tso we have a sane timeout value if (*prpare) doesn't set it.\n\nSat Dec 19 16:56:02 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib.h gmain.c (G_PRIORITY_LOW): Add #defines defining\n\tscale of priorities.\n\nSat Dec 19 16:56:02 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* gmain.c (g_main_poll): Allocate space for pollfd's\n\t_after_ adding poll wake-up-pipe record.\n\n\t* gmain.c (g_main_add_poll): Changed name\n\tof internal function g_main_add_poll_unlocked()\n\tback from the non-sensical g_main_add_unlocking_poll().\n\nSat Dec 19 06:25:55 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.m4: fixed a minor bug that would let configures bail out\n\tif the MODULES argument contained newlines.\n\n\t* acglib.m4: new file to be included by configure.in. it holds\n\tspecial GLIB_ autoconfiguration macros, eventually some of the\n\teasier ones should be moved into glib.m4, e.g. GLIB_IF_VAR_EQ,\n\tGLIB_STR_CONTAINS or GLIB_ADD_TO_VAR.\n\nSat Dec 19 04:27:17 1998  Tim Janik  <timj@gtk.org>\n\n\t* fixed up sys/poll.h and sys/types.h inclusions.\n\nSat Dec 19 03:10:50 1998  Tim Janik  <timj@gtk.org>\n\n\t* fixed up gthread includes, cleaned up glibconfig.h a little bit.\n\nFri Dec 18 12:51:39 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* gmain.c: Fix errors in computation of timeout\n\texpiration times > 1sec.\n\n1998-12-18  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in (have_threads): Changed the last pthread_cond_init\n\tto pthread_attr_init.\n\nFri Dec 18 00:03:17 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gmain.c:\n\t(g_main_is_running): new function to check whether a main loop has been\n\tquitted.\n\t(g_main_new): added a gboolean argument to determine whether the loop\n\tshould be considered initially running or not. however, g_main_run ()\n \twill still reset the main loops running state to TRUE upon initial\n \tentrance.\n\n\t* gmain.c:\n \t(g_main_iterate): documented this function's purpose in 5 steps.\n \tfor step 2), flag sources as G_SOURCE_READY even if !dispatch and\n\tcheck G_SOURCE_READY prior to (*prepare), so we don't call (*prepare)\n \ton them multiple times.\n\nThu Dec 17 23:43:47 1998  Tim Janik  <timj@gtk.org>\n\n\t* gmain.c (g_main_add_poll): reordered arguments, so GPollFD* comes\n\tfirst, <sigh> (sorry Snorfle, i should have let you know in the first\n \tplace).\n\t(g_main_dispatch): stack G_HOOK_FLAG_IN_CALL flags. call source's\n\tdestructor when destroying a source.\n\n1998-12-17  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* garray.c (g_ptr_array_remove_index): Fixed size in g_memmove,\n\treported by Alexander Larsson <alla@lysator.liu.se>.\n\n\t* gmem.c: Fixed bug, that made compile fail for -DENABLE_MEM_PROFILE.\n\nWed Dec 16 23:04:26 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.1.9\n\n\t* INSTALL:\n\t  NEWS:\n\t  README:\n\t  configure.in:\n\t  glib.spec:\n\t  docs/glib-config.1: version=1.1.9\n\nWed Dec 16 22:32:13 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* glib.h:\n\t  giounix.c: s/g_main_poll_add/g_main_remove_add/g\n                     s/g_main_poll_remove/g_main_remove_poll/g\n                     s/g_main_poll_add_unlocking/g_main_add_unlocking_poll/g\n          (from Tim Janik)\n\nWed Dec 16 20:04:10 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* configure.in: check for pthread_attr_init in all cases, du4\n\tneeds this since most of the other functions are just #defines\n\nThu Dec 17 04:10:49 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h (G_LOCK_DECLARE_*): if !G_THREADS_ENABLED, eat the\n\ttrailing semicolon with a bogus function declaration, instead\n\tof with a bogus variable declarations, so we avoid unused\n\tvariable warnings.\n\nWed Dec 16 07:49:16 PST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.1.8  (CVS tag is GLIB_1_1_8a)\n\n1998-12-16  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* giounix.c (g_io_channel_unix_get_fd): Fixed small bug.\n\n1998-12-16  Joel Becker  <jlbec@ocala.cs.miami.edu>\n\n\t* glib.h, gscanner.c: changed func_data to user_data in\n        g_scanner_scope_symbol_foreach and associated friends, because\n\tAIX headers #define func_data.\n\n1998-12-16  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Fixed stupid bug, that made\n\tg_static_mutex_lock(*mutex) not work as expected.\n\n\t* docs/glib-config.1: Updated to reflect the existence of gthread.\n\n\t* gmain.c (g_main_poll_add_unlocking): Changed\n\tg_main_poll_add_unlocked to g_main_poll_add_unlocking to match\n\tsemantic, (indeed, main_loop must be locked, when calling this\n\tfunction). Removed the unlocking from the end of that function, as\n\tthat is not right. Made a 'HOLDS' comment above the function.\n\nWed Dec 16 03:16:58 1998  Tim Janik  <timj@gtk.org>\n\n        * configure.in: version bump to 1.1.8, binary age 0, interface age 0.\n\n\t* glib.h: changed g_lock() to G_LOCK(), g_unlock() to G_UNLOCK() and\n\tg_trylock() to G_TRYLOCK(), since these are macros that expand to\n\tnothing with --disable-threads.\n\tchanged G_LOCK_DEFINE() to G_LOCK_DECLARE() and introduced\n \tG_LOCK_DECLARE_STATIC() to achive the results of static G_LOCK_DECLARE().\n\tchanged semantics of g_thread_supported to g_thread_supported() so it\n\tcan be used as a function like g_module_supported(). the actuall\n\tdefinition is still a macro that expands into a variable for\n \tperformance reasons though.\n\tvarious indentation and coding style cleanups.\n\n\t* configure.in: added --enable-threads that defaults to yes.\n\n\t* gmutex.c: changed tests g_thread_supported to g_thread_supported (),\n\tchanged variable settings of g_thread_supported\n \tto g_threads_got_initialized.\n\n\tgarray.c:\n\tgcache.c:\n\tgdataset.c:\n\tgdate.c:\n\tghash.c:\n\tglist.c:\n\tgmain.c:\n\tgnode.c:\n\tgslist.c:\n\tgstring.c:\n\tgtree.c:\n\tgutils.c:\n\tchanged s/g_lock/G_LOCK/, s/g_unlock/G_UNLOCK/,\n \ts/static G_LOCK_DEFINE/G_LOCK_DECLARE_STATIC/.\n\nTue Dec 15 23:16:05 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* INSTALL:\n\t  NEWS:\n\t  README\n\t  configure.in:\n\t  glib.spec:\n\t  docs/glib-config.1: Incremented version\n\nWed Dec 16 22:29:48 1998  Joel Becker  <jlbec@ocala.cs.miami.edu>\n\n\t* configure.in: fixed the AIX thread checking.\n\tJust an error on the wildcard.  BTW, -D_THREAD_SAFE\n\tis correct for AIX.\n\nWed Dec 16 02:02:48 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib-config.in (lib_glib): fixed library and flag ordering for\n\t--libs\n\nTue Dec 15 17:17:46 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* glib.h giounix.c giochannel.c: Use an \"inheritance\"\n\tscheme for IO channel memory allocation.h\n\n1998-12-15  Havoc Pennington  <hp@pobox.com>\n\n\t* gdate.c (g_date_prepare_to_parse): Solaris has a broken strftime\n\tthat produced garbage output for the test date I was using to\n\tset up the parser. So use a different date that Solaris seems\n\tto like.\n\n1998-12-15  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: Dont complain, if --without-threads or\n\t--with-threads=none is supplied; Test for pthread_attr_init\n\tinstead of pthread_cond_init, if threads seems to be supported by\n\tstandard glib. (CFLAGS): Use G_THREAD_CFLAGS for compiling of glib\n\tas well.\n\n\t* glib.h, gmutex.c: Changed private to private_key to avoid\n\tproblems when compiling with under C++.\n\n1998-12-15  Jeff Garzik  <jgarzik@Pobox.com>\n\n\t* configure.in:\n\tbugfixes, correctly support --without-threads and friends\n\n\t* gthread/testgthread.c: corrected 64-bitness problem\n\nTue Dec 15 10:40:09 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* gnode.c glist.c gslist.c: Make sure all\n\tcalls to g_node_validate_allocator are within\n\tcurrent_allocator lock, so we have consistency\n\ton that point. (Should not really matter,\n\tbut this way we match the comments)\n\n\t* glist.c (g_list_free_1): Removed some lines\n\tthat should never have been committed. (For\n\tdebugging)\n\n1998-12-11  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* gthread/gthread-nspr.c, configure.in: Added new default thread\n\timplementation on top of the mozilla nspr library.\n\n\t* gmem.c, gmessaged.c, gthread/gthread.c, gthread/gthread-*.c:\n\tChanged GStaticMutex and GStaticPrivate in gmem.c and gmessages.c\n\tinto GMutex and GPrivate resp. to make error reporting and use of\n\tgmem possible in most (not all, though) gthread functions. Also\n\tinitialized the modules via new init functions.\n\n\t* configure.in: Fixed syntax bug in definition of type\n\tGStaticMutex.\n\n\t* gthread/testgthread.c: Updated to work with nspr, but see note\n\tthere for remaining problems.\n\n1998-12-10  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* gmutex.c, glib.h: Now abort, if a mutex/cond/private is\n\tallocated before the thread system is set up.\n\n\t* gthread/gthread.c (g_thread_init): Removed g_thread_try_init(),\n\tas it is not necessary. Changed the error message. Corrected logic\n\tfor g_thread_use_default_impl.\n\n\t* gmutex.c (g_mutex_init): Keep the thread private data array\n\tafter calling g_thread_init().\n\n1998-12-09  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* gthread/testgthread.c (new_thread): Now also working for posix\n\tthreads; (wait_thread): Now a better implementation, that does not\n\tuse 100% CPU.\n\n\t* Made the thread related code follow GNU coding standard.\n\n\t* Made a comment (HOLDS:) above each function, that expects the\n\tgiven locks to be held.\n\n\t* Changed try_lock to trylock throughout.\n\n\t* glib.c: Eventually removed the #if 0'ed code for old GStaticMutex.\n\n\t* glib.c: Corrected g_trylock macro for G_DEBUG_LOCKS.\n\n\t* gmain.c (g_main_poll_add_unlocked): first take a new poll record\n\tform the poll_free_list.\n\n\t* gmem.c, gstrfuncs.c, gutils.c: Made it MT safe.\n\n\t* gthraed/*.c: Added copyright headers.\n\n\t* gthread/gthread-solaris.c: do not use g_log for errors, as g_log\n\tuses these module and endless recursions might happen, just use a\n\tplain fprintf(stderr,...).\n\n\t* gthread/gthread.c (g_thread_try_init): Call g_mutex_init().\n\n\t* gthread/testgthread.c: updated test program.\n\nTue Dec  8 18:49:56 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* Start at adding thread-safety. (mostly work\n\tof Sebastian Wilhelmi <wilhelmi@ira.uka.de>)\n\n\t- configure.in now looks for a system thread implementation.\n\tCurrently support is included for POSIX threads\n\tand Solaris threads. The default support is built\n\tinto a separate library -lgthread.\n\n\t- The thread implementation can be modified by passing\n\ta vector of functions g_thread_init().\n\n\t- The default or supplied functions are used to\n\timplement a small set of thread functions for\n\tmutexes, condition variables, and thread-private\n\tdata.\n\n\t- GLib now uses these functions to provide thread\n\tsafety. (In the sense that all global static\n\tdata is locked... individual structures must still\n\tbe locked by the caller.)\n\nSat Dec 12 19:08:59 1998  Tim Janik  <timj@gtk.org>\n\n\t* configure.in: always define G_HAVE_INLINE if __cplusplus is\n \tdefined, reported by Wan-Teh Chang <wtc@netscape.com>.\n\nThu Dec 10 21:49:39 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.1.7\n\n\t* INSTALL:\n\t  NEWS:\n\t  README:\n\t  configure.in:\n\t  glib.spec:\n\t  docs/glib-config.1: Increased version to 1.1.7\n\nWed Dec  9 22:44:44 EST 1998 Joel Becker <jlbec@ocala.cs.miami.edu>\n\n\t* Removed #define of G_COMPILED_WITH_DEBUGGING from glibconfig.h\n\tIt shouldn't be there, and it was causing a double #define.\n        (config.h defines it also)\n\nTue Dec  8 12:18:38 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.1.6\n\n\t* NEWS: updated\n\nMon Dec  7 23:10:41 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* gmain.c: fixes to #undef HAVE_POLL case\n\n1998-12-02  Havoc Pennington  <hp@pobox.com>\n\n\t* gdate.c (g_date_set_month): If Julian is valid, we have to\n\tupdate the dmy representation before setting the components\n\tof it.\n\t(g_date_set_day): Same.\n\t(g_date_set_year): Same.\n\n1998-12-02  Havoc Pennington  <hp@pobox.com>\n\n\t* testgdate.c, testgdateparser.c: Two new files. This is kind of\n\tugly code, but I want to go ahead and make the tests available.\n\tIt isn't contaminating any other code. :-) Since one of these\n\tis interactive and the other takes a while to run, I've kept\n\tthem separate from testglib for now.\n\t* Makefile.am: Build gdate test programs.\n\n1998-12-02  Havoc Pennington  <hp@pobox.com>\n\n\t* gdate.c (g_date_valid): Rely on GDate::dmy and GDate::Julian\n\tflags, rather than re-checking the validity of the actual\n\tvalues. This should be the correct behavior, the old way was\n\tleftover cruft.\n\n\t* glib.h, gdate.c: Changed MDY to DMY throughout.\n\nSat Nov 28 12:53:47 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* Makefile.am configure.in acconfig.h giochannel.c\n\t  glib.h glist.c gmain.c gutils.c:\n\n        - Revised GIOChannel to provide a generic virtual-function\n  \t  based interface.\n\t- Added unix fd-based GIOChannel's\n\t- Added generic main-loop abstraction\n\t- Added timeouts and idle functions using main-loop abstraction.\n\n1998-12-02  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib.h:\n\t* gdate.c: changed `gpointer struct_tm_p' parameter of\n\tg_date_to_struct_tm back to `struct tm *tm' and forward declared\n\t`struct tm' in glib.h; yes, this is nice, we still need not\n\tinclude time.h.\n\nTue Dec  1 23:01:44 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* INSTALL:\n          NEWS:\n\t  README:\n\t  glib.spec:\n\t  docs/glib-config.1: Incremented versions to 1.1.6.\n\nWed Dec  2 02:10:59 1998  Tim Janik  <timj@gtk.org>\n\n\t* gdate.c: s/time_t/GTime/ and s/g_print/g_message/\n\tinclude time.h.\n\n\t* glib.h: removed #include <time.h>, changed time_t paramter of\n \tg_date_set_time() to time_t, changed struct tm parameter of\n\tg_date_to_struct_tm to `gpointer struct_tm_p'. yes, this is not\n\tnice, but including time.h actually breaks a bunch of code.\n\n\t* incremented GLib version to 1.1.6.\n\n1998-11-30  Havoc Pennington  <hp@pobox.com>\n\n\t* gdate.c: New file, implements calendrical calculations.\n\n\t* glib.h: Added declarations for GDate module.\n\nMon Nov 30 07:12:10 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* ghook.c: added g_hook_list_marshal_check() to eventually destroy\n\thooks after they got marshalled.\n\nSun Nov 29 17:31:43 EST 1998  Jeff Garzik  <jgarzik@pobox.com>\n\n\t* configure.in, Makefile.am, gmodule/Makefile.am:\n\tPut -DFOO stuff into Makefile.am INCLUDES.\n\nSun Nov 29 14:17:09 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* configure.in: put debug -DFOO stuff into CPPFLAGS, not CFLAGS,\n\tso CFLAGS can be overridden at make time properly\n\nSat Nov 28 01:23:25 1998  Tim Janik  <timj@gtk.org>\n\n\t* ghash.c: implemented incremental freezing facility.\n\nThu Nov 26 01:36:20 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* ghash.c: reverted the g_hash_table_set_key_freefunc() addition,\n\tsince it's to specialized and needs to be resolved in a generic\n\tfashion.\n\nTue Nov 24 18:57:59 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* applied glib-tml-981120-0, change log appended below.\n\n\t* glibconfig.h.win32: passthrough 64-bit constants unchanged, VC++\n\tinfers them\n\nFri Nov 20 22:26:43 1998  Tor Lillqvist  <tml@iki.fi>\n\n        * glib.h: Moved MSC pragmas from glib.h to glibconfig.h.win32.\n        peer_offset field in WIN32 part of GIOChannel removed, need_wakeups\n        added. Added \"extern\" to __declspec(dllimport).\n\n        * gutils.c: Initialise need_wakeups.\n\n        * glibconfig.h.win32: Pragmas moved here. Define G_GINT64_CONSTANT.\n\n        * gmodule/gmodule.def: Added g_module_build_path.\n\n        * gscanner.c: (g_scanner_cur_value) Move initailisation of v\n        to before its use.\n\n        * glib.def: Added g_(s)list_sort.\n\n        * makefile.msc: A few more comments.\n\nTue Nov 24 14:05:47 EST 1998\tMichael K. Johnson <johnsonm@redhat.com>\n\n\t* glib.h: added GFreeFunc and g_hash_table_set_key_freefunc()\n\tprototype.\n\t* ghash.c: added g_hash_table_set_key_freefunc() implementation.\n\tModified the prototypes of the functions g_hash_node_destroy() and\n\tg_hash_nodes_destroy(), and changed the functions that call them\n\tto match the new definitions.\n\tThis changes no external interfaces, and should create no binary\n\tor source incompatibilities.  It does add a member to the\n\tGHashTable structure.\n\nTue Nov 24 09:40:00 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: removed the GListAllocator type and its g_*_allocator_*()\n \tfunction variants (which weren't working anyways) in favour of a\n \tgeneric GAllocator type. new functions:\n\tg_allocator_new, g_allocator_free, g_slist_push_allocator,\n\tg_slist_pop_allocator, g_list_push_allocator, g_list_pop_allocator,\n\tg_node_push_allocator and g_node_pop_allocator.\n\n\t* gstring.c: removed bogus slist allocator code.\n\t* gtree.c: maintain own list of free tree nodes and don't waste\n\tGSLists for that, removed bogus slist allocator code.\n\t* glist.c: use GAllocators for node allocation.\n\t* gslist.c: use GAllocators for node allocation.\n\t* gnode.c: use GAllocators for node allocation.\n\n\t* gdataset.c: cleanups wrt automatic initialization.\n\nMon Nov 23 10:03:58 1998  Owen Taylor  <otaylor@gtk.org>\n\n\t* glib.h garray.[ch]: added g_array_insert_vals() to\n\tinsert elements at an arbitrary index, and\n\tg_array_insert_val() macro.\n\nSun Nov 22 17:07:03 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gslist.c: new function g_slist_copy() to duplicate a list with all its\n\tdata pointers.\n\t* glist.c: new function g_list_copy.\n\nSat Nov 21 14:57:39 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* INSTALL:\n\t  NEWS:\n\t  README:\n\t  configure.in:\n\t  glib.spec: Updated to version 1.1.5\n\n\t* Released GLib 1.1.5\n\nWed Nov 18 1998 Elliot Lee <sopwith@redhat.com>\n\n\t* gdataset.c: There was a code path into g_data_set_internal\n\t  through a function (g_datalist_id_set_full). Neither function\n\t  checked for g_dataset_init having been run, but\n\t  g_data_set_internal used the memchunk. I added\n\t  a check into g_data_set_internal so it will do the\n\t  initialization if needed. (There's probably a better way.)\n\nMon Nov 16 07:48:06 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h (g_bit_nth_msf): fixed off-by-one error, so we don't waste\n\ta loop iteration if (-1) was passed, reported by Andreas Bombe\n \t<andreas.bombe@munich.netsurf.de>.\n\nFri Nov 13 15:17:34 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* glist.c gslist.c glib.h: Added g_list_sort() and\n\tg_slist_sort() to merge sort GLists and GSLists.\n\tSubmitted by Sven Over <sven.over@ob.kamp.net>\n\tover a year ago!\n\n\t* testglib.c: Test the new sort functions.\n\nWed Nov 11 23:23:22 EST 1998 Jeff Garzik <jgarzik@pobox.com>\n\n\t* Makefile.am : INCLUDES is the right way to add to CFLAGS, not\n\tDEFS.  Also there are bugs with '+=' in makefiles.\n\tGot rid of DEFS line by moving G_LOG_DOMAIN setting into INCLUDES.\n\tRemoved redundant -I from INCLUDES.\n\nWed Nov 11 18:11:24 EST 1998 Gregory McLean <gregm@comstar.net>\n\n\t* docs/*.sgml : Batch of new documentation that should be easier\n\tto maintain and extend. Plus generate whatever sort of doc file\n\tyou would like. I didn't change the Makefile stuff as I'm not sure\n\twhat default doc type people want. Oh and this is all DocBook format.\n\tEnjoy!\n\nTue Nov 10 17:12:45 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* configure.in: use __extension__ for long long on gcc >= 2.8 and\n\tegcs, and provide a G_GINT64_CONSTANT wrapper so -ansi -pedantic\n\tcompiles clean.\n\n\t* glib.h: make the endian x86 asm __const__ so the compiler can do\n\tbetter optimizations. Also remove the cc clobber, these shouldn't\n\tbe changing condition codes. Ditch some redundant casts. Add an\n\toptimization for 64-bit endian conversions in x86. Use constant\n\twrapper for the generic method.\n\n\t* testglib.c: use constant wrappers for 64-bit constants\n\n1998-11-04  Phil Schwan  <pschwan@cmu.edu>\n\n\t* configure.in: Added 'strncasecmp' to the list of functions to be\n\tsearched for.\n\t* glib.h: Added a prototype for 'g_strncasecmp'\n\t* gstrfuncs.c: (g_strncasecmp) new function modeled closely after\n\t'g_strcasecmp'\n\nWed Nov  4 15:06:44 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* config.h.win32 (new file)\n\t* glibconfig.h.win32\n\t* glib.def\n\t* makefile.msc: applied glib-tml-981104, win32 sync\n\n1998-11-03  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* glib.h:\n\t* garray.c:\n\t(g_array_remove_index): new function for removing an entry from an\n\tarray while preserving the order\n\t(g_array_remove_index_fast): new function for removing an entry\n\tfrom an array. the order might be distorted\n\t(g_ptr_array_remove_index_fast, g_ptr_array_remove_fast): new\n\tfunctions; working similiar to the above. (they have the semantic\n\tof the old g_ptr_array_remove[_index] functions)\n\t(g_ptr_array_remove_index, g_ptr_array_remove): new semantic. now\n\tthe order of the elements in the array is not changed\n\t(g_byte_array_remove_index, g_byte_array_remove_index_fast): new\n\tfunctions; byte_array wrapper for g_array_remove_index[_fast]\n\nSun Nov  1 23:00:18 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h\n\t* configure.in: endian macros defined using the glibconfig.h\n\tmechanism now\n\n\t* ghook.c: casts for GHookFunc and GHookCheckFunc to avoid warnings\n\nSat Oct 31 20:14:22 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* applied glib-tml-981101-1 patch from Tor Lillqvist (ChangeLog\n\tentry appended below)\n\n\t* testglib.c\n\t* gstrfuncs.c\n\t* glib.h: use G_HAVE_GINT64, since HAVE_GINT64 is gone\n\n\t* gmessages.c\n\t* gscanner.c: #include <config.h> in here too, for HAVE_UNISTD_H\n\n1998-11-01 Tor Lillqvist <tml@iki.fi>\n\n\t* glib.def: Added the new functions.\n\n\t* gutils.c:\n\t(g_getenv): Better implementation on Win32. No loop necessary.\n\t(g_get_any_init): Use P_tmpdir if defined as tmp directory. Don't\n\tset home dir always to NULL on Win32.  Don't use tmp directory as\n\tlast resort home directory, but return NULL if no home\n\tdirectory is known (application must check).\n\n\t* makefile.msc: Better touch command, just COPYing a single file\n\tsets the timestamp from that file, which isn't what touching should\n\tdo.\n\n1998-10-31  Raja R Harinath  <harinath@cs.umn.edu>\n\n\tLand glib-rrh-19981025-0.patch.\n\t* Makefile.am (glibconfig.h): New rule.\n\t(stamp-gc-h): New rule.  Generate `glibconfig.h'.\n\t* configure.in (AM_CONFIG_HEADER): It is now `config.h'.\n\t(HAVE_BROKEN_WCTYPE): On Solaris, look for iswalnum in -lw before\n\tconcluding \"broken wctype\".\n\t(glibconfig.h): Use AC_OUTPUT_COMMANDS to put generation code into\n\tconfig.status.\n\t* glib.h: Remove a lot of tests and defines.  All these have been\n\tmoved to `configure.in (glibconfig.h)'.\n\t* gerror.c: Include <config.h>.\n\t* gmem.c: Likewise.\n\t* gstrfuncs.c: Likewise.\n\t* gutils.c: Likewise.\n\nSat Oct 31 05:08:26 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: removed old G_ENUM(), G_FLAGS(), G_NV() and G_SV() macros.\n\tadded macros G_STRUCT_OFFSET(), G_STRUCT_MEMBER_P() and\n \tG_STRUCT_MEMBER() for handling structure fields through their offsets.\n\t(struct _GHookList): added a hook_free function member, that can be used\n\tto free additional fields in derived hook structures.\n\tg_hook_free(): if hook_list->hook_free != NULL, call this function prior\n\tto freeing the hook. (this functionality should have been there in the\n\tfirst place, it just got forgotten as an implementation detail).\n\nWed Oct 28 00:49:32 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h: G_BREAKPOINT for alpha from Robert Wilhelm\n\t<robert@physiol.med.tu-muenchen.de>\n\nTue Oct 27 07:25:53 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gscanner.c:\n\t(g_scanner_sync_file_offset): new function for file input.\n\trewind the filedescriptor to the current buffer position and blow\n \tthe file read ahead buffer. usefull for third party uses of our\n \tfiledescriptor, which hooks onto the current scanning position.\n\t(this became neccessary with the implementation of buffered\n\treads).\n\t(g_scanner_input_file):\n\t(g_scanner_input_text): automatically blow the read ahead buffer.\n\t(g_scanner_get_char): blow the read ahead buffer when the end of\n\tinput is reached, i.e. a '\\000' char is read.\n\nTue Oct 27 00:27:31 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h: get rid of duplicate #g_htonl and friends in the\n\tNATIVE_WIN32 part\n\nMon Oct 26 22:42:01 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* glibconfig.h.win32\n\t* gutils.c\n\t* makefile.msc: win32 patch from Tor Lillqvist (glib-tml-981027-0),\n\tfixes some minor win32 buglets\n\nMon Oct 26 22:12:03 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h: reimplemented the endian stuff, using inline asm\n\tfor x86. #define g_htonl and friends.\n\n\t* testglib.c: new tests for the endian stuff\n\n\t* configure.in: care for AIX in gmodule linker flags test (from\n\tJoel Becker <jlbec@raleigh.ibm.com>). Check $host_os for linux\n\tinstead of existance of /usr/include/linux\n\n\t* gutils.c: buh-bye evil warning. Thou hast been #ifdef'd out\n\tof thine existance!\n\nTue Oct 27 03:00:50 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: removed dummy structure definitions for struct _GCache,\n \t_GTree, _GTimer, _GMemChunk, _GListAllocator and _GStringChunk.\n\n\t* gutils.c: implement glib's inline functions _after_ all include\n \tstatements have been processed.\n\tremoved Tor's MAXPATHLEN check since there already was one supplied\n\tfurther down in this file.\n\t(LibMain): special cased the #ifdef __LCC__ case for NATIVE_WIN32,\n \tsince lcc maybe used on other platforms as well. why in hell is this\n\tstuff required?\n\t(g_get_any_init): for windows, if the user name is supplied, use it as\n\trealname also.\n\tin general, if there is no homedir specified, use the tmpdir that\n\twe already figured.\n\n\t* gtimer.c (g_timer_elapsed): changed a g_assert() statement to\n \tg_return_if_fail().\n\n\t* applied glib-tml-981020-0.patch for WIN32 portability, added some\n\tcomments and g_return_if_fail() statements, minor indentation fixes.\n\tChangeLog entry from Tor Lillqvist is appended.\n\n\t* glib.h (struct dirent): use lower case structure members.\n\n\t* glib.h:\n\t* makefile.lcc:\n\t* makefile.msc:\n\ts/COMPILING_GLIB/GLIB_COMPILATION/\n\n1998-10-20: Tor Lillqvist <tml@iki.fi>\n\n\t* README.win32 glib.def gmodule.def\n\t* glibconfig.h.win32 gmodule/gmoduleconf.h.win32:\n\tNew files for the Windows port. The .def files list exported\n\tsymbols for the Microsoft linker and compatibles.\n\n\t* configure.in:\n\tAdded checks for some platform-dependent headers: pwd.h sys/param.h\n\tsys/select.h sys/time.h sys/times.h unistd.h, and the function lstat.\n\n\t* gerror.c:\n\tConditionalized inclusion of system-dependent headers. Changes\n\tfor Windows: no gdb to do a stack trace. Just call abort().\n\n\t* glib.h:\n\tChanges for Windows:\n\n\tAdded macros G_DIR_SEPARATOR, G_DIR_SEPARATOR_S for\n\tplatform-dependent file name syntax elements. Added macros\n\tG_SEARCHPATH_SEPARATOR, G_SEARCHPATH_SEPARATOR_S for\n\tplatform-dependent search path syntax conventions.\n\n\tAdded pragmas for Microsoft C to make it more pedantic.\n\n\tMarked GLib's global variables for export from DLL.\n\n\tAdded the function g_strescape that escapes backslashes.\n\n\tAdded functions g_path_is_absolute and g_path_skip_root to\n\thandle platform-dependent file name syntax.\n\n\tAdded the function g_getenv that expands environment variables\n\tthat contain references to other environment variables, as is\n\ttypical on Windows NT.\n\n\tAdded the GIOChannel structure which is used to encapsulate the\n\tIPC mechanism used by the GIMP's plug-ins, and possibly other\n\tthings later. On Unix a GIOChannel encapsulates just a file\n\tdescriptor. On Windows it contains a file handle from _pipe() and a\n\tfew other things related to the implementation of gdk_input_add\n\tand GIMP plug-in communication. Subject to change.\n\n\tRemoved duplicate declarations of the version variables.\n\n\tFor the Microsoft compiler, declare own implementation of\n\tftruncate and the <dirent.h> functions.\n\n\t* gmem.c:\n\tDefine a symbolic name  for the profiling table size.\n\n\t* gmessages.c:\n\tConditionalized inclusion of unistd.h. On Windows, output using\n\tstdio to stdout.\n\n\t* gscanner.c:\n\tConditionalized inclusion of unistd.h. Added changes for\n\tMicrosoft C. Added CR to the skipped character set. Added small\n\tworkaround for MSC compiler bug in g_scanner_cur_value.\n\n\t* gstrfuncs.c:\n\tAdded the function g_strescape, which escapes the backslash\n\tcharacter. Needed especially when printing Windows filenames.\n\n\t* gtimer.c:\n\tConditionalized inclusion of unistd.h and sys/time.h. Added\n\timplementations for Windows.\n\n\t* gutils.c:\n\tConditionalized inclusion of platform-dependent headers. Use\n\tthe platform-independent file name syntax macros.\n\tConditionalize code on platform-dependent features. Added the\n\tfunctions g_path_is_absolute g_path_skip_root and g_getenv.\n\tAdded the GIOChannel-related functions. Added\n\tcompiler-dependent Unix compatibility functions for Windows.\n\n\t* makefile.lcc makefile.msc:\n\tNew files. Compiler-specific makefiles for LCC-Win32 and\n\tMicrosoft C. Only Microsoft C is actually supported currently.\n\n\t* testglib.c:\n\tAdded pathname check cases for Windows. Added workaround for\n\tbug in the Microsoft runtime library. Improved some tests a bit.\n\nSun Oct 25 01:24:01 CST 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.1.4\n\n\t* docs/Makefile.am:\n\t* docs/.cvsignore\n\t* docs/glib-config.1:\n\t* docs/glib.texi: Moved docs from gtk and created glib-config.1\n\tfrom gtk-config.1 in gtk\n\n\t* configure.in:\n\t* Makefile.am:\n\t* sanity_check: added in docs directory, change rule 'release'\n\tto 'snapshot' and created a new 'release' rule for doing the\n\tdistribution.  Added in a 'sanity' rule.\n\n\t* NEWS:\n\t* README:\n\t* INSTALL: Updated for the release\n\nSun Oct 25 07:30:10 1998  Tim Janik  <timj@gtk.org>\n\n\t* gscanner.c:\n\t(g_scanner_peek_next_char):\n \t(g_scanner_get_char): no more characters are available if read() returns\n \tanything less than 1, not only on 0 return.\n\n\t* glib.h:\n\t* gstrfuncs.c: final API cleanup of string arrays to suit sopwith's\n\targument order requirements.\n \t(g_strsplit): renamed from g_str_array_split().\n\t(g_strjoinv): renamed from g_str_array_joinv(), string array is\n\tnow passed as last parameter. removed `const' qualifier from string\n\tarray pointer (again).\n\t(g_strjoin): new function from sopwith to concatenate strings with\n\tan additional seperator.\n\t(g_strfreev): renamed from g_str_array_free.\n\nSat Oct 24 22:23:04 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* gnode.c: small fix to g_node_children_foreach to make it work right.\n\tFrom Paco Moya <paco@cadnotebk17.eecs.berkeley.edu>\n\nWed Oct 21 19:22:58 1998  Tim Janik  <timj@gtk.org>\n\n\t* configure.in (G_MODULE_HAVE_DLERROR): reverted part of the changes\n \tfrom Sebastian Wilhelmi (1998-10-20). don't specify a specific loading\n\tbehaviour (i.e. RTLD_NOW) when we are not sure whether it is supplied.\n\tchanged the return value from (!f2 && f1) to (!f2 || f1) so we default\n\tto not needing an underscore. reverted the extra plugin.c building,\n\tbecause .lo files are not ELF libraries, this can't work. This needs\n\tfurther investigation on Solaris...\n\nWed Oct 21 17:03:05 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gstrfuncs.c: API cleanups of the new g_str* functions for consistency\n \twith the existing naming scheme for g_str* functions. grouped the g_str*\n\tfunctions that will return a newly allocated string seperatedly. all of\n\tthe in_place arguments were skipped, the caller is supposed to pass a\n\tg_strdup()ed string if he wants to retrive a new copy. indentation and\n\tcoding style fixups. added some g_return_if_fail() statements.\n\tstring array functions are prefixed with g_str_array_.\n\t(g_strdelimit): return the modified string like all other g_str*\n \tfunctions, that operate in place.\n\t(g_strchug): renamed from g_str_chug(), removed in_place argument.\n\t(g_strchomp): renamed from g_str_chomp(), removed in_place argument.\n\t(g_strstrip): renamed from g_str_strip(), removed in_place argument.\n\t(g_str_array_join): renamed from g_strconcatv(), since it actually\n \toperates on a string array and has totaly different semantics from\n\tg_strconcat(). check for separator != NULL, don't segfault if the first\n \tstring is NULL. removed the `const' from the string array that's passed,\n\tso users can operate on gchar** string arrays.\n\t(g_str_array_split): renamed from g_str_split() because we actually\n \tproduce a string array. reimplemented this function for efficiency.\n\tremoved macro aliases g_str_joinv and g_str_join.\n\n1998-10-20  Elliot Lee  <sopwith@redhat.com>\n\n\t* glib.h, gstrfuncs.c: Move string join/split/free routines from\n \tlibgnome/gnome-string, rename, and add g_str_chug.\n\n1998-10-20  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* configure.in: made the check for needed _ in module's func-names\n\twork on solaris. (G_MODULE_NEED_USCORE must be set outside\n\tAC_CACHE_VAL, dlopen(0,0) refused to work on solaris).\n\nTue Oct 20 03:32:58 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* configure.in\n\t* acconfig.h: added test for endianness\n\n\t* glib.h: #define endian macros for system and some conversions\n\tbetween byte order\n\nThu Oct  8 06:47:27 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gdataset.c: removed functions g_dataset_id_set_destroy and\n\tg_datalist_id_set_destroy and macros g_dataset_set_destroy and\n\tg_datalist_set_destroy.\n\tadded new functions g_dataset_id_remove_no_notify and\n\tg_datalist_id_remove_no_notify plus associated macros\n\tg_dataset_remove_no_notify and g_datalist_remove_no_notify, which\n \twill remove a certain data portion without invocation of its destroy\n \tnotifier, this should only be used in very controled circumstances.\n\nWed Oct  7 05:31:24 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\tremoved the #pragma } statement after extern \"C\" {. use\n \t(c-set-offset 'inextern-lang 0) to fixup emacs cc-mode indentation.\n\n\t* glib.h:\n\t* ghook.c: API and code cleanups. changed the G_HOOK_ACTIVE and\n \tG_HOOK_IN_CALL enum vals to G_HOOK_FLAG_ACTIVE and G_HOOK_FLAG_IN_CALL.\n\tchanged the G_HOOK_IS_ACTIVE() and G_HOOK_IS_IN_CALL() macros to\n\tG_HOOK_ACTIVE() and G_HOOK_IN_CALL().\n\tfixed the g_hook_find* functions, so they iterate over non-active\n\thooks as well.\n\t(g_hook_first_valid):\n\t(g_hook_next_valid): added an extra argument gboolean may_be_in_call,\n\twhich indicates whether G_HOOK_IN_CALL() hooks are considered valid\n\tor not. these two functions are meant as iterators for the hook list\n\tinvocation, so they need to a) provide functionality to implement\n\tmay_recurse bahaviour and b) only walk active hooks.\n\nTue Oct  6 14:29:47 1998  Tim Janik  <timj@gtk.org>\n\n\t* gmem.c (g_malloc0): fixed memory offsett when ENABLE_MEM_CHECK is\n\tdefined and ENABLE_MEM_PROFILE is not (patch from Martin Pool\n \t<mbp@wistful.humbug.org.au>).\n\nSat Oct  3 01:18:10 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* ghook.c:\n\t(g_hook_list_invoke):\n\t(g_hook_list_invoke):\n\t(g_hook_list_marshal): properly handle the first valid hook to call,\n\tit maybe IN_CALL already.\n\t(g_hook_list_marshal): minor name change.\n\nFri Oct  2 23:21:21 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* ghook.c: renamed GHook.id to GHook.hook_id so we don't get troubles\n\twith ObjC which reserves \"id\" as a keyword (Raja R Harinath\n \t<harinath@cs.umn.edu>).\n\nWed Sep 30 10:53:03 1998  Tim Janik  <timj@gtk.org>\n\n\t* Makefile.am: added ghook.c.\n\n\t* glib.h:\n \t* ghook.c: generic callback maintenance functions.\n\n\t* glib.h: define G_GNUC_UNUSED.\n\nFri Sep 25 00:04:37 1998  Tim Janik  <timj@gtk.org>\n\n\t* configure.in: version bump to 1.1.4, binary age 0, interface age 0.\n\n\t* glib.h (struct _GScanner): dumped peeked_char and text_len in favour\n \tof *text_end and *buffer for buffered read()s.\n\n\t* gscanner.c: changed peeking and retrival of next character so we\n\thave buffered reads. fixed minor bug with number parsing error\n\treporting. made some static!!! variables local ones (why did we use\n \tstatic temporary variables in the lowlevel tokenization code anyways?).\n\nMon Sep 21 23:23:10 CDT 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.1.3\n\nMon Sep 21 07:43:13 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: added g_renew() which works as g_new() for g_realloc().\n\nMon Sep 21 02:22:12 1998  Tim Janik  <timj@gtk.org>\n\n\t* NEWS file update for upcoming release of GLib + GModule\n\tversion 1.1.3, binary age 0, interface age 0. (GModule uses\n\tthe same version numbers as GLib.)\n\n\t* glib.h: swap the inclusion of of float.h and limits.h to work\n\taround a egcs 1.1 oddity on Solaris 2.5.1 (fix provided by\n\tPer Abrahamsen  <abraham@dina.kvl.dk>).\n\n\t* glib.h:\n\t* gscanner.c: renamed the GValue union to GTokenValue, this should\n\tnot affect source compatibility in most cases.\n\n\t* ghash.c: added some g_return_if_fail() statements. make\n \tg_hash_table_lookup_node() an inline function so we save an extra\n\tfunction invocation on lookups.\n\nSun Sep 20 18:21:46 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* ltmain.sh: Patch to libtool-1.2b to make --disable-static\n\twork.\n\nSun Sep 20 02:09:44 1998  Josh MacDonald  <jmacd@axis.hip.berkeley.edu>\n\n\t* glib.h: New function g_hash_table_foreach_remove is similar to\n \tg_hash_table_foreach, but the callback's return value indicates\n \twhether to remove the element (if TRUE) or not (if FALSE).\n\tReturns the number of elements deleted.\n\nFri Sep 18 11:31:50 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h\n\t* gstrfuncs.c: added g_memdup implementation\n\nFri Sep 18 18:46:14 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gdataset.c: make the datalists a safe type (not using a generic\n\tgpointer) by expecting a GData* argument in the g_datalist functions.\n\tprovide g_dataset_foreach() and g_datalist_foreach() functions that\n \tallow a GDataForeachFunc function to walk the data lists.\n\t(g_dataset_destroy_internal): made this function truely reentrant (i.e.\n\tcan be called from within destroy notifiers as well).\n\tthe *_foreach functions are _not_ reentrant (unless all the other\n\tdataset and datalist functions).\n\nFri Sep 18 03:41:20 1998  Tim Janik  <timj@gtk.org>\n\n\t* gtree.c (g_tree_new): check for key_compare_func != NULL (reported\n\tby Michal Kara).\n\nThu Sep 17 18:55:46 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* config.h.in: removed from repository\n\n\t* install-sh\n\t* missing\n\t* mkinstalldirs: updated to latest automake version\n\nThu Sep 17 06:36:25 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gdataset.c: implemented g_datalist_* along the lines of g_dataset,\n\tbut operates on an opaque gpointer *datalist; pointer, e.g. for the\n\timplementation of GtkObject named data.\n\twe cache a certain portion of the already freed data entries now, to\n \tgain a slight performance improve with data reallocation.\n\nTue Sep 15 14:57:30 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* Makefile.am glib-config.in l*: Update to libtool-1.2b,\n\tchange library versioning scheme to drop LT_RELEASE\n\tfrom the -l line, while keeping it in the soname.\n\nFri Sep 11 02:11:46 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: explicitely include the prototypes for inline functions\n\tto cure gcc warnings for -Wmissing-prototypes.\n\nWed Sep  9 02:52:04 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* configure.in: added -posix check for NeXTStep\n\nTue Sep  8 05:04:06 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: abandon the use of ATEXIT(), we keep the fallback\n\tmacros for backwards compatibility. people ought to use g_atexit().\n\n\t* gutils.c (g_atexit): new function to take over the implementation\n\tof ATEXIT. this function is guarranteed to succeed, similar to\n\tg_malloc().\n\nMon Sep  7 20:07:38 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* configure.in: comment the -std1 check and save LIBS properly\n\nMon Sep  7 07:53:21 1998  Tim Janik  <timj@gtk.org>\n\n\t* configure.in: check for all three inline keywords individually.\n\n\t* glib.h: inlining hassle. for compilers that don't allow the `inline'\n \tkeyword, mostly because of strict ANSI C compliance or dumbness, we try\n \tto fall back to either `__inline__' or `__inline'.\n\twe define G_CAN_INLINE, if the compiler seems to be actually *capable*\n \tto do function inlining, in which case inline function bodys do make\n \tsense. we also define G_INLINE_FUNC to properly export the function\n \tprototypes if no inlinig can be performed. we special case most of the\n \tstuff, so inline functions can have a normal implementation by defining\n \tG_INLINE_FUNC to extern and G_CAN_INLINE to 1.\n\n\t* ltconfig: (compiler PIC flag test): special case linux for non\n\taout systems to honour lcc's position independant code (cases\n\t\"linux*aout)\" and \"linux*)\" got added). (this needs to go into\n\tlibtool which does an advanced test, checking for __LCC__).\n\n\t* autogen.sh: take $CC=lcc into account by invoking automake with\n\t--include-deps so lcc isn't scared by gcc's auto-dependancy\n\tgeneration code. care about $ACLOCAL_FLAGS. optionally feature\n\tautoheader.\n\n\t* minor fixups in other places to cure some of lcc's warnings.\n\nSun Sep  6 19:08:53 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* configure.in: added -std1 check for ANSI compliance (from gtk)\n\nSun Sep  6 12:31:50 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h: provide proper ATEXIT behavior on NeXTStep by !atexit\n\nSat Sep  5 18:03:36 1998  Tom Tromey  <tromey@cygnus.com>\n\n\t* gutils.c (GLIB_INLINE): Define.\n\t* glib.h (GLIB_INLINE): New define.\n\t(g_bit_nth_msf): Use it.  Also, add prototype.\n\t(g_bit_storage): Likewise.\n\t(g_bit_storage): Likewise.\n\nSat Sep  5 04:40:02 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t(g_chunk_new0): use g_mem_chunk_alloc0() to allocate the memchunk,\n\tso the correct size of the memchunk is allocated with 0's and not\n\ta memory portion of the size of the desired type.\n\n\t* gmem.c: new function g_mem_chunk_alloc0() which will initialize\n\ta memory area allocated with g_mem_chunk_alloc() with 0's.\n\nWed Sep  2 19:13:28 1998  Owen Taylor  <otaylor@redhat.com>\n\n\t* garray.c glib.h (g_array_[ap/pre]pend_vals): make\n\tdata argument const.\n\nWed Aug 26 06:32:40 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gstrfuncs.c: new function g_strnfill() to return a new string\n\tof specified length, filled with a specific character.\n\nTue Sep  1 23:46:31 1998  Josh MacDonald  <jmacd@axis.hip.berkeley.edu>\n\n\t* testglib.c (main): Update the array tests.  Reduce the number of\n\titerations for the prepend test from 10000 to 100 since it is\n\tO(n^2) and was taking longer than I would like to wait.\n\n\t* garray.c: I've worked on the GArray interface, mostly.  It was\n \tseriously broken before and I hate to do it, but this is going to\n \tbreak some code.  It is important to do this now, because more and\n \tmore people are starting to use glib and the interface was both\n \tbroken and inconsistent.  First, rename the _truncate functions of\n \tboth the GArray and GPtrArray classes to _set_size, since this\n \tfunction can also be used to extend the arrays.  GArray now\n \taccepts two more initialization arguments: clear and element_size.\n  \tInstead of providing the type to each access function, the array\n \tnow stores the element size.  Clear, if set, causes the library to\n \tzero element's memory as the array expands.  The major broken-ness\n \there was that array->len was in bytes, not elements.  Now, since\n \tthe array knows its element size, array->len is correct and I have\n \tremoved the g_array_length macro.  The only macro which now\n \taccepts the type as an argument is g_array_index, which casts the\n \telement to the right type--this interface does not change.  The\n \tappend and prepend functions simply need the types removed.\n  \tg_ptr_array_remove_index now returns the removed element.\n\n\t* gprimes.c (g_spaced_primes_closest): Move this function out of\n \tghash.c and rename it from g_hash_closest_prime.  Fix the primes\n \tso that they are actually prime (they weren't all -- isn't that\n \tnice?).\n\nMon Aug 24 02:08:56 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n \t* gstring.c:\n\t* gstrfuncs.c:\n \t(g_vsprintf): removed this function which was not publically\n\texported in glib.h. to export it, it should have been named\n \tdifferently in the first place, since its semantics differ from\n \tvsprintf(). apart from that, it was a possible cause for\n\tproblems since it worked on a previously allocated memory area and\n\twas used in a lot places of glib. exporting it would have been a\n\tguararant for problems with threaded programs.\n\t(g_printf_string_upper_bound): exported this function to return\n\ta string size, guarranteed to be big enough to hold the fully\n \texpanded format+args string. added 'q', 'L' and 'll' flag handling.\n \tin fact, the newly allocated area is in most cases much bigger than\n \trequired.\n\t(g_strdup_vprintf()): new function returning a newly allocated string\n \tcontaining the contents of *format and associated args (size is\n\tcalculated with g_printf_string_upper_bound()).\n\t(g_strdup_printf): new function which wraps g_strdup_vprintf().\n\n\t* configure.in: check for va_copy() or __va_copy() alternatively.\n\tcheck whether va_lists can be copyied by value.\n\n\t* glib.h: provide a definition for G_VA_COPY.\n\n\t* glib.h:\n\t* gmessages.c:\n \t(g_logv):\n\t(g_vsnprintf):\n\tpass va_lists by value, not by reference, since this causes problems\n\ton platforms that implement va_list as as arrays. internaly, use\n\tG_VA_COPY (new_arg, org_arg); va_end (new_arg); to produce a second\n\tva_list variable, if multiple passes are required. changed all\n\tcallers.\n\n\t* glib.h:\n\t* gerror.h:\n\trenamed g_debug() to g_on_error_query(), cleaned up a bit.\n\trenamed g_stack_trace() to g_on_error_stack_trace() since both\n\tfunctions cluttered different namespaces.\n\tthere is an appropriate comment in glib.h now that explains the\n\tunix and gdb specific dependencies of both functions.\n\tremoved g_attach_process().\n\tg_on_error_stack_trace() should probably be handled with caution,\n\ti've seem several different linux versions (2.0.x) become unstable\n\tafter invocation of this function.\n\n1998-08-18: Elliot Lee <sopwith@redhat.com>\n\n\t* In gmem.c, add the ability to exclude memory chunks from the\n \t  memory profiling information.\n\nTue Aug 18 18:23:09 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h\n\t* gstrfuncs.c: added g_strndup\n\nTue Aug 18 04:40:17 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gmessages.c: new function g_log_set_always_fatal() to set an\n\tadditional fatal_mask for log levels that are considered to be fatal\n\tglobally (required by gtk). since this mask is not domain-associated,\n\tit is restricted to the log levels, introduced by glib itself.\n\n\t* gmem.c:\n\t* grel.c:\n\t* gtree.c (g_tree_node_check):\n\tdon't use g_print() calls for informational/debugging output,\n\tbut log all this stuff through g_log() with G_LOG_LEVEL_INFO.\n\tlibraries shouldn't use printf(), g_print() or g_printerr() at all.\n\nTue Aug 18 02:46:44 1998  Tim Janik  <timj@gtk.org>\n\n\n\t* glib.h (__STRICT_ANSI__): if __STRICT_ANSI__ is defined, make\n\t`inline' a noop, since strict ANSI rules don't permit `inline'.\n\nMon Aug 17 15:21:42 1998  Tim Janik  <timj@gtk.org>\n\n\t* grel.c: made private functions static.\n\nSun Aug 16 23:23:46 CDT 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* gmodule/Makefile.am: added gmodule-dl.c and gmodule-dld.c to\n\t  EXTRA_DIST\n\t* glib.spec: version = 1.1.3\n\nMon Aug 17 01:46:14 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.m4: feature an extra MODULES parameter, so glib-config can\n\tbe invoked with the \"gmodule\" argument.\n\n\t* glib.h: changed the log level to G_LOG_LEVEL_CRITICAL for all\n \tg_return*_if_fail statements, and made them issue a message\n\tlike \"assertion `%s' failed\".\n\n\t* gmessages.c (g_logv): ugh, don't pass log_domain as NULL to\n \tg_log_find_domain.\n\nSun Aug 16 20:28:27 1998  Tim Janik  <timj@gtk.org>\n\n        * version bump to 1.1.3, binary age 0, interface age 0.\n\n\t* glib.h: be nice to platforms that don't have gint64 and don't\n\tissue #warning on every compilation. since glib doesn't require\n\tgint64 itself, packages that need gint64 should test for this\n \tthemselves.\n\n\t* glib.h:\n\t* gutils.c: added a new function g_vsnprintf().\n\nSun Aug 16 Elliot Lee\n\n\tglib.h: #error out if we don't recognize the SIZEOF_VOID_P\n\t        #warning if no gint64\n\nFri Aug 14 16:41:53 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: added static inline functions for bit mask tests:\n\tg_bit_nth_lsf, g_bit_nth_msf and g_bit_storage.\n\nFri Aug 13 14:23:37 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gmessages.c:\n\trevised the message handling system, which is now based on a new\n \tmechanism g_log*. most of the assertment macros got adapted to\n\tfeature the new g_log() call with an additional specification of\n\tthe log level in a preprocessor macro G_LOG_DOMAIN. if G_LOG_DOMAIN\n\tis undefined upon the includion of glib.h, it'll be defined with a\n\tvalue of (NULL) and thus preserves the original bahaviour for\n\twarning and error messages. the message handler setting functions\n\tfor g_warning, g_error and g_message are only provided for backwards\n\tcompatibility and might get removed somewhen.\n\n\t* Makefile.am: feature the G_LOG_DOMAIN macro to set the log domain\n\tto \"GLib\" upon compilation. we currently have to add this definition\n\tto the DEFS variable.\n\t* testglib.c: we need an ugly #undef G_LOG_DOMAIN at the start\n\tof this file currently, since automake doesn't support per target\n\t_CFLAGS yet.\n\n\t* glib.h: changed some gints to gbooleans, made a few const corrections,\n\tremoved some superfluous G_STMT_START{}G_STMT_END wrappers, added some\n\tin other required places.\n\n\t* gnode.c:\n \t(g_node_prepend):\n\t(g_node_insert_before):\n\t(g_node_insert):\n\t(g_node_append_data):\n\t(g_node_prepend_data):\n\t(g_node_insert_data_before):\n\t(g_node_insert_data):\n\t(g_node_append):\n\treturn (node), so these macros/functions can be usefully chained with\n\tg_node_new().\n\nMon Aug 10 17:56:11 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h: it's GTime now, and it's back!\n\nMon Aug 10 02:17:19 1998  Tim Janik  <timj@gtk.org>\n\n\t* Makefile.am: minor hack to cause SUBDIRS (gmodule) to be build\n\tlast. we do this by making all-recursive-am depend on all-am.\n\nSun Aug  9 15:56:11 1998  Tim Janik  <timj@gtk.org>\n\n\t* configure.in: added GModule checks. generate files in gmodule/.\n\t* glib-config.in: support library specifications `glib' and `gmodule'.\n\t* Makefile.am: feature the gmodule/ subdir.\n\nWed Aug  5 10:04:29 PDT 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.1.2\n\nWed Aug 05 01:15:36 1998  George Lebl  <jirka@5z.com>\n\n\t* testglib.c: fix 64-bitness in g_prints, sizeof doesn't\n\t  seem to return int so I cast it for printing, probably\n\t  just cosmetic\n\nTue Aug  4 19:54:06 PDT 1998 Shawn T. Amundson <amundson@gkt.org>\n\n\t* Released GLib 1.1.1\n\nTue Aug  4 15:17:54 1998  Tim Janik  <timj@gtk.org>\n\n\t* configure.in: version bump to 1.1.1, binary age 1, interface age 0.\n\t* NEWS: updates.\n\t* README: updates.\n\t* INSTALL: updates and fixes.\n\t* COPYING: include the GNU LGPL, rather than shipping an empty file.\n\t* AUTHORS: listed original authors here, and added people who made\n\tsignificant improvements to glib.\n\n\t* glib.h:\n\t* gutils.c: implement g_get_current_dir() which returns a newly\n\tallocated string, instead of a g_getcwd() variant that operates\n\ton a static buffer.\n\texport glib_interface_age and glib_binary_age.\n\tas a convenience, macro definitions have been added for\n \tg_node_insert_data, g_node_insert_data_before, g_node_append_data and\n\tg_node_prepend_data.\n\n\t* testglib.c: minor cleanups, print current dir.\n\nMon Aug  3 16:02:26 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gnode.c: change order of gpointer data; field in struct _GNode to\n\tbe partly binary compatible with GList and GSList.\n\n1998-08-03  Sebastian Wilhelmi  <wilhelmi@ira.uka.de>\n\n\t* garray.c (g_ptr_array_remove_index): bugfix: index check for\n\tarray has been wrong.\n\nFri Jul 31 22:17:05 1998  Tim Janik  <timj@gtk.org>\n\n\t* testglib.c (g_node_test): added a GNode test.\n\nFri Jul 31 09:08:16 1998  Tim Janik  <timj@gtk.org>\n\n\t* Makefile.am: compile gnode.c.\n\n\t* glib.h:\n\t* gnode.c: added implementation of n-way trees.\n\n\t* gtree.c (g_tree_traverse): added a warning to the switch() statement\n\twhich says that G_LEVEL_ORDER is not implemented.\n\nMon Jul 27 00:17:30 CDT 1998 Shawn T. Amundson <amundson@gtk.org>\n\n\t* Released GLib 1.1.0\n\nMon Jul 27 01:02:27 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: #if 0'ed out the GTime definition, until it is definitively\n \tneeded. #if 0'ed out the g_getcwd() version, because it is the wrong\n \timplementation.\n\nSat Jul 25 16:09:00 1998  Mark Crichton <crichton@expert.cc.purdue.edu>\n\n\t* glib.h: gtime changed to g_time.  gtime is used in\n\t/usr/include/time.h in NetBSD, causing multiple headaches.\n\tIf this isn't the right way of fixing it.... ;)\n\nThu Jul 23 00:29:14 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gscanner.c: new functions to make a scanner scope sensitive wrt\n \tsymbol lookups.\n\tg_scanner_scope_foreach_symbol, g_scanner_scope_lookup_symbol,\n\tg_scanner_scope_remove_symbol, g_scanner_scope_add_symbol and\n\tg_scanner_set_scope.\n\tg_scanner_add_symbol, g_scanner_remove_symbol and\n \tg_scanner_foreach_symbol are now aliases for scope 0.\n\nMon Jul 20 23:05:34 1998  George Lebl  <jirka@5z.com>\n\n\t* glib.h: typo fixed for alphas for gint64\n\nTue Jul 14 09:05:18 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gutils.c: new fuction g_dirname() which returns a newlly\n\tallocated string.\n\nFri Jul 10 06:33:43 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h:\n\t* gutils.h: added a bunch of utility/wrapper functions:\n\tg_basename(), g_getcwd(), g_get_user_name(), g_get_real_name(),\n\tg_get_home_dir(), g_get_tmp_dir(), g_get_prgname() and g_set_prgname().\n\n\t* gutils.c: removed all g_str* functions.\n\t* gstrfuncs.c: moved the bunch g_str* functions from gutils.c in this\n\tplace. this file shall never include <unistd.h> to avoid clashes for\n\tsome of the g_str* functions on some OSes.\n\nFri Jul 10 00:29:03 EEST 1998 Lauri Alanko <nether@gimp.org>\n\n\t* glib.h:\n\t* ghash.c: Renamed g_hash_table_lookup_full to\n\tg_hash_table_lookup_extended to conform with naming conventions.\n\nTue Jul  7 03:18:58 EEST 1998 Lauri Alanko <nether@gimp.org>\n\n\t* glib.h:\n\t* ghash.c: Generic cleanup, added a function:\n\t(g_hash_table_lookup_full): Return whether the lookup succeeded,\n\tand also retrieve the key and value. This allows one to\n\tdistinguish between failed lookup and finding a NULL, and also\n\tallows one to free a key in the hash.\n\nMon Jul  6 10:12:05 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* ltconfig: fix for properly detecting shared lib support on\n\tSunPro cc (taken from libtool 1.2.a)\n\nSat Jul  4 13:38:52 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h: added g_array_length\n\nTue Jun 30 11:58:25 1998  Tim Janik  <timj@gtk.org>\n\n\t* gscanner.c (g_scanner_unexp_token): take symbol_2_token into\n\taccount. react on valid/invalid string pairs.\n\nSat Jun 27 21:55:46 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.m4: ftp.glib.org -> ftp.gtk.org, since glib.org isn't\n\tours. ;)\n\nFri Jun 19 03:11:02 1998  Tim Janik  <timj@gtk.org>\n\n\t* gdataset.c: removed g_dataset_try_key, g_dataset_force_id and\n \tg_dataset_retrive_key in favour of GQuarks.\n\ta GQuark is an numeric id wich is associated with a certain string.\n\t(g_quark_try_string): try to get the quark associated with this string,\n \tif the lookup failed return 0.\n\t(g_quark_from_string): get the associated quark for a string, if there\n \tisn't currently a GQuark associated with this string, then allocate a\n \tnew quark and return that.\n\t(g_quark_from_static_string): like the above function, but the string\n \tisn't strdup()ed to save memory.\n\t(g_quark_to_string): get the string that is associated with a certain\n\tGQuark.\n\n\t* gdataset.c (g_dataset_id_set_data_full): invoke the destroy function\n\t_after_ the new data has been setup.\n\nThu Jun 18 02:35:21 1998  Owen Taylor  <otaylor@gtk.org>\n\n\t* glib.h: Changed messages for g_return_[val]_if_fail to\n\tbe somewhat more clear: assertion \"blah\" failed.\n\n1998-06-18  Federico Mena Quintero  <federico@nuclecu.unam.mx>\n\n\t* testglib.c (main): Use GINT_TO_POINTER casts to remove compiler\n\twarnings.\n\n\t* grel.c: #include <string.h>\n\nFri Jun 12 15:39:06 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h (GScanner): cleanups of the structure fields (binary\n\tincompatible).\n\nFri Jun 12 00:39:28 1998  Josh MacDonald  <jmacd@icw.EECS.Berkeley.EDU>\n\n\t* glib.h: add new hash and equal functions g_int_*.  complement\n\tg_direct_hash with g_direct_equal.\n\n\t* grel.c: new file, GRelations implement tuples of N-N mappings.\n\tA comment in glib.h briefly describes the interface.\n\n\t* ghash.c: new function, g_hash_table_size\n\n\t* glib.h: new typedefs, gsize, gssize, gtime.\n\n\t* garray.c: new functions implementing a simplified GArray.  This\n\tGPtrArray is an array of gpointers and has functions to add and\n\tremove elements, much like java.lang.Vector.\n\n\t* garray.c: new functions for the single-byte special case of\n\tGArray.  The functions g_byte_array* operate on arrays of bytes.\n\tInternally, a GArray is used.\n\n\t* testglib.c: tests for g_ptr_array, g_byte_array, and g_relation...\n\n1998-06-11  Federico Mena Quintero  <federico@nuclecu.unam.mx>\n\n\t* gdataset.c: #include <string.h>\n\nThu Jun 11 04:15:31 1998  Tim Janik  <timj@gtk.org>\n\n        * glib.h:\n        * gdataset.c: new function g_dataset_retrive_key. adjusted prealloc\n        sizes, to take up less space on initial allocation.\n\n1998-06-10  Raja R Harinath  <harinath@cs.umn.edu>\n\n\t* acinclude.m4: New file.  Contains `libtool.m4' from libtool-1.2,\n\tthe version from which glib's libtool forked.  Needed for people\n\twho use post-1.2 alphas of libtool.\n\t* configure.in (enable_mem_check, enable_mem_profile): Replace\n\t`echo -n' with AC_MSG_CHECKING.\n\t(fd_set): Explain test for `fd_set' better.\n\nWed Jun 10 19:29:51 1998  Owen Taylor  <otaylor@gtk.org>\n\n\t* Makefile.am glib.m4 configure.in:\n\n\tMoved out from GTK+; added AM_PATH_GLIB macro.\n\nWed Jun 10 12:56:07 1998  Owen Taylor  <otaylor@gtk.org>\n\n\t* glib.h: renamed g_const_pointer => gconstpointer\n\nTue Jun  9 17:47:33 1998  Owen Taylor  <otaylor@gtk.org>\n\n\t* glib.h: Remove #error - HP/UX.\n\nSat May 23 19:00:01 1998  Owen Taylor  <otaylor@gtk.org>\n  [ Combination of:\n     gtk-rrh-980412-0.patch (Raja R Harinath <harinath@cs.umn.edu>)\n     gtk-jbuhler-980516-0 (Jeremy Buhler <jbuhler@cs.washington.edu>) ]\n\n\t* glib.h ghash.c gstring.c gdataset.c gutils.c:\n\t- Added new typedef g_const_pointer; expunged all incorrect\n\t  uses of 'const gpointer'.\n\t- Fixed up warnings that that created,\n\t- Changed GHashFunc and GCompareFunc to take g_const_pointer\n\t  arguments. (Necessary, but will cause warnings in existing\n\t  code until fixed)\n\t- Added other new const in harmless positions.\n\nMon Jun  8 01:06:47 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: added enum-helper macros for code generation.\n\tadded G_BREAKPOINT().\n\nSat Jun  6 14:09:22 PDT 1998 Manish Singh <yosh@gimp.org>\n\n\t* gmem.c: commented out MEM_PROFILE and MEM_CHECK, causing weird\n\tproblems\n\nWed Jun  3 06:19:42 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h (g_chunk_new0): convenience macro, for allocating small chunks\n\tlike g_chunk_new() with additional 0 initialization.\n\nMon Jun  1 04:43:27 1998  Tim Janik  <timj@gtk.org>\n\n\t* ghash.c (g_hash_table_insert): wrote a comment describing why\n\ta hash node's key should not also get replaced when overriding\n \tprevious entries.\n\nTue May 26 18:30:06 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h (g_string_sized_new): new function to controll the preallocated\n\tsize of a GString.\n\n\t* glib.h (g_strreversed): new function to reverse a string.\n\nMon May 18 22:14:39 1998  Owen Taylor  <otaylor@gtk.org>\n(Yasuhiro SHIRASAKI <joke@awa.tohoku.ac.jp> : gtk-joke-980517-0.patch)\n\n\t* gutils.c: Restored a missing prototype for g_vsprintf.\n\nWed May 20 05:02:26 1998  Tim Janik  <timj@gtk.org>\n\n        * glib.h: conditionally define NULL, FALSE and TRUE.\n        (g_mem_chunk_create): new convenience macro as a short hand for\n        g_mem_chunk_new().\n        (g_chunk_free): new convenience macro to be consistent with g_chunk_new.\n\nTue, 19 May 1998 09:00:02 +0200  Paolo Molaro <lupus@debian.org>\n\n\t* gcompletion.c: generic functions for com<TAB>pletion...\n\nSun May 17 10:48:27 1998  Tim Janik  <timj@gtk.org>\n\n\t* gscanner.c (g_scanner_unexp_token): provide usefull default\n \tspecifications for identifier_spec and symbol_spec.\n\n\t* glib.h: new functions g_slist_nth_data and g_list_nth_data to return\n \tthe data of the nth element in the list.\n\nFri May 15 22:31:49 1998  Tim Janik  <timj@gtk.org>\n\n\t* gscanner.c (g_scanner_unexp_token): removed spurious va_end(args)\n \tthat for some reason didn't produce a compiler warning on my machine\n \t(is va_end defined to nothing for i386?).\n\nFri May 15 12:32:08 1998  rodo  <doulik@karlin.mff.cuni.cz>\n\n\t* gscanner.c: replaced some snprintf with g_snprintf\n\nFri May 15 00:56:59 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: further support for gcc function attributes: G_GNUC_FORMAT,\n\tG_GNUC_NORETURN and G_GNUC_CONST.\n\n\t* gscanner.c (g_scanner_stat_mode): changed stat() to lstat().\n\t(g_scanner_msg_handler): \"\\n\" at end of line!\n\t(g_scanner_foreach_symbol): new function to iterate over the symbol\n \ttable (GScanner does value-wrapping).\n\nThu May 14 04:14:12 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h: typedef gint gboolean;\n\tthis is needed to provide portability with big-endian platforms (e.g.\n\ttry sizeof(bool) for c++ on big-endians - it's 4).\n\tthis is also needed to maintain some_union.d_gint==some_union.d_gboolean.\n \tplus, gint to gboolean casts and vice versa need to be possible without\n \tloss.\n\nTue May 12 19:22:58 1998  Owen Taylor  <otaylor@gtk.org>\n\n \t* glib/glib.h: Added macros G[U]INT_TO_POINTER() and\n\tGPOINTER_TO_[U]INT for storing small integers integers\n\tinside pointers.\n\n\t* glib/testglib.c: Print sizeof() results\n\tas g_print(\"%ld\", (glong)sizeof(foo)), to deal with\n\tsize_t being long on Alpha's.\n\nTue May 12 16:54:15 1998  Owen Taylor  <otaylor@gtk.org>\n\t(James A <jamesa@demon.net> : gtk-jamesa-980511-4.patch)\n\n\t* glib.h gstring.c gmessages.c: Added some missing\n\tconst to arguments.\n\n\t* gutils.c (g_strsignal.c): Added missing return statements.\n\nMon May 11 21:11:54 1998  Owen Taylor  <otaylor@gtk.org>\n\n\t* gutils.c gmessages.c: Moved g_error, g_warning, g_message and\n\tg_print from gutils.c to new file gmessages.c, to avoid having to\n\tinclude <unistd.h> in gutils.c which was causing problems for the\n\tg_strsignal implementation on FreeBSD boxes.\n\nMon May 11 09:53:43 1998  Tim Janik  <timj@gtk.org>\n\n\t* configure.in: preserve automake CFLAGS.\n\n\t* Makefile.am: fully rename the created library to libglib-1.1.la.\n\tthis means we need to change certain portions of the Makefile.am on\n\tmajor/minor version bumps.\n\n\t* ltmain.sh: the -release option is not required anymore.\n\n        * glib.h: provide G_GNUC_FUNCTION and G_GNUC_PRETTY_FUNCTION to\n\tavoid conditionals. unconditionally define NULL, TRUE, FALSE, MAX,\n\tMIN, ABS and CLAMP, these macros might be screwed from other headers.\n\nMon May 11 01:44:10 1998  Tim Janik  <timj@gtk.org>\n\n\t* gdataset.c: new file, gdatasets implement the object data\n\tmechanism from GtkObject. a generic data pointer is associated with\n\ta certain location and a key id.\n\nSat May  9 20:08:12 1998  Owen Taylor  <otaylor@gtk.org>\n\n        * glib/gmem.c: Experimentally restore GMemChunk\n        to its primeval state - where mem areas are\n        freed incrementally instead of searching the tree\n        every time a mem area is completely empty. Also,\n        always keep one mem chunk around. (Reduced calls\n        to malloc() a lot, but doesn't really improve\n        performance significiantly)\n\nThu May  7 08:17:28 1998  Tim Janik  <timj@gtk.org>\n\n\t* glib.h (G_GNUC_PRINTF):\n\t(G_GNUC_SCANF): macros to facilitate the printf/scanf format argument\n\tchecking of gcc.\n\n\t* gstring.c: const corrections, string!=NULL checks at function entry.\n\t(g_string_down): new function for tolower(3) conversion.\n\t(g_string_up): new function for toupper(3) conversion.\n\n\t* gutils.c: const corrections.\n\t(g_strdown): g_string_down() counterpart.\n\t(g_strup): g_string_up() counterpart.\n\n\t* gscanner.c (g_scanner_unexp_token):\n \t(g_scanner_error):\n\t(g_scanner_warn): new functions to let a scanner put out warnings\n \tor errors, especially to react on unexpected tokens.\n\n\t* gslist.c:\n \t(g_slist_index): find out about about the position of a\n\tcertain data pointer.\n \t(g_slist_position): find out about about the position of a\n\tcertain node.\n\n\t* glist.c:\n \t(g_list_index): find out about about the position of a\n\tcertain data pointer.\n\nThu May  7 05:14:19 1998  Tim Janik  <timj@gtk.org>\n\n\t* ltmain.sh: added a new commandline flag -postfix similar to -release,\n\tbut will immediately change the library name.\n\n\t* Makefile.am: specify -postfix and -version-info\n\n\t* configure.in: version bump to 1.1.0. added GLIB_INTERFACE_AGE and\n\tGLIB_BINARY_AGE. calculate LT_* variables for libtool.\n\nFri May  1 16:36:08 1998  Owen Taylor  <otaylor@gtk.org>\n\n\t* gutils.c: (g_strcasecmp). Check for isupper before\n\ttaking tolower, and account for macroized tolower.\n\n\t* gutils.c (g_error): Check for recursion.\n\n1998-04-27  Elliot Lee  <sopwith@cuc.ml.org>\n\n\t* glist.c (g_list_position): New function to find the position of\n\ta link in a list - should be the inverse of g_list_nth(), but\n\thaven't tested it so poof.\n\nThu Apr 30 21:41:30 1998  Owen Taylor  <otaylor@gtk.org>\n\n\t* gstring.c : Check arguments more carefully,\n\t(gtk-draco-980423-1.patch; ramsey@rhrk.uni-kl.de)\n\nTue Apr  7 19:36:48 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* gutils.c (g_direct_compare): Removed, because that's what\n\ta NULL comparison function means. And it wasn't 64 bit safe.\n\nMon Apr  6 18:43:25 1998  Tim Janik  <timj@gtk.org>\n\n\t* gscanner.c (g_scanner_get_token_ll): fixed a bug that caused floats\n\tof the format \".xxx\" to be parsed as \"xxx\".\n\nFri Apr  3 20:36:35 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* gutils.c (g_parse_debug_string): Make debug string\n\tparsine case-insensitive\n\nFri Apr  3 17:03:18 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* gstring.c: corrected possible overrun when inserting into\n\tGStrings (thanks Elrond)\n\nFri Apr  3 18:05:45 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* testglib.c: Removed literal german from strings\n\tto appease SGI compiler.\n\nThu Mar 26 20:47:21 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* configure.in glib glibconfig.h.in: Add test for atexit/on_exit -\n\tuse on_exit if atexit not found in definition of ATEXIT.\n\nWed Mar 25 15:23:37 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* Makefile.am: Switched glibconfig.h rule from HEADERS\n\tto DATA, so that it is not added to DISTFILES\n\nWed Mar 18 22:27:08 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* garray.c: g_rarray_truncate length done correctly\n\nSun Mar 15 07:13:34 1998  Tim Janik  <timj@gimp.org>\n\n\t* gutils.c: changed *_handler variables to be named glib_*_handler,\n\tso you can easily access them from gdb.\n\nSat Mar 14 17:47:43 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* Makefile.am: Don't refer to current directory as $(top_builddir)\n\tto avoid confusing non-gmakes\n\nSat Mar 14 01:37:35 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* Makefile.am (configincludedir): Moved glibconfig.h to\n          $(pkglibdir)/include\n\nTue Mar 10 02:03:12 1998  Tim Janik  <timj@gimp.org>\n\n\t* gscanner.c (g_scanner_destroy_symbol_table_entry): new function to\n\tfree symbol table entries upon destruction\n \t(gtk-gronlund-980309-0.patch.gz).\n\nMon Mar  9 15:02:21 1998  Tim Janik  <timj@gimp.org>\n\n\t* glib.h: changed *_length functions to return guint.\n\tchanged *_nth functions to take guint as argument.\n\n\t* glist.c: adapted g_list_length and g_list_length.\n\n\t* gslist.c: adapted g_slist_length and g_slist_length.\n\nMon Mar  2 17:51:18 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* glib.h gutils.c : changed g_strcasecmp\n\t  to take gchar* not guchar*\n\n\t* testglib.c: Remove trailing ; after functions\n\nSun Mar  1 19:04:40 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* glib.h gstring.c: Added g_string_insert[_c]()\n\t  and g_string_erase().\n\n\t  From: Stefan Wille  <1wille@vsys1.informatik.uni-hamburg.de>\n\nMon Feb 16 23:05:06 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* glist.c (g_list_insert_sorted): Changed function\n\t  so elements are always inserted, even if they compare\n\t  equal with another.\n\nThu Feb 12 22:48:11 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* gstring.c glib.h: removed deprecated g_string_equal\n\t  and g_string_hash.\n\nTue Feb 10 13:04:36 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* configure.in: Add check to see if the C library's\n\t  iswalnum can actually be used. (Not true for\n\t  Linux libc-5.4.38)\n\nSat Feb  7 11:48:09 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* gstring.c gutils.c: added some additional consts in\n\t  appropriate places to remove a warning\n\nSat Feb  7 11:15:54 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* gutils.c: include <ctype.h> for tolower()\n\nFri Jan 30 23:57:17 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* added and autoconfigured in a new utility function\n\tg_strcasecmp\n\nWed Jan 28 23:53:27 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* glist.c\n\t* gslist.c\n\t* testglib.c: the sort functions compared backwards. Fixed\n\t* glib.h: list iterator macros now check for NULL pointers\n\nTue Jan 27 09:46:57 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* gstring.c: g_string_prepend and g_string_prepend_c had\n\tinterchanged src and dest parameters for g_memmove. Fixed.\n\nTue Jan 27 01:38:52 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* gslist.c: fixed a really, really lame error. g_slist_insert\n\tdidn't hook the data in! Reworked the routine to reflect the\n\tfunctionality of g_list\n\nWed Jan 21 01:13:25 1998  Tim Janik  <timj@psynet.net>\n\n\t* Applied patch from (Raja R Harinath <harinath@cs.umn.edu>)\n\t  to add function g_snprintf.\n        * configure.in (AC_CHECK_FUNCS): Check for vsnprintf.\n        * glib.h: Add prototype for g_snprintf.\n        * glibconfig.h.in: Add HAVE_VSNPRINTF.\n        * gutils.c (g_snprintf): new function.\n\nSat Jan 17 23:52:40 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* gstring.{c,h} gscanner.c:\n\t   renamed g_string_equal => g_str_equal\n\t   renamed g_string_hash => g_str_hash\n\t  And const corrected. Old functions left in for now.\n\nFri Jan  9 20:03:46 1998  Tim Janik  <timj@psynet.net>\n\n\t* gutils.c (g_strerror): changed message for EAGAIN from\n\t\"no more processes\" to \"try again\" since EAGAIN is used with\n\tfunctions else than fork().\n\n\t* gscanner.c (g_scanner_get_token_ll): use strtol() instead of\n\tstrtoul() to avoid conflicts with solaris.\n\n\t* merged the glib portions from Jan 2 to Jan 7 out of gtk+/ChangeLog\n \tinto this file.\n\nWed Jan  7 02:14:30 PST 1998 Manish Singh <yosh@gimp.org>\n\n\t* glib.h:\n\t* glist.c:\n\t* gslist.c:\n\t* testglib.c: Added g_[s]list_insert_sorted function\n\tand appropriate tests in testglib\n\nSat Jan  3 20:23:25 1998  Owen Taylor  <owt1@cornell.edu>\n\n\t* glib.h: Changed guint32 -> guint for bitfields.\n\t(Bitfields must be int or unsigned int?)\n\nFri Jan  2 23:52 PST 1998 Jay Painter <jpaint@serv.net>\n\n\t* glib_pre1.h:\n\t* glib_pre2.h:\n\t* glib.h: reverted glibconfig.h and glib.h files back to the\n\tway they were before my ugly hack.\n\n\t* gscanner.c: removed inlines from clist and gscanner\n\nTue Dec 23 02:49:51 1997  Tim Janik  <timj@psynet.net>\n\n\t* gscanner.c: new file for GScanner: Flexible lexical scanner for\n \tgeneral purpose.\n\t* glib_pre2.h: added GScanner includes. added g_strconcat and g_strtod.\n\tgutils.c (g_strconcat): new function for string concatenation of NULL\n \tterminated parameter list.\n\t(g_strtod): new function to perform best string to double conversion\n\twith or without consideration of the current locale.\n\nMon Dec 15 19:33:58 1997  Tim Janik  <timj@psynet.net>\n\n\t* glist.c: minor optimizations:\n \t(g_list_append): `if' optimized for common code path, commented out\n \tunneccessary `assert', saved one variable assignment.\n\t(g_list_prepend): saved two (conditioned) variable assignment.\n\t(g_list_insert): saved one  (conditioned) variable assignment,\n\tsaved one variable assignment.\n\t(g_list_remove): `if' optimized for common code path, saved two\n\tvariable assignments by using `g_list_free_1' (which is even\n \tfaster) instead of `g_list_free'.\n\t(g_list_reverse): saved allocation of one variable, saved one\n\tvariable assignment.\n\nWed Dec 10 23:27:20 1997  Tim Janik  <timj@psynet.net>\n\n\t* glib_pre1.h:\n\t* glib_pre2.h:\n\t* glib.h: this file now gets concatenated by makeglib_h from\n\tglib_pre1.h and glib_pre2.h to merge in glibconfig.h wich got\n\tcreated by configure (done by Jay Painter).\n\n\t* glib_pre2.h: the g_assert*() and g_return_*_fail() macros\n\tare wrapped by G_STMT_START and G_STMT_END now, to avoid conflicts\n\twhen used within if (...) g_macro(); else ... conditionals.\n\nTue Dec 17 13:14:07 1996  Peter Mattis  <pmattis@charnley.HIP.Berkeley.EDU>\n\n\t* glib.h: Changed 'g_return_if_fail' and 'g_return_val_if_fail' to\n\tnot call 'g_string' but to simply stringify the\n\texpression. Calling 'g_string' causes the expression to be\n\texpanded which is undesired.\n\nSun Dec  1 01:30:48 1996  Peter Mattis  <pmattis@charnley.HIP.Berkeley.EDU>\n\n\t* Started ChangeLog\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gmodule/gmodule-ar.c": "/* GMODULE - GLIB wrapper code for dynamic module loading\n * Copyright (C) 1998, 2000 Tim Janik\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/* \n * MT safe\n */\n\n/* because we are compatible with archive format only since AIX 4.3 */\n\n#define __AR_BIG__\n\n#include \"config.h\"\n\n#include <ar.h>\n#include <stdlib.h>\n\n#include <dlfcn.h>\n\n/* --- functions --- */\nstatic gchar*\nfetch_dlerror (gboolean replace_null)\n{\n  gchar *msg = dlerror ();\n\n  /* make sure we always return an error message != NULL, if\n   * expected to do so. */\n\n  if (!msg && replace_null)\n    return \"unknown dl-error\";\n\n  return msg;\n}\n\nstatic gchar* _g_module_get_member(const gchar* file_name)\n{\n  gchar* member = NULL;\n  struct fl_hdr file_header;\n  struct ar_hdr ar_header;\n  long first_member;\n  long name_len;\n  int fd;\n\n  fd = open(file_name, O_RDONLY);\n  if (fd == -1)\n    return NULL;\n\n  if (read(fd, (void*)&file_header, FL_HSZ) != FL_HSZ)\n    goto exit;\n\n  if (strncmp(file_header.fl_magic, AIAMAGBIG, SAIAMAG) != 0)\n    goto exit;\n\n  /* read first archive file member header */\n\n  first_member = atol(file_header.fl_fstmoff);\n\n  if (lseek(fd, first_member, SEEK_SET) != first_member)\n    goto exit;\n\n  if (read(fd, (void*)&ar_header, AR_HSZ - 2) != AR_HSZ - 2)\n    goto exit;\n\n  /* read member name */\n\n  name_len = atol(ar_header.ar_namlen);\n\n  member = g_malloc(name_len+1);\n  if (!member)\n    goto exit;\n\n  if (read(fd, (void*)member, name_len) != name_len)\n    {\n      g_free(member);\n      member = NULL;\n      goto exit;\n    }\n\n  member[name_len] = 0;\n\nexit:\n  close(fd);\n\n  return member;\n}\n\nstatic gpointer\n_g_module_open (const gchar *file_name,\n\t\tgboolean     bind_lazy,\n\t\tgboolean     bind_local)\n{\n  gpointer handle;\n  gchar* member;\n  gchar* full_name;\n\n  /* extract name of first member of archive */\n\n  member = _g_module_get_member (file_name);\n  if (member != NULL)\n    {\n      full_name = g_strconcat (file_name, \"(\", member, \")\", NULL);\n      g_free (member);\n    }\n  else\n    full_name = g_strdup (file_name);\n  \n  handle = dlopen (full_name, \n\t\t   (bind_local ? RTLD_LOCAL : RTLD_GLOBAL) | RTLD_MEMBER | (bind_lazy ? RTLD_LAZY : RTLD_NOW));\n\n  g_free (full_name);\n\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic gpointer\n_g_module_self (void)\n{\n  gpointer handle;\n\n  handle = dlopen (NULL, RTLD_GLOBAL | RTLD_LAZY);\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic void\n_g_module_close (gpointer handle,\n\t\t gboolean is_unref)\n{\n  /* are there any systems out there that have dlopen()/dlclose()\n   * without a reference count implementation?\n   */\n  is_unref |= 1;\n  \n  if (is_unref)\n    {\n      if (dlclose (handle) != 0)\n\tg_module_set_error (fetch_dlerror (TRUE));\n    }\n}\n\nstatic gpointer\n_g_module_symbol (gpointer     handle,\n\t\t  const gchar *symbol_name)\n{\n  gpointer p;\n  \n  p = dlsym (handle, symbol_name);\n  if (!p)\n    g_module_set_error (fetch_dlerror (FALSE));\n  \n  return p;\n}\n\nstatic gchar*\n_g_module_build_path (const gchar *directory,\n\t\t      const gchar *module_name)\n{\n  if (directory && *directory) {\n    if (strncmp (module_name, \"lib\", 3) == 0)\n      return g_strconcat (directory, \"/\", module_name, NULL);\n    else\n      return g_strconcat (directory, \"/lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n  } else if (strncmp (module_name, \"lib\", 3) == 0)\n    return g_strdup (module_name);\n  else\n    return g_strconcat (\"lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gmodule/gmodule.c": "/* GMODULE - GLIB wrapper code for dynamic module loading\n * Copyright (C) 1998 Tim Janik\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * Modified by the GLib Team and others 1997-2000.  See the AUTHORS\n * file for a list of people on the GLib Team.  See the ChangeLog\n * files for a list of changes.  These files are distributed with\n * GLib at ftp://ftp.gtk.org/pub/gtk/. \n */\n\n/* \n * MT safe\n */\n\n#include \"config.h\"\n\n#include \"glib.h\"\n#include \"gmodule.h\"\n\n#include <errno.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#ifdef G_OS_UNIX\n#include <unistd.h>\n#endif\n#ifdef G_OS_WIN32\n#include <io.h>\t\t/* For open() and close() prototypes. */\n#endif\n\n#include \"gmoduleconf.h\"\n#include \"gstdio.h\"\n\n/**\n * SECTION:modules\n * @title: Dynamic Loading of Modules\n * @short_description: portable method for dynamically loading 'plug-ins'\n *\n * These functions provide a portable way to dynamically load object files\n * (commonly known as 'plug-ins'). The current implementation supports all\n * systems that provide an implementation of dlopen() (e.g. Linux/Sun), as\n * well as Windows platforms via DLLs.\n *\n * A program which wants to use these functions must be linked to the\n * libraries output by the command `pkg-config --libs gmodule-2.0`.\n *\n * To use them you must first determine whether dynamic loading\n * is supported on the platform by calling g_module_supported().\n * If it is, you can open a module with g_module_open(),\n * find the module's symbols (e.g. function names) with g_module_symbol(),\n * and later close the module with g_module_close().\n * g_module_name() will return the file name of a currently opened module.\n *\n * If any of the above functions fail, the error status can be found with\n * g_module_error().\n *\n * The #GModule implementation features reference counting for opened modules,\n * and supports hook functions within a module which are called when the\n * module is loaded and unloaded (see #GModuleCheckInit and #GModuleUnload).\n *\n * If your module introduces static data to common subsystems in the running\n * program, e.g. through calling\n * `g_quark_from_static_string (\"my-module-stuff\")`,\n * it must ensure that it is never unloaded, by calling g_module_make_resident().\n *\n * Example: Calling a function defined in a GModule\n * |[<!-- language=\"C\" --> \n * // the function signature for 'say_hello'\n * typedef void (* SayHelloFunc) (const char *message);\n *\n * gboolean\n * just_say_hello (const char *filename, GError **error)\n * {\n *   SayHelloFunc  say_hello;\n *   GModule      *module;\n *\n *   module = g_module_open (filename, G_MODULE_BIND_LAZY);\n *   if (!module)\n *     {\n *       g_set_error (error, FOO_ERROR, FOO_ERROR_BLAH,\n *                    \"%s\", g_module_error ());\n *       return FALSE;\n *     }\n *\n *   if (!g_module_symbol (module, \"say_hello\", (gpointer *)&say_hello))\n *     {\n *       g_set_error (error, SAY_ERROR, SAY_ERROR_OPEN,\n *                    \"%s: %s\", filename, g_module_error ());\n *       if (!g_module_close (module))\n *         g_warning (\"%s: %s\", filename, g_module_error ());\n *       return FALSE;\n *     }\n *\n *   if (say_hello == NULL)\n *     {\n *       g_set_error (error, SAY_ERROR, SAY_ERROR_OPEN,\n *                    \"symbol say_hello is NULL\");\n *       if (!g_module_close (module))\n *         g_warning (\"%s: %s\", filename, g_module_error ());\n *       return FALSE;\n *     }\n *\n *   // call our function in the module\n *   say_hello (\"Hello world!\");\n *\n *   if (!g_module_close (module))\n *     g_warning (\"%s: %s\", filename, g_module_error ());\n *   return TRUE;\n *  }\n * ]|\n */\n\n/**\n * GModule:\n *\n * The #GModule struct is an opaque data structure to represent a\n * [dynamically-loaded module][glib-Dynamic-Loading-of-Modules].\n * It should only be accessed via the following functions.\n */\n\n/**\n * GModuleCheckInit:\n * @module: the #GModule corresponding to the module which has just been loaded\n *\n * Specifies the type of the module initialization function.\n * If a module contains a function named g_module_check_init() it is called\n * automatically when the module is loaded. It is passed the #GModule structure\n * and should return %NULL on success or a string describing the initialization\n * error.\n *\n * Returns: %NULL on success, or a string describing the initialization error\n */\n\n/**\n * GModuleUnload:\n * @module: the #GModule about to be unloaded\n *\n * Specifies the type of the module function called when it is unloaded.\n * If a module contains a function named g_module_unload() it is called\n * automatically when the module is unloaded.\n * It is passed the #GModule structure.\n */\n\n/**\n * G_MODULE_SUFFIX:\n *\n * Expands to the proper shared library suffix for the current platform\n * without the leading dot. For most Unices and Linux this is \"so\", and\n * for Windows this is \"dll\".\n */\n\n/**\n * G_MODULE_EXPORT:\n *\n * Used to declare functions exported by libraries or modules.\n *\n * When compiling for Windows, it marks the symbol as `dllexport`.\n *\n * When compiling for Linux and Unices, it marks the symbol as having `default`\n * visibility. This is no-op unless the code is being compiled with a\n * non-default\n * [visibility flag](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#index-fvisibility-1260)\n * such as `hidden`.\n */\n\n/**\n * G_MODULE_IMPORT:\n *\n * Used to declare functions imported from modules.\n */\n\n/* We maintain a list of modules, so we can reference count them.\n * That's needed because some platforms don't support references counts on\n * modules. Also, the module for the program itself is kept seperately for\n * faster access and because it has special semantics.\n */\n\n\n/* --- structures --- */\nstruct _GModule\n{\n  gchar\t*file_name;\n  gpointer handle;\n  guint ref_count : 31;\n  guint is_resident : 1;\n  GModuleUnload unload;\n  GModule *next;\n};\n\n\n/* --- prototypes --- */\nstatic gpointer\t\t_g_module_open\t\t(const gchar\t*file_name,\n\t\t\t\t\t\t gboolean\t bind_lazy,\n\t\t\t\t\t\t gboolean\t bind_local);\nstatic void\t\t_g_module_close\t\t(gpointer\t handle,\n\t\t\t\t\t\t gboolean\t is_unref);\nstatic gpointer\t\t_g_module_self\t\t(void);\nstatic gpointer\t\t_g_module_symbol\t(gpointer\t handle,\n\t\t\t\t\t\t const gchar\t*symbol_name);\nstatic gchar*\t\t_g_module_build_path\t(const gchar\t*directory,\n\t\t\t\t\t\t const gchar\t*module_name);\nstatic inline void\tg_module_set_error\t(const gchar\t*error);\nstatic inline GModule*\tg_module_find_by_handle (gpointer\t handle);\nstatic inline GModule*\tg_module_find_by_name\t(const gchar\t*name);\n\n\n/* --- variables --- */\nstatic GModule\t     *modules = NULL;\nstatic GModule\t     *main_module = NULL;\nstatic GPrivate       module_error_private = G_PRIVATE_INIT (g_free);\nstatic gboolean\t      module_debug_initialized = FALSE;\nstatic guint\t      module_debug_flags = 0;\n\n\n/* --- inline functions --- */\nstatic inline GModule*\ng_module_find_by_handle (gpointer handle)\n{\n  GModule *module;\n  GModule *retval = NULL;\n  \n  if (main_module && main_module->handle == handle)\n    retval = main_module;\n  else\n    for (module = modules; module; module = module->next)\n      if (handle == module->handle)\n\t{\n\t  retval = module;\n\t  break;\n\t}\n\n  return retval;\n}\n\nstatic inline GModule*\ng_module_find_by_name (const gchar *name)\n{\n  GModule *module;\n  GModule *retval = NULL;\n  \n  for (module = modules; module; module = module->next)\n    if (strcmp (name, module->file_name) == 0)\n\t{\n\t  retval = module;\n\t  break;\n\t}\n\n  return retval;\n}\n\nstatic inline void\ng_module_set_error_unduped (gchar *error)\n{\n  g_private_replace (&module_error_private, error);\n  errno = 0;\n}\n\nstatic inline void\ng_module_set_error (const gchar *error)\n{\n  g_module_set_error_unduped (g_strdup (error));\n}\n\n\n/* --- include platform specifc code --- */\n#define\tSUPPORT_OR_RETURN(rv)\t{ g_module_set_error (NULL); }\n#if\t(G_MODULE_IMPL == G_MODULE_IMPL_DL)\n#include \"gmodule-dl.c\"\n#elif\t(G_MODULE_IMPL == G_MODULE_IMPL_WIN32)\n#include \"gmodule-win32.c\"\n#elif\t(G_MODULE_IMPL == G_MODULE_IMPL_DYLD)\n#include \"gmodule-dyld.c\"\n#elif\t(G_MODULE_IMPL == G_MODULE_IMPL_AR)\n#include \"gmodule-ar.c\"\n#else\n#undef\tSUPPORT_OR_RETURN\n#define\tSUPPORT_OR_RETURN(rv)\t{ g_module_set_error (\"dynamic modules are \" \\\n                                              \"not supported by this system\"); return rv; }\nstatic gpointer\n_g_module_open (const gchar\t*file_name,\n\t\tgboolean\t bind_lazy,\n\t\tgboolean\t bind_local)\n{\n  return NULL;\n}\nstatic void\n_g_module_close\t(gpointer\t handle,\n\t\t gboolean\t is_unref)\n{\n}\nstatic gpointer\n_g_module_self (void)\n{\n  return NULL;\n}\nstatic gpointer\n_g_module_symbol (gpointer\t handle,\n\t\t  const gchar\t*symbol_name)\n{\n  return NULL;\n}\nstatic gchar*\n_g_module_build_path (const gchar *directory,\n\t\t      const gchar *module_name)\n{\n  return NULL;\n}\n#endif\t/* no implementation */\n\n/* --- functions --- */\n\n/**\n * g_module_supported:\n *\n * Checks if modules are supported on the current platform.\n *\n * Returns: %TRUE if modules are supported\n */\ngboolean\ng_module_supported (void)\n{\n  SUPPORT_OR_RETURN (FALSE);\n  \n  return TRUE;\n}\n\nstatic gchar*\nparse_libtool_archive (const gchar* libtool_name)\n{\n  const guint TOKEN_DLNAME = G_TOKEN_LAST + 1;\n  const guint TOKEN_INSTALLED = G_TOKEN_LAST + 2;\n  const guint TOKEN_LIBDIR = G_TOKEN_LAST + 3;\n  gchar *lt_dlname = NULL;\n  gboolean lt_installed = TRUE;\n  gchar *lt_libdir = NULL;\n  gchar *name;\n  GTokenType token;\n  GScanner *scanner;\n  \n  int fd = g_open (libtool_name, O_RDONLY, 0);\n  if (fd < 0)\n    {\n      gchar *display_libtool_name = g_filename_display_name (libtool_name);\n      g_module_set_error_unduped (g_strdup_printf (\"failed to open libtool archive \\\"%s\\\"\", display_libtool_name));\n      g_free (display_libtool_name);\n      return NULL;\n    }\n  /* search libtool's dlname specification  */\n  scanner = g_scanner_new (NULL);\n  g_scanner_input_file (scanner, fd);\n  scanner->config->symbol_2_token = TRUE;\n  g_scanner_scope_add_symbol (scanner, 0, \"dlname\", \n\t\t\t      GUINT_TO_POINTER (TOKEN_DLNAME));\n  g_scanner_scope_add_symbol (scanner, 0, \"installed\", \n\t\t\t      GUINT_TO_POINTER (TOKEN_INSTALLED));\n  g_scanner_scope_add_symbol (scanner, 0, \"libdir\", \n\t\t\t      GUINT_TO_POINTER (TOKEN_LIBDIR));\n  while (!g_scanner_eof (scanner))\n    {\n      token = g_scanner_get_next_token (scanner);\n      if (token == TOKEN_DLNAME || token == TOKEN_INSTALLED || \n\t  token == TOKEN_LIBDIR)\n\t{\n\t  if (g_scanner_get_next_token (scanner) != '=' ||\n\t      g_scanner_get_next_token (scanner) != \n\t      (token == TOKEN_INSTALLED ? \n\t       G_TOKEN_IDENTIFIER : G_TOKEN_STRING))\n\t    {\n\t      gchar *display_libtool_name = g_filename_display_name (libtool_name);\n\t      g_module_set_error_unduped (g_strdup_printf (\"unable to parse libtool archive \\\"%s\\\"\", display_libtool_name));\n\t      g_free (display_libtool_name);\n\n\t      g_free (lt_dlname);\n\t      g_free (lt_libdir);\n\t      g_scanner_destroy (scanner);\n\t      close (fd);\n\n\t      return NULL;\n\t    }\n\t  else\n\t    {\n\t      if (token == TOKEN_DLNAME)\n\t\t{\n\t\t  g_free (lt_dlname);\n\t\t  lt_dlname = g_strdup (scanner->value.v_string);\n\t\t}\n\t      else if (token == TOKEN_INSTALLED)\n\t\tlt_installed = \n\t\t  strcmp (scanner->value.v_identifier, \"yes\") == 0;\n\t      else /* token == TOKEN_LIBDIR */\n\t\t{\n\t\t  g_free (lt_libdir);\n\t\t  lt_libdir = g_strdup (scanner->value.v_string);\n\t\t}\n\t    }\n\t}      \n    }\n\n  if (!lt_installed)\n    {\n      gchar *dir = g_path_get_dirname (libtool_name);\n      g_free (lt_libdir);\n      lt_libdir = g_strconcat (dir, G_DIR_SEPARATOR_S \".libs\", NULL);\n      g_free (dir);\n    }\n\n  name = g_strconcat (lt_libdir, G_DIR_SEPARATOR_S, lt_dlname, NULL);\n  \n  g_free (lt_dlname);\n  g_free (lt_libdir);\n  g_scanner_destroy (scanner);\n  close (fd);\n\n  return name;\n}\n\nstatic inline gboolean\nstr_check_suffix (const gchar* string,\n\t\t  const gchar* suffix)\n{\n  gsize string_len = strlen (string);    \n  gsize suffix_len = strlen (suffix);    \n\n  return string_len >= suffix_len && \n    strcmp (string + string_len - suffix_len, suffix) == 0;\n}\n\nenum\n{\n  G_MODULE_DEBUG_RESIDENT_MODULES = 1 << 0,\n  G_MODULE_DEBUG_BIND_NOW_MODULES = 1 << 1\n};\n\nstatic void\n_g_module_debug_init (void)\n{\n  const GDebugKey keys[] = {\n    { \"resident-modules\", G_MODULE_DEBUG_RESIDENT_MODULES },\n    { \"bind-now-modules\", G_MODULE_DEBUG_BIND_NOW_MODULES }\n  };\n  const gchar *env;\n\n  env = g_getenv (\"G_DEBUG\");\n\n  module_debug_flags =\n    !env ? 0 : g_parse_debug_string (env, keys, G_N_ELEMENTS (keys));\n\n  module_debug_initialized = TRUE;\n}\n\nstatic GRecMutex g_module_global_lock;\n\n/**\n * g_module_open:\n * @file_name: (nullable): the name of the file containing the module, or %NULL\n *     to obtain a #GModule representing the main program itself\n * @flags: the flags used for opening the module. This can be the\n *     logical OR of any of the #GModuleFlags\n *\n * Opens a module. If the module has already been opened,\n * its reference count is incremented.\n *\n * First of all g_module_open() tries to open @file_name as a module.\n * If that fails and @file_name has the \".la\"-suffix (and is a libtool\n * archive) it tries to open the corresponding module. If that fails\n * and it doesn't have the proper module suffix for the platform\n * (#G_MODULE_SUFFIX), this suffix will be appended and the corresponding\n * module will be opended. If that fails and @file_name doesn't have the\n * \".la\"-suffix, this suffix is appended and g_module_open() tries to open\n * the corresponding module. If eventually that fails as well, %NULL is\n * returned.\n *\n * Returns: a #GModule on success, or %NULL on failure\n */\nGModule*\ng_module_open (const gchar    *file_name,\n\t       GModuleFlags    flags)\n{\n  GModule *module;\n  gpointer handle = NULL;\n  gchar *name = NULL;\n  \n  SUPPORT_OR_RETURN (NULL);\n  \n  g_rec_mutex_lock (&g_module_global_lock);\n\n  if (G_UNLIKELY (!module_debug_initialized))\n    _g_module_debug_init ();\n\n  if (module_debug_flags & G_MODULE_DEBUG_BIND_NOW_MODULES)\n    flags &= ~G_MODULE_BIND_LAZY;\n\n  if (!file_name)\n    {      \n      if (!main_module)\n\t{\n\t  handle = _g_module_self ();\n/* On Android 64 bit, RTLD_DEFAULT is (void *)0x0\n * so it always fails to create main_module if file_name is NULL */\n#if !defined(__BIONIC__) || !defined(__LP64__)\n\t  if (handle)\n#endif\n\t    {\n\t      main_module = g_new (GModule, 1);\n\t      main_module->file_name = NULL;\n\t      main_module->handle = handle;\n\t      main_module->ref_count = 1;\n\t      main_module->is_resident = TRUE;\n\t      main_module->unload = NULL;\n\t      main_module->next = NULL;\n\t    }\n\t}\n      else\n\tmain_module->ref_count++;\n\n      g_rec_mutex_unlock (&g_module_global_lock);\n      return main_module;\n    }\n  \n  /* we first search the module list by name */\n  module = g_module_find_by_name (file_name);\n  if (module)\n    {\n      module->ref_count++;\n      \n      g_rec_mutex_unlock (&g_module_global_lock);\n      return module;\n    }\n\n  /* check whether we have a readable file right away */\n  if (g_file_test (file_name, G_FILE_TEST_IS_REGULAR))\n    name = g_strdup (file_name);\n  /* try completing file name with standard library suffix */\n  if (!name)\n    {\n      name = g_strconcat (file_name, \".\" G_MODULE_SUFFIX, NULL);\n      if (!g_file_test (name, G_FILE_TEST_IS_REGULAR))\n\t{\n\t  g_free (name);\n\t  name = NULL;\n\t}\n    }\n  /* try completing by appending libtool suffix */\n  if (!name)\n    {\n      name = g_strconcat (file_name, \".la\", NULL);\n      if (!g_file_test (name, G_FILE_TEST_IS_REGULAR))\n\t{\n\t  g_free (name);\n\t  name = NULL;\n\t}\n    }\n  /* we can't access() the file, lets hope the platform backends finds\n   * it via library paths\n   */\n  if (!name)\n    {\n      gchar *dot = strrchr (file_name, '.');\n      gchar *slash = strrchr (file_name, G_DIR_SEPARATOR);\n      \n      /* make sure the name has a suffix */\n      if (!dot || dot < slash)\n\tname = g_strconcat (file_name, \".\" G_MODULE_SUFFIX, NULL);\n      else\n\tname = g_strdup (file_name);\n    }\n\n  /* ok, try loading the module */\n  if (name)\n    {\n      /* if it's a libtool archive, figure library file to load */\n      if (str_check_suffix (name, \".la\")) /* libtool archive? */\n\t{\n\t  gchar *real_name = parse_libtool_archive (name);\n\n\t  /* real_name might be NULL, but then module error is already set */\n\t  if (real_name)\n\t    {\n\t      g_free (name);\n\t      name = real_name;\n            }\n\t}\n      if (name)\n\thandle = _g_module_open (name, (flags & G_MODULE_BIND_LAZY) != 0,\n\t\t\t(flags & G_MODULE_BIND_LOCAL) != 0);\n    }\n  else\n    {\n      gchar *display_file_name = g_filename_display_name (file_name);\n      g_module_set_error_unduped (g_strdup_printf (\"unable to access file \\\"%s\\\"\", display_file_name));\n      g_free (display_file_name);\n    }\n  g_free (name);\n\n  if (handle)\n    {\n      gchar *saved_error;\n      GModuleCheckInit check_init;\n      const gchar *check_failed = NULL;\n      \n      /* search the module list by handle, since file names are not unique */\n      module = g_module_find_by_handle (handle);\n      if (module)\n\t{\n\t  _g_module_close (module->handle, TRUE);\n\t  module->ref_count++;\n\t  g_module_set_error (NULL);\n\t  \n\t  g_rec_mutex_unlock (&g_module_global_lock);\n\t  return module;\n\t}\n      \n      saved_error = g_strdup (g_module_error ());\n      g_module_set_error (NULL);\n      \n      module = g_new (GModule, 1);\n      module->file_name = g_strdup (file_name);\n      module->handle = handle;\n      module->ref_count = 1;\n      module->is_resident = FALSE;\n      module->unload = NULL;\n      module->next = modules;\n      modules = module;\n      \n      /* check initialization */\n      if (g_module_symbol (module, \"g_module_check_init\", (gpointer) &check_init) && check_init != NULL)\n\tcheck_failed = check_init (module);\n      \n      /* we don't call unload() if the initialization check failed. */\n      if (!check_failed)\n\tg_module_symbol (module, \"g_module_unload\", (gpointer) &module->unload);\n      \n      if (check_failed)\n\t{\n\t  gchar *error;\n\n\t  error = g_strconcat (\"GModule (\", file_name, \") \",\n                               \"initialization check failed: \",\n                               check_failed, NULL);\n\t  g_module_close (module);\n\t  module = NULL;\n\t  g_module_set_error (error);\n\t  g_free (error);\n\t}\n      else\n\tg_module_set_error (saved_error);\n\n      g_free (saved_error);\n    }\n\n  if (module != NULL &&\n      (module_debug_flags & G_MODULE_DEBUG_RESIDENT_MODULES))\n    g_module_make_resident (module);\n\n  g_rec_mutex_unlock (&g_module_global_lock);\n  return module;\n}\n\n/**\n * g_module_close:\n * @module: a #GModule to close\n *\n * Closes a module.\n *\n * Returns: %TRUE on success\n */\ngboolean\ng_module_close (GModule *module)\n{\n  SUPPORT_OR_RETURN (FALSE);\n  \n  g_return_val_if_fail (module != NULL, FALSE);\n  g_return_val_if_fail (module->ref_count > 0, FALSE);\n  \n  g_rec_mutex_lock (&g_module_global_lock);\n\n  module->ref_count--;\n  \n  if (!module->ref_count && !module->is_resident && module->unload)\n    {\n      GModuleUnload unload;\n\n      unload = module->unload;\n      module->unload = NULL;\n      unload (module);\n    }\n\n  if (!module->ref_count && !module->is_resident)\n    {\n      GModule *last;\n      GModule *node;\n      \n      last = NULL;\n      \n      node = modules;\n      while (node)\n\t{\n\t  if (node == module)\n\t    {\n\t      if (last)\n\t\tlast->next = node->next;\n\t      else\n\t\tmodules = node->next;\n\t      break;\n\t    }\n\t  last = node;\n\t  node = last->next;\n\t}\n      module->next = NULL;\n      \n      _g_module_close (module->handle, FALSE);\n      g_free (module->file_name);\n      g_free (module);\n    }\n  \n  g_rec_mutex_unlock (&g_module_global_lock);\n  return g_module_error() == NULL;\n}\n\n/**\n * g_module_make_resident:\n * @module: a #GModule to make permanently resident\n *\n * Ensures that a module will never be unloaded.\n * Any future g_module_close() calls on the module will be ignored.\n */\nvoid\ng_module_make_resident (GModule *module)\n{\n  g_return_if_fail (module != NULL);\n\n  module->is_resident = TRUE;\n}\n\n/**\n * g_module_error:\n *\n * Gets a string describing the last module error.\n *\n * Returns: a string describing the last module error\n */\nconst gchar *\ng_module_error (void)\n{\n  return g_private_get (&module_error_private);\n}\n\n/**\n * g_module_symbol:\n * @module: a #GModule\n * @symbol_name: the name of the symbol to find\n * @symbol: (out): returns the pointer to the symbol value\n *\n * Gets a symbol pointer from a module, such as one exported\n * by #G_MODULE_EXPORT. Note that a valid symbol can be %NULL.\n *\n * Returns: %TRUE on success\n */\ngboolean\ng_module_symbol (GModule     *module,\n                 const gchar *symbol_name,\n                 gpointer    *symbol)\n{\n  const gchar *module_error;\n\n  if (symbol)\n    *symbol = NULL;\n  SUPPORT_OR_RETURN (FALSE);\n  \n  g_return_val_if_fail (module != NULL, FALSE);\n  g_return_val_if_fail (symbol_name != NULL, FALSE);\n  g_return_val_if_fail (symbol != NULL, FALSE);\n  \n  g_rec_mutex_lock (&g_module_global_lock);\n\n#ifdef\tG_MODULE_NEED_USCORE\n  {\n    gchar *name;\n\n    name = g_strconcat (\"_\", symbol_name, NULL);\n    *symbol = _g_module_symbol (module->handle, name);\n    g_free (name);\n  }\n#else\t/* !G_MODULE_NEED_USCORE */\n  *symbol = _g_module_symbol (module->handle, symbol_name);\n#endif\t/* !G_MODULE_NEED_USCORE */\n  \n  module_error = g_module_error ();\n  if (module_error)\n    {\n      gchar *error;\n\n      error = g_strconcat (\"'\", symbol_name, \"': \", module_error, NULL);\n      g_module_set_error (error);\n      g_free (error);\n      *symbol = NULL;\n    }\n  \n  g_rec_mutex_unlock (&g_module_global_lock);\n  return !module_error;\n}\n\n/**\n * g_module_name:\n * @module: a #GModule\n *\n * Returns the filename that the module was opened with.\n *\n * If @module refers to the application itself, \"main\" is returned.\n *\n * Returns: (transfer none): the filename of the module\n */\nconst gchar *\ng_module_name (GModule *module)\n{\n  g_return_val_if_fail (module != NULL, NULL);\n  \n  if (module == main_module)\n    return \"main\";\n  \n  return module->file_name;\n}\n\n/**\n * g_module_build_path:\n * @directory: (nullable): the directory where the module is. This can be\n *     %NULL or the empty string to indicate that the standard platform-specific\n *     directories will be used, though that is not recommended\n * @module_name: the name of the module\n *\n * A portable way to build the filename of a module. The platform-specific\n * prefix and suffix are added to the filename, if needed, and the result\n * is added to the directory, using the correct separator character.\n *\n * The directory should specify the directory where the module can be found.\n * It can be %NULL or an empty string to indicate that the module is in a\n * standard platform-specific directory, though this is not recommended\n * since the wrong module may be found.\n *\n * For example, calling g_module_build_path() on a Linux system with a\n * @directory of `/lib` and a @module_name of \"mylibrary\" will return\n * `/lib/libmylibrary.so`. On a Windows system, using `\\Windows` as the\n * directory it will return `\\Windows\\mylibrary.dll`.\n *\n * Returns: the complete path of the module, including the standard library\n *     prefix and suffix. This should be freed when no longer needed\n */\ngchar *\ng_module_build_path (const gchar *directory,\n                     const gchar *module_name)\n{\n  g_return_val_if_fail (module_name != NULL, NULL);\n  \n  return _g_module_build_path (directory, module_name);\n}\n\n\n#ifdef G_OS_WIN32\n\n/* Binary compatibility versions. Not for newly compiled code. */\n\n_GLIB_EXTERN GModule *    g_module_open_utf8 (const gchar  *file_name,\n                                              GModuleFlags  flags);\n\n_GLIB_EXTERN const gchar *g_module_name_utf8 (GModule      *module);\n\nGModule*\ng_module_open_utf8 (const gchar    *file_name,\n                    GModuleFlags    flags)\n{\n  return g_module_open (file_name, flags);\n}\n\nconst gchar *\ng_module_name_utf8 (GModule *module)\n{\n  return g_module_name (module);\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gmodule/meson.build": "gmoduleconf_conf = configuration_data()\n\ng_module_need_uscore = 0\ng_module_broken_rtld_global = 0\ng_module_have_dlerror = 0\n\nlibdl_dep = [ ]\ng_module_lib_args = [ ]\ng_module_impl = ''\n\ndlopen_dlsym_test_code = '''\n#include <dlfcn.h>\nint glib_underscore_test (void) { return 42; }\nint main (int argc, char ** argv) {\n  void *f1 = (void*)0, *f2 = (void*)0, *handle;\n  handle = dlopen ((void*)0, 0);\n  if (handle) {\n    f1 = dlsym (handle, \"glib_underscore_test\");\n    f2 = dlsym (handle, \"_glib_underscore_test\");\n  }\n  return (!f2 || f1);\n}'''\n\n# On Windows force native WIN32 shared lib loader\nif host_system == 'windows'\n  g_module_impl = 'G_MODULE_IMPL_WIN32'\n# Force native AIX library loader\n# dlopen() filepath must be of the form /path/libname.a(libname.so)\nelif host_system == 'aix'\n  g_module_impl = 'G_MODULE_IMPL_AR'\nelif cc.links(dlopen_dlsym_test_code, name : 'dlopen() and dlsym() in system libraries')\n  g_module_impl = 'G_MODULE_IMPL_DL'\n# NSLinkModule (dyld) in system libraries (Darwin)\nelif cc.has_function('NSLinkModule')\n  g_module_impl = 'G_MODULE_IMPL_DYLD'\n  g_module_need_uscore = 1\nelif cc.links(dlopen_dlsym_test_code, args : '-ldl', name : 'dlopen() and dlsym() in libdl')\n  g_module_impl = 'G_MODULE_IMPL_DL'\n  libdl_dep = cc.find_library('dl')\n  g_module_lib_args = '-ldl'\nendif\n\n# additional checks for G_MODULE_IMPL_DL\nif g_module_impl == 'G_MODULE_IMPL_DL'\n  # FIXME: check for OSF1/5.0 RTLD_GLOBAL brokenness (is this still relevant?)\n\n  # Check whether we need preceding underscores\n  if cc.get_id() == 'msvc'\n    message('Building for MSVC: assuming that symbols are prefixed with underscore')\n    g_module_need_uscore = 1\n  elif meson.has_exe_wrapper()\n    # FIXME: communicate result via stdout instead of return value, so non-0 return is not printed in bold red\n    rres = cc.run(dlopen_dlsym_test_code,\n                  args : g_module_lib_args,\n                  name : 'dlsym() preceding underscores')\n    if host_system == 'windows' or rres.returncode() == 0\n      g_module_need_uscore = 1\n    endif\n  else\n    message('Cross-compiling: assuming that symbols aren\\'t prefixed with underscore')\n    g_module_need_uscore = 0\n  endif\n\n  if cc.has_function('dlerror', args : g_module_lib_args)\n    g_module_have_dlerror = 1\n  endif\nendif\n\n# Done, have we got an implementation?\nif g_module_impl == ''\n  g_module_impl = '0'\n  message('WARNING: No suitable GModule implementation found!')\nendif\n\ngmoduleconf_conf.set('G_MODULE_IMPL', g_module_impl)\ngmoduleconf_conf.set('G_MODULE_SUPPORTED', g_module_impl != '0')\ngmoduleconf_conf.set('G_MODULE_HAVE_DLERROR', g_module_have_dlerror)\ngmoduleconf_conf.set('G_MODULE_NEED_USCORE', g_module_need_uscore)\ngmoduleconf_conf.set('G_MODULE_BROKEN_RTLD_GLOBAL', g_module_broken_rtld_global)\n\ngmoduleconf_h = configure_file(input : 'gmoduleconf.h.in',\n                               output : 'gmoduleconf.h',\n                               configuration : gmoduleconf_conf)\n\ninstall_headers(['gmodule.h'], subdir : 'glib-2.0')\n\ngmodule_sources = ['gmodule.c']\nif host_system == 'windows'\n  gmodule_win_rc = configure_file(\n    input: 'gmodule.rc.in',\n    output: 'gmodule.rc',\n    configuration: glibconfig_conf,\n  )\n  gmodule_win_res = windows.compile_resources(gmodule_win_rc)\n  gmodule_sources += [gmodule_win_res]\nendif\n\nlibgmodule = library('gmodule-2.0',\n  sources : gmodule_sources,\n  version : library_version,\n  soversion : soversion,\n  install : true,\n  include_directories : [configinc, gmoduleinc],\n  dependencies : [libdl_dep, libglib_dep],\n  c_args : ['-DG_LOG_DOMAIN=\"GModule\"', '-DG_DISABLE_DEPRECATED'] + glib_hidden_visibility_args,\n  link_args : [glib_link_flags],\n)\n\nsupported_var = 'gmodule_supported=@0@'.format(g_module_impl != '0')\n\npkg.generate(libraries : [libgmodule, thread_dep],\n  requires : ['glib-2.0'],\n  version : glib_version,\n  variables : [supported_var],\n  install_dir : glib_pkgconfigreldir,\n  filebase : 'gmodule-no-export-2.0',\n  name : 'GModule',\n  description : 'Dynamic module loader for GLib',\n)\n\npkg.generate(libraries : [libgmodule, export_dynamic_ldflags],\n  requires : ['glib-2.0'],\n  version : glib_version,\n  variables : [supported_var],\n  install_dir : glib_pkgconfigreldir,\n  filebase : 'gmodule-export-2.0',\n  name : 'GModule',\n  description : 'Dynamic module loader for GLib',\n)\n\npkg.generate(libraries : [libgmodule, export_dynamic_ldflags],\n  requires : ['glib-2.0'],\n  version : glib_version,\n  variables : [supported_var],\n  install_dir : glib_pkgconfigreldir,\n  filebase : 'gmodule-2.0',\n  name : 'GModule',\n  description : 'Dynamic module loader for GLib',\n)\n\nlibgmodule_dep = declare_dependency(link_with : libgmodule,\n  include_directories : gmoduleinc)\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gmodule/gmodule-dl.c": "/* GMODULE - GLIB wrapper code for dynamic module loading\n * Copyright (C) 1998, 2000 Tim Janik\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * Modified by the GLib Team and others 1997-2000.  See the AUTHORS\n * file for a list of people on the GLib Team.  See the ChangeLog\n * files for a list of changes.  These files are distributed with\n * GLib at ftp://ftp.gtk.org/pub/gtk/. \n */\n\n/* \n * MT safe\n */\n#include \"config.h\"\n\n#include <dlfcn.h>\n\n/* Perl includes <nlist.h> and <link.h> instead of <dlfcn.h> on some systmes? */\n\n\n/* dlerror() is not implemented on all systems\n */\n#ifndef\tG_MODULE_HAVE_DLERROR\n#  ifdef __NetBSD__\n#    define dlerror()\tg_strerror (errno)\n#  else /* !__NetBSD__ */\n/* could we rely on errno's state here? */\n#    define dlerror()\t\"unknown dl-error\"\n#  endif /* !__NetBSD__ */\n#endif\t/* G_MODULE_HAVE_DLERROR */\n\n/* some flags are missing on some systems, so we provide\n * harmless defaults.\n * The Perl sources say, RTLD_LAZY needs to be defined as (1),\n * at least for Solaris 1.\n *\n * Mandatory:\n * RTLD_LAZY   - resolve undefined symbols as code from the dynamic library\n *\t\t is executed.\n * RTLD_NOW    - resolve all undefined symbols before dlopen returns, and fail\n *\t\t if this cannot be done.\n * Optionally:\n * RTLD_GLOBAL - the external symbols defined in the library will be made\n *\t\t available to subsequently loaded libraries.\n */\n#ifndef\tHAVE_RTLD_LAZY\n#define\tRTLD_LAZY\t1\n#endif\t/* RTLD_LAZY */\n#ifndef\tHAVE_RTLD_NOW\n#define\tRTLD_NOW\t0\n#endif\t/* RTLD_NOW */\n/* some systems (OSF1 V5.0) have broken RTLD_GLOBAL linkage */\n#ifdef G_MODULE_BROKEN_RTLD_GLOBAL\n#undef\tRTLD_GLOBAL\n#undef\tHAVE_RTLD_GLOBAL\n#endif /* G_MODULE_BROKEN_RTLD_GLOBAL */\n#ifndef\tHAVE_RTLD_GLOBAL\n#define\tRTLD_GLOBAL\t0\n#endif\t/* RTLD_GLOBAL */\n\n\n/* --- functions --- */\nstatic gchar*\nfetch_dlerror (gboolean replace_null)\n{\n  gchar *msg = dlerror ();\n\n  /* make sure we always return an error message != NULL, if\n   * expected to do so. */\n\n  if (!msg && replace_null)\n    return \"unknown dl-error\";\n\n  return msg;\n}\n\nstatic gpointer\n_g_module_open (const gchar *file_name,\n\t\tgboolean     bind_lazy,\n\t\tgboolean     bind_local)\n{\n  gpointer handle;\n  \n  handle = dlopen (file_name,\n\t\t   (bind_local ? 0 : RTLD_GLOBAL) | (bind_lazy ? RTLD_LAZY : RTLD_NOW));\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic gpointer\n_g_module_self (void)\n{\n  gpointer handle;\n  \n  /* to query symbols from the program itself, special link options\n   * are required on some systems.\n   */\n\n  /* On Android 32 bit (i.e. not __LP64__), dlopen(NULL)\n   * does not work reliable and generally no symbols are found\n   * at all. RTLD_DEFAULT works though.\n   * On Android 64 bit, dlopen(NULL) seems to work but dlsym(handle)\n   * always returns 'undefined symbol'. Only if RTLD_DEFAULT or \n   * NULL is given, dlsym returns an appropriate pointer.\n   */\n#if defined(__BIONIC__)\n  handle = RTLD_DEFAULT;\n#else\n  handle = dlopen (NULL, RTLD_GLOBAL | RTLD_LAZY);\n#endif\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic void\n_g_module_close (gpointer handle,\n\t\t gboolean is_unref)\n{\n  /* are there any systems out there that have dlopen()/dlclose()\n   * without a reference count implementation?\n   *\n   * See above for the Android special case\n   */\n#if defined(__BIONIC__)\n  is_unref = (handle != RTLD_DEFAULT);\n#else\n  is_unref |= 1;\n#endif\n\n  if (is_unref)\n    {\n      if (dlclose (handle) != 0)\n\tg_module_set_error (fetch_dlerror (TRUE));\n    }\n}\n\nstatic gpointer\n_g_module_symbol (gpointer     handle,\n\t\t  const gchar *symbol_name)\n{\n  gpointer p;\n  gchar *msg;\n\n  fetch_dlerror (FALSE);\n  p = dlsym (handle, symbol_name);\n  msg = fetch_dlerror (FALSE);\n  if (msg)\n    g_module_set_error (msg);\n  \n  return p;\n}\n\nstatic gchar*\n_g_module_build_path (const gchar *directory,\n\t\t      const gchar *module_name)\n{\n  if (directory && *directory) {\n    if (strncmp (module_name, \"lib\", 3) == 0)\n      return g_strconcat (directory, \"/\", module_name, NULL);\n    else\n      return g_strconcat (directory, \"/lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n  } else if (strncmp (module_name, \"lib\", 3) == 0)\n    return g_strdup (module_name);\n  else\n    return g_strconcat (\"lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/gdbusconnection.c": "/* GDBus - GLib D-Bus Library\n *\n * Copyright (C) 2008-2010 Red Hat, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General\n * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.\n *\n * Author: David Zeuthen <davidz@redhat.com>\n */\n\n/*\n * TODO for GDBus:\n *\n * - would be nice to expose GDBusAuthMechanism and an extension point\n *\n * - Need to rewrite GDBusAuth and rework GDBusAuthMechanism. In particular\n *   the mechanism VFuncs need to be able to set an error.\n *\n * - Need to document other mechanisms/sources for determining the D-Bus\n *   address of a well-known bus.\n *\n *   - e.g. on Win32 we need code like from here\n *\n *     http://cgit.freedesktop.org/~david/gdbus-standalone/tree/gdbus/gdbusaddress.c#n900\n *\n *     that was never copied over here because it originally was copy-paste\n *     from the GPLv2 / AFL 2.1 libdbus sources.\n *\n *   - on OS X we need to look in launchd for the address\n *\n *     https://bugs.freedesktop.org/show_bug.cgi?id=14259\n *\n *   - on X11 we need to look in a X11 property on the X server\n *     - (we can also just use dbus-launch(1) from the D-Bus\n *        distribution)\n *\n *   - (ideally) this requires D-Bus spec work because none of\n *     this has never really been specced out properly (except\n *     the X11 bits)\n *\n * - Related to the above, we also need to be able to launch a message bus\n *   instance.... Since we don't want to write our own bus daemon we should\n *   launch dbus-daemon(1) (thus: Win32 and OS X need to bundle it)\n *\n * - probably want a G_DBUS_NONCE_TCP_TMPDIR environment variable\n *   to specify where the nonce is stored. This will allow people to use\n *   G_DBUS_NONCE_TCP_TMPDIR=/mnt/secure.company.server/dbus-nonce-dir\n *   to easily achieve secure RPC via nonce-tcp.\n *\n * - need to expose an extension point for resolving D-Bus address and\n *   turning them into GIOStream objects. This will allow us to implement\n *   e.g. X11 D-Bus transports without dlopen()'ing or linking against\n *   libX11 from libgio.\n *   - see g_dbus_address_connect() in gdbusaddress.c\n *\n * - would be cute to use kernel-specific APIs to resolve fds for\n *   debug output when using G_DBUS_DEBUG=message, e.g. in addition to\n *\n *     fd 21: dev=8:1,mode=0100644,ino=1171231,uid=0,gid=0,rdev=0:0,size=234,atime=1273070640,mtime=1267126160,ctime=1267126160\n *\n *   maybe we can show more information about what fd 21 really is.\n *   Ryan suggests looking in /proc/self/fd for clues / symlinks!\n *   Initial experiments on Linux 2.6 suggests that the symlink looks\n *   like this:\n *\n *    3 -> /proc/18068/fd\n *\n *   e.g. not of much use.\n *\n *  - GDBus High-Level docs\n *    - Proxy: properties, signals...\n *    - Connection: IOStream based, ::close, connection setup steps\n *                  mainloop integration, threading\n *    - Differences from libdbus (extend \"Migrating from\")\n *      - the message handling thread\n *      - Using GVariant instead of GValue\n *    - Explain why the high-level API is a good thing and what\n *      kind of pitfalls it avoids\n *      - Export objects before claiming names\n *    - Talk about auto-starting services (cf. GBusNameWatcherFlags)\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"gdbusauth.h\"\n#include \"gdbusutils.h\"\n#include \"gdbusaddress.h\"\n#include \"gdbusmessage.h\"\n#include \"gdbusconnection.h\"\n#include \"gdbuserror.h\"\n#include \"gioenumtypes.h\"\n#include \"gdbusintrospection.h\"\n#include \"gdbusmethodinvocation.h\"\n#include \"gdbusprivate.h\"\n#include \"gdbusauthobserver.h\"\n#include \"ginitable.h\"\n#include \"gasyncinitable.h\"\n#include \"giostream.h\"\n#include \"gasyncresult.h\"\n#include \"gtask.h\"\n\n#ifdef G_OS_UNIX\n#include \"gunixconnection.h\"\n#include \"gunixfdmessage.h\"\n#endif\n\n#include \"glibintl.h\"\n\n/**\n * SECTION:gdbusconnection\n * @short_description: D-Bus Connections\n * @include: gio/gio.h\n *\n * The #GDBusConnection type is used for D-Bus connections to remote\n * peers such as a message buses. It is a low-level API that offers a\n * lot of flexibility. For instance, it lets you establish a connection\n * over any transport that can by represented as an #GIOStream.\n *\n * This class is rarely used directly in D-Bus clients. If you are writing\n * a D-Bus client, it is often easier to use the g_bus_own_name(),\n * g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.\n *\n * As an exception to the usual GLib rule that a particular object must not\n * be used by two threads at the same time, #GDBusConnection's methods may be\n * called from any thread. This is so that g_bus_get() and g_bus_get_sync()\n * can safely return the same #GDBusConnection when called from any thread.\n *\n * Most of the ways to obtain a #GDBusConnection automatically initialize it\n * (i.e. connect to D-Bus): for instance, g_dbus_connection_new() and\n * g_bus_get(), and the synchronous versions of those methods, give you an\n * initialized connection. Language bindings for GIO should use\n * g_initable_new() or g_async_initable_new_async(), which also initialize the\n * connection.\n *\n * If you construct an uninitialized #GDBusConnection, such as via\n * g_object_new(), you must initialize it via g_initable_init() or\n * g_async_initable_init_async() before using its methods or properties.\n * Calling methods or accessing properties on a #GDBusConnection that has not\n * completed initialization successfully is considered to be invalid, and leads\n * to undefined behaviour. In particular, if initialization fails with a\n * #GError, the only valid thing you can do with that #GDBusConnection is to\n * free it with g_object_unref().\n *\n * ## An example D-Bus server # {#gdbus-server}\n *\n * Here is an example for a D-Bus server:\n * [gdbus-example-server.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)\n *\n * ## An example for exporting a subtree # {#gdbus-subtree-server}\n *\n * Here is an example for exporting a subtree:\n * [gdbus-example-subtree.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)\n *\n * ## An example for file descriptor passing # {#gdbus-unix-fd-client}\n *\n * Here is an example for passing UNIX file descriptors:\n * [gdbus-unix-fd-client.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)\n *\n * ## An example for exporting a GObject # {#gdbus-export}\n *\n * Here is an example for exporting a #GObject:\n * [gdbus-example-export.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)\n */\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct _GDBusConnectionClass GDBusConnectionClass;\n\n/**\n * GDBusConnectionClass:\n * @closed: Signal class handler for the #GDBusConnection::closed signal.\n *\n * Class structure for #GDBusConnection.\n *\n * Since: 2.26\n */\nstruct _GDBusConnectionClass\n{\n  /*< private >*/\n  GObjectClass parent_class;\n\n  /*< public >*/\n  /* Signals */\n  void (*closed) (GDBusConnection *connection,\n                  gboolean         remote_peer_vanished,\n                  GError          *error);\n};\n\nG_LOCK_DEFINE_STATIC (message_bus_lock);\n\nstatic GWeakRef the_session_bus;\nstatic GWeakRef the_system_bus;\n\n/* Extra pseudo-member of GDBusSendMessageFlags.\n * Set by initable_init() to indicate that despite not being initialized yet,\n * enough of the only-valid-after-init members are set that we can send a\n * message, and we're being called from its thread, so no memory barrier is\n * required before accessing them.\n */\n#define SEND_MESSAGE_FLAGS_INITIALIZING (1u << 31)\n\n/* Same as SEND_MESSAGE_FLAGS_INITIALIZING, but in GDBusCallFlags */\n#define CALL_FLAGS_INITIALIZING (1u << 31)\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GDestroyNotify              callback;\n  gpointer                    user_data;\n  GMainContext               *context;\n} CallDestroyNotifyData;\n\nstatic gboolean\ncall_destroy_notify_data_in_idle (gpointer user_data)\n{\n  CallDestroyNotifyData *data = user_data;\n  data->callback (data->user_data);\n  return FALSE;\n}\n\nstatic void\ncall_destroy_notify_data_free (CallDestroyNotifyData *data)\n{\n  if (data->context != NULL)\n    g_main_context_unref (data->context);\n  g_free (data);\n}\n\n/*\n * call_destroy_notify: <internal>\n * @context: (nullable): A #GMainContext or %NULL.\n * @callback: (nullable): A #GDestroyNotify or %NULL.\n * @user_data: Data to pass to @callback.\n *\n * Schedules @callback to run in @context.\n */\nstatic void\ncall_destroy_notify (GMainContext  *context,\n                     GDestroyNotify callback,\n                     gpointer       user_data)\n{\n  GSource *idle_source;\n  CallDestroyNotifyData *data;\n\n  if (callback == NULL)\n    goto out;\n\n  data = g_new0 (CallDestroyNotifyData, 1);\n  data->callback = callback;\n  data->user_data = user_data;\n  data->context = context;\n  if (data->context != NULL)\n    g_main_context_ref (data->context);\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         call_destroy_notify_data_in_idle,\n                         data,\n                         (GDestroyNotify) call_destroy_notify_data_free);\n  g_source_set_name (idle_source, \"[gio] call_destroy_notify_data_in_idle\");\n  g_source_attach (idle_source, data->context);\n  g_source_unref (idle_source);\n\n out:\n  ;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic gboolean\n_g_strv_has_string (const gchar* const *haystack,\n                    const gchar        *needle)\n{\n  guint n;\n\n  for (n = 0; haystack != NULL && haystack[n] != NULL; n++)\n    {\n      if (g_strcmp0 (haystack[n], needle) == 0)\n        return TRUE;\n    }\n  return FALSE;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n#ifdef G_OS_WIN32\n#define CONNECTION_ENSURE_LOCK(obj) do { ; } while (FALSE)\n#else\n// TODO: for some reason this doesn't work on Windows\n#define CONNECTION_ENSURE_LOCK(obj) do {                                \\\n    if (G_UNLIKELY (g_mutex_trylock(&(obj)->lock)))                     \\\n      {                                                                 \\\n        g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \\\n                             \"CONNECTION_ENSURE_LOCK: GDBusConnection object lock is not locked\"); \\\n      }                                                                 \\\n  } while (FALSE)\n#endif\n\n#define CONNECTION_LOCK(obj) do {                                       \\\n    g_mutex_lock (&(obj)->lock);                                        \\\n  } while (FALSE)\n\n#define CONNECTION_UNLOCK(obj) do {                                     \\\n    g_mutex_unlock (&(obj)->lock);                                      \\\n  } while (FALSE)\n\n/* Flags in connection->atomic_flags */\nenum {\n    FLAG_INITIALIZED = 1 << 0,\n    FLAG_EXIT_ON_CLOSE = 1 << 1,\n    FLAG_CLOSED = 1 << 2\n};\n\n/**\n * GDBusConnection:\n *\n * The #GDBusConnection structure contains only private data and\n * should only be accessed using the provided API.\n *\n * Since: 2.26\n */\nstruct _GDBusConnection\n{\n  /*< private >*/\n  GObject parent_instance;\n\n  /* ------------------------------------------------------------------------ */\n  /* -- General object state ------------------------------------------------ */\n  /* ------------------------------------------------------------------------ */\n\n  /* General-purpose lock for most fields */\n  GMutex lock;\n\n  /* A lock used in the init() method of the GInitable interface - see comments\n   * in initable_init() for why a separate lock is needed.\n   *\n   * If you need both @lock and @init_lock, you must take @init_lock first.\n   */\n  GMutex init_lock;\n\n  /* Set (by loading the contents of /var/lib/dbus/machine-id) the first time\n   * someone calls org.freedesktop.DBus.Peer.GetMachineId(). Protected by @lock.\n   */\n  gchar *machine_id;\n\n  /* The underlying stream used for communication\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GIOStream *stream;\n\n  /* The object used for authentication (if any).\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GDBusAuth *auth;\n\n  /* Last serial used. Protected by @lock. */\n  guint32 last_serial;\n\n  /* The object used to send/receive messages.\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GDBusWorker *worker;\n\n  /* If connected to a message bus, this contains the unique name assigned to\n   * us by the bus (e.g. \":1.42\").\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  gchar *bus_unique_name;\n\n  /* The GUID returned by the other side if we authenticed as a client or\n   * the GUID to use if authenticating as a server.\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  gchar *guid;\n\n  /* FLAG_INITIALIZED is set exactly when initable_init() has finished running.\n   * Inspect @initialization_error to see whether it succeeded or failed.\n   *\n   * FLAG_EXIT_ON_CLOSE is the exit-on-close property.\n   *\n   * FLAG_CLOSED is the closed property. It may be read at any time, but\n   * may only be written while holding @lock.\n   */\n  volatile gint atomic_flags;\n\n  /* If the connection could not be established during initable_init(),\n   * this GError will be set.\n   * Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GError *initialization_error;\n\n  /* The result of g_main_context_ref_thread_default() when the object\n   * was created (the GObject _init() function) - this is used for delivery\n   * of the :closed GObject signal.\n   *\n   * Only set in the GObject init function, so no locks are needed.\n   */\n  GMainContext *main_context_at_construction;\n\n  /* Read-only construct properties, no locks needed */\n  gchar *address;\n  GDBusConnectionFlags flags;\n\n  /* Map used for managing method replies, protected by @lock */\n  GHashTable *map_method_serial_to_task;  /* guint32 -> GTask* */\n\n  /* Maps used for managing signal subscription, protected by @lock */\n  GHashTable *map_rule_to_signal_data;                      /* match rule (gchar*)    -> SignalData */\n  GHashTable *map_id_to_signal_data;                        /* id (guint)             -> SignalData */\n  GHashTable *map_sender_unique_name_to_signal_data_array;  /* unique sender (gchar*) -> GPtrArray* of SignalData */\n\n  /* Maps used for managing exported objects and subtrees,\n   * protected by @lock\n   */\n  GHashTable *map_object_path_to_eo;  /* gchar* -> ExportedObject* */\n  GHashTable *map_id_to_ei;           /* guint  -> ExportedInterface* */\n  GHashTable *map_object_path_to_es;  /* gchar* -> ExportedSubtree* */\n  GHashTable *map_id_to_es;           /* guint  -> ExportedSubtree* */\n\n  /* Map used for storing last used serials for each thread, protected by @lock */\n  GHashTable *map_thread_to_last_serial;\n\n  /* Structure used for message filters, protected by @lock */\n  GPtrArray *filters;\n\n  /* Capabilities negotiated during authentication\n   * Read-only after initable_init(), so it may be read without holding a\n   * lock, if you check for initialization first.\n   */\n  GDBusCapabilityFlags capabilities;\n\n  /* Protected by @init_lock */\n  GDBusAuthObserver *authentication_observer;\n\n  /* Read-only after initable_init(), so it may be read if you either\n   * hold @init_lock or check for initialization first.\n   */\n  GCredentials *credentials;\n\n  /* set to TRUE when finalizing */\n  gboolean finalizing;\n};\n\ntypedef struct ExportedObject ExportedObject;\nstatic void exported_object_free (ExportedObject *eo);\n\ntypedef struct ExportedSubtree ExportedSubtree;\nstatic void exported_subtree_free (ExportedSubtree *es);\n\nenum\n{\n  CLOSED_SIGNAL,\n  LAST_SIGNAL,\n};\n\nenum\n{\n  PROP_0,\n  PROP_STREAM,\n  PROP_ADDRESS,\n  PROP_FLAGS,\n  PROP_GUID,\n  PROP_UNIQUE_NAME,\n  PROP_CLOSED,\n  PROP_EXIT_ON_CLOSE,\n  PROP_CAPABILITY_FLAGS,\n  PROP_AUTHENTICATION_OBSERVER,\n};\n\nstatic void distribute_signals (GDBusConnection  *connection,\n                                GDBusMessage     *message);\n\nstatic void distribute_method_call (GDBusConnection  *connection,\n                                    GDBusMessage     *message);\n\nstatic gboolean handle_generic_unlocked (GDBusConnection *connection,\n                                         GDBusMessage    *message);\n\n\nstatic void purge_all_signal_subscriptions (GDBusConnection *connection);\nstatic void purge_all_filters (GDBusConnection *connection);\n\nstatic void schedule_method_call (GDBusConnection            *connection,\n                                  GDBusMessage               *message,\n                                  guint                       registration_id,\n                                  guint                       subtree_registration_id,\n                                  const GDBusInterfaceInfo   *interface_info,\n                                  const GDBusMethodInfo      *method_info,\n                                  const GDBusPropertyInfo    *property_info,\n                                  GVariant                   *parameters,\n                                  const GDBusInterfaceVTable *vtable,\n                                  GMainContext               *main_context,\n                                  gpointer                    user_data);\n\n#define _G_ENSURE_LOCK(name) do {                                       \\\n    if (G_UNLIKELY (G_TRYLOCK(name)))                                   \\\n      {                                                                 \\\n        g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \\\n                             \"_G_ENSURE_LOCK: Lock '\" #name \"' is not locked\"); \\\n      }                                                                 \\\n  } while (FALSE)                                                       \\\n\nstatic guint signals[LAST_SIGNAL] = { 0 };\n\nstatic void initable_iface_init       (GInitableIface      *initable_iface);\nstatic void async_initable_iface_init (GAsyncInitableIface *async_initable_iface);\n\nG_DEFINE_TYPE_WITH_CODE (GDBusConnection, g_dbus_connection, G_TYPE_OBJECT,\n                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE, initable_iface_init)\n                         G_IMPLEMENT_INTERFACE (G_TYPE_ASYNC_INITABLE, async_initable_iface_init)\n                         );\n\n/*\n * Check that all members of @connection that can only be accessed after\n * the connection is initialized can safely be accessed. If not,\n * log a critical warning. This function is a memory barrier.\n *\n * Returns: %TRUE if initialized\n */\nstatic gboolean\ncheck_initialized (GDBusConnection *connection)\n{\n  /* The access to @atomic_flags isn't conditional, so that this function\n   * provides a memory barrier for thread-safety even if checks are disabled.\n   * (If you don't want this stricter guarantee, you can call\n   * g_return_if_fail (check_initialized (c)).)\n   *\n   * This isn't strictly necessary now that we've decided use of an\n   * uninitialized GDBusConnection is undefined behaviour, but it seems\n   * better to be as deterministic as is feasible.\n   *\n   * (Anything that could suffer a crash from seeing undefined values\n   * must have a race condition - thread A initializes the connection while\n   * thread B calls a method without initialization, hoping that thread A will\n   * win the race - so its behaviour is undefined anyway.)\n   */\n  gint flags = g_atomic_int_get (&connection->atomic_flags);\n\n  g_return_val_if_fail (flags & FLAG_INITIALIZED, FALSE);\n\n  /* We can safely access this, due to the memory barrier above */\n  g_return_val_if_fail (connection->initialization_error == NULL, FALSE);\n\n  return TRUE;\n}\n\ntypedef enum {\n    MAY_BE_UNINITIALIZED = (1<<1)\n} CheckUnclosedFlags;\n\n/*\n * Check the same thing as check_initialized(), and also that the\n * connection is not closed. If the connection is uninitialized,\n * raise a critical warning (it's programmer error); if it's closed,\n * raise a recoverable GError (it's a runtime error).\n *\n * This function is a memory barrier.\n *\n * Returns: %TRUE if initialized and not closed\n */\nstatic gboolean\ncheck_unclosed (GDBusConnection     *connection,\n                CheckUnclosedFlags   check,\n                GError             **error)\n{\n  /* check_initialized() is effectively inlined, so we don't waste time\n   * doing two memory barriers\n   */\n  gint flags = g_atomic_int_get (&connection->atomic_flags);\n\n  if (!(check & MAY_BE_UNINITIALIZED))\n    {\n      g_return_val_if_fail (flags & FLAG_INITIALIZED, FALSE);\n      g_return_val_if_fail (connection->initialization_error == NULL, FALSE);\n    }\n\n  if (flags & FLAG_CLOSED)\n    {\n      g_set_error_literal (error,\n                           G_IO_ERROR,\n                           G_IO_ERROR_CLOSED,\n                           _(\"The connection is closed\"));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic GHashTable *alive_connections = NULL;\n\nstatic void\ng_dbus_connection_dispose (GObject *object)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (object);\n\n  G_LOCK (message_bus_lock);\n  CONNECTION_LOCK (connection);\n  if (connection->worker != NULL)\n    {\n      _g_dbus_worker_stop (connection->worker);\n      connection->worker = NULL;\n      if (alive_connections != NULL)\n        g_warn_if_fail (g_hash_table_remove (alive_connections, connection));\n    }\n  else\n    {\n      if (alive_connections != NULL)\n        g_warn_if_fail (!g_hash_table_contains (alive_connections, connection));\n    }\n  CONNECTION_UNLOCK (connection);\n  G_UNLOCK (message_bus_lock);\n\n  if (G_OBJECT_CLASS (g_dbus_connection_parent_class)->dispose != NULL)\n    G_OBJECT_CLASS (g_dbus_connection_parent_class)->dispose (object);\n}\n\nstatic void\ng_dbus_connection_finalize (GObject *object)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (object);\n\n  connection->finalizing = TRUE;\n\n  purge_all_signal_subscriptions (connection);\n\n  purge_all_filters (connection);\n  g_ptr_array_unref (connection->filters);\n\n  if (connection->authentication_observer != NULL)\n    g_object_unref (connection->authentication_observer);\n\n  if (connection->auth != NULL)\n    g_object_unref (connection->auth);\n\n  if (connection->credentials)\n    g_object_unref (connection->credentials);\n\n  if (connection->stream != NULL)\n    {\n      g_object_unref (connection->stream);\n      connection->stream = NULL;\n    }\n\n  g_free (connection->address);\n\n  g_free (connection->guid);\n  g_free (connection->bus_unique_name);\n\n  if (connection->initialization_error != NULL)\n    g_error_free (connection->initialization_error);\n\n  g_hash_table_unref (connection->map_method_serial_to_task);\n\n  g_hash_table_unref (connection->map_rule_to_signal_data);\n  g_hash_table_unref (connection->map_id_to_signal_data);\n  g_hash_table_unref (connection->map_sender_unique_name_to_signal_data_array);\n\n  g_hash_table_unref (connection->map_id_to_ei);\n  g_hash_table_unref (connection->map_object_path_to_eo);\n  g_hash_table_unref (connection->map_id_to_es);\n  g_hash_table_unref (connection->map_object_path_to_es);\n\n  g_hash_table_unref (connection->map_thread_to_last_serial);\n\n  g_main_context_unref (connection->main_context_at_construction);\n\n  g_free (connection->machine_id);\n\n  g_mutex_clear (&connection->init_lock);\n  g_mutex_clear (&connection->lock);\n\n  G_OBJECT_CLASS (g_dbus_connection_parent_class)->finalize (object);\n}\n\n/* called in any user thread, with the connection's lock not held */\nstatic void\ng_dbus_connection_get_property (GObject    *object,\n                                guint       prop_id,\n                                GValue     *value,\n                                GParamSpec *pspec)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (object);\n\n  switch (prop_id)\n    {\n    case PROP_STREAM:\n      g_value_set_object (value, g_dbus_connection_get_stream (connection));\n      break;\n\n    case PROP_GUID:\n      g_value_set_string (value, g_dbus_connection_get_guid (connection));\n      break;\n\n    case PROP_UNIQUE_NAME:\n      g_value_set_string (value, g_dbus_connection_get_unique_name (connection));\n      break;\n\n    case PROP_CLOSED:\n      g_value_set_boolean (value, g_dbus_connection_is_closed (connection));\n      break;\n\n    case PROP_EXIT_ON_CLOSE:\n      g_value_set_boolean (value, g_dbus_connection_get_exit_on_close (connection));\n      break;\n\n    case PROP_CAPABILITY_FLAGS:\n      g_value_set_flags (value, g_dbus_connection_get_capabilities (connection));\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\n/* called in any user thread, with the connection's lock not held */\nstatic void\ng_dbus_connection_set_property (GObject      *object,\n                                guint         prop_id,\n                                const GValue *value,\n                                GParamSpec   *pspec)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (object);\n\n  switch (prop_id)\n    {\n    case PROP_STREAM:\n      connection->stream = g_value_dup_object (value);\n      break;\n\n    case PROP_GUID:\n      connection->guid = g_value_dup_string (value);\n      break;\n\n    case PROP_ADDRESS:\n      connection->address = g_value_dup_string (value);\n      break;\n\n    case PROP_FLAGS:\n      connection->flags = g_value_get_flags (value);\n      break;\n\n    case PROP_EXIT_ON_CLOSE:\n      g_dbus_connection_set_exit_on_close (connection, g_value_get_boolean (value));\n      break;\n\n    case PROP_AUTHENTICATION_OBSERVER:\n      connection->authentication_observer = g_value_dup_object (value);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\n/* Base-class implementation of GDBusConnection::closed.\n *\n * Called in a user thread, by the main context that was thread-default when\n * the object was constructed.\n */\nstatic void\ng_dbus_connection_real_closed (GDBusConnection *connection,\n                               gboolean         remote_peer_vanished,\n                               GError          *error)\n{\n  gint flags = g_atomic_int_get (&connection->atomic_flags);\n\n  /* Because atomic int access is a memory barrier, we can safely read\n   * initialization_error without a lock, as long as we do it afterwards.\n   */\n  if (remote_peer_vanished &&\n      (flags & FLAG_EXIT_ON_CLOSE) != 0 &&\n      (flags & FLAG_INITIALIZED) != 0 &&\n      connection->initialization_error == NULL)\n    {\n      raise (SIGTERM);\n    }\n}\n\nstatic void\ng_dbus_connection_class_init (GDBusConnectionClass *klass)\n{\n  GObjectClass *gobject_class;\n\n  gobject_class = G_OBJECT_CLASS (klass);\n\n  gobject_class->finalize     = g_dbus_connection_finalize;\n  gobject_class->dispose      = g_dbus_connection_dispose;\n  gobject_class->set_property = g_dbus_connection_set_property;\n  gobject_class->get_property = g_dbus_connection_get_property;\n\n  klass->closed = g_dbus_connection_real_closed;\n\n  /**\n   * GDBusConnection:stream:\n   *\n   * The underlying #GIOStream used for I/O.\n   *\n   * If this is passed on construction and is a #GSocketConnection,\n   * then the corresponding #GSocket will be put into non-blocking mode.\n   *\n   * While the #GDBusConnection is active, it will interact with this\n   * stream from a worker thread, so it is not safe to interact with\n   * the stream directly.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_STREAM,\n                                   g_param_spec_object (\"stream\",\n                                                        P_(\"IO Stream\"),\n                                                        P_(\"The underlying streams used for I/O\"),\n                                                        G_TYPE_IO_STREAM,\n                                                        G_PARAM_READABLE |\n                                                        G_PARAM_WRITABLE |\n                                                        G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:address:\n   *\n   * A D-Bus address specifying potential endpoints that can be used\n   * when establishing the connection.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_ADDRESS,\n                                   g_param_spec_string (\"address\",\n                                                        P_(\"Address\"),\n                                                        P_(\"D-Bus address specifying potential socket endpoints\"),\n                                                        NULL,\n                                                        G_PARAM_WRITABLE |\n                                                        G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:flags:\n   *\n   * Flags from the #GDBusConnectionFlags enumeration.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_FLAGS,\n                                   g_param_spec_flags (\"flags\",\n                                                       P_(\"Flags\"),\n                                                       P_(\"Flags\"),\n                                                       G_TYPE_DBUS_CONNECTION_FLAGS,\n                                                       G_DBUS_CONNECTION_FLAGS_NONE,\n                                                       G_PARAM_WRITABLE |\n                                                       G_PARAM_CONSTRUCT_ONLY |\n                                                       G_PARAM_STATIC_NAME |\n                                                       G_PARAM_STATIC_BLURB |\n                                                       G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:guid:\n   *\n   * The GUID of the peer performing the role of server when\n   * authenticating.\n   *\n   * If you are constructing a #GDBusConnection and pass\n   * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the\n   * #GDBusConnection:flags property then you MUST also set this\n   * property to a valid guid.\n   *\n   * If you are constructing a #GDBusConnection and pass\n   * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the\n   * #GDBusConnection:flags property you will be able to read the GUID\n   * of the other peer here after the connection has been successfully\n   * initialized.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_GUID,\n                                   g_param_spec_string (\"guid\",\n                                                        P_(\"GUID\"),\n                                                        P_(\"GUID of the server peer\"),\n                                                        NULL,\n                                                        G_PARAM_READABLE |\n                                                        G_PARAM_WRITABLE |\n                                                        G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:unique-name:\n   *\n   * The unique name as assigned by the message bus or %NULL if the\n   * connection is not open or not a message bus connection.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_UNIQUE_NAME,\n                                   g_param_spec_string (\"unique-name\",\n                                                        P_(\"unique-name\"),\n                                                        P_(\"Unique name of bus connection\"),\n                                                        NULL,\n                                                        G_PARAM_READABLE |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:closed:\n   *\n   * A boolean specifying whether the connection has been closed.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_CLOSED,\n                                   g_param_spec_boolean (\"closed\",\n                                                         P_(\"Closed\"),\n                                                         P_(\"Whether the connection is closed\"),\n                                                         FALSE,\n                                                         G_PARAM_READABLE |\n                                                         G_PARAM_STATIC_NAME |\n                                                         G_PARAM_STATIC_BLURB |\n                                                         G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:exit-on-close:\n   *\n   * A boolean specifying whether the process will be terminated (by\n   * calling `raise(SIGTERM)`) if the connection is closed by the\n   * remote peer.\n   *\n   * Note that #GDBusConnection objects returned by g_bus_get_finish()\n   * and g_bus_get_sync() will (usually) have this property set to %TRUE.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_EXIT_ON_CLOSE,\n                                   g_param_spec_boolean (\"exit-on-close\",\n                                                         P_(\"Exit on close\"),\n                                                         P_(\"Whether the process is terminated when the connection is closed\"),\n                                                         FALSE,\n                                                         G_PARAM_READABLE |\n                                                         G_PARAM_WRITABLE |\n                                                         G_PARAM_STATIC_NAME |\n                                                         G_PARAM_STATIC_BLURB |\n                                                         G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:capabilities:\n   *\n   * Flags from the #GDBusCapabilityFlags enumeration\n   * representing connection features negotiated with the other peer.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_CAPABILITY_FLAGS,\n                                   g_param_spec_flags (\"capabilities\",\n                                                       P_(\"Capabilities\"),\n                                                       P_(\"Capabilities\"),\n                                                       G_TYPE_DBUS_CAPABILITY_FLAGS,\n                                                       G_DBUS_CAPABILITY_FLAGS_NONE,\n                                                       G_PARAM_READABLE |\n                                                       G_PARAM_STATIC_NAME |\n                                                       G_PARAM_STATIC_BLURB |\n                                                       G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection:authentication-observer:\n   *\n   * A #GDBusAuthObserver object to assist in the authentication process or %NULL.\n   *\n   * Since: 2.26\n   */\n  g_object_class_install_property (gobject_class,\n                                   PROP_AUTHENTICATION_OBSERVER,\n                                   g_param_spec_object (\"authentication-observer\",\n                                                        P_(\"Authentication Observer\"),\n                                                        P_(\"Object used to assist in the authentication process\"),\n                                                        G_TYPE_DBUS_AUTH_OBSERVER,\n                                                        G_PARAM_WRITABLE |\n                                                        G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_NAME |\n                                                        G_PARAM_STATIC_BLURB |\n                                                        G_PARAM_STATIC_NICK));\n\n  /**\n   * GDBusConnection::closed:\n   * @connection: the #GDBusConnection emitting the signal\n   * @remote_peer_vanished: %TRUE if @connection is closed because the\n   *     remote peer closed its end of the connection\n   * @error: (nullable): a #GError with more details about the event or %NULL\n   *\n   * Emitted when the connection is closed.\n   *\n   * The cause of this event can be\n   *\n   * - If g_dbus_connection_close() is called. In this case\n   *   @remote_peer_vanished is set to %FALSE and @error is %NULL.\n   *\n   * - If the remote peer closes the connection. In this case\n   *   @remote_peer_vanished is set to %TRUE and @error is set.\n   *\n   * - If the remote peer sends invalid or malformed data. In this\n   *   case @remote_peer_vanished is set to %FALSE and @error is set.\n   *\n   * Upon receiving this signal, you should give up your reference to\n   * @connection. You are guaranteed that this signal is emitted only\n   * once.\n   *\n   * Since: 2.26\n   */\n  signals[CLOSED_SIGNAL] = g_signal_new (I_(\"closed\"),\n                                         G_TYPE_DBUS_CONNECTION,\n                                         G_SIGNAL_RUN_LAST,\n                                         G_STRUCT_OFFSET (GDBusConnectionClass, closed),\n                                         NULL,\n                                         NULL,\n                                         NULL,\n                                         G_TYPE_NONE,\n                                         2,\n                                         G_TYPE_BOOLEAN,\n                                         G_TYPE_ERROR);\n}\n\nstatic void\ng_dbus_connection_init (GDBusConnection *connection)\n{\n  g_mutex_init (&connection->lock);\n  g_mutex_init (&connection->init_lock);\n\n  connection->map_method_serial_to_task = g_hash_table_new (g_direct_hash, g_direct_equal);\n\n  connection->map_rule_to_signal_data = g_hash_table_new (g_str_hash,\n                                                          g_str_equal);\n  connection->map_id_to_signal_data = g_hash_table_new (g_direct_hash,\n                                                        g_direct_equal);\n  connection->map_sender_unique_name_to_signal_data_array = g_hash_table_new_full (g_str_hash,\n                                                                                   g_str_equal,\n                                                                                   g_free,\n                                                                                   (GDestroyNotify) g_ptr_array_unref);\n\n  connection->map_object_path_to_eo = g_hash_table_new_full (g_str_hash,\n                                                             g_str_equal,\n                                                             NULL,\n                                                             (GDestroyNotify) exported_object_free);\n\n  connection->map_id_to_ei = g_hash_table_new (g_direct_hash,\n                                               g_direct_equal);\n\n  connection->map_object_path_to_es = g_hash_table_new_full (g_str_hash,\n                                                             g_str_equal,\n                                                             NULL,\n                                                             (GDestroyNotify) exported_subtree_free);\n\n  connection->map_id_to_es = g_hash_table_new (g_direct_hash,\n                                               g_direct_equal);\n\n  connection->map_thread_to_last_serial = g_hash_table_new (g_direct_hash,\n                                                            g_direct_equal);\n\n  connection->main_context_at_construction = g_main_context_ref_thread_default ();\n\n  connection->filters = g_ptr_array_new ();\n}\n\n/**\n * g_dbus_connection_get_stream:\n * @connection: a #GDBusConnection\n *\n * Gets the underlying stream used for IO.\n *\n * While the #GDBusConnection is active, it will interact with this\n * stream from a worker thread, so it is not safe to interact with\n * the stream directly.\n *\n * Returns: (transfer none): the stream used for IO\n *\n * Since: 2.26\n */\nGIOStream *\ng_dbus_connection_get_stream (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return NULL;\n\n  return connection->stream;\n}\n\n/**\n * g_dbus_connection_start_message_processing:\n * @connection: a #GDBusConnection\n *\n * If @connection was created with\n * %G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method\n * starts processing messages. Does nothing on if @connection wasn't\n * created with this flag or if the method has already been called.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_start_message_processing (GDBusConnection *connection)\n{\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return;\n\n  g_assert (connection->worker != NULL);\n  _g_dbus_worker_unfreeze (connection->worker);\n}\n\n/**\n * g_dbus_connection_is_closed:\n * @connection: a #GDBusConnection\n *\n * Gets whether @connection is closed.\n *\n * Returns: %TRUE if the connection is closed, %FALSE otherwise\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_is_closed (GDBusConnection *connection)\n{\n  gint flags;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n\n  flags = g_atomic_int_get (&connection->atomic_flags);\n\n  return (flags & FLAG_CLOSED) ? TRUE : FALSE;\n}\n\n/**\n * g_dbus_connection_get_capabilities:\n * @connection: a #GDBusConnection\n *\n * Gets the capabilities negotiated with the remote peer\n *\n * Returns: zero or more flags from the #GDBusCapabilityFlags enumeration\n *\n * Since: 2.26\n */\nGDBusCapabilityFlags\ng_dbus_connection_get_capabilities (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), G_DBUS_CAPABILITY_FLAGS_NONE);\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return G_DBUS_CAPABILITY_FLAGS_NONE;\n\n  return connection->capabilities;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called in a temporary thread without holding locks. */\nstatic void\nflush_in_thread_func (GTask         *task,\n                      gpointer       source_object,\n                      gpointer       task_data,\n                      GCancellable  *cancellable)\n{\n  GError *error = NULL;\n\n  if (g_dbus_connection_flush_sync (source_object,\n                                    cancellable,\n                                    &error))\n    g_task_return_boolean (task, TRUE);\n  else\n    g_task_return_error (task, error);\n}\n\n/**\n * g_dbus_connection_flush:\n * @connection: a #GDBusConnection\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the\n *     request is satisfied or %NULL if you don't care about the result\n * @user_data: The data to pass to @callback\n *\n * Asynchronously flushes @connection, that is, writes all queued\n * outgoing message to the transport and then flushes the transport\n * (using g_output_stream_flush_async()). This is useful in programs\n * that wants to emit a D-Bus signal and then exit immediately. Without\n * flushing the connection, there is no guaranteed that the message has\n * been sent to the networking buffers in the OS kernel.\n *\n * This is an asynchronous method. When the operation is finished,\n * @callback will be invoked in the\n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from. You can\n * then call g_dbus_connection_flush_finish() to get the result of the\n * operation. See g_dbus_connection_flush_sync() for the synchronous\n * version.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_flush (GDBusConnection     *connection,\n                         GCancellable        *cancellable,\n                         GAsyncReadyCallback  callback,\n                         gpointer             user_data)\n{\n  GTask *task;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n\n  task = g_task_new (connection, cancellable, callback, user_data);\n  g_task_set_source_tag (task, g_dbus_connection_flush);\n  g_task_run_in_thread (task, flush_in_thread_func);\n  g_object_unref (task);\n}\n\n/**\n * g_dbus_connection_flush_finish:\n * @connection: a #GDBusConnection\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed\n *     to g_dbus_connection_flush()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_flush().\n *\n * Returns: %TRUE if the operation succeeded, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_flush_finish (GDBusConnection  *connection,\n                                GAsyncResult     *res,\n                                GError          **error)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (g_task_is_valid (res, connection), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  return g_task_propagate_boolean (G_TASK (res), error);\n}\n\n/**\n * g_dbus_connection_flush_sync:\n * @connection: a #GDBusConnection\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously flushes @connection. The calling thread is blocked\n * until this is done. See g_dbus_connection_flush() for the\n * asynchronous version of this method and more details about what it\n * does.\n *\n * Returns: %TRUE if the operation succeeded, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_flush_sync (GDBusConnection  *connection,\n                              GCancellable     *cancellable,\n                              GError          **error)\n{\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  ret = FALSE;\n\n  /* This is only a best-effort attempt to see whether the connection is\n   * closed, so it doesn't need the lock. If the connection closes just\n   * after this check, but before scheduling the flush operation, the\n   * result will be more or less the same as if the connection closed while\n   * the flush operation was pending - it'll fail with either CLOSED or\n   * CANCELLED.\n   */\n  if (!check_unclosed (connection, 0, error))\n    goto out;\n\n  g_assert (connection->worker != NULL);\n\n  ret = _g_dbus_worker_flush_sync (connection->worker,\n                                   cancellable,\n                                   error);\n\n out:\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GDBusConnection *connection;\n  GError *error;\n  gboolean remote_peer_vanished;\n} EmitClosedData;\n\nstatic void\nemit_closed_data_free (EmitClosedData *data)\n{\n  g_object_unref (data->connection);\n  if (data->error != NULL)\n    g_error_free (data->error);\n  g_free (data);\n}\n\n/* Called in a user thread that has acquired the main context that was\n * thread-default when the object was constructed\n */\nstatic gboolean\nemit_closed_in_idle (gpointer user_data)\n{\n  EmitClosedData *data = user_data;\n  gboolean result;\n\n  g_object_notify (G_OBJECT (data->connection), \"closed\");\n  g_signal_emit (data->connection,\n                 signals[CLOSED_SIGNAL],\n                 0,\n                 data->remote_peer_vanished,\n                 data->error,\n                 &result);\n  return FALSE;\n}\n\n/* Can be called from any thread, must hold lock.\n * FLAG_CLOSED must already have been set.\n */\nstatic void\nschedule_closed_unlocked (GDBusConnection *connection,\n                          gboolean         remote_peer_vanished,\n                          GError          *error)\n{\n  GSource *idle_source;\n  EmitClosedData *data;\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  data = g_new0 (EmitClosedData, 1);\n  data->connection = g_object_ref (connection);\n  data->remote_peer_vanished = remote_peer_vanished;\n  data->error = error != NULL ? g_error_copy (error) : NULL;\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         emit_closed_in_idle,\n                         data,\n                         (GDestroyNotify) emit_closed_data_free);\n  g_source_set_name (idle_source, \"[gio] emit_closed_in_idle\");\n  g_source_attach (idle_source, connection->main_context_at_construction);\n  g_source_unref (idle_source);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_close:\n * @connection: a #GDBusConnection\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the request is\n *     satisfied or %NULL if you don't care about the result\n * @user_data: The data to pass to @callback\n *\n * Closes @connection. Note that this never causes the process to\n * exit (this might only happen if the other end of a shared message\n * bus connection disconnects, see #GDBusConnection:exit-on-close).\n *\n * Once the connection is closed, operations such as sending a message\n * will return with the error %G_IO_ERROR_CLOSED. Closing a connection\n * will not automatically flush the connection so queued messages may\n * be lost. Use g_dbus_connection_flush() if you need such guarantees.\n *\n * If @connection is already closed, this method fails with\n * %G_IO_ERROR_CLOSED.\n *\n * When @connection has been closed, the #GDBusConnection::closed\n * signal is emitted in the\n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread that @connection was constructed in.\n *\n * This is an asynchronous method. When the operation is finished,\n * @callback will be invoked in the \n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from. You can\n * then call g_dbus_connection_close_finish() to get the result of the\n * operation. See g_dbus_connection_close_sync() for the synchronous\n * version.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_close (GDBusConnection     *connection,\n                         GCancellable        *cancellable,\n                         GAsyncReadyCallback  callback,\n                         gpointer             user_data)\n{\n  GTask *task;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return;\n\n  g_assert (connection->worker != NULL);\n\n  task = g_task_new (connection, cancellable, callback, user_data);\n  g_task_set_source_tag (task, g_dbus_connection_close);\n  _g_dbus_worker_close (connection->worker, task);\n  g_object_unref (task);\n}\n\n/**\n * g_dbus_connection_close_finish:\n * @connection: a #GDBusConnection\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed\n *     to g_dbus_connection_close()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_close().\n *\n * Returns: %TRUE if the operation succeeded, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_close_finish (GDBusConnection  *connection,\n                                GAsyncResult     *res,\n                                GError          **error)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (g_task_is_valid (res, connection), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  return g_task_propagate_boolean (G_TASK (res), error);\n}\n\ntypedef struct {\n    GMainLoop *loop;\n    GAsyncResult *result;\n} SyncCloseData;\n\n/* Can be called by any thread, without the connection lock */\nstatic void\nsync_close_cb (GObject *source_object,\n               GAsyncResult *res,\n               gpointer user_data)\n{\n  SyncCloseData *data = user_data;\n\n  data->result = g_object_ref (res);\n  g_main_loop_quit (data->loop);\n}\n\n/**\n * g_dbus_connection_close_sync:\n * @connection: a #GDBusConnection\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously closes @connection. The calling thread is blocked\n * until this is done. See g_dbus_connection_close() for the\n * asynchronous version of this method and more details about what it\n * does.\n *\n * Returns: %TRUE if the operation succeeded, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_close_sync (GDBusConnection  *connection,\n                              GCancellable     *cancellable,\n                              GError          **error)\n{\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  ret = FALSE;\n\n  if (check_unclosed (connection, 0, error))\n    {\n      GMainContext *context;\n      SyncCloseData data;\n\n      context = g_main_context_new ();\n      g_main_context_push_thread_default (context);\n      data.loop = g_main_loop_new (context, TRUE);\n      data.result = NULL;\n\n      g_dbus_connection_close (connection, cancellable, sync_close_cb, &data);\n      g_main_loop_run (data.loop);\n      ret = g_dbus_connection_close_finish (connection, data.result, error);\n\n      g_object_unref (data.result);\n      g_main_loop_unref (data.loop);\n      g_main_context_pop_thread_default (context);\n      g_main_context_unref (context);\n    }\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_get_last_serial:\n * @connection: a #GDBusConnection\n *\n * Retrieves the last serial number assigned to a #GDBusMessage on\n * the current thread. This includes messages sent via both low-level\n * API such as g_dbus_connection_send_message() as well as\n * high-level API such as g_dbus_connection_emit_signal(),\n * g_dbus_connection_call() or g_dbus_proxy_call().\n *\n * Returns: the last used serial or zero when no message has been sent\n *     within the current thread\n *\n * Since: 2.34\n */\nguint32\ng_dbus_connection_get_last_serial (GDBusConnection *connection)\n{\n  guint32 ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n\n  CONNECTION_LOCK (connection);\n  ret = GPOINTER_TO_UINT (g_hash_table_lookup (connection->map_thread_to_last_serial,\n                                               g_thread_self ()));\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Can be called by any thread, with the connection lock held */\nstatic gboolean\ng_dbus_connection_send_message_unlocked (GDBusConnection   *connection,\n                                         GDBusMessage      *message,\n                                         GDBusSendMessageFlags flags,\n                                         volatile guint32  *out_serial,\n                                         GError           **error)\n{\n  guchar *blob;\n  gsize blob_size;\n  guint32 serial_to_use;\n  gboolean ret;\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (G_IS_DBUS_MESSAGE (message), FALSE);\n\n  /* TODO: check all necessary headers are present */\n\n  ret = FALSE;\n  blob = NULL;\n\n  if (out_serial != NULL)\n    *out_serial = 0;\n\n  /* If we're in initable_init(), don't check for being initialized, to avoid\n   * chicken-and-egg problems. initable_init() is responsible for setting up\n   * our prerequisites (mainly connection->worker), and only calling us\n   * from its own thread (so no memory barrier is needed).\n   */\n  if (!check_unclosed (connection,\n                       (flags & SEND_MESSAGE_FLAGS_INITIALIZING) ? MAY_BE_UNINITIALIZED : 0,\n                       error))\n    goto out;\n\n  blob = g_dbus_message_to_blob (message,\n                                 &blob_size,\n                                 connection->capabilities,\n                                 error);\n  if (blob == NULL)\n    goto out;\n\n  if (flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL)\n    serial_to_use = g_dbus_message_get_serial (message);\n  else\n    serial_to_use = ++connection->last_serial; /* TODO: handle overflow */\n\n  switch (blob[0])\n    {\n    case 'l':\n      ((guint32 *) blob)[2] = GUINT32_TO_LE (serial_to_use);\n      break;\n    case 'B':\n      ((guint32 *) blob)[2] = GUINT32_TO_BE (serial_to_use);\n      break;\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n#if 0\n  g_printerr (\"Writing message of %\" G_GSIZE_FORMAT \" bytes (serial %d) on %p:\\n\",\n              blob_size, serial_to_use, connection);\n  g_printerr (\"----\\n\");\n  hexdump (blob, blob_size);\n  g_printerr (\"----\\n\");\n#endif\n\n  /* TODO: use connection->auth to encode the blob */\n\n  if (out_serial != NULL)\n    *out_serial = serial_to_use;\n\n  /* store used serial for the current thread */\n  /* TODO: watch the thread disposal and remove associated record\n   *       from hashtable\n   *  - see https://bugzilla.gnome.org/show_bug.cgi?id=676825#c7\n   */\n  g_hash_table_replace (connection->map_thread_to_last_serial,\n                        g_thread_self (),\n                        GUINT_TO_POINTER (serial_to_use));\n\n  if (!(flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL))\n    g_dbus_message_set_serial (message, serial_to_use);\n\n  g_dbus_message_lock (message);\n  _g_dbus_worker_send_message (connection->worker,\n                               message,\n                               (gchar*) blob,\n                               blob_size);\n  blob = NULL; /* since _g_dbus_worker_send_message() steals the blob */\n\n  ret = TRUE;\n\n out:\n  g_free (blob);\n\n  return ret;\n}\n\n/**\n * g_dbus_connection_send_message:\n * @connection: a #GDBusConnection\n * @message: a #GDBusMessage\n * @flags: flags affecting how the message is sent\n * @out_serial: (out) (optional): return location for serial number assigned\n *     to @message when sending it or %NULL\n * @error: Return location for error or %NULL\n *\n * Asynchronously sends @message to the peer represented by @connection.\n *\n * Unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number\n * will be assigned by @connection and set on @message via\n * g_dbus_message_set_serial(). If @out_serial is not %NULL, then the\n * serial number used will be written to this location prior to\n * submitting the message to the underlying transport.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @message is not well-formed,\n * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]\n * for an example of how to use this low-level API to send and receive\n * UNIX file descriptors.\n *\n * Note that @message must be unlocked, unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.\n *\n * Returns: %TRUE if the message was well-formed and queued for\n *     transmission, %FALSE if @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_send_message (GDBusConnection        *connection,\n                                GDBusMessage           *message,\n                                GDBusSendMessageFlags   flags,\n                                volatile guint32       *out_serial,\n                                GError                **error)\n{\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (G_IS_DBUS_MESSAGE (message), FALSE);\n  g_return_val_if_fail ((flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL) || !g_dbus_message_get_locked (message), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  CONNECTION_LOCK (connection);\n  ret = g_dbus_connection_send_message_unlocked (connection, message, flags, out_serial, error);\n  CONNECTION_UNLOCK (connection);\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  guint32 serial;\n\n  gulong cancellable_handler_id;\n\n  GSource *timeout_source;\n\n  gboolean delivered;\n} SendMessageData;\n\n/* Can be called from any thread with or without lock held */\nstatic void\nsend_message_data_free (SendMessageData *data)\n{\n  g_assert (data->timeout_source == NULL);\n  g_assert (data->cancellable_handler_id == 0);\n\n  g_slice_free (SendMessageData, data);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* can be called from any thread with lock held; @task is (transfer full) */\nstatic void\nsend_message_with_reply_cleanup (GTask *task, gboolean remove)\n{\n  GDBusConnection *connection = g_task_get_source_object (task);\n  SendMessageData *data = g_task_get_task_data (task);\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  g_assert (!data->delivered);\n\n  data->delivered = TRUE;\n\n  if (data->timeout_source != NULL)\n    {\n      g_source_destroy (data->timeout_source);\n      data->timeout_source = NULL;\n    }\n  if (data->cancellable_handler_id > 0)\n    {\n      g_cancellable_disconnect (g_task_get_cancellable (task), data->cancellable_handler_id);\n      data->cancellable_handler_id = 0;\n    }\n\n  if (remove)\n    {\n      gboolean removed = g_hash_table_remove (connection->map_method_serial_to_task,\n                                              GUINT_TO_POINTER (data->serial));\n      g_warn_if_fail (removed);\n    }\n\n  g_object_unref (task);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called from GDBus worker thread with lock held; @task is (transfer full). */\nstatic void\nsend_message_data_deliver_reply_unlocked (GTask           *task,\n                                          GDBusMessage    *reply)\n{\n  SendMessageData *data = g_task_get_task_data (task);\n\n  if (data->delivered)\n    goto out;\n\n  g_task_return_pointer (task, g_object_ref (reply), g_object_unref);\n\n  send_message_with_reply_cleanup (task, TRUE);\n\n out:\n  ;\n}\n\n/* Called from a user thread, lock is not held */\nstatic void\nsend_message_data_deliver_error (GTask      *task,\n                                 GQuark      domain,\n                                 gint        code,\n                                 const char *message)\n{\n  GDBusConnection *connection = g_task_get_source_object (task);\n  SendMessageData *data = g_task_get_task_data (task);\n\n  CONNECTION_LOCK (connection);\n  if (data->delivered)\n    {\n      CONNECTION_UNLOCK (connection);\n      return;\n    }\n\n  g_object_ref (task);\n  send_message_with_reply_cleanup (task, TRUE);\n  CONNECTION_UNLOCK (connection);\n\n  g_task_return_new_error (task, domain, code, \"%s\", message);\n  g_object_unref (task);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called from a user thread, lock is not held; @task is (transfer full) */\nstatic gboolean\nsend_message_with_reply_cancelled_idle_cb (gpointer user_data)\n{\n  GTask *task = user_data;\n\n  send_message_data_deliver_error (task, G_IO_ERROR, G_IO_ERROR_CANCELLED,\n                                   _(\"Operation was cancelled\"));\n  return FALSE;\n}\n\n/* Can be called from any thread with or without lock held */\nstatic void\nsend_message_with_reply_cancelled_cb (GCancellable *cancellable,\n                                      gpointer      user_data)\n{\n  GTask *task = user_data;\n  GSource *idle_source;\n\n  /* postpone cancellation to idle handler since we may be called directly\n   * via g_cancellable_connect() (e.g. holding lock)\n   */\n  idle_source = g_idle_source_new ();\n  g_source_set_name (idle_source, \"[gio] send_message_with_reply_cancelled_idle_cb\");\n  g_task_attach_source (task, idle_source, send_message_with_reply_cancelled_idle_cb);\n  g_source_unref (idle_source);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called from a user thread, lock is not held; @task is (transfer full) */\nstatic gboolean\nsend_message_with_reply_timeout_cb (gpointer user_data)\n{\n  GTask *task = user_data;\n\n  send_message_data_deliver_error (task, G_IO_ERROR, G_IO_ERROR_TIMED_OUT,\n                                   _(\"Timeout was reached\"));\n  return FALSE;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called from a user thread, connection's lock is held */\nstatic void\ng_dbus_connection_send_message_with_reply_unlocked (GDBusConnection     *connection,\n                                                    GDBusMessage        *message,\n                                                    GDBusSendMessageFlags flags,\n                                                    gint                 timeout_msec,\n                                                    volatile guint32    *out_serial,\n                                                    GCancellable        *cancellable,\n                                                    GAsyncReadyCallback  callback,\n                                                    gpointer             user_data)\n{\n  GTask *task;\n  SendMessageData *data;\n  GError *error = NULL;\n  volatile guint32 serial;\n\n  if (out_serial == NULL)\n    out_serial = &serial;\n\n  if (timeout_msec == -1)\n    timeout_msec = 25 * 1000;\n\n  data = g_slice_new0 (SendMessageData);\n  task = g_task_new (connection, cancellable, callback, user_data);\n  g_task_set_source_tag (task,\n                         g_dbus_connection_send_message_with_reply_unlocked);\n  g_task_set_task_data (task, data, (GDestroyNotify) send_message_data_free);\n\n  if (g_task_return_error_if_cancelled (task))\n    {\n      g_object_unref (task);\n      return;\n    }\n\n  if (!g_dbus_connection_send_message_unlocked (connection, message, flags, out_serial, &error))\n    {\n      g_task_return_error (task, error);\n      g_object_unref (task);\n      return;\n    }\n  data->serial = *out_serial;\n\n  if (cancellable != NULL)\n    {\n      data->cancellable_handler_id = g_cancellable_connect (cancellable,\n                                                            G_CALLBACK (send_message_with_reply_cancelled_cb),\n                                                            g_object_ref (task),\n                                                            g_object_unref);\n    }\n\n  if (timeout_msec != G_MAXINT)\n    {\n      data->timeout_source = g_timeout_source_new (timeout_msec);\n      g_task_attach_source (task, data->timeout_source,\n                            (GSourceFunc) send_message_with_reply_timeout_cb);\n      g_source_unref (data->timeout_source);\n    }\n\n  g_hash_table_insert (connection->map_method_serial_to_task,\n                       GUINT_TO_POINTER (*out_serial),\n                       g_steal_pointer (&task));\n}\n\n/**\n * g_dbus_connection_send_message_with_reply:\n * @connection: a #GDBusConnection\n * @message: a #GDBusMessage\n * @flags: flags affecting how the message is sent\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @out_serial: (out) (optional): return location for serial number assigned\n *     to @message when sending it or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the request\n *     is satisfied or %NULL if you don't care about the result\n * @user_data: The data to pass to @callback\n *\n * Asynchronously sends @message to the peer represented by @connection.\n *\n * Unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number\n * will be assigned by @connection and set on @message via\n * g_dbus_message_set_serial(). If @out_serial is not %NULL, then the\n * serial number used will be written to this location prior to\n * submitting the message to the underlying transport.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will\n * fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,\n * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * This is an asynchronous method. When the operation is finished, @callback\n * will be invoked in the \n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from. You can then call\n * g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.\n * See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.\n *\n * Note that @message must be unlocked, unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.\n *\n * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]\n * for an example of how to use this low-level API to send and receive\n * UNIX file descriptors.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_send_message_with_reply (GDBusConnection       *connection,\n                                           GDBusMessage          *message,\n                                           GDBusSendMessageFlags  flags,\n                                           gint                   timeout_msec,\n                                           volatile guint32      *out_serial,\n                                           GCancellable          *cancellable,\n                                           GAsyncReadyCallback    callback,\n                                           gpointer               user_data)\n{\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n  g_return_if_fail (G_IS_DBUS_MESSAGE (message));\n  g_return_if_fail ((flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL) || !g_dbus_message_get_locked (message));\n  g_return_if_fail (timeout_msec >= 0 || timeout_msec == -1);\n\n  CONNECTION_LOCK (connection);\n  g_dbus_connection_send_message_with_reply_unlocked (connection,\n                                                      message,\n                                                      flags,\n                                                      timeout_msec,\n                                                      out_serial,\n                                                      cancellable,\n                                                      callback,\n                                                      user_data);\n  CONNECTION_UNLOCK (connection);\n}\n\n/**\n * g_dbus_connection_send_message_with_reply_finish:\n * @connection: a #GDBusConnection\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n *     g_dbus_connection_send_message_with_reply()\n * @error: teturn location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_send_message_with_reply().\n *\n * Note that @error is only set if a local in-process error\n * occurred. That is to say that the returned #GDBusMessage object may\n * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use\n * g_dbus_message_to_gerror() to transcode this to a #GError.\n *\n * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]\n * for an example of how to use this low-level API to send and receive\n * UNIX file descriptors.\n *\n * Returns: (transfer full): a locked #GDBusMessage or %NULL if @error is set\n *\n * Since: 2.26\n */\nGDBusMessage *\ng_dbus_connection_send_message_with_reply_finish (GDBusConnection  *connection,\n                                                  GAsyncResult     *res,\n                                                  GError          **error)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  g_return_val_if_fail (g_task_is_valid (res, connection), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  return g_task_propagate_pointer (G_TASK (res), error);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GAsyncResult *res;\n  GMainContext *context;\n  GMainLoop *loop;\n} SendMessageSyncData;\n\n/* Called from a user thread, lock is not held */\nstatic void\nsend_message_with_reply_sync_cb (GDBusConnection *connection,\n                                 GAsyncResult    *res,\n                                 gpointer         user_data)\n{\n  SendMessageSyncData *data = user_data;\n  data->res = g_object_ref (res);\n  g_main_loop_quit (data->loop);\n}\n\n/**\n * g_dbus_connection_send_message_with_reply_sync:\n * @connection: a #GDBusConnection\n * @message: a #GDBusMessage\n * @flags: flags affecting how the message is sent.\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @out_serial: (out) (optional): return location for serial number\n *     assigned to @message when sending it or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously sends @message to the peer represented by @connection\n * and blocks the calling thread until a reply is received or the\n * timeout is reached. See g_dbus_connection_send_message_with_reply()\n * for the asynchronous version of this method.\n *\n * Unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number\n * will be assigned by @connection and set on @message via\n * g_dbus_message_set_serial(). If @out_serial is not %NULL, then the\n * serial number used will be written to this location prior to\n * submitting the message to the underlying transport.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will\n * fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,\n * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * Note that @error is only set if a local in-process error\n * occurred. That is to say that the returned #GDBusMessage object may\n * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use\n * g_dbus_message_to_gerror() to transcode this to a #GError.\n *\n * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]\n * for an example of how to use this low-level API to send and receive\n * UNIX file descriptors.\n *\n * Note that @message must be unlocked, unless @flags contain the\n * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.\n *\n * Returns: (transfer full): a locked #GDBusMessage that is the reply\n *     to @message or %NULL if @error is set\n *\n * Since: 2.26\n */\nGDBusMessage *\ng_dbus_connection_send_message_with_reply_sync (GDBusConnection        *connection,\n                                                GDBusMessage           *message,\n                                                GDBusSendMessageFlags   flags,\n                                                gint                    timeout_msec,\n                                                volatile guint32       *out_serial,\n                                                GCancellable           *cancellable,\n                                                GError                **error)\n{\n  SendMessageSyncData data;\n  GDBusMessage *reply;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  g_return_val_if_fail (G_IS_DBUS_MESSAGE (message), NULL);\n  g_return_val_if_fail ((flags & G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL) || !g_dbus_message_get_locked (message), NULL);\n  g_return_val_if_fail (timeout_msec >= 0 || timeout_msec == -1, NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  data.res = NULL;\n  data.context = g_main_context_new ();\n  data.loop = g_main_loop_new (data.context, FALSE);\n\n  g_main_context_push_thread_default (data.context);\n\n  g_dbus_connection_send_message_with_reply (connection,\n                                             message,\n                                             flags,\n                                             timeout_msec,\n                                             out_serial,\n                                             cancellable,\n                                             (GAsyncReadyCallback) send_message_with_reply_sync_cb,\n                                             &data);\n  g_main_loop_run (data.loop);\n  reply = g_dbus_connection_send_message_with_reply_finish (connection,\n                                                            data.res,\n                                                            error);\n\n  g_main_context_pop_thread_default (data.context);\n\n  g_main_context_unref (data.context);\n  g_main_loop_unref (data.loop);\n  if (data.res)\n    g_object_unref (data.res);\n\n  return reply;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  guint                       id;\n  guint                       ref_count;\n  GDBusMessageFilterFunction  filter_function;\n  gpointer                    user_data;\n  GDestroyNotify              user_data_free_func;\n  GMainContext               *context;\n} FilterData;\n\n/* requires CONNECTION_LOCK */\nstatic FilterData **\ncopy_filter_list (GPtrArray *filters)\n{\n  FilterData **copy;\n  guint n;\n\n  copy = g_new (FilterData *, filters->len + 1);\n  for (n = 0; n < filters->len; n++)\n    {\n      copy[n] = filters->pdata[n];\n      copy[n]->ref_count++;\n    }\n  copy[n] = NULL;\n\n  return copy;\n}\n\n/* requires CONNECTION_LOCK */\nstatic void\nfree_filter_list (FilterData **filters)\n{\n  guint n;\n\n  for (n = 0; filters[n]; n++)\n    {\n      filters[n]->ref_count--;\n      if (filters[n]->ref_count == 0)\n        {\n          call_destroy_notify (filters[n]->context,\n                               filters[n]->user_data_free_func,\n                               filters[n]->user_data);\n          g_main_context_unref (filters[n]->context);\n          g_free (filters[n]);\n        }\n    }\n  g_free (filters);\n}\n\n/* Called in GDBusWorker's thread - we must not block - with no lock held */\nstatic void\non_worker_message_received (GDBusWorker  *worker,\n                            GDBusMessage *message,\n                            gpointer      user_data)\n{\n  GDBusConnection *connection;\n  FilterData **filters;\n  guint n;\n  gboolean alive;\n\n  G_LOCK (message_bus_lock);\n  alive = g_hash_table_contains (alive_connections, user_data);\n  if (!alive)\n    {\n      G_UNLOCK (message_bus_lock);\n      return;\n    }\n  connection = G_DBUS_CONNECTION (user_data);\n  g_object_ref (connection);\n  G_UNLOCK (message_bus_lock);\n\n  //g_debug (\"in on_worker_message_received\");\n\n  g_object_ref (message);\n  g_dbus_message_lock (message);\n\n  //g_debug (\"boo ref_count = %d %p %p\", G_OBJECT (connection)->ref_count, connection, connection->worker);\n\n  /* First collect the set of callback functions */\n  CONNECTION_LOCK (connection);\n  filters = copy_filter_list (connection->filters);\n  CONNECTION_UNLOCK (connection);\n\n  /* then call the filters in order (without holding the lock) */\n  for (n = 0; filters[n]; n++)\n    {\n      message = filters[n]->filter_function (connection,\n                                             message,\n                                             TRUE,\n                                             filters[n]->user_data);\n      if (message == NULL)\n        break;\n      g_dbus_message_lock (message);\n    }\n\n  CONNECTION_LOCK (connection);\n  free_filter_list (filters);\n  CONNECTION_UNLOCK (connection);\n\n  /* Standard dispatch unless the filter ate the message - no need to\n   * do anything if the message was altered\n   */\n  if (message != NULL)\n    {\n      GDBusMessageType message_type;\n\n      message_type = g_dbus_message_get_message_type (message);\n      if (message_type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN || message_type == G_DBUS_MESSAGE_TYPE_ERROR)\n        {\n          guint32 reply_serial;\n          GTask *task;\n\n          reply_serial = g_dbus_message_get_reply_serial (message);\n          CONNECTION_LOCK (connection);\n          task = g_hash_table_lookup (connection->map_method_serial_to_task,\n                                      GUINT_TO_POINTER (reply_serial));\n          if (task != NULL)\n            {\n              /* This removes @task from @map_method_serial_to_task. */\n              //g_debug (\"delivering reply/error for serial %d for %p\", reply_serial, connection);\n              send_message_data_deliver_reply_unlocked (task, message);\n            }\n          else\n            {\n              //g_debug (\"message reply/error for serial %d but no SendMessageData found for %p\", reply_serial, connection);\n            }\n          CONNECTION_UNLOCK (connection);\n        }\n      else if (message_type == G_DBUS_MESSAGE_TYPE_SIGNAL)\n        {\n          CONNECTION_LOCK (connection);\n          distribute_signals (connection, message);\n          CONNECTION_UNLOCK (connection);\n        }\n      else if (message_type == G_DBUS_MESSAGE_TYPE_METHOD_CALL)\n        {\n          CONNECTION_LOCK (connection);\n          distribute_method_call (connection, message);\n          CONNECTION_UNLOCK (connection);\n        }\n    }\n\n  if (message != NULL)\n    g_object_unref (message);\n  g_object_unref (connection);\n}\n\n/* Called in GDBusWorker's thread, lock is not held */\nstatic GDBusMessage *\non_worker_message_about_to_be_sent (GDBusWorker  *worker,\n                                    GDBusMessage *message,\n                                    gpointer      user_data)\n{\n  GDBusConnection *connection;\n  FilterData **filters;\n  guint n;\n  gboolean alive;\n\n  G_LOCK (message_bus_lock);\n  alive = g_hash_table_contains (alive_connections, user_data);\n  if (!alive)\n    {\n      G_UNLOCK (message_bus_lock);\n      return message;\n    }\n  connection = G_DBUS_CONNECTION (user_data);\n  g_object_ref (connection);\n  G_UNLOCK (message_bus_lock);\n\n  //g_debug (\"in on_worker_message_about_to_be_sent\");\n\n  /* First collect the set of callback functions */\n  CONNECTION_LOCK (connection);\n  filters = copy_filter_list (connection->filters);\n  CONNECTION_UNLOCK (connection);\n\n  /* then call the filters in order (without holding the lock) */\n  for (n = 0; filters[n]; n++)\n    {\n      g_dbus_message_lock (message);\n      message = filters[n]->filter_function (connection,\n                                             message,\n                                             FALSE,\n                                             filters[n]->user_data);\n      if (message == NULL)\n        break;\n    }\n\n  CONNECTION_LOCK (connection);\n  free_filter_list (filters);\n  CONNECTION_UNLOCK (connection);\n\n  g_object_unref (connection);\n\n  return message;\n}\n\n/* called with connection lock held, in GDBusWorker thread */\nstatic gboolean\ncancel_method_on_close (gpointer key, gpointer value, gpointer user_data)\n{\n  GTask *task = value;\n  SendMessageData *data = g_task_get_task_data (task);\n\n  if (data->delivered)\n    return FALSE;\n\n  g_task_return_new_error (task,\n                           G_IO_ERROR,\n                           G_IO_ERROR_CLOSED,\n                           _(\"The connection is closed\"));\n\n  /* Ask send_message_with_reply_cleanup not to remove the element from the\n   * hash table - we're in the middle of a foreach; that would be unsafe.\n   * Instead, return TRUE from this function so that it gets removed safely.\n   */\n  send_message_with_reply_cleanup (task, FALSE);\n  return TRUE;\n}\n\n/* Called in GDBusWorker's thread - we must not block - without lock held */\nstatic void\non_worker_closed (GDBusWorker *worker,\n                  gboolean     remote_peer_vanished,\n                  GError      *error,\n                  gpointer     user_data)\n{\n  GDBusConnection *connection;\n  gboolean alive;\n  guint old_atomic_flags;\n\n  G_LOCK (message_bus_lock);\n  alive = g_hash_table_contains (alive_connections, user_data);\n  if (!alive)\n    {\n      G_UNLOCK (message_bus_lock);\n      return;\n    }\n  connection = G_DBUS_CONNECTION (user_data);\n  g_object_ref (connection);\n  G_UNLOCK (message_bus_lock);\n\n  //g_debug (\"in on_worker_closed: %s\", error->message);\n\n  CONNECTION_LOCK (connection);\n  /* Even though this is atomic, we do it inside the lock to avoid breaking\n   * assumptions in remove_match_rule(). We'd need the lock in a moment\n   * anyway, so, no loss.\n   */\n  old_atomic_flags = g_atomic_int_or (&connection->atomic_flags, FLAG_CLOSED);\n\n  if (!(old_atomic_flags & FLAG_CLOSED))\n    {\n      g_hash_table_foreach_remove (connection->map_method_serial_to_task, cancel_method_on_close, NULL);\n      schedule_closed_unlocked (connection, remote_peer_vanished, error);\n    }\n  CONNECTION_UNLOCK (connection);\n\n  g_object_unref (connection);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Determines the biggest set of capabilities we can support on this\n * connection.\n *\n * Called with the init_lock held.\n */\nstatic GDBusCapabilityFlags\nget_offered_capabilities_max (GDBusConnection *connection)\n{\n      GDBusCapabilityFlags ret;\n      ret = G_DBUS_CAPABILITY_FLAGS_NONE;\n#ifdef G_OS_UNIX\n      if (G_IS_UNIX_CONNECTION (connection->stream))\n        ret |= G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING;\n#endif\n      return ret;\n}\n\n/* Called in a user thread, lock is not held */\nstatic gboolean\ninitable_init (GInitable     *initable,\n               GCancellable  *cancellable,\n               GError       **error)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (initable);\n  gboolean ret;\n\n  /* This method needs to be idempotent to work with the singleton\n   * pattern. See the docs for g_initable_init(). We implement this by\n   * locking.\n   *\n   * Unfortunately we can't use the main lock since the on_worker_*()\n   * callbacks above needs the lock during initialization (for message\n   * bus connections we do a synchronous Hello() call on the bus).\n   */\n  g_mutex_lock (&connection->init_lock);\n\n  ret = FALSE;\n\n  /* Make this a no-op if we're already initialized (successfully or\n   * unsuccessfully)\n   */\n  if ((g_atomic_int_get (&connection->atomic_flags) & FLAG_INITIALIZED))\n    {\n      ret = (connection->initialization_error == NULL);\n      goto out;\n    }\n\n  /* Because of init_lock, we can't get here twice in different threads */\n  g_assert (connection->initialization_error == NULL);\n\n  /* The user can pass multiple (but mutally exclusive) construct\n   * properties:\n   *\n   *  - stream (of type GIOStream)\n   *  - address (of type gchar*)\n   *\n   * At the end of the day we end up with a non-NULL GIOStream\n   * object in connection->stream.\n   */\n  if (connection->address != NULL)\n    {\n      g_assert (connection->stream == NULL);\n\n      if ((connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER) ||\n          (connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS))\n        {\n          g_set_error_literal (&connection->initialization_error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_INVALID_ARGUMENT,\n                               _(\"Unsupported flags encountered when constructing a client-side connection\"));\n          goto out;\n        }\n\n      connection->stream = g_dbus_address_get_stream_sync (connection->address,\n                                                           NULL, /* TODO: out_guid */\n                                                           cancellable,\n                                                           &connection->initialization_error);\n      if (connection->stream == NULL)\n        goto out;\n    }\n  else if (connection->stream != NULL)\n    {\n      /* nothing to do */\n    }\n  else\n    {\n      g_assert_not_reached ();\n    }\n\n  /* Authenticate the connection */\n  if (connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER)\n    {\n      g_assert (!(connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT));\n      g_assert (connection->guid != NULL);\n      connection->auth = _g_dbus_auth_new (connection->stream);\n      if (!_g_dbus_auth_run_server (connection->auth,\n                                    connection->authentication_observer,\n                                    connection->guid,\n                                    (connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS),\n                                    get_offered_capabilities_max (connection),\n                                    &connection->capabilities,\n                                    &connection->credentials,\n                                    cancellable,\n                                    &connection->initialization_error))\n        goto out;\n    }\n  else if (connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT)\n    {\n      g_assert (!(connection->flags & G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER));\n      g_assert (connection->guid == NULL);\n      connection->auth = _g_dbus_auth_new (connection->stream);\n      connection->guid = _g_dbus_auth_run_client (connection->auth,\n                                                  connection->authentication_observer,\n                                                  get_offered_capabilities_max (connection),\n                                                  &connection->capabilities,\n                                                  cancellable,\n                                                  &connection->initialization_error);\n      if (connection->guid == NULL)\n        goto out;\n    }\n\n  if (connection->authentication_observer != NULL)\n    {\n      g_object_unref (connection->authentication_observer);\n      connection->authentication_observer = NULL;\n    }\n\n  //g_output_stream_flush (G_SOCKET_CONNECTION (connection->stream)\n\n  //g_debug (\"haz unix fd passing powers: %d\", connection->capabilities & G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING);\n\n#ifdef G_OS_UNIX\n  /* We want all IO operations to be non-blocking since they happen in\n   * the worker thread which is shared by _all_ connections.\n   */\n  if (G_IS_SOCKET_CONNECTION (connection->stream))\n    {\n      g_socket_set_blocking (g_socket_connection_get_socket (G_SOCKET_CONNECTION (connection->stream)), FALSE);\n    }\n#endif\n\n  G_LOCK (message_bus_lock);\n  if (alive_connections == NULL)\n    alive_connections = g_hash_table_new (g_direct_hash, g_direct_equal);\n  g_hash_table_add (alive_connections, connection);\n  G_UNLOCK (message_bus_lock);\n\n  connection->worker = _g_dbus_worker_new (connection->stream,\n                                           connection->capabilities,\n                                           ((connection->flags & G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING) != 0),\n                                           on_worker_message_received,\n                                           on_worker_message_about_to_be_sent,\n                                           on_worker_closed,\n                                           connection);\n\n  /* if a bus connection, call org.freedesktop.DBus.Hello - this is how we're getting a name */\n  if (connection->flags & G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION)\n    {\n      GVariant *hello_result;\n\n      /* we could lift this restriction by adding code in gdbusprivate.c */\n      if (connection->flags & G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING)\n        {\n          g_set_error_literal (&connection->initialization_error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_FAILED,\n                               \"Cannot use DELAY_MESSAGE_PROCESSING with MESSAGE_BUS_CONNECTION\");\n          goto out;\n        }\n\n      hello_result = g_dbus_connection_call_sync (connection,\n                                                  \"org.freedesktop.DBus\", /* name */\n                                                  \"/org/freedesktop/DBus\", /* path */\n                                                  \"org.freedesktop.DBus\", /* interface */\n                                                  \"Hello\",\n                                                  NULL, /* parameters */\n                                                  G_VARIANT_TYPE (\"(s)\"),\n                                                  CALL_FLAGS_INITIALIZING,\n                                                  -1,\n                                                  NULL, /* TODO: cancellable */\n                                                  &connection->initialization_error);\n      if (hello_result == NULL)\n        goto out;\n\n      g_variant_get (hello_result, \"(s)\", &connection->bus_unique_name);\n      g_variant_unref (hello_result);\n      //g_debug (\"unique name is '%s'\", connection->bus_unique_name);\n    }\n\n  ret = TRUE;\n out:\n  if (!ret)\n    {\n      g_assert (connection->initialization_error != NULL);\n      g_propagate_error (error, g_error_copy (connection->initialization_error));\n    }\n\n  g_atomic_int_or (&connection->atomic_flags, FLAG_INITIALIZED);\n  g_mutex_unlock (&connection->init_lock);\n\n  return ret;\n}\n\nstatic void\ninitable_iface_init (GInitableIface *initable_iface)\n{\n  initable_iface->init = initable_init;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic void\nasync_initable_iface_init (GAsyncInitableIface *async_initable_iface)\n{\n  /* Use default */\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_new:\n * @stream: a #GIOStream\n * @guid: (nullable): the GUID to use if a authenticating as a server or %NULL\n * @flags: flags describing how to make the connection\n * @observer: (nullable): a #GDBusAuthObserver or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: a #GAsyncReadyCallback to call when the request is satisfied\n * @user_data: the data to pass to @callback\n *\n * Asynchronously sets up a D-Bus connection for exchanging D-Bus messages\n * with the end represented by @stream.\n *\n * If @stream is a #GSocketConnection, then the corresponding #GSocket\n * will be put into non-blocking mode.\n *\n * The D-Bus connection will interact with @stream from a worker thread.\n * As a result, the caller should not interact with @stream after this\n * method has been called, except by calling g_object_unref() on it.\n *\n * If @observer is not %NULL it may be used to control the\n * authentication process.\n *\n * When the operation is finished, @callback will be invoked. You can\n * then call g_dbus_connection_new_finish() to get the result of the\n * operation.\n *\n * This is a asynchronous failable constructor. See\n * g_dbus_connection_new_sync() for the synchronous\n * version.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_new (GIOStream            *stream,\n                       const gchar          *guid,\n                       GDBusConnectionFlags  flags,\n                       GDBusAuthObserver    *observer,\n                       GCancellable         *cancellable,\n                       GAsyncReadyCallback   callback,\n                       gpointer              user_data)\n{\n  _g_dbus_initialize ();\n\n  g_return_if_fail (G_IS_IO_STREAM (stream));\n\n  g_async_initable_new_async (G_TYPE_DBUS_CONNECTION,\n                              G_PRIORITY_DEFAULT,\n                              cancellable,\n                              callback,\n                              user_data,\n                              \"stream\", stream,\n                              \"guid\", guid,\n                              \"flags\", flags,\n                              \"authentication-observer\", observer,\n                              NULL);\n}\n\n/**\n * g_dbus_connection_new_finish:\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback\n *     passed to g_dbus_connection_new().\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_new().\n *\n * Returns: a #GDBusConnection or %NULL if @error is set. Free\n *     with g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_dbus_connection_new_finish (GAsyncResult  *res,\n                              GError       **error)\n{\n  GObject *object;\n  GObject *source_object;\n\n  g_return_val_if_fail (G_IS_ASYNC_RESULT (res), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  source_object = g_async_result_get_source_object (res);\n  g_assert (source_object != NULL);\n  object = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object),\n                                        res,\n                                        error);\n  g_object_unref (source_object);\n  if (object != NULL)\n    return G_DBUS_CONNECTION (object);\n  else\n    return NULL;\n}\n\n/**\n * g_dbus_connection_new_sync:\n * @stream: a #GIOStream\n * @guid: (nullable): the GUID to use if a authenticating as a server or %NULL\n * @flags: flags describing how to make the connection\n * @observer: (nullable): a #GDBusAuthObserver or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously sets up a D-Bus connection for exchanging D-Bus messages\n * with the end represented by @stream.\n *\n * If @stream is a #GSocketConnection, then the corresponding #GSocket\n * will be put into non-blocking mode.\n *\n * The D-Bus connection will interact with @stream from a worker thread.\n * As a result, the caller should not interact with @stream after this\n * method has been called, except by calling g_object_unref() on it.\n *\n * If @observer is not %NULL it may be used to control the\n * authentication process.\n *\n * This is a synchronous failable constructor. See\n * g_dbus_connection_new() for the asynchronous version.\n *\n * Returns: a #GDBusConnection or %NULL if @error is set. Free with g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_dbus_connection_new_sync (GIOStream             *stream,\n                            const gchar           *guid,\n                            GDBusConnectionFlags   flags,\n                            GDBusAuthObserver     *observer,\n                            GCancellable          *cancellable,\n                            GError               **error)\n{\n  _g_dbus_initialize ();\n  g_return_val_if_fail (G_IS_IO_STREAM (stream), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n  return g_initable_new (G_TYPE_DBUS_CONNECTION,\n                         cancellable,\n                         error,\n                         \"stream\", stream,\n                         \"guid\", guid,\n                         \"flags\", flags,\n                         \"authentication-observer\", observer,\n                         NULL);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_new_for_address:\n * @address: a D-Bus address\n * @flags: flags describing how to make the connection\n * @observer: (nullable): a #GDBusAuthObserver or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: a #GAsyncReadyCallback to call when the request is satisfied\n * @user_data: the data to pass to @callback\n *\n * Asynchronously connects and sets up a D-Bus client connection for\n * exchanging D-Bus messages with an endpoint specified by @address\n * which must be in the\n * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).\n *\n * This constructor can only be used to initiate client-side\n * connections - use g_dbus_connection_new() if you need to act as the\n * server. In particular, @flags cannot contain the\n * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or\n * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.\n *\n * When the operation is finished, @callback will be invoked. You can\n * then call g_dbus_connection_new_finish() to get the result of the\n * operation.\n *\n * If @observer is not %NULL it may be used to control the\n * authentication process.\n *\n * This is a asynchronous failable constructor. See\n * g_dbus_connection_new_for_address_sync() for the synchronous\n * version.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_new_for_address (const gchar          *address,\n                                   GDBusConnectionFlags  flags,\n                                   GDBusAuthObserver    *observer,\n                                   GCancellable         *cancellable,\n                                   GAsyncReadyCallback   callback,\n                                   gpointer              user_data)\n{\n  _g_dbus_initialize ();\n\n  g_return_if_fail (address != NULL);\n\n  g_async_initable_new_async (G_TYPE_DBUS_CONNECTION,\n                              G_PRIORITY_DEFAULT,\n                              cancellable,\n                              callback,\n                              user_data,\n                              \"address\", address,\n                              \"flags\", flags,\n                              \"authentication-observer\", observer,\n                              NULL);\n}\n\n/**\n * g_dbus_connection_new_for_address_finish:\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed\n *     to g_dbus_connection_new()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_new_for_address().\n *\n * Returns: a #GDBusConnection or %NULL if @error is set. Free with\n *     g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_dbus_connection_new_for_address_finish (GAsyncResult  *res,\n                                          GError       **error)\n{\n  GObject *object;\n  GObject *source_object;\n\n  g_return_val_if_fail (G_IS_ASYNC_RESULT (res), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  source_object = g_async_result_get_source_object (res);\n  g_assert (source_object != NULL);\n  object = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object),\n                                        res,\n                                        error);\n  g_object_unref (source_object);\n  if (object != NULL)\n    return G_DBUS_CONNECTION (object);\n  else\n    return NULL;\n}\n\n/**\n * g_dbus_connection_new_for_address_sync:\n * @address: a D-Bus address\n * @flags: flags describing how to make the connection\n * @observer: (nullable): a #GDBusAuthObserver or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously connects and sets up a D-Bus client connection for\n * exchanging D-Bus messages with an endpoint specified by @address\n * which must be in the\n * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).\n *\n * This constructor can only be used to initiate client-side\n * connections - use g_dbus_connection_new_sync() if you need to act\n * as the server. In particular, @flags cannot contain the\n * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or\n * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.\n *\n * This is a synchronous failable constructor. See\n * g_dbus_connection_new_for_address() for the asynchronous version.\n *\n * If @observer is not %NULL it may be used to control the\n * authentication process.\n *\n * Returns: a #GDBusConnection or %NULL if @error is set. Free with\n *     g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_dbus_connection_new_for_address_sync (const gchar           *address,\n                                        GDBusConnectionFlags   flags,\n                                        GDBusAuthObserver     *observer,\n                                        GCancellable          *cancellable,\n                                        GError               **error)\n{\n  _g_dbus_initialize ();\n\n  g_return_val_if_fail (address != NULL, NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n  return g_initable_new (G_TYPE_DBUS_CONNECTION,\n                         cancellable,\n                         error,\n                         \"address\", address,\n                         \"flags\", flags,\n                         \"authentication-observer\", observer,\n                         NULL);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_set_exit_on_close:\n * @connection: a #GDBusConnection\n * @exit_on_close: whether the process should be terminated\n *     when @connection is closed by the remote peer\n *\n * Sets whether the process should be terminated when @connection is\n * closed by the remote peer. See #GDBusConnection:exit-on-close for\n * more details.\n *\n * Note that this function should be used with care. Most modern UNIX\n * desktops tie the notion of a user session the session bus, and expect\n * all of a users applications to quit when their bus connection goes away.\n * If you are setting @exit_on_close to %FALSE for the shared session\n * bus connection, you should make sure that your application exits\n * when the user session ends.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_set_exit_on_close (GDBusConnection *connection,\n                                     gboolean         exit_on_close)\n{\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n\n  if (exit_on_close)\n    g_atomic_int_or (&connection->atomic_flags, FLAG_EXIT_ON_CLOSE);\n  else\n    g_atomic_int_and (&connection->atomic_flags, ~FLAG_EXIT_ON_CLOSE);\n\n}\n\n/**\n * g_dbus_connection_get_exit_on_close:\n * @connection: a #GDBusConnection\n *\n * Gets whether the process is terminated when @connection is\n * closed by the remote peer. See\n * #GDBusConnection:exit-on-close for more details.\n *\n * Returns: whether the process is terminated when @connection is\n *     closed by the remote peer\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_get_exit_on_close (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n\n  if (g_atomic_int_get (&connection->atomic_flags) & FLAG_EXIT_ON_CLOSE)\n    return TRUE;\n  else\n    return FALSE;\n}\n\n/**\n * g_dbus_connection_get_guid:\n * @connection: a #GDBusConnection\n *\n * The GUID of the peer performing the role of server when\n * authenticating. See #GDBusConnection:guid for more details.\n *\n * Returns: The GUID. Do not free this string, it is owned by\n *     @connection.\n *\n * Since: 2.26\n */\nconst gchar *\ng_dbus_connection_get_guid (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  return connection->guid;\n}\n\n/**\n * g_dbus_connection_get_unique_name:\n * @connection: a #GDBusConnection\n *\n * Gets the unique name of @connection as assigned by the message\n * bus. This can also be used to figure out if @connection is a\n * message bus connection.\n *\n * Returns: the unique name or %NULL if @connection is not a message\n *     bus connection. Do not free this string, it is owned by\n *     @connection.\n *\n * Since: 2.26\n */\nconst gchar *\ng_dbus_connection_get_unique_name (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return NULL;\n\n  return connection->bus_unique_name;\n}\n\n/**\n * g_dbus_connection_get_peer_credentials:\n * @connection: a #GDBusConnection\n *\n * Gets the credentials of the authenticated peer. This will always\n * return %NULL unless @connection acted as a server\n * (e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)\n * when set up and the client passed credentials as part of the\n * authentication process.\n *\n * In a message bus setup, the message bus is always the server and\n * each application is a client. So this method will always return\n * %NULL for message bus clients.\n *\n * Returns: (transfer none) (nullable): a #GCredentials or %NULL if not\n *     available. Do not free this object, it is owned by @connection.\n *\n * Since: 2.26\n */\nGCredentials *\ng_dbus_connection_get_peer_credentials (GDBusConnection *connection)\n{\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n\n  /* do not use g_return_val_if_fail(), we want the memory barrier */\n  if (!check_initialized (connection))\n    return NULL;\n\n  return connection->credentials;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic volatile guint _global_filter_id = 1;\n\n/**\n * g_dbus_connection_add_filter:\n * @connection: a #GDBusConnection\n * @filter_function: a filter function\n * @user_data: user data to pass to @filter_function\n * @user_data_free_func: function to free @user_data with when filter\n *     is removed or %NULL\n *\n * Adds a message filter. Filters are handlers that are run on all\n * incoming and outgoing messages, prior to standard dispatch. Filters\n * are run in the order that they were added.  The same handler can be\n * added as a filter more than once, in which case it will be run more\n * than once.  Filters added during a filter callback won't be run on\n * the message being processed. Filter functions are allowed to modify\n * and even drop messages.\n *\n * Note that filters are run in a dedicated message handling thread so\n * they can't block and, generally, can't do anything but signal a\n * worker thread. Also note that filters are rarely needed - use API\n * such as g_dbus_connection_send_message_with_reply(),\n * g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.\n *\n * If a filter consumes an incoming message the message is not\n * dispatched anywhere else - not even the standard dispatch machinery\n * (that API such as g_dbus_connection_signal_subscribe() and\n * g_dbus_connection_send_message_with_reply() relies on) will see the\n * message. Similarly, if a filter consumes an outgoing message, the\n * message will not be sent to the other peer.\n *\n * If @user_data_free_func is non-%NULL, it will be called (in the\n * thread-default main context of the thread you are calling this\n * method from) at some point after @user_data is no longer\n * needed. (It is not guaranteed to be called synchronously when the\n * filter is removed, and may be called after @connection has been\n * destroyed.)\n *\n * Returns: a filter identifier that can be used with\n *     g_dbus_connection_remove_filter()\n *\n * Since: 2.26\n */\nguint\ng_dbus_connection_add_filter (GDBusConnection            *connection,\n                              GDBusMessageFilterFunction  filter_function,\n                              gpointer                    user_data,\n                              GDestroyNotify              user_data_free_func)\n{\n  FilterData *data;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n  g_return_val_if_fail (filter_function != NULL, 0);\n  g_return_val_if_fail (check_initialized (connection), 0);\n\n  CONNECTION_LOCK (connection);\n  data = g_new0 (FilterData, 1);\n  data->id = g_atomic_int_add (&_global_filter_id, 1); /* TODO: overflow etc. */\n  data->ref_count = 1;\n  data->filter_function = filter_function;\n  data->user_data = user_data;\n  data->user_data_free_func = user_data_free_func;\n  data->context = g_main_context_ref_thread_default ();\n  g_ptr_array_add (connection->filters, data);\n  CONNECTION_UNLOCK (connection);\n\n  return data->id;\n}\n\n/* only called from finalize(), removes all filters */\nstatic void\npurge_all_filters (GDBusConnection *connection)\n{\n  guint n;\n  for (n = 0; n < connection->filters->len; n++)\n    {\n      FilterData *data = connection->filters->pdata[n];\n\n      call_destroy_notify (data->context,\n                           data->user_data_free_func,\n                           data->user_data);\n      g_main_context_unref (data->context);\n      g_free (data);\n    }\n}\n\n/**\n * g_dbus_connection_remove_filter:\n * @connection: a #GDBusConnection\n * @filter_id: an identifier obtained from g_dbus_connection_add_filter()\n *\n * Removes a filter.\n *\n * Note that since filters run in a different thread, there is a race\n * condition where it is possible that the filter will be running even\n * after calling g_dbus_connection_remove_filter(), so you cannot just\n * free data that the filter might be using. Instead, you should pass\n * a #GDestroyNotify to g_dbus_connection_add_filter(), which will be\n * called when it is guaranteed that the data is no longer needed.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_remove_filter (GDBusConnection *connection,\n                                 guint            filter_id)\n{\n  guint n;\n  gboolean found;\n  FilterData *to_destroy;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n  g_return_if_fail (check_initialized (connection));\n\n  CONNECTION_LOCK (connection);\n  found = FALSE;\n  to_destroy = NULL;\n  for (n = 0; n < connection->filters->len; n++)\n    {\n      FilterData *data = connection->filters->pdata[n];\n      if (data->id == filter_id)\n        {\n          found = TRUE;\n          g_ptr_array_remove_index (connection->filters, n);\n          data->ref_count--;\n          if (data->ref_count == 0)\n            to_destroy = data;\n          break;\n        }\n    }\n  CONNECTION_UNLOCK (connection);\n\n  /* do free without holding lock */\n  if (to_destroy != NULL)\n    {\n      if (to_destroy->user_data_free_func != NULL)\n        to_destroy->user_data_free_func (to_destroy->user_data);\n      g_main_context_unref (to_destroy->context);\n      g_free (to_destroy);\n    }\n  else if (!found)\n    {\n      g_warning (\"g_dbus_connection_remove_filter: No filter found for filter_id %d\", filter_id);\n    }\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  gchar *rule;\n  gchar *sender;\n  gchar *sender_unique_name; /* if sender is unique or org.freedesktop.DBus, then that name... otherwise blank */\n  gchar *interface_name;\n  gchar *member;\n  gchar *object_path;\n  gchar *arg0;\n  GDBusSignalFlags flags;\n  GArray *subscribers;\n} SignalData;\n\ntypedef struct\n{\n  GDBusSignalCallback callback;\n  gpointer user_data;\n  GDestroyNotify user_data_free_func;\n  guint id;\n  GMainContext *context;\n} SignalSubscriber;\n\nstatic void\nsignal_data_free (SignalData *signal_data)\n{\n  g_free (signal_data->rule);\n  g_free (signal_data->sender);\n  g_free (signal_data->sender_unique_name);\n  g_free (signal_data->interface_name);\n  g_free (signal_data->member);\n  g_free (signal_data->object_path);\n  g_free (signal_data->arg0);\n  g_array_free (signal_data->subscribers, TRUE);\n  g_free (signal_data);\n}\n\nstatic gchar *\nargs_to_rule (const gchar      *sender,\n              const gchar      *interface_name,\n              const gchar      *member,\n              const gchar      *object_path,\n              const gchar      *arg0,\n              GDBusSignalFlags  flags)\n{\n  GString *rule;\n\n  rule = g_string_new (\"type='signal'\");\n  if (flags & G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE)\n    g_string_prepend_c (rule, '-');\n  if (sender != NULL)\n    g_string_append_printf (rule, \",sender='%s'\", sender);\n  if (interface_name != NULL)\n    g_string_append_printf (rule, \",interface='%s'\", interface_name);\n  if (member != NULL)\n    g_string_append_printf (rule, \",member='%s'\", member);\n  if (object_path != NULL)\n    g_string_append_printf (rule, \",path='%s'\", object_path);\n\n  if (arg0 != NULL)\n    {\n      if (flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH)\n        g_string_append_printf (rule, \",arg0path='%s'\", arg0);\n      else if (flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE)\n        g_string_append_printf (rule, \",arg0namespace='%s'\", arg0);\n      else\n        g_string_append_printf (rule, \",arg0='%s'\", arg0);\n    }\n\n  return g_string_free (rule, FALSE);\n}\n\nstatic volatile guint _global_subscriber_id = 1;\nstatic volatile guint _global_registration_id = 1;\nstatic volatile guint _global_subtree_registration_id = 1;\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called in a user thread, lock is held */\nstatic void\nadd_match_rule (GDBusConnection *connection,\n                const gchar     *match_rule)\n{\n  GError *error;\n  GDBusMessage *message;\n\n  if (match_rule[0] == '-')\n    return;\n\n  message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", /* name */\n                                            \"/org/freedesktop/DBus\", /* path */\n                                            \"org.freedesktop.DBus\", /* interface */\n                                            \"AddMatch\");\n  g_dbus_message_set_body (message, g_variant_new (\"(s)\", match_rule));\n  error = NULL;\n  if (!g_dbus_connection_send_message_unlocked (connection,\n                                                message,\n                                                G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                NULL,\n                                                &error))\n    {\n      g_critical (\"Error while sending AddMatch() message: %s\", error->message);\n      g_error_free (error);\n    }\n  g_object_unref (message);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called in a user thread, lock is held */\nstatic void\nremove_match_rule (GDBusConnection *connection,\n                   const gchar     *match_rule)\n{\n  GError *error;\n  GDBusMessage *message;\n\n  if (match_rule[0] == '-')\n    return;\n\n  message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", /* name */\n                                            \"/org/freedesktop/DBus\", /* path */\n                                            \"org.freedesktop.DBus\", /* interface */\n                                            \"RemoveMatch\");\n  g_dbus_message_set_body (message, g_variant_new (\"(s)\", match_rule));\n\n  error = NULL;\n  if (!g_dbus_connection_send_message_unlocked (connection,\n                                                message,\n                                                G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                NULL,\n                                                &error))\n    {\n      /* If we could get G_IO_ERROR_CLOSED here, it wouldn't be reasonable to\n       * critical; but we're holding the lock, and our caller checked whether\n       * we were already closed, so we can't get that error.\n       */\n      g_critical (\"Error while sending RemoveMatch() message: %s\", error->message);\n      g_error_free (error);\n    }\n  g_object_unref (message);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic gboolean\nis_signal_data_for_name_lost_or_acquired (SignalData *signal_data)\n{\n  return g_strcmp0 (signal_data->sender_unique_name, \"org.freedesktop.DBus\") == 0 &&\n         g_strcmp0 (signal_data->interface_name, \"org.freedesktop.DBus\") == 0 &&\n         g_strcmp0 (signal_data->object_path, \"/org/freedesktop/DBus\") == 0 &&\n         (g_strcmp0 (signal_data->member, \"NameLost\") == 0 ||\n          g_strcmp0 (signal_data->member, \"NameAcquired\") == 0);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_signal_subscribe:\n * @connection: a #GDBusConnection\n * @sender: (nullable): sender name to match on (unique or well-known name)\n *     or %NULL to listen from all senders\n * @interface_name: (nullable): D-Bus interface name to match on or %NULL to\n *     match on all interfaces\n * @member: (nullable): D-Bus signal name to match on or %NULL to match on\n *     all signals\n * @object_path: (nullable): object path to match on or %NULL to match on\n *     all object paths\n * @arg0: (nullable): contents of first string argument to match on or %NULL\n *     to match on all kinds of arguments\n * @flags: #GDBusSignalFlags describing how arg0 is used in subscribing to the\n *     signal\n * @callback: callback to invoke when there is a signal matching the requested data\n * @user_data: user data to pass to @callback\n * @user_data_free_func: (nullable): function to free @user_data with when\n *     subscription is removed or %NULL\n *\n * Subscribes to signals on @connection and invokes @callback with a whenever\n * the signal is received. Note that @callback will be invoked in the \n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from.\n *\n * If @connection is not a message bus connection, @sender must be\n * %NULL.\n *\n * If @sender is a well-known name note that @callback is invoked with\n * the unique name for the owner of @sender, not the well-known name\n * as one would expect. This is because the message bus rewrites the\n * name. As such, to avoid certain race conditions, users should be\n * tracking the name owner of the well-known name and use that when\n * processing the received signal.\n *\n * If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or\n * %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is\n * interpreted as part of a namespace or path.  The first argument\n * of a signal is matched against that part as specified by D-Bus.\n *\n * If @user_data_free_func is non-%NULL, it will be called (in the\n * thread-default main context of the thread you are calling this\n * method from) at some point after @user_data is no longer\n * needed. (It is not guaranteed to be called synchronously when the\n * signal is unsubscribed from, and may be called after @connection\n * has been destroyed.)\n *\n * Returns: a subscription identifier that can be used with g_dbus_connection_signal_unsubscribe()\n *\n * Since: 2.26\n */\nguint\ng_dbus_connection_signal_subscribe (GDBusConnection     *connection,\n                                    const gchar         *sender,\n                                    const gchar         *interface_name,\n                                    const gchar         *member,\n                                    const gchar         *object_path,\n                                    const gchar         *arg0,\n                                    GDBusSignalFlags     flags,\n                                    GDBusSignalCallback  callback,\n                                    gpointer             user_data,\n                                    GDestroyNotify       user_data_free_func)\n{\n  gchar *rule;\n  SignalData *signal_data;\n  SignalSubscriber subscriber;\n  GPtrArray *signal_data_array;\n  const gchar *sender_unique_name;\n\n  /* Right now we abort if AddMatch() fails since it can only fail with the bus being in\n   * an OOM condition. We might want to change that but that would involve making\n   * g_dbus_connection_signal_subscribe() asynchronous and having the call sites\n   * handle that. And there's really no sensible way of handling this short of retrying\n   * to add the match rule... and then there's the little thing that, hey, maybe there's\n   * a reason the bus in an OOM condition.\n   *\n   * Doable, but not really sure it's worth it...\n   */\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n  g_return_val_if_fail (sender == NULL || (g_dbus_is_name (sender) && (connection->flags & G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION)), 0);\n  g_return_val_if_fail (interface_name == NULL || g_dbus_is_interface_name (interface_name), 0);\n  g_return_val_if_fail (member == NULL || g_dbus_is_member_name (member), 0);\n  g_return_val_if_fail (object_path == NULL || g_variant_is_object_path (object_path), 0);\n  g_return_val_if_fail (callback != NULL, 0);\n  g_return_val_if_fail (check_initialized (connection), 0);\n  g_return_val_if_fail (!((flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH) && (flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE)), 0);\n  g_return_val_if_fail (!(arg0 == NULL && (flags & (G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH | G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE))), 0);\n\n  CONNECTION_LOCK (connection);\n\n  /* If G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE was specified, we will end up\n   * with a '-' character to prefix the rule (which will otherwise be\n   * normal).\n   *\n   * This allows us to hash the rule and do our lifecycle tracking in\n   * the usual way, but the '-' prevents the match rule from ever\n   * actually being send to the bus (either for add or remove).\n   */\n  rule = args_to_rule (sender, interface_name, member, object_path, arg0, flags);\n\n  if (sender != NULL && (g_dbus_is_unique_name (sender) || g_strcmp0 (sender, \"org.freedesktop.DBus\") == 0))\n    sender_unique_name = sender;\n  else\n    sender_unique_name = \"\";\n\n  subscriber.callback = callback;\n  subscriber.user_data = user_data;\n  subscriber.user_data_free_func = user_data_free_func;\n  subscriber.id = g_atomic_int_add (&_global_subscriber_id, 1); /* TODO: overflow etc. */\n  subscriber.context = g_main_context_ref_thread_default ();\n\n  /* see if we've already have this rule */\n  signal_data = g_hash_table_lookup (connection->map_rule_to_signal_data, rule);\n  if (signal_data != NULL)\n    {\n      g_array_append_val (signal_data->subscribers, subscriber);\n      g_free (rule);\n      goto out;\n    }\n\n  signal_data = g_new0 (SignalData, 1);\n  signal_data->rule                  = rule;\n  signal_data->sender                = g_strdup (sender);\n  signal_data->sender_unique_name    = g_strdup (sender_unique_name);\n  signal_data->interface_name        = g_strdup (interface_name);\n  signal_data->member                = g_strdup (member);\n  signal_data->object_path           = g_strdup (object_path);\n  signal_data->arg0                  = g_strdup (arg0);\n  signal_data->flags                 = flags;\n  signal_data->subscribers           = g_array_new (FALSE, FALSE, sizeof (SignalSubscriber));\n  g_array_append_val (signal_data->subscribers, subscriber);\n\n  g_hash_table_insert (connection->map_rule_to_signal_data,\n                       signal_data->rule,\n                       signal_data);\n\n  /* Add the match rule to the bus...\n   *\n   * Avoid adding match rules for NameLost and NameAcquired messages - the bus will\n   * always send such messages to us.\n   */\n  if (connection->flags & G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION)\n    {\n      if (!is_signal_data_for_name_lost_or_acquired (signal_data))\n        add_match_rule (connection, signal_data->rule);\n    }\n\n  signal_data_array = g_hash_table_lookup (connection->map_sender_unique_name_to_signal_data_array,\n                                           signal_data->sender_unique_name);\n  if (signal_data_array == NULL)\n    {\n      signal_data_array = g_ptr_array_new ();\n      g_hash_table_insert (connection->map_sender_unique_name_to_signal_data_array,\n                           g_strdup (signal_data->sender_unique_name),\n                           signal_data_array);\n    }\n  g_ptr_array_add (signal_data_array, signal_data);\n\n out:\n  g_hash_table_insert (connection->map_id_to_signal_data,\n                       GUINT_TO_POINTER (subscriber.id),\n                       signal_data);\n\n  CONNECTION_UNLOCK (connection);\n\n  return subscriber.id;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* called in any thread */\n/* must hold lock when calling this (except if connection->finalizing is TRUE) */\nstatic void\nunsubscribe_id_internal (GDBusConnection *connection,\n                         guint            subscription_id,\n                         GArray          *out_removed_subscribers)\n{\n  SignalData *signal_data;\n  GPtrArray *signal_data_array;\n  guint n;\n\n  signal_data = g_hash_table_lookup (connection->map_id_to_signal_data,\n                                     GUINT_TO_POINTER (subscription_id));\n  if (signal_data == NULL)\n    {\n      /* Don't warn here, we may have thrown all subscriptions out when the connection was closed */\n      goto out;\n    }\n\n  for (n = 0; n < signal_data->subscribers->len; n++)\n    {\n      SignalSubscriber *subscriber;\n\n      subscriber = &(g_array_index (signal_data->subscribers, SignalSubscriber, n));\n      if (subscriber->id != subscription_id)\n        continue;\n\n      g_warn_if_fail (g_hash_table_remove (connection->map_id_to_signal_data,\n                                           GUINT_TO_POINTER (subscription_id)));\n      g_array_append_val (out_removed_subscribers, *subscriber);\n      g_array_remove_index (signal_data->subscribers, n);\n\n      if (signal_data->subscribers->len == 0)\n        {\n          g_warn_if_fail (g_hash_table_remove (connection->map_rule_to_signal_data, signal_data->rule));\n\n          signal_data_array = g_hash_table_lookup (connection->map_sender_unique_name_to_signal_data_array,\n                                                   signal_data->sender_unique_name);\n          g_warn_if_fail (signal_data_array != NULL);\n          g_warn_if_fail (g_ptr_array_remove (signal_data_array, signal_data));\n\n          if (signal_data_array->len == 0)\n            {\n              g_warn_if_fail (g_hash_table_remove (connection->map_sender_unique_name_to_signal_data_array,\n                                                   signal_data->sender_unique_name));\n            }\n\n          /* remove the match rule from the bus unless NameLost or NameAcquired (see subscribe()) */\n          if ((connection->flags & G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION) &&\n              !is_signal_data_for_name_lost_or_acquired (signal_data) &&\n              !g_dbus_connection_is_closed (connection) &&\n              !connection->finalizing)\n            {\n              /* The check for g_dbus_connection_is_closed() means that\n               * sending the RemoveMatch message can't fail with\n               * G_IO_ERROR_CLOSED, because we're holding the lock,\n               * so on_worker_closed() can't happen between the check we just\n               * did, and releasing the lock later.\n               */\n              remove_match_rule (connection, signal_data->rule);\n            }\n\n          signal_data_free (signal_data);\n        }\n\n      goto out;\n    }\n\n  g_assert_not_reached ();\n\n out:\n  ;\n}\n\n/**\n * g_dbus_connection_signal_unsubscribe:\n * @connection: a #GDBusConnection\n * @subscription_id: a subscription id obtained from\n *     g_dbus_connection_signal_subscribe()\n *\n * Unsubscribes from signals.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_signal_unsubscribe (GDBusConnection *connection,\n                                      guint            subscription_id)\n{\n  GArray *subscribers;\n  guint n;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n  g_return_if_fail (check_initialized (connection));\n\n  subscribers = g_array_new (FALSE, FALSE, sizeof (SignalSubscriber));\n\n  CONNECTION_LOCK (connection);\n  unsubscribe_id_internal (connection,\n                           subscription_id,\n                           subscribers);\n  CONNECTION_UNLOCK (connection);\n\n  /* invariant */\n  g_assert (subscribers->len == 0 || subscribers->len == 1);\n\n  /* call GDestroyNotify without lock held */\n  for (n = 0; n < subscribers->len; n++)\n    {\n      SignalSubscriber *subscriber;\n      subscriber = &(g_array_index (subscribers, SignalSubscriber, n));\n      call_destroy_notify (subscriber->context,\n                           subscriber->user_data_free_func,\n                           subscriber->user_data);\n      g_main_context_unref (subscriber->context);\n    }\n\n  g_array_free (subscribers, TRUE);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  guint                subscription_id;\n  GDBusSignalCallback  callback;\n  gpointer             user_data;\n  GDBusMessage        *message;\n  GDBusConnection     *connection;\n  const gchar         *sender;\n  const gchar         *path;\n  const gchar         *interface;\n  const gchar         *member;\n} SignalInstance;\n\n/* called on delivery thread (e.g. where g_dbus_connection_signal_subscribe() was called) with\n * no locks held\n */\nstatic gboolean\nemit_signal_instance_in_idle_cb (gpointer data)\n{\n  SignalInstance *signal_instance = data;\n  GVariant *parameters;\n  gboolean has_subscription;\n\n  parameters = g_dbus_message_get_body (signal_instance->message);\n  if (parameters == NULL)\n    {\n      parameters = g_variant_new (\"()\");\n      g_variant_ref_sink (parameters);\n    }\n  else\n    {\n      g_variant_ref_sink (parameters);\n    }\n\n#if 0\n  g_print (\"in emit_signal_instance_in_idle_cb (id=%d sender=%s path=%s interface=%s member=%s params=%s)\\n\",\n           signal_instance->subscription_id,\n           signal_instance->sender,\n           signal_instance->path,\n           signal_instance->interface,\n           signal_instance->member,\n           g_variant_print (parameters, TRUE));\n#endif\n\n  /* Careful here, don't do the callback if we no longer has the subscription */\n  CONNECTION_LOCK (signal_instance->connection);\n  has_subscription = FALSE;\n  if (g_hash_table_lookup (signal_instance->connection->map_id_to_signal_data,\n                           GUINT_TO_POINTER (signal_instance->subscription_id)) != NULL)\n    has_subscription = TRUE;\n  CONNECTION_UNLOCK (signal_instance->connection);\n\n  if (has_subscription)\n    signal_instance->callback (signal_instance->connection,\n                               signal_instance->sender,\n                               signal_instance->path,\n                               signal_instance->interface,\n                               signal_instance->member,\n                               parameters,\n                               signal_instance->user_data);\n\n  g_variant_unref (parameters);\n\n  return FALSE;\n}\n\nstatic void\nsignal_instance_free (SignalInstance *signal_instance)\n{\n  g_object_unref (signal_instance->message);\n  g_object_unref (signal_instance->connection);\n  g_free (signal_instance);\n}\n\nstatic gboolean\nnamespace_rule_matches (const gchar *namespace,\n                        const gchar *name)\n{\n  gint len_namespace;\n  gint len_name;\n\n  len_namespace = strlen (namespace);\n  len_name = strlen (name);\n\n  if (len_name < len_namespace)\n    return FALSE;\n\n  if (memcmp (namespace, name, len_namespace) != 0)\n    return FALSE;\n\n  return len_namespace == len_name || name[len_namespace] == '.';\n}\n\nstatic gboolean\npath_rule_matches (const gchar *path_a,\n                   const gchar *path_b)\n{\n  gint len_a, len_b;\n\n  len_a = strlen (path_a);\n  len_b = strlen (path_b);\n\n  if (len_a < len_b && (len_a == 0 || path_a[len_a - 1] != '/'))\n    return FALSE;\n\n  if (len_b < len_a && (len_b == 0 || path_b[len_b - 1] != '/'))\n    return FALSE;\n\n  return memcmp (path_a, path_b, MIN (len_a, len_b)) == 0;\n}\n\n/* called in GDBusWorker thread WITH lock held */\nstatic void\nschedule_callbacks (GDBusConnection *connection,\n                    GPtrArray       *signal_data_array,\n                    GDBusMessage    *message,\n                    const gchar     *sender)\n{\n  guint n, m;\n  const gchar *interface;\n  const gchar *member;\n  const gchar *path;\n  const gchar *arg0;\n\n  interface = NULL;\n  member = NULL;\n  path = NULL;\n  arg0 = NULL;\n\n  interface = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  path = g_dbus_message_get_path (message);\n  arg0 = g_dbus_message_get_arg0 (message);\n\n#if 0\n  g_print (\"In schedule_callbacks:\\n\"\n           \"  sender    = '%s'\\n\"\n           \"  interface = '%s'\\n\"\n           \"  member    = '%s'\\n\"\n           \"  path      = '%s'\\n\"\n           \"  arg0      = '%s'\\n\",\n           sender,\n           interface,\n           member,\n           path,\n           arg0);\n#endif\n\n  /* TODO: if this is slow, then we can change signal_data_array into\n   *       map_object_path_to_signal_data_array or something.\n   */\n  for (n = 0; n < signal_data_array->len; n++)\n    {\n      SignalData *signal_data = signal_data_array->pdata[n];\n\n      if (signal_data->interface_name != NULL && g_strcmp0 (signal_data->interface_name, interface) != 0)\n        continue;\n\n      if (signal_data->member != NULL && g_strcmp0 (signal_data->member, member) != 0)\n        continue;\n\n      if (signal_data->object_path != NULL && g_strcmp0 (signal_data->object_path, path) != 0)\n        continue;\n\n      if (signal_data->arg0 != NULL)\n        {\n          if (arg0 == NULL)\n            continue;\n\n          if (signal_data->flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE)\n            {\n              if (!namespace_rule_matches (signal_data->arg0, arg0))\n                continue;\n            }\n          else if (signal_data->flags & G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH)\n            {\n              if (!path_rule_matches (signal_data->arg0, arg0))\n                continue;\n            }\n          else if (!g_str_equal (signal_data->arg0, arg0))\n            continue;\n        }\n\n      for (m = 0; m < signal_data->subscribers->len; m++)\n        {\n          SignalSubscriber *subscriber;\n          GSource *idle_source;\n          SignalInstance *signal_instance;\n\n          subscriber = &(g_array_index (signal_data->subscribers, SignalSubscriber, m));\n\n          signal_instance = g_new0 (SignalInstance, 1);\n          signal_instance->subscription_id = subscriber->id;\n          signal_instance->callback = subscriber->callback;\n          signal_instance->user_data = subscriber->user_data;\n          signal_instance->message = g_object_ref (message);\n          signal_instance->connection = g_object_ref (connection);\n          signal_instance->sender = sender;\n          signal_instance->path = path;\n          signal_instance->interface = interface;\n          signal_instance->member = member;\n\n          idle_source = g_idle_source_new ();\n          g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n          g_source_set_callback (idle_source,\n                                 emit_signal_instance_in_idle_cb,\n                                 signal_instance,\n                                 (GDestroyNotify) signal_instance_free);\n          g_source_set_name (idle_source, \"[gio] emit_signal_instance_in_idle_cb\");\n          g_source_attach (idle_source, subscriber->context);\n          g_source_unref (idle_source);\n        }\n    }\n}\n\n/* called in GDBusWorker thread with lock held */\nstatic void\ndistribute_signals (GDBusConnection *connection,\n                    GDBusMessage    *message)\n{\n  GPtrArray *signal_data_array;\n  const gchar *sender;\n\n  sender = g_dbus_message_get_sender (message);\n\n  if (G_UNLIKELY (_g_dbus_debug_signal ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Signal:\\n\"\n               \" <<<< RECEIVED SIGNAL %s.%s\\n\"\n               \"      on object %s\\n\"\n               \"      sent by name %s\\n\",\n               g_dbus_message_get_interface (message),\n               g_dbus_message_get_member (message),\n               g_dbus_message_get_path (message),\n               sender != NULL ? sender : \"(none)\");\n      _g_dbus_debug_print_unlock ();\n    }\n\n  /* collect subscribers that match on sender */\n  if (sender != NULL)\n    {\n      signal_data_array = g_hash_table_lookup (connection->map_sender_unique_name_to_signal_data_array, sender);\n      if (signal_data_array != NULL)\n        schedule_callbacks (connection, signal_data_array, message, sender);\n    }\n\n  /* collect subscribers not matching on sender */\n  signal_data_array = g_hash_table_lookup (connection->map_sender_unique_name_to_signal_data_array, \"\");\n  if (signal_data_array != NULL)\n    schedule_callbacks (connection, signal_data_array, message, sender);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* only called from finalize(), removes all subscriptions */\nstatic void\npurge_all_signal_subscriptions (GDBusConnection *connection)\n{\n  GHashTableIter iter;\n  gpointer key;\n  GArray *ids;\n  GArray *subscribers;\n  guint n;\n\n  ids = g_array_new (FALSE, FALSE, sizeof (guint));\n  g_hash_table_iter_init (&iter, connection->map_id_to_signal_data);\n  while (g_hash_table_iter_next (&iter, &key, NULL))\n    {\n      guint subscription_id = GPOINTER_TO_UINT (key);\n      g_array_append_val (ids, subscription_id);\n    }\n\n  subscribers = g_array_new (FALSE, FALSE, sizeof (SignalSubscriber));\n  for (n = 0; n < ids->len; n++)\n    {\n      guint subscription_id = g_array_index (ids, guint, n);\n      unsubscribe_id_internal (connection,\n                               subscription_id,\n                               subscribers);\n    }\n  g_array_free (ids, TRUE);\n\n  /* call GDestroyNotify without lock held */\n  for (n = 0; n < subscribers->len; n++)\n    {\n      SignalSubscriber *subscriber;\n      subscriber = &(g_array_index (subscribers, SignalSubscriber, n));\n      call_destroy_notify (subscriber->context,\n                           subscriber->user_data_free_func,\n                           subscriber->user_data);\n      g_main_context_unref (subscriber->context);\n    }\n\n  g_array_free (subscribers, TRUE);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic GDBusInterfaceVTable *\n_g_dbus_interface_vtable_copy (const GDBusInterfaceVTable *vtable)\n{\n  /* Don't waste memory by copying padding - remember to update this\n   * when changing struct _GDBusInterfaceVTable in gdbusconnection.h\n   */\n  return g_memdup ((gconstpointer) vtable, 3 * sizeof (gpointer));\n}\n\nstatic void\n_g_dbus_interface_vtable_free (GDBusInterfaceVTable *vtable)\n{\n  g_free (vtable);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic GDBusSubtreeVTable *\n_g_dbus_subtree_vtable_copy (const GDBusSubtreeVTable *vtable)\n{\n  /* Don't waste memory by copying padding - remember to update this\n   * when changing struct _GDBusSubtreeVTable in gdbusconnection.h\n   */\n  return g_memdup ((gconstpointer) vtable, 3 * sizeof (gpointer));\n}\n\nstatic void\n_g_dbus_subtree_vtable_free (GDBusSubtreeVTable *vtable)\n{\n  g_free (vtable);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstruct ExportedObject\n{\n  gchar *object_path;\n  GDBusConnection *connection;\n\n  /* maps gchar* -> ExportedInterface* */\n  GHashTable *map_if_name_to_ei;\n};\n\n/* only called with lock held */\nstatic void\nexported_object_free (ExportedObject *eo)\n{\n  g_free (eo->object_path);\n  g_hash_table_unref (eo->map_if_name_to_ei);\n  g_free (eo);\n}\n\ntypedef struct\n{\n  ExportedObject *eo;\n\n  guint                       id;\n  gchar                      *interface_name;\n  GDBusInterfaceVTable       *vtable;\n  GDBusInterfaceInfo         *interface_info;\n\n  GMainContext               *context;\n  gpointer                    user_data;\n  GDestroyNotify              user_data_free_func;\n} ExportedInterface;\n\n/* called with lock held */\nstatic void\nexported_interface_free (ExportedInterface *ei)\n{\n  g_dbus_interface_info_cache_release (ei->interface_info);\n  g_dbus_interface_info_unref ((GDBusInterfaceInfo *) ei->interface_info);\n\n  call_destroy_notify (ei->context,\n                       ei->user_data_free_func,\n                       ei->user_data);\n\n  g_main_context_unref (ei->context);\n\n  g_free (ei->interface_name);\n  _g_dbus_interface_vtable_free (ei->vtable);\n  g_free (ei);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Convenience function to check if @registration_id (if not zero) or\n * @subtree_registration_id (if not zero) has been unregistered. If\n * so, returns %TRUE.\n *\n * May be called by any thread. Caller must *not* hold lock.\n */\nstatic gboolean\nhas_object_been_unregistered (GDBusConnection  *connection,\n                              guint             registration_id,\n                              guint             subtree_registration_id)\n{\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n\n  ret = FALSE;\n\n  CONNECTION_LOCK (connection);\n  if (registration_id != 0 && g_hash_table_lookup (connection->map_id_to_ei,\n                                                   GUINT_TO_POINTER (registration_id)) == NULL)\n    {\n      ret = TRUE;\n    }\n  else if (subtree_registration_id != 0 && g_hash_table_lookup (connection->map_id_to_es,\n                                                                GUINT_TO_POINTER (subtree_registration_id)) == NULL)\n    {\n      ret = TRUE;\n    }\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GDBusConnection *connection;\n  GDBusMessage *message;\n  gpointer user_data;\n  const gchar *property_name;\n  const GDBusInterfaceVTable *vtable;\n  GDBusInterfaceInfo *interface_info;\n  const GDBusPropertyInfo *property_info;\n  guint registration_id;\n  guint subtree_registration_id;\n} PropertyData;\n\nstatic void\nproperty_data_free (PropertyData *data)\n{\n  g_object_unref (data->connection);\n  g_object_unref (data->message);\n  g_free (data);\n}\n\n/* called in thread where object was registered - no locks held */\nstatic gboolean\ninvoke_get_property_in_idle_cb (gpointer _data)\n{\n  PropertyData *data = _data;\n  GVariant *value;\n  GError *error;\n  GDBusMessage *reply;\n\n  if (has_object_been_unregistered (data->connection,\n                                    data->registration_id,\n                                    data->subtree_registration_id))\n    {\n      reply = g_dbus_message_new_method_error (data->message,\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"No such interface \u201corg.freedesktop.DBus.Properties\u201d on object at path %s\"),\n                                               g_dbus_message_get_path (data->message));\n      g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      goto out;\n    }\n\n  error = NULL;\n  value = data->vtable->get_property (data->connection,\n                                      g_dbus_message_get_sender (data->message),\n                                      g_dbus_message_get_path (data->message),\n                                      data->interface_info->name,\n                                      data->property_name,\n                                      &error,\n                                      data->user_data);\n\n\n  if (value != NULL)\n    {\n      g_assert_no_error (error);\n\n      g_variant_take_ref (value);\n      reply = g_dbus_message_new_method_reply (data->message);\n      g_dbus_message_set_body (reply, g_variant_new (\"(v)\", value));\n      g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_variant_unref (value);\n      g_object_unref (reply);\n    }\n  else\n    {\n      gchar *dbus_error_name;\n      g_assert (error != NULL);\n      dbus_error_name = g_dbus_error_encode_gerror (error);\n      reply = g_dbus_message_new_method_error_literal (data->message,\n                                                       dbus_error_name,\n                                                       error->message);\n      g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_free (dbus_error_name);\n      g_error_free (error);\n      g_object_unref (reply);\n    }\n\n out:\n  return FALSE;\n}\n\n/* called in thread where object was registered - no locks held */\nstatic gboolean\ninvoke_set_property_in_idle_cb (gpointer _data)\n{\n  PropertyData *data = _data;\n  GError *error;\n  GDBusMessage *reply;\n  GVariant *value;\n\n  error = NULL;\n  value = NULL;\n\n  g_variant_get (g_dbus_message_get_body (data->message),\n                 \"(ssv)\",\n                 NULL,\n                 NULL,\n                 &value);\n\n  if (!data->vtable->set_property (data->connection,\n                                   g_dbus_message_get_sender (data->message),\n                                   g_dbus_message_get_path (data->message),\n                                   data->interface_info->name,\n                                   data->property_name,\n                                   value,\n                                   &error,\n                                   data->user_data))\n    {\n      gchar *dbus_error_name;\n      g_assert (error != NULL);\n      dbus_error_name = g_dbus_error_encode_gerror (error);\n      reply = g_dbus_message_new_method_error_literal (data->message,\n                                                       dbus_error_name,\n                                                       error->message);\n      g_free (dbus_error_name);\n      g_error_free (error);\n    }\n  else\n    {\n      reply = g_dbus_message_new_method_reply (data->message);\n    }\n\n  g_assert (reply != NULL);\n  g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n  g_variant_unref (value);\n\n  return FALSE;\n}\n\n/* called in any thread with connection's lock held */\nstatic gboolean\nvalidate_and_maybe_schedule_property_getset (GDBusConnection            *connection,\n                                             GDBusMessage               *message,\n                                             guint                       registration_id,\n                                             guint                       subtree_registration_id,\n                                             gboolean                    is_get,\n                                             GDBusInterfaceInfo         *interface_info,\n                                             const GDBusInterfaceVTable *vtable,\n                                             GMainContext               *main_context,\n                                             gpointer                    user_data)\n{\n  gboolean handled;\n  const char *interface_name;\n  const char *property_name;\n  const GDBusPropertyInfo *property_info;\n  GSource *idle_source;\n  PropertyData *property_data;\n  GDBusMessage *reply;\n\n  handled = FALSE;\n\n  if (is_get)\n    g_variant_get (g_dbus_message_get_body (message),\n                   \"(&s&s)\",\n                   &interface_name,\n                   &property_name);\n  else\n    g_variant_get (g_dbus_message_get_body (message),\n                   \"(&s&sv)\",\n                   &interface_name,\n                   &property_name,\n                   NULL);\n\n  if (vtable == NULL)\n    goto out;\n\n  /* Check that the property exists - if not fail with org.freedesktop.DBus.Error.InvalidArgs\n   */\n  property_info = NULL;\n\n  /* TODO: the cost of this is O(n) - it might be worth caching the result */\n  property_info = g_dbus_interface_info_lookup_property (interface_info, property_name);\n  if (property_info == NULL)\n    {\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"No such property \u201c%s\u201d\"),\n                                               property_name);\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  if (is_get && !(property_info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE))\n    {\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"Property \u201c%s\u201d is not readable\"),\n                                               property_name);\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n  else if (!is_get && !(property_info->flags & G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE))\n    {\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"Property \u201c%s\u201d is not writable\"),\n                                               property_name);\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  if (!is_get)\n    {\n      GVariant *value;\n\n      /* Fail with org.freedesktop.DBus.Error.InvalidArgs if the type\n       * of the given value is wrong\n       */\n      g_variant_get_child (g_dbus_message_get_body (message), 2, \"v\", &value);\n      if (g_strcmp0 (g_variant_get_type_string (value), property_info->signature) != 0)\n        {\n          reply = g_dbus_message_new_method_error (message,\n                                                   \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                                   _(\"Error setting property \u201c%s\u201d: Expected type \u201c%s\u201d but got \u201c%s\u201d\"),\n                                                   property_name, property_info->signature,\n                                                   g_variant_get_type_string (value));\n          g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n          g_variant_unref (value);\n          g_object_unref (reply);\n          handled = TRUE;\n          goto out;\n        }\n\n      g_variant_unref (value);\n    }\n\n  /* If the vtable pointer for get_property() resp. set_property() is\n   * NULL then dispatch the call via the method_call() handler.\n   */\n  if (is_get)\n    {\n      if (vtable->get_property == NULL)\n        {\n          schedule_method_call (connection, message, registration_id, subtree_registration_id,\n                                interface_info, NULL, property_info, g_dbus_message_get_body (message),\n                                vtable, main_context, user_data);\n          handled = TRUE;\n          goto out;\n        }\n    }\n  else\n    {\n      if (vtable->set_property == NULL)\n        {\n          schedule_method_call (connection, message, registration_id, subtree_registration_id,\n                                interface_info, NULL, property_info, g_dbus_message_get_body (message),\n                                vtable, main_context, user_data);\n          handled = TRUE;\n          goto out;\n        }\n    }\n\n  /* ok, got the property info - call user code in an idle handler */\n  property_data = g_new0 (PropertyData, 1);\n  property_data->connection = g_object_ref (connection);\n  property_data->message = g_object_ref (message);\n  property_data->user_data = user_data;\n  property_data->property_name = property_name;\n  property_data->vtable = vtable;\n  property_data->interface_info = interface_info;\n  property_data->property_info = property_info;\n  property_data->registration_id = registration_id;\n  property_data->subtree_registration_id = subtree_registration_id;\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         is_get ? invoke_get_property_in_idle_cb : invoke_set_property_in_idle_cb,\n                         property_data,\n                         (GDestroyNotify) property_data_free);\n  if (is_get)\n    g_source_set_name (idle_source, \"[gio] invoke_get_property_in_idle_cb\");\n  else\n    g_source_set_name (idle_source, \"[gio] invoke_set_property_in_idle_cb\");\n  g_source_attach (idle_source, main_context);\n  g_source_unref (idle_source);\n\n  handled = TRUE;\n\n out:\n  return handled;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nhandle_getset_property (GDBusConnection *connection,\n                        ExportedObject  *eo,\n                        GDBusMessage    *message,\n                        gboolean         is_get)\n{\n  ExportedInterface *ei;\n  gboolean handled;\n  const char *interface_name;\n  const char *property_name;\n\n  handled = FALSE;\n\n  if (is_get)\n    g_variant_get (g_dbus_message_get_body (message),\n                   \"(&s&s)\",\n                   &interface_name,\n                   &property_name);\n  else\n    g_variant_get (g_dbus_message_get_body (message),\n                   \"(&s&sv)\",\n                   &interface_name,\n                   &property_name,\n                   NULL);\n\n  /* Fail with org.freedesktop.DBus.Error.InvalidArgs if there is\n   * no such interface registered\n   */\n  ei = g_hash_table_lookup (eo->map_if_name_to_ei, interface_name);\n  if (ei == NULL)\n    {\n      GDBusMessage *reply;\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"No such interface \u201c%s\u201d\"),\n                                               interface_name);\n      g_dbus_connection_send_message_unlocked (eo->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  handled = validate_and_maybe_schedule_property_getset (eo->connection,\n                                                         message,\n                                                         ei->id,\n                                                         0,\n                                                         is_get,\n                                                         ei->interface_info,\n                                                         ei->vtable,\n                                                         ei->context,\n                                                         ei->user_data);\n out:\n  return handled;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\ntypedef struct\n{\n  GDBusConnection *connection;\n  GDBusMessage *message;\n  gpointer user_data;\n  const GDBusInterfaceVTable *vtable;\n  GDBusInterfaceInfo *interface_info;\n  guint registration_id;\n  guint subtree_registration_id;\n} PropertyGetAllData;\n\nstatic void\nproperty_get_all_data_free (PropertyData *data)\n{\n  g_object_unref (data->connection);\n  g_object_unref (data->message);\n  g_free (data);\n}\n\n/* called in thread where object was registered - no locks held */\nstatic gboolean\ninvoke_get_all_properties_in_idle_cb (gpointer _data)\n{\n  PropertyGetAllData *data = _data;\n  GVariantBuilder builder;\n  GDBusMessage *reply;\n  guint n;\n\n  if (has_object_been_unregistered (data->connection,\n                                    data->registration_id,\n                                    data->subtree_registration_id))\n    {\n      reply = g_dbus_message_new_method_error (data->message,\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"No such interface \u201corg.freedesktop.DBus.Properties\u201d on object at path %s\"),\n                                               g_dbus_message_get_path (data->message));\n      g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      goto out;\n    }\n\n  /* TODO: Right now we never fail this call - we just omit values if\n   *       a get_property() call is failing.\n   *\n   *       We could fail the whole call if just a single get_property() call\n   *       returns an error. We need clarification in the D-Bus spec about this.\n   */\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"(a{sv})\"));\n  g_variant_builder_open (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n  for (n = 0; data->interface_info->properties != NULL && data->interface_info->properties[n] != NULL; n++)\n    {\n      const GDBusPropertyInfo *property_info = data->interface_info->properties[n];\n      GVariant *value;\n\n      if (!(property_info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE))\n        continue;\n\n      value = data->vtable->get_property (data->connection,\n                                          g_dbus_message_get_sender (data->message),\n                                          g_dbus_message_get_path (data->message),\n                                          data->interface_info->name,\n                                          property_info->name,\n                                          NULL,\n                                          data->user_data);\n\n      if (value == NULL)\n        continue;\n\n      g_variant_take_ref (value);\n      g_variant_builder_add (&builder,\n                             \"{sv}\",\n                             property_info->name,\n                             value);\n      g_variant_unref (value);\n    }\n  g_variant_builder_close (&builder);\n\n  reply = g_dbus_message_new_method_reply (data->message);\n  g_dbus_message_set_body (reply, g_variant_builder_end (&builder));\n  g_dbus_connection_send_message (data->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n\n out:\n  return FALSE;\n}\n\nstatic gboolean\ninterface_has_readable_properties (GDBusInterfaceInfo *interface_info)\n{\n  gint i;\n\n  if (!interface_info->properties)\n    return FALSE;\n\n  for (i = 0; interface_info->properties[i]; i++)\n    if (interface_info->properties[i]->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)\n      return TRUE;\n\n  return FALSE;\n}\n\n/* called in any thread with connection's lock held */\nstatic gboolean\nvalidate_and_maybe_schedule_property_get_all (GDBusConnection            *connection,\n                                              GDBusMessage               *message,\n                                              guint                       registration_id,\n                                              guint                       subtree_registration_id,\n                                              GDBusInterfaceInfo         *interface_info,\n                                              const GDBusInterfaceVTable *vtable,\n                                              GMainContext               *main_context,\n                                              gpointer                    user_data)\n{\n  gboolean handled;\n  GSource *idle_source;\n  PropertyGetAllData *property_get_all_data;\n\n  handled = FALSE;\n\n  if (vtable == NULL)\n    goto out;\n\n  /* If the vtable pointer for get_property() is NULL but we have a\n   * non-zero number of readable properties, then dispatch the call via\n   * the method_call() handler.\n   */\n  if (vtable->get_property == NULL && interface_has_readable_properties (interface_info))\n    {\n      schedule_method_call (connection, message, registration_id, subtree_registration_id,\n                            interface_info, NULL, NULL, g_dbus_message_get_body (message),\n                            vtable, main_context, user_data);\n      handled = TRUE;\n      goto out;\n    }\n\n  /* ok, got the property info - call user in an idle handler */\n  property_get_all_data = g_new0 (PropertyGetAllData, 1);\n  property_get_all_data->connection = g_object_ref (connection);\n  property_get_all_data->message = g_object_ref (message);\n  property_get_all_data->user_data = user_data;\n  property_get_all_data->vtable = vtable;\n  property_get_all_data->interface_info = interface_info;\n  property_get_all_data->registration_id = registration_id;\n  property_get_all_data->subtree_registration_id = subtree_registration_id;\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         invoke_get_all_properties_in_idle_cb,\n                         property_get_all_data,\n                         (GDestroyNotify) property_get_all_data_free);\n  g_source_set_name (idle_source, \"[gio] invoke_get_all_properties_in_idle_cb\");\n  g_source_attach (idle_source, main_context);\n  g_source_unref (idle_source);\n\n  handled = TRUE;\n\n out:\n  return handled;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nhandle_get_all_properties (GDBusConnection *connection,\n                           ExportedObject  *eo,\n                           GDBusMessage    *message)\n{\n  ExportedInterface *ei;\n  gboolean handled;\n  const char *interface_name;\n\n  handled = FALSE;\n\n  g_variant_get (g_dbus_message_get_body (message),\n                 \"(&s)\",\n                 &interface_name);\n\n  /* Fail with org.freedesktop.DBus.Error.InvalidArgs if there is\n   * no such interface registered\n   */\n  ei = g_hash_table_lookup (eo->map_if_name_to_ei, interface_name);\n  if (ei == NULL)\n    {\n      GDBusMessage *reply;\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"No such interface \u201c%s\u201d\"),\n                                               interface_name);\n      g_dbus_connection_send_message_unlocked (eo->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  handled = validate_and_maybe_schedule_property_get_all (eo->connection,\n                                                          message,\n                                                          ei->id,\n                                                          0,\n                                                          ei->interface_info,\n                                                          ei->vtable,\n                                                          ei->context,\n                                                          ei->user_data);\n out:\n  return handled;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstatic const gchar introspect_header[] =\n  \"<!DOCTYPE node PUBLIC \\\"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\\\"\\n\"\n  \"                      \\\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\\\">\\n\"\n  \"<!-- GDBus \" PACKAGE_VERSION \" -->\\n\"\n  \"<node>\\n\";\n\nstatic const gchar introspect_tail[] =\n  \"</node>\\n\";\n\nstatic const gchar introspect_properties_interface[] =\n  \"  <interface name=\\\"org.freedesktop.DBus.Properties\\\">\\n\"\n  \"    <method name=\\\"Get\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"interface_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"property_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"v\\\" name=\\\"value\\\" direction=\\\"out\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"    <method name=\\\"GetAll\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"interface_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"a{sv}\\\" name=\\\"properties\\\" direction=\\\"out\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"    <method name=\\\"Set\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"interface_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"property_name\\\" direction=\\\"in\\\"/>\\n\"\n  \"      <arg type=\\\"v\\\" name=\\\"value\\\" direction=\\\"in\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"    <signal name=\\\"PropertiesChanged\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"interface_name\\\"/>\\n\"\n  \"      <arg type=\\\"a{sv}\\\" name=\\\"changed_properties\\\"/>\\n\"\n  \"      <arg type=\\\"as\\\" name=\\\"invalidated_properties\\\"/>\\n\"\n  \"    </signal>\\n\"\n  \"  </interface>\\n\";\n\nstatic const gchar introspect_introspectable_interface[] =\n  \"  <interface name=\\\"org.freedesktop.DBus.Introspectable\\\">\\n\"\n  \"    <method name=\\\"Introspect\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"xml_data\\\" direction=\\\"out\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"  </interface>\\n\"\n  \"  <interface name=\\\"org.freedesktop.DBus.Peer\\\">\\n\"\n  \"    <method name=\\\"Ping\\\"/>\\n\"\n  \"    <method name=\\\"GetMachineId\\\">\\n\"\n  \"      <arg type=\\\"s\\\" name=\\\"machine_uuid\\\" direction=\\\"out\\\"/>\\n\"\n  \"    </method>\\n\"\n  \"  </interface>\\n\";\n\nstatic void\nintrospect_append_header (GString *s)\n{\n  g_string_append (s, introspect_header);\n}\n\nstatic void\nmaybe_add_path (const gchar *path, gsize path_len, const gchar *object_path, GHashTable *set)\n{\n  if (g_str_has_prefix (object_path, path) && strlen (object_path) > path_len && object_path[path_len-1] == '/')\n    {\n      const gchar *begin;\n      const gchar *end;\n      gchar *s;\n\n      begin = object_path + path_len;\n      end = strchr (begin, '/');\n      if (end != NULL)\n        s = g_strndup (begin, end - begin);\n      else\n        s = g_strdup (begin);\n\n      if (!g_hash_table_contains (set, s))\n        g_hash_table_add (set, s);\n      else\n        g_free (s);\n    }\n}\n\n/* TODO: we want a nicer public interface for this */\n/* called in any thread with connection's lock held */\nstatic gchar **\ng_dbus_connection_list_registered_unlocked (GDBusConnection *connection,\n                                            const gchar     *path)\n{\n  GPtrArray *p;\n  gchar **ret;\n  GHashTableIter hash_iter;\n  const gchar *object_path;\n  gsize path_len;\n  GHashTable *set;\n  GList *keys;\n  GList *l;\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  path_len = strlen (path);\n  if (path_len > 1)\n    path_len++;\n\n  set = g_hash_table_new (g_str_hash, g_str_equal);\n\n  g_hash_table_iter_init (&hash_iter, connection->map_object_path_to_eo);\n  while (g_hash_table_iter_next (&hash_iter, (gpointer) &object_path, NULL))\n    maybe_add_path (path, path_len, object_path, set);\n\n  g_hash_table_iter_init (&hash_iter, connection->map_object_path_to_es);\n  while (g_hash_table_iter_next (&hash_iter, (gpointer) &object_path, NULL))\n    maybe_add_path (path, path_len, object_path, set);\n\n  p = g_ptr_array_new ();\n  keys = g_hash_table_get_keys (set);\n  for (l = keys; l != NULL; l = l->next)\n    g_ptr_array_add (p, l->data);\n  g_hash_table_unref (set);\n  g_list_free (keys);\n\n  g_ptr_array_add (p, NULL);\n  ret = (gchar **) g_ptr_array_free (p, FALSE);\n  return ret;\n}\n\n/* called in any thread with connection's lock not held */\nstatic gchar **\ng_dbus_connection_list_registered (GDBusConnection *connection,\n                                   const gchar     *path)\n{\n  gchar **ret;\n  CONNECTION_LOCK (connection);\n  ret = g_dbus_connection_list_registered_unlocked (connection, path);\n  CONNECTION_UNLOCK (connection);\n  return ret;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nhandle_introspect (GDBusConnection *connection,\n                   ExportedObject  *eo,\n                   GDBusMessage    *message)\n{\n  guint n;\n  GString *s;\n  GDBusMessage *reply;\n  GHashTableIter hash_iter;\n  ExportedInterface *ei;\n  gchar **registered;\n\n  /* first the header with the standard interfaces */\n  s = g_string_sized_new (sizeof (introspect_header) +\n                          sizeof (introspect_properties_interface) +\n                          sizeof (introspect_introspectable_interface) +\n                          sizeof (introspect_tail));\n  introspect_append_header (s);\n  if (!g_hash_table_lookup (eo->map_if_name_to_ei,\n                            \"org.freedesktop.DBus.Properties\"))\n    g_string_append (s, introspect_properties_interface);\n\n  if (!g_hash_table_lookup (eo->map_if_name_to_ei,\n                            \"org.freedesktop.DBus.Introspectable\"))\n    g_string_append (s, introspect_introspectable_interface);\n\n  /* then include the registered interfaces */\n  g_hash_table_iter_init (&hash_iter, eo->map_if_name_to_ei);\n  while (g_hash_table_iter_next (&hash_iter, NULL, (gpointer) &ei))\n    g_dbus_interface_info_generate_xml (ei->interface_info, 2, s);\n\n  /* finally include nodes registered below us */\n  registered = g_dbus_connection_list_registered_unlocked (connection, eo->object_path);\n  for (n = 0; registered != NULL && registered[n] != NULL; n++)\n    g_string_append_printf (s, \"  <node name=\\\"%s\\\"/>\\n\", registered[n]);\n  g_strfreev (registered);\n  g_string_append (s, introspect_tail);\n\n  reply = g_dbus_message_new_method_reply (message);\n  g_dbus_message_set_body (reply, g_variant_new (\"(s)\", s->str));\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n  g_string_free (s, TRUE);\n\n  return TRUE;\n}\n\n/* called in thread where object was registered - no locks held */\nstatic gboolean\ncall_in_idle_cb (gpointer user_data)\n{\n  GDBusMethodInvocation *invocation = G_DBUS_METHOD_INVOCATION (user_data);\n  GDBusInterfaceVTable *vtable;\n  guint registration_id;\n  guint subtree_registration_id;\n\n  registration_id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (invocation), \"g-dbus-registration-id\"));\n  subtree_registration_id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (invocation), \"g-dbus-subtree-registration-id\"));\n\n  if (has_object_been_unregistered (g_dbus_method_invocation_get_connection (invocation),\n                                    registration_id,\n                                    subtree_registration_id))\n    {\n      GDBusMessage *reply;\n      reply = g_dbus_message_new_method_error (g_dbus_method_invocation_get_message (invocation),\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"No such interface \u201c%s\u201d on object at path %s\"),\n                                               g_dbus_method_invocation_get_interface_name (invocation),\n                                               g_dbus_method_invocation_get_object_path (invocation));\n      g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      goto out;\n    }\n\n  vtable = g_object_get_data (G_OBJECT (invocation), \"g-dbus-interface-vtable\");\n  g_assert (vtable != NULL && vtable->method_call != NULL);\n\n  vtable->method_call (g_dbus_method_invocation_get_connection (invocation),\n                       g_dbus_method_invocation_get_sender (invocation),\n                       g_dbus_method_invocation_get_object_path (invocation),\n                       g_dbus_method_invocation_get_interface_name (invocation),\n                       g_dbus_method_invocation_get_method_name (invocation),\n                       g_dbus_method_invocation_get_parameters (invocation),\n                       g_object_ref (invocation),\n                       g_dbus_method_invocation_get_user_data (invocation));\n\n out:\n  return FALSE;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic void\nschedule_method_call (GDBusConnection            *connection,\n                      GDBusMessage               *message,\n                      guint                       registration_id,\n                      guint                       subtree_registration_id,\n                      const GDBusInterfaceInfo   *interface_info,\n                      const GDBusMethodInfo      *method_info,\n                      const GDBusPropertyInfo    *property_info,\n                      GVariant                   *parameters,\n                      const GDBusInterfaceVTable *vtable,\n                      GMainContext               *main_context,\n                      gpointer                    user_data)\n{\n  GDBusMethodInvocation *invocation;\n  GSource *idle_source;\n\n  invocation = _g_dbus_method_invocation_new (g_dbus_message_get_sender (message),\n                                              g_dbus_message_get_path (message),\n                                              g_dbus_message_get_interface (message),\n                                              g_dbus_message_get_member (message),\n                                              method_info,\n                                              property_info,\n                                              connection,\n                                              message,\n                                              parameters,\n                                              user_data);\n\n  /* TODO: would be nicer with a real MethodData like we already\n   * have PropertyData and PropertyGetAllData... */\n  g_object_set_data (G_OBJECT (invocation), \"g-dbus-interface-vtable\", (gpointer) vtable);\n  g_object_set_data (G_OBJECT (invocation), \"g-dbus-registration-id\", GUINT_TO_POINTER (registration_id));\n  g_object_set_data (G_OBJECT (invocation), \"g-dbus-subtree-registration-id\", GUINT_TO_POINTER (subtree_registration_id));\n\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_DEFAULT);\n  g_source_set_callback (idle_source,\n                         call_in_idle_cb,\n                         invocation,\n                         g_object_unref);\n  g_source_set_name (idle_source, \"[gio, \" __FILE__ \"] call_in_idle_cb\");\n  g_source_attach (idle_source, main_context);\n  g_source_unref (idle_source);\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nvalidate_and_maybe_schedule_method_call (GDBusConnection            *connection,\n                                         GDBusMessage               *message,\n                                         guint                       registration_id,\n                                         guint                       subtree_registration_id,\n                                         GDBusInterfaceInfo         *interface_info,\n                                         const GDBusInterfaceVTable *vtable,\n                                         GMainContext               *main_context,\n                                         gpointer                    user_data)\n{\n  GDBusMethodInfo *method_info;\n  GDBusMessage *reply;\n  GVariant *parameters;\n  gboolean handled;\n  GVariantType *in_type;\n\n  handled = FALSE;\n\n  /* TODO: the cost of this is O(n) - it might be worth caching the result */\n  method_info = g_dbus_interface_info_lookup_method (interface_info, g_dbus_message_get_member (message));\n\n  /* if the method doesn't exist, return the org.freedesktop.DBus.Error.UnknownMethod\n   * error to the caller\n   */\n  if (method_info == NULL)\n    {\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"No such method \u201c%s\u201d\"),\n                                               g_dbus_message_get_member (message));\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n      handled = TRUE;\n      goto out;\n    }\n\n  parameters = g_dbus_message_get_body (message);\n  if (parameters == NULL)\n    {\n      parameters = g_variant_new (\"()\");\n      g_variant_ref_sink (parameters);\n    }\n  else\n    {\n      g_variant_ref (parameters);\n    }\n\n  /* Check that the incoming args are of the right type - if they are not, return\n   * the org.freedesktop.DBus.Error.InvalidArgs error to the caller\n   */\n  in_type = _g_dbus_compute_complete_signature (method_info->in_args);\n  if (!g_variant_is_of_type (parameters, in_type))\n    {\n      gchar *type_string;\n\n      type_string = g_variant_type_dup_string (in_type);\n\n      reply = g_dbus_message_new_method_error (message,\n                                               \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                               _(\"Type of message, \u201c%s\u201d, does not match expected type \u201c%s\u201d\"),\n                                               g_variant_get_type_string (parameters),\n                                               type_string);\n      g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_variant_type_free (in_type);\n      g_variant_unref (parameters);\n      g_object_unref (reply);\n      g_free (type_string);\n      handled = TRUE;\n      goto out;\n    }\n  g_variant_type_free (in_type);\n\n  /* schedule the call in idle */\n  schedule_method_call (connection, message, registration_id, subtree_registration_id,\n                        interface_info, method_info, NULL, parameters,\n                        vtable, main_context, user_data);\n  g_variant_unref (parameters);\n  handled = TRUE;\n\n out:\n  return handled;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nobj_message_func (GDBusConnection *connection,\n                  ExportedObject  *eo,\n                  GDBusMessage    *message)\n{\n  const gchar *interface_name;\n  const gchar *member;\n  const gchar *signature;\n  gboolean handled;\n\n  handled = FALSE;\n\n  interface_name = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  signature = g_dbus_message_get_signature (message);\n\n  /* see if we have an interface for handling this call */\n  if (interface_name != NULL)\n    {\n      ExportedInterface *ei;\n      ei = g_hash_table_lookup (eo->map_if_name_to_ei, interface_name);\n      if (ei != NULL)\n        {\n          /* we do - invoke the handler in idle in the right thread */\n\n          /* handle no vtable or handler being present */\n          if (ei->vtable == NULL || ei->vtable->method_call == NULL)\n            goto out;\n\n          handled = validate_and_maybe_schedule_method_call (connection,\n                                                             message,\n                                                             ei->id,\n                                                             0,\n                                                             ei->interface_info,\n                                                             ei->vtable,\n                                                             ei->context,\n                                                             ei->user_data);\n          goto out;\n        }\n    }\n\n  if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Introspectable\") == 0 &&\n      g_strcmp0 (member, \"Introspect\") == 0 &&\n      g_strcmp0 (signature, \"\") == 0)\n    {\n      handled = handle_introspect (connection, eo, message);\n      goto out;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Properties\") == 0 &&\n           g_strcmp0 (member, \"Get\") == 0 &&\n           g_strcmp0 (signature, \"ss\") == 0)\n    {\n      handled = handle_getset_property (connection, eo, message, TRUE);\n      goto out;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Properties\") == 0 &&\n           g_strcmp0 (member, \"Set\") == 0 &&\n           g_strcmp0 (signature, \"ssv\") == 0)\n    {\n      handled = handle_getset_property (connection, eo, message, FALSE);\n      goto out;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Properties\") == 0 &&\n           g_strcmp0 (member, \"GetAll\") == 0 &&\n           g_strcmp0 (signature, \"s\") == 0)\n    {\n      handled = handle_get_all_properties (connection, eo, message);\n      goto out;\n    }\n\n out:\n  return handled;\n}\n\n/**\n * g_dbus_connection_register_object:\n * @connection: a #GDBusConnection\n * @object_path: the object path to register at\n * @interface_info: introspection data for the interface\n * @vtable: (nullable): a #GDBusInterfaceVTable to call into or %NULL\n * @user_data: (nullable): data to pass to functions in @vtable\n * @user_data_free_func: function to call when the object path is unregistered\n * @error: return location for error or %NULL\n *\n * Registers callbacks for exported objects at @object_path with the\n * D-Bus interface that is described in @interface_info.\n *\n * Calls to functions in @vtable (and @user_data_free_func) will happen\n * in the \n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from.\n *\n * Note that all #GVariant values passed to functions in @vtable will match\n * the signature given in @interface_info - if a remote caller passes\n * incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`\n * is returned to the remote caller.\n *\n * Additionally, if the remote caller attempts to invoke methods or\n * access properties not mentioned in @interface_info the\n * `org.freedesktop.DBus.Error.UnknownMethod` resp.\n * `org.freedesktop.DBus.Error.InvalidArgs` errors\n * are returned to the caller.\n *\n * It is considered a programming error if the\n * #GDBusInterfaceGetPropertyFunc function in @vtable returns a\n * #GVariant of incorrect type.\n *\n * If an existing callback is already registered at @object_path and\n * @interface_name, then @error is set to #G_IO_ERROR_EXISTS.\n *\n * GDBus automatically implements the standard D-Bus interfaces\n * org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable\n * and org.freedesktop.Peer, so you don't have to implement those for the\n * objects you export. You can implement org.freedesktop.DBus.Properties\n * yourself, e.g. to handle getting and setting of properties asynchronously.\n *\n * Note that the reference count on @interface_info will be\n * incremented by 1 (unless allocated statically, e.g. if the\n * reference count is -1, see g_dbus_interface_info_ref()) for as long\n * as the object is exported. Also note that @vtable will be copied.\n *\n * See this [server][gdbus-server] for an example of how to use this method.\n *\n * Returns: 0 if @error is set, otherwise a registration id (never 0)\n *     that can be used with g_dbus_connection_unregister_object()\n *\n * Since: 2.26\n */\nguint\ng_dbus_connection_register_object (GDBusConnection             *connection,\n                                   const gchar                 *object_path,\n                                   GDBusInterfaceInfo          *interface_info,\n                                   const GDBusInterfaceVTable  *vtable,\n                                   gpointer                     user_data,\n                                   GDestroyNotify               user_data_free_func,\n                                   GError                     **error)\n{\n  ExportedObject *eo;\n  ExportedInterface *ei;\n  guint ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n  g_return_val_if_fail (object_path != NULL && g_variant_is_object_path (object_path), 0);\n  g_return_val_if_fail (interface_info != NULL, 0);\n  g_return_val_if_fail (g_dbus_is_interface_name (interface_info->name), 0);\n  g_return_val_if_fail (error == NULL || *error == NULL, 0);\n  g_return_val_if_fail (check_initialized (connection), 0);\n\n  ret = 0;\n\n  CONNECTION_LOCK (connection);\n\n  eo = g_hash_table_lookup (connection->map_object_path_to_eo, object_path);\n  if (eo == NULL)\n    {\n      eo = g_new0 (ExportedObject, 1);\n      eo->object_path = g_strdup (object_path);\n      eo->connection = connection;\n      eo->map_if_name_to_ei = g_hash_table_new_full (g_str_hash,\n                                                     g_str_equal,\n                                                     NULL,\n                                                     (GDestroyNotify) exported_interface_free);\n      g_hash_table_insert (connection->map_object_path_to_eo, eo->object_path, eo);\n    }\n\n  ei = g_hash_table_lookup (eo->map_if_name_to_ei, interface_info->name);\n  if (ei != NULL)\n    {\n      g_set_error (error,\n                   G_IO_ERROR,\n                   G_IO_ERROR_EXISTS,\n                   _(\"An object is already exported for the interface %s at %s\"),\n                   interface_info->name,\n                   object_path);\n      goto out;\n    }\n\n  ei = g_new0 (ExportedInterface, 1);\n  ei->id = g_atomic_int_add (&_global_registration_id, 1); /* TODO: overflow etc. */\n  ei->eo = eo;\n  ei->user_data = user_data;\n  ei->user_data_free_func = user_data_free_func;\n  ei->vtable = _g_dbus_interface_vtable_copy (vtable);\n  ei->interface_info = g_dbus_interface_info_ref (interface_info);\n  g_dbus_interface_info_cache_build (ei->interface_info);\n  ei->interface_name = g_strdup (interface_info->name);\n  ei->context = g_main_context_ref_thread_default ();\n\n  g_hash_table_insert (eo->map_if_name_to_ei,\n                       (gpointer) ei->interface_name,\n                       ei);\n  g_hash_table_insert (connection->map_id_to_ei,\n                       GUINT_TO_POINTER (ei->id),\n                       ei);\n\n  ret = ei->id;\n\n out:\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/**\n * g_dbus_connection_unregister_object:\n * @connection: a #GDBusConnection\n * @registration_id: a registration id obtained from\n *     g_dbus_connection_register_object()\n *\n * Unregisters an object.\n *\n * Returns: %TRUE if the object was unregistered, %FALSE otherwise\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_unregister_object (GDBusConnection *connection,\n                                     guint            registration_id)\n{\n  ExportedInterface *ei;\n  ExportedObject *eo;\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (check_initialized (connection), FALSE);\n\n  ret = FALSE;\n\n  CONNECTION_LOCK (connection);\n\n  ei = g_hash_table_lookup (connection->map_id_to_ei,\n                            GUINT_TO_POINTER (registration_id));\n  if (ei == NULL)\n    goto out;\n\n  eo = ei->eo;\n\n  g_warn_if_fail (g_hash_table_remove (connection->map_id_to_ei, GUINT_TO_POINTER (ei->id)));\n  g_warn_if_fail (g_hash_table_remove (eo->map_if_name_to_ei, ei->interface_name));\n  /* unregister object path if we have no more exported interfaces */\n  if (g_hash_table_size (eo->map_if_name_to_ei) == 0)\n    g_warn_if_fail (g_hash_table_remove (connection->map_object_path_to_eo,\n                                         eo->object_path));\n\n  ret = TRUE;\n\n out:\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\ntypedef struct {\n  GClosure *method_call_closure;\n  GClosure *get_property_closure;\n  GClosure *set_property_closure;\n} RegisterObjectData;\n\nstatic RegisterObjectData *\nregister_object_data_new (GClosure *method_call_closure,\n                          GClosure *get_property_closure,\n                          GClosure *set_property_closure)\n{\n  RegisterObjectData *data;\n\n  data = g_new0 (RegisterObjectData, 1);\n\n  if (method_call_closure != NULL)\n    {\n      data->method_call_closure = g_closure_ref (method_call_closure);\n      g_closure_sink (method_call_closure);\n      if (G_CLOSURE_NEEDS_MARSHAL (method_call_closure))\n        g_closure_set_marshal (method_call_closure, g_cclosure_marshal_generic);\n    }\n\n  if (get_property_closure != NULL)\n    {\n      data->get_property_closure = g_closure_ref (get_property_closure);\n      g_closure_sink (get_property_closure);\n      if (G_CLOSURE_NEEDS_MARSHAL (get_property_closure))\n        g_closure_set_marshal (get_property_closure, g_cclosure_marshal_generic);\n    }\n\n  if (set_property_closure != NULL)\n    {\n      data->set_property_closure = g_closure_ref (set_property_closure);\n      g_closure_sink (set_property_closure);\n      if (G_CLOSURE_NEEDS_MARSHAL (set_property_closure))\n        g_closure_set_marshal (set_property_closure, g_cclosure_marshal_generic);\n    }\n\n  return data;\n}\n\nstatic void\nregister_object_free_func (gpointer user_data)\n{\n  RegisterObjectData *data = user_data;\n\n  g_clear_pointer (&data->method_call_closure, g_closure_unref);\n  g_clear_pointer (&data->get_property_closure, g_closure_unref);\n  g_clear_pointer (&data->set_property_closure, g_closure_unref);\n\n  g_free (data);\n}\n\nstatic void\nregister_with_closures_on_method_call (GDBusConnection       *connection,\n                                       const gchar           *sender,\n                                       const gchar           *object_path,\n                                       const gchar           *interface_name,\n                                       const gchar           *method_name,\n                                       GVariant              *parameters,\n                                       GDBusMethodInvocation *invocation,\n                                       gpointer               user_data)\n{\n  RegisterObjectData *data = user_data;\n  GValue params[] = { G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT };\n\n  g_value_init (&params[0], G_TYPE_DBUS_CONNECTION);\n  g_value_set_object (&params[0], connection);\n\n  g_value_init (&params[1], G_TYPE_STRING);\n  g_value_set_string (&params[1], sender);\n\n  g_value_init (&params[2], G_TYPE_STRING);\n  g_value_set_string (&params[2], object_path);\n\n  g_value_init (&params[3], G_TYPE_STRING);\n  g_value_set_string (&params[3], interface_name);\n\n  g_value_init (&params[4], G_TYPE_STRING);\n  g_value_set_string (&params[4], method_name);\n\n  g_value_init (&params[5], G_TYPE_VARIANT);\n  g_value_set_variant (&params[5], parameters);\n\n  g_value_init (&params[6], G_TYPE_DBUS_METHOD_INVOCATION);\n  g_value_set_object (&params[6], invocation);\n\n  g_closure_invoke (data->method_call_closure, NULL, G_N_ELEMENTS (params), params, NULL);\n\n  g_value_unset (params + 0);\n  g_value_unset (params + 1);\n  g_value_unset (params + 2);\n  g_value_unset (params + 3);\n  g_value_unset (params + 4);\n  g_value_unset (params + 5);\n  g_value_unset (params + 6);\n}\n\nstatic GVariant *\nregister_with_closures_on_get_property (GDBusConnection *connection,\n                                        const gchar     *sender,\n                                        const gchar     *object_path,\n                                        const gchar     *interface_name,\n                                        const gchar     *property_name,\n                                        GError         **error,\n                                        gpointer         user_data)\n{\n  RegisterObjectData *data = user_data;\n  GValue params[] = { G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT };\n  GValue result_value = G_VALUE_INIT;\n  GVariant *result;\n\n  g_value_init (&params[0], G_TYPE_DBUS_CONNECTION);\n  g_value_set_object (&params[0], connection);\n\n  g_value_init (&params[1], G_TYPE_STRING);\n  g_value_set_string (&params[1], sender);\n\n  g_value_init (&params[2], G_TYPE_STRING);\n  g_value_set_string (&params[2], object_path);\n\n  g_value_init (&params[3], G_TYPE_STRING);\n  g_value_set_string (&params[3], interface_name);\n\n  g_value_init (&params[4], G_TYPE_STRING);\n  g_value_set_string (&params[4], property_name);\n\n  g_value_init (&result_value, G_TYPE_VARIANT);\n\n  g_closure_invoke (data->get_property_closure, &result_value, G_N_ELEMENTS (params), params, NULL);\n\n  result = g_value_get_variant (&result_value);\n  if (result)\n    g_variant_ref (result);\n\n  g_value_unset (params + 0);\n  g_value_unset (params + 1);\n  g_value_unset (params + 2);\n  g_value_unset (params + 3);\n  g_value_unset (params + 4);\n  g_value_unset (&result_value);\n\n  if (!result)\n    g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_FAILED,\n                 _(\"Unable to retrieve property %s.%s\"),\n                 interface_name, property_name);\n\n  return result;\n}\n\nstatic gboolean\nregister_with_closures_on_set_property (GDBusConnection *connection,\n                                        const gchar     *sender,\n                                        const gchar     *object_path,\n                                        const gchar     *interface_name,\n                                        const gchar     *property_name,\n                                        GVariant        *value,\n                                        GError         **error,\n                                        gpointer         user_data)\n{\n  RegisterObjectData *data = user_data;\n  GValue params[] = { G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT };\n  GValue result_value = G_VALUE_INIT;\n  gboolean result;\n\n  g_value_init (&params[0], G_TYPE_DBUS_CONNECTION);\n  g_value_set_object (&params[0], connection);\n\n  g_value_init (&params[1], G_TYPE_STRING);\n  g_value_set_string (&params[1], sender);\n\n  g_value_init (&params[2], G_TYPE_STRING);\n  g_value_set_string (&params[2], object_path);\n\n  g_value_init (&params[3], G_TYPE_STRING);\n  g_value_set_string (&params[3], interface_name);\n\n  g_value_init (&params[4], G_TYPE_STRING);\n  g_value_set_string (&params[4], property_name);\n\n  g_value_init (&params[5], G_TYPE_VARIANT);\n  g_value_set_variant (&params[5], value);\n\n  g_value_init (&result_value, G_TYPE_BOOLEAN);\n\n  g_closure_invoke (data->set_property_closure, &result_value, G_N_ELEMENTS (params), params, NULL);\n\n  result = g_value_get_boolean (&result_value);\n\n  g_value_unset (params + 0);\n  g_value_unset (params + 1);\n  g_value_unset (params + 2);\n  g_value_unset (params + 3);\n  g_value_unset (params + 4);\n  g_value_unset (params + 5);\n  g_value_unset (&result_value);\n\n  if (!result)\n    g_set_error (error,\n                 G_DBUS_ERROR, G_DBUS_ERROR_FAILED,\n                 _(\"Unable to set property %s.%s\"),\n                 interface_name, property_name);\n\n  return result;\n}\n\n/**\n * g_dbus_connection_register_object_with_closures: (rename-to g_dbus_connection_register_object)\n * @connection: A #GDBusConnection.\n * @object_path: The object path to register at.\n * @interface_info: Introspection data for the interface.\n * @method_call_closure: (nullable): #GClosure for handling incoming method calls.\n * @get_property_closure: (nullable): #GClosure for getting a property.\n * @set_property_closure: (nullable): #GClosure for setting a property.\n * @error: Return location for error or %NULL.\n *\n * Version of g_dbus_connection_register_object() using closures instead of a\n * #GDBusInterfaceVTable for easier binding in other languages.\n *\n * Returns: 0 if @error is set, otherwise a registration id (never 0)\n * that can be used with g_dbus_connection_unregister_object() .\n *\n * Since: 2.46\n */\nguint\ng_dbus_connection_register_object_with_closures (GDBusConnection     *connection,\n                                                 const gchar         *object_path,\n                                                 GDBusInterfaceInfo  *interface_info,\n                                                 GClosure            *method_call_closure,\n                                                 GClosure            *get_property_closure,\n                                                 GClosure            *set_property_closure,\n                                                 GError             **error)\n{\n  RegisterObjectData *data;\n  GDBusInterfaceVTable vtable =\n    {\n      method_call_closure != NULL  ? register_with_closures_on_method_call  : NULL,\n      get_property_closure != NULL ? register_with_closures_on_get_property : NULL,\n      set_property_closure != NULL ? register_with_closures_on_set_property : NULL\n    };\n\n  data = register_object_data_new (method_call_closure, get_property_closure, set_property_closure);\n\n  return g_dbus_connection_register_object (connection,\n                                            object_path,\n                                            interface_info,\n                                            &vtable,\n                                            data,\n                                            register_object_free_func,\n                                            error);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_emit_signal:\n * @connection: a #GDBusConnection\n * @destination_bus_name: (nullable): the unique bus name for the destination\n *     for the signal or %NULL to emit to all listeners\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to emit a signal on\n * @signal_name: the name of the signal to emit\n * @parameters: (nullable): a #GVariant tuple with parameters for the signal\n *              or %NULL if not passing parameters\n * @error: Return location for error or %NULL\n *\n * Emits a signal.\n *\n * If the parameters GVariant is floating, it is consumed.\n *\n * This can only fail if @parameters is not compatible with the D-Bus protocol\n * (%G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed\n * (%G_IO_ERROR_CLOSED).\n *\n * Returns: %TRUE unless @error is set\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_emit_signal (GDBusConnection  *connection,\n                               const gchar      *destination_bus_name,\n                               const gchar      *object_path,\n                               const gchar      *interface_name,\n                               const gchar      *signal_name,\n                               GVariant         *parameters,\n                               GError          **error)\n{\n  GDBusMessage *message;\n  gboolean ret;\n\n  message = NULL;\n  ret = FALSE;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (destination_bus_name == NULL || g_dbus_is_name (destination_bus_name), FALSE);\n  g_return_val_if_fail (object_path != NULL && g_variant_is_object_path (object_path), FALSE);\n  g_return_val_if_fail (interface_name != NULL && g_dbus_is_interface_name (interface_name), FALSE);\n  g_return_val_if_fail (signal_name != NULL && g_dbus_is_member_name (signal_name), FALSE);\n  g_return_val_if_fail (parameters == NULL || g_variant_is_of_type (parameters, G_VARIANT_TYPE_TUPLE), FALSE);\n  g_return_val_if_fail (check_initialized (connection), FALSE);\n\n  if (G_UNLIKELY (_g_dbus_debug_emission ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Emission:\\n\"\n               \" >>>> SIGNAL EMISSION %s.%s()\\n\"\n               \"      on object %s\\n\"\n               \"      destination %s\\n\",\n               interface_name, signal_name,\n               object_path,\n               destination_bus_name != NULL ? destination_bus_name : \"(none)\");\n      _g_dbus_debug_print_unlock ();\n    }\n\n  message = g_dbus_message_new_signal (object_path,\n                                       interface_name,\n                                       signal_name);\n\n  if (destination_bus_name != NULL)\n    g_dbus_message_set_header (message,\n                               G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION,\n                               g_variant_new_string (destination_bus_name));\n\n  if (parameters != NULL)\n    g_dbus_message_set_body (message, parameters);\n\n  ret = g_dbus_connection_send_message (connection, message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, error);\n  g_object_unref (message);\n\n  return ret;\n}\n\nstatic void\nadd_call_flags (GDBusMessage           *message,\n                         GDBusCallFlags  flags)\n{\n  GDBusMessageFlags msg_flags = 0;\n\n  if (flags & G_DBUS_CALL_FLAGS_NO_AUTO_START)\n    msg_flags |= G_DBUS_MESSAGE_FLAGS_NO_AUTO_START;\n  if (flags & G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)\n    msg_flags |= G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION;\n  if (msg_flags)\n    g_dbus_message_set_flags (message, msg_flags);\n}\n\nstatic GVariant *\ndecode_method_reply (GDBusMessage        *reply,\n                     const gchar         *method_name,\n                     const GVariantType  *reply_type,\n                     GUnixFDList        **out_fd_list,\n                     GError             **error)\n{\n  GVariant *result;\n\n  result = NULL;\n  switch (g_dbus_message_get_message_type (reply))\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n      result = g_dbus_message_get_body (reply);\n      if (result == NULL)\n        {\n          result = g_variant_new (\"()\");\n          g_variant_ref_sink (result);\n        }\n      else\n        {\n          g_variant_ref (result);\n        }\n\n      if (!g_variant_is_of_type (result, reply_type))\n        {\n          gchar *type_string = g_variant_type_dup_string (reply_type);\n\n          g_set_error (error,\n                       G_IO_ERROR,\n                       G_IO_ERROR_INVALID_ARGUMENT,\n                       _(\"Method \u201c%s\u201d returned type \u201c%s\u201d, but expected \u201c%s\u201d\"),\n                       method_name, g_variant_get_type_string (result), type_string);\n\n          g_variant_unref (result);\n          g_free (type_string);\n          result = NULL;\n        }\n\n#ifdef G_OS_UNIX\n      if (result != NULL)\n        {\n          if (out_fd_list != NULL)\n            {\n              *out_fd_list = g_dbus_message_get_unix_fd_list (reply);\n              if (*out_fd_list != NULL)\n                g_object_ref (*out_fd_list);\n            }\n        }\n#endif\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n      g_dbus_message_to_gerror (reply, error);\n      break;\n\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  return result;\n}\n\n\ntypedef struct\n{\n  GVariantType *reply_type;\n  gchar *method_name; /* for error message */\n\n  GUnixFDList *fd_list;\n} CallState;\n\nstatic void\ncall_state_free (CallState *state)\n{\n  g_variant_type_free (state->reply_type);\n  g_free (state->method_name);\n\n  if (state->fd_list != NULL)\n    g_object_unref (state->fd_list);\n  g_slice_free (CallState, state);\n}\n\n/* called in any thread, with the connection's lock not held */\nstatic void\ng_dbus_connection_call_done (GObject      *source,\n                             GAsyncResult *result,\n                             gpointer      user_data)\n{\n  GDBusConnection *connection = G_DBUS_CONNECTION (source);\n  GTask *task = user_data;\n  CallState *state = g_task_get_task_data (task);\n  GError *error = NULL;\n  GDBusMessage *reply;\n  GVariant *value = NULL;\n\n  reply = g_dbus_connection_send_message_with_reply_finish (connection,\n                                                            result,\n                                                            &error);\n\n  if (G_UNLIKELY (_g_dbus_debug_call ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Call:\\n\"\n               \" <<<< ASYNC COMPLETE %s() (serial %d)\\n\"\n               \"      \",\n               state->method_name,\n               g_dbus_message_get_reply_serial (reply));\n      if (reply != NULL)\n        {\n          g_print (\"SUCCESS\\n\");\n        }\n      else\n        {\n          g_print (\"FAILED: %s\\n\",\n                   error->message);\n        }\n      _g_dbus_debug_print_unlock ();\n    }\n\n  if (reply != NULL)\n    value = decode_method_reply (reply, state->method_name, state->reply_type, &state->fd_list, &error);\n\n  if (error != NULL)\n    g_task_return_error (task, error);\n  else\n    g_task_return_pointer (task, value, (GDestroyNotify) g_variant_unref);\n\n  g_clear_object (&reply);\n  g_object_unref (task);\n}\n\n/* called in any thread, with the connection's lock not held */\nstatic void\ng_dbus_connection_call_internal (GDBusConnection        *connection,\n                                 const gchar            *bus_name,\n                                 const gchar            *object_path,\n                                 const gchar            *interface_name,\n                                 const gchar            *method_name,\n                                 GVariant               *parameters,\n                                 const GVariantType     *reply_type,\n                                 GDBusCallFlags          flags,\n                                 gint                    timeout_msec,\n                                 GUnixFDList            *fd_list,\n                                 GCancellable           *cancellable,\n                                 GAsyncReadyCallback     callback,\n                                 gpointer                user_data)\n{\n  GDBusMessage *message;\n  guint32 serial;\n\n  g_return_if_fail (G_IS_DBUS_CONNECTION (connection));\n  g_return_if_fail (bus_name == NULL || g_dbus_is_name (bus_name));\n  g_return_if_fail (object_path != NULL && g_variant_is_object_path (object_path));\n  g_return_if_fail (interface_name != NULL && g_dbus_is_interface_name (interface_name));\n  g_return_if_fail (method_name != NULL && g_dbus_is_member_name (method_name));\n  g_return_if_fail (timeout_msec >= 0 || timeout_msec == -1);\n  g_return_if_fail ((parameters == NULL) || g_variant_is_of_type (parameters, G_VARIANT_TYPE_TUPLE));\n  g_return_if_fail (check_initialized (connection));\n#ifdef G_OS_UNIX\n  g_return_if_fail (fd_list == NULL || G_IS_UNIX_FD_LIST (fd_list));\n#else\n  g_return_if_fail (fd_list == NULL);\n#endif\n\n  message = g_dbus_message_new_method_call (bus_name,\n                                            object_path,\n                                            interface_name,\n                                            method_name);\n  add_call_flags (message, flags);\n  if (parameters != NULL)\n    g_dbus_message_set_body (message, parameters);\n\n#ifdef G_OS_UNIX\n  if (fd_list != NULL)\n    g_dbus_message_set_unix_fd_list (message, fd_list);\n#endif\n\n  /* If the user has no callback then we can just send the message with\n   * the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set and skip all\n   * the logic for processing the reply.  If the service sends the reply\n   * anyway then it will just be ignored.\n   */\n  if (callback != NULL)\n    {\n      CallState *state;\n      GTask *task;\n\n      state = g_slice_new0 (CallState);\n      state->method_name = g_strjoin (\".\", interface_name, method_name, NULL);\n\n      if (reply_type == NULL)\n        reply_type = G_VARIANT_TYPE_ANY;\n\n      state->reply_type = g_variant_type_copy (reply_type);\n\n      task = g_task_new (connection, cancellable, callback, user_data);\n      g_task_set_source_tag (task, g_dbus_connection_call_internal);\n      g_task_set_task_data (task, state, (GDestroyNotify) call_state_free);\n\n      g_dbus_connection_send_message_with_reply (connection,\n                                                 message,\n                                                 G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                 timeout_msec,\n                                                 &serial,\n                                                 cancellable,\n                                                 g_dbus_connection_call_done,\n                                                 task);\n    }\n  else\n    {\n      GDBusMessageFlags flags;\n\n      flags = g_dbus_message_get_flags (message);\n      flags |= G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED;\n      g_dbus_message_set_flags (message, flags);\n\n      g_dbus_connection_send_message (connection,\n                                      message,\n                                      G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                      &serial, NULL);\n    }\n\n  if (G_UNLIKELY (_g_dbus_debug_call ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Call:\\n\"\n               \" >>>> ASYNC %s.%s()\\n\"\n               \"      on object %s\\n\"\n               \"      owned by name %s (serial %d)\\n\",\n               interface_name,\n               method_name,\n               object_path,\n               bus_name != NULL ? bus_name : \"(none)\",\n               serial);\n      _g_dbus_debug_print_unlock ();\n    }\n\n  if (message != NULL)\n    g_object_unref (message);\n}\n\n/* called in any thread, with the connection's lock not held */\nstatic GVariant *\ng_dbus_connection_call_finish_internal (GDBusConnection  *connection,\n                                        GUnixFDList     **out_fd_list,\n                                        GAsyncResult     *res,\n                                        GError          **error)\n{\n  GTask *task;\n  CallState *state;\n  GVariant *ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  g_return_val_if_fail (g_task_is_valid (res, connection), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  task = G_TASK (res);\n  state = g_task_get_task_data (task);\n\n  ret = g_task_propagate_pointer (task, error);\n  if (!ret)\n    return NULL;\n\n  if (out_fd_list != NULL)\n    *out_fd_list = state->fd_list != NULL ? g_object_ref (state->fd_list) : NULL;\n  return ret;\n}\n\n/* called in any user thread, with the connection's lock not held */\nstatic GVariant *\ng_dbus_connection_call_sync_internal (GDBusConnection         *connection,\n                                      const gchar             *bus_name,\n                                      const gchar             *object_path,\n                                      const gchar             *interface_name,\n                                      const gchar             *method_name,\n                                      GVariant                *parameters,\n                                      const GVariantType      *reply_type,\n                                      GDBusCallFlags           flags,\n                                      gint                     timeout_msec,\n                                      GUnixFDList             *fd_list,\n                                      GUnixFDList            **out_fd_list,\n                                      GCancellable            *cancellable,\n                                      GError                 **error)\n{\n  GDBusMessage *message;\n  GDBusMessage *reply;\n  GVariant *result;\n  GError *local_error;\n  GDBusSendMessageFlags send_flags;\n\n  message = NULL;\n  reply = NULL;\n  result = NULL;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n  g_return_val_if_fail (bus_name == NULL || g_dbus_is_name (bus_name), NULL);\n  g_return_val_if_fail (object_path != NULL && g_variant_is_object_path (object_path), NULL);\n  g_return_val_if_fail (interface_name != NULL && g_dbus_is_interface_name (interface_name), NULL);\n  g_return_val_if_fail (method_name != NULL && g_dbus_is_member_name (method_name), NULL);\n  g_return_val_if_fail (timeout_msec >= 0 || timeout_msec == -1, NULL);\n  g_return_val_if_fail ((parameters == NULL) || g_variant_is_of_type (parameters, G_VARIANT_TYPE_TUPLE), NULL);\n#ifdef G_OS_UNIX\n  g_return_val_if_fail (fd_list == NULL || G_IS_UNIX_FD_LIST (fd_list), NULL);\n#else\n  g_return_val_if_fail (fd_list == NULL, NULL);\n#endif\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  if (!(flags & CALL_FLAGS_INITIALIZING))\n    g_return_val_if_fail (check_initialized (connection), FALSE);\n\n  if (reply_type == NULL)\n    reply_type = G_VARIANT_TYPE_ANY;\n\n  message = g_dbus_message_new_method_call (bus_name,\n                                            object_path,\n                                            interface_name,\n                                            method_name);\n  add_call_flags (message, flags);\n  if (parameters != NULL)\n    g_dbus_message_set_body (message, parameters);\n\n#ifdef G_OS_UNIX\n  if (fd_list != NULL)\n    g_dbus_message_set_unix_fd_list (message, fd_list);\n#endif\n\n  if (G_UNLIKELY (_g_dbus_debug_call ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Call:\\n\"\n               \" >>>> SYNC %s.%s()\\n\"\n               \"      on object %s\\n\"\n               \"      owned by name %s\\n\",\n               interface_name,\n               method_name,\n               object_path,\n               bus_name != NULL ? bus_name : \"(none)\");\n      _g_dbus_debug_print_unlock ();\n    }\n\n  local_error = NULL;\n\n  send_flags = G_DBUS_SEND_MESSAGE_FLAGS_NONE;\n\n  /* translate from one flavour of flags to another... */\n  if (flags & CALL_FLAGS_INITIALIZING)\n    send_flags |= SEND_MESSAGE_FLAGS_INITIALIZING;\n\n  reply = g_dbus_connection_send_message_with_reply_sync (connection,\n                                                          message,\n                                                          send_flags,\n                                                          timeout_msec,\n                                                          NULL, /* volatile guint32 *out_serial */\n                                                          cancellable,\n                                                          &local_error);\n\n  if (G_UNLIKELY (_g_dbus_debug_call ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Call:\\n\"\n               \" <<<< SYNC COMPLETE %s.%s()\\n\"\n               \"      \",\n               interface_name,\n               method_name);\n      if (reply != NULL)\n        {\n          g_print (\"SUCCESS\\n\");\n        }\n      else\n        {\n          g_print (\"FAILED: %s\\n\",\n                   local_error->message);\n        }\n      _g_dbus_debug_print_unlock ();\n    }\n\n  if (reply == NULL)\n    {\n      if (error != NULL)\n        *error = local_error;\n      else\n        g_error_free (local_error);\n      goto out;\n    }\n\n  result = decode_method_reply (reply, method_name, reply_type, out_fd_list, error);\n\n out:\n  if (message != NULL)\n    g_object_unref (message);\n  if (reply != NULL)\n    g_object_unref (reply);\n\n  return result;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_call:\n * @connection: a #GDBusConnection\n * @bus_name: (nullable): a unique or well-known bus name or %NULL if\n *     @connection is not a message bus connection\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to invoke method on\n * @method_name: the name of the method to invoke\n * @parameters: (nullable): a #GVariant tuple with parameters for the method\n *     or %NULL if not passing parameters\n * @reply_type: (nullable): the expected type of the reply (which will be a\n *     tuple), or %NULL\n * @flags: flags from the #GDBusCallFlags enumeration\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the request\n *     is satisfied or %NULL if you don't care about the result of the\n *     method invocation\n * @user_data: the data to pass to @callback\n *\n * Asynchronously invokes the @method_name method on the\n * @interface_name D-Bus interface on the remote object at\n * @object_path owned by @bus_name.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will\n * fail with %G_IO_ERROR_CANCELLED. If @parameters contains a value\n * not compatible with the D-Bus protocol, the operation fails with\n * %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * If @reply_type is non-%NULL then the reply will be checked for having this type and an\n * error will be raised if it does not match.  Said another way, if you give a @reply_type\n * then any non-%NULL return value will be of this type. Unless it\u2019s\n * %G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple containing one or more\n * values.\n *\n * If the @parameters #GVariant is floating, it is consumed. This allows\n * convenient 'inline' use of g_variant_new(), e.g.:\n * |[<!-- language=\"C\" -->\n *  g_dbus_connection_call (connection,\n *                          \"org.freedesktop.StringThings\",\n *                          \"/org/freedesktop/StringThings\",\n *                          \"org.freedesktop.StringThings\",\n *                          \"TwoStrings\",\n *                          g_variant_new (\"(ss)\",\n *                                         \"Thing One\",\n *                                         \"Thing Two\"),\n *                          NULL,\n *                          G_DBUS_CALL_FLAGS_NONE,\n *                          -1,\n *                          NULL,\n *                          (GAsyncReadyCallback) two_strings_done,\n *                          NULL);\n * ]|\n *\n * This is an asynchronous method. When the operation is finished,\n * @callback will be invoked in the\n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from. You can then call\n * g_dbus_connection_call_finish() to get the result of the operation.\n * See g_dbus_connection_call_sync() for the synchronous version of this\n * function.\n *\n * If @callback is %NULL then the D-Bus method call message will be sent with\n * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.\n *\n * Since: 2.26\n */\nvoid\ng_dbus_connection_call (GDBusConnection     *connection,\n                        const gchar         *bus_name,\n                        const gchar         *object_path,\n                        const gchar         *interface_name,\n                        const gchar         *method_name,\n                        GVariant            *parameters,\n                        const GVariantType  *reply_type,\n                        GDBusCallFlags       flags,\n                        gint                 timeout_msec,\n                        GCancellable        *cancellable,\n                        GAsyncReadyCallback  callback,\n                        gpointer             user_data)\n{\n  g_dbus_connection_call_internal (connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, NULL, cancellable, callback, user_data);\n}\n\n/**\n * g_dbus_connection_call_finish:\n * @connection: a #GDBusConnection\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_call()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_call().\n *\n * Returns: %NULL if @error is set. Otherwise a #GVariant tuple with\n *     return values. Free with g_variant_unref().\n *\n * Since: 2.26\n */\nGVariant *\ng_dbus_connection_call_finish (GDBusConnection  *connection,\n                               GAsyncResult     *res,\n                               GError          **error)\n{\n  return g_dbus_connection_call_finish_internal (connection, NULL, res, error);\n}\n\n/**\n * g_dbus_connection_call_sync:\n * @connection: a #GDBusConnection\n * @bus_name: (nullable): a unique or well-known bus name or %NULL if\n *     @connection is not a message bus connection\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to invoke method on\n * @method_name: the name of the method to invoke\n * @parameters: (nullable): a #GVariant tuple with parameters for the method\n *     or %NULL if not passing parameters\n * @reply_type: (nullable): the expected type of the reply, or %NULL\n * @flags: flags from the #GDBusCallFlags enumeration\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously invokes the @method_name method on the\n * @interface_name D-Bus interface on the remote object at\n * @object_path owned by @bus_name.\n *\n * If @connection is closed then the operation will fail with\n * %G_IO_ERROR_CLOSED. If @cancellable is canceled, the\n * operation will fail with %G_IO_ERROR_CANCELLED. If @parameters\n * contains a value not compatible with the D-Bus protocol, the operation\n * fails with %G_IO_ERROR_INVALID_ARGUMENT.\n *\n * If @reply_type is non-%NULL then the reply will be checked for having\n * this type and an error will be raised if it does not match.  Said\n * another way, if you give a @reply_type then any non-%NULL return\n * value will be of this type.\n *\n * If the @parameters #GVariant is floating, it is consumed.\n * This allows convenient 'inline' use of g_variant_new(), e.g.:\n * |[<!-- language=\"C\" -->\n *  g_dbus_connection_call_sync (connection,\n *                               \"org.freedesktop.StringThings\",\n *                               \"/org/freedesktop/StringThings\",\n *                               \"org.freedesktop.StringThings\",\n *                               \"TwoStrings\",\n *                               g_variant_new (\"(ss)\",\n *                                              \"Thing One\",\n *                                              \"Thing Two\"),\n *                               NULL,\n *                               G_DBUS_CALL_FLAGS_NONE,\n *                               -1,\n *                               NULL,\n *                               &error);\n * ]|\n *\n * The calling thread is blocked until a reply is received. See\n * g_dbus_connection_call() for the asynchronous version of\n * this method.\n *\n * Returns: %NULL if @error is set. Otherwise a #GVariant tuple with\n *     return values. Free with g_variant_unref().\n *\n * Since: 2.26\n */\nGVariant *\ng_dbus_connection_call_sync (GDBusConnection     *connection,\n                             const gchar         *bus_name,\n                             const gchar         *object_path,\n                             const gchar         *interface_name,\n                             const gchar         *method_name,\n                             GVariant            *parameters,\n                             const GVariantType  *reply_type,\n                             GDBusCallFlags       flags,\n                             gint                 timeout_msec,\n                             GCancellable        *cancellable,\n                             GError             **error)\n{\n  return g_dbus_connection_call_sync_internal (connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, NULL, NULL, cancellable, error);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n#ifdef G_OS_UNIX\n\n/**\n * g_dbus_connection_call_with_unix_fd_list:\n * @connection: a #GDBusConnection\n * @bus_name: (nullable): a unique or well-known bus name or %NULL if\n *     @connection is not a message bus connection\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to invoke method on\n * @method_name: the name of the method to invoke\n * @parameters: (nullable): a #GVariant tuple with parameters for the method\n *     or %NULL if not passing parameters\n * @reply_type: (nullable): the expected type of the reply, or %NULL\n * @flags: flags from the #GDBusCallFlags enumeration\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @fd_list: (nullable): a #GUnixFDList or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: (nullable): a #GAsyncReadyCallback to call when the request is\n *     satisfied or %NULL if you don't * care about the result of the\n *     method invocation\n * @user_data: The data to pass to @callback.\n *\n * Like g_dbus_connection_call() but also takes a #GUnixFDList object.\n *\n * This method is only available on UNIX.\n *\n * Since: 2.30\n */\nvoid\ng_dbus_connection_call_with_unix_fd_list (GDBusConnection     *connection,\n                                          const gchar         *bus_name,\n                                          const gchar         *object_path,\n                                          const gchar         *interface_name,\n                                          const gchar         *method_name,\n                                          GVariant            *parameters,\n                                          const GVariantType  *reply_type,\n                                          GDBusCallFlags       flags,\n                                          gint                 timeout_msec,\n                                          GUnixFDList         *fd_list,\n                                          GCancellable        *cancellable,\n                                          GAsyncReadyCallback  callback,\n                                          gpointer             user_data)\n{\n  g_dbus_connection_call_internal (connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, cancellable, callback, user_data);\n}\n\n/**\n * g_dbus_connection_call_with_unix_fd_list_finish:\n * @connection: a #GDBusConnection\n * @out_fd_list: (out) (optional): return location for a #GUnixFDList or %NULL\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n *     g_dbus_connection_call_with_unix_fd_list()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_dbus_connection_call_with_unix_fd_list().\n *\n * Returns: %NULL if @error is set. Otherwise a #GVariant tuple with\n *     return values. Free with g_variant_unref().\n *\n * Since: 2.30\n */\nGVariant *\ng_dbus_connection_call_with_unix_fd_list_finish (GDBusConnection  *connection,\n                                                 GUnixFDList     **out_fd_list,\n                                                 GAsyncResult     *res,\n                                                 GError          **error)\n{\n  return g_dbus_connection_call_finish_internal (connection, out_fd_list, res, error);\n}\n\n/**\n * g_dbus_connection_call_with_unix_fd_list_sync:\n * @connection: a #GDBusConnection\n * @bus_name: (nullable): a unique or well-known bus name or %NULL\n *     if @connection is not a message bus connection\n * @object_path: path of remote object\n * @interface_name: D-Bus interface to invoke method on\n * @method_name: the name of the method to invoke\n * @parameters: (nullable): a #GVariant tuple with parameters for\n *     the method or %NULL if not passing parameters\n * @reply_type: (nullable): the expected type of the reply, or %NULL\n * @flags: flags from the #GDBusCallFlags enumeration\n * @timeout_msec: the timeout in milliseconds, -1 to use the default\n *     timeout or %G_MAXINT for no timeout\n * @fd_list: (nullable): a #GUnixFDList or %NULL\n * @out_fd_list: (out) (optional): return location for a #GUnixFDList or %NULL\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Like g_dbus_connection_call_sync() but also takes and returns #GUnixFDList objects.\n *\n * This method is only available on UNIX.\n *\n * Returns: %NULL if @error is set. Otherwise a #GVariant tuple with\n *     return values. Free with g_variant_unref().\n *\n * Since: 2.30\n */\nGVariant *\ng_dbus_connection_call_with_unix_fd_list_sync (GDBusConnection     *connection,\n                                               const gchar         *bus_name,\n                                               const gchar         *object_path,\n                                               const gchar         *interface_name,\n                                               const gchar         *method_name,\n                                               GVariant            *parameters,\n                                               const GVariantType  *reply_type,\n                                               GDBusCallFlags       flags,\n                                               gint                 timeout_msec,\n                                               GUnixFDList         *fd_list,\n                                               GUnixFDList        **out_fd_list,\n                                               GCancellable        *cancellable,\n                                               GError             **error)\n{\n  return g_dbus_connection_call_sync_internal (connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, out_fd_list, cancellable, error);\n}\n\n#endif /* G_OS_UNIX */\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nstruct ExportedSubtree\n{\n  guint                     id;\n  gchar                    *object_path;\n  GDBusConnection          *connection;\n  GDBusSubtreeVTable       *vtable;\n  GDBusSubtreeFlags         flags;\n\n  GMainContext             *context;\n  gpointer                  user_data;\n  GDestroyNotify            user_data_free_func;\n};\n\nstatic void\nexported_subtree_free (ExportedSubtree *es)\n{\n  call_destroy_notify (es->context,\n                       es->user_data_free_func,\n                       es->user_data);\n\n  g_main_context_unref (es->context);\n\n  _g_dbus_subtree_vtable_free (es->vtable);\n  g_free (es->object_path);\n  g_free (es);\n}\n\n/* called without lock held in the thread where the caller registered\n * the subtree\n */\nstatic gboolean\nhandle_subtree_introspect (GDBusConnection *connection,\n                           ExportedSubtree *es,\n                           GDBusMessage    *message)\n{\n  GString *s;\n  gboolean handled;\n  GDBusMessage *reply;\n  gchar **children;\n  gboolean is_root;\n  const gchar *sender;\n  const gchar *requested_object_path;\n  const gchar *requested_node;\n  GDBusInterfaceInfo **interfaces;\n  guint n;\n  gchar **subnode_paths;\n  gboolean has_properties_interface;\n  gboolean has_introspectable_interface;\n\n  handled = FALSE;\n\n  requested_object_path = g_dbus_message_get_path (message);\n  sender = g_dbus_message_get_sender (message);\n  is_root = (g_strcmp0 (requested_object_path, es->object_path) == 0);\n\n  s = g_string_new (NULL);\n  introspect_append_header (s);\n\n  /* Strictly we don't need the children in dynamic mode, but we avoid the\n   * conditionals to preserve code clarity\n   */\n  children = es->vtable->enumerate (es->connection,\n                                    sender,\n                                    es->object_path,\n                                    es->user_data);\n\n  if (!is_root)\n    {\n      requested_node = strrchr (requested_object_path, '/') + 1;\n\n      /* Assert existence of object if we are not dynamic */\n      if (!(es->flags & G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES) &&\n          !_g_strv_has_string ((const gchar * const *) children, requested_node))\n        goto out;\n    }\n  else\n    {\n      requested_node = NULL;\n    }\n\n  interfaces = es->vtable->introspect (es->connection,\n                                       sender,\n                                       es->object_path,\n                                       requested_node,\n                                       es->user_data);\n  if (interfaces != NULL)\n    {\n      has_properties_interface = FALSE;\n      has_introspectable_interface = FALSE;\n\n      for (n = 0; interfaces[n] != NULL; n++)\n        {\n          if (strcmp (interfaces[n]->name, \"org.freedesktop.DBus.Properties\") == 0)\n            has_properties_interface = TRUE;\n          else if (strcmp (interfaces[n]->name, \"org.freedesktop.DBus.Introspectable\") == 0)\n            has_introspectable_interface = TRUE;\n        }\n      if (!has_properties_interface)\n        g_string_append (s, introspect_properties_interface);\n      if (!has_introspectable_interface)\n        g_string_append (s, introspect_introspectable_interface);\n\n      for (n = 0; interfaces[n] != NULL; n++)\n        {\n          g_dbus_interface_info_generate_xml (interfaces[n], 2, s);\n          g_dbus_interface_info_unref (interfaces[n]);\n        }\n      g_free (interfaces);\n    }\n\n  /* then include <node> entries from the Subtree for the root */\n  if (is_root)\n    {\n      for (n = 0; children != NULL && children[n] != NULL; n++)\n        g_string_append_printf (s, \"  <node name=\\\"%s\\\"/>\\n\", children[n]);\n    }\n\n  /* finally include nodes registered below us */\n  subnode_paths = g_dbus_connection_list_registered (es->connection, requested_object_path);\n  for (n = 0; subnode_paths != NULL && subnode_paths[n] != NULL; n++)\n    g_string_append_printf (s, \"  <node name=\\\"%s\\\"/>\\n\", subnode_paths[n]);\n  g_strfreev (subnode_paths);\n\n  g_string_append (s, \"</node>\\n\");\n\n  reply = g_dbus_message_new_method_reply (message);\n  g_dbus_message_set_body (reply, g_variant_new (\"(s)\", s->str));\n  g_dbus_connection_send_message (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n\n  handled = TRUE;\n\n out:\n  g_string_free (s, TRUE);\n  g_strfreev (children);\n  return handled;\n}\n\n/* called without lock held in the thread where the caller registered\n * the subtree\n */\nstatic gboolean\nhandle_subtree_method_invocation (GDBusConnection *connection,\n                                  ExportedSubtree *es,\n                                  GDBusMessage    *message)\n{\n  gboolean handled;\n  const gchar *sender;\n  const gchar *interface_name;\n  const gchar *member;\n  const gchar *signature;\n  const gchar *requested_object_path;\n  const gchar *requested_node;\n  gboolean is_root;\n  GDBusInterfaceInfo *interface_info;\n  const GDBusInterfaceVTable *interface_vtable;\n  gpointer interface_user_data;\n  guint n;\n  GDBusInterfaceInfo **interfaces;\n  gboolean is_property_get;\n  gboolean is_property_set;\n  gboolean is_property_get_all;\n\n  handled = FALSE;\n  interfaces = NULL;\n\n  requested_object_path = g_dbus_message_get_path (message);\n  sender = g_dbus_message_get_sender (message);\n  interface_name = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  signature = g_dbus_message_get_signature (message);\n  is_root = (g_strcmp0 (requested_object_path, es->object_path) == 0);\n\n  is_property_get = FALSE;\n  is_property_set = FALSE;\n  is_property_get_all = FALSE;\n  if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Properties\") == 0)\n    {\n      if (g_strcmp0 (member, \"Get\") == 0 && g_strcmp0 (signature, \"ss\") == 0)\n        is_property_get = TRUE;\n      else if (g_strcmp0 (member, \"Set\") == 0 && g_strcmp0 (signature, \"ssv\") == 0)\n        is_property_set = TRUE;\n      else if (g_strcmp0 (member, \"GetAll\") == 0 && g_strcmp0 (signature, \"s\") == 0)\n        is_property_get_all = TRUE;\n    }\n\n  if (!is_root)\n    {\n      requested_node = strrchr (requested_object_path, '/') + 1;\n\n      if (~es->flags & G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES)\n        {\n          /* We don't want to dispatch to unenumerated\n           * nodes, so ensure that the child exists.\n           */\n          gchar **children;\n          gboolean exists;\n\n          children = es->vtable->enumerate (es->connection,\n                                            sender,\n                                            es->object_path,\n                                            es->user_data);\n\n          exists = _g_strv_has_string ((const gchar * const *) children, requested_node);\n          g_strfreev (children);\n\n          if (!exists)\n            goto out;\n        }\n    }\n  else\n    {\n      requested_node = NULL;\n    }\n\n  /* get introspection data for the node */\n  interfaces = es->vtable->introspect (es->connection,\n                                       sender,\n                                       requested_object_path,\n                                       requested_node,\n                                       es->user_data);\n\n  if (interfaces == NULL)\n    goto out;\n\n  interface_info = NULL;\n  for (n = 0; interfaces[n] != NULL; n++)\n    {\n      if (g_strcmp0 (interfaces[n]->name, interface_name) == 0)\n        interface_info = interfaces[n];\n    }\n\n  /* dispatch the call if the user wants to handle it */\n  if (interface_info != NULL)\n    {\n      /* figure out where to dispatch the method call */\n      interface_user_data = NULL;\n      interface_vtable = es->vtable->dispatch (es->connection,\n                                               sender,\n                                               es->object_path,\n                                               interface_name,\n                                               requested_node,\n                                               &interface_user_data,\n                                               es->user_data);\n      if (interface_vtable == NULL)\n        goto out;\n\n      CONNECTION_LOCK (connection);\n      handled = validate_and_maybe_schedule_method_call (es->connection,\n                                                         message,\n                                                         0,\n                                                         es->id,\n                                                         interface_info,\n                                                         interface_vtable,\n                                                         es->context,\n                                                         interface_user_data);\n      CONNECTION_UNLOCK (connection);\n    }\n  /* handle org.freedesktop.DBus.Properties interface if not explicitly handled */\n  else if (is_property_get || is_property_set || is_property_get_all)\n    {\n      if (is_property_get)\n        g_variant_get (g_dbus_message_get_body (message), \"(&s&s)\", &interface_name, NULL);\n      else if (is_property_set)\n        g_variant_get (g_dbus_message_get_body (message), \"(&s&sv)\", &interface_name, NULL, NULL);\n      else if (is_property_get_all)\n        g_variant_get (g_dbus_message_get_body (message), \"(&s)\", &interface_name, NULL, NULL);\n      else\n        g_assert_not_reached ();\n\n      /* see if the object supports this interface at all */\n      for (n = 0; interfaces[n] != NULL; n++)\n        {\n          if (g_strcmp0 (interfaces[n]->name, interface_name) == 0)\n            interface_info = interfaces[n];\n        }\n\n      /* Fail with org.freedesktop.DBus.Error.InvalidArgs if the user-code\n       * claims it won't support the interface\n       */\n      if (interface_info == NULL)\n        {\n          GDBusMessage *reply;\n          reply = g_dbus_message_new_method_error (message,\n                                                   \"org.freedesktop.DBus.Error.InvalidArgs\",\n                                                   _(\"No such interface \u201c%s\u201d\"),\n                                                   interface_name);\n          g_dbus_connection_send_message (es->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n          g_object_unref (reply);\n          handled = TRUE;\n          goto out;\n        }\n\n      /* figure out where to dispatch the property get/set/getall calls */\n      interface_user_data = NULL;\n      interface_vtable = es->vtable->dispatch (es->connection,\n                                               sender,\n                                               es->object_path,\n                                               interface_name,\n                                               requested_node,\n                                               &interface_user_data,\n                                               es->user_data);\n      if (interface_vtable == NULL)\n        {\n          g_warning (\"The subtree introspection function indicates that '%s' \"\n                     \"is a valid interface name, but calling the dispatch \"\n                     \"function on that interface gave us NULL\", interface_name);\n          goto out;\n        }\n\n      if (is_property_get || is_property_set)\n        {\n          CONNECTION_LOCK (connection);\n          handled = validate_and_maybe_schedule_property_getset (es->connection,\n                                                                 message,\n                                                                 0,\n                                                                 es->id,\n                                                                 is_property_get,\n                                                                 interface_info,\n                                                                 interface_vtable,\n                                                                 es->context,\n                                                                 interface_user_data);\n          CONNECTION_UNLOCK (connection);\n        }\n      else if (is_property_get_all)\n        {\n          CONNECTION_LOCK (connection);\n          handled = validate_and_maybe_schedule_property_get_all (es->connection,\n                                                                  message,\n                                                                  0,\n                                                                  es->id,\n                                                                  interface_info,\n                                                                  interface_vtable,\n                                                                  es->context,\n                                                                  interface_user_data);\n          CONNECTION_UNLOCK (connection);\n        }\n    }\n\n out:\n  if (interfaces != NULL)\n    {\n      for (n = 0; interfaces[n] != NULL; n++)\n        g_dbus_interface_info_unref (interfaces[n]);\n      g_free (interfaces);\n    }\n\n  return handled;\n}\n\ntypedef struct\n{\n  GDBusMessage *message;\n  ExportedSubtree *es;\n} SubtreeDeferredData;\n\nstatic void\nsubtree_deferred_data_free (SubtreeDeferredData *data)\n{\n  g_object_unref (data->message);\n  g_free (data);\n}\n\n/* called without lock held in the thread where the caller registered the subtree */\nstatic gboolean\nprocess_subtree_vtable_message_in_idle_cb (gpointer _data)\n{\n  SubtreeDeferredData *data = _data;\n  gboolean handled;\n\n  handled = FALSE;\n\n  if (g_strcmp0 (g_dbus_message_get_interface (data->message), \"org.freedesktop.DBus.Introspectable\") == 0 &&\n      g_strcmp0 (g_dbus_message_get_member (data->message), \"Introspect\") == 0 &&\n      g_strcmp0 (g_dbus_message_get_signature (data->message), \"\") == 0)\n    handled = handle_subtree_introspect (data->es->connection,\n                                         data->es,\n                                         data->message);\n  else\n    handled = handle_subtree_method_invocation (data->es->connection,\n                                                data->es,\n                                                data->message);\n\n  if (!handled)\n    {\n      CONNECTION_LOCK (data->es->connection);\n      handled = handle_generic_unlocked (data->es->connection, data->message);\n      CONNECTION_UNLOCK (data->es->connection);\n    }\n\n  /* if we couldn't handle the request, just bail with the UnknownMethod error */\n  if (!handled)\n    {\n      GDBusMessage *reply;\n      reply = g_dbus_message_new_method_error (data->message,\n                                               \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                               _(\"Method \u201c%s\u201d on interface \u201c%s\u201d with signature \u201c%s\u201d does not exist\"),\n                                               g_dbus_message_get_member (data->message),\n                                               g_dbus_message_get_interface (data->message),\n                                               g_dbus_message_get_signature (data->message));\n      g_dbus_connection_send_message (data->es->connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n      g_object_unref (reply);\n    }\n\n  return FALSE;\n}\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic gboolean\nsubtree_message_func (GDBusConnection *connection,\n                      ExportedSubtree *es,\n                      GDBusMessage    *message)\n{\n  GSource *idle_source;\n  SubtreeDeferredData *data;\n\n  data = g_new0 (SubtreeDeferredData, 1);\n  data->message = g_object_ref (message);\n  data->es = es;\n\n  /* defer this call to an idle handler in the right thread */\n  idle_source = g_idle_source_new ();\n  g_source_set_priority (idle_source, G_PRIORITY_HIGH);\n  g_source_set_callback (idle_source,\n                         process_subtree_vtable_message_in_idle_cb,\n                         data,\n                         (GDestroyNotify) subtree_deferred_data_free);\n  g_source_set_name (idle_source, \"[gio] process_subtree_vtable_message_in_idle_cb\");\n  g_source_attach (idle_source, es->context);\n  g_source_unref (idle_source);\n\n  /* since we own the entire subtree, handlers for objects not in the subtree have been\n   * tried already by libdbus-1 - so we just need to ensure that we're always going\n   * to reply to the message\n   */\n  return TRUE;\n}\n\n/**\n * g_dbus_connection_register_subtree:\n * @connection: a #GDBusConnection\n * @object_path: the object path to register the subtree at\n * @vtable: a #GDBusSubtreeVTable to enumerate, introspect and\n *     dispatch nodes in the subtree\n * @flags: flags used to fine tune the behavior of the subtree\n * @user_data: data to pass to functions in @vtable\n * @user_data_free_func: function to call when the subtree is unregistered\n * @error: return location for error or %NULL\n *\n * Registers a whole subtree of dynamic objects.\n *\n * The @enumerate and @introspection functions in @vtable are used to\n * convey, to remote callers, what nodes exist in the subtree rooted\n * by @object_path.\n *\n * When handling remote calls into any node in the subtree, first the\n * @enumerate function is used to check if the node exists. If the node exists\n * or the #G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set\n * the @introspection function is used to check if the node supports the\n * requested method. If so, the @dispatch function is used to determine\n * where to dispatch the call. The collected #GDBusInterfaceVTable and\n * #gpointer will be used to call into the interface vtable for processing\n * the request.\n *\n * All calls into user-provided code will be invoked in the\n * [thread-default main context][g-main-context-push-thread-default]\n * of the thread you are calling this method from.\n *\n * If an existing subtree is already registered at @object_path or\n * then @error is set to #G_IO_ERROR_EXISTS.\n *\n * Note that it is valid to register regular objects (using\n * g_dbus_connection_register_object()) in a subtree registered with\n * g_dbus_connection_register_subtree() - if so, the subtree handler\n * is tried as the last resort. One way to think about a subtree\n * handler is to consider it a fallback handler for object paths not\n * registered via g_dbus_connection_register_object() or other bindings.\n *\n * Note that @vtable will be copied so you cannot change it after\n * registration.\n *\n * See this [server][gdbus-subtree-server] for an example of how to use\n * this method.\n *\n * Returns: 0 if @error is set, otherwise a subtree registration id (never 0)\n * that can be used with g_dbus_connection_unregister_subtree() .\n *\n * Since: 2.26\n */\nguint\ng_dbus_connection_register_subtree (GDBusConnection           *connection,\n                                    const gchar               *object_path,\n                                    const GDBusSubtreeVTable  *vtable,\n                                    GDBusSubtreeFlags          flags,\n                                    gpointer                   user_data,\n                                    GDestroyNotify             user_data_free_func,\n                                    GError                   **error)\n{\n  guint ret;\n  ExportedSubtree *es;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), 0);\n  g_return_val_if_fail (object_path != NULL && g_variant_is_object_path (object_path), 0);\n  g_return_val_if_fail (vtable != NULL, 0);\n  g_return_val_if_fail (error == NULL || *error == NULL, 0);\n  g_return_val_if_fail (check_initialized (connection), 0);\n\n  ret = 0;\n\n  CONNECTION_LOCK (connection);\n\n  es = g_hash_table_lookup (connection->map_object_path_to_es, object_path);\n  if (es != NULL)\n    {\n      g_set_error (error,\n                   G_IO_ERROR,\n                   G_IO_ERROR_EXISTS,\n                   _(\"A subtree is already exported for %s\"),\n                   object_path);\n      goto out;\n    }\n\n  es = g_new0 (ExportedSubtree, 1);\n  es->object_path = g_strdup (object_path);\n  es->connection = connection;\n\n  es->vtable = _g_dbus_subtree_vtable_copy (vtable);\n  es->flags = flags;\n  es->id = g_atomic_int_add (&_global_subtree_registration_id, 1); /* TODO: overflow etc. */\n  es->user_data = user_data;\n  es->user_data_free_func = user_data_free_func;\n  es->context = g_main_context_ref_thread_default ();\n\n  g_hash_table_insert (connection->map_object_path_to_es, es->object_path, es);\n  g_hash_table_insert (connection->map_id_to_es,\n                       GUINT_TO_POINTER (es->id),\n                       es);\n\n  ret = es->id;\n\n out:\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/**\n * g_dbus_connection_unregister_subtree:\n * @connection: a #GDBusConnection\n * @registration_id: a subtree registration id obtained from\n *     g_dbus_connection_register_subtree()\n *\n * Unregisters a subtree.\n *\n * Returns: %TRUE if the subtree was unregistered, %FALSE otherwise\n *\n * Since: 2.26\n */\ngboolean\ng_dbus_connection_unregister_subtree (GDBusConnection *connection,\n                                      guint            registration_id)\n{\n  ExportedSubtree *es;\n  gboolean ret;\n\n  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), FALSE);\n  g_return_val_if_fail (check_initialized (connection), FALSE);\n\n  ret = FALSE;\n\n  CONNECTION_LOCK (connection);\n\n  es = g_hash_table_lookup (connection->map_id_to_es,\n                            GUINT_TO_POINTER (registration_id));\n  if (es == NULL)\n    goto out;\n\n  g_warn_if_fail (g_hash_table_remove (connection->map_id_to_es, GUINT_TO_POINTER (es->id)));\n  g_warn_if_fail (g_hash_table_remove (connection->map_object_path_to_es, es->object_path));\n\n  ret = TRUE;\n\n out:\n  CONNECTION_UNLOCK (connection);\n\n  return ret;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* may be called in any thread, with connection's lock held */\nstatic void\nhandle_generic_ping_unlocked (GDBusConnection *connection,\n                              const gchar     *object_path,\n                              GDBusMessage    *message)\n{\n  GDBusMessage *reply;\n  reply = g_dbus_message_new_method_reply (message);\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n}\n\n/* may be called in any thread, with connection's lock held */\nstatic void\nhandle_generic_get_machine_id_unlocked (GDBusConnection *connection,\n                                        const gchar     *object_path,\n                                        GDBusMessage    *message)\n{\n  GDBusMessage *reply;\n\n  reply = NULL;\n  if (connection->machine_id == NULL)\n    {\n      GError *error;\n\n      error = NULL;\n      connection->machine_id = _g_dbus_get_machine_id (&error);\n      if (connection->machine_id == NULL)\n        {\n          reply = g_dbus_message_new_method_error_literal (message,\n                                                           \"org.freedesktop.DBus.Error.Failed\",\n                                                           error->message);\n          g_error_free (error);\n        }\n    }\n\n  if (reply == NULL)\n    {\n      reply = g_dbus_message_new_method_reply (message);\n      g_dbus_message_set_body (reply, g_variant_new (\"(s)\", connection->machine_id));\n    }\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n}\n\n/* may be called in any thread, with connection's lock held */\nstatic void\nhandle_generic_introspect_unlocked (GDBusConnection *connection,\n                                    const gchar     *object_path,\n                                    GDBusMessage    *message)\n{\n  guint n;\n  GString *s;\n  gchar **registered;\n  GDBusMessage *reply;\n\n  /* first the header */\n  s = g_string_new (NULL);\n  introspect_append_header (s);\n\n  registered = g_dbus_connection_list_registered_unlocked (connection, object_path);\n  for (n = 0; registered != NULL && registered[n] != NULL; n++)\n      g_string_append_printf (s, \"  <node name=\\\"%s\\\"/>\\n\", registered[n]);\n  g_strfreev (registered);\n  g_string_append (s, \"</node>\\n\");\n\n  reply = g_dbus_message_new_method_reply (message);\n  g_dbus_message_set_body (reply, g_variant_new (\"(s)\", s->str));\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n  g_string_free (s, TRUE);\n}\n\n/* may be called in any thread, with connection's lock held */\nstatic gboolean\nhandle_generic_unlocked (GDBusConnection *connection,\n                         GDBusMessage    *message)\n{\n  gboolean handled;\n  const gchar *interface_name;\n  const gchar *member;\n  const gchar *signature;\n  const gchar *path;\n\n  CONNECTION_ENSURE_LOCK (connection);\n\n  handled = FALSE;\n\n  interface_name = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  signature = g_dbus_message_get_signature (message);\n  path = g_dbus_message_get_path (message);\n\n  if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Introspectable\") == 0 &&\n      g_strcmp0 (member, \"Introspect\") == 0 &&\n      g_strcmp0 (signature, \"\") == 0)\n    {\n      handle_generic_introspect_unlocked (connection, path, message);\n      handled = TRUE;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Peer\") == 0 &&\n           g_strcmp0 (member, \"Ping\") == 0 &&\n           g_strcmp0 (signature, \"\") == 0)\n    {\n      handle_generic_ping_unlocked (connection, path, message);\n      handled = TRUE;\n    }\n  else if (g_strcmp0 (interface_name, \"org.freedesktop.DBus.Peer\") == 0 &&\n           g_strcmp0 (member, \"GetMachineId\") == 0 &&\n           g_strcmp0 (signature, \"\") == 0)\n    {\n      handle_generic_get_machine_id_unlocked (connection, path, message);\n      handled = TRUE;\n    }\n\n  return handled;\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* called in GDBusWorker thread with connection's lock held */\nstatic void\ndistribute_method_call (GDBusConnection *connection,\n                        GDBusMessage    *message)\n{\n  GDBusMessage *reply;\n  ExportedObject *eo;\n  ExportedSubtree *es;\n  const gchar *object_path;\n  const gchar *interface_name;\n  const gchar *member;\n  const gchar *path;\n  gchar *subtree_path;\n  gchar *needle;\n\n  g_assert (g_dbus_message_get_message_type (message) == G_DBUS_MESSAGE_TYPE_METHOD_CALL);\n\n  interface_name = g_dbus_message_get_interface (message);\n  member = g_dbus_message_get_member (message);\n  path = g_dbus_message_get_path (message);\n  subtree_path = g_strdup (path);\n  needle = strrchr (subtree_path, '/');\n  if (needle != NULL && needle != subtree_path)\n    {\n      *needle = '\\0';\n    }\n  else\n    {\n      g_free (subtree_path);\n      subtree_path = NULL;\n    }\n\n\n  if (G_UNLIKELY (_g_dbus_debug_incoming ()))\n    {\n      _g_dbus_debug_print_lock ();\n      g_print (\"========================================================================\\n\"\n               \"GDBus-debug:Incoming:\\n\"\n               \" <<<< METHOD INVOCATION %s.%s()\\n\"\n               \"      on object %s\\n\"\n               \"      invoked by name %s\\n\"\n               \"      serial %d\\n\",\n               interface_name, member,\n               path,\n               g_dbus_message_get_sender (message) != NULL ? g_dbus_message_get_sender (message) : \"(none)\",\n               g_dbus_message_get_serial (message));\n      _g_dbus_debug_print_unlock ();\n    }\n\n  object_path = g_dbus_message_get_path (message);\n  g_assert (object_path != NULL);\n\n  eo = g_hash_table_lookup (connection->map_object_path_to_eo, object_path);\n  if (eo != NULL)\n    {\n      if (obj_message_func (connection, eo, message))\n        goto out;\n    }\n\n  es = g_hash_table_lookup (connection->map_object_path_to_es, object_path);\n  if (es != NULL)\n    {\n      if (subtree_message_func (connection, es, message))\n        goto out;\n    }\n\n  if (subtree_path != NULL)\n    {\n      es = g_hash_table_lookup (connection->map_object_path_to_es, subtree_path);\n      if (es != NULL)\n        {\n          if (subtree_message_func (connection, es, message))\n            goto out;\n        }\n    }\n\n  if (handle_generic_unlocked (connection, message))\n    goto out;\n\n  /* if we end up here, the message has not been not handled - so return an error saying this */\n  reply = g_dbus_message_new_method_error (message,\n                                           \"org.freedesktop.DBus.Error.UnknownMethod\",\n                                           _(\"No such interface \u201c%s\u201d on object at path %s\"),\n                                           interface_name,\n                                           object_path);\n  g_dbus_connection_send_message_unlocked (connection, reply, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);\n  g_object_unref (reply);\n\n out:\n  g_free (subtree_path);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* Called in any user thread, with the message_bus_lock held. */\nstatic GWeakRef *\nmessage_bus_get_singleton (GBusType   bus_type,\n                           GError   **error)\n{\n  GWeakRef *ret;\n  const gchar *starter_bus;\n\n  ret = NULL;\n\n  switch (bus_type)\n    {\n    case G_BUS_TYPE_SESSION:\n      ret = &the_session_bus;\n      break;\n\n    case G_BUS_TYPE_SYSTEM:\n      ret = &the_system_bus;\n      break;\n\n    case G_BUS_TYPE_STARTER:\n      starter_bus = g_getenv (\"DBUS_STARTER_BUS_TYPE\");\n      if (g_strcmp0 (starter_bus, \"session\") == 0)\n        {\n          ret = message_bus_get_singleton (G_BUS_TYPE_SESSION, error);\n          goto out;\n        }\n      else if (g_strcmp0 (starter_bus, \"system\") == 0)\n        {\n          ret = message_bus_get_singleton (G_BUS_TYPE_SYSTEM, error);\n          goto out;\n        }\n      else\n        {\n          if (starter_bus != NULL)\n            {\n              g_set_error (error,\n                           G_IO_ERROR,\n                           G_IO_ERROR_INVALID_ARGUMENT,\n                           _(\"Cannot determine bus address from DBUS_STARTER_BUS_TYPE environment variable\"\n                             \" \u2014 unknown value \u201c%s\u201d\"),\n                           starter_bus);\n            }\n          else\n            {\n              g_set_error_literal (error,\n                                   G_IO_ERROR,\n                                   G_IO_ERROR_INVALID_ARGUMENT,\n                                   _(\"Cannot determine bus address because the DBUS_STARTER_BUS_TYPE environment \"\n                                     \"variable is not set\"));\n            }\n        }\n      break;\n\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n out:\n  return ret;\n}\n\n/* Called in any user thread, without holding locks. */\nstatic GDBusConnection *\nget_uninitialized_connection (GBusType       bus_type,\n                              GCancellable  *cancellable,\n                              GError       **error)\n{\n  GWeakRef *singleton;\n  GDBusConnection *ret;\n\n  ret = NULL;\n\n  G_LOCK (message_bus_lock);\n  singleton = message_bus_get_singleton (bus_type, error);\n  if (singleton == NULL)\n    goto out;\n\n  ret = g_weak_ref_get (singleton);\n\n  if (ret == NULL)\n    {\n      gchar *address;\n      address = g_dbus_address_get_for_bus_sync (bus_type, cancellable, error);\n      if (address == NULL)\n        goto out;\n      ret = g_object_new (G_TYPE_DBUS_CONNECTION,\n                          \"address\", address,\n                          \"flags\", G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT |\n                                   G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,\n                          \"exit-on-close\", TRUE,\n                          NULL);\n\n      g_weak_ref_set (singleton, ret);\n      g_free (address);\n    }\n\n  g_assert (ret != NULL);\n\n out:\n  G_UNLOCK (message_bus_lock);\n  return ret;\n}\n\n/* May be called from any thread. Must not hold message_bus_lock. */\nGDBusConnection *\n_g_bus_get_singleton_if_exists (GBusType bus_type)\n{\n  GWeakRef *singleton;\n  GDBusConnection *ret = NULL;\n\n  G_LOCK (message_bus_lock);\n  singleton = message_bus_get_singleton (bus_type, NULL);\n  if (singleton == NULL)\n    goto out;\n\n  ret = g_weak_ref_get (singleton);\n\n out:\n  G_UNLOCK (message_bus_lock);\n  return ret;\n}\n\n/* May be called from any thread. Must not hold message_bus_lock. */\nvoid\n_g_bus_forget_singleton (GBusType bus_type)\n{\n  GWeakRef *singleton;\n\n  G_LOCK (message_bus_lock);\n\n  singleton = message_bus_get_singleton (bus_type, NULL);\n\n  if (singleton != NULL)\n    g_weak_ref_set (singleton, NULL);\n\n  G_UNLOCK (message_bus_lock);\n}\n\n/**\n * g_bus_get_sync:\n * @bus_type: a #GBusType\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @error: return location for error or %NULL\n *\n * Synchronously connects to the message bus specified by @bus_type.\n * Note that the returned object may shared with other callers,\n * e.g. if two separate parts of a process calls this function with\n * the same @bus_type, they will share the same object.\n *\n * This is a synchronous failable function. See g_bus_get() and\n * g_bus_get_finish() for the asynchronous version.\n *\n * The returned object is a singleton, that is, shared with other\n * callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the\n * event that you need a private message bus connection, use\n * g_dbus_address_get_for_bus_sync() and\n * g_dbus_connection_new_for_address().\n *\n * Note that the returned #GDBusConnection object will (usually) have\n * the #GDBusConnection:exit-on-close property set to %TRUE.\n *\n * Returns: (transfer full): a #GDBusConnection or %NULL if @error is set.\n *     Free with g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_bus_get_sync (GBusType       bus_type,\n                GCancellable  *cancellable,\n                GError       **error)\n{\n  GDBusConnection *connection;\n\n  _g_dbus_initialize ();\n\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  connection = get_uninitialized_connection (bus_type, cancellable, error);\n  if (connection == NULL)\n    goto out;\n\n  if (!g_initable_init (G_INITABLE (connection), cancellable, error))\n    {\n      g_object_unref (connection);\n      connection = NULL;\n    }\n\n out:\n  return connection;\n}\n\nstatic void\nbus_get_async_initable_cb (GObject      *source_object,\n                           GAsyncResult *res,\n                           gpointer      user_data)\n{\n  GTask *task = user_data;\n  GError *error = NULL;\n\n  if (!g_async_initable_init_finish (G_ASYNC_INITABLE (source_object),\n                                     res,\n                                     &error))\n    {\n      g_assert (error != NULL);\n      g_task_return_error (task, error);\n      g_object_unref (source_object);\n    }\n  else\n    {\n      g_task_return_pointer (task, source_object, g_object_unref);\n    }\n  g_object_unref (task);\n}\n\n/**\n * g_bus_get:\n * @bus_type: a #GBusType\n * @cancellable: (nullable): a #GCancellable or %NULL\n * @callback: a #GAsyncReadyCallback to call when the request is satisfied\n * @user_data: the data to pass to @callback\n *\n * Asynchronously connects to the message bus specified by @bus_type.\n *\n * When the operation is finished, @callback will be invoked. You can\n * then call g_bus_get_finish() to get the result of the operation.\n *\n * This is a asynchronous failable function. See g_bus_get_sync() for\n * the synchronous version.\n *\n * Since: 2.26\n */\nvoid\ng_bus_get (GBusType             bus_type,\n           GCancellable        *cancellable,\n           GAsyncReadyCallback  callback,\n           gpointer             user_data)\n{\n  GDBusConnection *connection;\n  GTask *task;\n  GError *error = NULL;\n\n  _g_dbus_initialize ();\n\n  task = g_task_new (NULL, cancellable, callback, user_data);\n  g_task_set_source_tag (task, g_bus_get);\n\n  connection = get_uninitialized_connection (bus_type, cancellable, &error);\n  if (connection == NULL)\n    {\n      g_assert (error != NULL);\n      g_task_return_error (task, error);\n      g_object_unref (task);\n    }\n  else\n    {\n      g_async_initable_init_async (G_ASYNC_INITABLE (connection),\n                                   G_PRIORITY_DEFAULT,\n                                   cancellable,\n                                   bus_get_async_initable_cb,\n                                   task);\n    }\n}\n\n/**\n * g_bus_get_finish:\n * @res: a #GAsyncResult obtained from the #GAsyncReadyCallback passed\n *     to g_bus_get()\n * @error: return location for error or %NULL\n *\n * Finishes an operation started with g_bus_get().\n *\n * The returned object is a singleton, that is, shared with other\n * callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the\n * event that you need a private message bus connection, use\n * g_dbus_address_get_for_bus_sync() and\n * g_dbus_connection_new_for_address().\n *\n * Note that the returned #GDBusConnection object will (usually) have\n * the #GDBusConnection:exit-on-close property set to %TRUE.\n *\n * Returns: (transfer full): a #GDBusConnection or %NULL if @error is set.\n *     Free with g_object_unref().\n *\n * Since: 2.26\n */\nGDBusConnection *\ng_bus_get_finish (GAsyncResult  *res,\n                  GError       **error)\n{\n  g_return_val_if_fail (g_task_is_valid (res, NULL), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  return g_task_propagate_pointer (G_TASK (res), error);\n}\n\n/* ---------------------------------------------------------------------------------------------------- */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/ChangeLog.pre-2-0",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/tests/utf8.txt",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/glib/tests/markups/fail-41.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/glib/tests/markups/fail-3.expected",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/glib/tests/markups/fail-2.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/glib/tests/markups/fail-52.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/glib/tests/markups/fail-41.expected",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/glib/tests/markups/fail-50.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/glib/tests/markups/fail-3.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/glib/tests/markups/fail-53.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/empty-key.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/bad-header.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/uri-mismatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/huge-chunk-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/valid-no-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/no-text-data.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/header-only.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/mtime-zero.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/valid.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/header-and-chunk-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/gio/tests/thumbnails/overlong-value.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/docs/reference/glib/mainloop-states.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/docs/reference/glib/mainloop-states.gif",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/docs/reference/glib/file-name-encodings.sxd",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/docs/reference/glib/file-name-encodings.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/docs/reference/gio/menu-model.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/docs/reference/gio/menu-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/docs/reference/gio/gvfs-overview.odg",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/docs/reference/gio/gvfs-overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.58.3-6dur3us76cyy4fasbozj73rxq4q5bzl7/spack-src/docs/reference/gobject/images/glue.png"
    ],
    "total_files": 1882
}