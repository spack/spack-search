{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/specs/sl6/dcap-fedora.spec": "Name:\t\tdcap\nVersion:\t2.47.10\nRelease:\t2%{?dist}\nSummary:\tClient Tools for dCache\n\nGroup:\t\tApplications/Internet\n#\t\tplugins/gssapi/{base64.[ch],gssIoTunnel.c,util.c} - BSD license\n#\t\tthe rest - LGPLv2+ license\nLicense:\tLGPLv2+ and BSD\nURL:\t\thttp://www.dcache.org/manuals/libdcap.shtml\nSource0:\thttps://github.com/dCache/%{name}/archive/%{version}.tar.gz\nBuildRoot:\t%{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)\n\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\nBuildRequires:\tglobus-gssapi-gsi-devel\nBuildRequires:\tkrb5-devel\nBuildRequires:\topenssl-devel\nBuildRequires:\tautoconf\nBuildRequires:\tautomake\nBuildRequires:\tlibtool\n%if %{?fedora}%{!?fedora:0} || %{?rhel}%{!?rhel:0} >= 6\n#\t\tNo CUnit in EPEL 5\nBuildRequires:\tCUnit-devel\n%endif\n\n%description\ndCache is a distributed mass storage system.\nThis package contains the client tools.\n\n%package libs\nSummary:\tClient Libraries for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+\n\n%description libs\ndCache is a distributed mass storage system.\nThis package contains the client libraries.\n\n%package devel\nSummary:\tClient Development Files for dCache\nGroup:\t\tDevelopment/Libraries\nLicense:\tLGPLv2+\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description devel\ndCache is a distributed mass storage system.\nThis package contains the client development files.\n\n%package tunnel-gsi\nSummary:\tGSI tunnel for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+ and BSD\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description tunnel-gsi\nThis package contains the gsi tunnel plugin library used by dcap-libs.\nThis library is dynamically loaded at runtime.\n\n%package tunnel-krb\nSummary:\tKerberos tunnel for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+ and BSD\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description tunnel-krb\nThis package contains the kerberos tunnel plugin library used by dcap-libs.\nThis library is dynamically loaded at runtime.\n\n%package tunnel-ssl\nSummary:\tSSL tunnel for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description tunnel-ssl\nThis package contains the ssl tunnel plugin library used by dcap-libs.\nThis library is dynamically loaded at runtime.\n\n%package tunnel-telnet\nSummary:\tTelnet tunnel for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description tunnel-telnet\nThis package contains the telnet tunnel plugin library used by dcap-libs.\nThis library is dynamically loaded at runtime.\n\n%prep\n%setup -q\n\n%build\nchmod +x bootstrap.sh\n./bootstrap.sh\n\n%configure \\\n    --disable-static \\\n    --with-tunneldir=%{_libdir}/%{name} \\\n    --with-globus-include=%{_includedir}/globus \\\n    --with-globus-lib=/dummy\nmake %{?_smp_mflags}\n\n%install\nrm -rf %{buildroot}\n\nmake install DESTDIR=%{buildroot}\n\n# Remove libtool archive files\nrm -rf %{buildroot}/%{_libdir}/*.la\nrm -rf %{buildroot}/%{_libdir}/%{name}/*.la\n\n# We are installing the docs in the files sections\nrm -rf %{buildroot}/%{_docdir}\n\n%clean\nrm -rf %{buildroot}\n\n%if %{?fedora}%{!?fedora:0} || %{?rhel}%{!?rhel:0} >= 6\n%check\nmake %{?_smp_mflags} check\n%endif\n\n%post libs -p /sbin/ldconfig\n\n%postun libs -p /sbin/ldconfig\n\n# Redefine license as doc for old rpm versions (EPEL 5 and 6)\n%{!?_licensedir: %global license %%doc}\n\n%files\n%{_bindir}/dccp\n%{_mandir}/man1/dccp.1*\n\n%files libs\n%{_libdir}/libdcap.so.*\n%{_libdir}/libpdcap.so.*\n%dir %{_libdir}/%{name}\n%license LICENSE COPYING.LIB AUTHORS\n\n%files devel\n%{_libdir}/libdcap.so\n%{_libdir}/libpdcap.so\n%{_includedir}/dc_hack.h\n%{_includedir}/dcap.h\n%{_includedir}/dcap_errno.h\n\n%files tunnel-gsi\n%{_libdir}/%{name}/libgsiTunnel.so\n%license plugins/gssapi/Copyright\n\n%files tunnel-krb\n%{_libdir}/%{name}/libgssTunnel.so\n%license plugins/gssapi/Copyright\n\n%files tunnel-ssl\n%{_libdir}/%{name}/libsslTunnel.so\n\n%files tunnel-telnet\n%{_libdir}/%{name}/libtelnetTunnel.so\n\n%changelog\n* Mon Jan 11 2016 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.10-1\n- New upstream release\n- Drop patch dcap-dlopen.patch - merged upstream\n\n* Wed Jun 17 2015 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.47.9-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_23_Mass_Rebuild\n\n* Tue Feb 10 2015 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.9-1\n- New upstream release\n- Enable tests and add BR CUnit-devel (except EPEL 5)\n- Adapt to new license packaging guidelines\n\n* Sat Aug 16 2014 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.47.8-3\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_21_22_Mass_Rebuild\n\n* Sat Jun 07 2014 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.47.8-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_21_Mass_Rebuild\n\n* Thu Aug 15 2013 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.8-1\n- New upstream release\n- Drop patch dcap-segfault.patch - merged upstream\n\n* Sat Aug 03 2013 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.47.7-4\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_20_Mass_Rebuild\n\n* Fri Jun 28 2013 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.7-3\n- Fix segfault\n\n* Wed Feb 13 2013 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.47.7-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_19_Mass_Rebuild\n\n* Tue Nov 27 2012 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.7-1\n- New upstream release\n\n* Wed Jul 18 2012 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.47.6-3\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_18_Mass_Rebuild\n\n* Thu Jul 12 2012 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.6-2\n- Remove encoding fixes\n\n* Thu May 24 2012 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.6-1\n- New upstream release (EMI 2 release)\n- Drop patches dcap-aliasing.patch and dcap-libs.patch implemented upstream\n\n* Fri Jan 13 2012 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.47.5-3\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_17_Mass_Rebuild\n\n* Fri Feb 11 2011 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.47.5-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_15_Mass_Rebuild\n\n* Sat Nov 06 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.5-1\n- New upstream release\n- Drop dcap-docs.patch - implemented upstream\n- Put CFLAGS back to default - the issue causing problem is fixed upstream\n\n* Thu Jun 17 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.2-2\n- Adjust CFLAGS so that the compiled program works correctly\n\n* Wed Apr 07 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.2-1\n- New upstream release\n- Drop dcap-adler32.patch - implemented upstream\n\n* Thu Mar 11 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.44.0-3\n- Add missing build requires on autotools\n- Fix configure to look for functions in the right libraries\n\n* Wed Mar 10 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.44.0-2\n- Use the adler32 function from zlib and drop the bundled source file\n- Drop the zlib license tag again\n\n* Wed Mar 10 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.44.0-1\n- Major revision of spec file - upstream has started using autotools\n- Add zlib license tag due to the adler32 source\n\n* Sun Jan  3 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 1.2.44-2\n- Porting to additional architectures\n- Add BSD license tags for the tunnel-gsi and tunnel-krb sub packages\n\n* Thu Dec 17 2009 Mattias Ellert <mattias.ellert@fysast.uu.se> - 1.2.44-1\n- Update to version 1.2.44 (svn tag 1.9.3-7)\n\n* Thu Sep 17 2009 Mattias Ellert <mattias.ellert@fysast.uu.se> - 1.2.42-2\n- Update to new svn tag 1.9.3-3\n\n* Thu Aug 13 2009 Mattias Ellert <mattias.ellert@fysast.uu.se> - 1.2.42-1\n- Initial Fedora package based on svn tag 1.9.3-1\n",
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/specs/sl6/dcap-epel.spec": "Name:\t\tdcap\nVersion:\t2.47.6\nRelease:\t1%{?dist}\nSummary:\tClient Tools for dCache\n\nGroup:\t\tApplications/Internet\n#\t\tplugins/gssapi/{base64.[ch],gssIoTunnel.c,util.c} - BSD license\n#\t\tthe rest - LGPLv2+ license\nLicense:\tLGPLv2+ and BSD\nURL:\t\thttp://www.dcache.org/manuals/libdcap.shtml\n#\t\tThe source tarfile is created from a subversion checkout:\n#\t\tsvn export http://svn.dcache.org/dCache/tags/dcap-2.47.6 \\\n#\t\t    dcap-2.47.6\n#\t\ttar -z -c -f dcap-2.47.6.tar.gz dcap-2.47.6\nSource0:\t%{name}-%{version}.tar.gz\n#\t\tAllow loading of plugins outside default library search path\nPatch0:\t\t%{name}-dlopen.patch\n#\t\tReduce overlinking\n#\t\thttp://rb.dcache.org/r/1646\nPatch1:\t\t%{name}-libs.patch.2.47.6\n#\t\tFix strict aliasing warnings\n#\t\thttp://rb.dcache.org/r/2632\nPatch2:\t\t%{name}-aliasing.patch\nBuildRoot:\t%{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)\n\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\nBuildRequires:\tglobus-gssapi-gsi-devel%{?_isa}\nBuildRequires:\tkrb5-devel%{?_isa}\nBuildRequires:\topenssl-devel%{?_isa}\nBuildRequires:\tautoconf\nBuildRequires:\tautomake\nBuildRequires:\tlibtool\n\n%description\ndCache is a distributed mass storage system.\nThis package contains the client tools.\n\n%package libs\nSummary:\tClient Libraries for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+\n\n%description libs\ndCache is a distributed mass storage system.\nThis package contains the client libraries.\n\n%package devel\nSummary:\tClient Development Files for dCache\nGroup:\t\tDevelopment/Libraries\nLicense:\tLGPLv2+\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description devel\ndCache is a distributed mass storage system.\nThis package contains the client development files.\n\n%package tunnel-gsi\nSummary:\tGSI tunnel for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+ and BSD\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description tunnel-gsi\nThis package contains the gsi tunnel plugin library used by dcap-libs.\nThis library is dynamically loaded at runtime.\n\n%package tunnel-krb\nSummary:\tKerberos tunnel for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+ and BSD\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description tunnel-krb\nThis package contains the kerberos tunnel plugin library used by dcap-libs.\nThis library is dynamically loaded at runtime.\n\n%package tunnel-ssl\nSummary:\tSSL tunnel for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description tunnel-ssl\nThis package contains the ssl tunnel plugin library used by dcap-libs.\nThis library is dynamically loaded at runtime.\n\n%package tunnel-telnet\nSummary:\tTelnet tunnel for dCache\nGroup:\t\tSystem Environment/Libraries\nLicense:\tLGPLv2+\nRequires:\t%{name}-libs%{?_isa} = %{version}-%{release}\n\n%description tunnel-telnet\nThis package contains the telnet tunnel plugin library used by dcap-libs.\nThis library is dynamically loaded at runtime.\n\n%prep\n%setup -q\n%patch0 -p1\n%patch1 -p0\n%patch2 -p1\n\nfor f in Copyright base64.c base64.h util.c ; do\n    iconv -f iso-8859-1 -t utf-8 plugins/gssapi/$f -o plugins/gssapi/$f.new\n    mv plugins/gssapi/$f.new plugins/gssapi/$f\ndone\n\nsed 's!@@LIBDIR@@!%{_libdir}!' -i src/tunnelManager.c\n\n%build\nchmod +x bootstrap.sh\n./bootstrap.sh\n\n# The defaults optflags creates a broken binary\nexport CFLAGS=\"%optflags\"\n%configure \\\n    --with-globus-include=\"%{_includedir}/globus -I%{_libdir}/globus/include\" \\\n    --with-globus-lib=/dummy\nmake %{?_smp_mflags}\n\n%install\nrm -rf $RPM_BUILD_ROOT\n\nmake install DESTDIR=$RPM_BUILD_ROOT\n\n# Remove static libraries and libtool archive files\nrm -rf $RPM_BUILD_ROOT/%{_libdir}/*.a\nrm -rf $RPM_BUILD_ROOT/%{_libdir}/*.la\n\n# Move plugins out of the default library path\nmkdir $RPM_BUILD_ROOT/%{_libdir}/%{name}\nmv $RPM_BUILD_ROOT/%{_libdir}/lib*Tunnel* $RPM_BUILD_ROOT/%{_libdir}/%{name}\n\n# We are installing the docs in the files sections\nrm -rf $RPM_BUILD_ROOT/%{_docdir}\n\n%clean\nrm -rf $RPM_BUILD_ROOT\n\n%post libs -p /sbin/ldconfig\n\n%postun libs -p /sbin/ldconfig\n\n%files\n%defattr(-,root,root,-)\n%{_bindir}/dccp\n%_mandir/man1/dccp.1.gz\n#### These seem to be removed in dcap-2.47.6 tag\n#%{_bindir}/dcap_test\n#%{_bindir}/dcap_url_test\n#%{_bindir}/dcsuck\n#%{_bindir}/readv_test\n#%{_bindir}/wdccp\n\n%files libs\n%defattr(-,root,root,-)\n%{_libdir}/libdcap.so.*\n%{_libdir}/libpdcap.so.*\n%dir %{_libdir}/%{name}\n%doc LICENSE COPYING.LIB AUTHORS\n\n%files devel\n%defattr(-,root,root,-)\n%{_libdir}/libdcap.so\n%{_libdir}/libpdcap.so\n%{_includedir}/dc_hack.h\n%{_includedir}/dcap.h\n%{_includedir}/dcap_errno.h\n\n%files tunnel-gsi\n%defattr(-,root,root,-)\n%{_libdir}/%{name}/libgsiTunnel.so\n%doc plugins/gssapi/Copyright\n\n%files tunnel-krb\n%defattr(-,root,root,-)\n%{_libdir}/%{name}/libgssTunnel.so\n%doc plugins/gssapi/Copyright\n\n%files tunnel-ssl\n%defattr(-,root,root,-)\n%{_libdir}/%{name}/libsslTunnel.so\n\n%files tunnel-telnet\n%defattr(-,root,root,-)\n%{_libdir}/%{name}/libtelnetTunnel.so\n\n%changelog\n* Fri Feb 11 2011 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.47.5-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_15_Mass_Rebuild\n\n* Sat Nov 06 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.5-1\n- New upstream release\n- Drop dcap-docs.patch - implemented upstream\n- Put CFLAGS back to default - the issue causing problem is fixed upstream\n\n* Thu Jun 17 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.2-2\n- Adjust CFLAGS so that the compiled program works correctly\n\n* Wed Apr 07 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.47.2-1\n- New upstream release\n- Drop dcap-adler32.patch - implemented upstream\n\n* Thu Mar 11 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.44.0-3\n- Add missing build requires on autotools\n- Fix configure to look for functions in the right libraries\n\n* Wed Mar 10 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.44.0-2\n- Use the adler32 function from zlib and drop the bundled source file\n- Drop the zlib license tag again\n\n* Wed Mar 10 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 2.44.0-1\n- Major revision of spec file - upstream has started using autotools\n- Add zlib license tag due to the adler32 source\n\n* Sun Jan  3 2010 Mattias Ellert <mattias.ellert@fysast.uu.se> - 1.2.44-2\n- Porting to additional architectures\n- Add BSD license tags for the tunnel-gsi and tunnel-krb sub packages\n\n* Thu Dec 17 2009 Mattias Ellert <mattias.ellert@fysast.uu.se> - 1.2.44-1\n- Update to version 1.2.44 (svn tag 1.9.3-7)\n\n* Thu Sep 17 2009 Mattias Ellert <mattias.ellert@fysast.uu.se> - 1.2.42-2\n- Update to new svn tag 1.9.3-3\n\n* Thu Aug 13 2009 Mattias Ellert <mattias.ellert@fysast.uu.se> - 1.2.42-1\n- Initial Fedora package based on svn tag 1.9.3-1\n",
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/src/win32_libdl.c": "\n/*\n * $Id: win32_libdl.c,v 1.2 2004-11-01 19:33:30 tigran Exp $\n */\n\n#include <windows.h>\n#include <stdio.h>\n\n#include \"win32_libdl.h\"\n\nstatic char errbuf[512];\n\nvoid *dlopen(const char *name, int mode)\n{\n  HINSTANCE hdll;\n\n  hdll = LoadLibrary(name);\n#ifdef _WIN32\n  if (! hdll) {\n    sprintf(errbuf, \"error code %d loading library %s\", GetLastError(), name);\n    return NULL;\n  }\n#else\n  if ((UINT) hdll < 32) {\n    sprintf(errbuf, \"error code %d loading library %s\", (UINT) hdll, name);\n    return NULL;\n  }\n#endif\n  return (void *) hdll;\n}\n\nvoid *dlsym(void *lib, const char *name)\n{\n  HMODULE hdll = (HMODULE) lib;\n  void *symAddr;\n  symAddr = (void *) GetProcAddress(hdll, name);\n  if (symAddr == NULL)\n    sprintf(errbuf, \"can't find symbol %s\", name);\n  return symAddr;\n}\n\nint dlclose(void *lib)\n{\n  HMODULE hdll = (HMODULE) lib;\n\n#ifdef _WIN32\n  if (FreeLibrary(hdll))\n    return 0;\n  else {\n    sprintf(errbuf, \"error code %d closing library\", GetLastError());\n    return -1;\n  }\n#else\n  FreeLibrary(hdll);\n  return 0;\n#endif\n}\n\nchar *dlerror()\n{\n  return errbuf;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/src/tunnelManager.c": "/*\n *   DCAP - dCache Access Protocol client interface\n *\n *   Copyright (C) 2000,2004 DESY Hamburg DMG-Division.\n *\n *   AUTHOR: Tigran Mkrtchayn (tigran.mkrtchyan@desy.de)\n *\n *   This program can be distributed under the terms of the GNU LGPL.\n *   See the file COPYING.LIB\n *\n */\n \n \n/*\n * $Id: tunnelManager.c,v 1.11 2004-11-01 19:33:30 tigran Exp $\n */\n\n#ifndef WIN32\n#   include <dlfcn.h>\n#   include <unistd.h>\n#else\n#    include \"win32_libdl.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"dcap.h\"\n#include \"sysdep.h\"\n#include \"debug_level.h\"\n#include \"ioTunnel.h\"\n#include \"tunnelManager.h\"\n\ntypedef struct {\n\tint sock;\n\tioTunnel *tunnel;\n} tunnelPair;\n\nstatic MUTEX(gLock);\n\nstatic tunnelPair *tunnelMap;\nstatic unsigned int qLen = 0; /* number of elements in the memory*/\n\n\nint setTunnelPair(int sock, ioTunnel *tunnel)\n{\n\ttunnelPair *tmp;\n\tm_lock(&gLock);\n\t\n\ttmp = realloc(tunnelMap, sizeof(tunnelPair)*(qLen +1));\n\tif(tmp == NULL) {\n\t\tm_unlock(&gLock);\n\t\treturn -1;\n\t}\n\t\n\ttunnelMap = tmp;\n\ttunnelMap[qLen].sock = sock;\n\ttunnelMap[qLen].tunnel = tunnel;\n\t\n\t++qLen;\n\t\n\tm_unlock(&gLock);\n\treturn 0;\n}\n\nioTunnel * getTunnelPair(int sock)\n{\n\n\tunsigned int i;\n\tioTunnel *en;\n\t\n\tm_lock(&gLock);\n\tfor(i = 0; i < qLen; i++) {\n\t\tif(tunnelMap[i].sock == sock) {\t\t\n\t\t\ten =  tunnelMap[i].tunnel;\n\t\t\tm_unlock(&gLock);\n\t\t\treturn en;\n\t\t}\n\t}\n\tm_unlock(&gLock);\n\treturn NULL;\n}\n\n\nioTunnel *addIoPlugin(const char *libname)\n{\n\tvoid *handle;\n\tioTunnel *tunnel;\n\tchar *fullpath;\n\n\tif(libname == NULL) {\n\t\tdc_debug(DC_ERROR, \"Bad tunnel name\");\n\t\treturn NULL;\n\t}\n\n\t/* magick library name, do nothing */\n\tif( strcmp(libname, \"null\") == 0 ) {\n\t\treturn NULL;\n\t}\n\n\thandle = dlopen( libname, RTLD_NOW);\n\t\t\n\tif(handle == NULL) {\n\t\tfullpath = malloc(strlen(TUNNELLIBDIR) + strlen(libname) + 2);\n\t\tstrcpy(fullpath, TUNNELLIBDIR);\n\t\tstrcat(fullpath, \"/\");\n\t\tstrcat(fullpath, libname);\n\t\thandle = dlopen(fullpath, RTLD_NOW);\n\t\tfree(fullpath);\n\t}\n\n\tif(handle == NULL) {\t\t\n\t\tgoto fail;\n\t}\n\n\ttunnel = (ioTunnel *)malloc(sizeof(ioTunnel));\n\tif(tunnel == NULL) {\n\t\tdc_debug(DC_ERROR, \"Failed to allocate memory for tunnel\");\n\t\tdlclose(handle);\n\t\treturn NULL;\n\t}\n\n\t\n\ttunnel->eRead = (ssize_t (*)(int , void *, size_t ))dlsym(handle, \"eRead\");\n\tif(tunnel->eRead == NULL) goto fail;\n\t\n\ttunnel->eWrite = (ssize_t (*)(int ,const void *, size_t ))dlsym(handle, \"eWrite\");\n\tif(tunnel->eWrite == NULL) goto fail;\n\t\n\ttunnel->eInit = (int(*)(int))dlsym(handle, \"eInit\");\t\n\tif(tunnel->eInit == NULL) goto fail;\n\t\n\ttunnel->eDestroy = (int(*)(int))dlsym(handle, \"eDestroy\");\n\tif(tunnel->eDestroy == NULL) goto fail;\n\t\t\n\n\tdc_debug(DC_INFO, \"Activating IO tunnel. Provider: [%s].\", libname);\n\t\t\n\treturn tunnel;\n\t\nfail:\n\tdc_debug(DC_ERROR, \"Failed to add IO tunnel (%s). Provider: [%s].\", dlerror(), libname);\n\n\tif(handle != NULL ) {\n\t\tdlclose(handle);\n\t}\n\treturn NULL;\t\n\t\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/src/win32_libdl.h": "/*\n *   DCAP - dCache Access Protocol client interface\n *\n *   Copyright (C) 2000,2004 DESY Hamburg DMG-Division.\n *\n *   AUTHOR: Tigran Mkrtchayn (tigran.mkrtchyan@desy.de)\n *\n *   This program can be distributed under the terms of the GNU LGPL.\n *   See the file COPYING.LIB\n *\n */\n\n\n/*\n * $Id: win32_libdl.h,v 1.2 2004-11-01 19:33:30 tigran Exp $\n */\n\n#ifndef WIN32_LIBDL_H\n#define WIN32_LIBDL_H\n\n#define RTLD_LAZY 1\n#define RTLD_NOW  2\n\nextern void  *dlopen(const char *, int);\nextern void  *dlsym(void *, const char *);\nextern int   dlclose(void *);\nextern char  *dlerror(void);\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/src/system_io.c": "/*\n *   DCAP - dCache Access Protocol client interface\n *\n *   Copyright (C) 2000,2004 DESY Hamburg DMG-Division.\n *\n *   AUTHOR: Tigran Mkrtchayn (tigran.mkrtchyan@desy.de)\n *   FIXED BY: Vladimir Podstavkov (podstvkv@fnal.gov)\n *\n *   This program can be distributed under the terms of the GNU LGPL.\n *   See the file COPYING.LIB\n *\n */\n\n\n/*\n * $Id: system_io.c,v 1.54 2006-09-26 07:41:11 tigran Exp $\n */\n\n#ifdef LIBC_SYSCALLS\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include \"dcap_debug.h\"\n#include \"sysdep.h\"\n#include <signal.h>\n\nstatic MUTEX(gLock);\nstatic void *handle;\n\n#ifdef __APPLE__\n#define off64_t off_t\n#endif\n\n/*\n *  Convert from (void *) to different function pointer\n *  types.  For details why this is necessary, please\n *  see dlsym man-page:\n *\n *    http://www.opengroup.org/onlinepubs/009695399/functions/dlsym.html\n */\nunion pointer_converter {\n  void *symbol;\n  int (*s_open)           (const char *, int, ...);\n  ssize_t (*s_read)       (int, void *, size_t);\n  ssize_t (*s_readv)      (int, const struct iovec *vector, int count);\n  ssize_t (*s_pread)      (int, void *, size_t, off_t);\n  ssize_t (*s_pread64)    (int, void *, size_t, off64_t);\n  ssize_t (*s_write)      (int, const void *, size_t);\n  ssize_t (*s_writev)     (int, const struct iovec *vector, int count);\n  ssize_t (*s_pwrite)     (int, const void *, size_t, off_t);\n  ssize_t (*s_pwrite64)   (int, const void *, size_t, off64_t);\n  off64_t (*s_lseek64)    (int, off64_t, int);\n  int (*s_close)          (int);\n#ifdef _STAT_VER\n  int (*s_stat)           (int , const char *, struct stat *);\n  int (*s_fstat)          (int, int, struct stat *);\n  int (*s_stat64)         (int , const char *, struct stat64 *);\n  int (*s_lstat64)        (int , const char *, struct stat64 *);\n  int (*s_lstat)          (int , const char *, struct stat *);\n  int (*s_fstat64)        (int, int, struct stat64 *);\n#else\n  int (*s_stat)           (const char *, struct stat *);\n  int (*s_fstat)          (int, struct stat *);\n  int (*s_stat64)         (const char *, struct stat64 *);\n  int (*s_lstat64)        (const char *, struct stat64 *);\n  int (*s_lstat)          (const char *, struct stat *);\n  int (*s_fstat64)        (int, struct stat64 *);\n#endif\n  int (*s_fsync)          (int);\n  int (*s_dup)            (int);\n  int (*s_closedir)       (DIR *);\n  DIR *(*s_opendir)       (const char *);\n  struct dirent *(*s_readdir) (DIR *);\n  struct dirent64 *(*s_readdir64) (DIR *);\n  off_t (*s_telldir)      (DIR *);\n  void (*s_seekdir)       (DIR *, off_t);\n  int (*s_unlink)         (const char *);\n  int (*s_rmdir)          (const char *);\n  int (*s_mkdir)          (const char *, mode_t);\n  int (*s_chmod)          (const char *, mode_t);\n  int (*s_chown)          (const char *, uid_t, gid_t);\n  int (*s_access)         (const char *, int);\n  int (*s_rename)         (const char *, const char *);\n  int (*s_acl)            (const char *, int, int, void *);\n  int (*s_facl)           (int, int, int, void *);\n  FILE *(*s_fopen)        (const char *, const char *);\n  FILE *(*s_fopen64)      (const char *, const char *);\n  FILE *(*s_fdopen)       (int, const char *);\n  int (*s_fclose)         (FILE *);\n  size_t (*s_fwrite)      (const void *, size_t, size_t, FILE *);\n  size_t (*s_fread)       (void *, size_t, size_t, FILE *);\n  int (*s_fseeko64)       (FILE *, off64_t, int);\n  off64_t (*s_ftello64)   (FILE *);\n  int (*s_ferror)         (FILE *);\n  int (*s_fflush)         (FILE *);\n  int (*s_feof)           (FILE *);\n  char *(*s_fgets)        (char *, int, FILE *);\n  int (*s_fgetc)          (FILE *);\n};\n\n#define ASSIGN_FN(FN_VARIABLE, CONVERTER, HANDLE, SYMBOL) \\\n  do {                                                    \\\n    CONVERTER.symbol = dlsym( HANDLE, SYMBOL);            \\\n    FN_VARIABLE = CONVERTER. FN_VARIABLE;                 \\\n  } while(0)\n\n#ifndef LIBC\n#define LIBC NULL\n#endif\nstatic char *libname = LIBC;\nstatic int (*s_open)           (const char *, int, ...);\nstatic ssize_t (*s_read)       (int, void *, size_t);\nstatic ssize_t (*s_readv)      (int, const struct iovec *vector, int count);\nstatic ssize_t (*s_pread)      (int, void *, size_t, off_t);\nstatic ssize_t (*s_pread64)    (int, void *, size_t, off64_t);\nstatic ssize_t (*s_write)      (int, const void *, size_t);\nstatic ssize_t (*s_writev)     (int, const struct iovec *vector, int count);\nstatic ssize_t (*s_pwrite)     (int, const void *, size_t, off_t);\nstatic ssize_t (*s_pwrite64)   (int, const void *, size_t, off64_t);\nstatic off64_t (*s_lseek64)    (int, off64_t, int);\nstatic int (*s_close)          (int);\n\n/*\n * A version number is included in the x86 SVR4 stat interface\n * so that SVR3 binaries can be supported\n */\n#ifdef _STAT_VER\nstatic int (*s_stat)       (int , const char *, struct stat *);\nstatic int (*s_fstat)      (int, int, struct stat *);\nstatic int (*s_stat64)     (int , const char *, struct stat64 *);\nstatic int (*s_lstat64)    (int , const char *, struct stat64 *);\nstatic int (*s_lstat)      (int , const char *, struct stat *);\nstatic int (*s_fstat64)    (int, int, struct stat64 *);\n#else\nstatic int (*s_stat)       (const char *, struct stat *);\nstatic int (*s_fstat)      (int, struct stat *);\nstatic int (*s_stat64)     (const char *, struct stat64 *);\nstatic int (*s_lstat64)    (const char *, struct stat64 *);\nstatic int (*s_lstat)      (const char *, struct stat *);\nstatic int (*s_fstat64)    (int, struct stat64 *);\n#endif\nstatic int (*s_fsync)      (int);\nstatic int (*s_dup)        (int);\nstatic int              (*s_closedir)   (DIR *);\nstatic DIR *            (*s_opendir)    (const char *);\nstatic struct dirent *  (*s_readdir)    (DIR *);\nstatic struct dirent64 *(*s_readdir64)  (DIR *);\nstatic off_t            (*s_telldir)    (DIR *);\nstatic void             (*s_seekdir)    (DIR *, off_t);\nstatic int              (*s_unlink)(const char *);\nstatic int              (*s_rmdir)(const char *);\nstatic int              (*s_mkdir)(const char *, mode_t);\nstatic int              (*s_chmod)(const char *, mode_t);\nstatic int              (*s_chown)(const char *, uid_t, gid_t);\nstatic int              (*s_access)(const char *, int);\nstatic int              (*s_rename)(const char *, const char *);\n#ifdef HAVE_ACL\nstatic int              (*s_acl)(const char *, int, int, void *);\n#endif /* HAVE_ACL */\n#ifdef HAVE_FACL\nstatic int              (*s_facl)(int, int, int, void *);\n#endif /* HAVE_FACL */\n\nstatic FILE * (*s_fopen)(const char *, const char *);\nstatic FILE * (*s_fopen64)(const char *, const char *);\nstatic FILE * (*s_fdopen)(int, const char *);\nstatic int  (*s_fclose)(FILE *);\nstatic size_t (*s_fwrite)(const void *, size_t, size_t, FILE *);\nstatic size_t (*s_fread)(void *, size_t, size_t, FILE *);\nstatic int (*s_fseeko64)(FILE *, off64_t, int);\nstatic off64_t (*s_ftello64)(FILE *);\nstatic int (*s_ferror)(FILE *);\nstatic int (*s_fflush)(FILE *);\nstatic int (*s_feof)(FILE *);\nstatic char * (*s_fgets)(char *, int, FILE *);\nstatic int (*s_fgetc)(FILE *);\n\nstatic int initIfNeeded();\nstatic void stat64to32(struct stat *st32, const struct stat64 *st64);\n\n\n/* FIXME: stat64to32 is duplicated in dcap_stat.c */\nvoid stat64to32(struct stat *st32, const struct stat64 *st64)\n{\n\tmemset(st32, 0, sizeof(struct stat) );\n\n\tst32->st_dev = st64->st_dev;\n\tst32->st_ino = st64->st_ino;\n\tst32->st_mode = st64->st_mode;\n\tst32->st_nlink = st64->st_nlink;\n\tst32->st_uid = st64->st_uid;\n\tst32->st_gid = st64->st_gid;\n\tst32->st_rdev = st64->st_rdev;\n\tst32->st_size = st64->st_size;\n\tst32->st_blksize = st64->st_blksize;\n\tst32->st_blocks = st64->st_blocks;\n\tst32->st_atime = st64->st_atime;\n\tst32->st_mtime = st64->st_mtime;\n\tst32->st_ctime = st64->st_ctime;\n}\n\nint initIfNeeded()\n{\n\tunion pointer_converter convert;\n\tchar *em;\n\n\tsigset_t block_set;\n\n\n\t/* we do not want to be interrupted */\n\tsigemptyset(&block_set);\n\tsigaddset(&block_set, SIGALRM);\n\tsigprocmask(SIG_BLOCK, &block_set, NULL);\n\n\tm_lock(&gLock);\n\n\tif(handle != NULL) {\n\t\tm_unlock(&gLock);\n/*\t\tdc_debug(DC_TRACE, \"System IO already initialized.\");\t\t*/\n\n\t\t/* restore signal handling */\n\t\tsigprocmask(SIG_UNBLOCK, &block_set, NULL);\n\t\treturn 0;\n\t}\n\n/*\tdc_debug(DC_IO, \"Initializing System IO.\"); */\n\tif( getenv(\"DCACHE_IOLIB\") != NULL ) {\n\t\tlibname = getenv(\"DCACHE_IOLIB\");\n\t}\n\tif( libname != NULL ) {\n\t\thandle = dlopen( libname, RTLD_NOW | RTLD_GLOBAL);\n\t\tif(handle == NULL) {\n\t\t\tm_unlock(&gLock);\n/*\t\t\tdc_debug(DC_ERROR, \"Failed to initialize System IO: (%s).\", dlerror()); */\n#if 0\n\t\t\tperror(dlerror() );\n#endif\n\t\t\t/* restore signal handling */\n\t\t\tsigprocmask(SIG_UNBLOCK, &block_set, NULL);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t#ifdef RTLD_NEXT\n\telse{\n\t\t/* try to use other dynamic libraries to get requaried functions */\n\n\t\thandle = RTLD_NEXT;\n\t}\n\t#endif\n\n\n\tASSIGN_FN( s_open,     convert, handle, OPEN_SYM);\n\tASSIGN_FN( s_read,     convert, handle, READ_SYM);\n\tASSIGN_FN( s_readv,    convert, handle, READV_SYM);\n\tASSIGN_FN( s_pread,    convert, handle, PREAD_SYM);\n\tASSIGN_FN( s_pread64,  convert, handle, PREAD64_SYM);\n\tASSIGN_FN( s_write,    convert, handle, WRITE_SYM);\n\tASSIGN_FN( s_writev,   convert, handle, WRITEV_SYM);\n\tASSIGN_FN( s_pwrite,   convert, handle, PWRITE_SYM);\n\tASSIGN_FN( s_pwrite64, convert, handle, PWRITE64_SYM);\n\tASSIGN_FN( s_lseek64,  convert, handle, LSEEK64_SYM);\n\tASSIGN_FN( s_close,    convert, handle, CLOSE_SYM);\n\tASSIGN_FN( s_stat,     convert, handle, STAT64_SYM);\n\tASSIGN_FN( s_stat64,   convert, handle, STAT64_SYM);\n\tASSIGN_FN( s_lstat,    convert, handle, LSTAT_SYM);\n\tASSIGN_FN( s_lstat64,  convert, handle, LSTAT64_SYM);\n\tASSIGN_FN( s_fstat,    convert, handle, FSTAT_SYM);\n\tASSIGN_FN( s_fstat64,  convert, handle, FSTAT64_SYM);\n\n\tASSIGN_FN( s_fsync,    convert, handle, FSYNC_SYM);\n\n\tASSIGN_FN( s_dup,      convert, handle, DUP_SYM);\n\n\tASSIGN_FN( s_opendir,  convert, handle, OPENDIR_SYM);\n\tASSIGN_FN( s_closedir, convert, handle, CLOSEDIR_SYM);\n\tASSIGN_FN( s_readdir,  convert, handle, READDIR_SYM);\n\tASSIGN_FN( s_readdir64, convert, handle, READDIR64_SYM);\n\tASSIGN_FN( s_telldir,  convert, handle, TELLDIR_SYM);\n\tASSIGN_FN( s_seekdir,  convert, handle, SEEKDIR_SYM);\n\n\tASSIGN_FN( s_unlink,   convert, handle, UNLINK_SYM);\n\tASSIGN_FN( s_rmdir,    convert, handle, RMDIR_SYM);\n\tASSIGN_FN( s_mkdir,    convert, handle, MKDIR_SYM);\n\tASSIGN_FN( s_chmod,    convert, handle, CHMOD_SYM);\n\tASSIGN_FN( s_chown,    convert, handle, CHOWN_SYM);\n\tASSIGN_FN( s_access,   convert, handle, ACCESS_SYM);\n\tASSIGN_FN( s_rename,   convert, handle, RENAME_SYM);\n#ifdef HAVE_ACL\n\tASSIGN_FN( s_acl,      convert, handle, ACL_SYM);\n#endif /* HAVE_ACL */\n#ifdef HAVE_FACL\n\tASSIGN_FN( s_facl,     convert, handle, FACL_SYM);\n#endif /* HAVE_FACL */\n\n\tASSIGN_FN( s_fopen,    convert, handle, \"fopen\");\n\tASSIGN_FN( s_fopen64,  convert, handle, \"fopen64\");\n\tASSIGN_FN( s_fdopen,   convert, handle, \"fdopen\");\n\tASSIGN_FN( s_fread,    convert, handle, \"fread\");\n\tASSIGN_FN( s_fwrite,   convert, handle, \"fwrite\");\n\tASSIGN_FN( s_fseeko64, convert, handle, \"fseeko64\");\n\tASSIGN_FN( s_fclose,   convert, handle, \"fclose\");\n\tASSIGN_FN( s_fflush,   convert, handle, \"fflush\");\n\tASSIGN_FN( s_ftello64, convert, handle, \"ftello64\");\n\tASSIGN_FN( s_feof,     convert, handle, \"feof\");\n\tASSIGN_FN( s_ferror,   convert, handle, \"ferror\");\n\tASSIGN_FN( s_fgets,    convert, handle, \"fgets\");\n\tASSIGN_FN( s_fgetc,    convert, handle, \"fgetc\");\n\n\tif( (s_open == NULL) || (s_read == NULL) ||\n\t\t(s_pread == NULL) || (s_write == NULL) ||\n\t\t(s_pwrite == NULL) || (s_pread64 == NULL) || (s_pwrite64 == NULL) ||\n\t\t(s_lseek64 == NULL) || (s_close == NULL) ||\n\t\t(s_stat == NULL) || (s_fstat == NULL ) || (s_fsync == NULL) ||\n\t\t(s_stat64 == NULL) || (s_fstat64 == NULL ) ||\n\t\t(s_lstat == NULL) || (s_lstat64 == NULL ) ||\n\t\t(s_dup == NULL) || (s_opendir == NULL) || (s_closedir == NULL) ||\n\t\t(s_readdir == NULL) || (s_readdir64 ==  NULL) ||\n\t\t(s_telldir == NULL) || (s_seekdir == NULL) ||\n\t\t(s_unlink == NULL ) || (s_rmdir == NULL ) ||\n\t\t(s_mkdir == NULL ) || (s_chmod == NULL ) || (s_access == NULL )  ||\n#ifdef HAVE_ACL\n\t\t(s_acl == NULL ) ||\n#endif /* HAVE_ACL */\n#ifdef HAVE_FACL\n\t\t(s_facl == NULL ) ||\n#endif /* HAVE_FACL */\n\n\t\t(s_chown == NULL ) ) {\n\n\t\t/* try to write error message it's possible */\n\t\tif( s_write != NULL ) {\n\t\t\tem = dlerror();\n\t\t\tif(em != NULL ) {\n\t\t\t\ts_write(2, em, strlen(em) );\n\t\t\t}\n\t\t}\n\n/*\t\tdc_debug(DC_ERROR, \"Failed to initialize System IO: (%s).\", dlerror()); */\n\t\tdlclose(handle);\n\t\thandle = NULL;\n\t\tm_unlock(&gLock);\n\n#if 0\n\t\tperror( dlerror() );\n\n\t\tfprintf(stderr, \"open 0x%x\\n\", sOpen);\n\t\tfprintf(stderr, \"read 0x%x\\n\", sRead);\n\t\tfprintf(stderr, \"write 0x%x\\n\", sWrite);\n\t\tfprintf(stderr, \"pread 0x%x\\n\", sPread);\n\t\tfprintf(stderr, \"pwrite 0x%x\\n\", sPwrite);\n\t\tfprintf(stderr, \"lseek 0x%x\\n\", sLseek);\n\t\tfprintf(stderr, \"close 0x%x\\n\", sClose);\n\t\tfprintf(stderr, \"stat 0x%x\\n\", sStat);\n\t\tfprintf(stderr, \"stat64 0x%x\\n\", sStat64);\n\t\tfprintf(stderr, \"fstat 0x%x\\n\", sFstat);\n\t\tfprintf(stderr, \"fstat64 0x%x\\n\", sFstat64);\n\t\tfprintf(stderr, \"lstat 0x%x\\n\", sLstat);\n\t\tfprintf(stderr, \"lstat64 0x%x\\n\", sLstat64);\n\t\tfprintf(stderr, \"dup 0x%x\\n\", sDup);\n\t\tfprintf(stderr, \"fsync 0x%x\\n\", sFsync);\n\t\tfprintf(stderr, \"opendir 0x%x\\n\", sOpendir);\n\t\tfprintf(stderr, \"readdir 0x%x\\n\", sReaddir);\n\t\tfprintf(stderr, \"readdir64 0x%x\\n\", sReaddir64);\n\t\tfprintf(stderr, \"closedir 0x%x\\n\", sClosedir);\n\t\tfprintf(stderr, \"seekdir 0x%x\\n\", sSeekdir);\n\t\tfprintf(stderr, \"telldir 0x%x\\n\", sTelldir);\n\t\tfflush(stderr);\n#endif\n\t\t/* restore signal handling */\n\t\tsigprocmask(SIG_UNBLOCK, &block_set, NULL);\n\n\t\treturn -17;\n\n\n\t}\n\n\tm_unlock(&gLock);\n\n\t/* restore signal handling */\n\tsigprocmask(SIG_UNBLOCK, &block_set, NULL);\n\n\treturn 0;\n\n}\n\nint\nsystem_open(const char *fd, int flags, mode_t mode)\n{\n\treturn initIfNeeded() == 0 ? s_open(fd, flags, mode) : -1;\n}\n\nint\nsystem_read(int fd, void *buf, size_t buflen)\n{\n\treturn initIfNeeded() == 0 ? s_read( fd, buf, buflen) : -1;\n}\n\nint\nsystem_readv(int fd, const struct iovec *vector, int count)\n{\n\treturn initIfNeeded() == 0 ? s_readv( fd, vector, count) : -1;\n}\n\nint system_pread(int fd, void *buf, size_t buflen, off_t offset)\n{\n\treturn initIfNeeded() == 0 ? s_pread( fd, buf, buflen, offset) : -1;\n}\n\nint system_pread64(int fd, void *buf, size_t buflen, off64_t offset)\n{\n\treturn initIfNeeded() == 0 ? s_pread64( fd, buf, buflen, offset) : -1;\n}\n\nint system_write(int fd, const void *buf, size_t buflen)\n{\n\treturn initIfNeeded() == 0 ? s_write( fd, buf, buflen) : -1;\n}\n\nint\nsystem_writev(int fd, const struct iovec *vector, int count)\n{\n\treturn initIfNeeded() == 0 ? s_writev( fd, vector, count) : -1;\n}\n\nint system_pwrite(int fd, void *buf, size_t buflen, off_t offset)\n{\n\treturn initIfNeeded() == 0 ? s_pwrite( fd, buf, buflen, offset) : -1;\n}\n\nint system_pwrite64(int fd, void *buf, size_t buflen, off64_t offset)\n{\n\treturn initIfNeeded() == 0 ? s_pwrite64( fd, buf, buflen, offset) : -1;\n}\n\nint system_close(int fd)\n{\n\treturn initIfNeeded() == 0 ? s_close(fd) : -1;\n}\n\n\noff64_t\nsystem_lseek64(int fd, off64_t offset, int whence)\n{\n\treturn initIfNeeded() == 0 ? s_lseek64(fd, offset, whence) : -1;\n}\n\n#ifdef _STAT_VER\nint system_fstat( int fd, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_fstat64(_STAT_VER, fd, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n\n}\n\nint system_stat64( const char *path, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_stat64(_STAT_VER, path, buf) : -1;\n}\n\n\nint system_fstat64( int fd, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_fstat64(_STAT_VER, fd, buf) : -1;\n}\n\nint system_stat( const char *path, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_stat64(_STAT_VER, path, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n}\n\n\nint system_lstat( const char *path, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_lstat64(_STAT_VER, path, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n}\n\nint system_lstat64( const char *path, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_lstat64(_STAT_VER, path, buf) : -1;\n}\n#else\nint system_fstat( int fd, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_fstat64(fd, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n\n}\n\nint system_stat64( const char *path, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_stat64(path, buf) : -1;\n}\n\n\nint system_fstat64( int fd, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_fstat64(fd, buf) : -1;\n}\n\nint system_stat( const char *path, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_stat64(path, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n}\n\n\nint system_lstat( const char *path, struct stat *buf)\n{\n\tstruct stat64 s;\n\tint rc;\n\tif ( initIfNeeded() != 0 ) {\n\t\treturn -1;\n\t}\n\n\trc = s_lstat64(path, &s);\n\n\tstat64to32(buf, &s);\n\treturn rc;\n}\n\nint system_lstat64( const char *path, struct stat64 *buf)\n{\n\treturn initIfNeeded() == 0 ? s_lstat64(path, buf) : -1;\n}\n#endif\n\n\nint system_fsync(int fd)\n{\n\treturn initIfNeeded() == 0 ? s_fsync(fd) : -1;\n}\n\nint system_dup(int fd)\n{\n\treturn initIfNeeded() == 0 ? s_dup(fd) : -1;\n}\n\nDIR * system_opendir(const char *path)\n{\n\treturn initIfNeeded() == 0? s_opendir(path) : NULL;\n}\n\nint system_closedir( DIR *dir )\n{\n\treturn initIfNeeded() == 0? s_closedir(dir) : -1;\n}\n\nstruct dirent * system_readdir(DIR *dir)\n{\n\treturn initIfNeeded() == 0? s_readdir(dir) : NULL;\n}\n\nstruct dirent64 * system_readdir64(DIR *dir)\n{\n\treturn initIfNeeded() == 0? s_readdir64(dir) : NULL;\n}\n\noff_t system_telldir( DIR *dir)\n{\n\treturn initIfNeeded() == 0?  s_telldir(dir) : -1;\n}\n\nvoid system_seekdir( DIR *dir, off_t offset)\n{\n\tif ( initIfNeeded() == 0 ) {\n\t\ts_seekdir(dir, offset );\n\t}\n}\n\n\nFILE * system_fopen( const char *path, const char *mode)\n{\n\treturn initIfNeeded() == 0 ? s_fopen(path, mode) : NULL;\n}\n\nFILE * system_fopen64( const char *path, const char *mode)\n{\n\treturn initIfNeeded() == 0 ? s_fopen64(path, mode) : NULL;\n}\n\nFILE * system_fdopen( int fd, const char *mode)\n{\n\treturn initIfNeeded() == 0 ? s_fdopen(fd, mode) : NULL;\n}\n\nsize_t system_fread( void *buf, size_t i , size_t n, FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fread(buf, i, n, stream) : 0;\n}\n\nsize_t system_fwrite( const void *buf, size_t i , size_t n, FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fwrite(buf, i, n, stream) : 0;\n}\n\nint system_fclose(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fclose(stream) : -1;\n}\n\nint system_feof(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_feof(stream) : -1;\n}\n\nint system_ferror(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_ferror(stream) : -1;\n}\n\nint system_fflush(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fflush(stream) : -1;\n}\n\nlong system_ftello64(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_ftello64(stream) : -1;\n}\n\nint system_fseeko64(FILE *stream, off64_t offset, int w)\n{\n\treturn initIfNeeded() == 0 ? s_fseeko64(stream, offset, w) : -1;\n}\n\nchar * system_fgets( char *s, int size, FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fgets(s, size, stream) : NULL;\n}\n\nint system_fgetc(FILE *stream)\n{\n\treturn initIfNeeded() == 0 ? s_fgetc(stream) : -1;\n}\n\nint system_unlink(const char *path)\n{\n\treturn initIfNeeded() == 0 ? s_unlink(path) : -1;\n}\n\nint system_rmdir(const char *path)\n{\n\treturn initIfNeeded() == 0 ? s_rmdir(path) : -1;\n}\n\nint system_mkdir(const char *path, mode_t mode)\n{\n\treturn initIfNeeded() == 0 ? s_mkdir(path, mode) : -1;\n}\n\nint system_chmod(const char *path, mode_t mode)\n{\n        return initIfNeeded() == 0 ? s_chmod(path, mode) : -1;\n}\n\nint system_chown(const char *path, uid_t uid, gid_t gid)\n{\n        return initIfNeeded() == 0 ? s_chown(path, uid, gid) : -1;\n}\n\nint system_access(const char *path, int mode)\n{\n        return initIfNeeded() == 0 ? s_access(path, mode) : -1;\n}\n\n\nint system_rename(const char *oldPath, const char *newPath)\n{\n        return initIfNeeded() == 0 ? s_rename(oldPath, newPath) : -1;\n}\n\n#ifdef HAVE_ACL\nint system_acl(const char *path, int cmd, int cnt, void *buf)\n{\n        return initIfNeeded() == 0 ? s_acl(path, cmd, cnt, buf) : -1;\n}\n#endif /* HAVE_ACL */\n\n#ifdef HAVE_FACL\nint system_facl(int fd, int cmd, int cnt, void *buf)\n{\n        return initIfNeeded() == 0 ? s_facl(fd, cmd, cnt, buf) : -1;\n}\n#endif /* HAVE_FACL */\n\n#endif /* LIBC_SYSCALLS */\n",
        "/tmp/vanessa/spack-stage/spack-stage-dcap-2.47.12-6gsnz3jne4g37hyz2eyvnu7mse6xgqad/spack-src/patches/2.47.6/dcap-dlopen.patch": "diff -ur dcap-1.9.7.1.orig/src/tunnelManager.c dcap-1.9.7.1/src/tunnelManager.c\n--- dcap-1.9.7.1.orig/src/tunnelManager.c\t2010-03-09 09:47:40.028551086 +0100\n+++ dcap-1.9.7.1/src/tunnelManager.c\t2010-03-09 11:32:11.657304932 +0100\n@@ -84,6 +84,7 @@\n {\n \tvoid *handle;\n \tioTunnel *tunnel;\n+\tchar *fullpath;\n \n \tif(libname == NULL) {\n \t\tdc_debug(DC_ERROR, \"Bad tunnel name\");\n@@ -97,6 +98,14 @@\n \n \thandle = dlopen( libname, RTLD_NOW);\n \t\t\n+\tif(handle == NULL) {\n+\t\tfullpath = malloc(strlen(\"@@LIBDIR@@/dcap/\") + strlen(libname) + 1);\n+\t\tstrcpy(fullpath, \"@@LIBDIR@@/dcap/\");\n+\t\tstrcat(fullpath, libname);\n+\t\thandle = dlopen(fullpath, RTLD_NOW);\n+\t\tfree(fullpath);\n+\t}\n+\n \tif(handle == NULL) {\t\t\n \t\tgoto fail;\n \t}\n"
    },
    "skipped": [],
    "total_files": 166
}