{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/example/code_generation/gemm.c": "/*\n * Copyright 2003-2016 Jeffrey K. Hollingsworth\n *\n * This file is part of Active Harmony.\n *\n * Active Harmony is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Active Harmony is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Active Harmony.  If not, see <http://www.gnu.org/licenses/>.\n */\n#define _XOPEN_SOURCE 600 // Needed for gethostname().\n\n/*\n * This is an example of an application that uses the code-server\n * to search for code variants of a naive matrix multiplication\n * implementation for optimally performing configurations.\n *\n * The code variants are generated by the CHiLL framework.\n *   http://ctop.cs.utah.edu/ctop/?page_id=21\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <time.h>\n\n#include <mpi.h>\n#include <dlfcn.h>\n#include <sys/time.h>\n\n#include \"hclient.h\"\n#include \"defaults.h\"\n\n#define SESSION_NAME      \"gemm\"\n#define SHLIB_SYMBOL_NAME \"gemm_\"\n#define SEARCH_MAX 400\n#define N 500\n\n/*\n * ISO C forbids conversion of object pointer to function pointer.  We\n * get around this by first casting to a word-length integer.  (LP64\n * compilers assumed).\n */\n#define HACK_CAST(x) (code_t)(long)(x)\n\n/*\n * Function signature of the tuning target function produced by CHiLL.\n */\ntypedef void (*code_t)(void*, void*, void*, void*);\n\n/*\n * Internal helper function prototypes.\n */\nint    fetch_configuration(void);\nint    check_convergence(void);\nchar*  construct_so_filename(void);\nint    update_so(const char* filename);\nvoid   initialize_matrices(void);\nint    check_code_correctness(void);\nint    penalty_factor(void);\ndouble calculate_performance(double raw_perf);\ndouble timer(void);\nint    dprint(const char* fmt, ...);\nint    errprint(const char* fmt, ...);\n\n/*\n * Global variable declarations.\n */\nint debug = 1;\nint rank = -1;\nhdesc_t* hdesc;\nhtask_t* htask;\nint matrix_size = N;\n\n/*\n * Pointers to data loaded from shared libraries of generated code.\n */\nvoid* flib_eval;\ncode_t code_so;\n\n/*\n * Matrix definitions.\n */\ndouble A[N][N];\ndouble B[N][N];\ndouble C[N][N];\ndouble C_TRUTH[N][N];\n\n/*\n * Parameters that will be modified by the Harmony server.\n */\nlong TI, TJ, TK, UI, UJ;\n\ndouble time_start, time_end;\nconst char* new_code_path;\n\nint main(int argc, char* argv[])\n{\n    char numbuf[12];\n    char hostname[64];\n    int harmony_connected;\n    int node_count;\n    double time_initial, time_current, time;\n    double raw_perf, perf;\n    int i, found_iter = 0, harmonized;\n\n    // MPI Initialization.\n    MPI_Init(&argc, &argv);\n    time_initial = MPI_Wtime();\n\n    // Get the rank and size of this MPI application.\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &node_count);\n\n    // Retrieve for the host name.\n    gethostname(hostname, sizeof(hostname));\n    harmony_connected = 0;\n\n    // Initialize Harmony API.\n    hdesc = ah_alloc();\n    if (hdesc == NULL) {\n        errprint(\"Failed to initialize a Harmony session descriptor.\\n\");\n        goto cleanup;\n    }\n    ah_args(hdesc, &argc, argv);\n\n    // Set the location where new code will arrive.\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <new_code_dir>\"\n                \" [KEY_1=VAL_1] .. [KEY_N=VAL_N]\\n\\n\", argv[0]);\n        MPI_Finalize();\n        return -1;\n    }\n    new_code_path = argv[1];\n\n    if (ah_connect(hdesc, NULL, 0) != 0) {\n        errprint(\"Could not connect to Harmony tuning session: %s\\n\",\n                 ah_error());\n        MPI_Abort(MPI_COMM_WORLD, -1);\n    }\n    harmony_connected = 1;\n\n    if (rank == 0) {\n        // We are the master rank.  Establish a new Harmony tuning search.\n        hdef_t* hdef = ah_def_alloc();\n        snprintf(numbuf, sizeof(numbuf), \"%d\", node_count);\n\n        if (ah_def_name(hdef, SESSION_NAME)               != 0 ||\n            ah_def_strategy(hdef, \"pro.so\")               != 0 ||\n            ah_def_layers(hdef, \"codegen.so\")             != 0 ||\n            ah_def_cfg(hdef, CFGKEY_CLIENT_COUNT, numbuf) != 0)\n        {\n            errprint(\"Error during session configuration: %s.\\n\", ah_error());\n            goto cleanup;\n        }\n\n        if (ah_def_int(hdef, \"TI\", 2, 500, 2, NULL) != 0 ||\n            ah_def_int(hdef, \"TJ\", 2, 500, 2, NULL) != 0 ||\n            ah_def_int(hdef, \"TK\", 2, 500, 2, NULL) != 0 ||\n            ah_def_int(hdef, \"UI\", 1,   8, 1, NULL) != 0 ||\n            ah_def_int(hdef, \"UJ\", 1,   8, 1, NULL) != 0)\n        {\n            errprint(\"Failed to define tuning session: %s\\n\", ah_error());\n            goto cleanup;\n        }\n\n        htask = ah_start(hdesc, hdef);\n        ah_def_free(hdef);\n        if (!htask) {\n            errprint(\"Could not start tuning task: %s\\n\", ah_error());\n            goto cleanup;\n        }\n    }\n\n    MPI_Barrier(MPI_COMM_WORLD);\n    if (rank != 0) {\n        // Everybody else may now join the master's new Harmony search.\n        htask = ah_join(hdesc, SESSION_NAME);\n        if (!htask) {\n            errprint(\"Could not start tuning task: %s\\n\", ah_error());\n            goto cleanup;\n        }\n    }\n\n    // Associate local memory to the session's runtime tunable\n    // parameters.  For example, these represent loop tiling and\n    // unrolling factors.\n    //\n    if (ah_bind_int(htask, \"TI\", &TI) != 0 ||\n        ah_bind_int(htask, \"TJ\", &TJ) != 0 ||\n        ah_bind_int(htask, \"TK\", &TK) != 0 ||\n        ah_bind_int(htask, \"UI\", &UI) != 0 ||\n        ah_bind_int(htask, \"UJ\", &UJ) != 0)\n    {\n        errprint(\"Error binding local memory to Harmony variables.\\n\");\n        goto cleanup;\n    }\n\n    dprint(\"MPI node ready and searching for new shared objects in %s:%s\\n\",\n           hostname, new_code_path);\n\n    initialize_matrices();\n\n    dprint(\"Entering main loop.\\n\");\n    harmonized = 0;\n    for (i = 1; i < SEARCH_MAX; ++i) {\n        dprint(\"Begin iteration #%d\\n\", i);\n\n        // Retrieve a new point to test from the tuning session.\n        if (fetch_configuration() != 0)\n            goto cleanup;\n\n        memset(C, 0, sizeof(C));\n\n        // Perform and measure the client application code.\n        time_start = timer();\n        code_so(&matrix_size, A, B, C);\n        time_end = timer();\n\n        raw_perf = time_end - time_start;\n        dprint(\"Application code took %lf seconds\\n\", raw_perf);\n\n        check_code_correctness();\n\n        perf = calculate_performance(raw_perf);\n        dprint(\"TI:%ld, TJ:%ld, TK:%ld, UI:%ld, UJ:%ld = %lf\\n\",\n               TI, TJ, TK, UI, UJ, perf);\n\n        // Update the performance result.\n        if (ah_report(htask, &perf) != 0) {\n            errprint(\"Error reporting performance to server.\\n\");\n            goto cleanup;\n        }\n\n        if (!harmonized) {\n            // check_convergence() returns 0 if not converged, 1 if converged.\n            harmonized = check_convergence();\n            if (harmonized != 0 && harmonized != 1) {\n                errprint(\"Error checking harmony convergence status.\\n\");\n                goto cleanup;\n            }\n\n            if (harmonized) {\n                // Harmony server has converged, so make one final fetch\n                // to load the harmonized values, and disconnect from\n                // server.\n                //\n                if (fetch_configuration() != 0)\n                    goto cleanup;\n\n                if (ah_leave(htask) != 0) {\n                    errprint(\"Error leaving tuning session.\");\n                    goto cleanup;\n                }\n\n                // At this point, the application may continue its\n                // execution using the harmonized values without\n                // interference from the Harmony server.\n                //\n                harmony_connected = 0;\n                found_iter = i;\n            }\n        }\n        MPI_Barrier(MPI_COMM_WORLD);\n    }\n\n    // Print final book-keeping messages.\n    time_current = MPI_Wtime();\n    time = time_current - time_initial;\n    dprint(\"%.3f: machine=%s [# node_count=%i]\\n\",\n           time, hostname, node_count);\n\n    // Leave the Harmony session, if needed.\n    if (harmony_connected) {\n        if (ah_close(hdesc) != 0) {\n            errprint(\"Error disconnecting from Harmony session.\\n\");\n            harmony_connected = 0;\n            goto cleanup;\n        }\n    }\n    else {\n        dprint(\"Reached final harmonized values (TI:%ld, TJ:%ld, TK:%ld,\"\n               \" UI:%ld, UJ:%ld) at iteration %d of %d\\n\",\n               TI, TJ, TK, UI, UJ, found_iter, SEARCH_MAX);\n    }\n    MPI_Finalize();\n    return 0;\n\n  cleanup:\n    if (harmony_connected) {\n        if (ah_close(hdesc) != 0)\n            errprint(\"Error disconnecting from Harmony session.\\n\");\n    }\n    ah_free(hdesc);\n    return MPI_Abort(MPI_COMM_WORLD, -1);\n}\n\n/*\n * Internal helper function prototypes.\n */\n\ndouble timer()\n{\n    struct timeval tv;\n\n    if (gettimeofday(&tv, NULL) != 0)\n        errprint(\"Error during gettimeofday()\\n\");\n\n    return (tv.tv_sec + 1.0e-6 * tv.tv_usec);\n}\n\n/*\n * Contact tuning session to see if a new configuration is available.\n * If so, update the underlying shared object and function pointer.\n */\nint fetch_configuration(void)\n{\n    int changed = 0;\n\n    while (changed == 0) {\n        changed = ah_fetch(htask);\n\n        if (changed == 1) {\n            // Harmony updated variable values.  Load a new shared object.\n            if (update_so(construct_so_filename()) != 0) {\n                errprint(\"Could not load new code object.\");\n                return -1;\n            }\n        }\n        else if (changed == 0) {\n            // No points available from Harmony, and ah_best() failed.\n            sleep(1);\n            continue;\n        }\n        else {\n            errprint(\"Error fetching new values from Harmony server.\\n\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\n/*\n * Check if the parameter space search has converged.\n * Only rank 0 communicates directly with the Harmony server.\n */\nint check_convergence(void)\n{\n    int status;\n\n    if (rank == 0) {\n        dprint(\"Checking Harmony search status.\\n\");\n        status = ah_converged(htask);\n    }\n    else {\n        dprint(\"Waiting to hear search status from rank 0.\\n\");\n    }\n\n    // Broadcast the result of ah_converged().\n    MPI_Bcast(&status, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    return status;\n}\n\n/*\n * Construct the full pathname for the new code variant.\n */\nchar* construct_so_filename()\n{\n    static char fullpath[1024];\n\n    snprintf(fullpath, sizeof(fullpath), \"%s/gemm_%ld_%ld_%ld_%ld_%ld.so\",\n             new_code_path, TI, TJ, TK, UI, UJ);\n    return fullpath;\n}\n\n/*\n * Update the code we wish to test.\n *\n * Loads function <symbol_name> from shared object <filename>,\n * and stores that address in code_ptr.\n */\nint update_so(const char* filename)\n{\n    char* err_str;\n\n    flib_eval = dlopen(filename, RTLD_LAZY);\n    err_str = dlerror();\n    if (err_str) {\n        errprint(\"Error opening %s: %s\\n\", filename, err_str);\n        return -1;\n    }\n\n    code_so = HACK_CAST(dlsym(flib_eval, SHLIB_SYMBOL_NAME));\n    err_str = dlerror();\n    if (err_str) {\n        errprint(\"Error finding symbol \" SHLIB_SYMBOL_NAME \" in %s: %s\\n\",\n                 filename, err_str);\n        return -1;\n    }\n\n    dprint(\"Evaluation candidate updated.\\n\");\n    return 0;\n}\n\nvoid initialize_matrices(void)\n{\n    int i, j, k;\n\n    for (i = 0; i < N; ++i) {\n        for (j = 0; j < N; ++j) {\n            A[i][j] = i;\n            B[i][j] = j;\n        }\n    }\n\n    for (i = 0; i < N; ++i)\n        for (k = 0; k < N; ++k)\n            for (j = 0; j < N; ++j)\n                C_TRUTH[i][j] += A[k][i] * B[j][k];\n}\n\nint check_code_correctness(void)\n{\n    int i, j;\n    for (i=0; i<N; i++) {\n        for (j=0; j<N; j++) {\n            if(C[i][j] != C_TRUTH[i][j]) {\n                errprint(\"C_TRUTH[%d][%d]=%lf, C[%d][%d]=%lf don't match \\n\",\n                         i, j, C_TRUTH[i][j], i, j, C[i][j]);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/*\n * Illustrates the use of a local penalization technique.\n */\nint penalty_factor()\n{\n    int increment = 100;\n    int return_val = 0;\n\n    if (TI < TJ)\n        return_val += increment;\n\n    if (UI*UJ > 16)\n        return_val = return_val + (3 * increment);\n\n    return return_val;\n}\n\ndouble calculate_performance(double raw_perf)\n{\n    int result = (int)(raw_perf * 1000);\n    return (double)(result + penalty_factor());\n}\n\nint dprint(const char* fmt, ...)\n{\n    va_list ap;\n    int count;\n\n    if (!debug)\n        return 0;\n\n    va_start(ap, fmt);\n    fprintf(stderr, \"[r%d] \", rank);\n    count = vfprintf(stderr, fmt, ap);\n    va_end(ap);\n\n    return count;\n}\n\nint errprint(const char* fmt, ...)\n{\n    va_list ap;\n    int count;\n\n    va_start(ap, fmt);\n    fprintf(stderr, \"[r%d] \", rank);\n    count = vfprintf(stderr, fmt, ap);\n    va_end(ap);\n\n    return count;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/src/hinfo.c": "/*\n * Copyright 2003-2014 Jeffrey K. Hollingsworth\n *\n * This file is part of Active Harmony.\n *\n * Active Harmony is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Active Harmony is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Active Harmony.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * \\page app_hinfo Harmony Information Utility\n *\n * Hinfo is a tool used to print information about an Active Harmony\n * installation and its configuration.  The application can also\n * perform basic validation of the installation or included\n * components, and warn the user if any problems are detected.\n *\n * **Usage Syntax**\n *\n *     hinfo [flags]\n *\n * **Flag Information**\n * Flag            | Short | Description\n * --------------- | ----- | -----------\n * --home          | -h    | Print Active Harmony installation path.\n * --info=[STRING] | -i    | Display detailed information about a specific plug-in.  If the argument includes path information (a '\\' character), the string is treated as a file and opened directly.  Otherwise, HARMONY_HOME/libexec is searched for a matching plug-in (by title or filename).\n * --list          | -l    | List all available Active Harmony plug-ins.\n * --verbose       | -v    | Display verbose output during operation.\n *\n * **Usage and Output Examples**\n *\n * Many hinfo operations require a valid Active Harmony installation.\n * The location this directory is inferred or explicitly set using the\n * following rules, in decreasing order of precedence:\n *\n * 1. HARMONY_HOME environment variable.\n * 2. Invocation path of hinfo.\n * 3. PATH environment variable.\n *\n * The following example instructs hinfo to print the Active Harmony\n * installation path to be used, and verbosely explain how the path\n * was inferred.\n *\n *     $ hinfo --home -v\n *     Inferring home via PATH environment variable.\n *     Harmony home: /usr/local/packages/activeharmony/bin/..\n *\n *     $ ./bin/hinfo --home -v\n *     Inferring home via program invocation path.\n *     Harmony home: ./bin/..\n *\n * The following example instructs hinfo to list all available\n * plug-ins.  The plug-ins are listed by title (when available), and\n * file name.\n *\n *     $ hinfo --list\n *     Available strategies:\n *         exhaustive.so\n *         nemo.so\n *         nm.so\n *         pro.so\n *         random.so\n *\n *     Available processing layers:\n *         agg (agg.so)\n *         cache (cache.so)\n *         codegen (codegen.so)\n *         constraint (constraint.so)\n *         group (group.so)\n *         logger (log.so)\n *         xmlWriter (xmlWriter.so)\n *\n * Hinfo can also provide detailed information about specific\n * plug-ins.  Plug-ins may be specified by title or file name, as in\n * the following example:\n *\n *     $ hinfo -i logger\n *     Considering `log.so' as a strategy plug-in:\n *         Not a strategy: No strategy callbacks defined.\n *\n *     Considering `log.so' as a processing layer plug-in:\n *         Detected `logger' layer.  Valid callbacks defined:\n *             logger_join\n *             logger_analyze\n *             logger_init\n *             logger_fini\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <getopt.h>\n#include <dirent.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <limits.h>\n#include <libgen.h>\n\n#include \"session-core.h\"\n#include \"hmesg.h\"\n#include \"hsockutil.h\"\n#include \"hutil.h\"\n\n#define vprint(...) if (verbose) { printf(__VA_ARGS__); }\n\ntypedef enum hinfo_cmd {\n    HINFO_UNKNOWN,\n    HINFO_HOME,\n    HINFO_LIST,\n    HINFO_INFO,\n\n    HINFO_MAX\n} hinfo_cmd_t;\n\nstatic const char* strategy_required[] = {\n    \"strategy_analyze\",\n    \"strategy_generate\",\n    \"strategy_rejected\",\n    \"strategy_best\",\n    NULL\n};\n\nstatic const char* strategy_valid[] = {\n    \"strategy_init\",\n    \"strategy_fini\",\n    \"strategy_join\",\n    \"strategy_getcfg\",\n    \"strategy_setcfg\",\n    NULL\n};\n\nstatic const char* layer_suffix[] = {\n    \"join\",\n    \"generate\",\n    \"analyze\",\n    \"init\",\n    \"fini\",\n    \"getcfg\",\n    \"setcfg\",\n    NULL\n};\n\n/*\n * Internal helper function prototypes.\n */\nint   parse_opts(int argc, char* argv[]);\nchar* find_harmony_home(const char* progname);\nint   is_valid_harmony_home(const char* dir);\nint   search_libexec(void);\nvoid* find_plugin(const char* name);\nvoid  print_details(void* handle);\nchar* is_layer(void* handle);\nint   is_strategy(void* handle);\nint   qsort_strcmp(const void* a, const void* b);\n\nint   libexec_open(void);\nchar* libexec_path(void);\nvoid  libexec_close(void);\n\n// Global Variables.\nhinfo_cmd_t command;\nchar* cmd_arg;\nchar* curr_file;\nint verbose;\nchar* home_dir;\n\nchar** layer;\nint layer_len, layer_cap;\nchar** strat;\nint strat_len, strat_cap;\n\nvoid usage(const char* prog)\n{\n    fprintf(stderr, \"Usage: %s [options]\\n\", prog);\n    fprintf(stderr, \"OPTIONS:\\n\"\n\"  -h, --home        Print Active Harmony installation path.\\n\"\n\"  -i, --info=STRING Detailed information about a specific plug-in.  If the\\n\"\n\"                      argument includes path information (a '\\' character),\\n\"\n\"                      STRING is treated as a file and opened directly.\\n\"\n\"                      Otherwise, HARMONY_HOME/libexec is searched for a\\n\"\n\"                      matching plug-in (by title or filename).\\n\"\n\"  -l, --list        List all available Active Harmony plug-ins.\\n\"\n\"  -v, --verbose     Print additional information during operation.\\n\");\n}\n\nint main(int argc, char* argv[])\n{\n    int i, retval = 0;\n    void* handle;\n\n    if (parse_opts(argc, argv) != 0)\n        goto error;\n\n    switch (command) {\n    case HINFO_HOME:\n        home_dir = find_harmony_home(argv[0]);\n        printf(\"Harmony home: %s\\n\", home_dir);\n        break;\n\n    case HINFO_LIST:\n        home_dir = find_harmony_home(argv[0]);\n        if (search_libexec() != 0)\n            goto error;\n\n        printf(\"Available strategies:\\n\");\n        for (i = 0; i < strat_len; ++i) {\n            printf(\"    %s\\n\", strat[i]);\n            free(strat[i]);\n        }\n        printf(\"\\n\");\n        free(strat);\n\n        printf(\"Available processing layers:\\n\");\n        for (i = 0; i < layer_len; ++i) {\n            printf(\"    %s\\n\", layer[i]);\n            free(layer[i]);\n        }\n        printf(\"\\n\");\n        free(layer);\n\n        break;\n\n    case HINFO_INFO:\n        if (strchr(cmd_arg, '/')) {\n            // Argument includes path information.  Open the file directly.\n            handle = dlopen(cmd_arg, RTLD_LAZY | RTLD_LOCAL);\n            if (!handle) {\n                fprintf(stderr, \"Could not dlopen %s: %s\\n\",\n                            cmd_arg, dlerror());\n                goto error;\n            }\n            curr_file = stralloc(cmd_arg);\n        }\n        else {\n            home_dir = find_harmony_home(argv[0]);\n\n            // Open the file in HARMONY_HOME/libexec.\n            errno = 0;\n            handle = find_plugin(cmd_arg);\n            if (!handle) {\n                fprintf(stderr, \"Could not find plug-in named %s.\\n\", cmd_arg);\n                goto error;\n            }\n        }\n\n        print_details(handle);\n        if (dlclose(handle) != 0)\n            fprintf(stderr, \"Warning: Could not close\"\n                    \" dynamic library %s: %s\\n\", curr_file, dlerror());\n\n        free(curr_file);\n        break;\n\n    default:\n        usage(argv[0]);\n        fprintf(stderr, \"\\nNo operation requested.\\n\");\n    }\n    goto cleanup;\n\n  error:\n    retval = -1;\n\n  cleanup:\n    free(home_dir);\n    return retval;\n}\n\nint parse_opts(int argc, char* argv[])\n{\n    int c;\n    static struct option long_options[] = {\n        {\"home\",    no_argument,       NULL, 'h'},\n        {\"info\",    required_argument, NULL, 'i'},\n        {\"list\",    no_argument,       NULL, 'l'},\n        {\"verbose\", no_argument,       NULL, 'v'},\n        {NULL, 0, NULL, 0}\n    };\n\n    while (1) {\n        c = getopt_long(argc, argv, \":hi:lv\", long_options, NULL);\n        if (c == -1)\n            break;\n\n        switch(c) {\n        case 'h': command = HINFO_HOME; break;\n        case 'i': command = HINFO_INFO; cmd_arg = optarg; break;\n        case 'l': command = HINFO_LIST; break;\n        case 'v': verbose = 1; break;\n\n        case ':':\n            usage(argv[0]);\n            fprintf(stderr, \"\\nOption ('%c') requires an argument.\\n\", optopt);\n            break;\n\n        case '?':\n        default:\n            usage(argv[0]);\n            fprintf(stderr, \"\\nInvalid argument ('%c').\\n\", optopt);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n/*\n * Determine the location of the Active Harmony installation directory.\n */\nchar* find_harmony_home(const char* argv0)\n{\n    char* retval;\n    int home_from_env = 0;\n\n    // First check HARMONY_HOME environment variable.\n    retval = getenv(\"HARMONY_HOME\");\n    if (retval) {\n        vprint(\"Found home via HARMONY_HOME environment variable.\\n\");\n\n        retval = stralloc(retval);\n        if (!retval) {\n            perror(\"Could not allocate memory for home path\");\n            exit(-1);\n        }\n        home_from_env = 1;\n    }\n    // See if program invocation specified a path.\n    else if (strchr(argv0, '/')) {\n        vprint(\"Inferring home via program invocation path.\\n\");\n\n        retval = sprintf_alloc(\"%s   \", argv0); // Allocate 3 extra chars.\n        if (!retval) {\n            perror(\"Could not allocate memory for home path\");\n            exit(-1);\n        }\n        retval = dirname(retval);\n        strcat(retval, \"/..\");\n    }\n    // As a last resort, search the PATH environment variable.\n    else {\n        char* dirpath;\n        char* tmpbuf = stralloc(argv0);\n\n        if (!tmpbuf) {\n            perror(\"Could not allocate temporary memory for program name\");\n            exit(-1);\n        }\n\n        dirpath = search_path( basename(tmpbuf) );\n        if (!dirpath) {\n            fprintf(stderr, \"Could not find HARMONY_HOME\\n\");\n            exit(-1);\n        }\n        vprint(\"Inferring home via PATH environment variable.\\n\");\n\n        retval = sprintf_alloc(\"%s/..\", dirname(dirpath));\n        if (!retval) {\n            perror(\"Could not allocate memory for home path\");\n            exit(-1);\n        }\n        free(tmpbuf);\n    }\n\n    if (!is_valid_harmony_home(retval)) {\n        if (home_from_env) {\n            fprintf(stderr, \"HARMONY_HOME (\\\"%s\\\") does not refer to a valid\"\n                    \" Active Harmony installation directory.\\n\", retval);\n        }\n        else {\n            fprintf(stderr, \"%s is not within a valid Active Harmony\"\n                    \" installation directory.\\n\", argv0);\n        }\n        exit(-1);\n    }\n\n    return retval;\n}\n\nint is_valid_harmony_home(const char* dir)\n{\n    static const char* home_file[] = {\n        // Not a complete list.  Just enough to move forward confidently.\n        \"bin/hinfo\",\n        \"bin/tuna\",\n        \"libexec/random.so\",\n        NULL\n    };\n    int i, valid = 1;\n    char* tmpbuf;\n\n    for (i = 0; valid && home_file[i]; ++i) {\n        tmpbuf = sprintf_alloc(\"%s/%s\", dir, home_file[i]);\n        if (!tmpbuf) {\n            perror(\"Could not allocate memory for file path\");\n            exit(-1);\n        }\n\n        if (!file_exists(tmpbuf))\n            valid = 0;\n\n        free(tmpbuf);\n    }\n    return valid;\n}\n\nint search_libexec(void)\n{\n    int retval = 0;\n\n    if (libexec_open() != 0)\n        return -1;\n\n    while (1) {\n        void* handle;\n        char* fname = libexec_path();\n        if (!fname)\n            break;\n\n        handle = dlopen(fname, RTLD_LAZY | RTLD_LOCAL);\n        if (handle) {\n            char* base = basename(fname);\n            char* prefix;\n\n            prefix = is_layer(handle);\n            if (prefix) {\n                if (layer_len == layer_cap) {\n                    if (array_grow(&layer, &layer_cap, sizeof(char*)) != 0) {\n                        perror(\"Could not grow layer list\");\n                        exit(-1);\n                    }\n                }\n                layer[layer_len] = sprintf_alloc(\"%s (%s)\", prefix, base);\n                if (!layer[layer_len]) {\n                    perror(\"Could not allocate layer list entry\");\n                    exit(-1);\n                }\n                ++layer_len;\n            }\n\n            if (is_strategy(handle)) {\n                if (strat_len == strat_cap) {\n                    if (array_grow(&strat, &strat_cap, sizeof(char*)) != 0) {\n                        perror(\"Could not grow strategy list\");\n                        exit(-1);\n                    }\n                }\n                strat[strat_len] = stralloc(base);\n                if (!strat[strat_len]) {\n                    perror(\"Could not allocate strategy list entry\");\n                    exit(-1);\n                }\n                ++strat_len;\n            }\n\n            if (dlclose(handle) != 0)\n                fprintf(stderr, \"Warning: Could not close\"\n                        \" dynamic library %s: %s\\n\", base, dlerror());\n        }\n    }\n    if (errno) {\n        retval = -1;\n    }\n    libexec_close();\n\n    qsort(layer, layer_len, sizeof(char*), qsort_strcmp);\n    qsort(strat, strat_len, sizeof(char*), qsort_strcmp);\n    return retval;\n}\n\nvoid* find_plugin(const char* name)\n{\n    char* tail;\n    int by_filename;\n    void* handle = NULL;\n\n    if (libexec_open() != 0)\n        return NULL;\n\n    // If the search name ends with .so, search libexec by filename.\n    // Otherwise, search libexec by plug-in title.\n    tail = strrchr(name, '.');\n    by_filename = (tail && strcmp(tail, \".so\") == 0);\n\n    while (!handle) {\n        char* fname = libexec_path();\n        if (!fname)\n            break;\n\n        if (by_filename) {\n            tail = strrchr(fname, '/');\n            if (tail && strcmp(++tail, name) == 0) {\n                handle = dlopen(fname, RTLD_LAZY | RTLD_LOCAL);\n                if (!handle) {\n                    fprintf(stderr, \"Could not dlopen %s: %s\\n\",\n                            tail, dlerror());\n                }\n                curr_file = stralloc(name);\n            }\n        }\n        else {\n            handle = dlopen(fname, RTLD_LAZY | RTLD_LOCAL);\n            if (handle) {\n                char* title = dlsym(handle, \"harmony_layer_name\");\n                if (title && strcmp(title, name) == 0) {\n                    curr_file = stralloc( basename(fname) );\n                }\n                else {\n                    if (dlclose(handle) != 0) {\n                        fprintf(stderr, \"Warning: Could not\"\n                                \" close dynamic library %s: %s\\n\",\n                                basename(fname), dlerror());\n                    }\n                    handle = NULL;\n                }\n            }\n        }\n    }\n\n    libexec_close();\n    return handle;\n}\n\nvoid print_details(void* handle)\n{\n    int i, some_defined;\n    const char* prefix;\n\n    // Strategy plug-in analysis.\n    some_defined = 0;\n    for (i = 0; strategy_required[i]; ++i)\n        if (dlsym(handle, strategy_required[i]))\n            some_defined = 1;\n\n    for (i = 0; strategy_valid[i]; ++i)\n        if (dlsym(handle, strategy_valid[i]))\n            some_defined = 1;\n\n    printf(\"Considering `%s' as a strategy plug-in:\\n\", curr_file);\n    if (some_defined) {\n        if (is_strategy(handle)) {\n            printf(\"    Callbacks defined:\\n\");\n            for (i = 0; strategy_required[i]; ++i) {\n                if (dlsym(handle, strategy_required[i]))\n                    printf(\"        %s\\n\", strategy_required[i]);\n            }\n\n            for (i = 0; strategy_valid[i]; ++i) {\n                if (dlsym(handle, strategy_valid[i]))\n                    printf(\"        %s\\n\", strategy_valid[i]);\n            }\n        }\n        else {\n            printf(\"    Not a valid strategy.  Missing required callbacks:\\n\");\n            for (i = 0; strategy_required[i]; ++i) {\n                if (!dlsym(handle, strategy_required[i]))\n                    printf(\"        %s\\n\", strategy_required[i]);\n            }\n        }\n    }\n    else {\n        printf(\"    Not a strategy: No strategy callbacks defined.\\n\");\n    }\n    printf(\"\\n\");\n\n    // Processing layer plug-in analysis.\n    printf(\"Considering `%s' as a processing layer plug-in:\\n\", curr_file);\n    prefix = dlsym(handle, \"harmony_layer_name\");\n    if (prefix) {\n        if (is_layer(handle)) {\n            printf(\"    Detected layer `%s'.  Callbacks defined:\\n\", prefix);\n            for (i = 0; layer_suffix[i]; ++i) {\n                char* fname = sprintf_alloc(\"%s_%s\", prefix, layer_suffix[i]);\n                if (!fname) {\n                    perror(\"Could not allocate layer function name\");\n                    exit(-1);\n                }\n\n                if (dlsym(handle, fname)) {\n                    printf(\"        %s\\n\", fname);\n                }\n                free(fname);\n            }\n        }\n        else {\n            printf(\"    Not a valid processing layer.  No required callbacks\"\n                   \" defined:\\n\");\n            printf(\"        %s_analyze\\n\", prefix);\n            printf(\"        %s_generate\\n\", prefix);\n        }\n    }\n    else {\n        printf(\"    Not a processing layer: harmony_layer_name not found.\\n\");\n    }\n    printf(\"\\n\");\n}\n\n/* Quick check for required processing layer plug-in function symbols\n * within shared library.\n *\n * Returns the defined layer name.\n */\nchar* is_layer(void* handle)\n{\n    int valid = 0;\n    char* prefix;\n    char* fname;\n\n    // Plugin layers must define a layer name.\n    prefix = dlsym(handle, \"harmony_layer_name\");\n    if (!prefix)\n        return NULL;\n\n    // Then, either <prefix>_generate or <prefix>_analyze must be defined.\n    fname = sprintf_alloc(\"%s_generate\", prefix);\n    if (!fname) {\n        perror(\"Could not allocate space for function name\");\n        exit(-1);\n    }\n\n    if (dlsym(handle, fname) != NULL) {\n        valid = 1;\n    }\n    else {\n        sprintf(fname, \"%s_analyze\", prefix);\n        if (dlsym(handle, fname) != NULL)\n            valid = 1;\n    }\n    free(fname);\n\n    return (valid ? prefix : NULL);\n}\n\n/*\n * Quick check for required strategy plug-in function symbols within\n * shared library.\n */\nint is_strategy(void* handle)\n{\n    int i;\n\n    for (i = 0; strategy_required[i]; ++i) {\n        if (dlsym(handle, strategy_required[i]) == NULL)\n            return 0;\n    }\n    return 1;\n}\n\nint qsort_strcmp(const void* a, const void* b)\n{\n    char* const* _a = a;\n    char* const* _b = b;\n    return strcmp(*_a, *_b);\n}\n\n/*\n * The following three utility functions are used to search the\n * libexec directory.\n */\nstatic DIR* dp;\nstatic char* path;\nstatic int cap;\n\nint libexec_open(void)\n{\n    if (!path) {\n        cap = 1024;\n        path = malloc(cap * sizeof(*path));\n        if (!path) {\n            perror(\"Could not allocate memory for libexec filename\");\n            exit(-1);\n        }\n    }\n\n    if (!dp) {\n        // Open the libexec directory, if DIR pointer isn't set.\n        while (snprintf(path, cap, \"%s/libexec\", home_dir) >= cap) {\n            if (array_grow(&path, &cap, sizeof(*path)) != 0) {\n                perror(\"Could not grow memory for libexec directory path\");\n                exit(-1);\n            }\n        }\n\n        dp = opendir(path);\n        if (!dp) {\n            perror(\"Could not open Harmony's libexec directory\");\n            return -1;\n        }\n        vprint(\"Performing scan of HARMONY_HOME (`%s') directory.\\n\", path);\n    }\n    else {\n        rewinddir(dp);\n    }\n    return 0;\n}\n\nchar* libexec_path(void)\n{\n    while (1) {\n        char* file;\n        struct dirent* entry;\n        struct stat finfo;\n\n        errno = 0;\n        entry = readdir(dp);\n        if (entry == NULL) {\n            if (errno) {\n                perror(\"Could not retrieve directory entry\");\n            }\n            break;\n        }\n        file = entry->d_name;\n\n        // Build the file path string.\n        while (snprintf(path, cap, \"%s/libexec/%s\", home_dir, file) >= cap) {\n            if (array_grow(&path, &cap, sizeof(*path)) != 0) {\n                perror(\"Could not grow memory for libexec file path\");\n                exit(-1);\n            }\n        }\n\n        // Request file metadata.\n        if (stat(path, &finfo) != 0) {\n            vprint(\"  Skipping %s: stat error: %s\\n\", file, strerror(errno));\n            continue;\n        }\n\n        // Only consider regular files.\n        if (!S_ISREG(finfo.st_mode)) {\n            vprint(\"  Skipping %s: non-regular file.\\n\", file);\n            continue;\n        }\n\n        // Path now contains a regular file within libexec.\n        vprint(\"  Considering %s.\\n\", file);\n        return path;\n    }\n    return NULL;\n}\n\nvoid libexec_close(void)\n{\n    if (dp) {\n        vprint(\"Directory scan complete.\\n\");\n        if (closedir(dp) != 0) {\n            perror(\"Could not close DIR pointer\");\n        }\n        dp = NULL;\n    }\n\n    if (path) {\n        free(path);\n        path = NULL;\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/src/hplugin.c": "/*\n * Copyright 2003-2016 Jeffrey K. Hollingsworth\n *\n * This file is part of Active Harmony.\n *\n * Active Harmony is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Active Harmony is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Active Harmony.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"hplugin.h\"\n#include \"hutil.h\"\n\n#include <stdlib.h> // For NULL and free().\n#include <string.h> // For memset().\n#include <dlfcn.h>  // For dlopen(), dlsym(), dlerror(), and dlclose().\n\nconst hplugin_t hplugin_zero = HPLUGIN_INITIALIZER;\n\n/*\n * Internal helper function prototypes.\n */\nstatic int load_hooks(hplugin_t* plugin);\nstatic int verify_hooks(hplugin_t* plugin, const char** errptr);\nstatic int verify_type(hplugin_t* plugin, const char** errptr);\n\n/*\n * Base structure management implementation.\n */\n\nint hplugin_open(hplugin_t* plugin, const char* filename, const char** errptr)\n{\n    const char* errstr;\n\n    // Tabula rasa.\n    memset(plugin, 0, sizeof(*plugin));\n\n    plugin->handle = dlopen(filename, RTLD_LAZY | RTLD_LOCAL);\n    if (!plugin->handle) {\n        errstr = dlerror();\n        goto error;\n    }\n\n    // Find plug-in variables.\n    plugin->type_str = dlsym(plugin->handle, \"hplugin_type\");\n    plugin->name     = dlsym(plugin->handle, \"hplugin_name\");\n    plugin->keyinfo  = dlsym(plugin->handle, \"hplugin_keyinfo\");\n\n    if (verify_type(plugin, &errstr) != 0)\n        return -1;\n\n    if (load_hooks(plugin) != 0) {\n        errstr = \"Could not allocate memory for plug-in symbol\";\n        goto error;\n    }\n\n    if (verify_hooks(plugin, &errstr) != 0)\n        return -1;\n\n    if (plugin->alloc) {\n        plugin->data = plugin->alloc();\n        if (!plugin->data) {\n            errstr = \"Could not allocate private data for plug-in\";\n            goto error;\n        }\n    }\n\n    return 0;\n\n  error:\n    if (plugin->handle)\n        dlclose(plugin->handle);\n\n    if (errptr)\n        *errptr = errstr;\n    return -1;\n}\n\nint hplugin_close(hplugin_t* plugin, const char** errptr)\n{\n    const char* errstr;\n\n    if (dlclose(plugin->handle) != 0) {\n        if (errptr) {\n            errstr = dlerror();\n            goto error;\n        }\n    }\n\n    return 0;\n\n  error:\n    if (errptr)\n        *errptr = errstr;\n    return -1;\n}\n\n/*\n * Event function calling interface.\n */\n\nint hplugin_analyze(hplugin_t* plugin, hflow_t* flow, htrial_t* trial)\n{\n    if (plugin->type == HPLUGIN_STRATEGY) {\n        return plugin->strategy.analyze(plugin->data, trial);\n    }\n    else if (plugin->type == HPLUGIN_LAYER) {\n        if (plugin->layer.analyze)\n            return plugin->layer.analyze(plugin->data, flow, trial);\n    }\n    return 0;\n}\n\nint hplugin_best(hplugin_t* plugin, hpoint_t* point)\n{\n    if (plugin->type != HPLUGIN_STRATEGY)\n        return -1;\n\n    if (plugin->strategy.best)\n        return plugin->strategy.best(plugin->data, point);\n    else\n        return 0;\n}\n\nint hplugin_generate(hplugin_t* plugin, hflow_t* flow, htrial_t* trial)\n{\n    if (plugin->type == HPLUGIN_STRATEGY) {\n        hpoint_t* point = (hpoint_t*) &trial->point;\n        return plugin->strategy.generate(plugin->data, flow, point);\n    }\n    else if (plugin->type == HPLUGIN_LAYER) {\n        if (plugin->layer.generate)\n            return plugin->layer.generate(plugin->data, flow, trial);\n    }\n    return 0;\n}\n\nint hplugin_rejected(hplugin_t* plugin, hflow_t* flow, htrial_t* trial)\n{\n    if (plugin->type != HPLUGIN_STRATEGY)\n        return -1;\n\n    hpoint_t* point = (hpoint_t*) &trial->point;\n    return plugin->strategy.rejected(plugin->data, flow, point);\n}\n\nint hplugin_init(hplugin_t* plugin, hspace_t* space)\n{\n    if (plugin->init)\n        return plugin->init(plugin->data, space);\n    else\n        return 0;\n}\n\nint hplugin_join(hplugin_t* plugin, const char* client)\n{\n    if (plugin->join)\n        return plugin->join(plugin->data, client);\n    else\n        return 0;\n}\n\nint hplugin_setcfg(hplugin_t* plugin, const char* key, const char* val)\n{\n    if (plugin->setcfg)\n        return plugin->setcfg(plugin->data, key, val);\n    else\n        return 0;\n}\n\nint hplugin_fini(hplugin_t* plugin)\n{\n    if (plugin->fini)\n        return plugin->fini(plugin->data);\n    else\n        return 0;\n}\n\n/*\n * Internal helper function implementation.\n */\n\n/*\n * ISO C forbids conversion of object pointers to function pointers,\n * making it difficult to use dlsym() for functions.  We get around\n * this by first casting to a word-length integer.  (ILP32/LP64\n * compilers assumed).\n */\n#define dlfptr(x, y) ((void*) (void (*)(void))(long)(dlsym((x), (y))))\n\nint load_hooks(hplugin_t* plugin)\n{\n    const char* prefix = plugin->name;\n    void*       handle = plugin->handle;\n\n    char* buf = NULL;\n    int   len = 0;\n    int   retval = 0;\n\n    if (plugin->type == HPLUGIN_STRATEGY) {\n        // Find strategy specific event functions.\n        plugin->strategy.generate =\n            (strategy_generate_t) dlfptr(handle, \"strategy_generate\");\n        plugin->strategy.rejected =\n            (strategy_rejected_t) dlfptr(handle, \"strategy_rejected\");\n        plugin->strategy.analyze =\n            (strategy_analyze_t) dlfptr(handle, \"strategy_analyze\");\n        plugin->strategy.best =\n            (strategy_best_t) dlfptr(handle, \"strategy_best\");\n        prefix = \"strategy\";\n    }\n    else if (plugin->type == HPLUGIN_LAYER) {\n        // Find layer specific event functions.\n        if (snprintf_grow(&buf, &len, \"%s_generate\", prefix) < 0) goto error;\n        plugin->layer.generate = (layer_generate_t) dlfptr(handle, buf);\n\n        if (snprintf_grow(&buf, &len, \"%s_analyze\", prefix) < 0) goto error;\n        plugin->layer.analyze = (layer_analyze_t) dlfptr(handle, buf);\n    }\n\n    // Load optional plug-in hooks.\n    if (snprintf_grow(&buf, &len, \"%s_alloc\", prefix) < 0) goto error;\n    plugin->alloc = (hook_alloc_t) dlfptr(handle, buf);\n\n    if (snprintf_grow(&buf, &len, \"%s_init\", prefix) < 0) goto error;\n    plugin->init = (hook_init_t) dlfptr(handle, buf);\n\n    if (snprintf_grow(&buf, &len, \"%s_join\", prefix) < 0) goto error;\n    plugin->join = (hook_join_t) dlfptr(handle, buf);\n\n    if (snprintf_grow(&buf, &len, \"%s_setcfg\", prefix) < 0) goto error;\n    plugin->setcfg = (hook_setcfg_t) dlfptr(handle, buf);\n\n    if (snprintf_grow(&buf, &len, \"%s_fini\", prefix) < 0) goto error;\n    plugin->fini = (hook_fini_t) dlfptr(handle, buf);\n\n    goto cleanup;\n\n  error:\n    retval = -1;\n\n  cleanup:\n    free(buf);\n    return retval;\n}\n\nint verify_hooks(hplugin_t* plugin, const char** errptr)\n{\n    if (plugin->type == HPLUGIN_STRATEGY) {\n        if (!plugin->strategy.generate) {\n            *errptr = \"Strategy plug-in missing symbol: strategy_generate\";\n            return -1;\n        }\n\n        if (!plugin->strategy.analyze) {\n            *errptr = \"Strategy plug-in missing symbol: strategy_analyze\";\n            return -1;\n        }\n\n        if (!plugin->strategy.rejected) {\n            *errptr = \"Strategy plug-in missing symbol: strategy_rejected\";\n            return -1;\n        }\n\n        if (!plugin->strategy.best) {\n            *errptr = \"Strategy plug-in missing symbol: strategy_best\";\n            return -1;\n        }\n    }\n    else if (plugin->type == HPLUGIN_LAYER) {\n        if (!plugin->layer.generate &&\n            !plugin->layer.analyze &&\n            !plugin->init &&\n            !plugin->join &&\n            !plugin->setcfg)\n        {\n            *errptr = \"Layer plug-in does not define any event functions\";\n            return -1;\n        }\n    }\n    else {\n        *errptr = \"Improper Active Harmony plug-in type\";\n        return -1;\n    }\n\n    return 0;\n}\n\nint verify_type(hplugin_t* plugin, const char** errptr)\n{\n    if (!plugin->type_str) {\n        *errptr = \"Library is not an Active Harmony plug-in\";\n        return -1;\n    }\n    else if (strcmp(plugin->type_str, \"strategy\") == 0) {\n        plugin->type = HPLUGIN_STRATEGY;\n    }\n    else if (strcmp(plugin->type_str, \"layer\") == 0) {\n        if (!plugin->name) {\n            *errptr = \"Layer plug-in does not define its name\";\n            return -1;\n        }\n        plugin->type = HPLUGIN_LAYER;\n    }\n    else {\n        *errptr = \"Unknown Active Harmony plug-in type\";\n        return -1;\n    }\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/gemm/code.properties": "#!/bin/bash\n\n# this is a global \"properties\" file for code-generation.\n#  Please note that there are no spaces between the lvalue and\n#  the rvalue in variable definitions. Some versions of bash\n#  do not like the spaces. So - sticking with the one that works\n#  for all.\n\necho \"initializing\"\n\n##################### CHiLL, OMEGA, SUIF Paths\n# exports: indicate where the CHiLL components and libraries are.\n\nCHILLHOME=\nOMEGA_P=\nSUIFHOME=\n\nif [ -n \"$CHILLHOME\" ]; then\n    PATH=$CHILLHOME/bin:$PATH\nfi\n\nif [ -n \"$OMEGA_P\" ]; then\n    export OMEGA_P\nfi\n\nif [ -n \"$SUIFHOME\" ]; then\n    PATH=$SUIFHOME/i386-linux/bin/:$PATH\n    LD_LIBRARY_PATH=$SUIFHOME/i386-linux/solib:$LD_LIBRARY_PATH\nfi\n\nexport PATH LD_LIBRARY_PATH\n########################################\n\n###################### loop names, languages\n# remember that the appname should be the same as the directory name\n#  for the loop. For example, if you want to tune for dgemv, you will have\n#  to create a directory named \"dgemv\" within the code-generator directory\n#  and have all the files necessary there.\nappname=gemm\nfile_prefix=gemm\n# fortran or c file?\nfile_suffix=f\n########################################\n\n###################### are we using a particular CHiLL version\nuse_default_chill=1\n# if we are not using the default CHiLL, tell me what version of CHiLL you\n#  want to use. Also - make sure you include this name in the \n#  required_files.dat so that this executable can be copied to all the\n#  code generation hosts.\n# Note the \"./\" which is required.\nchill_exec_name=\"./chill.v.0.1.8 \"\n\n###################### local and remote hosts spec\n# are we using remote hosts for compilation?\nuse_remote_hosts=1\n# if use_remote_host is set to 1, we also need to provide the following \n#  parameters. username is your username\n#username=\n\n###################### COMPILATION\n# what format should we compile the file into? If you are dynamically loading\n#  the new code using dlopen/dlsym, we should compile the code to .so. If\n#  we are compiling this to an executable, then we can set this suffix to\n#  \".exe\". For compiling to .exe, the assumption is that the user provides a\n#  driver.c (or f) and is listed as one of the required files for code generation\n#  in \"required_files.dat\" file.\n# driver.c (or f) will be linked with the new code. So when you run the code, the\n#  performance will reflect the change in the parameters.\noutput_file_suffix=so\n\n# need to provide this only if we are compiling to a .exe\ndriver_filename=driver.c\n\n# fortran compilation (note the trailing space in the end, which is needed).\nFC_COMMAND=\"gfortran -m32 -O3 \"\n\n# c compilation (note the trailing space in the end, which is needed).\nCC_COMMAND=\"gcc -m32 -O3 \"   \n",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/generic/code.properties": "#!/bin/bash\n\n# this is a global \"properties\" file for code-generation.\n#  Please note that there are no spaces between the lvalue and\n#  the rvalue in variable definitions. Some versions of bash\n#  do not like the spaces. So - sticking with the one that works\n#  for all.\n\necho \"initializing\"\n\n##################### CHiLL, OMEGA, SUIF Paths\n### These definitions probably won't change.\n# exports: indicate where the CHiLL components and libraries are.\n# Here the assumption is that CHiLL components are installed in their\n#  respective directories. If not, please make a change here. Maybe they\n#  installed in $HOME/projects/ directory?\n\nexport OMEGA_P=$HOME/omega\nexport SUIFHOME=$HOME/suifhome\nexport PATH=$HOME/chill/bin:${SUIFHOME}/i386-linux/bin/:${PATH}\nexport LD_LIBRARY_PATH=${SUIFHOME}/i386-linux/solib:${LD_LIBRARY_PATH}\n########################################\n\n###################### loop names, languages\n# remember that the appname should be the same as the directory name\n#  for the loop. For example, if you want to tune for dgemv, you will have\n#  to create a directory named \"dgemv\" within the code-generator directory\n#  and have all the files necessary there.\nappname=gemm\nfile_prefix=gemm\n# fortran or c file?\nfile_suffix=f\n########################################\n\n###################### are we using a particular CHiLL version\nuse_default_chill=1\n# if we are not using the default CHiLL, tell me what version of CHiLL you\n#  want to use. Also - make sure you include this name in the \n#  required_files.dat so that this executable can be copied to all the\n#  code generation hosts.\n# Note the \"./\" which is required.\nchill_exec_name=\"./chill.v.0.1.8 \"\n\n###################### local and remote hosts spec\n# are we using remote hosts for compilation?\nuse_remote_hosts=0\n# if use_remote_host is set to 1, we also need to provide the following \n#  parameters. username is your username\n#username=\n\n###################### COMPILATION\n# what format should we compile the file into? If you are dynamically loading\n#  the new code using dlopen/dlsym, we should compile the code to .so. If\n#  we are compiling this to an executable, then we can set this suffix to\n#  \".exe\". For compiling to .exe, the assumption is that the user provides a\n#  driver.c (or f) and is listed as one of the required files for code generation\n#  in \"required_files.dat\" file.\n# driver.c (or f) will be linked with the new code. So when you run the code, the\n#  performance will reflect the change in the parameters.\noutput_file_suffix=so\n\n# need to provide this only if we are compiling to a .exe\ndriver_filename=driver.c\n\n# fortran compilation (note the trailing space in the end, which is needed).\nFC_COMMAND=\"gfortran -O3 \"\n\n# c compilation (note the trailing space in the end, which is needed).\nCC_COMMAND=\"gcc -O3 \"   \n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/irs/rmatmult3_at.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/irs/rmatmult3_at.spd",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/irs/rmatmult3_at.sp1",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/gemm/gemm.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/gemm/gemm_at.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/generic/gemm.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/generic/gemm_at.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/smg2000/OUT__1__6119__.spd",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/smg2000/OUT__1__6119__.spd.64",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/smg2000/OUT__1__6119__.sp1",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/smg2000/OUT__1__6119__.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/code-server/smg2000/OUT__1__6119__.spd.32",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/hserver1.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/hserver2.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/arrowdown.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/arrowright.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.6.0-fefqlbdzhdk22psmjtxyfeqjruxye4tl/spack-src/doc/Users_Guide.html/search/search_l.png"
    ],
    "total_files": 312
}