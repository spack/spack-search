{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/example/code_generation/gemm.c": "/*\n * Copyright 2003-2013 Jeffrey K. Hollingsworth\n *\n * This file is part of Active Harmony.\n *\n * Active Harmony is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Active Harmony is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Active Harmony.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * This is an example of an application that uses the code-server\n * to search for code variants of a naive matrix multiplication\n * implementation for optimally performing configurations.\n *\n * The code variants are generated by the CHiLL framework.\n *   http://ctop.cs.utah.edu/ctop/?page_id=21\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <time.h>\n\n#include <mpi.h>\n#include <dlfcn.h>\n#include <sys/time.h>\n\n#include \"hclient.h\"\n#include \"defaults.h\"\n\n#define SESSION_NAME      \"gemm\"\n#define SHLIB_SYMBOL_NAME \"gemm_\"\n#define SEARCH_MAX 400\n#define N 500\n\n/* ISO C forbids conversion of object pointer to function pointer.  We\n * get around this by first casting to a word-length integer.  (LP64\n * compilers assumed).\n */\n#define HACK_CAST(x) (code_t)(long)(x)\n\n/* Function signature of the tuning target function produced by CHiLL. */\ntypedef void (*code_t)(void *, void *, void *, void *);\n\n/*\n * Function Prototypes\n */\nint    fetch_configuration(void);\nint    check_convergence(hdesc_t *hdesc);\nchar * construct_so_filename(void);\nint    update_so(const char *filename);\nvoid   initialize_matrices(void);\nint    check_code_correctness(void);\nint    penalty_factor(void);\ndouble calculate_performance(double raw_perf);\ndouble timer(void);\nint    dprint(const char *fmt, ...);\nint    errprint(const char *fmt, ...);\n/*\n * Global variable declarations.\n */\nint debug = 1;\nint rank = -1;\nhdesc_t *hdesc = NULL;\nint matrix_size = N;\n\n/* Pointers to data loaded from shared libraries of generated code. */\nvoid *flib_eval;\ncode_t code_so;\n\n/*\n * Matrix definitions.\n */\ndouble A[N][N];\ndouble B[N][N];\ndouble C[N][N];\ndouble C_TRUTH[N][N];\n\n/* Parameters that will be modified by the Harmony server. */\nlong TI, TJ, TK, UI, UJ;\n\ndouble time_start, time_end;\nconst char *new_code_path;\n\nint main(int argc, char *argv[])\n{\n    char numbuf[12];\n    char hostname[64];\n    int harmony_connected;\n    int node_count;\n    double time_initial, time_current, time;\n    double raw_perf, perf;\n    int i, found_iter, harmonized;\n\n    /* MPI Initialization */\n    MPI_Init(&argc, &argv);\n    time_initial = MPI_Wtime();\n\n    /* Set the location where new code will arrive. */\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <new_code_dir>\"\n                \" [KEY_1=VAL_1] .. [KEY_N=VAL_N]\\n\\n\", argv[0]);\n        MPI_Finalize();\n        return -1;\n    }\n    new_code_path = argv[1];\n\n    /* Get the rank and size of this MPI application. */\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &node_count);\n\n    /* Retrieve for the host name */\n    gethostname(hostname, sizeof(hostname));\n    harmony_connected = 0;\n\n    /* Initialize Harmony API. */\n    hdesc = harmony_init(&argc, &argv);\n    if (hdesc == NULL) {\n        errprint(\"Failed to initialize a Harmony session.\\n\");\n        goto cleanup;\n    }\n\n    if (rank == 0) {\n        /* We are the master rank.  Establish a new Harmony tuning session. */\n        snprintf(numbuf, sizeof(numbuf), \"%d\", node_count);\n\n        errno = 0;\n        harmony_session_name(hdesc, SESSION_NAME);\n        harmony_setcfg(hdesc, CFGKEY_CLIENT_COUNT, numbuf);\n        harmony_setcfg(hdesc, CFGKEY_SESSION_STRATEGY, \"pro.so\");\n        harmony_setcfg(hdesc, CFGKEY_SESSION_LAYERS, \"codegen.so\");\n        if (errno) {\n            errprint(\"Error during session configuration.\\n\");\n            MPI_Abort(MPI_COMM_WORLD, -1);\n        }\n\n        if (harmony_int(hdesc, \"TI\", 2, 500, 2) != 0 ||\n            harmony_int(hdesc, \"TJ\", 2, 500, 2) != 0 ||\n            harmony_int(hdesc, \"TK\", 2, 500, 2) != 0 ||\n            harmony_int(hdesc, \"UI\", 1,   8, 1) != 0 ||\n            harmony_int(hdesc, \"UJ\", 1,   8, 1) != 0)\n        {\n            errprint(\"Failed to define tuning session\\n\");\n            MPI_Abort(MPI_COMM_WORLD, -1);\n        }\n\n        if (harmony_launch(hdesc, NULL, 0) != 0) {\n            errprint(\"Could not launch tuning session: %s\\n\",\n                     harmony_error_string(hdesc));\n            MPI_Abort(MPI_COMM_WORLD, -1);\n        }\n    }\n\n    /* Everybody should wait until a tuning session is created. */\n    MPI_Barrier(MPI_COMM_WORLD);\n\n    /* Associate local memory to the session's runtime tunable\n     * parameters.  For example, these represent loop tiling and\n     * unrolling factors.\n     */\n    if (harmony_bind_int(hdesc, \"TI\", &TI) != 0 ||\n        harmony_bind_int(hdesc, \"TJ\", &TJ) != 0 ||\n        harmony_bind_int(hdesc, \"TK\", &TK) != 0 ||\n        harmony_bind_int(hdesc, \"UI\", &UI) != 0 ||\n        harmony_bind_int(hdesc, \"UJ\", &UJ) != 0)\n    {\n        errprint(\"Error binding local memory to Harmony variables.\\n\");\n        goto cleanup;\n    }\n\n    /* Connect to Harmony server and register ourselves as a client. */\n    if (harmony_join(hdesc, NULL, 0, SESSION_NAME) != 0) {\n        errprint(\"Could not join Harmony tuning session.\\n\");\n        goto cleanup;\n    }\n    harmony_connected = 1;\n\n    dprint(\"MPI node ready and searching for new shared objects in %s:%s\\n\",\n           hostname, new_code_path);\n\n    initialize_matrices();\n\n    dprint(\"Entering main loop.\\n\");\n    harmonized = 0;\n    for (i = 1; i < SEARCH_MAX; ++i) {\n        dprint(\"Begin iteration #%d\\n\", i);\n\n        /* Retrieve a new point to test from the tuning session. */\n        if (fetch_configuration() != 0)\n            goto cleanup;\n\n        memset(C, 0, sizeof(C));\n\n        /* Perform and measure the client application code. */\n        time_start = timer();\n        code_so(&matrix_size, A, B, C);\n        time_end = timer();\n\n        raw_perf = time_end - time_start;\n        dprint(\"Application code took %lf seconds\\n\", raw_perf);\n\n        check_code_correctness();\n\n        perf = calculate_performance(raw_perf);\n        dprint(\"TI:%ld, TJ:%ld, TK:%ld, UI:%ld, UJ:%ld = %lf\\n\",\n               TI, TJ, TK, UI, UJ, perf);\n\n        /* update the performance result */\n        if (harmony_report(hdesc, perf) != 0) {\n            errprint(\"Error reporting performance to server.\\n\");\n            goto cleanup;\n        }\n\n        if (!harmonized) {\n            harmonized = check_convergence(hdesc);\n            if (harmonized != 0) {\n                errprint(\"Error checking harmony convergence status.\\n\");\n                goto cleanup;\n            }\n\n            if (harmonized) {\n                /*\n                 * Harmony server has converged, so make one final fetch\n                 * to load the harmonized values, and disconnect from\n                 * server.\n                 */\n                if (fetch_configuration() != 0)\n                    goto cleanup;\n\n                if (harmony_leave(hdesc) != 0) {\n                    errprint(\"Error leaving tuning session.\");\n                    goto cleanup;\n                }\n\n                /* At this point, the application may continue its\n                 * execution using the harmonized values without\n                 * interference from the Harmony server.\n                 */\n                harmony_connected = 0;\n                found_iter = i;\n            }\n        }\n        MPI_Barrier(MPI_COMM_WORLD);\n    }\n\n    /* Print final book-keeping messages. */\n    time_current = MPI_Wtime();\n    time = time_current - time_initial;\n    dprint(\"%.3f: machine=%s [# node_count=%i]\\n\",\n           time, hostname, node_count);\n\n    /* Leave the Harmony session, if needed. */\n    if (harmony_connected) {\n        if (harmony_leave(hdesc) != 0) {\n            errprint(\"Error leaving Harmony session.\\n\");\n            harmony_connected = 0;\n            goto cleanup;\n        }\n    }\n    else {\n        dprint(\"Reached final harmonized values (TI:%ld, TJ:%ld, TK:%ld,\"\n               \" UI:%ld, UJ:%ld) at iteration %d of %d\\n\",\n               TI, TJ, TK, UI, UJ, found_iter, SEARCH_MAX);\n    }\n    MPI_Finalize();\n    return 0;\n\n  cleanup:\n    if (harmony_connected) {\n        if (harmony_leave(hdesc) != 0)\n            errprint(\"Error disconnecting from Harmony server.\\n\");\n    }\n    harmony_fini(hdesc);\n    return MPI_Abort(MPI_COMM_WORLD, -1);\n}\n\ndouble timer()\n{\n    struct timeval tv;\n\n    if (gettimeofday(&tv, NULL) != 0)\n        errprint(\"Error during gettimeofday()\\n\");\n\n    return (tv.tv_sec + 1.0e-6 * tv.tv_usec);\n}\n\n/*\n * Contact tuning session to see if a new configuration is available.\n * If so, update the underlying shared object and function pointer.\n */\nint fetch_configuration(void)\n{\n    int changed = 0;\n\n    while (changed == 0) {\n        changed = harmony_fetch(hdesc);\n\n        if (changed == 1) {\n            /* Harmony updated variable values.  Load a new shared object. */\n            if (update_so(construct_so_filename()) != 0) {\n                errprint(\"Could not load new code object.\");\n                return -1;\n            }\n        }\n        else if (changed == 0) {\n            /* No points available from Harmony, and harmony_best() failed. */\n            sleep(1);\n            continue;\n        }\n        else {\n            errprint(\"Error fetching new values from Harmony server.\\n\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\n/*\n * Check if the parameter space search has converged.\n * Only rank 0 communicates directly with the Harmony server.\n */\nint check_convergence(hdesc_t *hdesc)\n{\n    int status;\n\n    if (rank == 0) {\n        dprint(\"Checking Harmony search status.\\n\");\n        status = harmony_converged(hdesc);\n    }\n    else {\n        dprint(\"Waiting to hear search status from rank 0.\\n\");\n    }\n\n    /* Broadcast the result of harmony_converged(). */\n    MPI_Bcast(&status, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    return status;\n}\n\n/*\n * Construct the full pathname for the new code variant.\n */\nchar *construct_so_filename()\n{\n    static char fullpath[1024];\n\n    snprintf(fullpath, sizeof(fullpath), \"%s/gemm_%ld_%ld_%ld_%ld_%ld.so\",\n             new_code_path, TI, TJ, TK, UI, UJ);\n    return fullpath;\n}\n\n/* Update the code we wish to test.\n * Loads function <symbol_name> from shared object <filename>,\n * and stores that address in code_ptr.\n */\nint update_so(const char *filename)\n{\n    char *err_str;\n\n    flib_eval = dlopen(filename, RTLD_LAZY);\n    err_str = dlerror();\n    if (err_str) {\n        errprint(\"Error opening %s: %s\\n\", filename, err_str);\n        return -1;\n    }\n\n    code_so = HACK_CAST(dlsym(flib_eval, SHLIB_SYMBOL_NAME));\n    err_str = dlerror();\n    if (err_str) {\n        errprint(\"Error finding symbol \" SHLIB_SYMBOL_NAME \" in %s: %s\\n\",\n                 filename, err_str);\n        return -1;\n    }\n\n    dprint(\"Evaluation candidate updated.\\n\");\n    return 0;\n}\n\nvoid initialize_matrices(void)\n{\n    int i, j, k;\n\n    for (i = 0; i < N; ++i) {\n        for (j = 0; j < N; ++j) {\n            A[i][j] = i;\n            B[i][j] = j;\n        }\n    }\n\n    for (i = 0; i < N; ++i)\n        for (k = 0; k < N; ++k)\n            for (j = 0; j < N; ++j)\n                C_TRUTH[i][j] += A[k][i] * B[j][k];\n}\n\nint check_code_correctness(void)\n{\n    int i, j;\n    for (i=0; i<N; i++) {\n        for (j=0; j<N; j++) {\n            if(C[i][j] != C_TRUTH[i][j]) {\n                errprint(\"C_TRUTH[%d][%d]=%lf, C[%d][%d]=%lf don't match \\n\",\n                         i, j, C_TRUTH[i][j], i, j, C[i][j]);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/* Illustrates the use of a local penalization technique. */\nint penalty_factor()\n{\n    int increment = 100;\n    int return_val = 0;\n\n    if (TI < TJ)\n        return_val += increment;\n\n    if (UI*UJ > 16)\n        return_val = return_val + (3 * increment);\n\n    return return_val;\n}\n\ndouble calculate_performance(double raw_perf)\n{\n    int result = (int)(raw_perf * 1000);\n    return (double)(result + penalty_factor());\n}\n\nint dprint(const char *fmt, ...)\n{\n    va_list ap;\n    int count;\n\n    if (!debug)\n        return 0;\n\n    va_start(ap, fmt);\n    fprintf(stderr, \"[r%d] \", rank);\n    count = vfprintf(stderr, fmt, ap);\n    va_end(ap);\n\n    return count;\n}\n\nint errprint(const char *fmt, ...)\n{\n    va_list ap;\n    int count;\n\n    va_start(ap, fmt);\n    fprintf(stderr, \"[r%d] \", rank);\n    count = vfprintf(stderr, fmt, ap);\n    va_end(ap);\n\n    return count;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/src/session-core.c": "/*\n * Copyright 2003-2013 Jeffrey K. Hollingsworth\n *\n * This file is part of Active Harmony.\n *\n * Active Harmony is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Active Harmony is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Active Harmony.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"session-core.h\"\n#include \"hsession.h\"\n#include \"hcfg.h\"\n#include \"hmesg.h\"\n#include \"hutil.h\"\n#include \"hsockutil.h\"\n#include \"defaults.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <strings.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <math.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n\n/* Session structure exported to 3rd party plug-ins. */\nhsession_t *sess;\n\n/* Be sure all remaining global definitions are declared static to\n * reduce the number of symbols exported by --export-dynamic.\n */\n\n/* --------------------------------\n * Callback registration variables.\n */\ntypedef struct callback {\n    int fd;\n    int index;\n    cb_func_t func;\n} callback_t;\n\nstatic callback_t *cb = NULL;\nstatic int cb_len = 0;\nstatic int cb_cap = 0;\n\n/* -------------------------\n * Plug-in system variables.\n */\nstatic strategy_generate_t strategy_generate;\nstatic strategy_rejected_t strategy_rejected;\nstatic strategy_analyze_t  strategy_analyze;\nstatic strategy_best_t     strategy_best;\n\nstatic hook_init_t         strategy_init;\nstatic hook_join_t         strategy_join;\nstatic hook_getcfg_t       strategy_getcfg;\nstatic hook_setcfg_t       strategy_setcfg;\nstatic hook_fini_t         strategy_fini;\n\ntypedef struct layer {\n    const char *name;\n\n    layer_generate_t generate;\n    layer_analyze_t  analyze;\n\n    hook_init_t      init;\n    hook_join_t      join;\n    hook_getcfg_t    getcfg;\n    hook_setcfg_t    setcfg;\n    hook_fini_t      fini;\n\n    int *wait_generate;\n    int wait_generate_len;\n    int wait_generate_cap;\n\n    int *wait_analyze;\n    int wait_analyze_len;\n    int wait_analyze_cap;\n} layer_t;\n\n/* Stack of layer objects. */\nstatic layer_t *lstack = NULL;\nstatic int lstack_len = 0;\nstatic int lstack_cap = 0;\n\n/* ------------------------------\n * Forward function declarations.\n */\nstatic int generate_trial(void);\nstatic int plugin_workflow(int trial_idx);\nstatic int workflow_transition(int trial_idx);\nstatic int handle_callback(callback_t *cb);\nstatic int handle_join(hmesg_t *mesg);\nstatic int handle_getcfg(hmesg_t *mesg);\nstatic int handle_setcfg(hmesg_t *mesg);\nstatic int handle_fetch(hmesg_t *mesg);\nstatic int handle_report(hmesg_t *mesg);\nstatic int handle_reject(int trial_idx);\nstatic int handle_wait(int trial_idx);\nstatic int load_strategy(const char *file);\nstatic int load_layers(const char *list);\nstatic int extend_lists(int target_cap);\nstatic void reverse_array(void *ptr, int head, int tail);\n\n/* -------------------\n * Workflow variables.\n */\nstatic const char *errmsg;\nstatic int curr_layer = 0;\nstatic hflow_t flow;\n\n/* List of all points generated, but not yet returned to the strategy. */\nstatic htrial_t *pending = NULL;\nstatic int pending_cap = 0;\nstatic int pending_len = 0;\n\n/* List of all trials (point/performance pairs) waiting for client fetch. */\nstatic int *ready = NULL;\nstatic int ready_head = 0;\nstatic int ready_tail = 0;\nstatic int ready_cap = 0;\n\nstatic int per_client = DEFAULT_PER_CLIENT;\nstatic int num_clients = 0;\n\n/* ----------------------------\n * Variables used for select().\n */\nstatic struct timeval polltime, *pollstate;\nstatic fd_set fds;\nstatic int maxfd;\n\n/* =================================\n * Core session routines begin here.\n */\nint main(int argc, char **argv)\n{\n    struct stat sb;\n    int i, retval;\n    fd_set ready_fds;\n    const char *ptr;\n    hmesg_t mesg = HMESG_INITIALIZER;\n    hmesg_t session_mesg = HMESG_INITIALIZER;\n\n    /* Check that we have been launched correctly by checking that\n     * STDIN_FILENO is a socket descriptor.\n     *\n     * Print an error message to stderr if this is not the case.  This\n     * should be the only time an error message is printed to stdout\n     * or stderr.\n     */\n    if (fstat(STDIN_FILENO, &sb) < 0) {\n        perror(\"Could not determine the status of STDIN\");\n        return -1;\n    }\n\n    if (!S_ISSOCK(sb.st_mode)) {\n        fprintf(stderr, \"%s should not be launched manually.\\n\", argv[0]);\n        return -1;\n    }\n\n    /* Initialize data structures. */\n    pollstate = &polltime;\n    FD_ZERO(&fds);\n    FD_SET(STDIN_FILENO, &fds);\n    maxfd = STDIN_FILENO;\n\n    if (array_grow(&cb, &cb_cap, sizeof(callback_t)) < 0)\n        goto error;\n\n    if (array_grow(&lstack, &lstack_cap, sizeof(layer_t)) < 0)\n        goto error;\n\n    /* Receive initial session message. */\n    mesg.type = HMESG_SESSION;\n    if (mesg_recv(STDIN_FILENO, &session_mesg) < 1) {\n        mesg.data.string = \"Socket or deserialization error\";\n        goto error;\n    }\n\n    if (session_mesg.type != HMESG_SESSION ||\n        session_mesg.status != HMESG_STATUS_REQ)\n    {\n        mesg.data.string = \"Invalid initial message\";\n        goto error;\n    }\n\n    /* Load and initialize the strategy code object. */\n    sess = &session_mesg.data.session;\n\n    ptr = hcfg_get(sess->cfg, CFGKEY_SESSION_STRATEGY);\n    if (load_strategy(ptr) < 0)\n        goto error;\n\n    /* Load and initialize requested layer's. */\n    ptr = hcfg_get(sess->cfg, CFGKEY_SESSION_LAYERS);\n    if (ptr && load_layers(ptr) < 0)\n        goto error;\n\n    mesg.dest   = session_mesg.dest;\n    mesg.type   = session_mesg.type;\n    mesg.status = HMESG_STATUS_OK;\n    mesg.src_id = session_mesg.src_id;\n    if (mesg_send(STDIN_FILENO, &mesg) < 1) {\n        errmsg = session_mesg.data.string;\n        goto error;\n    }\n\n    ptr = hcfg_get(sess->cfg, CFGKEY_PER_CLIENT_STORAGE);\n    if (ptr) {\n        per_client = atoi(ptr);\n        if (per_client < 1) {\n            errmsg = \"Invalid config value for \" CFGKEY_PER_CLIENT_STORAGE \".\";\n            goto error;\n        }\n    }\n\n    retval = 0;\n    ptr = hcfg_get(sess->cfg, CFGKEY_CLIENT_COUNT);\n    if (ptr) {\n        retval = atoi(ptr);\n        if (retval < 1) {\n            errmsg = \"Invalid config value for \" CFGKEY_CLIENT_COUNT \".\";\n            goto error;\n        }\n        retval *= per_client;\n    }\n    if (extend_lists(retval) != 0)\n        goto error;\n\n    while (1) {\n        flow.status = HFLOW_ACCEPT;\n        flow.point  = HPOINT_INITIALIZER;\n\n        ready_fds = fds;\n        retval = select(maxfd + 1, &ready_fds, NULL, NULL, pollstate);\n        if (retval < 0)\n            goto error;\n\n        /* Launch callbacks, if needed. */\n        for (i = 0; i < cb_len; ++i) {\n            if (FD_ISSET(cb[i].fd, &ready_fds))\n                handle_callback(&cb[i]);\n        }\n\n        /* Handle hmesg_t, if needed. */\n        if (FD_ISSET(STDIN_FILENO, &ready_fds)) {\n            if (mesg_recv(STDIN_FILENO, &mesg) < 1)\n                goto error;\n\n            hcfg_set(sess->cfg, CFGKEY_CURRENT_CLIENT, mesg.src_id);\n            switch (mesg.type) {\n            case HMESG_JOIN:   retval = handle_join(&mesg); break;\n            case HMESG_GETCFG: retval = handle_getcfg(&mesg); break;\n            case HMESG_SETCFG: retval = handle_setcfg(&mesg); break;\n            case HMESG_FETCH:  retval = handle_fetch(&mesg); break;\n            case HMESG_REPORT: retval = handle_report(&mesg); break;\n            default:\n                errmsg = \"Internal error: Unknown message type.\";\n                goto error;\n            }\n            if (retval != 0)\n                goto error;\n\n            hcfg_set(sess->cfg, CFGKEY_CURRENT_CLIENT, NULL);\n            mesg.src_id = NULL;\n            if (mesg_send(STDIN_FILENO, &mesg) < 1)\n                goto error;\n        }\n\n        /* Generate another point, if there's room in the queue. */\n        while (pollstate != NULL && pending_len < pending_cap) {\n            generate_trial();\n        }\n    }\n    goto cleanup;\n\n  error:\n    mesg.status = HMESG_STATUS_FAIL;\n    mesg.data.string = errmsg;\n    mesg_send(STDIN_FILENO, &mesg);\n\n  cleanup:\n    for (i = lstack_len - 1; i >= 0; --i) {\n        if (lstack[i].fini)\n            lstack[i].fini();\n    }\n\n    hmesg_fini(&session_mesg);\n    hmesg_fini(&mesg);\n    return retval;\n}\n\nint generate_trial(void)\n{\n    int idx;\n    hpoint_t *point;\n\n    /* Find a free point. */\n    for (idx = 0; idx < pending_cap; ++idx) {\n        if (pending[idx].point.id == -1) {\n            point = (hpoint_t *) &pending[idx].point;\n            break;\n        }\n    }\n    if (idx == pending_cap) {\n        errmsg = \"Internal error: Point generation overflow.\";\n        return -1;\n    }\n\n    /* Call strategy generation routine. */\n    if (strategy_generate(&flow, point) != 0)\n        return -1;\n\n    if (flow.status == HFLOW_WAIT) {\n        /* Strategy requests that we pause point generation. */\n        pollstate = NULL;\n        return 0;\n    }\n\n    /* Begin generation workflow for new point. */\n    ++pending_len;\n    pending[idx].perf = INFINITY;\n    curr_layer = 1;\n\n    return plugin_workflow(idx);\n}\n\nint plugin_workflow(int trial_idx)\n{\n    htrial_t *trial = &pending[trial_idx];\n\n    while (curr_layer != 0 && curr_layer <= lstack_len)\n    {\n        int stack_idx = abs(curr_layer) - 1;\n        int retval;\n\n        flow.status = HFLOW_ACCEPT;\n        if (curr_layer < 0) {\n            /* Analyze workflow. */\n            if (lstack[stack_idx].analyze) {\n                if (lstack[stack_idx].analyze(&flow, trial) != 0)\n                    return -1;\n            }\n        }\n        else {\n            /* Generate workflow. */\n            if (lstack[stack_idx].generate) {\n                if (lstack[stack_idx].generate(&flow, trial) != 0)\n                    return -1;\n            }\n        }\n\n        retval = workflow_transition(trial_idx);\n        if (retval < 0) return -1;\n        if (retval > 0) return  0;\n    }\n\n    if (curr_layer == 0) {\n        hpoint_t *point = (hpoint_t *) &trial->point;\n\n        /* Completed analysis layers.  Send trial to strategy. */\n        if (strategy_analyze(trial) != 0)\n            return -1;\n\n        /* Remove point data from pending list. */\n        hpoint_fini(point);\n        *point = HPOINT_INITIALIZER;\n        --pending_len;\n\n        /* Point generation attempts may begin again. */\n        pollstate = &polltime;\n    }\n    else if (curr_layer > lstack_len) {\n        /* Completed generation layers.  Enqueue trial in ready queue. */\n        if (ready[ready_tail] != -1) {\n            errmsg = \"Internal error: Ready queue overflow.\";\n            return -1;\n        }\n\n        ready[ready_tail] = trial_idx;\n        ready_tail = (ready_tail + 1) % ready_cap;\n    }\n    else {\n        errmsg = \"Internal error: Invalid current plug-in layer.\";\n        return -1;\n    }\n\n    return 0;\n}\n\n/* Layer state machine transitions. */\nint workflow_transition(int trial_idx)\n{\n    switch (flow.status) {\n    case HFLOW_ACCEPT:\n        curr_layer += 1;\n        break;\n\n    case HFLOW_WAIT:\n        if (handle_wait(trial_idx) != 0) {\n            return -1;\n        }\n        return 1;\n\n    case HFLOW_RETURN:\n    case HFLOW_RETRY:\n        curr_layer = -curr_layer;\n        break;\n\n    case HFLOW_REJECT:\n        if (handle_reject(trial_idx) != 0)\n            return -1;\n\n        if (flow.status == HFLOW_WAIT)\n            return 1;\n\n        curr_layer = 1;\n        break;\n\n    default:\n        errmsg = \"Internal error: Invalid workflow status.\";\n        return -1;\n    }\n    return 0;\n}\n\nint handle_reject(int trial_idx)\n{\n    htrial_t *trial = &pending[trial_idx];\n\n    if (curr_layer < 0) {\n        errmsg = \"Internal error: REJECT invalid for analysis workflow.\";\n        return -1;\n    }\n\n    /* Regenerate this rejected point. */\n    if (strategy_rejected(&flow, (hpoint_t *) &trial->point) != 0)\n        return -1;\n\n    if (flow.status == HFLOW_WAIT)\n        pollstate = NULL;\n\n    return 0;\n}\n\nint handle_wait(int trial_idx)\n{\n    int idx = abs(curr_layer) - 1;\n    int **list;\n    int *len, *cap;\n\n    if (curr_layer < 0) {\n        list = &lstack[idx].wait_analyze;\n        len  = &lstack[idx].wait_analyze_len;\n        cap  = &lstack[idx].wait_analyze_cap;\n    }\n    else {\n        list = &lstack[idx].wait_generate;\n        len  = &lstack[idx].wait_generate_len;\n        cap  = &lstack[idx].wait_generate_cap;\n    }\n\n    if (*len == *cap) {\n        int i;\n\n        array_grow(list, cap, sizeof(int));\n        for (i = *len; i < *cap; ++i)\n            (*list)[i] = -1;\n    }\n\n    if ((*list)[*len] != -1) {\n        errmsg = \"Internal error: Could not append to wait list.\";\n        return -1;\n    }\n\n    (*list)[*len] = trial_idx;\n    ++(*len);\n    return 0;\n}\n\nint handle_callback(callback_t *cb)\n{\n    htrial_t **trial_list;\n    int *list, *len, trial_idx;\n    int i, idx, retval;\n\n    curr_layer = cb->index;\n    idx = abs(curr_layer) - 1;\n\n    /* The idx variable represents layer plugin index for now. */\n    if (curr_layer < 0) {\n        list = lstack[idx].wait_analyze;\n        len = &lstack[idx].wait_analyze_len;\n    }\n    else {\n        list = lstack[idx].wait_generate;\n        len = &lstack[idx].wait_generate_len;\n    }\n\n    if (*len < 1) {\n        errmsg = \"Internal error: Callback on layer with empty waitlist.\";\n        return -1;\n    }\n\n    /* Prepare a list of htrial_t pointers. */\n    trial_list = (htrial_t **) malloc(*len * sizeof(htrial_t *));\n    for (i = 0; i < *len; ++i)\n        trial_list[i] = &pending[ list[i] ];\n\n    /* Reusing idx to represent waitlist index.  (Shame on me.) */\n    idx = cb->func(cb->fd, &flow, *len, trial_list);\n    free(trial_list);\n\n    trial_idx = list[idx];\n    retval = workflow_transition(trial_idx);\n    if (retval < 0) return -1;\n    if (retval > 0) return  0;\n\n    --(*len);\n    list[ idx] = list[*len];\n    list[*len] = -1;\n    return plugin_workflow(trial_idx);\n}\n\nint handle_join(hmesg_t *mesg)\n{\n    int i;\n\n    /* Verify that client signature matches current session. */\n    if (!hsignature_match(&mesg->data.join, &sess->sig)) {\n        errmsg = \"Incompatible join signature.\";\n        return -1;\n    }\n\n    if (hsignature_copy(&mesg->data.join, &sess->sig) < 0) {\n        errmsg = \"Internal error: Could not copy signature.\";\n        return -1;\n    }\n\n    /* Grow the pending and ready queues. */\n    ++num_clients;\n    if (extend_lists(num_clients * per_client) != 0)\n        return -1;\n\n    /* Launch all join hooks defined in the plug-in stack. */\n    if (strategy_join && strategy_join(mesg->src_id) != 0)\n        return -1;\n\n    for (i = 0; i < lstack_len; ++i) {\n        if (lstack[i].join && lstack[i].join(mesg->src_id) != 0)\n            return -1;\n    }\n\n    mesg->status = HMESG_STATUS_OK;\n    return 0;\n}\n\nint handle_getcfg(hmesg_t *mesg)\n{\n    int i;\n    const char *key;\n\n    key = mesg->data.string;\n\n    /* Launch all getcfg hooks defined in the plug-in stack. */\n    if (strategy_getcfg && strategy_getcfg(key) != 0)\n        return -1;\n\n    for (i = 0; i < lstack_len; ++i) {\n        if (lstack[i].getcfg && lstack[i].getcfg(key) != 0)\n            return -1;\n    }\n\n    /* Prepare getcfg response message for client. */\n    mesg->data.string = hcfg_get(sess->cfg, key);\n    mesg->status = HMESG_STATUS_OK;\n    return 0;\n}\n\nint handle_setcfg(hmesg_t *mesg)\n{\n    static char *buf = NULL;\n    static int buflen = 0;\n\n    int i;\n    char *key, *val;\n    const char *oldval;\n\n    hcfg_parse((char *)mesg->data.string, &key, &val);\n    if (!key) {\n        errmsg = strerror(EINVAL);\n        return -1;\n    }\n\n    /* Launch all setcfg hooks defined in the plug-in stack. */\n    if (strategy_setcfg && strategy_setcfg(key, val) != 0)\n        return -1;\n\n    for (i = 0; i < lstack_len; ++i) {\n        if (lstack[i].setcfg && lstack[i].setcfg(key, val) != 0)\n            return -1;\n    }\n\n    /* Store the original value, possibly allocating memory for it. */\n    oldval = hcfg_get(sess->cfg, key);\n    if (oldval) {\n        snprintf_grow(&buf, &buflen, \"%s\", oldval);\n        oldval = buf;\n    }\n\n    /* Finally, update the configuration system. */\n    if (hcfg_set(sess->cfg, key, val) != 0) {\n        errmsg = \"Internal error: Could not modify configuration.\";\n        return -1;\n    }\n\n    /* Prepare setcfg response message for client. */\n    mesg->data.string = oldval;\n    mesg->status = HMESG_STATUS_OK;\n    return 0;\n}\n\nint handle_fetch(hmesg_t *mesg)\n{\n    int idx = ready[ready_head];\n    hpoint_t *cand = &mesg->data.fetch.cand;\n    hpoint_t *best = &mesg->data.fetch.best;\n    htrial_t *next;\n\n    /* If ready queue is empty, inform client that we're busy. */\n    if (idx == -1) {\n        mesg->status = HMESG_STATUS_BUSY;\n        return 0;\n    }\n    next = &pending[idx];\n\n    /* Otherwise, prepare a response to the client. */\n    *cand = HPOINT_INITIALIZER;\n    if (hpoint_copy(cand, &next->point) != 0) {\n        errmsg = \"Internal error: Could not copy candidate point data.\";\n        return -1;\n    }\n\n    *best = HPOINT_INITIALIZER;\n    if (strategy_best(best) != 0)\n        return -1;\n\n    /* Remove the first point from the ready queue. */\n    ready[ready_head] = -1;\n    ready_head = (ready_head + 1) % ready_cap;\n\n    mesg->status = HMESG_STATUS_OK;\n    return 0;\n}\n\nint handle_report(hmesg_t *mesg)\n{\n    int idx;\n\n    /* Find the associated trial in the pending list. */\n    for (idx = 0; idx < pending_cap; ++idx) {\n        if (pending[idx].point.id == mesg->data.report.cand.id)\n            break;\n    }\n    if (idx == pending_cap) {\n        errmsg = \"Rouge point support not yet implemented.\";\n        return -1;\n    }\n\n    /* Update performance in our local records. */\n    pending[idx].perf = mesg->data.report.perf;\n\n    /* Begin the workflow at the outermost analysis layer. */\n    curr_layer = -lstack_len;\n    if (plugin_workflow(idx) != 0)\n        return -1;\n\n    hmesg_scrub(mesg);\n    mesg->status = HMESG_STATUS_OK;\n    return 0;\n}\n\n/* ISO C forbids conversion of object pointer to function pointer,\n * making it difficult to use dlsym() for functions.  We get around\n * this by first casting to a word-length integer.  (ILP32/LP64\n * compilers assumed).\n */\n#define dlfptr(x, y) ((void (*)(void))(long)(dlsym((x), (y))))\n\nint load_strategy(const char *file)\n{\n    const char *root;\n    char *path;\n    void *lib;\n\n    if (!file)\n        file = DEFAULT_STRATEGY;\n\n    root = hcfg_get(sess->cfg, CFGKEY_HARMONY_HOME);\n    path = sprintf_alloc(\"%s/libexec/%s\", root, file);\n\n    lib = dlopen(path, RTLD_LAZY | RTLD_LOCAL);\n    free(path);\n    if (!lib) {\n        errmsg = dlerror();\n        return -1;\n    }\n\n    strategy_generate = (strategy_generate_t) dlfptr(lib, \"strategy_generate\");\n    strategy_rejected = (strategy_rejected_t) dlfptr(lib, \"strategy_rejected\");\n    strategy_analyze  =  (strategy_analyze_t) dlfptr(lib, \"strategy_analyze\");\n    strategy_best     =     (strategy_best_t) dlfptr(lib, \"strategy_best\");\n\n    strategy_init     =         (hook_init_t) dlfptr(lib, \"strategy_init\");\n    strategy_join     =         (hook_join_t) dlfptr(lib, \"strategy_join\");\n    strategy_getcfg   =       (hook_getcfg_t) dlfptr(lib, \"strategy_getcfg\");\n    strategy_setcfg   =       (hook_setcfg_t) dlfptr(lib, \"strategy_setcfg\");\n    strategy_fini     =         (hook_fini_t) dlfptr(lib, \"strategy_fini\");\n\n    if (!strategy_generate) {\n        errmsg = \"Strategy does not define strategy_generate()\";\n        return -1;\n    }\n\n    if (!strategy_rejected) {\n        errmsg = \"Strategy does not define strategy_rejected()\";\n        return -1;\n    }\n\n    if (!strategy_analyze) {\n        errmsg = \"Strategy does not define strategy_analyze()\";\n        return -1;\n    }\n\n    if (!strategy_best) {\n        errmsg = \"Strategy does not define strategy_best()\";\n        return -1;\n    }\n\n    if (strategy_init)\n        return strategy_init(&sess->sig);\n\n    return 0;\n}\n\nint load_layers(const char *list)\n{\n    const char *prefix, *end;\n    char *path;\n    int path_len, retval;\n    void *lib;\n\n    path = NULL;\n    path_len = 0;\n    retval = 0;\n    while (list && *list) {\n        if (lstack_len == lstack_cap) {\n            if (array_grow(&lstack, &lstack_cap, sizeof(layer_t)) < 0) {\n                retval = -1;\n                goto cleanup;\n            }\n        }\n        end = strchr(list, SESSION_LAYER_SEP);\n        if (!end)\n            end = list + strlen(list);\n\n        prefix = hcfg_get(sess->cfg, CFGKEY_HARMONY_HOME);\n        if (snprintf_grow(&path, &path_len, \"%s/libexec/%.*s\",\n                          prefix, end - list, list) < 0)\n        {\n            retval = -1;\n            goto cleanup;\n        }\n\n        lib = dlopen(path, RTLD_LAZY | RTLD_LOCAL);\n        if (!lib) {\n            errmsg = dlerror();\n            retval = -1;\n            goto cleanup;\n        }\n\n        prefix = (const char *) dlsym(lib, \"harmony_layer_name\");\n        if (!prefix) {\n            errmsg = dlerror();\n            retval = -1;\n            goto cleanup;\n        }\n        lstack[lstack_len].name = prefix;\n\n        if (snprintf_grow(&path, &path_len, \"%s_init\", prefix) < 0) {\n            retval = -1;\n            goto cleanup;\n        }\n        lstack[lstack_len].init = (hook_init_t) dlfptr(lib, path);\n\n        if (snprintf_grow(&path, &path_len, \"%s_join\", prefix) < 0) {\n            retval = -1;\n            goto cleanup;\n        }\n        lstack[lstack_len].join = (hook_join_t) dlfptr(lib, path);\n\n        if (snprintf_grow(&path, &path_len, \"%s_generate\", prefix) < 0) {\n            retval = -1;\n            goto cleanup;\n        }\n        lstack[lstack_len].generate = (layer_generate_t) dlfptr(lib, path);\n\n        if (snprintf_grow(&path, &path_len, \"%s_analyze\", prefix) < 0) {\n            retval = -1;\n            goto cleanup;\n        }\n        lstack[lstack_len].analyze = (layer_analyze_t) dlfptr(lib, path);\n\n        if (snprintf_grow(&path, &path_len, \"%s_getcfg\", prefix) < 0) {\n            retval = -1;\n            goto cleanup;\n        }\n        lstack[lstack_len].getcfg = (hook_getcfg_t) dlfptr(lib, path);\n\n        if (snprintf_grow(&path, &path_len, \"%s_setcfg\", prefix) < 0) {\n            retval = -1;\n            goto cleanup;\n        }\n        lstack[lstack_len].setcfg = (hook_setcfg_t) dlfptr(lib, path);\n\n        if (snprintf_grow(&path, &path_len, \"%s_fini\", prefix) < 0) {\n            retval = -1;\n            goto cleanup;\n        }\n        lstack[lstack_len].fini = (hook_fini_t) dlfptr(lib, path);\n\n        if (lstack[lstack_len].init) {\n            curr_layer = lstack_len + 1;\n            if (lstack[lstack_len].init(&sess->sig) < 0) {\n                retval = -1;\n                goto cleanup;\n            }\n        }\n        ++lstack_len;\n\n        if (*end)\n            list = end + 1;\n        else\n            list = NULL;\n    }\n\n  cleanup:\n    free(path);\n    return retval;\n}\n\nint extend_lists(int target_cap)\n{\n    int orig_cap = pending_cap;\n    int i;\n\n    if (pending_cap >= target_cap && pending_cap != 0)\n        return 0;\n\n    if (ready && ready_tail <= ready_head && ready[ready_head] != -1) {\n        i = ready_cap - ready_head;\n\n        /* Shift ready array to align head with array index 0. */\n        reverse_array(ready, 0, ready_cap);\n        reverse_array(ready, 0, i);\n        reverse_array(ready, i, ready_cap);\n\n        ready_head = 0;\n        ready_tail = ready_cap - ready_tail + ready_head;\n    }\n\n    ready_cap = target_cap;\n    if (array_grow(&ready, &ready_cap, sizeof(htrial_t *)) != 0) {\n        errmsg = \"Internal error: Could not extend ready array.\";\n        return -1;\n    }\n\n    pending_cap = target_cap;\n    if (array_grow(&pending, &pending_cap, sizeof(htrial_t)) != 0) {\n        errmsg = \"Internal error: Could not extend pending array.\";\n        return -1;\n    }\n\n    for (i = orig_cap; i < pending_cap; ++i) {\n        hpoint_t *point = (hpoint_t *) &pending[i].point;\n        *point = HPOINT_INITIALIZER;\n        ready[i] = -1;\n    }\n    return 0;\n}\n\nvoid reverse_array(void *ptr, int head, int tail)\n{\n    unsigned long *arr = (unsigned long *) ptr;\n\n    while (head < --tail) {\n        /* Swap head and tail entries. */\n        arr[head] ^= arr[tail];\n        arr[tail] ^= arr[head];\n        arr[head] ^= arr[tail];\n        ++head;\n    }\n}\n\n/* ========================================================\n * Exported functions for pluggable modules.\n */\n\nint callback_generate(int fd, cb_func_t func)\n{\n    if (cb_len >= cb_cap) {\n        if (array_grow(&cb, &cb_cap, sizeof(callback_t)) < 0)\n            return -1;\n    }\n    cb[cb_len].fd = fd;\n    cb[cb_len].index = curr_layer;\n    cb[cb_len].func = func;\n    ++cb_len;\n\n    FD_SET(fd, &fds);\n    if (maxfd < fd)\n        maxfd = fd;\n\n    return 0;\n}\n\nint callback_analyze(int fd, cb_func_t func)\n{\n    if (cb_len >= cb_cap) {\n        if (array_grow(&cb, &cb_cap, sizeof(callback_t)) < 0)\n            return -1;\n    }\n    cb[cb_len].fd = fd;\n    cb[cb_len].index = -curr_layer;\n    cb[cb_len].func = func;\n    ++cb_len;\n\n    FD_SET(fd, &fds);\n    if (maxfd < fd)\n        maxfd = fd;\n\n    return 0;\n}\n\nconst char *session_getcfg(const char *key)\n{\n    return hcfg_get(sess->cfg, key);\n}\n\nint session_setcfg(const char *key, const char *val)\n{\n    return hcfg_set(sess->cfg, key, val);\n}\n\nvoid session_error(const char *msg)\n{\n    errmsg = msg;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/gemm/code.properties": "#!/bin/bash\n\n# this is a global \"properties\" file for code-generation.\n#  Please note that there are no spaces between the lvalue and\n#  the rvalue in variable definitions. Some versions of bash\n#  do not like the spaces. So - sticking with the one that works\n#  for all.\n\necho \"initializing\"\n\n##################### CHiLL, OMEGA, SUIF Paths\n# exports: indicate where the CHiLL components and libraries are.\n\nCHILLHOME=\nOMEGA_P=\nSUIFHOME=\n\nif [ -n \"$CHILLHOME\" ]; then\n    PATH=$CHILLHOME/bin:$PATH\nfi\n\nif [ -n \"$OMEGA_P\" ]; then\n    export OMEGA_P\nfi\n\nif [ -n \"$SUIFHOME\" ]; then\n    PATH=$SUIFHOME/i386-linux/bin/:$PATH\n    LD_LIBRARY_PATH=$SUIFHOME/i386-linux/solib:$LD_LIBRARY_PATH\nfi\n\nexport PATH LD_LIBRARY_PATH\n########################################\n\n###################### loop names, languages\n# remember that the appname should be the same as the directory name\n#  for the loop. For example, if you want to tune for dgemv, you will have\n#  to create a directory named \"dgemv\" within the code-generator directory\n#  and have all the files necessary there.\nappname=gemm\nfile_prefix=gemm\n# fortran or c file?\nfile_suffix=f\n########################################\n\n###################### are we using a particular CHiLL version\nuse_default_chill=1\n# if we are not using the default CHiLL, tell me what version of CHiLL you\n#  want to use. Also - make sure you include this name in the \n#  required_files.dat so that this executable can be copied to all the\n#  code generation hosts.\n# Note the \"./\" which is required.\nchill_exec_name=\"./chill.v.0.1.8 \"\n\n###################### local and remote hosts spec\n# are we using remote hosts for compilation?\nuse_remote_hosts=1\n# if use_remote_host is set to 1, we also need to provide the following \n#  parameters. username is your username\n#username=\n\n###################### COMPILATION\n# what format should we compile the file into? If you are dynamically loading\n#  the new code using dlopen/dlsym, we should compile the code to .so. If\n#  we are compiling this to an executable, then we can set this suffix to\n#  \".exe\". For compiling to .exe, the assumption is that the user provides a\n#  driver.c (or f) and is listed as one of the required files for code generation\n#  in \"required_files.dat\" file.\n# driver.c (or f) will be linked with the new code. So when you run the code, the\n#  performance will reflect the change in the parameters.\noutput_file_suffix=so\n\n# need to provide this only if we are compiling to a .exe\ndriver_filename=driver.c\n\n# fortran compilation (note the trailing space in the end, which is needed).\nFC_COMMAND=\"gfortran -m32 -O3 \"\n\n# c compilation (note the trailing space in the end, which is needed).\nCC_COMMAND=\"gcc -m32 -O3 \"   \n",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/generic/code.properties": "#!/bin/bash\n\n# this is a global \"properties\" file for code-generation.\n#  Please note that there are no spaces between the lvalue and\n#  the rvalue in variable definitions. Some versions of bash\n#  do not like the spaces. So - sticking with the one that works\n#  for all.\n\necho \"initializing\"\n\n##################### CHiLL, OMEGA, SUIF Paths\n### These definitions probably won't change.\n# exports: indicate where the CHiLL components and libraries are.\n# Here the assumption is that CHiLL components are installed in their\n#  respective directories. If not, please make a change here. Maybe they\n#  installed in $HOME/projects/ directory?\n\nexport OMEGA_P=$HOME/omega\nexport SUIFHOME=$HOME/suifhome\nexport PATH=$HOME/chill/bin:${SUIFHOME}/i386-linux/bin/:${PATH}\nexport LD_LIBRARY_PATH=${SUIFHOME}/i386-linux/solib:${LD_LIBRARY_PATH}\n########################################\n\n###################### loop names, languages\n# remember that the appname should be the same as the directory name\n#  for the loop. For example, if you want to tune for dgemv, you will have\n#  to create a directory named \"dgemv\" within the code-generator directory\n#  and have all the files necessary there.\nappname=gemm\nfile_prefix=gemm\n# fortran or c file?\nfile_suffix=f\n########################################\n\n###################### are we using a particular CHiLL version\nuse_default_chill=1\n# if we are not using the default CHiLL, tell me what version of CHiLL you\n#  want to use. Also - make sure you include this name in the \n#  required_files.dat so that this executable can be copied to all the\n#  code generation hosts.\n# Note the \"./\" which is required.\nchill_exec_name=\"./chill.v.0.1.8 \"\n\n###################### local and remote hosts spec\n# are we using remote hosts for compilation?\nuse_remote_hosts=0\n# if use_remote_host is set to 1, we also need to provide the following \n#  parameters. username is your username\n#username=\n\n###################### COMPILATION\n# what format should we compile the file into? If you are dynamically loading\n#  the new code using dlopen/dlsym, we should compile the code to .so. If\n#  we are compiling this to an executable, then we can set this suffix to\n#  \".exe\". For compiling to .exe, the assumption is that the user provides a\n#  driver.c (or f) and is listed as one of the required files for code generation\n#  in \"required_files.dat\" file.\n# driver.c (or f) will be linked with the new code. So when you run the code, the\n#  performance will reflect the change in the parameters.\noutput_file_suffix=so\n\n# need to provide this only if we are compiling to a .exe\ndriver_filename=driver.c\n\n# fortran compilation (note the trailing space in the end, which is needed).\nFC_COMMAND=\"gfortran -O3 \"\n\n# c compilation (note the trailing space in the end, which is needed).\nCC_COMMAND=\"gcc -O3 \"   \n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/irs/rmatmult3_at.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/irs/rmatmult3_at.spd",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/irs/rmatmult3_at.sp1",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/gemm/gemm.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/gemm/gemm_at.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/generic/gemm.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/generic/gemm_at.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/smg2000/OUT__1__6119__.spd",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/smg2000/OUT__1__6119__.spd.64",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/smg2000/OUT__1__6119__.sp1",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/smg2000/OUT__1__6119__.sp2",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/code-server/smg2000/OUT__1__6119__.spd.32",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/images/hserver1.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/images/logo_new.ppm",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/images/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/images/hserver2.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/images/logo.ppm",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/hserver1.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2mo.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2mlastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2plastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2vertline.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2lastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/hserver2.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2blank.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2link.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2ns.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2cl.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2mnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Users_Guide.html/search/search_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-activeharmony-4.5-36ugpy65hrj4hzr7urgexqizgy4jd5uo/spack-src/doc/Message-Flow-Diagrams/AH-Message-Flow.doc"
    ],
    "total_files": 308
}