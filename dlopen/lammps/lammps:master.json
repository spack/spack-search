{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/src/USER-MOLFILE/molfile_interface.cpp": "/* -*- c++ -*- ----------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   https://lammps.sandia.gov/, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n------------------------------------------------------------------------- */\n\n/* ----------------------------------------------------------------------\n   Contributing author: Axel Kohlmeyer (Temple)\n------------------------------------------------------------------------- */\n\n#include \"molfile_interface.h\"\n#include \"molfile_plugin.h\"\n\n#include <sys/types.h>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\n\n#if defined(_WIN32)\n#include <windows.h>\n#else\n#include <dirent.h>\n#include <dlfcn.h>\n#endif\n\n#if vmdplugin_ABIVERSION < 16\n#error \"unsupported VMD molfile plugin ABI version\"\n#endif\n\n#define DEBUG 0\n\nextern \"C\" {\n  typedef int (*initfunc)(void);\n  typedef int (*regfunc)(void *, vmdplugin_register_cb);\n  typedef int (*finifunc)(void);\n\n  typedef struct {\n    void *p;\n    const char *name;\n  } plugin_reginfo_t;\n\n  // callback function for plugin registration.\n  static int plugin_register_cb(void *v, vmdplugin_t *p)\n  {\n    plugin_reginfo_t *r = static_cast<plugin_reginfo_t *>(v);\n    // make sure we have the proper plugin type (native reader)\n    // for the desired file type (called \"name\" at this level)\n    if ((strcmp(MOLFILE_PLUGIN_TYPE,p->type) == 0)\n        && (strcmp(r->name, p->name) == 0)) {\n      r->p = static_cast<void *>(p);\n    }\n    return 0;\n  }\n\n  /* periodic table of elements for translation of ordinal to atom type */\n  static const char *pte_label[] = {\n    \"X\",  \"H\",  \"He\", \"Li\", \"Be\", \"B\",  \"C\",  \"N\",  \"O\",  \"F\",  \"Ne\",\n    \"Na\", \"Mg\", \"Al\", \"Si\", \"P\" , \"S\",  \"Cl\", \"Ar\", \"K\",  \"Ca\", \"Sc\",\n    \"Ti\", \"V\",  \"Cr\", \"Mn\", \"Fe\", \"Co\", \"Ni\", \"Cu\", \"Zn\", \"Ga\", \"Ge\",\n    \"As\", \"Se\", \"Br\", \"Kr\", \"Rb\", \"Sr\", \"Y\",  \"Zr\", \"Nb\", \"Mo\", \"Tc\",\n    \"Ru\", \"Rh\", \"Pd\", \"Ag\", \"Cd\", \"In\", \"Sn\", \"Sb\", \"Te\", \"I\",  \"Xe\",\n    \"Cs\", \"Ba\", \"La\", \"Ce\", \"Pr\", \"Nd\", \"Pm\", \"Sm\", \"Eu\", \"Gd\", \"Tb\",\n    \"Dy\", \"Ho\", \"Er\", \"Tm\", \"Yb\", \"Lu\", \"Hf\", \"Ta\", \"W\",  \"Re\", \"Os\",\n    \"Ir\", \"Pt\", \"Au\", \"Hg\", \"Tl\", \"Pb\", \"Bi\", \"Po\", \"At\", \"Rn\", \"Fr\",\n    \"Ra\", \"Ac\", \"Th\", \"Pa\", \"U\",  \"Np\", \"Pu\", \"Am\", \"Cm\", \"Bk\", \"Cf\",\n    \"Es\", \"Fm\", \"Md\", \"No\", \"Lr\", \"Rf\", \"Db\", \"Sg\", \"Bh\", \"Hs\", \"Mt\",\n    \"Ds\", \"Rg\"\n  };\n  static const int nr_pte_entries = sizeof(pte_label) / sizeof(char *);\n\n  /* corresponding table of masses. */\n  static const float pte_mass[] = {\n    /* X  */ 0.00000, 1.00794, 4.00260, 6.941, 9.012182, 10.811,\n    /* C  */ 12.0107, 14.0067, 15.9994, 18.9984032, 20.1797,\n    /* Na */ 22.989770, 24.3050, 26.981538, 28.0855, 30.973761,\n    /* S  */ 32.065, 35.453, 39.948, 39.0983, 40.078, 44.955910,\n    /* Ti */ 47.867, 50.9415, 51.9961, 54.938049, 55.845, 58.9332,\n    /* Ni */ 58.6934, 63.546, 65.409, 69.723, 72.64, 74.92160,\n    /* Se */ 78.96, 79.904, 83.798, 85.4678, 87.62, 88.90585,\n    /* Zr */ 91.224, 92.90638, 95.94, 98.0, 101.07, 102.90550,\n    /* Pd */ 106.42, 107.8682, 112.411, 114.818, 118.710, 121.760,\n    /* Te */ 127.60, 126.90447, 131.293, 132.90545, 137.327,\n    /* La */ 138.9055, 140.116, 140.90765, 144.24, 145.0, 150.36,\n    /* Eu */ 151.964, 157.25, 158.92534, 162.500, 164.93032,\n    /* Er */ 167.259, 168.93421, 173.04, 174.967, 178.49, 180.9479,\n    /* W  */ 183.84, 186.207, 190.23, 192.217, 195.078, 196.96655,\n    /* Hg */ 200.59, 204.3833, 207.2, 208.98038, 209.0, 210.0, 222.0,\n    /* Fr */ 223.0, 226.0, 227.0, 232.0381, 231.03588, 238.02891,\n    /* Np */ 237.0, 244.0, 243.0, 247.0, 247.0, 251.0, 252.0, 257.0,\n    /* Md */ 258.0, 259.0, 262.0, 261.0, 262.0, 266.0, 264.0, 269.0,\n    /* Mt */ 268.0, 271.0, 272.0\n  };\n\n  /*\n   * corresponding table of VDW radii.\n   * van der Waals radii are taken from A. Bondi,\n   * J. Phys. Chem., 68, 441 - 452, 1964,\n   * except the value for H, which is taken from R.S. Rowland & R. Taylor,\n   * J.Phys.Chem., 100, 7384 - 7391, 1996. Radii that are not available in\n   * either of these publications have RvdW = 2.00 \\AA.\n   * The radii for Ions (Na, K, Cl, Ca, Mg, and Cs are based on the CHARMM27\n   * Rmin/2 parameters for (SOD, POT, CLA, CAL, MG, CES) by default.\n   */\n  static const float pte_vdw_radius[] = {\n    /* X  */ 1.5, 1.2, 1.4, 1.82, 2.0, 2.0,\n    /* C  */ 1.7, 1.55, 1.52, 1.47, 1.54,\n    /* Na */ 1.36, 1.18, 2.0, 2.1, 1.8,\n    /* S  */ 1.8, 2.27, 1.88, 1.76, 1.37, 2.0,\n    /* Ti */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Ni */ 1.63, 1.4, 1.39, 1.07, 2.0, 1.85,\n    /* Se */ 1.9, 1.85, 2.02, 2.0, 2.0, 2.0,\n    /* Zr */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Pd */ 1.63, 1.72, 1.58, 1.93, 2.17, 2.0,\n    /* Te */ 2.06, 1.98, 2.16, 2.1, 2.0,\n    /* La */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Eu */ 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Er */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* W  */ 2.0, 2.0, 2.0, 2.0, 1.72, 1.66,\n    /* Hg */ 1.55, 1.96, 2.02, 2.0, 2.0, 2.0, 2.0,\n    /* Fr */ 2.0, 2.0, 2.0, 2.0, 2.0, 1.86,\n    /* Np */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Md */ 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n    /* Mt */ 2.0, 2.0, 2.0\n  };\n\n  /* lookup functions */\n\n  static const char *get_pte_label(const int idx)\n  {\n    if ((idx < 1) || (idx >= nr_pte_entries)) return pte_label[0];\n\n    return pte_label[idx];\n  }\n\n  static float get_pte_mass(const int idx)\n  {\n    if ((idx < 1) || (idx >= nr_pte_entries)) return pte_mass[0];\n\n    return pte_mass[idx];\n  }\n\n  static float get_pte_vdw_radius(const int idx)\n  {\n    if ((idx < 1) || (idx >= nr_pte_entries)) return pte_vdw_radius[0];\n\n#if 1\n    /* Replace with Hydrogen radius with an \"all-atom\" radius */\n    if (idx == 1)\n      return 1.0;    /* H  */\n#else\n    /* Replace with old VMD atom radii values */\n    switch (idx) {\n    case  1: return 1.0;    /* H  */\n    case  6: return 1.5;    /* C  */\n    case  7: return 1.4;    /* N  */\n    case  8: return 1.3;    /* O  */\n    case  9: return 1.2;    /* F  */\n    case 15: return 1.5;    /* P  */\n    case 16: return 1.9;    /* S  */\n    }\n#endif\n\n    return pte_vdw_radius[idx];\n  }\n\n  static int get_pte_idx_from_string(const char *label) {\n    int i, ind;\n    char atom[3];\n\n    if (label != nullptr) {\n      /* zap string */\n      atom[0] = atom[1] = atom[2] = '\\0';\n\n      for (ind=0,i=0; (ind<2) && (label[i]!='\\0'); i++) {\n        if (label[i] != ' ') {\n          atom[ind] = toupper(label[i]);\n          ind++;\n        }\n      }\n\n      if (ind < 1)\n        return 0; /* no non-whitespace characters */\n\n      for (i=0; i < nr_pte_entries; ++i) {\n        if ((toupper(pte_label[i][0]) == atom[0]) && (toupper(pte_label[i][1]) == atom[1]))\n          return i;\n      }\n    }\n\n    return 0;\n  }\n\n  // directory traversal helper functions\n\n#if defined(_WIN32)\n\n  // Win32 directory traversal handle\n  typedef struct {\n    HANDLE h;\n    WIN32_FIND_DATA fd;\n    char *name;\n    char *searchname;\n    int dlen;\n  } dirhandle_t;\n\n  // open a directory handle\n  static dirhandle_t *my_opendir(const char *dirname)\n  {\n    dirhandle_t *d;\n    int len;\n\n    if (dirname == nullptr)\n      return nullptr;\n    d = new dirhandle_t;\n\n    len = 2 + strlen(dirname);\n    d->name = new char[len];\n    strcpy(d->name, dirname);\n    strcat(d->name, \"\\\\\");\n    d->dlen = len;\n\n    len += 1;\n    d->searchname = new char[len];\n    strcpy(d->searchname, dirname);\n    strcat(d->searchname, \"\\\\*\");\n\n    d->h = FindFirstFile(d->searchname, &(d->fd));\n    if (d->h == ((HANDLE)(-1))) {\n      delete[] d->searchname;\n      delete[] d->name;\n      delete d;\n      return nullptr;\n    }\n    return d;\n  }\n\n  // get next file name from directory handle\n  static char *my_readdir(dirhandle_t *d)\n  {\n    if (FindNextFile(d->h, &(d->fd))) {\n      return d->fd.cFileName;\n    }\n    return nullptr;\n  }\n\n  // close directory handle\n  static void my_closedir(dirhandle_t *d)\n  {\n    if (d->h != nullptr) {\n      FindClose(d->h);\n    }\n    delete[] d->searchname;\n    delete[] d->name;\n    delete d;\n  }\n\n  // open a shared object file\n  static void *my_dlopen(const char *fname) {\n    return (void *)LoadLibrary(fname);\n  }\n\n  // resolve a symbol in shared object\n  static void *my_dlsym(void *h, const char *sym) {\n    return (void *)GetProcAddress((HINSTANCE)h, sym);\n  }\n\n  // close a shared object\n  static int my_dlclose(void *h) {\n    /* FreeLibrary returns nonzero on success */\n    return !FreeLibrary((HINSTANCE)h);\n  }\n\n#else\n\n  // Unix directory traversal handle\n  typedef struct {\n    DIR *d;\n    char *name;\n    int dlen;\n  } dirhandle_t;\n\n  // open a directory handle\n  static dirhandle_t *my_opendir(const char *dirname)\n  {\n    dirhandle_t *d;\n    int len;\n\n    if (dirname == nullptr) return nullptr;\n\n    d = new dirhandle_t;\n    len = 2 + strlen(dirname);\n    d->name = new char[len];\n    strcpy(d->name,dirname);\n    strcat(d->name,\"/\");\n    d->dlen = len;\n\n    d->d = opendir(d->name);\n    if (d->d == nullptr) {\n      delete[] d->name;\n      delete d;\n      return nullptr;\n    }\n    return d;\n  }\n\n  // get next file name from directory handle\n  static char *my_readdir(dirhandle_t *d)\n  {\n    struct dirent *p;\n\n    if ((p = readdir(d->d)) != nullptr) {\n      return p->d_name;\n    }\n\n    return nullptr;\n  }\n\n  // close directory handle\n  static void my_closedir(dirhandle_t *d)\n  {\n    if (d->d != nullptr) {\n      closedir(d->d);\n    }\n    delete[] d->name;\n    delete d;\n    return;\n  }\n\n  // open a shared object file\n  static void *my_dlopen(const char *fname) {\n    return dlopen(fname, RTLD_NOW);\n  }\n\n  // resolve a symbol in shared object\n  static void *my_dlsym(void *h, const char *sym) {\n    return dlsym(h, sym);\n  }\n\n  // close a shared object\n  static int my_dlclose(void *h) {\n    return dlclose(h);\n  }\n\n#endif\n\n} // end of extern \"C\" region\n\nusing namespace LAMMPS_NS;\n\n// constructor.\nMolfileInterface::MolfileInterface(const char *type, const int mode)\n  : _plugin(0), _dso(0), _ptr(0), _info(0), _natoms(0),\n    _mode(mode), _caps(M_NONE)\n{\n  _name = new char[5];\n  strcpy(_name,\"none\");\n  _type = new char[1+strlen(type)];\n  strcpy(_type,type);\n}\n\n// destructor.\nMolfileInterface::~MolfileInterface()\n{\n  forget_plugin();\n\n  if (_info) {\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    delete[] a;\n    _info = nullptr;\n  }\n  delete[] _name;\n  delete[] _type;\n}\n\n// register the best matching plugin in a given directory\nint MolfileInterface::find_plugin(const char *pluginpath)\n{\n  dirhandle_t *dir;\n  char *filename, *ext, *next, *path, *plugindir;\n  int retval = E_NONE;\n\n#if defined(_WIN32)\n#define MY_PATHSEP ';'\n#else\n#define MY_PATHSEP ':'\n#endif\n  if (pluginpath == nullptr) return E_DIR;\n  plugindir = path = strdup(pluginpath);\n\n  while (plugindir) {\n    // check if this a single directory or path.\n    next = strchr(plugindir,MY_PATHSEP);\n    if (next) {\n      *next = '\\0';\n      ++next;\n    }\n\n    dir = my_opendir(plugindir);\n    if (!dir)\n      retval = (retval > E_DIR) ? retval : E_DIR;\n\n    // search for suitable file names and try to inspect them\n    while (dir) {\n      char *fullname;\n      int len;\n\n      filename = my_readdir(dir);\n      if (filename == nullptr) break;\n\n      // only look at .so files\n      ext = strrchr(filename, '.');\n      if (ext == nullptr) continue;\n      if (strcasecmp(ext,\".so\") != 0) continue;\n\n      // construct full pathname of potential DSO\n      len = dir->dlen;\n      len += strlen(filename);\n      fullname = new char[len];\n      strcpy(fullname,dir->name);\n      strcat(fullname,filename);\n\n      // try to register plugin at file name.\n      int rv = load_plugin(fullname);\n      if (rv > retval) retval = rv;\n\n      delete[] fullname;\n    }\n    if (dir)\n      my_closedir(dir);\n\n    plugindir = next;\n  }\n  free(path);\n  return retval;\n}\n\n// register the best matching plugin in a given directory\nint MolfileInterface::load_plugin(const char *filename)\n{\n  void *dso;\n  int len, retval = E_NONE;\n\n  // access shared object\n  dso = my_dlopen(filename);\n  if (dso == nullptr)\n    return E_FILE;\n\n  // check for required plugin symbols\n  void *ifunc = my_dlsym(dso,\"vmdplugin_init\");\n  void *rfunc = my_dlsym(dso,\"vmdplugin_register\");\n  void *ffunc = my_dlsym(dso,\"vmdplugin_fini\");\n  if (ifunc == nullptr || rfunc == nullptr || ffunc == nullptr) {\n    my_dlclose(dso);\n    return E_SYMBOL;\n  }\n\n  // initialize plugin. skip plugin if it fails.\n  if (((initfunc)(ifunc))()) {\n    my_dlclose(dso);\n    return E_SYMBOL;\n  }\n\n  // pre-register plugin.\n  // the callback will be called for each plugin in the DSO and\n  // check the file type. plugin->name will change if successful.\n  plugin_reginfo_t reginfo;\n  reginfo.p = nullptr;\n  reginfo.name=_type;\n  ((regfunc)rfunc)(&reginfo, plugin_register_cb);\n\n  // make some checks to see if the plugin is suitable or not.\n  molfile_plugin_t *plugin = static_cast<molfile_plugin_t *>(reginfo.p);\n\n  // if the callback found a matching plugin and copied the struct,\n  // its name element will point to a different location now.\n  if (plugin == nullptr) {\n    retval = E_TYPE;\n\n    // check if the ABI matches the one used to compile this code\n  } else if (plugin->abiversion != vmdplugin_ABIVERSION) {\n    retval = E_ABI;\n\n    // check if (basic) reading is supported\n  } else if ((_mode & M_READ) &&\n             ( (plugin->open_file_read == nullptr) ||\n               (plugin->read_next_timestep  == nullptr) ||\n               (plugin->close_file_read == nullptr) )) {\n    retval = E_MODE;\n\n    // check if (basic) writing is supported\n  } else if ( (_mode & M_WRITE) &&\n              ( (plugin->open_file_write == nullptr) ||\n                (plugin->write_timestep  == nullptr) ||\n                (plugin->close_file_write == nullptr) )) {\n    retval = E_MODE;\n\n    // make some additional check, if we\n    // already have a plugin registered.\n    // NOTE: this has to come last.\n  } else if (_dso && _plugin) {\n    molfile_plugin_t *p;\n    p = static_cast<molfile_plugin_t *>(_plugin);\n\n    // check if the new plugin is of a newer major version\n    if (p->majorv > plugin->majorv) {\n      retval = E_VERSION;\n\n    // check if the new plugin is of a newer minor version\n    } else if ( (p->majorv == plugin->majorv) &&\n                (p->minorv >= plugin->minorv)) {\n      retval = E_VERSION;\n    }\n  }\n\n  // bingo! this one is a keeper.\n  if (retval == E_NONE) {\n\n    // make sure any existing plugin is wiped out\n    forget_plugin();\n\n    delete[] _name;\n    len = 16;\n    len += strlen(plugin->prettyname);\n    len += strlen(plugin->author);\n    _name = new char[len];\n    sprintf(_name,\"%s v%d.%d by %s\",plugin->prettyname,\n            plugin->majorv, plugin->minorv, plugin->author);\n\n    // determine plugin capabilities\n    _caps = M_NONE;\n    if (plugin->read_next_timestep)      _caps |= M_READ;\n    if (plugin->write_timestep)          _caps |= M_WRITE;\n#if vmdplugin_ABIVERSION > 10\n    // required to tell if velocities are present\n    if (plugin->read_timestep_metadata)  _caps |= M_RVELS;\n    // we can always offer velocities. we may not know if\n    // they will be written by the plugin though.\n    if (plugin->write_timestep)          _caps |= M_WVELS;\n#endif\n    if (plugin->read_structure)          _caps |= M_RSTRUCT;\n    if (plugin->write_structure)         _caps |= M_WSTRUCT;\n    if (plugin->read_bonds)              _caps |= M_RBONDS;\n    if (plugin->write_bonds)             _caps |= M_WBONDS;\n    if (plugin->read_angles)             _caps |= M_RANGLES;\n    if (plugin->write_angles)            _caps |= M_WANGLES;\n    if (plugin->read_volumetric_data)    _caps |= M_RVOL;\n    if (plugin->write_volumetric_data)   _caps |= M_WVOL;\n\n    if (_mode & M_WRITE) {\n      _mode |= (_caps & M_WSTRUCT);\n      _mode |= (_caps & M_WVELS);\n    } else if (_mode & M_READ) {\n      _mode |= (_caps & M_RSTRUCT);\n      _mode |= (_caps & M_RVELS);\n    }\n\n    _plugin = plugin;\n    _dso = dso;\n    return E_MATCH;\n  }\n\n  // better luck next time. clean up and return.\n  my_dlclose(dso);\n  return retval;\n}\n\n// deregister a plugin and close or reset all associated objects.\nvoid MolfileInterface::forget_plugin()\n{\n  if (_ptr)\n    close();\n\n  if (_plugin)\n    _plugin = nullptr;\n\n  if (_dso) {\n    void *ffunc = my_dlsym(_dso,\"vmdplugin_fini\");\n    if (ffunc)\n      ((finifunc)ffunc)();\n    my_dlclose(_dso);\n  }\n  _dso = nullptr;\n\n  delete[] _name;\n    _name = new char[5];\n  strcpy(_name,\"none\");\n\n  _caps = M_NONE;\n}\n\n// open file for reading or writing\nint MolfileInterface::open(const char *name, int *natoms)\n{\n  if (!_plugin || !_dso || !natoms)\n    return E_FILE;\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n\n  if (_mode & M_WRITE)\n    _ptr = p->open_file_write(name,_type,*natoms);\n  else if (_mode & M_READ)\n    _ptr = p->open_file_read(name,_type,natoms);\n\n  if (_ptr == nullptr)\n    return E_FILE;\n\n  _natoms = *natoms;\n  // we need to deal with structure information,\n  // so we allocate and initialize storage for it.\n  if (_mode & (M_RSTRUCT|M_WSTRUCT)) {\n    molfile_atom_t *a = new molfile_atom_t[_natoms];\n    _info = a;\n    memset(_info,0,_natoms*sizeof(molfile_atom_t));\n    for (int i=0; i < _natoms; ++i) {\n      a[i].name[0] = 'X';\n      a[i].type[0] = a[i].resname[0] = a[i].segid[0] = 'U';\n      a[i].type[1] = a[i].resname[1] = a[i].segid[1] = 'N';\n      a[i].type[2] = a[i].resname[2] = a[i].segid[2] = 'K';\n      a[i].chain[0] = 'X';\n    }\n  }\n  return E_NONE;\n}\n\n// get of set atom structure information\nint MolfileInterface::structure()\n{\n  if (!_plugin || !_dso)\n    return E_FILE;\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n\n  int optflags = MOLFILE_NOOPTIONS;\n\n  if (_mode & M_WSTRUCT) {\n    optflags |= (_props & P_BFAC) ? MOLFILE_BFACTOR : 0;\n    optflags |= (_props & P_OCCP) ? MOLFILE_OCCUPANCY : 0;\n    optflags |= (_props & P_MASS) ? MOLFILE_MASS : 0;\n    optflags |= (_props & P_CHRG) ? MOLFILE_CHARGE : 0;\n    optflags |= (_props & P_RADS) ? MOLFILE_RADIUS : 0;\n    optflags |= (_props & P_ATMN) ? MOLFILE_ATOMICNUMBER : 0;\n\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    p->write_structure(_ptr,optflags,a);\n  } else if (_mode & M_RSTRUCT) {\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    p->read_structure(_ptr,&optflags,a);\n    // mandatory properties\n    _props = P_NAME|P_TYPE|P_RESN|P_RESI|P_SEGN|P_CHAI;\n    // optional properties\n    _props |= (optflags & MOLFILE_BFACTOR) ? P_BFAC : 0;\n    _props |= (optflags & MOLFILE_OCCUPANCY) ? P_OCCP : 0;\n    _props |= (optflags & MOLFILE_MASS) ? P_MASS : 0;\n    _props |= (optflags & MOLFILE_CHARGE) ? P_CHRG : 0;\n    _props |= (optflags & MOLFILE_RADIUS) ? P_RADS : 0;\n    _props |= (optflags & MOLFILE_ATOMICNUMBER) ? P_ATMN : 0;\n  }\n  return 0;\n}\n\n// safely close file\nint MolfileInterface::close()\n{\n  if (!_plugin || !_dso || !_ptr)\n    return E_FILE;\n\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n\n  if (_mode & M_WRITE) {\n    p->close_file_write(_ptr);\n  } else if (_mode & M_READ) {\n    p->close_file_read(_ptr);\n  }\n\n  if (_info) {\n    molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n    delete[] a;\n    _info = nullptr;\n  }\n  _ptr = nullptr;\n  _natoms = 0;\n\n  return E_NONE;\n}\n\n\n// read or write timestep\nint MolfileInterface::timestep(float *coords, float *vels,\n                               float *cell, double *simtime)\n{\n  if (!_plugin || !_dso || !_ptr)\n    return 1;\n\n  molfile_plugin_t *p = static_cast<molfile_plugin_t *>(_plugin);\n  molfile_timestep_t *t = new molfile_timestep_t;\n  int rv;\n\n  if (_mode & M_WRITE) {\n    t->coords = coords;\n    t->velocities = vels;\n    if (cell != nullptr) {\n      t->A = cell[0];\n      t->B = cell[1];\n      t->C = cell[2];\n      t->alpha = cell[3];\n      t->beta = cell[4];\n      t->gamma = cell[5];\n    } else {\n      t->A = 0.0f;\n      t->B = 0.0f;\n      t->C = 0.0f;\n      t->alpha = 90.0f;\n      t->beta = 90.0f;\n      t->gamma = 90.0f;\n    }\n\n    if (simtime)\n      t->physical_time = *simtime;\n    else\n      t->physical_time = 0.0;\n\n    rv = p->write_timestep(_ptr,t);\n\n  } else {\n    // no coordinate storage => skip step\n    if (coords == nullptr) {\n      rv = p->read_next_timestep(_ptr, _natoms, nullptr);\n    } else {\n      t->coords = coords;\n      t->velocities = vels;\n      t->A = 0.0f;\n      t->B = 0.0f;\n      t->C = 0.0f;\n      t->alpha = 90.0f;\n      t->beta = 90.0f;\n      t->gamma = 90.0f;\n      t->physical_time = 0.0;\n      rv = p->read_next_timestep(_ptr, _natoms, t);\n      if (cell != nullptr) {\n        cell[0] = t->A;\n        cell[1] = t->B;\n        cell[2] = t->C;\n        cell[3] = t->alpha;\n        cell[4] = t->beta;\n        cell[5] = t->gamma;\n      }\n      if (simtime)\n        *simtime = t->physical_time;\n    }\n\n    if (rv == MOLFILE_EOF) {\n      delete t;\n      return 1;\n    }\n  }\n\n  delete t;\n  return 0;\n}\n\n// functions to read properties from molfile structure\n\n#define PROPUPDATE(PROP,ENTRY,VAL)              \\\n  if (propid == PROP) { VAL = a.ENTRY; }\n\n#define PROPSTRCPY(PROP,ENTRY,VAL)              \\\n  if (propid == PROP) { strcpy(VAL,a.ENTRY); }\n\n// single precision floating point props\nstatic float read_float_property(molfile_atom_t &a, const int propid)\n{\n  float prop = 0.0f;\n  int iprop = 0;\n  PROPUPDATE(MolfileInterface::P_OCCP,occupancy,prop);\n  PROPUPDATE(MolfileInterface::P_BFAC,bfactor,prop);\n  PROPUPDATE(MolfileInterface::P_MASS,mass,prop);\n  PROPUPDATE(MolfileInterface::P_CHRG,charge,prop);\n  PROPUPDATE(MolfileInterface::P_RADS,radius,prop);\n\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_MASS),\n             atomicnumber,iprop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_RADS),\n             atomicnumber,iprop);\n  if (propid & MolfileInterface::P_ATMN) {\n    if (propid & MolfileInterface::P_MASS)\n      prop = get_pte_mass(iprop);\n    if (propid & MolfileInterface::P_RADS)\n      prop = get_pte_vdw_radius(iprop);\n  }\n\n  return prop;\n}\n\n// integer and derived props\nstatic int read_int_property(molfile_atom_t &a, const int propid)\n{\n  int prop = 0;\n  const char * sprop;\n\n  PROPUPDATE(MolfileInterface::P_RESI,resid,prop);\n  PROPUPDATE(MolfileInterface::P_ATMN,atomicnumber,prop);\n\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_NAME),\n             name,sprop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_TYPE),\n             type,sprop);\n\n  if (propid & MolfileInterface::P_ATMN) {\n    if (propid & (MolfileInterface::P_NAME|MolfileInterface::P_TYPE))\n      prop = get_pte_idx_from_string(sprop);\n  }\n\n  return prop;\n}\n\n// string and derived props\nstatic const char *read_string_property(molfile_atom_t &a,\n                                        const int propid)\n{\n  const char *prop = nullptr;\n  int iprop = 0;\n  PROPUPDATE(MolfileInterface::P_NAME,name,prop);\n  PROPUPDATE(MolfileInterface::P_TYPE,type,prop);\n  PROPUPDATE(MolfileInterface::P_RESN,resname,prop);\n  PROPUPDATE(MolfileInterface::P_SEGN,segid,prop);\n\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_NAME),\n             atomicnumber,iprop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_TYPE),\n             atomicnumber,iprop);\n\n  if (propid & MolfileInterface::P_ATMN) {\n    if (propid & (MolfileInterface::P_NAME|MolfileInterface::P_TYPE))\n      prop = get_pte_label(iprop);\n  }\n\n  return prop;\n}\n#undef PROPUPDATE\n#undef PROPSTRCPY\n\n// functions to store properties into molfile structure\n\n#define PROPUPDATE(PROP,ENTRY,VAL)                                  \\\n  if ((propid & PROP) == PROP) { a.ENTRY = VAL; plist |= PROP; }\n\n#define PROPSTRCPY(PROP,ENTRY,VAL)                                      \\\n  if ((propid & PROP) == PROP) { strcpy(a.ENTRY,VAL); plist |= PROP; }\n\n// floating point props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const float prop)\n{\n  int plist = MolfileInterface::P_NONE;\n  PROPUPDATE(MolfileInterface::P_OCCP,occupancy,prop);\n  PROPUPDATE(MolfileInterface::P_BFAC,bfactor,prop);\n  PROPUPDATE(MolfileInterface::P_MASS,mass,prop);\n  PROPUPDATE(MolfileInterface::P_CHRG,charge,prop);\n  PROPUPDATE(MolfileInterface::P_RADS,radius,prop);\n  return plist;\n}\n\n// double precision floating point props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const double prop)\n{\n  return write_atom_property(a,propid,static_cast<float>(prop));\n}\n\n// integer and derived props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const int prop)\n{\n  int plist = MolfileInterface::P_NONE;\n  PROPUPDATE(MolfileInterface::P_RESI,resid,prop);\n  PROPUPDATE(MolfileInterface::P_ATMN,atomicnumber,prop);\n  PROPUPDATE((MolfileInterface::P_ATMN|MolfileInterface::P_MASS),\n             mass,get_pte_mass(prop));\n  PROPSTRCPY((MolfileInterface::P_ATMN|MolfileInterface::P_NAME),\n             name,get_pte_label(prop));\n  PROPSTRCPY((MolfileInterface::P_ATMN|MolfileInterface::P_TYPE),\n             type,get_pte_label(prop));\n  return plist;\n}\n\n// integer and derived props\nstatic int write_atom_property(molfile_atom_t &a,\n                               const int propid,\n                               const char *prop)\n{\n  int plist = MolfileInterface::P_NONE;\n  PROPSTRCPY(MolfileInterface::P_NAME,name,prop);\n  PROPSTRCPY(MolfileInterface::P_TYPE,type,prop);\n  PROPSTRCPY(MolfileInterface::P_RESN,resname,prop);\n  PROPSTRCPY(MolfileInterface::P_SEGN,segid,prop);\n  return plist;\n}\n#undef PROPUPDATE\n#undef PROPSTRCPY\n\n// set/get atom floating point property\nint MolfileInterface::property(int propid, int idx, float *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT)\n    _props |= write_atom_property(a[idx], propid, *prop);\n\n  if (_mode & M_RSTRUCT)\n    *prop = read_float_property(a[idx], propid);\n\n  return _props;\n}\n\n// set/get per type floating point property\nint MolfileInterface::property(int propid, int *types, float *prop)\n{\n  if ((_info == nullptr) || (types == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n  }\n\n  // useless for reading.\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom floating point property\nint MolfileInterface::property(int propid, float *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[i]);\n  }\n\n  if (_mode & M_RSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      prop[i] = read_float_property(a[i], propid);\n  }\n\n  return _props;\n}\n\n// set/get atom floating point property\nint MolfileInterface::property(int propid, int idx, double *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT)\n    return write_atom_property(a[idx], propid, *prop);\n\n  if (_mode & M_RSTRUCT)\n    *prop = static_cast<double>(read_float_property(a[idx], propid));\n\n  return _props;\n}\n\n// set/get per type floating point property\nint MolfileInterface::property(int propid, int *types, double *prop)\n{\n  if ((_info == nullptr) || (types == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n  }\n\n  // useless for reading\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom floating point property\nint MolfileInterface::property(int propid, double *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[i]);\n  }\n  if (_mode & M_RSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      prop[i] = static_cast<double>(read_float_property(a[i], propid));\n  }\n\n  return _props;\n}\n\n#define INT_TO_STRING_BODY(IDX)                         \\\n  buf[15] = 0;                                          \\\n  if (propid & P_NAME)                                  \\\n    _props |= write_atom_property(a[IDX],P_NAME,buf);   \\\n  if (propid & P_TYPE)                                  \\\n    _props |= write_atom_property(a[IDX],P_TYPE,buf);   \\\n  buf[7] = 0;                                           \\\n  if (propid & P_RESN)                                  \\\n    _props |= write_atom_property(a[IDX],P_RESN,buf);   \\\n  if (propid & P_SEGN)                                  \\\n    _props |= write_atom_property(a[IDX],P_SEGN,buf);   \\\n  buf[1] = 0;                                           \\\n  if (propid & P_CHAI)                                  \\\n    _props |= write_atom_property(a[IDX],P_CHAI,buf)\n\n// set/get atom integer property\nint MolfileInterface::property(int propid, int idx, int *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    char buf[64];\n\n    _props |= write_atom_property(a[idx], propid, *prop);\n\n    if (propid & (P_NAME|P_TYPE|P_RESN|P_SEGN|P_CHAI)) {\n      sprintf(buf,\"%d\",*prop);\n      INT_TO_STRING_BODY(idx);\n    }\n  }\n\n  if (_mode & M_RSTRUCT)\n    *prop = read_int_property(a[idx], propid);\n\n  return _props;\n}\n\n// set/get per type integer property\nint MolfileInterface::property(int propid, int *types, int *prop)\n{\n  if ((_info == nullptr) || (types == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    char buf[64];\n\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n\n    if (propid & (P_NAME|P_TYPE|P_RESN|P_SEGN|P_CHAI)) {\n      for (int i=0; i < _natoms; ++i) {\n        sprintf(buf,\"%d\",prop[types[i]]);\n        INT_TO_STRING_BODY(i);\n      }\n    }\n  }\n\n  // useless when reading\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom integer property\nint MolfileInterface::property(int propid, int *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    char buf[64];\n\n    for (int i=0; i < _natoms; ++i)\n      _props |= write_atom_property(a[i],propid,prop[i]);\n\n    if (propid & (P_NAME|P_TYPE|P_RESN|P_SEGN|P_CHAI)) {\n      for (int i=0; i < _natoms; ++i) {\n        sprintf(buf,\"%d\",prop[i]);\n        INT_TO_STRING_BODY(i);\n      }\n    }\n  }\n\n  if (_mode & M_RSTRUCT) {\n    for (int i=0; i < _natoms; ++i)\n      prop[i] = read_int_property(a[i], propid);\n  }\n\n  return _props;\n}\n#undef INT_TO_STRING_BODY\n\n// set/get atom string property\nint MolfileInterface::property(int propid, int idx, char *prop)\n{\n  if ((_info == nullptr) || (prop == nullptr) || (idx < 0) || (idx >= _natoms))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    _props |= write_atom_property(a[idx], propid, prop);\n  }\n\n  if (_mode & M_RSTRUCT)\n    strcpy(prop,read_string_property(a[idx], propid));\n\n  return _props;\n}\n\n// set/get per type string property\nint MolfileInterface::property(int propid, int *types, char **prop)\n{\n  if ((_info == nullptr) || (types == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i) {\n      _props |= write_atom_property(a[i], propid, prop[types[i]]);\n    }\n  }\n\n  // useless when reading\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n\n// set/get per atom string property\nint MolfileInterface::property(int propid, char **prop)\n{\n  if ((_info == nullptr) || (prop == nullptr))\n    return P_NONE;\n\n  molfile_atom_t *a = static_cast<molfile_atom_t *>(_info);\n\n  if (_mode & M_WSTRUCT) {\n    for (int i=0; i < _natoms; ++i) {\n      _props |= write_atom_property(a[i], propid, prop[i]);\n    }\n  }\n\n  // not supported right now. XXX: should we use strdup() here?\n  if (_mode & M_RSTRUCT)\n    return P_NONE;\n\n  return _props;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/lib/kokkos/core/src/impl/Kokkos_Profiling.cpp": "/*\n//@HEADER\n// ************************************************************************\n//\n//                        Kokkos v. 3.0\n//       Copyright (2020) National Technology & Engineering\n//               Solutions of Sandia, LLC (NTESS).\n//\n// Under the terms of Contract DE-NA0003525 with NTESS,\n// the U.S. Government retains certain rights in this software.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the Corporation nor the names of the\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Questions? Contact Christian R. Trott (crtrott@sandia.gov)\n//\n// ************************************************************************\n//@HEADER\n*/\n\n#include <Kokkos_Macros.hpp>\n#include <Kokkos_Tuners.hpp>\n#include <impl/Kokkos_Profiling.hpp>\n#if defined(KOKKOS_ENABLE_LIBDL)\n#include <dlfcn.h>\n#endif\n\n#include <cstring>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <stack>\n#include <iostream>\nnamespace Kokkos {\n\nnamespace Tools {\n\nnamespace Experimental {\n#ifdef KOKKOS_ENABLE_TUNING\nstatic size_t kernel_name_context_variable_id;\nstatic size_t kernel_type_context_variable_id;\nstatic std::unordered_map<size_t, std::unordered_set<size_t>>\n    features_per_context;\nstatic std::unordered_set<size_t> active_features;\nstatic std::unordered_map<size_t, VariableValue> feature_values;\nstatic std::unordered_map<size_t, VariableInfo> variable_metadata;\n#endif\nstatic EventSet current_callbacks;\nstatic EventSet backup_callbacks;\nstatic EventSet no_profiling;\n\nbool eventSetsEqual(const EventSet& l, const EventSet& r) {\n  return l.init == r.init && l.finalize == r.finalize &&\n         l.begin_parallel_for == r.begin_parallel_for &&\n         l.end_parallel_for == r.end_parallel_for &&\n         l.begin_parallel_reduce == r.begin_parallel_reduce &&\n         l.end_parallel_reduce == r.end_parallel_reduce &&\n         l.begin_parallel_scan == r.begin_parallel_scan &&\n         l.end_parallel_scan == r.end_parallel_scan &&\n         l.push_region == r.push_region && l.pop_region == r.pop_region &&\n         l.allocate_data == r.allocate_data &&\n         l.deallocate_data == r.deallocate_data &&\n         l.create_profile_section == r.create_profile_section &&\n         l.start_profile_section == r.start_profile_section &&\n         l.stop_profile_section == r.stop_profile_section &&\n         l.destroy_profile_section == r.destroy_profile_section &&\n         l.profile_event == r.profile_event &&\n         l.begin_deep_copy == r.begin_deep_copy &&\n         l.end_deep_copy == r.end_deep_copy && l.begin_fence == r.begin_fence &&\n         l.end_fence == r.end_fence && l.sync_dual_view == r.sync_dual_view &&\n         l.modify_dual_view == r.modify_dual_view &&\n         l.declare_input_type == r.declare_input_type &&\n         l.declare_output_type == r.declare_output_type &&\n         l.end_tuning_context == r.end_tuning_context &&\n         l.begin_tuning_context == r.begin_tuning_context &&\n         l.request_output_values == r.request_output_values &&\n         l.declare_optimization_goal == r.declare_optimization_goal;\n}\n}  // namespace Experimental\nbool profileLibraryLoaded() {\n  return !Experimental::eventSetsEqual(Experimental::current_callbacks,\n                                       Experimental::no_profiling);\n}\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,\n                      uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_for != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_for)(kernelPrefix.c_str(),\n                                                          devID, kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n  }\n#endif\n}\n\nvoid endParallelFor(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_for != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_for)(kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    Experimental::end_context(Experimental::get_current_context_id());\n  }\n#endif\n}\n\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,\n                       uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_scan != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_scan)(kernelPrefix.c_str(),\n                                                           devID, kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n  }\n#endif\n}\n\nvoid endParallelScan(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_scan != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_scan)(kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    Experimental::end_context(Experimental::get_current_context_id());\n  }\n#endif\n}\n\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,\n                         uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_reduce != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_reduce)(\n        kernelPrefix.c_str(), devID, kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n  }\n#endif\n}\n\nvoid endParallelReduce(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_reduce != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_reduce)(kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    Experimental::end_context(Experimental::get_current_context_id());\n  }\n#endif\n}\n\nvoid pushRegion(const std::string& kName) {\n  if (Experimental::current_callbacks.push_region != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.push_region)(kName.c_str());\n  }\n}\n\nvoid popRegion() {\n  if (Experimental::current_callbacks.pop_region != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.pop_region)();\n  }\n}\n\nvoid allocateData(const SpaceHandle space, const std::string label,\n                  const void* ptr, const uint64_t size) {\n  if (Experimental::current_callbacks.allocate_data != nullptr) {\n    (*Experimental::current_callbacks.allocate_data)(space, label.c_str(), ptr,\n                                                     size);\n  }\n}\n\nvoid deallocateData(const SpaceHandle space, const std::string label,\n                    const void* ptr, const uint64_t size) {\n  if (Experimental::current_callbacks.deallocate_data != nullptr) {\n    (*Experimental::current_callbacks.deallocate_data)(space, label.c_str(),\n                                                       ptr, size);\n  }\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,\n                   const void* dst_ptr, const SpaceHandle src_space,\n                   const std::string src_label, const void* src_ptr,\n                   const uint64_t size) {\n  if (Experimental::current_callbacks.begin_deep_copy != nullptr) {\n    (*Experimental::current_callbacks.begin_deep_copy)(\n        dst_space, dst_label.c_str(), dst_ptr, src_space, src_label.c_str(),\n        src_ptr, size);\n#ifdef KOKKOS_ENABLE_TUNING\n    if (Kokkos::tune_internals()) {\n      auto context_id = Experimental::get_new_context_id();\n      Experimental::begin_context(context_id);\n      Experimental::VariableValue contextValues[] = {\n          Experimental::make_variable_value(\n              Experimental::kernel_name_context_variable_id,\n              \"deep_copy_kernel\"),\n          Experimental::make_variable_value(\n              Experimental::kernel_type_context_variable_id, \"deep_copy\")};\n      Experimental::set_input_values(context_id, 2, contextValues);\n    }\n#endif\n  }\n}\n\nvoid endDeepCopy() {\n  if (Experimental::current_callbacks.end_deep_copy != nullptr) {\n    (*Experimental::current_callbacks.end_deep_copy)();\n#ifdef KOKKOS_ENABLE_TUNING\n    if (Kokkos::tune_internals()) {\n      Experimental::end_context(Experimental::get_current_context_id());\n    }\n#endif\n  }\n}\n\nvoid beginFence(const std::string name, const uint32_t deviceId,\n                uint64_t* handle) {\n  if (Experimental::current_callbacks.begin_fence != nullptr) {\n    (*Experimental::current_callbacks.begin_fence)(name.c_str(), deviceId,\n                                                   handle);\n  }\n}\n\nvoid endFence(const uint64_t handle) {\n  if (Experimental::current_callbacks.end_fence != nullptr) {\n    (*Experimental::current_callbacks.end_fence)(handle);\n  }\n}\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n  if (Experimental::current_callbacks.create_profile_section != nullptr) {\n    (*Experimental::current_callbacks.create_profile_section)(\n        sectionName.c_str(), secID);\n  }\n}\n\nvoid startSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.start_profile_section != nullptr) {\n    (*Experimental::current_callbacks.start_profile_section)(secID);\n  }\n}\n\nvoid stopSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.stop_profile_section != nullptr) {\n    (*Experimental::current_callbacks.stop_profile_section)(secID);\n  }\n}\n\nvoid destroyProfileSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.destroy_profile_section != nullptr) {\n    (*Experimental::current_callbacks.destroy_profile_section)(secID);\n  }\n}\n\nvoid markEvent(const std::string& eventName) {\n  if (Experimental::current_callbacks.profile_event != nullptr) {\n    (*Experimental::current_callbacks.profile_event)(eventName.c_str());\n  }\n}\n\nSpaceHandle make_space_handle(const char* space_name) {\n  SpaceHandle handle;\n  strncpy(handle.name, space_name, 63);\n  return handle;\n}\n\nvoid initialize() {\n  // Make sure initialize calls happens only once\n  static int is_initialized = 0;\n  if (is_initialized) return;\n  is_initialized = 1;\n\n#ifdef KOKKOS_ENABLE_LIBDL\n  void* firstProfileLibrary = nullptr;\n\n  char* envProfileLibrary = getenv(\"KOKKOS_PROFILE_LIBRARY\");\n\n  // If we do not find a profiling library in the environment then exit\n  // early.\n  if (envProfileLibrary == nullptr) {\n    return;\n  }\n\n  char* envProfileCopy =\n      (char*)malloc(sizeof(char) * (strlen(envProfileLibrary) + 1));\n  sprintf(envProfileCopy, \"%s\", envProfileLibrary);\n\n  char* profileLibraryName = strtok(envProfileCopy, \";\");\n\n  if ((profileLibraryName != nullptr) &&\n      (strcmp(profileLibraryName, \"\") != 0)) {\n    firstProfileLibrary = dlopen(profileLibraryName, RTLD_NOW | RTLD_GLOBAL);\n\n    if (firstProfileLibrary == nullptr) {\n      std::cerr << \"Error: Unable to load KokkosP library: \"\n                << profileLibraryName << std::endl;\n      std::cerr << \"dlopen(\" << profileLibraryName\n                << \", RTLD_NOW | RTLD_GLOBAL) failed with \" << dlerror()\n                << '\\n';\n    } else {\n#ifdef KOKKOS_ENABLE_PROFILING_LOAD_PRINT\n      std::cout << \"KokkosP: Library Loaded: \" << profileLibraryName\n                << std::endl;\n#endif\n      // dlsym returns a pointer to an object, while we want to assign to\n      // pointer to function A direct cast will give warnings hence, we have to\n      // workaround the issue by casting pointer to pointers.\n      auto p1 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_for\");\n      Experimental::set_begin_parallel_for_callback(\n          *reinterpret_cast<beginFunction*>(&p1));\n      auto p2 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_scan\");\n      Experimental::set_begin_parallel_scan_callback(\n          *reinterpret_cast<beginFunction*>(&p2));\n      auto p3 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_reduce\");\n      Experimental::set_begin_parallel_reduce_callback(\n          *reinterpret_cast<beginFunction*>(&p3));\n\n      auto p4 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_scan\");\n      Experimental::set_end_parallel_scan_callback(\n          *reinterpret_cast<endFunction*>(&p4));\n      auto p5 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_for\");\n      Experimental::set_end_parallel_for_callback(\n          *reinterpret_cast<endFunction*>(&p5));\n      auto p6 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_reduce\");\n      Experimental::set_end_parallel_reduce_callback(\n          *reinterpret_cast<endFunction*>(&p6));\n\n      auto p7 = dlsym(firstProfileLibrary, \"kokkosp_init_library\");\n      Experimental::set_init_callback(*reinterpret_cast<initFunction*>(&p7));\n      auto p8 = dlsym(firstProfileLibrary, \"kokkosp_finalize_library\");\n      Experimental::set_finalize_callback(\n          *reinterpret_cast<finalizeFunction*>(&p8));\n\n      auto p9 = dlsym(firstProfileLibrary, \"kokkosp_push_profile_region\");\n      Experimental::set_push_region_callback(\n          *reinterpret_cast<pushFunction*>(&p9));\n      auto p10 = dlsym(firstProfileLibrary, \"kokkosp_pop_profile_region\");\n      Experimental::set_pop_region_callback(\n          *reinterpret_cast<popFunction*>(&p10));\n\n      auto p11 = dlsym(firstProfileLibrary, \"kokkosp_allocate_data\");\n      Experimental::set_allocate_data_callback(\n          *reinterpret_cast<allocateDataFunction*>(&p11));\n      auto p12 = dlsym(firstProfileLibrary, \"kokkosp_deallocate_data\");\n      Experimental::set_deallocate_data_callback(\n          *reinterpret_cast<deallocateDataFunction*>(&p12));\n\n      auto p13 = dlsym(firstProfileLibrary, \"kokkosp_begin_deep_copy\");\n      Experimental::set_begin_deep_copy_callback(\n          *reinterpret_cast<beginDeepCopyFunction*>(&p13));\n      auto p14 = dlsym(firstProfileLibrary, \"kokkosp_end_deep_copy\");\n      Experimental::set_end_deep_copy_callback(\n          *reinterpret_cast<endDeepCopyFunction*>(&p14));\n\n      auto p15 = dlsym(firstProfileLibrary, \"kokkosp_begin_fence\");\n      Experimental::set_begin_fence_callback(\n          *reinterpret_cast<beginFenceFunction*>(&p15));\n      auto p16 = dlsym(firstProfileLibrary, \"kokkosp_end_fence\");\n      Experimental::set_end_fence_callback(\n          *reinterpret_cast<endFenceFunction*>(&p16));\n\n      auto p17 = dlsym(firstProfileLibrary, \"kokkosp_dual_view_sync\");\n      Experimental::set_dual_view_sync_callback(\n          *reinterpret_cast<dualViewSyncFunction*>(&p17));\n      auto p18 = dlsym(firstProfileLibrary, \"kokkosp_dual_view_modify\");\n      Experimental::set_dual_view_modify_callback(\n          *reinterpret_cast<dualViewModifyFunction*>(&p18));\n\n      auto p19 = dlsym(firstProfileLibrary, \"kokkosp_create_profile_section\");\n      Experimental::set_create_profile_section_callback(\n          *(reinterpret_cast<createProfileSectionFunction*>(&p19)));\n      auto p20 = dlsym(firstProfileLibrary, \"kokkosp_start_profile_section\");\n      Experimental::set_start_profile_section_callback(\n          *reinterpret_cast<startProfileSectionFunction*>(&p20));\n      auto p21 = dlsym(firstProfileLibrary, \"kokkosp_stop_profile_section\");\n      Experimental::set_stop_profile_section_callback(\n          *reinterpret_cast<stopProfileSectionFunction*>(&p21));\n      auto p22 = dlsym(firstProfileLibrary, \"kokkosp_destroy_profile_section\");\n      Experimental::set_destroy_profile_section_callback(\n          *(reinterpret_cast<destroyProfileSectionFunction*>(&p22)));\n\n      auto p23 = dlsym(firstProfileLibrary, \"kokkosp_profile_event\");\n      Experimental::set_profile_event_callback(\n          *reinterpret_cast<profileEventFunction*>(&p23));\n\n#ifdef KOKKOS_ENABLE_TUNING\n      auto p24 = dlsym(firstProfileLibrary, \"kokkosp_declare_output_type\");\n      Experimental::set_declare_output_type_callback(\n          *reinterpret_cast<Experimental::outputTypeDeclarationFunction*>(\n              &p24));\n\n      auto p25 = dlsym(firstProfileLibrary, \"kokkosp_declare_input_type\");\n      Experimental::set_declare_input_type_callback(\n          *reinterpret_cast<Experimental::inputTypeDeclarationFunction*>(&p25));\n      auto p26 = dlsym(firstProfileLibrary, \"kokkosp_request_values\");\n      Experimental::set_request_output_values_callback(\n          *reinterpret_cast<Experimental::requestValueFunction*>(&p26));\n      auto p27 = dlsym(firstProfileLibrary, \"kokkosp_end_context\");\n      Experimental::set_end_context_callback(\n          *reinterpret_cast<Experimental::contextEndFunction*>(&p27));\n      auto p28 = dlsym(firstProfileLibrary, \"kokkosp_begin_context\");\n      Experimental::set_begin_context_callback(\n          *reinterpret_cast<Experimental::contextBeginFunction*>(&p28));\n      auto p29 =\n          dlsym(firstProfileLibrary, \"kokkosp_declare_optimization_goal\");\n      Experimental::set_declare_optimization_goal_callback(\n          *reinterpret_cast<Experimental::optimizationGoalDeclarationFunction*>(\n              &p29));\n#endif  // KOKKOS_ENABLE_TUNING\n    }\n  }\n#endif  // KOKKOS_ENABLE_LIBDL\n  if (Experimental::current_callbacks.init != nullptr) {\n    (*Experimental::current_callbacks.init)(\n        0, (uint64_t)KOKKOSP_INTERFACE_VERSION, (uint32_t)0, nullptr);\n  }\n\n#ifdef KOKKOS_ENABLE_TUNING\n  Experimental::VariableInfo kernel_name;\n  kernel_name.type = Experimental::ValueType::kokkos_value_string;\n  kernel_name.category =\n      Experimental::StatisticalCategory::kokkos_value_categorical;\n  kernel_name.valueQuantity =\n      Experimental::CandidateValueType::kokkos_value_unbounded;\n\n  std::array<std::string, 4> candidate_values = {\n      \"parallel_for\",\n      \"parallel_reduce\",\n      \"parallel_scan\",\n      \"parallel_copy\",\n  };\n\n  Experimental::SetOrRange kernel_type_variable_candidates =\n      Experimental::make_candidate_set(4, candidate_values.data());\n\n  Experimental::kernel_name_context_variable_id =\n      Experimental::declare_input_type(\"kokkos.kernel_name\", kernel_name);\n\n  Experimental::VariableInfo kernel_type;\n  kernel_type.type = Experimental::ValueType::kokkos_value_string;\n  kernel_type.category =\n      Experimental::StatisticalCategory::kokkos_value_categorical;\n  kernel_type.valueQuantity =\n      Experimental::CandidateValueType::kokkos_value_set;\n  kernel_type.candidates = kernel_type_variable_candidates;\n  Experimental::kernel_type_context_variable_id =\n      Experimental::declare_input_type(\"kokkos.kernel_type\", kernel_type);\n\n#endif\n\n  Experimental::no_profiling.init     = nullptr;\n  Experimental::no_profiling.finalize = nullptr;\n\n  Experimental::no_profiling.begin_parallel_for    = nullptr;\n  Experimental::no_profiling.begin_parallel_scan   = nullptr;\n  Experimental::no_profiling.begin_parallel_reduce = nullptr;\n  Experimental::no_profiling.end_parallel_scan     = nullptr;\n  Experimental::no_profiling.end_parallel_for      = nullptr;\n  Experimental::no_profiling.end_parallel_reduce   = nullptr;\n\n  Experimental::no_profiling.push_region     = nullptr;\n  Experimental::no_profiling.pop_region      = nullptr;\n  Experimental::no_profiling.allocate_data   = nullptr;\n  Experimental::no_profiling.deallocate_data = nullptr;\n\n  Experimental::no_profiling.begin_deep_copy = nullptr;\n  Experimental::no_profiling.end_deep_copy   = nullptr;\n\n  Experimental::no_profiling.create_profile_section  = nullptr;\n  Experimental::no_profiling.start_profile_section   = nullptr;\n  Experimental::no_profiling.stop_profile_section    = nullptr;\n  Experimental::no_profiling.destroy_profile_section = nullptr;\n\n  Experimental::no_profiling.profile_event = nullptr;\n\n  Experimental::no_profiling.declare_input_type    = nullptr;\n  Experimental::no_profiling.declare_output_type   = nullptr;\n  Experimental::no_profiling.request_output_values = nullptr;\n  Experimental::no_profiling.end_tuning_context    = nullptr;\n#ifdef KOKKOS_ENABLE_LIBDL\n  free(envProfileCopy);\n#endif\n}\n\nvoid finalize() {\n  // Make sure finalize calls happens only once\n  static int is_finalized = 0;\n  if (is_finalized) return;\n  is_finalized = 1;\n\n  if (Experimental::current_callbacks.finalize != nullptr) {\n    (*Experimental::current_callbacks.finalize)();\n\n    Experimental::pause_tools();\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  // clean up string candidate set\n  for (auto& metadata_pair : Experimental::variable_metadata) {\n    auto metadata = metadata_pair.second;\n    if ((metadata.type == Experimental::ValueType::kokkos_value_string) &&\n        (metadata.valueQuantity ==\n         Experimental::CandidateValueType::kokkos_value_set)) {\n      auto candidate_set = metadata.candidates.set;\n      delete[] candidate_set.values.string_value;\n    }\n  }\n#endif\n}\n\nvoid syncDualView(const std::string& label, const void* const ptr,\n                  bool to_device) {\n  if (Experimental::current_callbacks.sync_dual_view != nullptr) {\n    (*Experimental::current_callbacks.sync_dual_view)(label.c_str(), ptr,\n                                                      to_device);\n  }\n}\nvoid modifyDualView(const std::string& label, const void* const ptr,\n                    bool on_device) {\n  if (Experimental::current_callbacks.modify_dual_view != nullptr) {\n    (*Experimental::current_callbacks.modify_dual_view)(label.c_str(), ptr,\n                                                        on_device);\n  }\n}\n\n}  // namespace Tools\n\nnamespace Tools {\nnamespace Experimental {\nvoid set_init_callback(initFunction callback) {\n  current_callbacks.init = callback;\n}\nvoid set_finalize_callback(finalizeFunction callback) {\n  current_callbacks.finalize = callback;\n}\nvoid set_begin_parallel_for_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_for = callback;\n}\nvoid set_end_parallel_for_callback(endFunction callback) {\n  current_callbacks.end_parallel_for = callback;\n}\nvoid set_begin_parallel_reduce_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_reduce = callback;\n}\nvoid set_end_parallel_reduce_callback(endFunction callback) {\n  current_callbacks.end_parallel_reduce = callback;\n}\nvoid set_begin_parallel_scan_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_scan = callback;\n}\nvoid set_end_parallel_scan_callback(endFunction callback) {\n  current_callbacks.end_parallel_scan = callback;\n}\nvoid set_push_region_callback(pushFunction callback) {\n  current_callbacks.push_region = callback;\n}\nvoid set_pop_region_callback(popFunction callback) {\n  current_callbacks.pop_region = callback;\n}\nvoid set_allocate_data_callback(allocateDataFunction callback) {\n  current_callbacks.allocate_data = callback;\n}\nvoid set_deallocate_data_callback(deallocateDataFunction callback) {\n  current_callbacks.deallocate_data = callback;\n}\nvoid set_create_profile_section_callback(\n    createProfileSectionFunction callback) {\n  current_callbacks.create_profile_section = callback;\n}\nvoid set_start_profile_section_callback(startProfileSectionFunction callback) {\n  current_callbacks.start_profile_section = callback;\n}\nvoid set_stop_profile_section_callback(stopProfileSectionFunction callback) {\n  current_callbacks.stop_profile_section = callback;\n}\nvoid set_destroy_profile_section_callback(\n    destroyProfileSectionFunction callback) {\n  current_callbacks.destroy_profile_section = callback;\n}\nvoid set_profile_event_callback(profileEventFunction callback) {\n  current_callbacks.profile_event = callback;\n}\nvoid set_begin_deep_copy_callback(beginDeepCopyFunction callback) {\n  current_callbacks.begin_deep_copy = callback;\n}\nvoid set_end_deep_copy_callback(endDeepCopyFunction callback) {\n  current_callbacks.end_deep_copy = callback;\n}\nvoid set_begin_fence_callback(beginFenceFunction callback) {\n  current_callbacks.begin_fence = callback;\n}\nvoid set_end_fence_callback(endFenceFunction callback) {\n  current_callbacks.end_fence = callback;\n}\n\nvoid set_dual_view_sync_callback(dualViewSyncFunction callback) {\n  current_callbacks.sync_dual_view = callback;\n}\nvoid set_dual_view_modify_callback(dualViewModifyFunction callback) {\n  current_callbacks.modify_dual_view = callback;\n}\n\nvoid set_declare_output_type_callback(outputTypeDeclarationFunction callback) {\n  current_callbacks.declare_output_type = callback;\n}\nvoid set_declare_input_type_callback(inputTypeDeclarationFunction callback) {\n  current_callbacks.declare_input_type = callback;\n}\nvoid set_request_output_values_callback(requestValueFunction callback) {\n  current_callbacks.request_output_values = callback;\n}\nvoid set_end_context_callback(contextEndFunction callback) {\n  current_callbacks.end_tuning_context = callback;\n}\nvoid set_begin_context_callback(contextBeginFunction callback) {\n  current_callbacks.begin_tuning_context = callback;\n}\nvoid set_declare_optimization_goal_callback(\n    optimizationGoalDeclarationFunction callback) {\n  current_callbacks.declare_optimization_goal = callback;\n}\n\nvoid pause_tools() {\n  backup_callbacks  = current_callbacks;\n  current_callbacks = no_profiling;\n}\n\nvoid resume_tools() { current_callbacks = backup_callbacks; }\n\nEventSet get_callbacks() { return current_callbacks; }\nvoid set_callbacks(EventSet new_events) { current_callbacks = new_events; }\n}  // namespace Experimental\n}  // namespace Tools\n\nnamespace Profiling {\nbool profileLibraryLoaded() { return Kokkos::Tools::profileLibraryLoaded(); }\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,\n                      uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelFor(kernelPrefix, devID, kernelID);\n}\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,\n                         uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelReduce(kernelPrefix, devID, kernelID);\n}\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,\n                       uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelScan(kernelPrefix, devID, kernelID);\n}\nvoid endParallelFor(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelFor(kernelID);\n}\nvoid endParallelReduce(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelReduce(kernelID);\n}\nvoid endParallelScan(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelScan(kernelID);\n}\n\nvoid pushRegion(const std::string& kName) { Kokkos::Tools::pushRegion(kName); }\nvoid popRegion() { Kokkos::Tools::popRegion(); }\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n  Kokkos::Tools::createProfileSection(sectionName, secID);\n}\nvoid destroyProfileSection(const uint32_t secID) {\n  Kokkos::Tools::destroyProfileSection(secID);\n}\n\nvoid startSection(const uint32_t secID) { Kokkos::Tools::startSection(secID); }\n\nvoid stopSection(const uint32_t secID) { Kokkos::Tools::stopSection(secID); }\n\nvoid markEvent(const std::string& eventName) {\n  Kokkos::Tools::markEvent(eventName);\n}\nvoid allocateData(const SpaceHandle handle, const std::string name,\n                  const void* data, const uint64_t size) {\n  Kokkos::Tools::allocateData(handle, name, data, size);\n}\nvoid deallocateData(const SpaceHandle space, const std::string label,\n                    const void* ptr, const uint64_t size) {\n  Kokkos::Tools::deallocateData(space, label, ptr, size);\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,\n                   const void* dst_ptr, const SpaceHandle src_space,\n                   const std::string src_label, const void* src_ptr,\n                   const uint64_t size) {\n  Kokkos::Tools::beginDeepCopy(dst_space, dst_label, dst_ptr, src_space,\n                               src_label, src_ptr, size);\n}\nvoid endDeepCopy() { Kokkos::Tools::endDeepCopy(); }\n\nvoid finalize() { Kokkos::Tools::finalize(); }\nvoid initialize() { Kokkos::Tools::initialize(); }\n\nSpaceHandle make_space_handle(const char* space_name) {\n  return Kokkos::Tools::make_space_handle(space_name);\n}\n}  // namespace Profiling\n\n}  // namespace Kokkos\n\n// Tuning\n\nnamespace Kokkos {\nnamespace Tools {\nnamespace Experimental {\nstatic size_t& get_context_counter() {\n  static size_t x;\n  return x;\n}\nstatic size_t& get_variable_counter() {\n  static size_t x;\n  return ++x;\n}\n\nsize_t get_new_context_id() { return ++get_context_counter(); }\nsize_t get_current_context_id() { return get_context_counter(); }\nvoid decrement_current_context_id() { --get_context_counter(); }\nsize_t get_new_variable_id() { return get_variable_counter(); }\n\nsize_t declare_output_type(const std::string& variableName, VariableInfo info) {\n  size_t variableId = get_new_variable_id();\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_output_type != nullptr) {\n    (*Experimental::current_callbacks.declare_output_type)(variableName.c_str(),\n                                                           variableId, &info);\n  }\n  variable_metadata[variableId] = info;\n#else\n  (void)variableName;\n  (void)info;\n#endif\n  return variableId;\n}\n\nsize_t declare_input_type(const std::string& variableName, VariableInfo info) {\n  size_t variableId = get_new_variable_id();\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_input_type != nullptr) {\n    (*Experimental::current_callbacks.declare_input_type)(variableName.c_str(),\n                                                          variableId, &info);\n  }\n  variable_metadata[variableId] = info;\n#else\n  (void)variableName;\n  (void)info;\n#endif\n  return variableId;\n}\n\nvoid set_input_values(size_t contextId, size_t count, VariableValue* values) {\n#ifdef KOKKOS_ENABLE_TUNING\n  if (features_per_context.find(contextId) == features_per_context.end()) {\n    features_per_context[contextId] = std::unordered_set<size_t>();\n  }\n  for (size_t x = 0; x < count; ++x) {\n    values[x].metadata = &variable_metadata[values[x].type_id];\n    features_per_context[contextId].insert(values[x].type_id);\n    active_features.insert(values[x].type_id);\n    feature_values[values[x].type_id] = values[x];\n  }\n#else\n  (void)contextId;\n  (void)count;\n  (void)values;\n#endif\n}\n#include <iostream>\nvoid request_output_values(size_t contextId, size_t count,\n                           VariableValue* values) {\n#ifdef KOKKOS_ENABLE_TUNING\n  std::vector<size_t> context_ids;\n  std::vector<VariableValue> context_values;\n  for (auto id : active_features) {\n    context_values.push_back(feature_values[id]);\n  }\n  if (Experimental::current_callbacks.request_output_values != nullptr) {\n    for (size_t x = 0; x < count; ++x) {\n      values[x].metadata = &variable_metadata[values[x].type_id];\n    }\n    (*Experimental::current_callbacks.request_output_values)(\n        contextId, context_values.size(), context_values.data(), count, values);\n  }\n#else\n  (void)contextId;\n  (void)count;\n  (void)values;\n#endif\n}\n\n#ifdef KOKKOS_ENABLE_TUNING\nstatic std::unordered_map<size_t, size_t> optimization_goals;\n#endif\n\nvoid begin_context(size_t contextId) {\n  if (Experimental::current_callbacks.begin_tuning_context != nullptr) {\n    (*Experimental::current_callbacks.begin_tuning_context)(contextId);\n  }\n}\nvoid end_context(size_t contextId) {\n#ifdef KOKKOS_ENABLE_TUNING\n  for (auto id : features_per_context[contextId]) {\n    active_features.erase(id);\n  }\n  if (Experimental::current_callbacks.end_tuning_context != nullptr) {\n    (*Experimental::current_callbacks.end_tuning_context)(\n        contextId, feature_values[optimization_goals[contextId]]);\n  }\n  optimization_goals.erase(contextId);\n  decrement_current_context_id();\n#else\n  (void)contextId;\n#endif\n}\n\nbool have_tuning_tool() {\n#ifdef KOKKOS_ENABLE_TUNING\n  return (Experimental::current_callbacks.request_output_values != nullptr);\n#else\n  return false;\n#endif\n}\n\nVariableValue make_variable_value(size_t id, int64_t val) {\n  VariableValue variable_value;\n  variable_value.type_id         = id;\n  variable_value.value.int_value = val;\n  return variable_value;\n}\nVariableValue make_variable_value(size_t id, double val) {\n  VariableValue variable_value;\n  variable_value.type_id            = id;\n  variable_value.value.double_value = val;\n  return variable_value;\n}\nVariableValue make_variable_value(size_t id, const std::string& val) {\n  VariableValue variable_value;\n  variable_value.type_id = id;\n  strncpy(variable_value.value.string_value, val.c_str(),\n          KOKKOS_TOOLS_TUNING_STRING_LENGTH - 1);\n  return variable_value;\n}\nSetOrRange make_candidate_set(size_t size, std::string* data) {\n  SetOrRange value_set;\n  value_set.set.values.string_value = new TuningString[size];\n  for (size_t x = 0; x < size; ++x) {\n    strncpy(value_set.set.values.string_value[x], data[x].c_str(),\n            KOKKOS_TOOLS_TUNING_STRING_LENGTH - 1);\n  }\n  value_set.set.size = size;\n  return value_set;\n}\nSetOrRange make_candidate_set(size_t size, int64_t* data) {\n  SetOrRange value_set;\n  value_set.set.size             = size;\n  value_set.set.values.int_value = data;\n  return value_set;\n}\nSetOrRange make_candidate_set(size_t size, double* data) {\n  SetOrRange value_set;\n  value_set.set.size                = size;\n  value_set.set.values.double_value = data;\n  return value_set;\n}\nSetOrRange make_candidate_range(double lower, double upper, double step,\n                                bool openLower = false,\n                                bool openUpper = false) {\n  SetOrRange value_range;\n  value_range.range.lower.double_value = lower;\n  value_range.range.upper.double_value = upper;\n  value_range.range.step.double_value  = step;\n  value_range.range.openLower          = openLower;\n  value_range.range.openUpper          = openUpper;\n  return value_range;\n}\n\nSetOrRange make_candidate_range(int64_t lower, int64_t upper, int64_t step,\n                                bool openLower = false,\n                                bool openUpper = false) {\n  SetOrRange value_range;\n  value_range.range.lower.int_value = lower;\n  value_range.range.upper.int_value = upper;\n  value_range.range.step.int_value  = step;\n  value_range.range.openLower       = openLower;\n  value_range.range.openUpper       = openUpper;\n  return value_range;\n}\n\nsize_t get_new_context_id();\nsize_t get_current_context_id();\nvoid decrement_current_context_id();\nsize_t get_new_variable_id();\nvoid declare_optimization_goal(const size_t context,\n                               const OptimizationGoal& goal) {\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_optimization_goal != nullptr) {\n    (*Experimental::current_callbacks.declare_optimization_goal)(context, goal);\n  }\n  optimization_goals[context] = goal.type_id;\n#else\n  (void)context;\n  (void)goal;\n#endif\n}\n}  // end namespace Experimental\n}  // end namespace Tools\n\n}  // end namespace Kokkos\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/lib/molfile/vmdplugin.h": "/***************************************************************************\n *cr\n *cr            (C) Copyright 1995-2006 The Board of Trustees of the\n *cr                        University of Illinois\n *cr                         All Rights Reserved\n *cr\n ***************************************************************************/\n\n/***************************************************************************\n * RCS INFORMATION:\n *\n *      $RCSfile: vmdplugin.h,v $\n *      $Author: johns $       $Locker:  $             $State: Exp $\n *      $Revision: 1.34 $       $Date: 2018/05/02 03:12:56 $\n *\n ***************************************************************************/\n\n/** @file\n * This header must be included by every VMD plugin library.  It defines the\n * API for every plugin so that VMD can organize the plugins it finds.\n */\n\n#ifndef VMD_PLUGIN_H\n#define VMD_PLUGIN_H\n\n\n/*\n * Preprocessor tricks to make it easier for us to redefine the names of\n * functions when building static plugins.\n */\n#if !defined(VMDPLUGIN)\n/**\n  * macro defining VMDPLUGIN if it hasn't already been set to the name of\n  * a static plugin that is being compiled.  This is the catch-all case.\n  */\n#define VMDPLUGIN vmdplugin\n#endif\n/** concatenation macro, joins args x and y together as a single string */\n#define xcat(x, y) cat(x, y)\n/** concatenation macro, joins args x and y together as a single string */\n#define cat(x, y) x ## y\n\n/*\n *  macros to correctly define plugin function names depending on whether\n *  the plugin is being compiled for static linkage or dynamic loading.\n *  When compiled for static linkage, each plugin needs to have unique\n *  function names for all of its entry points.  When compiled for dynamic\n *  loading, the plugins must name their entry points consistently so that\n *  the plugin loading mechanism can find the register, register_tcl, init,\n *  and fini routines via dlopen() or similar operating system interfaces.\n */\n/*@{*/\n/** Macro names entry points correctly for static linkage or dynamic loading */\n#define VMDPLUGIN_register     xcat(VMDPLUGIN, _register)\n#define VMDPLUGIN_register_tcl xcat(VMDPLUGIN, _register_tcl)\n#define VMDPLUGIN_init         xcat(VMDPLUGIN, _init)\n#define VMDPLUGIN_fini         xcat(VMDPLUGIN, _fini)\n/*@}*/\n\n\n/** \"WIN32\" is defined on both WIN32 and WIN64 platforms... */\n#if (defined(WIN32))\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#if !defined(STATIC_PLUGIN)\n#if defined(VMDPLUGIN_EXPORTS)\n/**\n *  Only define DllMain for plugins, not in VMD or in statically linked plugins\n *  VMDPLUGIN_EXPORTS is only defined when compiling dynamically loaded plugins\n */\nBOOL APIENTRY DllMain( HANDLE hModule,\n                       DWORD ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n  return TRUE;\n}\n\n#define VMDPLUGIN_API __declspec(dllexport)\n#else\n#define VMDPLUGIN_API __declspec(dllimport)\n#endif /* VMDPLUGIN_EXPORTS */\n#else  /* ! STATIC_PLUGIN */\n#define VMDPLUGIN_API\n#endif /* ! STATIC_PLUGIN */\n#else\n/** If we're not compiling on Windows, then this macro is defined empty */\n#define VMDPLUGIN_API\n#endif\n\n/** define plugin linkage correctly for both C and C++ based plugins */\n#ifdef __cplusplus\n#define VMDPLUGIN_EXTERN extern \"C\" VMDPLUGIN_API\n#else\n#define VMDPLUGIN_EXTERN extern VMDPLUGIN_API\n#endif  /* __cplusplus */\n\n/*\n * Plugin API functions start here\n */\n\n\n/**\n * Init routine: called the first time the library is loaded by the\n * application and before any other API functions are referenced.\n * Return 0 on success.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_init(void);\n\n/**\n * Macro for creating a struct header used in all plugin structures.\n *\n * This header should be placed at the top of every plugin API definition\n * so that it can be treated as a subtype of the base plugin type.\n *\n * abiversion: Defines the ABI for the base plugin type (not for other plugins)\n * type: A string descriptor of the plugin type.\n * name: A name for the plugin.\n * author: A string identifier, possibly including newlines.\n * Major and minor version.\n * is_reentrant: Whether this library can be run concurrently with itself.\n */\n#define vmdplugin_HEAD \\\n  int abiversion; \\\n  const char *type; \\\n  const char *name; \\\n  const char *prettyname; \\\n  const char *author; \\\n  int majorv; \\\n  int minorv; \\\n  int is_reentrant;\n\n/**\n  * Typedef for generic plugin header, individual plugins can\n  * make their own structures as long as the header info remains\n  * the same as the generic plugin header, most easily done by\n  * using the vmdplugin_HEAD macro.\n  */\ntypedef struct {\n  vmdplugin_HEAD\n} vmdplugin_t;\n\n/**\n * Use this macro to initialize the abiversion member of each plugin\n */\n#define vmdplugin_ABIVERSION  18\n\n/*@{*/\n/** Use this macro to indicate a plugin's thread-safety at registration time */\n#define VMDPLUGIN_THREADUNSAFE 0\n#define VMDPLUGIN_THREADSAFE   1\n/*@}*/\n\n/*@{*/\n/** Error return code for use in the plugin registration and init functions */\n#define VMDPLUGIN_SUCCESS      0\n#define VMDPLUGIN_ERROR       -1\n/*@}*/\n\n/**\n * Function pointer typedef for register callback functions\n */\ntypedef int (*vmdplugin_register_cb)(void *, vmdplugin_t *);\n\n/**\n * Allow the library to register plugins with the application.\n * The callback should be called using the passed-in void pointer, which\n * should not be interpreted in any way by the library.  Each vmdplugin_t\n * pointer passed to the application should point to statically-allocated\n * or heap-allocated memory and should never be later modified by the plugin.\n * Applications must be permitted to retain only a copy of the the plugin\n * pointer, without making any deep copy of the items in the struct.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_register(void *, vmdplugin_register_cb);\n\n/**\n * Allow the library to register Tcl extensions.\n * This API is optional; if found by dlopen, it will be called after first\n * calling init and register.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_register_tcl(void *, void *tcl_interp,\n    vmdplugin_register_cb);\n\n/**\n * The Fini method is called when the application will no longer use\n * any plugins in the library.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_fini(void);\n\n#endif   /* VMD_PLUGIN_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/lib/molfile/Makefile.lammps": "# This file contains the hooks to build and link LAMMPS with the VMD\n# molfile plugins described here:\n# \n# http://www.ks.uiuc.edu/Research/vmd/plugins/molfile\n# \n# When you build LAMMPS with the USER-MOLFILE package installed, it will\n# use the 3 settings in this file.  They should be set as follows.\n# \n# The molfile_SYSINC setting is to point to the folder with the VMD\n# plugin headers. By default it points to bundled headers in this folder\n# \n# The molfile_SYSLIB setting is for a system dynamic loading library\n# that will be used to load the molfile plugins.  It contains functions\n# like dlopen(), dlsym() and so on for dynamic linking of executable\n# code into an executable.  For Linux and most current Unix-like\n# operating systems, the setting of \"-ldl\" will work.  On some platforms\n# you may need \"-ldld\".  For compilation on Windows, a different\n# mechanism is used that is part of the Windows programming environment\n# and thus molfile_SYSLIB can be left blank.\n# \n# The molfile_SYSINC and molfile_SYSPATH variables do not typically need\n# to be set.  If the dl library is not in a place the linker can find\n# it, specify its directory via the molfile_SYSPATH variable, e.g.\n# -Ldir.\n\n# -----------------------------------------------------------\n\n# Settings that the LAMMPS build will import when this package is installed\n\n# change this to -I/path/to/your/lib/vmd/plugins/include if the bundled\n# header files are incompatible with your VMD plugsins\nmolfile_SYSINC =-I../../lib/molfile\n#\nifneq ($(LIBOBJDIR),/Obj_mingw32)\nifneq ($(LIBOBJDIR),/Obj_mingw64)\nifneq ($(LIBOBJDIR),/Obj_mingw32-mpi)\nifneq ($(LIBOBJDIR),/Obj_mingw64-mpi)\nmolfile_SYSLIB = -ldl\nendif\nendif\nendif\nendif\nmolfile_SYSPATH =\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/COUPLE/plugin/liblammpsplugin.c": "/* -*- c++ -*- ----------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n------------------------------------------------------------------------- */\n\n/*\n   Variant of the C style library interface to LAMMPS\n   that uses a shared library and dynamically opens it,\n   so this can be used as a prototype code to integrate\n   a LAMMPS plugin to some other software.\n*/\n\n#include \"library.h\"\n#include \"liblammpsplugin.h\"\n#include <stdlib.h>\n#include <dlfcn.h>\n\nliblammpsplugin_t *liblammpsplugin_load(const char *lib)\n{\n  liblammpsplugin_t *lmp;\n  void *handle;\n\n  if (lib == NULL) return NULL;\n  handle = dlopen(lib,RTLD_NOW|RTLD_GLOBAL);\n  if (handle == NULL) return NULL;\n  \n  lmp = (liblammpsplugin_t *) malloc(sizeof(liblammpsplugin_t));\n  lmp->handle = handle;\n\n#define ADDSYM(symbol) lmp->symbol = dlsym(handle,\"lammps_\" #symbol)\n  ADDSYM(open);\n  ADDSYM(open_no_mpi);\n  ADDSYM(close);\n  ADDSYM(version);\n  ADDSYM(file);\n  ADDSYM(command);\n  ADDSYM(commands_list);\n  ADDSYM(commands_string);\n  ADDSYM(free);\n  ADDSYM(extract_setting);\n  ADDSYM(extract_global);\n  ADDSYM(extract_box);\n  ADDSYM(extract_atom);\n  ADDSYM(extract_compute);\n  ADDSYM(extract_fix);\n  ADDSYM(extract_variable);\n\n  ADDSYM(get_thermo);\n  ADDSYM(get_natoms);\n\n  ADDSYM(set_variable);\n  ADDSYM(reset_box);\n\n  ADDSYM(gather_atoms);\n  ADDSYM(gather_atoms_concat);\n  ADDSYM(gather_atoms_subset);\n  ADDSYM(scatter_atoms);\n  ADDSYM(scatter_atoms_subset);\n\n  ADDSYM(set_fix_external_callback);\n\n  ADDSYM(config_has_package);\n  ADDSYM(config_package_count);\n  ADDSYM(config_package_name);\n  ADDSYM(config_has_gzip_support);\n  ADDSYM(config_has_png_support);\n  ADDSYM(config_has_jpeg_support);\n  ADDSYM(config_has_ffmpeg_support);\n  ADDSYM(config_has_exceptions);\n  ADDSYM(create_atoms);\n#ifdef LAMMPS_EXCEPTIONS\n  lmp->has_exceptions = 1;\n  ADDSYM(has_error);\n  ADDSYM(get_last_error_message);\n#else\n  lmp->has_exceptions = 0;\n  lmp->has_error = NULL;\n  lmp->get_last_error_message = NULL;\n#endif\n  return lmp;\n}\n\nint liblammpsplugin_release(liblammpsplugin_t *lmp)\n{\n  if (lmp == NULL) return 1;\n  if (lmp->handle == NULL) return 2;\n\n  dlclose(lmp->handle);\n  free((void *)lmp);\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/valgrind/OpenMP.supp": "{\n   OpenMP_cuda_init_part1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlopen*\n   obj:*/lib*/libcuda.so.*\n   obj:*\n   ...\n   fun:call_init.part.0\n   fun:_dl_init\n   obj:/usr/lib*/ld-2.*.so\n}\n{\n   OpenMP_init_part1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   obj:/usr/lib*/libgomp.so.1*\n   fun:call_init.part.0\n   fun:_dl_init\n}\n{\n   OpenMP_init_part2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   obj:/usr/lib*/libgomp.so.1*\n   fun:GOMP_parallel\n   ...\n   fun:main\n}\n{\n   OpenMP_init_part3\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   obj:/usr/lib*/libgomp.so.1*\n   fun:omp_set_num_threads\n   ...\n   fun:main\n}\n{\n   OpenMP_init_part4\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:GOMP_parallel\n   ...\n}\n{\n   OpenMP_init_part5\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   obj:/usr/lib*/libgomp.so.1*\n   fun:omp_set_num_threads\n   ...\n}\n{\n   OpenMP_init_part6\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:calloc\n   ...\n   fun:GOMP_parallel\n   ...\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/valgrind/OpenMPI.supp": "{\n   OpenMPI_MPI_init1\n   Memcheck:Leak\n   match-leak-kinds: indirect\n   fun:malloc\n   obj:*\n   ...\n   fun:ompi_mpi_init\n   fun:PMPI_Init\n   fun:main\n}\n{\n   OpenMPI_MPI_init2\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   ...\n   fun:mca_pml_base_select\n}\n{\n   OpenMPI_MPI_init3\n   Memcheck:Leak\n   match-leak-kinds: indirect\n   fun:malloc\n   ...\n   fun:mca_pml_base_select\n}\n{\n   OpenMPI_MPI_init3\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:?alloc\n   ...\n   fun:ompi_mpi_init\n   fun:PMPI_Init\n   fun:main\n}\n{\n   OpenMPI_MPI_init4\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:?alloc\n   ...\n   fun:ompi_mpi_init\n   fun:PMPI_Init\n   fun:main\n}\n{\n   OpenMPI_MPI_init5\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:?alloc\n   obj:*/libopen-pal.so.*\n   fun:mca_base_framework_components_open\n   fun:mca_base_framework_open\n   ...\n   fun:ompi_mpi_init\n   fun:PMPI_Init\n}\n{\n   OpenMPI_MPI_init6\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:realloc\n   obj:*/libopen-pal.so.*\n   ...\n   fun:opal_progress\n   fun:ompi_mpi_init\n   fun:PMPI_Init\n   fun:main\n}\n{\n   OpenMPI_MPI_init7\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:realloc\n   obj:*/libopen-pal.so.*\n   ...\n   fun:orte_init\n   fun:ompi_mpi_init\n}\n{\n   OpenMPI_MPI_init8\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:?alloc\n   ...\n   fun:orte_init\n   fun:ompi_mpi_init\n}\n{\n   OpenMPI_MPI_init9\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   ...\n   fun:orte_init\n   fun:ompi_mpi_init\n   fun:PMPI_Init\n}\n{\n   OpenMPI_MPI_init10\n   Memcheck:Leak\n   match-leak-kinds: indirect\n   fun:malloc\n   ...\n   fun:ompi_mpi_init\n   fun:PMPI_Init\n}\n{\n   OpenMPI_MPI_init11\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:ompi_mpi_init\n   fun:PMPI_Init\n}\n{\n   OpenMPI_MPI_init12\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   ...\n   fun:ompi_mpi_init\n   fun:PMPI_Init\n}\n{\n   OpenMPI_MPI_thread1\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:?alloc\n   ...\n   fun:start_thread\n   fun:clone\n}\n{\n   OpenMPI_MPI_thread2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:?alloc\n   ...\n   fun:start_thread\n   fun:clone\n}\n{\n   OpenMPI_comm_init1\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:?alloc\n   ...\n   fun:ompi_comm_enable\n   fun:mca_topo_base_cart_create\n   fun:PMPI_Cart_create\n}\n{\n   OpenMPI_comm_init2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:?alloc\n   ...\n   fun:ompi_comm_enable\n   fun:mca_topo_base_cart_create\n   fun:PMPI_Cart_create\n}\n{\n   OpenMPI_comm_init3\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:realloc\n   ...\n   fun:mca_topo_base_comm_select\n   fun:PMPI_Cart_create\n}\n{\n   OpenMPI_comm_init4\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:?alloc\n   ...\n   fun:mca_topo_base_comm_select\n   fun:PMPI_Cart_create\n}\n{\n   OpenMPI_dlopen_strdup1\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   fun:strdup\n   ...\n   fun:dlopen*\n}\n{\n   OpenMPI_dlopen_strdup2\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   fun:strdup\n   ...\n   fun:dl_open_worker\n}\n{\n   OpenMPI_dlopen_strdup3\n   Memcheck:Leak\n   match-leak-kinds: indirect\n   fun:malloc\n   fun:strdup\n   ...\n   fun:event_base_loop\n   ...\n   fun:clone\n}\n{\n   OpenMPI_dlerror1\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   ...\n   fun:_dl_init\n   fun:_dl_catch_exception\n   ...\n   fun:_dlerror_run\n}\n{\n   OpenMPI_dlerror2\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:calloc\n   ...\n   fun:_dl_init\n   fun:_dl_catch_exception\n   ...\n   fun:dl_open_worker\n   fun:_dl_catch_exception\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/false_positives.txt": "aa\naat\nabc\nabf\nABI\nabo\nAbramyan\nabsTol\nAcc\nAccelerys\nAccelrys\nacceptor\nAcceptor\nacceptors\naccomx\naccomy\naccomz\naccuracies\nach\nackland\nAckland\nacolor\nacos\nActa\nactinide\nacylindricity\naddforce\nAddington\naddtorque\nadf\nAdhikari\nadiam\nadim\nAdjiman\nadof\nadp\nAdri\nadvect\nadvection\nadvects\naffine\nAfshar\nagilio\nAgilio\nagni\nAgnolin\nAi\nAidan\naij\nairebo\nAj\najs\najaramil\nakohlmey\nAktulga\nal\nalain\nAlain\nAlamos\nalat\nAlbe\nalchemical\nAlCu\nAlderton\nAlejandre\nAleksei\nalessandro\nAlessandro\nAlexey\nali\naliceblue\nAllinger\nallocaters\nallosws\nAlO\nAlonso\nalphashrink\namap\nAmatrix\nAMD\namino\nAmirjalayer\nAmit\namu\nAmzallag\nanalytical\nAnders\nAndzelm\nAng\nanglegrad\nangletangrad\nangmom\nangmomx\nangmomy\nangmomz\nAngs\nanharmonic\nanharmonicity\naniso\nanisotropic\nanisotropies\nanisotropy\nansi\nantiquewhite\nAntisymmetrized\nantisymmetry\nanton\nAntonelli\napi\nApoorva\nAppl\nApu\narallel\narccos\narge\nArchlinux\narcsin\narg\nargs\nargv\narrhenius\nArun\narXiv\nasin\nAskari\naskoose\nasphere\nASPHERE\naspherical\nasphericity\nAsq\nassignee\nassively\nAsta\nAstart\nAstop\nasub\nasubrama\nAsumming\natan\natc\nAtC\nATC\nathermal\natime\natimestep\nathomps\natm\natomeye\natomfile\nAtomicPairStyle\natomID\natomistic\nattogram\nattograms\nattrac\nAtw\nAtwater\natwt\naugt\nAuO\nautomagically\nAvalos\navalue\naveforce\nAvendano\navi\nAVX\nawpmd\nAWPMD\nAxel\nAxilrod\nAy\nAyton\nAz\nAzevedo\nazimuthal\nAzuri\nba\nBabadi\nBabaei\nbackcolor\nbackends\nBaczewski\nBagi\nBagnold\nBkappa\nBal\nbalancer\nBalankura\nBalasubramanian\nBalatsky\nBallenegger\nBammann\nBanna\nBarashev\nbarostat\nBarostats\nbarostatted\nbarostatting\nBarostatting\nBarrat\nBartelt\nBartels\nbarycenter\nbarye\nBashford\nbashrc\nBaskes\nBatra\nBayly\nbb\nbcc\nbcolor\nbdiam\nbdw\nBeckman\nBelak\nBellott\nbenchmarking\nBennet\nBerardi\nBeraun\nberendsen\nBerendsen\nberger\nBerkowitz\nberlin\nBerne\nBertotti\nBessarab\nBeutler\nBext\nBfrac\nbgq\nBh\nBialke\nbicrystal\nBiersack\nbigbig\nbigint\nBij\nbilayer\nbilayers\nbiquadratic\nbinsize\nbinstyle\nbinutils\nbiomolecular\nbiomolecule\nBiomolecules\nBiophys\nBiosym\nbisectioning\nbispectrum\nBispectrum\nbitbucket\nbitmapped\nbitmask\nbitrate\nbitrates\nBitzek\nBlaise\nblanchedalmond\nblocksize\nblueviolet\nbn\nbni\nbo\nBochum\nbocs\nbodyflag\nbodyforce\nbodystyle\nBogaerts\nBogusz\nBohrs\nboltz\nBoltzman\nBondAngle\nBondBond\nbondchk\nbondmax\nbondtype\nBonet\nBonomi\nboolean\nboostostat\nboostostatting\nBoresch\nBotero\nBotu\nBouguet\nBourne\nboxcolor\nboxlo\nboxhi\nboxxlo\nboxxhi\nboxylo\nboxyhi\nboxzlo\nboxzhi\nbp\nbpclermont\nbpls\nbr\nBranduardi\nBranicio\nbrennan\nBrien\nBrilliantov\nBroadwell\nBroglie\nbrownian\nbrownw\nBroyden\nBryantsev\nBtarget\nbtype\nbuckPlusAttr\nbuf\nbuiltin\nBulatov\nBureekaew\nburlywood\nBussi\nButurigakkwaishi\nBuyl\nBybee\nbz\ncadetblue\nCagin\ncalc\ncalibre\ncaltech\nCaltech\nCamilloni\nCamiloni\nCampana\nCao\nCapolungo\nCaro\ncartesian\nCasP\nCaswell\nCates\ncauchy\ncauchystat\nCavazzoni\nCavium\nCawkwell\ncbecker\nccache\nccachepiecewise\nccl\nccmake\nccN\nccNspecies\nCCu\ncd\ncdeam\ncdennist\ncdof\nceil\nCeil\ncenterline\ncentro\ncentroid\nCentroid\ncentrosymmetry\nCercignani\ncercignanilampis\nCerda\nceriotti\nCeriotti\nCerutti\ncfg\nCFG\ncfile\nCFL\ncgdna\nCGDNA\ncgs\ncgsdk\nCGSDK\nChalopin\nChampaign\ncharmm\nCHARMM\ncharmmfsh\ncharmmfsw\ncharptr\nChaudhuri\ncheckbox\ncheckmark\ncheckqeq\nchemistries\nChemnitz\nCheng\nChenoweth\nchiral\nChiralIDs\nchiralIDs\nchirality\nCho\nChooseOffset\nchris\nChristoph\nChu\nchunkID\nCiccotti\nCieplak\nCii\nCij\ncis\nciv\nCKD\nClang\nclearstore\nCleary\nClebsch\nclemson\nClermont\nclo\nClovertown\ncmake\nCMake\ncmap\nCmax\ncmd\ncmdlist\ncmds\nCmin\ncmm\nCMM\ncn\ncN\nCn\ncna\ncnp\ncnr\ncoaxstk\ncodebase\ncoeff\nCoeff\nCoefficientN\ncoeffs\nCoeffs\ncohesionless\nCoker\nColberg\ncoleman\nColliex\ncollinear\ncollisional\nColumic\ncolvars\nColvars\nCOLVARS\ncomID\nCommun\ncompositing\ncompressibility\ncompressive\nComput\ncomputable\ncompute\nconcat\ncond\nconda\nConda\nCondens\nConnor\nconf\nconfig\nconfigfile\nconfigurational\nconformational\nConstMatrix\nContrib\ncooperativity\ncoord\nCoord\nCoordN\ncoords\ncoreshell\ncornflowerblue\ncornsilk\ncorotate\ncorotation\ncorotational\ncorrelator\ncosineshifted\ncossq\ncostheta\nCouette\ncoul\ncoulgauss\ncoulombic\nCoulombic\nCoulombics\nCourant\ncovalent\ncovalently\ncovariance\ncpp\ncpu\ncreateatoms\ncreateAtoms\nCreateIDs\ncrespi\nCrespi\nCritchley\ncrossterm\nCrowson\nCrozier\nCryst\nCrystallogr\nCsanyi\ncsh\ncshrc\nCSiC\ncsld\ncslib\nCSlib\ncstdio\ncstdlib\ncstring\ncstyle\ncsvr\nctrl\nCtypes\nctypes\ncuda\nCuda\nCUDA\nCuH\nCui\ncuFFT\nCummins\nCurk\nCusentino\ncustomIDs\ncutbond\ncuthi\ncutinner\ncutlo\ncutmax\ncutoffA\ncutoffC\ncuu\ncv\nCv\nCval\ncvar\ncvff\ncwiggle\ncygwin\nCygwin\ncylindrically\nCyrot\ncyrstals\ncython\nDaivis\nDammak\ndampflag\nDarden\ndarkblue\ndarkcyan\ndarkgoldenrod\ndarkgray\ndarkgreen\ndarkkhaki\ndarkmagenta\ndarkolivegreen\ndarkorange\ndarkorchid\ndarkred\ndarksalmon\ndarkseagreen\ndarkslateblue\ndarkslategray\ndarkturquoise\ndarkviolet\nDas\nDasgupta\ndashpot\ndat\ndatafile\ndatatype\ndatums\nDavidchack\nDaw\ndcd\ndcub\nDcut\nde\ndE\nDe\ndeallocated\ndecorrelation\ndebye\nDebye\nDecius\ndecompositions\ndecrementing\ndeeppink\ndeepskyblue\ndefgrad\ndefn\ndeformable\ndel\ndelaystep\nDeleteIDs\ndeleteIDs\ndelflag\nDellago\ndelocalization\ndelocalized\ndelr\ndeltaHf\nDendrimer\ndendritic\nDenniston\ndephase\ndephasing\ndequidt\nDequidt\nder\ndereference\nderekt\nDeresiewicz\nDerjagin\nDerjaguin\nDerlet\nDeserno\nDestree\ndestructor\ndetils\nDevanathan\ndevel\nDevemy\ndeviatoric\nDevine\ndf\ndfftw\nDFT\ndftb\ndh\ndhex\ndia\ndiag\ndiagonalization\ndiagonalize\ndiagonalized\ndiagonalizers\ndiagonalizing\nDiallo\ndiel\ndifferentiable\ndiffusively\ndiffusivity\ndihedral\ndihedrals\nDihedrals\ndihydride\nDij\ndimdim\ndimensioned\ndimensionality\ndimgray\ndipolar\ndir\nDirec\ndirname\ndiscoverable\ndiscretization\ndiscretized\ndisp\ndissipative\nDissipative\ndistharm\ndl\ndlambda\nDLAMMPS\ndll\ndlopen\ndm\ndmax\nDmax\ndmg\ndmi\ndnf\nDNi\nDobson\nDobnikar\nDodds\ndocenv\ndodgerblue\ndof\ndoi\nDonadio\ndotc\nDoty\ndoxygen\ndoxygenclass\ndoxygenfunction\ndownarrow\nDoye\ndpd\nDPD\ndpdTheta\ndphi\nDPhil\ndr\ndR\ndragforce\nDrautz\ndreiding\nDreiding\ndrfourth\ndrho\ndrsquared\ndrude\nDrude\nDRUDE\ndsf\ndsmc\ndt\ndtgrow\ndtheta\ndtshrink\ndu\ndU\nDudarev\nDuin\nDullweber\ndumpfile\nDunbrack\nDunweg\nDupont\ndUs\ndV\ndvector\ndVx\ndW\ndx\ndy\ndylib\ndyn\ndyne\ndynes\ndynmat\nDyre\nDzyaloshinskii\nEaa\nEaat\nEacn\neam\neangle\nearg\neatom\nEb\nEba\nEbeling\nebend\nebond\nebook\nebt\nec\nEc\neco\necoul\necp\nEcut\nEdgeIDs\nedgeIDs\nedihed\nedim\nedip\nedn\nedpd\neDPD\nedu\nee\nEebt\nees\neFF\nefield\neffm\neflag\neflux\neg\nEggebrecht\nehex\neHEX\nEi\neigen\neigensolve\neigensolver\neigensolvers\neigendecomposition\neigenvalue\neigenvalues\neigenvector\neigenvectors\neij\nEij\nEijnden\nEike\neim\neimp\nEindhoven\nEisenforschung\nEjtehadi\nEl\nelaplong\nElectroneg\nelectronegative\nelectronegativity\nEleftheriou\nElementN\nelementset\nelementsets\nelif\nElj\nEllad\nellipsoidflag\nelong\nElsevier\nElsner\nElstner\nelt\nemacs\nemax\nEmax\nEmbt\nemi\nemol\neN\nenergetics\nenergyCorr\neng\nEngility\nengilitycorp\nengrot\nengtrans\nengvib\nenobonds\nEnSight\nenthalpy\nenums\nenvoke\neos\nepair\nepcc\nepl\nEpp\nEpq\neps\nEpton\nepub\nePUB\neq\neqal\neqch\nEqp\nEqq\nEqs\nequi\nequil\nequilibrate\nequilibrated\nequilibrates\nequilibrating\nequilibration\nEquilibria\nequilization\nequipartitioning\nErcolessi\nErdmann\neradius\nerate\nerc\nerf\nerfc\nErhart\nerorate\nerose\nerotate\nerrno\nErtas\nervel\nEspanol\nEshelby\neshelby\neskm\nesph\nestretch\nesu\nesub\nesw\net\netag\netap\nETarget\nethernet\netol\netot\netotal\netube\nEulerian\neulerian\neulerimplicit\nEurophys\nev\neV\nevalue\nEvanseck\nevdwl\nevector\nevec\nevecs\neval\nevals\nEveraers\nEvgeny\nevirials\newald\nEwald\nexcitations\nexcv\nexe\nexecutables\nextep\nextrema\nexy\ney\nez\nfaceset\nfacesets\nfactorizable\nfactorizations\nFahrenberger\nFaken\nFarago\nFasolino\nFath\nFava\nfbMC\nFc\nfcc\nfcm\nFd\nfd\nfdotr\nfdt\nFehlberg\nFellinger\nfe\nfemtosecond\nfemtoseconds\nfene\nFennell\nfep\nFEP\nfermi\nFermionic\nFerrand\nfexternal\nFexternal\nffield\nffl\nffmpeg\nFFmpeg\nffplay\nfft\nfftbench\nfftw\nfgets\nfhg\nFi\nFichthorn\nFickian\nfieldname\nfigshare\nFij\nfilelink\nfilename\nFilename\nfilenames\nFilenames\nFily\nfileper\nfilesystem\nFincham\nFinchham\nFinnis\nFiorin\nfixID\nfj\nFji\nflagfld\nflagHI\nflaglog\nflagN\nflagVF\nfld\nfloralwhite\nFlorez\nflv\nfmackay\nfmag\nfmass\nfmm\nfmt\nfmx\nfmy\nfmz\nfN\nFn\nfname\nfno\nFnudge\nfoces\nFock\nFogarty\nFoiles\nfopenmp\nforceclear\nforestgreen\nformatarg\nformulae\nForschungszentrum\nFortran\nfortran\nFosado\nfourier\nfp\nfphi\nfPIC\nfplo\nFqq\nFraige\nframerate\nFrauenheim\nFraunhofer\nfread\nFreitas\nFrenkel\nFriedrichs\nfs\nfsh\nfstyle\nfsw\nftm\nftol\nfugacity\nFumi\nfunc\nfuncs\nfunctionalities\nfunctionals\nfunroll\nfuer\nfx\nfy\nfz\nGahler\ngainsboro\nGalindo\ngamA\ngammaA\ngammaFactor\ngammaR\ngamR\nGan\nGaN\nganzenmueller\nGanzenmuller\nGao\nGathert\nGaus\ngauss\ngaussian\ngaussians\nGaussians\nGavhane\ngayberne\ngcc\ngcmc\ngdot\nGeC\nGeier\ngencode\ngeorg\nGeorg\nGermann\nGermano\ngerolf\nGerolf\nGershgorin\ngettimeofday\ngewald\nGezelter\nGflop\ngfortran\nghostwhite\nGiacomo\ngif\ngifsicle\nGillan\nGingold\nGissinger\ngithub\ngjf\ngjwagne\ngl\ngladky\nGladky\ngld\ngle\nglobbing\nGlosli\nGlotzer\ngmail\ngmake\ngmask\nGmask\nGMock\ngneb\nGNEB\nGoldfarb\nGonzalez-Melchor\ngooglemail\ngoogletest\nGordan\nGoudeau\nGPa\ngpu\ngpuID\ngpus\ngradgradflag\ngradV\nGradVidottan\ngraining\nGraining\nGrama\ngrana\ngranregion\ngraphene\nGreathouse\ngreenyellow\nGreffet\ngrem\ngREM\nGrest\nGrigera\nGrimme\ngrmask\nGrmask\ngromacs\nGromacs\ngromos\nGronbech\nGroot\ngroupbig\ngroupbit\ngrp\nGrueneisen\ngsmooth\ngstyle\nGTL\nGubbins\nGuericke\nGuenole\ngui\nGumbsch\nGunsteren\nGunzenmuller\nGuo\ngw\ngyromagnetic\ngz\ngzipped\nHaak\nHafskjold\nhalfstepback\nHalperin\nHalver\nHamaker\nHamel\nhaptic\nHara\nHarpertown\nHarting\nHartree\nHartrees\nHasan\nHashtable\nHaswell\nHaugk\nHayoun\nHayre\nhbar\nhbcut\nhbn\nhbnewflag\nhbond\nhcp\nheatconduction\nHebenstreit\nHecht\nHeenen\nHendrik\nHenin\nHenkelman\nHenkes\nhenrich\nHenrich\nHermitian\nHerrmann\nHertizian\nhertzian\nHertzsch\nheterostructures\nhexahedrons\nhexatic\nhexorder\nHeyes\nHfO\nhgrid\nhhmrr\nHibbs\nHigdon\nHijazi\nHilger\nHinestrosa\nhisto\nhistogrammed\nhistogramming\nhma\nhmaktulga\nhplanck\nhoc\nHochbruck\nHofling\nHolian\nHolm\nholonomic\nHomebrew\nhooke\nHookean\nhotpink\nHoulle\nhowto\nHowto\nHoyt\nHs\nhstyle\nhtml\nhTST\nhttps\nhu\nHueckel\nHuetter\nHugonio\nhugoniostat\nHugoniostat\nHugoniot\nHura\nhux\nhwloc\nhx\nhy\nhydrophobicity\nhydrostatic\nhydrostatically\nHynninen\nHyoungki\nhyperdynamics\nhyperplane\nhyperradius\nhyperspherical\nhysteretic\nhz\nIbanez\niatom\nibar\nibm\nicc\nico\nicosahedral\nidealgas\nIDR\nidx\nie\nielement\nieni\nifdefs\niff\nifort\nIhle\nij\nijk\nijkl\nik\nIkeshoji\nilmenau\nIlmenau\nilp\nIlya\nim\nIm\nimageint\nImageint\nImagemagick\nimd\nImpey\nimpl\nimpropers\nImpropers\nimulator\nincludelink\nincompressible\nincrementing\nindenter\nindenters\nindianred\nindices\ninertiax\ninertiay\ninertiaz\ninfile\ninfty\ninhomogeneities\ninhomogeneous\ninit\ninitialdelay\ninitializations\nInitiatorIDs\ninitio\nInP\ninregion\ninstantiation\nInstitut\nintegrators\nIntegrators\nintel\nintelmpi\ninteral\ninteratomic\nInteratomic\ninterconvert\ninterial\ninterlayer\nintermolecular\nInterparticle\ninterstitials\nintertube\nIntr\nintra\nintralayer\nintramolecular\nints\ninv\ninvariants\ninversed\nionocovalent\niostreams\niparam\nipi\nipp\nIppolito\nIPv\nIPython\nipython\nIsele\nisenthalpic\nish\nIshida\niso\nisodemic\nisoenergetic\nisoenthalpic\nisokinetic\nisomorphism\nisothermal\nisotropically\nisovolume\nIsralewitz\niter\niters\niteratively\nIth\nItsets\nitype\nitypeN\niva\nIvanov\nIvector\nIw\niwyu\nixcm\nixx\nIxx\nixy\nIxy\nixz\nIxz\niy\niycm\niyy\nIyy\niyz\nIyz\niz\nizcm\nized\nIzrailev\nIzumi\nIzvekov\nizz\nIzz\nJacobsen\nJadhav\njagreat\nJahn\nJalalvand\njames\nJanssen\nJanssens\nJaramillo\nJarzynski\njatempl\njavascript\njcp\njea\njec\nJeffers\njewett\nJewett\nji\nJiang\nJiao\njik\nJIK\njku\njN\nJoannopoulos\nJochim\nJonsson\nJorgensen\njp\njparam\njpeg\njpeglib\njpg\nJPG\njpl\nJth\njtranch\njtype\njtypeN\nJuelich\nJulien\njunghans\nJunghans\nJungnickel\nJupyter\nJusto\nJusufi\nJx\nJy\nJz\njzimmer\nKadiri\nKai\nKalia\nKamberaj\nKapfer\nKarls\nKarlsruhe\nKarniadakis\nKarplus\nKarttunen\nkate\nKatsnelson\nKatsura\nKaufmann\nKawata\nKaxiras\nKayser\nkb\nkB\nkbit\nkbits\nkcal\nkcl\nKd\nKDevelop\nke\nKE\nKeblinski\nKeefe\nkeflag\nKeir\nKelchner\nKelkar\nKemper\nkepler\nkeV\nKeyes\nKhersonskii\nKhrapak\nKhvostov\nKi\nKikugawa\nkim\nkinetostats\nkJ\nkk\nKlahn\nKlapp\nKloss\nKloza\nkmax\nKmax\nKMP\nkmu\nKnizhnik\nknl\nKofke\nkofke\nKohlmeyer\nKohn\nkokkos\nKolafa\nKollman\nkolmogorov\nKolmogorov\nKondor\nkonglt\nKoning\nKooser\nKorn\nKoskinen\nKoster\nKosztin\nKp\nKraker\nKraus\nKremer\nKress\nKronik\nksh\nkspace\nKspace\nKSpace\nKSpaceStyle\nKspring\nkT\nkTequil\nkth\nKth\nkTln\nktypeN\nKub\nKubo\nKumagai\nKumar\nKurebayashi\nKuronen\nKusters\nKutta\nKuznetsov\nkx\nLackmann\nLadd\nlagrangian\nlambdai\nlamda\nLambdaLanczos\nlammps\nLammps\nLAMMPS\nlammpsplot\nLampis\nLamoureux\nLanczos\nLande\nLandron\nlangevin\nLangevin\nLangston\nlanl\nlarentzos\nLarentzos\nLaroche\nlars\nlatencies\nLatour\nlatourr\nlattce\nLaupretre\nLauriat\nlavenderblush\nlawngreen\nlB\nlbfgs\nlbl\nLBtype\nlcbop\nld\nldfftw\nldg\nlebedeva\nLebedeva\nLebold\nLechman\nLehoucq\nLeimkuhler\nLeite\nleiu\nlemonchiffon\nLenart\nlennard\nLennard\nLenosky\nLenz\nLett\nLeuven\nLeven\nLewy\nlgvdw\nLiang\nlibatc\nlibAtoms\nlibawpmd\nlibch\nlibcolvars\nlibcurl\nlibdir\nlibdl\nlibfftw\nlibgcc\nlibgpu\nlibjpeg\nlibkim\nliblammps\nLiblammps\nliblink\nlibmeam\nlibmessage\nlibmpi\nlibmpich\nlibnuma\nlibplumed\nlibplumedKernel\nlibpng\nlibpoems\nlibqmmm\nlibrar\nlibreax\nlibs\nLifshitz\nligand\nlightblue\nlightcoral\nlightcyan\nlightgoldenrodyellow\nlightgreen\nlightgrey\nlightpink\nlightsalmon\nlightseagreen\nlightskyblue\nlightslategray\nlightsteelblue\nlightyellow\nLikhtman\nlimegreen\nlinalg\nLindahl\nlineflag\nlineforce\nlinesearch\nlinux\nLiouville\nLisal\nlistfile\nLittmark\nLiu\nLivermore\nlj\nllammps\nLLVM\nlm\nlmp\nlmpptr\nlmpqst\nlmpsdata\nLmpsdata\nlmptype\nLMT\nln\nlocalTemp\nlocalvectors\nLoewen\nlogfile\nlogfreq\nlogicals\nLomdahl\nLond\nlookup\nlookups\nLookups\nLoopVar\nLorant\nlorenz\nLos\nlossless\nlossy\nLozovik\nlps\nlpsapi\nlrt\nlsfftw\nltbbmalloc\nlubricateU\nlucy\nLua\nLuding\nLussetti\nLustig\nlval\nlwsock\nlx\nly\nLybrand\nLyulin\nlz\nMaaravi\nMackay\nMackrodt\nMacromolecules\nmacroparticle\nMacOS\nMadura\nMagda\nMagdeburg\nmagelec\nMaginn\nmagneton\nmagnetons\nmainboard\nmainboards\nmakefile\nMakefile\nmakefiles\nMakefiles\nmakelist\nmakepkg\nMakse\nmalloc\nMalolepsza\nManby\nMandadapu\nMandelli\nManh\nmanifoldforce\nManolopoulos\nmanpages\nmanybody\nMANYBODY\nMaras\nMarchetti\nMarchi\nMariella\nMarinica\nMarrink\nMarroquin\nMarsaglia\nMarseille\nMartyna\nmary\nmarys\nMasaglia\nMashayak\nMassimilliano\nmassless\nmasstotal\nMasuhiro\nMatchett\nMaterias\nmathbf\nmathjax\nmatlab\nmatplotlib\nMatsubara\nMattice\nMattox\nMattson\nmaxangle\nmaxbond\nmaxchunk\nmaxelt\nmaxeval\nmaxfiles\nMaxfoo\nmaxima\nmaxit\nmaxiter\nmaxsize\nmaxspecial\nmaxSteps\nmaxstrain\nmaxwell\nMaxwellian\nmaxX\nMayergoyz\nMayoral\nmbt\nMbytes\nMBytes\nmc\nMcLachlan\nmd\nmdf\nmdpd\nmDPD\nmeam\nmeamc\nMEAMC\nmeamf\nmeanDist\nmech\nMecke\nmediumaquamarine\nmediumblue\nmediumorchid\nmediumpurple\nmediumseagreen\nmediumslateblue\nmediumspringgreen\nmediumturquoise\nmediumvioletred\nMees\nMehl\nMei\nMelchor\nMeloni\nMelrose\nMem\nmem\nmemalign\nMEMALIGN\nmembered\nmemcheck\nMendelev\nmer\nMeremianin\nMersenne\nMerz\nmeshless\nmeso\nmesocnt\nMESODPD\nmesodpd\nMESONT\nmesont\nmesoparticle\nmesoscale\nmesoscopic\nmetadata\nmetadynamics\nMetadynamics\nMethfessel\nmethine\nMetin\nmeV\nMezei\nmgpt\nMGPT\nmgptfast\nmh\nmicelle\nmicelles\nmichael\nmichele\nMickel\nmicrocanonical\nmicroelastic\nmicroporous\nMicroscale\nmidnightblue\nmie\nMie\nMij\nMikami\nMilano\nMilitzer\nMinary\nmincap\nMindlin\nminhbonds\nmingw\nminima\nminimizations\nminimizer\nminimizers\nminneigh\nminorder\nminSteps\nmintcream\nMintmire\nMiron\nmis\nMises\nMishin\nMishra\nmistyped\nmistyrose\nMj\nmK\nmkdir\nmkv\nmliap\nmliappy\nmlparks\nMniszewski\nmnt\nmobi\nmodc\nModell\nmodelled\nmodelling\nModelling\nModine\nmofff\nMOFFF\nMohd\nMohles\nmol\nMol\nmolfile\nMolfile\nMolPairStyle\nmoltemplate\nmomb\nMonaghan\nMonaghans\nmonodisperse\nmonodispersity\nmonovalent\nMontalenti\nMontero\nMorefoo\nMorfill\nMori\nMoriya\nmorris\nMorriss\nmorse\nMorteza\nMosayebi\nMoseler\nMoskalev\nMoustafa\nmov\nmpi\nMPI\nmpicc\nmpiCC\nmpich\nmpicolor\nmpicxx\nmpiexec\nmpiio\nmpirun\nmplayer\nmps\nMryglod\nmscg\nMSCG\nmsd\nmsi\nMSI\nmsm\nmsse\nmsst\nMtchell\nMth\nmtk\nMtotal\nmuB\nMuccioli\nmui\nMukherjee\nMulders\nmult\nmulti\nmultibody\nMultibody\nmulticenter\nmulticentered\nmulticmd\nmulticomponent\nmulticore\nmultielectron\nmultinode\nmultiphysics\nmultiscale\nmultisectioning\nmultithreading\nMultithreading\nMundy\nMurdick\nMurtola\nMurty\nMuser\nMuto\nmuVT\nmux\nmuy\nmuz\nM\u00fcller\nmv\nmV\nMvapich\nmvh\nmvv\nMxN\nmyCompute\nmyIndex\nmylammps\nMyPool\nmysocket\nmyTemp\nmyVec\nna\nnabla\nNagaosa\nNakano\nnall\nnamespace\nnamespaces\nnamedtuple\nnan\nNaN\nNandor\nnangles\nNangletype\nnangletypes\nNangletypes\nnano\nnanoindentation\nNanoletters\nnanomechanics\nnanometer\nnanometers\nnanoparticles\nNanotube\nnanotube\nnanotubes\nNarulkar\nnasa\nnasr\nnatively\nNatoli\nnatoms\nNatoms\nNattempt\nnavajowhite\nNavier\nnb\nNbin\nNbins\nnbody\nNbody\nnbonds\nnbondtype\nNbondtype\nnbondtypes\nNbondtypes\nnBOt\nnbrhood\nNbtypes\nnc\nNc\nnchunk\nNchunk\nncoeff\nncol\nncorr\nncount\nnd\nndihedrals\nndihedraltypes\nNdihedraltype\nNdirango\nndof\nNdof\nNdouble\nndx\nneb\nneel\nNeel\nNeelov\nNegre\nnelem\nnelems\nNelement\nNelements\nnemd\nnetcdf\nnetstat\nNettleton\nNeumann\nNevent\nnevery\nNevery\nnewfile\nNewns\nnewtype\nNeyts\nNf\nnfft\nnfile\nNfile\nNfreq\nng\nNg\nnghost\nNghost\nNgpu\nNgyuen\nnh\nnharmonic\nnhc\nnhi\nNiAlH\nNicklas\nNiklasson\nNikolskiy\nnimpropers\nnimpropertypes\nNimpropertype\nNinteger\nNissila\nnist\nnitride\nnitrides\nniu\nNk\nnktv\nnl\nnlen\nNlines\nnlo\nnlocal\nNlocal\nNlog\nnlp\nnm\nNm\nNmax\nnmax\nNmin\nnmin\nNmols\nnn\nNocedal\nnocite\nnocoeff\nnodeless\nnodeset\nnodesets\nNoehring\nNoffset\nnoforce\nNoid\nnolib\nnonequilibrium\nnongauss\nnonGaussian\nnonlocal\nNonlocal\nNoordhoek\nnopreliminary\nNord\nnorder\nNordlund\nnormals\nNoskov\nnoslip\nnoticable\nnoutcol\nNoutput\nnoutrow\nNovik\nNovint\nnp\nNpair\nNpairs\nnparams\nnparticle\nnpernode\nnph\nNpH\nNphi\nnphug\nnprocs\nNprocs\nnpt\nnr\nNr\nNrecompute\nNrepeat\nnreset\nNrho\nNroff\nnrow\nnrun\nNs\nNsample\nNskip\nNspecies\nns\nnsq\nNstart\nnstats\nNstep\nNsteplast\nNstop\nnsub\nNswap\nNt\nNtable\nntheta\nnthreads\nntimestep\nNtptask\nNtriples\nNtype\nntypes\nNtypes\nnucleotides\nnum\nnuma\nnumactl\nnumdiff\nnumericalfreedom\nnumerics\nnumpy\nNumpy\nNurdin\nNvalue\nNvaluelast\nNvalues\nnvc\nnvcc\nnve\nnvidia\nnvk\nnvt\nNwait\nnwchem\nnx\nNx\nnxnodes\nny\nNy\nnz\nNz\nocl\noctahedral\noctants\nOhara\nohenrich\nok\nOkabe\nOkamoto\nO'Keefe\nOKeefe\noldlace\nolecular\nOleinik\nOlfason\nolivedrab\nOllila\nomegaDD\nomegax\nomegay\nomegaz\nOmelyan\nomp\nOMP\nonelevel\noneway\nonn\nons\nOO\nopencl\nopenKIM\nopenmp\nOpenMP\nopenmpi\nopls\nOppelstrup\noptimizations\norangered\norganometallic\norientational\norientationsFile\norientorder\nOrlikowski\nornl\nOrnstein\nOrsi\northo\northonormal\northorhombic\noso\nOtype\nOuldridge\noutfile\noutmost\noutputss\nOuyang\noverdamped\noverlayed\nOvito\noxdna\noxrna\noxDNA\noxRNA\npackings\npadua\nPadua\npafi\npalegoldenrod\npalegreen\npaleturquoise\npalevioletred\nPanagiotopoulos\nPandit\nPapaconstantopoulos\npapayawhip\npaquay\nPaquay\nparallelepiped\nParallelizable\nparallelization\nparallelized\nparallelizing\nparam\nparameterization\nparameterizations\nparameterize\nparameterized\nparams\nParaView\nparmin\nParrinello\nPartay\nParticuology\npastewka\nPastewka\npathangle\npathname\npathnames\nPatomtrans\nPattnaik\nPavese\nPavia\nPaxton\npbc\npc\npchain\nPchain\nPdamp\npdb\npdf\npdfs\npdim\npe\nPeachey\npeachpuff\nPearlman\nPedersen\npeID\nPEigenDense\nPeng\npeptide\nperatom\nPergamon\nperi\nperidynamic\nPeridynamic\nperidynamics\nPeridynamics\nperl\npermittivity\nperp\nPerram\npersp\nPersp\nperu\nPeskin\nPettifor\npfactor\npgi\nph\nPhilipp\nPhillpot\nPhilos\nphiphi\nphonon\nphonons\nphophorous\nphosphide\nPhs\nPhysica\nphysik\nPiaggi\npicocoulomb\npicocoulombs\npicogram\npicograms\npicosecond\npicoseconds\npid\npiecewise\nPieniazek\nPieter\npimd\nPiola\nPisarev\nPishevar\nPitera\npj\npjintve\nplaneforce\nPlathe\nPlimpton\nplog\nploop\nPloS\nplt\nplumedfile\npmb\nPmolrotate\nPmoltrans\npN\npng\nPodhorszki\nPoiseuille\npoisson\nPolak\npolarizabilities\npolarizability\npolarizable\nPolarizable\npolarizables\npolarizer\nPolitano\npolyA\npolybond\npolydisperse\npolydispersity\npolyelectrolyte\npolyhedra\npolymorphism\nPolym\npopen\nPopov\npopstore\nPoresag\npos\nPoschel\nposix\npostfix\npostfixed\npostfixes\nPostma\nPotapkin\npotin\nPourtois\npowderblue\nppn\npppm\nprd\nPrakash\npre\nPre\nprec\nprecession\nprefactor\nprefactors\nprepend\nprepended\npreprint\nprintf\nprintflag\npriori\nPriya\nproc\nProc\nprocs\nProny\nprogguide\nps\nPs\npscreen\npscrozi\npseudodynamics\npseudopotential\nPstart\nPstop\npstyle\nPtarget\npth\npthread\npthreads\nptm\nPTM\nptol\nptr\npu\npurdue\nPurohit\npushstore\npvar\npw\npwqmmm\npx\nPx\npxx\nPxx\nPxy\npy\nPy\npydir\npylammps\nPyLammps\npymbar\npymodule\npymol\npypar\npythonic\npytorch\nPyy\npz\nPz\nPzz\nqbmsst\nqcore\nqdist\nqE\nqe\nqeff\nqelectron\nqeq\nQeQ\nQEq\nqfactor\nqfile\nqi\nQi\nqj\nQj\nQl\nqm\nQmin\nqmmm\nqmol\nqoffload\nqopenmp\nqoverride\nqqr\nqqrd\nqtb\nquadratically\nquadrupolar\nQuant\nquartic\nquat\nquaternion\nquaternions\nquati\nquatj\nquatk\nquatw\nqueryargs\nQueteschiner\nqw\nqx\nqy\nqz\nradian\nradians\nRafferty\nrahman\nRahman\nRaman\nramped\nramping\nRamprasad\nRandisi\nrandomizations\nRaphson\nRappe\nRavelo\nrc\nRc\nRcm\nrcmax\nRcmx\nRcmy\nRcut\nrcutfac\nrdc\nrdf\nRDideal\nrdx\nreacter\nReadline\nrealTypeMap\nreal_t\nREADME\nrealtime\nreamin\nreax\nREAXC\nReaxFF\nrebo\nrecursing\nRee\nrefactored\nrefactoring\nreflectionstyle\nReinders\nreinit\nrelaxbox\nrelink\nrelTol\nremappings\nremd\nRen\nRendon\nreneighbor\nreneighboring\nReneighboring\nreneighborings\nRensselaer\nreparameterizing\nrepo\nrepresentable\nReproducibility\nreproducibility\nrepuls\nrescale\nrescaled\nrescales\nrescaling\nRescaling\nrespa\nRESPA\nrespecified\nresponder\nresquared\nREsquared\nrestartfile\nrestartinfo\nrethrowing\nRevenga\nrewrap\nrezwanur\nrfac\nrfile\nrg\nRg\nRhaphson\nRhe\nrheological\nrheology\nrhodo\nRhodo\nrhodopsin\nrhok\nrhomax\nrhomin\nrhorho\nrhosum\nri\nRi\nRibiere\nrichard\nrigidID\nrigidify\nrij\nrIJ\nRij\nRIj\nRik\nRin\nRino\nRiRj\nRisi\nRix\nRiy\nrj\nRj\nRjinner\nRjinnerN\nRjk\nrjones\nRjouter\nRjouterN\nrk\nrkf\nRkinner\nRkinnerN\nRkouter\nRkouterN\nrmask\nRmask\nrmass\nrmax\nRmax\nrmdir\nrmin\nRmin\nRMS\nrmsd\nrnage\nrNEMD\nro\nRochus\nRockett\nrocksalt\nRodrigues\nRohart\nRonchetti\nRonevich\nRosati\nRosenberger\nRossky\nrosybrown\nrotationally\nRotenberg\nRovigatti\nroyalblue\nrozero\nRperp\nRr\nrRESPA\nRspace\nrsq\nrst\nrstyle\nRubensson\nRubia\nRudd\nRudra\nRudranarayan\nRudzinski\nRunge\nruntime\nRutuparna\nrx\nry\nrz\nRyckaert\nRycroft\nRydbergs\nRz\nSabry\nsaddlebrown\nSadigh\nsaed\nsafezone\nSafran\nSagui\nSaidi\nSalanne\nSalles\nsandia\nSandia\nsandybrown\nsanitizer\nSanyal\nsc\nscafacos\nSCAFACOS\nscalability\nscalable\nScalable\nscalexy\nscalexz\nscaleyz\nSchaik\nSchilfgarde\nSchimansky\nSchiotz\nSchlitter\nSchmid\nSchratt\nSchoen\nSchotte\nSchulten\nSchunk\nSchuring\nSchwen\nSci\nscreenshot\nscreenshots\nScripps\nScripta\nsdk\nsdpd\nSDPD\nse\nseagreen\nSecor\nsectoring\nsed\nsegmental\nSeifert\nsellerio\nSellerio\nSemaev\nsemiaxes\nsemimetals\nSemin\nSensable\nSep\nseqdep\nSerpico\nsetfl\nsetforce\nSethna\nsetmask\nSetmask\nsetpoint\nsetvel\nsfftw\nSg\nShan\nShanno\nshapex\nshapey\nshapez\nshapshot\nshardlow\nShardlow\nshawn\nShen\nShenderova\nShi\nShiga\nShinoda\nShiomi\nshlib\nSHM\nshm\nshockvel\nshrinkexceed\nShugaev\nsi\nSiC\nSiepmann\nSievers\nSij\nSikandar\nSilbert\nSilling\nSim\nSimov\nSimul\nsimulations\nSinnott\nsinusoid\nsinusoidally\nSiO\nSirk\nSival\nsizeI\nsizeJ\nsizex\nsj\nsjplimp\nsjtu\nSkomski\nskyblue\nSkylake\nslateblue\nslategray\nslater\nSlepoy\nSliozberg\nsLLG\nsllod\nsm\nsmallbig\nsmallint\nSmallint\nsmallsmall\nsmd\nSMD\nsmi\nSmirichinski\nSmit\nsmtbq\nsna\nsnad\nsnapcoeff\nsnapparam\nsnav\nSnodin\nSodani\nSoderlind\nsolvated\nsolvation\nsomeuser\nSorensen\nsoundspeed\nsourceforge\nSouza\nsp\nspacings\nSpearot\nspecular\nspellcheck\nSpellmeyer\nsph\nSPH\nSpickermann\nsplined\nspparks\nSpringer\nspringgreen\nspx\nspz\nsqdistharm\nsqrt\nsrc\nsrd\nsright\nSrinivasan\nSrivastava\nSrolovitz\nsrp\nsrun\nss\nssao\nstamoor\nstamoore\nstanford\nStarikov\nstartstep\nStartstep\nstatcoul\nstatcoulombs\nstatvolt\nstdin\nstdio\nstdlib\nsteelblue\nStegailov\nSteinbach\nSteinhardt\nSteinhauser\nStepaniants\nstepwise\nStesmans\nStillinger\nstk\nStockmayer\nStoddard\nstochastically\nstochasticity\nstoichiometric\nstoichiometry\nStokesian\nStoll\nstopstep\nStouch\nStraatsma\nStrachan\nStratford\nStrathclyde\nStraub\nstrcmp\nstreitz\nStreitz\nStreiz\nstrerror\nstrided\nstrietz\nstrmatch\nstrncmp\nstrstr\nStukowski\nSu\nsubbox\nSubclassed\nsubcutoff\nsubcycle\nsubcycling\nsubhi\nsublo\nSubramaniyan\nsubscripted\nsubscripting\nsudo\nSugaku\nSuhai\nSukumaran\nSulc\nsumsq\nSunderland\nsupercell\nsuperset\nsupersphere\nSupinski\nSurblys\nsurfactant\nsurfactants\nSuter\nSutmann\nsvn\nsw\nSwegat\nswiggle\nSwiler\nSwinburne\nSwol\nSwope\nSx\nsy\nSy\nsymplectic\nSynechococcus\nsys\nsysdim\nSyst\nsystemd\nSz\nTabbernor\ntabinner\nTadmor\nTafipolsky\ntagID\ntagint\nTainter\nTait\ntaitwater\nTajkhorshid\nTamaskovics\nTanaka\ntanh\ntanmoy\nTanmoy\nTartakovsky\ntaskset\ntaubi\ntb\ntchain\nTchain\nTcl\nTcom\ntcsh\ntdamp\ntdpd\ntDPD\nTdrude\nTechnol\nTelsa\ntempCorrCoeff\ntemplated\nTempleton\nTequil\nters\ntersoff\nTersoff\ntesselation\nTetot\ntex\ntfac\ntfmc\ntfMC\ntgnpt\ntgnvt\nThakkar\nThaokar\nth\nthb\nthei\nTheodorou\nTheor\nthermalization\nthermalize\nthermalized\nThermalized\nthermalizing\nThermalizing\nthermo\nthermochemical\nthermochemistry\nthermodynamically\nThermophysical\nthermostatted\nthermostatting\nThermostatting\nThes\nThess\nThexe\nThiaville\nThibaudeau\nThijsse\nThirumalai\nthreebody\nthrid\nThunderX\nthylakoid\nTHz\nTigran\nTij\nTildesley\ntimespan\ntimestamp\ntimestamps\ntimestep\ntimestepping\ntimesteps\nTiN\nTiO\nTirrell\nTiter\nTji\nTk\nTkin\ntloop\ntlsph\ntmax\nTmax\ntmd\ntmin\nTmin\ntmp\ntN\nTobias\nTohoku\ntokenizer\ntokyo\ntol\nToennies\ntomic\ntoolchain\ntopologies\nToporov\nTorder\ntorsions\nTosi\nToukmaji\nToxvaerd\ntpa\ntpc\ntpm\ntptask\ntqx\ntqy\ntqz\ntraceless\ntradeoff\ntraj\nTranchida\ntransactional\ntransferability\ntranslational\nTranslational\ntrate\nTref\nTretyakov\ntri\ntriangleflag\nTribello\ntriclinic\nTriclinic\ntriflag\ntrigonal\ntrilinear\nTrinkle\ntripflag\ntris\ntrj\ntrott\nTrott\nTrung\nTrushin\ntscale\nTschopp\nTsige\nTsrd\nTstart\ntstat\nTstop\nTsuji\nTsuzuki\ntt\nTt\nTThis\nttm\nttol\ntu\nTuckerman\ntue\ntunable\ntuple\ntuples\nTurkand\nTutein\ntweakable\ntwobody\ntwojmax\nTx\ntxt\ntypeI\ntypeJ\ntypeN\ntypeargs\nTz\nTzou\nub\nUberuaga\nuChem\nuCond\nuef\nUEF\nufm\nUhlenbeck\nUi\nuInfParallel\nuk\nul\nulb\nUleft\nuloop\nUlomek\nulsph\nuMech\numin\nUmin\nun\nunary\nuncomment\nuncompute\nunderprediction\nundump\nuniaxial\nuniaxially\nunimodal\nunitarg\nunitless\nUniversite\nunix\nunmaintained\nunoptimized\nunpadded\nunphysical\nunphysically\nunreacted\nunscaled\nunsets\nunsmoothed\nunsolvated\nunsplit\nunstrained\nuntar\nuntilted\nuparrow\nupenn\nupto\nUrbakh\nUrbana\nusec\nuSemiParallel\nuserguide\nusername\nusr\nutil\nutils\nutsa\nUttormark\nuval\nuvm\nuwo\nUzdin\nvacf\nVaid\nVaiwala\nvalent\nValeriu\nvalgrind\nValone\nvaluev\nValuev\nVanden\nVandenbrande\nVanduyfhuys\nvaravg\nVarshalovich\nVarshney\nvashishta\nVashishta\nvasp\nvcm\nVcm\nvdfmax\nvdim\nvdisplace\nvdW\nvdwl\nvec\nvectorial\nvectorization\nVectorization\nvectorized\nVegt\nvel\nVel\u00e1zquez\nvenv\nVerlag\nverlet\nVerlet\nversa\nves\nvflag\nvhi\nvibrational\nVij\nVikas\nvirial\nVirial\nvirialmode\nvirials\nvirtualenv\nviscoelastic\nviscoelasticity\nviscosities\nviscously\nvizplotgui\nVj\nVkl\nvlo\nvmax\nvmd\nVMDARCH\nVMDHOME\nvn\nVoigt\nvolfactor\nVolkov\nVolpe\nvolpress\nvolumetric\nvon\nVoro\nVorobyov\nvoronoi\nVoronoi\nVORONOI\nVorselaars\nVoth\nvpz\nvratio\nVries\nVsevolod\nVsmall\nVstream\nvtarget\nvtk\nVTK\nvtp\nvtr\nvtu\nVu\nVuilleumier\nvv\nvx\nVx\nvxcm\nvxmu\nvy\nVy\nvycm\nvz\nVz\nvzcm\nvzi\nWaals\nWadley\nwallstyle\nwalltime\nWaltham\nwavepacket\nwB\nWbody\nwca\nwebpage\nWeckner\nWeinanE\nWennberg\nWestmere\nWestview\nwf\nwget\nWhelan\nwhitesmoke\nwhitespace\nWi\nWicaksono\nWidom\nwidom\nWijk\nWikipedia\nWildcard\nwildcard\nwildcards\nWirnsberger\nwirtes\nwitin\nWittmaack\nwn\nWolde\nworkflow\nWorley\nWriggers\nWuppertal\nWurtzite\nwww\nwx\nWx\nwy\nWy\nwz\nWz\nxa\nxAVX\nxb\nXc\nxcm\nXcm\nXcode\nxCORE\nXeon\nxflag\nxhi\nxHost\nXiaohu\nXiaowang\nXie\nxk\nxlat\nxlo\nxmax\nXmax\nxmgrace\nxMIC\nxmin\nxml\nxmovie\nXmovie\nxmu\nXmu\nXP\nxplane\nXPlor\nxrd\nxs\nxstk\nxsu\nxtc\nxu\nXu\nxxt\nxxxxx\nxy\nxyz\nxz\nxzhou\nyaff\nyaml\nYAFF\nYamada\nYaser\nYazdani\nYbar\nybox\nYc\nycm\nYeh\nyellowgreen\nYethiraj\nyflag\nyhi\nyi\nylat\nylo\nymax\nymin\nYoshida\nys\nysu\nyu\nYu\nYuh\nyukawa\nYukawa\nYusof\nYuya\nyx\nyy\nyz\nZannoni\nzbl\nZBL\nZc\nzcm\nZeeman\nZemer\nZepeda\nzflag\nZhang\nZhen\nzhi\nZhigilei\nZhou\nZhu\nzi\nZi\nziegenhain\nZiegenhain\nZj\nzlim\nzlo\nzmax\nzmin\nzmq\nzN\nzs\nzst\nzsu\nzu\nzx\nzy\nZybin\nzz\nZm\nPowerShell\nfilesystems\nzincblende\nZstandard\nZstd\nzstd\nchecksum\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/.git/objects/pack/pack-bfcdc6a5ee9ae205baae9e581aa9529334d70058.idx",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/.git/objects/pack/pack-bfcdc6a5ee9ae205baae9e581aa9529334d70058.pack",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/SPIN/read_restart/restart_hcp_cobalt.equil",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/hyper/local.000000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/hyper/local.001300.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/hyper/global.089000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/hyper/local.000400.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/hyper/global.000000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/hyper/global.041000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/hyper/global.048000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/hyper/global.045000.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/mliap/relu1hidden.mliap.pytorch.model.pt",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/mscg/output_9Jan17/x.out",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/cgsdk/sds-monolayer/data.sds.gz",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/cgsdk/peg-verlet/data.pegc12e8.gz",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/phonon/3-3D-FCC-Cu-EAM/CuPhonon.bin.6500000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/phonon/4-Graphene/Graphene.bin.6000000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/phonon/1-1D-mono/phonon.bin.2000000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/phonon/2-1D-diatomic/phonon.bin.2000000",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/diffraction/Output/bulkNi_001.saed.0_VisIt_Image.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/reaction/nylon,6-6_melt/large_nylon_melt.data.gz",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/manifold/diffusion/msd_plot2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/manifold/diffusion/msd.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/manifold/energy/energy_conservation.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/manifold/energy/energy_conservation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/mesont/C_10_10.mesocnt",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/examples/USER/mesont/TABTP_10_10.mesont",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/lammps-shell/icons/lammps.ico",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/lammps-shell/icons/lmpfile.ico",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/lammps-shell/icons/hicolor/64x64/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/lammps-shell/icons/hicolor/22x22/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/lammps-shell/icons/hicolor/48x48/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/lammps-shell/icons/hicolor/16x16/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/lammps-shell/icons/hicolor/32x32/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/lammps-shell/icons/hicolor/128x128/apps/lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/createatoms/Manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/xmgrace/lammpsplot.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/emacs/lammps-mode.el",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/i-pi/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/polybond/Manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/matlab/README.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/tools/pymol_asphere/doc/asphere_vis.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/balance_uniform.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/screenshot_pymol.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/screenshot_gl.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/saed_mesh.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/balance_rcb.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/saed_ewald_intersect.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/sinusoid.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/xrd_mesh.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/balance_nonuniform.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/screenshot_vmd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/gran_mixer.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/dump2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/hop2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/dump1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/gran_funnel.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/hop1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/screenshot_atomeye.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/osinfo.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/wsl_install2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/powershell.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/wsl_integration.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/first_login.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/windows_update.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/wsl_install3.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/updates.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/wsl_install1.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/windows_firewall.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/ubuntu_in_store.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/img/wsl_tutorial/compilation_result.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/colvars-refman-lammps.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/pair_resquared_extra.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/PDLammps_overview.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/USER-CGDNA.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/SMD_LAMMPS_userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/PDLammps_EPS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/pair_gayberne_extra.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/PDLammps_VES.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/kspace.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/PDF/SPH_LAMMPS_userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_pull_request2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_pull_request_feature_branch1.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/ccmake-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/user_intel.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_pull_request4.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/zeeman_langevin.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/examples_edpd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/atc_nanotube.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_merged.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_additional_changes.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/qbmsst_shock.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/examples_mdpd_first.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/dreiding_hbond.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/qbmsst_init.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/cmake-gui-initial.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/pylammps_mc_energies_plot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/coverage-overview-manybody.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_edits_maintainers.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/coverage-file-branches.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/examples_mdpd_last.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/improper_distance.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/umbrella.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/lj_soft.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/ccmake-initial.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_automated_checks_passed.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_new_pull_request.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/cmake-codeblocks.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/fix_wall_ees_image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_reverse_pull_request3.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/rhodo_staggered.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/dynamical_matrix_phonons.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/pimd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/offload_knc.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/ccmake-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_reverse_pull_request7.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/coul_soft.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/pylammps_mc_minimum.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/dihedral_sign.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/pylammps_mc_disordered.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/lammps-classes.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/examples_mdpd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_https_block.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_create_new_pull_request1.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/uef_frames.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_changes_others.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/coverage-overview-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/pair_body_rounded.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/examples_tdpd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/coverage-file-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_pull_request3.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_create_new_pull_request2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_reverse_pull_request4.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/python-invoke-lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/cmake-gui-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_fork.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/third_order_force_constant.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/fix_integration_spin_stdecomposition.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/lammps-invoke-python.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_reverse_pull_request5.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/pair_atm_dia.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_reverse_pull_request6.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_branch.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/cmake-gui-popup.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_reverse_pull_request2.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/pylammps_dihedral.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/bondswap.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_reverse_pull_request.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/WF_LJ.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_automated_checks.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/pylammps-invoke-lammps.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/tutorial_steve_assignee.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/dihedral_spherical_angles.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/src/JPG/pair_cosine_squared_graphs.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_static/lammps-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_static/lammps.ico",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-normal.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/Roboto-Slab-Regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/Roboto-Slab-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/Roboto-Slab-Bold.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/fontawesome-webfont.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-bold-italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-bold.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-bold-italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-normal.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-normal-italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/Roboto-Slab-Bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/fontawesome-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/css/fonts/lato-normal-italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/RobotoSlab-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Inconsolata.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Inconsolata-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Lato-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/Lato-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/FontAwesome.otf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/RobotoSlab-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/static/fonts/fontawesome-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/nl/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/es/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/pt_BR/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/ru/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/et/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/tr/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/fr/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/de/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/en/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/zh_CN/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/utils/sphinx-config/_themes/lammps_theme/locale/sv/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-lammps-master-xqih4vtwfruso4ztmu5l75w4zctvmjjr/spack-src/doc/doxygen/lammps-logo.png"
    ],
    "total_files": 10134
}