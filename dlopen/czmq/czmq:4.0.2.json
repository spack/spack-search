{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-czmq-4.0.2-zfoicjaila2umpuugu7wnnojijtppicg/spack-src/src/Makemodule-local.am": "# Project-local changes to auto-generated content\n\n# Android-qt requires this special link dependency\nif ON_ANDROID\nsrc_libczmq_la_LIBADD += -llog\nendif\n\ncheck-py: src/libczmq.la\n\t$(LIBTOOL) --mode=execute -dlopen src/libczmq.la python bindings/python/test.py\n",
        "/tmp/vanessa/spack-stage/spack-stage-czmq-4.0.2-zfoicjaila2umpuugu7wnnojijtppicg/spack-src/bindings/python_cffi/czmq_cffi.py": "################################################################################\n#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #\n#  Read the zproject/README.md for information about making permanent changes. #\n################################################################################\n\nfrom __future__ import print_function\nimport os\nimport re\nimport sys\n\nfrom pyczmq._cffi import ffi\n\ntry:\n    # If LD_LIBRARY_PATH or your OSs equivalent is set, this is the only way to\n    # load the library.  If we use find_library below, we get the wrong result.\n    if os.name == 'posix':\n        if sys.platform == 'darwin':\n            libpath = 'libczmq.4.dylib'\n        else:\n            libpath = 'libczmq.so.4'\n    elif os.name == 'nt':\n        libpath = 'libczmq.dll'\n    lib = ffi.dlopen(libpath)\nexcept OSError:\n    libpath = find_library(\"czmq\")\n    if not libpath:\n        raise ImportError(\"Unable to find libczmq\")\n    lib = ffi.dlopen(libpath)\n\n# Custom setup for czmq\nffi.cdef('''\ntypedef int... time_t;\ntypedef int... off_t;\n\ntypedef unsigned char   byte;           //  Single unsigned byte = 8 bits\ntypedef unsigned short  dbyte;          //  Double byte = 16 bits\ntypedef unsigned int    qbyte;          //  Quad byte = 32 bits\ntypedef int SOCKET;\n\n//  -- destroy an item\ntypedef void (czmq_destructor) (void **item);\n//  -- duplicate an item\ntypedef void *(czmq_duplicator) (const void *item);\n//  - compare two items, for sorting\ntypedef int (czmq_comparator) (const void *item1, const void *item2);\n''')\n\n\ncdefs = '''\ntypedef struct _zactor_t zactor_t;\ntypedef struct _zsock_t zsock_t;\ntypedef struct _zmsg_t zmsg_t;\ntypedef struct _zarmour_t zarmour_t;\ntypedef struct _zchunk_t zchunk_t;\ntypedef struct _char_t char_t;\ntypedef struct _zcert_t zcert_t;\ntypedef struct _zlist_t zlist_t;\ntypedef struct _zcertstore_t zcertstore_t;\ntypedef struct _zframe_t zframe_t;\ntypedef struct _zclock_t zclock_t;\ntypedef struct _msecs_t msecs_t;\ntypedef struct _zconfig_t zconfig_t;\ntypedef struct _zdigest_t zdigest_t;\ntypedef struct _zdir_t zdir_t;\ntypedef struct _zhash_t zhash_t;\ntypedef struct _zdir_patch_t zdir_patch_t;\ntypedef struct _zfile_t zfile_t;\ntypedef struct _zhashx_t zhashx_t;\ntypedef struct _zlistx_t zlistx_t;\ntypedef struct _ziflist_t ziflist_t;\ntypedef struct _zloop_t zloop_t;\ntypedef struct _zmq_pollitem_t zmq_pollitem_t;\ntypedef struct _zpoller_t zpoller_t;\ntypedef struct _zproc_t zproc_t;\ntypedef struct _va_list_t va_list_t;\ntypedef struct _socket_t socket_t;\ntypedef struct _zstr_t zstr_t;\ntypedef struct _ztimerset_t ztimerset_t;\ntypedef struct _ztrie_t ztrie_t;\ntypedef struct _zuuid_t zuuid_t;\n// Actors get a pipe and arguments from caller\ntypedef void (zactor_fn) (\n    zsock_t *pipe, void *args);\n\n// Loaders retrieve certificates from an arbitrary source.\ntypedef void (zcertstore_loader) (\n    zcertstore_t *self);\n\n// Destructor for loader state.\ntypedef void (zcertstore_destructor) (\n    void **self_p);\n\n// \ntypedef int (zconfig_fct) (\n    zconfig_t *self, void *arg, int level);\n\n// Callback function for zhash_freefn method\ntypedef void (zhash_free_fn) (\n    void *data);\n\n// Destroy an item\ntypedef void (zhashx_destructor_fn) (\n    void **item);\n\n// Duplicate an item\ntypedef void * (zhashx_duplicator_fn) (\n    const void *item);\n\n// Compare two items, for sorting\ntypedef int (zhashx_comparator_fn) (\n    const void *item1, const void *item2);\n\n// compare two items, for sorting\ntypedef void (zhashx_free_fn) (\n    void *data);\n\n// compare two items, for sorting\ntypedef size_t (zhashx_hash_fn) (\n    const void *key);\n\n// Serializes an item to a longstr.                       \n// The caller takes ownership of the newly created object.\ntypedef char * (zhashx_serializer_fn) (\n    const void *item);\n\n// Deserializes a longstr into an item.                   \n// The caller takes ownership of the newly created object.\ntypedef void * (zhashx_deserializer_fn) (\n    const char *item_str);\n\n// Comparison function e.g. for sorting and removing.\ntypedef int (zlist_compare_fn) (\n    void *item1, void *item2);\n\n// Callback function for zlist_freefn method\ntypedef void (zlist_free_fn) (\n    void *data);\n\n// Destroy an item\ntypedef void (zlistx_destructor_fn) (\n    void **item);\n\n// Duplicate an item\ntypedef void * (zlistx_duplicator_fn) (\n    const void *item);\n\n// Compare two items, for sorting\ntypedef int (zlistx_comparator_fn) (\n    const void *item1, const void *item2);\n\n// Callback function for reactor socket activity\ntypedef int (zloop_reader_fn) (\n    zloop_t *loop, zsock_t *reader, void *arg);\n\n// Callback function for reactor events (low-level)\ntypedef int (zloop_fn) (\n    zloop_t *loop, zmq_pollitem_t *item, void *arg);\n\n// Callback for reactor timer events\ntypedef int (zloop_timer_fn) (\n    zloop_t *loop, int timer_id, void *arg);\n\n// Callback function for timer event.\ntypedef void (ztimerset_fn) (\n    int timer_id, void *arg);\n\n// Callback function for ztrie_node to destroy node data.\ntypedef void (ztrie_destroy_data_fn) (\n    void **data);\n\n// CLASS: zactor\n// Create a new actor passing arbitrary arguments reference.\nzactor_t *\n    zactor_new (zactor_fn task, void *args);\n\n// Destroy an actor.\nvoid\n    zactor_destroy (zactor_t **self_p);\n\n// Send a zmsg message to the actor, take ownership of the message\n// and destroy when it has been sent.                             \nint\n    zactor_send (zactor_t *self, zmsg_t **msg_p);\n\n// Receive a zmsg message from the actor. Returns NULL if the actor \n// was interrupted before the message could be received, or if there\n// was a timeout on the actor.                                      \nzmsg_t *\n    zactor_recv (zactor_t *self);\n\n// Probe the supplied object, and report if it looks like a zactor_t.\nbool\n    zactor_is (void *self);\n\n// Probe the supplied reference. If it looks like a zactor_t instance,\n// return the underlying libzmq actor handle; else if it looks like   \n// a libzmq actor handle, return the supplied value.                  \nvoid *\n    zactor_resolve (void *self);\n\n// Return the actor's zsock handle. Use this when you absolutely need\n// to work with the zsock instance rather than the actor.            \nzsock_t *\n    zactor_sock (zactor_t *self);\n\n// Self test of this class.\nvoid\n    zactor_test (bool verbose);\n\n// CLASS: zarmour\n// Create a new zarmour\nzarmour_t *\n    zarmour_new (void);\n\n// Destroy the zarmour\nvoid\n    zarmour_destroy (zarmour_t **self_p);\n\n// Encode a stream of bytes into an armoured string. Returns the armoured\n// string, or NULL if there was insufficient memory available to allocate\n// a new string.                                                         \nchar *\n    zarmour_encode (zarmour_t *self, const byte *data, size_t size);\n\n// Decode an armoured string into a chunk. The decoded output is    \n// null-terminated, so it may be treated as a string, if that's what\n// it was prior to encoding.                                        \nzchunk_t *\n    zarmour_decode (zarmour_t *self, const char *data);\n\n// Get the mode property.\nint\n    zarmour_mode (zarmour_t *self);\n\n// Get printable string for mode.\nconst char *\n    zarmour_mode_str (zarmour_t *self);\n\n// Set the mode property.\nvoid\n    zarmour_set_mode (zarmour_t *self, int mode);\n\n// Return true if padding is turned on.\nbool\n    zarmour_pad (zarmour_t *self);\n\n// Turn padding on or off. Default is on.\nvoid\n    zarmour_set_pad (zarmour_t *self, bool pad);\n\n// Get the padding character.\nchar\n    zarmour_pad_char (zarmour_t *self);\n\n// Set the padding character.\nvoid\n    zarmour_set_pad_char (zarmour_t *self, char pad_char);\n\n// Return if splitting output into lines is turned on. Default is off.\nbool\n    zarmour_line_breaks (zarmour_t *self);\n\n// Turn splitting output into lines on or off.\nvoid\n    zarmour_set_line_breaks (zarmour_t *self, bool line_breaks);\n\n// Get the line length used for splitting lines.\nsize_t\n    zarmour_line_length (zarmour_t *self);\n\n// Set the line length used for splitting lines.\nvoid\n    zarmour_set_line_length (zarmour_t *self, size_t line_length);\n\n// Print properties of object\nvoid\n    zarmour_print (zarmour_t *self);\n\n// Self test of this class.\nvoid\n    zarmour_test (bool verbose);\n\n// CLASS: zcert\n// Create and initialize a new certificate in memory\nzcert_t *\n    zcert_new (void);\n\n// Accepts public/secret key pair from caller\nzcert_t *\n    zcert_new_from (const byte *public_key, const byte *secret_key);\n\n// Load certificate from file\nzcert_t *\n    zcert_load (const char *filename);\n\n// Destroy a certificate in memory\nvoid\n    zcert_destroy (zcert_t **self_p);\n\n// Return public part of key pair as 32-byte binary string\nconst byte *\n    zcert_public_key (zcert_t *self);\n\n// Return secret part of key pair as 32-byte binary string\nconst byte *\n    zcert_secret_key (zcert_t *self);\n\n// Return public part of key pair as Z85 armored string\nconst char *\n    zcert_public_txt (zcert_t *self);\n\n// Return secret part of key pair as Z85 armored string\nconst char *\n    zcert_secret_txt (zcert_t *self);\n\n// Set certificate metadata from formatted string.\nvoid\n    zcert_set_meta (zcert_t *self, const char *name, const char *format, ...);\n\n// Unset certificate metadata.\nvoid\n    zcert_unset_meta (zcert_t *self, const char *name);\n\n// Get metadata value from certificate; if the metadata value doesn't\n// exist, returns NULL.                                              \nconst char *\n    zcert_meta (zcert_t *self, const char *name);\n\n// Get list of metadata fields from certificate. Caller is responsible for\n// destroying list. Caller should not modify the values of list items.    \nzlist_t *\n    zcert_meta_keys (zcert_t *self);\n\n// Save full certificate (public + secret) to file for persistent storage  \n// This creates one public file and one secret file (filename + \"_secret\").\nint\n    zcert_save (zcert_t *self, const char *filename);\n\n// Save public certificate only to file for persistent storage\nint\n    zcert_save_public (zcert_t *self, const char *filename);\n\n// Save secret certificate only to file for persistent storage\nint\n    zcert_save_secret (zcert_t *self, const char *filename);\n\n// Apply certificate to socket, i.e. use for CURVE security on socket.\n// If certificate was loaded from public file, the secret key will be \n// undefined, and this certificate will not work successfully.        \nvoid\n    zcert_apply (zcert_t *self, void *socket);\n\n// Return copy of certificate; if certificate is NULL or we exhausted\n// heap memory, returns NULL.                                        \nzcert_t *\n    zcert_dup (zcert_t *self);\n\n// Return true if two certificates have the same keys\nbool\n    zcert_eq (zcert_t *self, zcert_t *compare);\n\n// Print certificate contents to stdout\nvoid\n    zcert_print (zcert_t *self);\n\n// Self test of this class\nvoid\n    zcert_test (bool verbose);\n\n// CLASS: zcertstore\n// Create a new certificate store from a disk directory, loading and        \n// indexing all certificates in that location. The directory itself may be  \n// absent, and created later, or modified at any time. The certificate store\n// is automatically refreshed on any zcertstore_lookup() call. If the       \n// location is specified as NULL, creates a pure-memory store, which you    \n// can work with by inserting certificates at runtime.                      \nzcertstore_t *\n    zcertstore_new (const char *location);\n\n// Destroy a certificate store object in memory. Does not affect anything\n// stored on disk.                                                       \nvoid\n    zcertstore_destroy (zcertstore_t **self_p);\n\n// Override the default disk loader with a custom loader fn.\nvoid\n    zcertstore_set_loader (zcertstore_t *self, zcertstore_loader loader, zcertstore_destructor destructor, void *state);\n\n// Look up certificate by public key, returns zcert_t object if found,\n// else returns NULL. The public key is provided in Z85 text format.  \nzcert_t *\n    zcertstore_lookup (zcertstore_t *self, const char *public_key);\n\n// Insert certificate into certificate store in memory. Note that this\n// does not save the certificate to disk. To do that, use zcert_save()\n// directly on the certificate. Takes ownership of zcert_t object.    \nvoid\n    zcertstore_insert (zcertstore_t *self, zcert_t **cert_p);\n\n// Empty certificate hashtable. This wrapper exists to be friendly to bindings,\n// which don't usually have access to struct internals.                        \nvoid\n    zcertstore_empty (zcertstore_t *self);\n\n// Print list of certificates in store to logging facility\nvoid\n    zcertstore_print (zcertstore_t *self);\n\n// Self test of this class\nvoid\n    zcertstore_test (bool verbose);\n\n// CLASS: zchunk\n// Create a new chunk of the specified size. If you specify the data, it   \n// is copied into the chunk. If you do not specify the data, the chunk is  \n// allocated and left empty, and you can then add data using zchunk_append.\nzchunk_t *\n    zchunk_new (const void *data, size_t size);\n\n// Destroy a chunk\nvoid\n    zchunk_destroy (zchunk_t **self_p);\n\n// Resizes chunk max_size as requested; chunk_cur size is set to zero\nvoid\n    zchunk_resize (zchunk_t *self, size_t size);\n\n// Return chunk cur size\nsize_t\n    zchunk_size (zchunk_t *self);\n\n// Return chunk max size\nsize_t\n    zchunk_max_size (zchunk_t *self);\n\n// Return chunk data\nbyte *\n    zchunk_data (zchunk_t *self);\n\n// Set chunk data from user-supplied data; truncate if too large. Data may\n// be null. Returns actual size of chunk                                  \nsize_t\n    zchunk_set (zchunk_t *self, const void *data, size_t size);\n\n// Fill chunk data from user-supplied octet\nsize_t\n    zchunk_fill (zchunk_t *self, byte filler, size_t size);\n\n// Append user-supplied data to chunk, return resulting chunk size. If the \n// data would exceeded the available space, it is truncated. If you want to\n// grow the chunk to accommodate new data, use the zchunk_extend method.   \nsize_t\n    zchunk_append (zchunk_t *self, const void *data, size_t size);\n\n// Append user-supplied data to chunk, return resulting chunk size. If the\n// data would exceeded the available space, the chunk grows in size.      \nsize_t\n    zchunk_extend (zchunk_t *self, const void *data, size_t size);\n\n// Copy as much data from 'source' into the chunk as possible; returns the  \n// new size of chunk. If all data from 'source' is used, returns exhausted  \n// on the source chunk. Source can be consumed as many times as needed until\n// it is exhausted. If source was already exhausted, does not change chunk. \nsize_t\n    zchunk_consume (zchunk_t *self, zchunk_t *source);\n\n// Returns true if the chunk was exhausted by consume methods, or if the\n// chunk has a size of zero.                                            \nbool\n    zchunk_exhausted (zchunk_t *self);\n\n// Read chunk from an open file descriptor\nzchunk_t *\n    zchunk_read (FILE *handle, size_t bytes);\n\n// Write chunk to an open file descriptor\nint\n    zchunk_write (zchunk_t *self, FILE *handle);\n\n// Try to slurp an entire file into a chunk. Will read up to maxsize of  \n// the file. If maxsize is 0, will attempt to read the entire file and   \n// fail with an assertion if that cannot fit into memory. Returns a new  \n// chunk containing the file data, or NULL if the file could not be read.\nzchunk_t *\n    zchunk_slurp (const char *filename, size_t maxsize);\n\n// Create copy of chunk, as new chunk object. Returns a fresh zchunk_t   \n// object, or null if there was not enough heap memory. If chunk is null,\n// returns null.                                                         \nzchunk_t *\n    zchunk_dup (zchunk_t *self);\n\n// Return chunk data encoded as printable hex string. Caller must free\n// string when finished with it.                                      \nchar *\n    zchunk_strhex (zchunk_t *self);\n\n// Return chunk data copied into freshly allocated string\n// Caller must free string when finished with it.        \nchar *\n    zchunk_strdup (zchunk_t *self);\n\n// Return TRUE if chunk body is equal to string, excluding terminator\nbool\n    zchunk_streq (zchunk_t *self, const char *string);\n\n// Transform zchunk into a zframe that can be sent in a message.\nzframe_t *\n    zchunk_pack (zchunk_t *self);\n\n// Transform a zframe into a zchunk.\nzchunk_t *\n    zchunk_unpack (zframe_t *frame);\n\n// Calculate SHA1 digest for chunk, using zdigest class.\nconst char *\n    zchunk_digest (zchunk_t *self);\n\n// Dump chunk to FILE stream, for debugging and tracing.\nvoid\n    zchunk_fprint (zchunk_t *self, FILE *file);\n\n// Dump message to stderr, for debugging and tracing.\n// See zchunk_fprint for details                     \nvoid\n    zchunk_print (zchunk_t *self);\n\n// Probe the supplied object, and report if it looks like a zchunk_t.\nbool\n    zchunk_is (void *self);\n\n// Self test of this class.\nvoid\n    zchunk_test (bool verbose);\n\n// CLASS: zclock\n// Sleep for a number of milliseconds\nvoid\n    zclock_sleep (int msecs);\n\n// Return current system clock as milliseconds. Note that this clock can  \n// jump backwards (if the system clock is changed) so is unsafe to use for\n// timers and time offsets. Use zclock_mono for that instead.             \nint64_t\n    zclock_time (void);\n\n// Return current monotonic clock in milliseconds. Use this when you compute\n// time offsets. The monotonic clock is not affected by system changes and  \n// so will never be reset backwards, unlike a system clock.                 \nint64_t\n    zclock_mono (void);\n\n// Return current monotonic clock in microseconds. Use this when you compute\n// time offsets. The monotonic clock is not affected by system changes and  \n// so will never be reset backwards, unlike a system clock.                 \nint64_t\n    zclock_usecs (void);\n\n// Return formatted date/time as fresh string. Free using zstr_free().\nchar *\n    zclock_timestr (void);\n\n// Self test of this class.\nvoid\n    zclock_test (bool verbose);\n\n// CLASS: zconfig\n// Create new config item\nzconfig_t *\n    zconfig_new (const char *name, zconfig_t *parent);\n\n// Destroy a config item and all its children\nvoid\n    zconfig_destroy (zconfig_t **self_p);\n\n// Load a config tree from a specified ZPL text file; returns a zconfig_t  \n// reference for the root, if the file exists and is readable. Returns NULL\n// if the file does not exist.                                             \nzconfig_t *\n    zconfig_load (const char *filename);\n\n// Equivalent to zconfig_load, taking a format string instead of a fixed\n// filename.                                                            \nzconfig_t *\n    zconfig_loadf (const char *format, ...);\n\n// Return name of config item\nchar *\n    zconfig_name (zconfig_t *self);\n\n// Return value of config item\nchar *\n    zconfig_value (zconfig_t *self);\n\n// Insert or update configuration key with value\nvoid\n    zconfig_put (zconfig_t *self, const char *path, const char *value);\n\n// Equivalent to zconfig_put, accepting a format specifier and variable\n// argument list, instead of a single string value.                    \nvoid\n    zconfig_putf (zconfig_t *self, const char *path, const char *format, ...);\n\n// Get value for config item into a string value; leading slash is optional\n// and ignored.                                                            \nchar *\n    zconfig_get (zconfig_t *self, const char *path, const char *default_value);\n\n// Set config item name, name may be NULL\nvoid\n    zconfig_set_name (zconfig_t *self, const char *name);\n\n// Set new value for config item. The new value may be a string, a printf  \n// format, or NULL. Note that if string may possibly contain '%', or if it \n// comes from an insecure source, you must use '%s' as the format, followed\n// by the string.                                                          \nvoid\n    zconfig_set_value (zconfig_t *self, const char *format, ...);\n\n// Find our first child, if any\nzconfig_t *\n    zconfig_child (zconfig_t *self);\n\n// Find our first sibling, if any\nzconfig_t *\n    zconfig_next (zconfig_t *self);\n\n// Find a config item along a path; leading slash is optional and ignored.\nzconfig_t *\n    zconfig_locate (zconfig_t *self, const char *path);\n\n// Locate the last config item at a specified depth\nzconfig_t *\n    zconfig_at_depth (zconfig_t *self, int level);\n\n// Execute a callback for each config item in the tree; returns zero if\n// successful, else -1.                                                \nint\n    zconfig_execute (zconfig_t *self, zconfig_fct handler, void *arg);\n\n// Add comment to config item before saving to disk. You can add as many\n// comment lines as you like. If you use a null format, all comments are\n// deleted.                                                             \nvoid\n    zconfig_set_comment (zconfig_t *self, const char *format, ...);\n\n// Return comments of config item, as zlist.\nzlist_t *\n    zconfig_comments (zconfig_t *self);\n\n// Save a config tree to a specified ZPL text file, where a filename\n// \"-\" means dump to standard output.                               \nint\n    zconfig_save (zconfig_t *self, const char *filename);\n\n// Equivalent to zconfig_save, taking a format string instead of a fixed\n// filename.                                                            \nint\n    zconfig_savef (zconfig_t *self, const char *format, ...);\n\n// Report filename used during zconfig_load, or NULL if none\nconst char *\n    zconfig_filename (zconfig_t *self);\n\n// Reload config tree from same file that it was previously loaded from.\n// Returns 0 if OK, -1 if there was an error (and then does not change  \n// existing data).                                                      \nint\n    zconfig_reload (zconfig_t **self_p);\n\n// Load a config tree from a memory chunk\nzconfig_t *\n    zconfig_chunk_load (zchunk_t *chunk);\n\n// Save a config tree to a new memory chunk\nzchunk_t *\n    zconfig_chunk_save (zconfig_t *self);\n\n// Load a config tree from a null-terminated string\nzconfig_t *\n    zconfig_str_load (const char *string);\n\n// Save a config tree to a new null terminated string\nchar *\n    zconfig_str_save (zconfig_t *self);\n\n// Return true if a configuration tree was loaded from a file and that\n// file has changed in since the tree was loaded.                     \nbool\n    zconfig_has_changed (zconfig_t *self);\n\n// Print the config file to open stream\nvoid\n    zconfig_fprint (zconfig_t *self, FILE *file);\n\n// Print properties of object\nvoid\n    zconfig_print (zconfig_t *self);\n\n// Self test of this class\nvoid\n    zconfig_test (bool verbose);\n\n// CLASS: zdigest\n// Constructor - creates new digest object, which you use to build up a\n// digest by repeatedly calling zdigest_update() on chunks of data.    \nzdigest_t *\n    zdigest_new (void);\n\n// Destroy a digest object\nvoid\n    zdigest_destroy (zdigest_t **self_p);\n\n// Add buffer into digest calculation\nvoid\n    zdigest_update (zdigest_t *self, const byte *buffer, size_t length);\n\n// Return final digest hash data. If built without crypto support,\n// returns NULL.                                                  \nconst byte *\n    zdigest_data (zdigest_t *self);\n\n// Return final digest hash size\nsize_t\n    zdigest_size (zdigest_t *self);\n\n// Return digest as printable hex string; caller should not modify nor   \n// free this string. After calling this, you may not use zdigest_update()\n// on the same digest. If built without crypto support, returns NULL.    \nchar *\n    zdigest_string (zdigest_t *self);\n\n// Self test of this class.\nvoid\n    zdigest_test (bool verbose);\n\n// CLASS: zdir\n// Create a new directory item that loads in the full tree of the specified\n// path, optionally located under some parent path. If parent is \"-\", then \n// loads only the top-level directory, and does not use parent as a path.  \nzdir_t *\n    zdir_new (const char *path, const char *parent);\n\n// Destroy a directory tree and all children it contains.\nvoid\n    zdir_destroy (zdir_t **self_p);\n\n// Return directory path\nconst char *\n    zdir_path (zdir_t *self);\n\n// Return last modification time for directory.\ntime_t\n    zdir_modified (zdir_t *self);\n\n// Return total hierarchy size, in bytes of data contained in all files\n// in the directory tree.                                              \noff_t\n    zdir_cursize (zdir_t *self);\n\n// Return directory count\nsize_t\n    zdir_count (zdir_t *self);\n\n// Returns a sorted list of zfile objects; Each entry in the list is a pointer\n// to a zfile_t item already allocated in the zdir tree. Do not destroy the   \n// original zdir tree until you are done with this list.                      \nzlist_t *\n    zdir_list (zdir_t *self);\n\n// Remove directory, optionally including all files that it contains, at  \n// all levels. If force is false, will only remove the directory if empty.\n// If force is true, will remove all files and all subdirectories.        \nvoid\n    zdir_remove (zdir_t *self, bool force);\n\n// Calculate differences between two versions of a directory tree.    \n// Returns a list of zdir_patch_t patches. Either older or newer may  \n// be null, indicating the directory is empty/absent. If alias is set,\n// generates virtual filename (minus path, plus alias).               \nzlist_t *\n    zdir_diff (zdir_t *older, zdir_t *newer, const char *alias);\n\n// Return full contents of directory as a zdir_patch list.\nzlist_t *\n    zdir_resync (zdir_t *self, const char *alias);\n\n// Load directory cache; returns a hash table containing the SHA-1 digests\n// of every file in the tree. The cache is saved between runs in .cache.  \nzhash_t *\n    zdir_cache (zdir_t *self);\n\n// Print contents of directory to open stream\nvoid\n    zdir_fprint (zdir_t *self, FILE *file, int indent);\n\n// Print contents of directory to stdout\nvoid\n    zdir_print (zdir_t *self, int indent);\n\n// Create a new zdir_watch actor instance:                       \n//                                                               \n//     zactor_t *watch = zactor_new (zdir_watch, NULL);          \n//                                                               \n// Destroy zdir_watch instance:                                  \n//                                                               \n//     zactor_destroy (&watch);                                  \n//                                                               \n// Enable verbose logging of commands and activity:              \n//                                                               \n//     zstr_send (watch, \"VERBOSE\");                             \n//                                                               \n// Subscribe to changes to a directory path:                     \n//                                                               \n//     zsock_send (watch, \"ss\", \"SUBSCRIBE\", \"directory_path\");  \n//                                                               \n// Unsubscribe from changes to a directory path:                 \n//                                                               \n//     zsock_send (watch, \"ss\", \"UNSUBSCRIBE\", \"directory_path\");\n//                                                               \n// Receive directory changes:                                    \n//     zsock_recv (watch, \"sp\", &path, &patches);                \n//                                                               \n//     // Delete the received data.                              \n//     free (path);                                              \n//     zlist_destroy (&patches);                                 \nvoid\n    zdir_watch (zsock_t *pipe, void *unused);\n\n// Self test of this class.\nvoid\n    zdir_test (bool verbose);\n\n// CLASS: zdir_patch\n// Create new patch\nzdir_patch_t *\n    zdir_patch_new (const char *path, zfile_t *file, int op, const char *alias);\n\n// Destroy a patch\nvoid\n    zdir_patch_destroy (zdir_patch_t **self_p);\n\n// Create copy of a patch. If the patch is null, or memory was exhausted,\n// returns null.                                                         \nzdir_patch_t *\n    zdir_patch_dup (zdir_patch_t *self);\n\n// Return patch file directory path\nconst char *\n    zdir_patch_path (zdir_patch_t *self);\n\n// Return patch file item\nzfile_t *\n    zdir_patch_file (zdir_patch_t *self);\n\n// Return operation\nint\n    zdir_patch_op (zdir_patch_t *self);\n\n// Return patch virtual file path\nconst char *\n    zdir_patch_vpath (zdir_patch_t *self);\n\n// Calculate hash digest for file (create only)\nvoid\n    zdir_patch_digest_set (zdir_patch_t *self);\n\n// Return hash digest for patch file\nconst char *\n    zdir_patch_digest (zdir_patch_t *self);\n\n// Self test of this class.\nvoid\n    zdir_patch_test (bool verbose);\n\n// CLASS: zfile\n// If file exists, populates properties. CZMQ supports portable symbolic\n// links, which are files with the extension \".ln\". A symbolic link is a\n// text file containing one line, the filename of a target file. Reading\n// data from the symbolic link actually reads from the target file. Path\n// may be NULL, in which case it is not used.                           \nzfile_t *\n    zfile_new (const char *path, const char *name);\n\n// Destroy a file item\nvoid\n    zfile_destroy (zfile_t **self_p);\n\n// Duplicate a file item, returns a newly constructed item. If the file\n// is null, or memory was exhausted, returns null.                     \nzfile_t *\n    zfile_dup (zfile_t *self);\n\n// Return file name, remove path if provided\nconst char *\n    zfile_filename (zfile_t *self, const char *path);\n\n// Refresh file properties from disk; this is not done automatically   \n// on access methods, otherwise it is not possible to compare directory\n// snapshots.                                                          \nvoid\n    zfile_restat (zfile_t *self);\n\n// Return when the file was last modified. If you want this to reflect the\n// current situation, call zfile_restat before checking this property.    \ntime_t\n    zfile_modified (zfile_t *self);\n\n// Return the last-known size of the file. If you want this to reflect the\n// current situation, call zfile_restat before checking this property.    \noff_t\n    zfile_cursize (zfile_t *self);\n\n// Return true if the file is a directory. If you want this to reflect   \n// any external changes, call zfile_restat before checking this property.\nbool\n    zfile_is_directory (zfile_t *self);\n\n// Return true if the file is a regular file. If you want this to reflect\n// any external changes, call zfile_restat before checking this property.\nbool\n    zfile_is_regular (zfile_t *self);\n\n// Return true if the file is readable by this process. If you want this to\n// reflect any external changes, call zfile_restat before checking this    \n// property.                                                               \nbool\n    zfile_is_readable (zfile_t *self);\n\n// Return true if the file is writeable by this process. If you want this \n// to reflect any external changes, call zfile_restat before checking this\n// property.                                                              \nbool\n    zfile_is_writeable (zfile_t *self);\n\n// Check if file has stopped changing and can be safely processed.\n// Updates the file statistics from disk at every call.           \nbool\n    zfile_is_stable (zfile_t *self);\n\n// Return true if the file was changed on disk since the zfile_t object\n// was created, or the last zfile_restat() call made on it.            \nbool\n    zfile_has_changed (zfile_t *self);\n\n// Remove the file from disk\nvoid\n    zfile_remove (zfile_t *self);\n\n// Open file for reading                             \n// Returns 0 if OK, -1 if not found or not accessible\nint\n    zfile_input (zfile_t *self);\n\n// Open file for writing, creating directory if needed               \n// File is created if necessary; chunks can be written to file at any\n// location. Returns 0 if OK, -1 if error.                           \nint\n    zfile_output (zfile_t *self);\n\n// Read chunk from file at specified position. If this was the last chunk,\n// sets the eof property. Returns a null chunk in case of error.          \nzchunk_t *\n    zfile_read (zfile_t *self, size_t bytes, off_t offset);\n\n// Returns true if zfile_read() just read the last chunk in the file.\nbool\n    zfile_eof (zfile_t *self);\n\n// Write chunk to file at specified position\n// Return 0 if OK, else -1                  \nint\n    zfile_write (zfile_t *self, zchunk_t *chunk, off_t offset);\n\n// Read next line of text from file. Returns a pointer to the text line,\n// or NULL if there was nothing more to read from the file.             \nconst char *\n    zfile_readln (zfile_t *self);\n\n// Close file, if open\nvoid\n    zfile_close (zfile_t *self);\n\n// Return file handle, if opened\nFILE *\n    zfile_handle (zfile_t *self);\n\n// Calculate SHA1 digest for file, using zdigest class.\nconst char *\n    zfile_digest (zfile_t *self);\n\n// Self test of this class.\nvoid\n    zfile_test (bool verbose);\n\n// CLASS: zframe\n// Create a new frame. If size is not null, allocates the frame data\n// to the specified size. If additionally, data is not null, copies \n// size octets from the specified data into the frame body.         \nzframe_t *\n    zframe_new (const void *data, size_t size);\n\n// Destroy a frame\nvoid\n    zframe_destroy (zframe_t **self_p);\n\n// Create an empty (zero-sized) frame\nzframe_t *\n    zframe_new_empty (void);\n\n// Create a frame with a specified string content.\nzframe_t *\n    zframe_from (const char *string);\n\n// Receive frame from socket, returns zframe_t object or NULL if the recv  \n// was interrupted. Does a blocking recv, if you want to not block then use\n// zpoller or zloop.                                                       \nzframe_t *\n    zframe_recv (void *source);\n\n// Send a frame to a socket, destroy frame after sending.\n// Return -1 on error, 0 on success.                     \nint\n    zframe_send (zframe_t **self_p, void *dest, int flags);\n\n// Return number of bytes in frame data\nsize_t\n    zframe_size (zframe_t *self);\n\n// Return address of frame data\nbyte *\n    zframe_data (zframe_t *self);\n\n// Return meta data property for frame           \n// Caller must free string when finished with it.\nconst char *\n    zframe_meta (zframe_t *self, const char *property);\n\n// Create a new frame that duplicates an existing frame. If frame is null,\n// or memory was exhausted, returns null.                                 \nzframe_t *\n    zframe_dup (zframe_t *self);\n\n// Return frame data encoded as printable hex string, useful for 0MQ UUIDs.\n// Caller must free string when finished with it.                          \nchar *\n    zframe_strhex (zframe_t *self);\n\n// Return frame data copied into freshly allocated string\n// Caller must free string when finished with it.        \nchar *\n    zframe_strdup (zframe_t *self);\n\n// Return TRUE if frame body is equal to string, excluding terminator\nbool\n    zframe_streq (zframe_t *self, const char *string);\n\n// Return frame MORE indicator (1 or 0), set when reading frame from socket\n// or by the zframe_set_more() method                                      \nint\n    zframe_more (zframe_t *self);\n\n// Set frame MORE indicator (1 or 0). Note this is NOT used when sending\n// frame to socket, you have to specify flag explicitly.                \nvoid\n    zframe_set_more (zframe_t *self, int more);\n\n// Return frame routing ID, if the frame came from a ZMQ_SERVER socket.\n// Else returns zero.                                                  \nuint32_t\n    zframe_routing_id (zframe_t *self);\n\n// Set routing ID on frame. This is used if/when the frame is sent to a\n// ZMQ_SERVER socket.                                                  \nvoid\n    zframe_set_routing_id (zframe_t *self, uint32_t routing_id);\n\n// Return frame group of radio-dish pattern.\nconst char *\n    zframe_group (zframe_t *self);\n\n// Set group on frame. This is used if/when the frame is sent to a\n// ZMQ_RADIO socket.                                              \n// Return -1 on error, 0 on success.                              \nint\n    zframe_set_group (zframe_t *self, const char *group);\n\n// Return TRUE if two frames have identical size and data\n// If either frame is NULL, equality is always false.    \nbool\n    zframe_eq (zframe_t *self, zframe_t *other);\n\n// Set new contents for frame\nvoid\n    zframe_reset (zframe_t *self, const void *data, size_t size);\n\n// Send message to zsys log sink (may be stdout, or system facility as       \n// configured by zsys_set_logstream). Prefix shows before frame, if not null.\nvoid\n    zframe_print (zframe_t *self, const char *prefix);\n\n// Probe the supplied object, and report if it looks like a zframe_t.\nbool\n    zframe_is (void *self);\n\n// Self test of this class.\nvoid\n    zframe_test (bool verbose);\n\n// CLASS: zhash\n// Create a new, empty hash container\nzhash_t *\n    zhash_new (void);\n\n// Destroy a hash container and all items in it\nvoid\n    zhash_destroy (zhash_t **self_p);\n\n// Unpack binary frame into a new hash table. Packed data must follow format\n// defined by zhash_pack. Hash table is set to autofree. An empty frame     \n// unpacks to an empty hash table.                                          \nzhash_t *\n    zhash_unpack (zframe_t *frame);\n\n// Insert item into hash table with specified key and item.               \n// If key is already present returns -1 and leaves existing item unchanged\n// Returns 0 on success.                                                  \nint\n    zhash_insert (zhash_t *self, const char *key, void *item);\n\n// Update item into hash table with specified key and item.            \n// If key is already present, destroys old item and inserts new one.   \n// Use free_fn method to ensure deallocator is properly called on item.\nvoid\n    zhash_update (zhash_t *self, const char *key, void *item);\n\n// Remove an item specified by key from the hash table. If there was no such\n// item, this function does nothing.                                        \nvoid\n    zhash_delete (zhash_t *self, const char *key);\n\n// Return the item at the specified key, or null\nvoid *\n    zhash_lookup (zhash_t *self, const char *key);\n\n// Reindexes an item from an old key to a new key. If there was no such\n// item, does nothing. Returns 0 if successful, else -1.               \nint\n    zhash_rename (zhash_t *self, const char *old_key, const char *new_key);\n\n// Set a free function for the specified hash table item. When the item is\n// destroyed, the free function, if any, is called on that item.          \n// Use this when hash items are dynamically allocated, to ensure that     \n// you don't have memory leaks. You can pass 'free' or NULL as a free_fn. \n// Returns the item, or NULL if there is no such item.                    \nvoid *\n    zhash_freefn (zhash_t *self, const char *key, zhash_free_fn free_fn);\n\n// Return the number of keys/items in the hash table\nsize_t\n    zhash_size (zhash_t *self);\n\n// Make copy of hash table; if supplied table is null, returns null.    \n// Does not copy items themselves. Rebuilds new table so may be slow on \n// very large tables. NOTE: only works with item values that are strings\n// since there's no other way to know how to duplicate the item value.  \nzhash_t *\n    zhash_dup (zhash_t *self);\n\n// Return keys for items in table\nzlist_t *\n    zhash_keys (zhash_t *self);\n\n// Simple iterator; returns first item in hash table, in no given order, \n// or NULL if the table is empty. This method is simpler to use than the \n// foreach() method, which is deprecated. To access the key for this item\n// use zhash_cursor(). NOTE: do NOT modify the table while iterating.    \nvoid *\n    zhash_first (zhash_t *self);\n\n// Simple iterator; returns next item in hash table, in no given order, \n// or NULL if the last item was already returned. Use this together with\n// zhash_first() to process all items in a hash table. If you need the  \n// items in sorted order, use zhash_keys() and then zlist_sort(). To    \n// access the key for this item use zhash_cursor(). NOTE: do NOT modify \n// the table while iterating.                                           \nvoid *\n    zhash_next (zhash_t *self);\n\n// After a successful first/next method, returns the key for the item that\n// was returned. This is a constant string that you may not modify or     \n// deallocate, and which lasts as long as the item in the hash. After an  \n// unsuccessful first/next, returns NULL.                                 \nconst char *\n    zhash_cursor (zhash_t *self);\n\n// Add a comment to hash table before saving to disk. You can add as many   \n// comment lines as you like. These comment lines are discarded when loading\n// the file. If you use a null format, all comments are deleted.            \nvoid\n    zhash_comment (zhash_t *self, const char *format, ...);\n\n// Serialize hash table to a binary frame that can be sent in a message.\n// The packed format is compatible with the 'dictionary' type defined in\n// http://rfc.zeromq.org/spec:35/FILEMQ, and implemented by zproto:     \n//                                                                      \n//    ; A list of name/value pairs                                      \n//    dictionary      = dict-count *( dict-name dict-value )            \n//    dict-count      = number-4                                        \n//    dict-value      = longstr                                         \n//    dict-name       = string                                          \n//                                                                      \n//    ; Strings are always length + text contents                       \n//    longstr         = number-4 *VCHAR                                 \n//    string          = number-1 *VCHAR                                 \n//                                                                      \n//    ; Numbers are unsigned integers in network byte order             \n//    number-1        = 1OCTET                                          \n//    number-4        = 4OCTET                                          \n//                                                                      \n// Comments are not included in the packed data. Item values MUST be    \n// strings.                                                             \nzframe_t *\n    zhash_pack (zhash_t *self);\n\n// Save hash table to a text file in name=value format. Hash values must be\n// printable strings; keys may not contain '=' character. Returns 0 if OK, \n// else -1 if a file error occurred.                                       \nint\n    zhash_save (zhash_t *self, const char *filename);\n\n// Load hash table from a text file in name=value format; hash table must \n// already exist. Hash values must printable strings; keys may not contain\n// '=' character. Returns 0 if OK, else -1 if a file was not readable.    \nint\n    zhash_load (zhash_t *self, const char *filename);\n\n// When a hash table was loaded from a file by zhash_load, this method will\n// reload the file if it has been modified since, and is \"stable\", i.e. not\n// still changing. Returns 0 if OK, -1 if there was an error reloading the \n// file.                                                                   \nint\n    zhash_refresh (zhash_t *self);\n\n// Set hash for automatic value destruction\nvoid\n    zhash_autofree (zhash_t *self);\n\n// Self test of this class.\nvoid\n    zhash_test (bool verbose);\n\n// CLASS: zhashx\n// Create a new, empty hash container\nzhashx_t *\n    zhashx_new (void);\n\n// Destroy a hash container and all items in it\nvoid\n    zhashx_destroy (zhashx_t **self_p);\n\n// Unpack binary frame into a new hash table. Packed data must follow format\n// defined by zhashx_pack. Hash table is set to autofree. An empty frame    \n// unpacks to an empty hash table.                                          \nzhashx_t *\n    zhashx_unpack (zframe_t *frame);\n\n// Same as unpack but uses a user-defined deserializer function to convert\n// a longstr back into item format.                                       \nzhashx_t *\n    zhashx_unpack_own (zframe_t *frame, zhashx_deserializer_fn deserializer);\n\n// Insert item into hash table with specified key and item.               \n// If key is already present returns -1 and leaves existing item unchanged\n// Returns 0 on success.                                                  \nint\n    zhashx_insert (zhashx_t *self, const void *key, void *item);\n\n// Update or insert item into hash table with specified key and item. If the\n// key is already present, destroys old item and inserts new one. If you set\n// a container item destructor, this is called on the old value. If the key \n// was not already present, inserts a new item. Sets the hash cursor to the \n// new item.                                                                \nvoid\n    zhashx_update (zhashx_t *self, const void *key, void *item);\n\n// Remove an item specified by key from the hash table. If there was no such\n// item, this function does nothing.                                        \nvoid\n    zhashx_delete (zhashx_t *self, const void *key);\n\n// Delete all items from the hash table. If the key destructor is  \n// set, calls it on every key. If the item destructor is set, calls\n// it on every item.                                               \nvoid\n    zhashx_purge (zhashx_t *self);\n\n// Return the item at the specified key, or null\nvoid *\n    zhashx_lookup (zhashx_t *self, const void *key);\n\n// Reindexes an item from an old key to a new key. If there was no such\n// item, does nothing. Returns 0 if successful, else -1.               \nint\n    zhashx_rename (zhashx_t *self, const void *old_key, const void *new_key);\n\n// Set a free function for the specified hash table item. When the item is\n// destroyed, the free function, if any, is called on that item.          \n// Use this when hash items are dynamically allocated, to ensure that     \n// you don't have memory leaks. You can pass 'free' or NULL as a free_fn. \n// Returns the item, or NULL if there is no such item.                    \nvoid *\n    zhashx_freefn (zhashx_t *self, const void *key, zhashx_free_fn free_fn);\n\n// Return the number of keys/items in the hash table\nsize_t\n    zhashx_size (zhashx_t *self);\n\n// Return a zlistx_t containing the keys for the items in the       \n// table. Uses the key_duplicator to duplicate all keys and sets the\n// key_destructor as destructor for the list.                       \nzlistx_t *\n    zhashx_keys (zhashx_t *self);\n\n// Return a zlistx_t containing the values for the items in the  \n// table. Uses the duplicator to duplicate all items and sets the\n// destructor as destructor for the list.                        \nzlistx_t *\n    zhashx_values (zhashx_t *self);\n\n// Simple iterator; returns first item in hash table, in no given order, \n// or NULL if the table is empty. This method is simpler to use than the \n// foreach() method, which is deprecated. To access the key for this item\n// use zhashx_cursor(). NOTE: do NOT modify the table while iterating.   \nvoid *\n    zhashx_first (zhashx_t *self);\n\n// Simple iterator; returns next item in hash table, in no given order, \n// or NULL if the last item was already returned. Use this together with\n// zhashx_first() to process all items in a hash table. If you need the \n// items in sorted order, use zhashx_keys() and then zlistx_sort(). To  \n// access the key for this item use zhashx_cursor(). NOTE: do NOT modify\n// the table while iterating.                                           \nvoid *\n    zhashx_next (zhashx_t *self);\n\n// After a successful first/next method, returns the key for the item that\n// was returned. This is a constant string that you may not modify or     \n// deallocate, and which lasts as long as the item in the hash. After an  \n// unsuccessful first/next, returns NULL.                                 \nconst void *\n    zhashx_cursor (zhashx_t *self);\n\n// Add a comment to hash table before saving to disk. You can add as many   \n// comment lines as you like. These comment lines are discarded when loading\n// the file. If you use a null format, all comments are deleted.            \nvoid\n    zhashx_comment (zhashx_t *self, const char *format, ...);\n\n// Save hash table to a text file in name=value format. Hash values must be\n// printable strings; keys may not contain '=' character. Returns 0 if OK, \n// else -1 if a file error occurred.                                       \nint\n    zhashx_save (zhashx_t *self, const char *filename);\n\n// Load hash table from a text file in name=value format; hash table must \n// already exist. Hash values must printable strings; keys may not contain\n// '=' character. Returns 0 if OK, else -1 if a file was not readable.    \nint\n    zhashx_load (zhashx_t *self, const char *filename);\n\n// When a hash table was loaded from a file by zhashx_load, this method will\n// reload the file if it has been modified since, and is \"stable\", i.e. not \n// still changing. Returns 0 if OK, -1 if there was an error reloading the  \n// file.                                                                    \nint\n    zhashx_refresh (zhashx_t *self);\n\n// Serialize hash table to a binary frame that can be sent in a message.\n// The packed format is compatible with the 'dictionary' type defined in\n// http://rfc.zeromq.org/spec:35/FILEMQ, and implemented by zproto:     \n//                                                                      \n//    ; A list of name/value pairs                                      \n//    dictionary      = dict-count *( dict-name dict-value )            \n//    dict-count      = number-4                                        \n//    dict-value      = longstr                                         \n//    dict-name       = string                                          \n//                                                                      \n//    ; Strings are always length + text contents                       \n//    longstr         = number-4 *VCHAR                                 \n//    string          = number-1 *VCHAR                                 \n//                                                                      \n//    ; Numbers are unsigned integers in network byte order             \n//    number-1        = 1OCTET                                          \n//    number-4        = 4OCTET                                          \n//                                                                      \n// Comments are not included in the packed data. Item values MUST be    \n// strings.                                                             \nzframe_t *\n    zhashx_pack (zhashx_t *self);\n\n// Same as pack but uses a user-defined serializer function to convert items\n// into longstr.                                                            \nzframe_t *\n    zhashx_pack_own (zhashx_t *self, zhashx_serializer_fn serializer);\n\n// Make a copy of the list; items are duplicated if you set a duplicator \n// for the list, otherwise not. Copying a null reference returns a null  \n// reference. Note that this method's behavior changed slightly for CZMQ \n// v3.x, as it does not set nor respect autofree. It does however let you\n// duplicate any hash table safely. The old behavior is in zhashx_dup_v2.\nzhashx_t *\n    zhashx_dup (zhashx_t *self);\n\n// Set a user-defined deallocator for hash items; by default items are not\n// freed when the hash is destroyed.                                      \nvoid\n    zhashx_set_destructor (zhashx_t *self, zhashx_destructor_fn destructor);\n\n// Set a user-defined duplicator for hash items; by default items are not\n// copied when the hash is duplicated.                                   \nvoid\n    zhashx_set_duplicator (zhashx_t *self, zhashx_duplicator_fn duplicator);\n\n// Set a user-defined deallocator for keys; by default keys are freed\n// when the hash is destroyed using free().                          \nvoid\n    zhashx_set_key_destructor (zhashx_t *self, zhashx_destructor_fn destructor);\n\n// Set a user-defined duplicator for keys; by default keys are duplicated\n// using strdup.                                                         \nvoid\n    zhashx_set_key_duplicator (zhashx_t *self, zhashx_duplicator_fn duplicator);\n\n// Set a user-defined comparator for keys; by default keys are\n// compared using strcmp.                                     \nvoid\n    zhashx_set_key_comparator (zhashx_t *self, zhashx_comparator_fn comparator);\n\n// Set a user-defined comparator for keys; by default keys are\n// compared using strcmp.                                     \nvoid\n    zhashx_set_key_hasher (zhashx_t *self, zhashx_hash_fn hasher);\n\n// Make copy of hash table; if supplied table is null, returns null.    \n// Does not copy items themselves. Rebuilds new table so may be slow on \n// very large tables. NOTE: only works with item values that are strings\n// since there's no other way to know how to duplicate the item value.  \nzhashx_t *\n    zhashx_dup_v2 (zhashx_t *self);\n\n// Self test of this class.\nvoid\n    zhashx_test (bool verbose);\n\n// CLASS: ziflist\n// Get a list of network interfaces currently defined on the system\nziflist_t *\n    ziflist_new (void);\n\n// Destroy a ziflist instance\nvoid\n    ziflist_destroy (ziflist_t **self_p);\n\n// Reload network interfaces from system\nvoid\n    ziflist_reload (ziflist_t *self);\n\n// Return the number of network interfaces on system\nsize_t\n    ziflist_size (ziflist_t *self);\n\n// Get first network interface, return NULL if there are none\nconst char *\n    ziflist_first (ziflist_t *self);\n\n// Get next network interface, return NULL if we hit the last one\nconst char *\n    ziflist_next (ziflist_t *self);\n\n// Return the current interface IP address as a printable string\nconst char *\n    ziflist_address (ziflist_t *self);\n\n// Return the current interface broadcast address as a printable string\nconst char *\n    ziflist_broadcast (ziflist_t *self);\n\n// Return the current interface network mask as a printable string\nconst char *\n    ziflist_netmask (ziflist_t *self);\n\n// Return the list of interfaces.\nvoid\n    ziflist_print (ziflist_t *self);\n\n// Self test of this class.\nvoid\n    ziflist_test (bool verbose);\n\n// CLASS: zlist\n// Create a new list container\nzlist_t *\n    zlist_new (void);\n\n// Destroy a list container\nvoid\n    zlist_destroy (zlist_t **self_p);\n\n// Return the item at the head of list. If the list is empty, returns NULL.\n// Leaves cursor pointing at the head item, or NULL if the list is empty.  \nvoid *\n    zlist_first (zlist_t *self);\n\n// Return the next item. If the list is empty, returns NULL. To move to\n// the start of the list call zlist_first (). Advances the cursor.     \nvoid *\n    zlist_next (zlist_t *self);\n\n// Return the item at the tail of list. If the list is empty, returns NULL.\n// Leaves cursor pointing at the tail item, or NULL if the list is empty.  \nvoid *\n    zlist_last (zlist_t *self);\n\n// Return first item in the list, or null, leaves the cursor\nvoid *\n    zlist_head (zlist_t *self);\n\n// Return last item in the list, or null, leaves the cursor\nvoid *\n    zlist_tail (zlist_t *self);\n\n// Return the current item of list. If the list is empty, returns NULL.     \n// Leaves cursor pointing at the current item, or NULL if the list is empty.\nvoid *\n    zlist_item (zlist_t *self);\n\n// Append an item to the end of the list, return 0 if OK or -1 if this  \n// failed for some reason (out of memory). Note that if a duplicator has\n// been set, this method will also duplicate the item.                  \nint\n    zlist_append (zlist_t *self, void *item);\n\n// Push an item to the start of the list, return 0 if OK or -1 if this  \n// failed for some reason (out of memory). Note that if a duplicator has\n// been set, this method will also duplicate the item.                  \nint\n    zlist_push (zlist_t *self, void *item);\n\n// Pop the item off the start of the list, if any\nvoid *\n    zlist_pop (zlist_t *self);\n\n// Checks if an item already is present. Uses compare method to determine if \n// items are equal. If the compare method is NULL the check will only compare\n// pointers. Returns true if item is present else false.                     \nbool\n    zlist_exists (zlist_t *self, void *item);\n\n// Remove the specified item from the list if present\nvoid\n    zlist_remove (zlist_t *self, void *item);\n\n// Make a copy of list. If the list has autofree set, the copied list will  \n// duplicate all items, which must be strings. Otherwise, the list will hold\n// pointers back to the items in the original list. If list is null, returns\n// NULL.                                                                    \nzlist_t *\n    zlist_dup (zlist_t *self);\n\n// Purge all items from list\nvoid\n    zlist_purge (zlist_t *self);\n\n// Return number of items in the list\nsize_t\n    zlist_size (zlist_t *self);\n\n// Sort the list. If the compare function is null, sorts the list by     \n// ascending key value using a straight ASCII comparison. If you specify \n// a compare function, this decides how items are sorted. The sort is not\n// stable, so may reorder items with the same keys. The algorithm used is\n// combsort, a compromise between performance and simplicity.            \nvoid\n    zlist_sort (zlist_t *self, zlist_compare_fn compare);\n\n// Set list for automatic item destruction; item values MUST be strings. \n// By default a list item refers to a value held elsewhere. When you set \n// this, each time you append or push a list item, zlist will take a copy\n// of the string value. Then, when you destroy the list, it will free all\n// item values automatically. If you use any other technique to allocate \n// list values, you must free them explicitly before destroying the list.\n// The usual technique is to pop list items and destroy them, until the  \n// list is empty.                                                        \nvoid\n    zlist_autofree (zlist_t *self);\n\n// Sets a compare function for this list. The function compares two items.\n// It returns an integer less than, equal to, or greater than zero if the \n// first item is found, respectively, to be less than, to match, or be    \n// greater than the second item.                                          \n// This function is used for sorting, removal and exists checking.        \nvoid\n    zlist_comparefn (zlist_t *self, zlist_compare_fn fn);\n\n// Set a free function for the specified list item. When the item is     \n// destroyed, the free function, if any, is called on that item.         \n// Use this when list items are dynamically allocated, to ensure that    \n// you don't have memory leaks. You can pass 'free' or NULL as a free_fn.\n// Returns the item, or NULL if there is no such item.                   \nvoid *\n    zlist_freefn (zlist_t *self, void *item, zlist_free_fn fn, bool at_tail);\n\n// Self test of this class.\nvoid\n    zlist_test (bool verbose);\n\n// CLASS: zlistx\n// Create a new, empty list.\nzlistx_t *\n    zlistx_new (void);\n\n// Destroy a list. If an item destructor was specified, all items in the\n// list are automatically destroyed as well.                            \nvoid\n    zlistx_destroy (zlistx_t **self_p);\n\n// Add an item to the head of the list. Calls the item duplicator, if any,\n// on the item. Resets cursor to list head. Returns an item handle on     \n// success, NULL if memory was exhausted.                                 \nvoid *\n    zlistx_add_start (zlistx_t *self, void *item);\n\n// Add an item to the tail of the list. Calls the item duplicator, if any,\n// on the item. Resets cursor to list head. Returns an item handle on     \n// success, NULL if memory was exhausted.                                 \nvoid *\n    zlistx_add_end (zlistx_t *self, void *item);\n\n// Return the number of items in the list\nsize_t\n    zlistx_size (zlistx_t *self);\n\n// Return first item in the list, or null, leaves the cursor\nvoid *\n    zlistx_head (zlistx_t *self);\n\n// Return last item in the list, or null, leaves the cursor\nvoid *\n    zlistx_tail (zlistx_t *self);\n\n// Return the item at the head of list. If the list is empty, returns NULL.\n// Leaves cursor pointing at the head item, or NULL if the list is empty.  \nvoid *\n    zlistx_first (zlistx_t *self);\n\n// Return the next item. At the end of the list (or in an empty list),     \n// returns NULL. Use repeated zlistx_next () calls to work through the list\n// from zlistx_first (). First time, acts as zlistx_first().               \nvoid *\n    zlistx_next (zlistx_t *self);\n\n// Return the previous item. At the start of the list (or in an empty list),\n// returns NULL. Use repeated zlistx_prev () calls to work through the list \n// backwards from zlistx_last (). First time, acts as zlistx_last().        \nvoid *\n    zlistx_prev (zlistx_t *self);\n\n// Return the item at the tail of list. If the list is empty, returns NULL.\n// Leaves cursor pointing at the tail item, or NULL if the list is empty.  \nvoid *\n    zlistx_last (zlistx_t *self);\n\n// Returns the value of the item at the cursor, or NULL if the cursor is\n// not pointing to an item.                                             \nvoid *\n    zlistx_item (zlistx_t *self);\n\n// Returns the handle of the item at the cursor, or NULL if the cursor is\n// not pointing to an item.                                              \nvoid *\n    zlistx_cursor (zlistx_t *self);\n\n// Returns the item associated with the given list handle, or NULL if passed     \n// in handle is NULL. Asserts that the passed in handle points to a list element.\nvoid *\n    zlistx_handle_item (void *handle);\n\n// Find an item in the list, searching from the start. Uses the item     \n// comparator, if any, else compares item values directly. Returns the   \n// item handle found, or NULL. Sets the cursor to the found item, if any.\nvoid *\n    zlistx_find (zlistx_t *self, void *item);\n\n// Detach an item from the list, using its handle. The item is not modified, \n// and the caller is responsible for destroying it if necessary. If handle is\n// null, detaches the first item on the list. Returns item that was detached,\n// or null if none was. If cursor was at item, moves cursor to previous item,\n// so you can detach items while iterating forwards through a list.          \nvoid *\n    zlistx_detach (zlistx_t *self, void *handle);\n\n// Detach item at the cursor, if any, from the list. The item is not modified,\n// and the caller is responsible for destroying it as necessary. Returns item \n// that was detached, or null if none was. Moves cursor to previous item, so  \n// you can detach items while iterating forwards through a list.              \nvoid *\n    zlistx_detach_cur (zlistx_t *self);\n\n// Delete an item, using its handle. Calls the item destructor is any is \n// set. If handle is null, deletes the first item on the list. Returns 0 \n// if an item was deleted, -1 if not. If cursor was at item, moves cursor\n// to previous item, so you can delete items while iterating forwards    \n// through a list.                                                       \nint\n    zlistx_delete (zlistx_t *self, void *handle);\n\n// Move an item to the start of the list, via its handle.\nvoid\n    zlistx_move_start (zlistx_t *self, void *handle);\n\n// Move an item to the end of the list, via its handle.\nvoid\n    zlistx_move_end (zlistx_t *self, void *handle);\n\n// Remove all items from the list, and destroy them if the item destructor\n// is set.                                                                \nvoid\n    zlistx_purge (zlistx_t *self);\n\n// Sort the list. If an item comparator was set, calls that to compare    \n// items, otherwise compares on item value. The sort is not stable, so may\n// reorder equal items.                                                   \nvoid\n    zlistx_sort (zlistx_t *self);\n\n// Create a new node and insert it into a sorted list. Calls the item        \n// duplicator, if any, on the item. If low_value is true, starts searching   \n// from the start of the list, otherwise searches from the end. Use the item \n// comparator, if any, to find where to place the new node. Returns a handle \n// to the new node, or NULL if memory was exhausted. Resets the cursor to the\n// list head.                                                                \nvoid *\n    zlistx_insert (zlistx_t *self, void *item, bool low_value);\n\n// Move an item, specified by handle, into position in a sorted list. Uses \n// the item comparator, if any, to determine the new location. If low_value\n// is true, starts searching from the start of the list, otherwise searches\n// from the end.                                                           \nvoid\n    zlistx_reorder (zlistx_t *self, void *handle, bool low_value);\n\n// Make a copy of the list; items are duplicated if you set a duplicator\n// for the list, otherwise not. Copying a null reference returns a null \n// reference.                                                           \nzlistx_t *\n    zlistx_dup (zlistx_t *self);\n\n// Set a user-defined deallocator for list items; by default items are not\n// freed when the list is destroyed.                                      \nvoid\n    zlistx_set_destructor (zlistx_t *self, zlistx_destructor_fn destructor);\n\n// Set a user-defined duplicator for list items; by default items are not\n// copied when the list is duplicated.                                   \nvoid\n    zlistx_set_duplicator (zlistx_t *self, zlistx_duplicator_fn duplicator);\n\n// Set a user-defined comparator for zlistx_find and zlistx_sort; the method \n// must return -1, 0, or 1 depending on whether item1 is less than, equal to,\n// or greater than, item2.                                                   \nvoid\n    zlistx_set_comparator (zlistx_t *self, zlistx_comparator_fn comparator);\n\n// Self test of this class.\nvoid\n    zlistx_test (bool verbose);\n\n// CLASS: zloop\n// Create a new zloop reactor\nzloop_t *\n    zloop_new (void);\n\n// Destroy a reactor\nvoid\n    zloop_destroy (zloop_t **self_p);\n\n// Register socket reader with the reactor. When the reader has messages, \n// the reactor will call the handler, passing the arg. Returns 0 if OK, -1\n// if there was an error. If you register the same socket more than once, \n// each instance will invoke its corresponding handler.                   \nint\n    zloop_reader (zloop_t *self, zsock_t *sock, zloop_reader_fn handler, void *arg);\n\n// Cancel a socket reader from the reactor. If multiple readers exist for\n// same socket, cancels ALL of them.                                     \nvoid\n    zloop_reader_end (zloop_t *self, zsock_t *sock);\n\n// Configure a registered reader to ignore errors. If you do not set this,\n// then readers that have errors are removed from the reactor silently.   \nvoid\n    zloop_reader_set_tolerant (zloop_t *self, zsock_t *sock);\n\n// Register low-level libzmq pollitem with the reactor. When the pollitem  \n// is ready, will call the handler, passing the arg. Returns 0 if OK, -1   \n// if there was an error. If you register the pollitem more than once, each\n// instance will invoke its corresponding handler. A pollitem with         \n// socket=NULL and fd=0 means 'poll on FD zero'.                           \nint\n    zloop_poller (zloop_t *self, zmq_pollitem_t *item, zloop_fn handler, void *arg);\n\n// Cancel a pollitem from the reactor, specified by socket or FD. If both\n// are specified, uses only socket. If multiple poll items exist for same\n// socket/FD, cancels ALL of them.                                       \nvoid\n    zloop_poller_end (zloop_t *self, zmq_pollitem_t *item);\n\n// Configure a registered poller to ignore errors. If you do not set this,\n// then poller that have errors are removed from the reactor silently.    \nvoid\n    zloop_poller_set_tolerant (zloop_t *self, zmq_pollitem_t *item);\n\n// Register a timer that expires after some delay and repeats some number of\n// times. At each expiry, will call the handler, passing the arg. To run a  \n// timer forever, use 0 times. Returns a timer_id that is used to cancel the\n// timer in the future. Returns -1 if there was an error.                   \nint\n    zloop_timer (zloop_t *self, size_t delay, size_t times, zloop_timer_fn handler, void *arg);\n\n// Cancel a specific timer identified by a specific timer_id (as returned by\n// zloop_timer).                                                            \nint\n    zloop_timer_end (zloop_t *self, int timer_id);\n\n// Register a ticket timer. Ticket timers are very fast in the case where   \n// you use a lot of timers (thousands), and frequently remove and add them. \n// The main use case is expiry timers for servers that handle many clients, \n// and which reset the expiry timer for each message received from a client.\n// Whereas normal timers perform poorly as the number of clients grows, the \n// cost of ticket timers is constant, no matter the number of clients. You  \n// must set the ticket delay using zloop_set_ticket_delay before creating a \n// ticket. Returns a handle to the timer that you should use in             \n// zloop_ticket_reset and zloop_ticket_delete.                              \nvoid *\n    zloop_ticket (zloop_t *self, zloop_timer_fn handler, void *arg);\n\n// Reset a ticket timer, which moves it to the end of the ticket list and\n// resets its execution time. This is a very fast operation.             \nvoid\n    zloop_ticket_reset (zloop_t *self, void *handle);\n\n// Delete a ticket timer. We do not actually delete the ticket here, as    \n// other code may still refer to the ticket. We mark as deleted, and remove\n// later and safely.                                                       \nvoid\n    zloop_ticket_delete (zloop_t *self, void *handle);\n\n// Set the ticket delay, which applies to all tickets. If you lower the   \n// delay and there are already tickets created, the results are undefined.\nvoid\n    zloop_set_ticket_delay (zloop_t *self, size_t ticket_delay);\n\n// Set hard limit on number of timers allowed. Setting more than a small  \n// number of timers (10-100) can have a dramatic impact on the performance\n// of the reactor. For high-volume cases, use ticket timers. If the hard  \n// limit is reached, the reactor stops creating new timers and logs an    \n// error.                                                                 \nvoid\n    zloop_set_max_timers (zloop_t *self, size_t max_timers);\n\n// Set verbose tracing of reactor on/off. The default verbose setting is\n// off (false).                                                         \nvoid\n    zloop_set_verbose (zloop_t *self, bool verbose);\n\n// By default the reactor stops if the process receives a SIGINT or SIGTERM \n// signal. This makes it impossible to shut-down message based architectures\n// like zactors. This method lets you switch off break handling. The default\n// nonstop setting is off (false).                                          \nvoid\n    zloop_set_nonstop (zloop_t *self, bool nonstop);\n\n// Start the reactor. Takes control of the thread and returns when the 0MQ  \n// context is terminated or the process is interrupted, or any event handler\n// returns -1. Event handlers may register new sockets and timers, and      \n// cancel sockets. Returns 0 if interrupted, -1 if canceled by a handler.   \nint\n    zloop_start (zloop_t *self);\n\n// Self test of this class.\nvoid\n    zloop_test (bool verbose);\n\n// CLASS: zmsg\n// Create a new empty message object\nzmsg_t *\n    zmsg_new (void);\n\n// Destroy a message object and all frames it contains\nvoid\n    zmsg_destroy (zmsg_t **self_p);\n\n// Receive message from socket, returns zmsg_t object or NULL if the recv   \n// was interrupted. Does a blocking recv. If you want to not block then use \n// the zloop class or zmsg_recv_nowait or zmq_poll to check for socket input\n// before receiving.                                                        \nzmsg_t *\n    zmsg_recv (void *source);\n\n// Load/append an open file into new message, return the message.\n// Returns NULL if the message could not be loaded.              \nzmsg_t *\n    zmsg_load (FILE *file);\n\n// Decodes a serialized message frame created by zmsg_encode () and returns\n// a new zmsg_t object. Returns NULL if the frame was badly formatted or   \n// there was insufficient memory to work.                                  \nzmsg_t *\n    zmsg_decode (zframe_t *frame);\n\n// Generate a signal message encoding the given status. A signal is a short\n// message carrying a 1-byte success/failure code (by convention, 0 means  \n// OK). Signals are encoded to be distinguishable from \"normal\" messages.  \nzmsg_t *\n    zmsg_new_signal (byte status);\n\n// Send message to destination socket, and destroy the message after sending\n// it successfully. If the message has no frames, sends nothing but destroys\n// the message anyhow. Nullifies the caller's reference to the message (as  \n// it is a destructor).                                                     \nint\n    zmsg_send (zmsg_t **self_p, void *dest);\n\n// Send message to destination socket as part of a multipart sequence, and \n// destroy the message after sending it successfully. Note that after a    \n// zmsg_sendm, you must call zmsg_send or another method that sends a final\n// message part. If the message has no frames, sends nothing but destroys  \n// the message anyhow. Nullifies the caller's reference to the message (as \n// it is a destructor).                                                    \nint\n    zmsg_sendm (zmsg_t **self_p, void *dest);\n\n// Return size of message, i.e. number of frames (0 or more).\nsize_t\n    zmsg_size (zmsg_t *self);\n\n// Return total size of all frames in message.\nsize_t\n    zmsg_content_size (zmsg_t *self);\n\n// Return message routing ID, if the message came from a ZMQ_SERVER socket.\n// Else returns zero.                                                      \nuint32_t\n    zmsg_routing_id (zmsg_t *self);\n\n// Set routing ID on message. This is used if/when the message is sent to a\n// ZMQ_SERVER socket.                                                      \nvoid\n    zmsg_set_routing_id (zmsg_t *self, uint32_t routing_id);\n\n// Push frame to the front of the message, i.e. before all other frames.  \n// Message takes ownership of frame, will destroy it when message is sent.\n// Returns 0 on success, -1 on error. Deprecates zmsg_push, which did not \n// nullify the caller's frame reference.                                  \nint\n    zmsg_prepend (zmsg_t *self, zframe_t **frame_p);\n\n// Add frame to the end of the message, i.e. after all other frames.      \n// Message takes ownership of frame, will destroy it when message is sent.\n// Returns 0 on success. Deprecates zmsg_add, which did not nullify the   \n// caller's frame reference.                                              \nint\n    zmsg_append (zmsg_t *self, zframe_t **frame_p);\n\n// Remove first frame from message, if any. Returns frame, or NULL.\nzframe_t *\n    zmsg_pop (zmsg_t *self);\n\n// Push block of memory to front of message, as a new frame.\n// Returns 0 on success, -1 on error.                       \nint\n    zmsg_pushmem (zmsg_t *self, const void *data, size_t size);\n\n// Add block of memory to the end of the message, as a new frame.\n// Returns 0 on success, -1 on error.                            \nint\n    zmsg_addmem (zmsg_t *self, const void *data, size_t size);\n\n// Push string as new frame to front of message.\n// Returns 0 on success, -1 on error.           \nint\n    zmsg_pushstr (zmsg_t *self, const char *string);\n\n// Push string as new frame to end of message.\n// Returns 0 on success, -1 on error.         \nint\n    zmsg_addstr (zmsg_t *self, const char *string);\n\n// Push formatted string as new frame to front of message.\n// Returns 0 on success, -1 on error.                     \nint\n    zmsg_pushstrf (zmsg_t *self, const char *format, ...);\n\n// Push formatted string as new frame to end of message.\n// Returns 0 on success, -1 on error.                   \nint\n    zmsg_addstrf (zmsg_t *self, const char *format, ...);\n\n// Pop frame off front of message, return as fresh string. If there were\n// no more frames in the message, returns NULL.                         \nchar *\n    zmsg_popstr (zmsg_t *self);\n\n// Push encoded message as a new frame. Message takes ownership of    \n// submessage, so the original is destroyed in this call. Returns 0 on\n// success, -1 on error.                                              \nint\n    zmsg_addmsg (zmsg_t *self, zmsg_t **msg_p);\n\n// Remove first submessage from message, if any. Returns zmsg_t, or NULL if\n// decoding was not successful.                                            \nzmsg_t *\n    zmsg_popmsg (zmsg_t *self);\n\n// Remove specified frame from list, if present. Does not destroy frame.\nvoid\n    zmsg_remove (zmsg_t *self, zframe_t *frame);\n\n// Set cursor to first frame in message. Returns frame, or NULL, if the\n// message is empty. Use this to navigate the frames as a list.        \nzframe_t *\n    zmsg_first (zmsg_t *self);\n\n// Return the next frame. If there are no more frames, returns NULL. To move\n// to the first frame call zmsg_first(). Advances the cursor.               \nzframe_t *\n    zmsg_next (zmsg_t *self);\n\n// Return the last frame. If there are no frames, returns NULL.\nzframe_t *\n    zmsg_last (zmsg_t *self);\n\n// Save message to an open file, return 0 if OK, else -1. The message is  \n// saved as a series of frames, each with length and data. Note that the  \n// file is NOT guaranteed to be portable between operating systems, not   \n// versions of CZMQ. The file format is at present undocumented and liable\n// to arbitrary change.                                                   \nint\n    zmsg_save (zmsg_t *self, FILE *file);\n\n// Serialize multipart message to a single message frame. Use this method\n// to send structured messages across transports that do not support     \n// multipart data. Allocates and returns a new frame containing the      \n// serialized message. To decode a serialized message frame, use         \n// zmsg_decode ().                                                       \nzframe_t *\n    zmsg_encode (zmsg_t *self);\n\n// Create copy of message, as new message object. Returns a fresh zmsg_t\n// object. If message is null, or memory was exhausted, returns null.   \nzmsg_t *\n    zmsg_dup (zmsg_t *self);\n\n// Send message to zsys log sink (may be stdout, or system facility as\n// configured by zsys_set_logstream).                                 \nvoid\n    zmsg_print (zmsg_t *self);\n\n// Return true if the two messages have the same number of frames and each  \n// frame in the first message is identical to the corresponding frame in the\n// other message. As with zframe_eq, return false if either message is NULL.\nbool\n    zmsg_eq (zmsg_t *self, zmsg_t *other);\n\n// Return signal value, 0 or greater, if message is a signal, -1 if not.\nint\n    zmsg_signal (zmsg_t *self);\n\n// Probe the supplied object, and report if it looks like a zmsg_t.\nbool\n    zmsg_is (void *self);\n\n// Self test of this class.\nvoid\n    zmsg_test (bool verbose);\n\n// CLASS: zpoller\n// Create new poller, specifying zero or more readers. The list of \n// readers ends in a NULL. Each reader can be a zsock_t instance, a\n// zactor_t instance, a libzmq socket (void *), or a file handle.  \nzpoller_t *\n    zpoller_new (void *reader, ...);\n\n// Destroy a poller\nvoid\n    zpoller_destroy (zpoller_t **self_p);\n\n// Add a reader to be polled. Returns 0 if OK, -1 on failure. The reader may\n// be a libzmq void * socket, a zsock_t instance, or a zactor_t instance.   \nint\n    zpoller_add (zpoller_t *self, void *reader);\n\n// Remove a reader from the poller; returns 0 if OK, -1 on failure. The reader\n// must have been passed during construction, or in an zpoller_add () call.   \nint\n    zpoller_remove (zpoller_t *self, void *reader);\n\n// By default the poller stops if the process receives a SIGINT or SIGTERM  \n// signal. This makes it impossible to shut-down message based architectures\n// like zactors. This method lets you switch off break handling. The default\n// nonstop setting is off (false).                                          \nvoid\n    zpoller_set_nonstop (zpoller_t *self, bool nonstop);\n\n// Poll the registered readers for I/O, return first reader that has input.  \n// The reader will be a libzmq void * socket, or a zsock_t or zactor_t       \n// instance as specified in zpoller_new/zpoller_add. The timeout should be   \n// zero or greater, or -1 to wait indefinitely. Socket priority is defined   \n// by their order in the poll list. If you need a balanced poll, use the low \n// level zmq_poll method directly. If the poll call was interrupted (SIGINT),\n// or the ZMQ context was destroyed, or the timeout expired, returns NULL.   \n// You can test the actual exit condition by calling zpoller_expired () and  \n// zpoller_terminated (). The timeout is in msec.                            \nvoid *\n    zpoller_wait (zpoller_t *self, int timeout);\n\n// Return true if the last zpoller_wait () call ended because the timeout\n// expired, without any error.                                           \nbool\n    zpoller_expired (zpoller_t *self);\n\n// Return true if the last zpoller_wait () call ended because the process\n// was interrupted, or the parent context was destroyed.                 \nbool\n    zpoller_terminated (zpoller_t *self);\n\n// Self test of this class.\nvoid\n    zpoller_test (bool verbose);\n\n// CLASS: zproc\n// Returns CZMQ version as a single 6-digit integer encoding the major\n// version (x 10000), the minor version (x 100) and the patch.        \nint\n    zproc_czmq_version (void);\n\n// Returns true if the process received a SIGINT or SIGTERM signal.\n// It is good practice to use this method to exit any infinite loop\n// processing messages.                                            \nbool\n    zproc_interrupted (void);\n\n// Returns true if the underlying libzmq supports CURVE security.\nbool\n    zproc_has_curve (void);\n\n// Return current host name, for use in public tcp:// endpoints.\n// If the host name is not resolvable, returns NULL.            \nchar *\n    zproc_hostname (void);\n\n// Move the current process into the background. The precise effect     \n// depends on the operating system. On POSIX boxes, moves to a specified\n// working directory (if specified), closes all file handles, reopens   \n// stdin, stdout, and stderr to the null device, and sets the process to\n// ignore SIGHUP. On Windows, does nothing. Returns 0 if OK, -1 if there\n// was an error.                                                        \nvoid\n    zproc_daemonize (const char *workdir);\n\n// Drop the process ID into the lockfile, with exclusive lock, and   \n// switch the process to the specified group and/or user. Any of the \n// arguments may be null, indicating a no-op. Returns 0 on success,  \n// -1 on failure. Note if you combine this with zsys_daemonize, run  \n// after, not before that method, or the lockfile will hold the wrong\n// process ID.                                                       \nvoid\n    zproc_run_as (const char *lockfile, const char *group, const char *user);\n\n// Configure the number of I/O threads that ZeroMQ will use. A good  \n// rule of thumb is one thread per gigabit of traffic in or out. The \n// default is 1, sufficient for most applications. If the environment\n// variable ZSYS_IO_THREADS is defined, that provides the default.   \n// Note that this method is valid only before any socket is created. \nvoid\n    zproc_set_io_threads (size_t io_threads);\n\n// Configure the number of sockets that ZeroMQ will allow. The default  \n// is 1024. The actual limit depends on the system, and you can query it\n// by using zsys_socket_limit (). A value of zero means \"maximum\".      \n// Note that this method is valid only before any socket is created.    \nvoid\n    zproc_set_max_sockets (size_t max_sockets);\n\n// Set network interface name to use for broadcasts, particularly zbeacon.    \n// This lets the interface be configured for test environments where required.\n// For example, on Mac OS X, zbeacon cannot bind to 255.255.255.255 which is  \n// the default when there is no specified interface. If the environment       \n// variable ZSYS_INTERFACE is set, use that as the default interface name.    \n// Setting the interface to \"*\" means \"use all available interfaces\".         \nvoid\n    zproc_set_biface (const char *value);\n\n// Return network interface to use for broadcasts, or \"\" if none was set.\nconst char *\n    zproc_biface (void);\n\n// Set log identity, which is a string that prefixes all log messages sent\n// by this process. The log identity defaults to the environment variable \n// ZSYS_LOGIDENT, if that is set.                                         \nvoid\n    zproc_set_log_ident (const char *value);\n\n// Sends log output to a PUB socket bound to the specified endpoint. To   \n// collect such log output, create a SUB socket, subscribe to the traffic \n// you care about, and connect to the endpoint. Log traffic is sent as a  \n// single string frame, in the same format as when sent to stdout. The    \n// log system supports a single sender; multiple calls to this method will\n// bind the same sender to multiple endpoints. To disable the sender, call\n// this method with a null argument.                                      \nvoid\n    zproc_set_log_sender (const char *endpoint);\n\n// Enable or disable logging to the system facility (syslog on POSIX boxes,\n// event log on Windows). By default this is disabled.                     \nvoid\n    zproc_set_log_system (bool logsystem);\n\n// Log error condition - highest priority\nvoid\n    zproc_log_error (const char *format, ...);\n\n// Log warning condition - high priority\nvoid\n    zproc_log_warning (const char *format, ...);\n\n// Log normal, but significant, condition - normal priority\nvoid\n    zproc_log_notice (const char *format, ...);\n\n// Log informational message - low priority\nvoid\n    zproc_log_info (const char *format, ...);\n\n// Log debug-level message - lowest priority\nvoid\n    zproc_log_debug (const char *format, ...);\n\n// Self test of this class.\nvoid\n    zproc_test (bool verbose);\n\n// CLASS: zsock\n// Create a new socket. Returns the new socket, or NULL if the new socket\n// could not be created. Note that the symbol zsock_new (and other       \n// constructors/destructors for zsock) are redirected to the *_checked   \n// variant, enabling intelligent socket leak detection. This can have    \n// performance implications if you use a LOT of sockets. To turn off this\n// redirection behaviour, define ZSOCK_NOCHECK.                          \nzsock_t *\n    zsock_new (int type);\n\n// Destroy the socket. You must use this for any socket created via the\n// zsock_new method.                                                   \nvoid\n    zsock_destroy (zsock_t **self_p);\n\n// Create a PUB socket. Default action is bind.\nzsock_t *\n    zsock_new_pub (const char *endpoint);\n\n// Create a SUB socket, and optionally subscribe to some prefix string. Default\n// action is connect.                                                          \nzsock_t *\n    zsock_new_sub (const char *endpoint, const char *subscribe);\n\n// Create a REQ socket. Default action is connect.\nzsock_t *\n    zsock_new_req (const char *endpoint);\n\n// Create a REP socket. Default action is bind.\nzsock_t *\n    zsock_new_rep (const char *endpoint);\n\n// Create a DEALER socket. Default action is connect.\nzsock_t *\n    zsock_new_dealer (const char *endpoint);\n\n// Create a ROUTER socket. Default action is bind.\nzsock_t *\n    zsock_new_router (const char *endpoint);\n\n// Create a PUSH socket. Default action is connect.\nzsock_t *\n    zsock_new_push (const char *endpoint);\n\n// Create a PULL socket. Default action is bind.\nzsock_t *\n    zsock_new_pull (const char *endpoint);\n\n// Create an XPUB socket. Default action is bind.\nzsock_t *\n    zsock_new_xpub (const char *endpoint);\n\n// Create an XSUB socket. Default action is connect.\nzsock_t *\n    zsock_new_xsub (const char *endpoint);\n\n// Create a PAIR socket. Default action is connect.\nzsock_t *\n    zsock_new_pair (const char *endpoint);\n\n// Create a STREAM socket. Default action is connect.\nzsock_t *\n    zsock_new_stream (const char *endpoint);\n\n// Create a SERVER socket. Default action is bind.\nzsock_t *\n    zsock_new_server (const char *endpoint);\n\n// Create a CLIENT socket. Default action is connect.\nzsock_t *\n    zsock_new_client (const char *endpoint);\n\n// Create a RADIO socket. Default action is bind.\nzsock_t *\n    zsock_new_radio (const char *endpoint);\n\n// Create a DISH socket. Default action is connect.\nzsock_t *\n    zsock_new_dish (const char *endpoint);\n\n// Create a GATHER socket. Default action is bind.\nzsock_t *\n    zsock_new_gather (const char *endpoint);\n\n// Create a SCATTER socket. Default action is connect.\nzsock_t *\n    zsock_new_scatter (const char *endpoint);\n\n// Bind a socket to a formatted endpoint. For tcp:// endpoints, supports   \n// ephemeral ports, if you specify the port number as \"*\". By default      \n// zsock uses the IANA designated range from C000 (49152) to FFFF (65535). \n// To override this range, follow the \"*\" with \"[first-last]\". Either or   \n// both first and last may be empty. To bind to a random port within the   \n// range, use \"!\" in place of \"*\".                                         \n//                                                                         \n// Examples:                                                               \n//     tcp://127.0.0.1:*           bind to first free port from C000 up    \n//     tcp://127.0.0.1:!           bind to random port from C000 to FFFF   \n//     tcp://127.0.0.1:*[60000-]   bind to first free port from 60000 up   \n//     tcp://127.0.0.1:![-60000]   bind to random port from C000 to 60000  \n//     tcp://127.0.0.1:![55000-55999]                                      \n//                                 bind to random port from 55000 to 55999 \n//                                                                         \n// On success, returns the actual port number used, for tcp:// endpoints,  \n// and 0 for other transports. On failure, returns -1. Note that when using\n// ephemeral ports, a port may be reused by different services without     \n// clients being aware. Protocols that run on ephemeral ports should take  \n// this into account.                                                      \nint\n    zsock_bind (zsock_t *self, const char *format, ...);\n\n// Returns last bound endpoint, if any.\nconst char *\n    zsock_endpoint (zsock_t *self);\n\n// Unbind a socket from a formatted endpoint.                     \n// Returns 0 if OK, -1 if the endpoint was invalid or the function\n// isn't supported.                                               \nint\n    zsock_unbind (zsock_t *self, const char *format, ...);\n\n// Connect a socket to a formatted endpoint        \n// Returns 0 if OK, -1 if the endpoint was invalid.\nint\n    zsock_connect (zsock_t *self, const char *format, ...);\n\n// Disconnect a socket from a formatted endpoint                  \n// Returns 0 if OK, -1 if the endpoint was invalid or the function\n// isn't supported.                                               \nint\n    zsock_disconnect (zsock_t *self, const char *format, ...);\n\n// Attach a socket to zero or more endpoints. If endpoints is not null,     \n// parses as list of ZeroMQ endpoints, separated by commas, and prefixed by \n// '@' (to bind the socket) or '>' (to connect the socket). Returns 0 if all\n// endpoints were valid, or -1 if there was a syntax error. If the endpoint \n// does not start with '@' or '>', the serverish argument defines whether   \n// it is used to bind (serverish = true) or connect (serverish = false).    \nint\n    zsock_attach (zsock_t *self, const char *endpoints, bool serverish);\n\n// Returns socket type as printable constant string.\nconst char *\n    zsock_type_str (zsock_t *self);\n\n// Send a 'picture' message to the socket (or actor). The picture is a   \n// string that defines the type of each frame. This makes it easy to send\n// a complex multiframe message in one call. The picture can contain any \n// of these characters, each corresponding to one or two arguments:      \n//                                                                       \n//     i = int (signed)                                                  \n//     1 = uint8_t                                                       \n//     2 = uint16_t                                                      \n//     4 = uint32_t                                                      \n//     8 = uint64_t                                                      \n//     s = char *                                                        \n//     b = byte *, size_t (2 arguments)                                  \n//     c = zchunk_t *                                                    \n//     f = zframe_t *                                                    \n//     h = zhashx_t *                                                    \n//     U = zuuid_t *                                                     \n//     p = void * (sends the pointer value, only meaningful over inproc) \n//     m = zmsg_t * (sends all frames in the zmsg)                       \n//     z = sends zero-sized frame (0 arguments)                          \n//     u = uint (deprecated)                                             \n//                                                                       \n// Note that s, b, c, and f are encoded the same way and the choice is   \n// offered as a convenience to the sender, which may or may not already  \n// have data in a zchunk or zframe. Does not change or take ownership of \n// any arguments. Returns 0 if successful, -1 if sending failed for any  \n// reason.                                                               \nint\n    zsock_send (void *self, const char *picture, ...);\n\n// Send a 'picture' message to the socket (or actor). This is a va_list \n// version of zsock_send (), so please consult its documentation for the\n// details.                                                             \nint\n    zsock_vsend (void *self, const char *picture, va_list argptr);\n\n// Receive a 'picture' message to the socket (or actor). See zsock_send for\n// the format and meaning of the picture. Returns the picture elements into\n// a series of pointers as provided by the caller:                         \n//                                                                         \n//     i = int * (stores signed integer)                                   \n//     4 = uint32_t * (stores 32-bit unsigned integer)                     \n//     8 = uint64_t * (stores 64-bit unsigned integer)                     \n//     s = char ** (allocates new string)                                  \n//     b = byte **, size_t * (2 arguments) (allocates memory)              \n//     c = zchunk_t ** (creates zchunk)                                    \n//     f = zframe_t ** (creates zframe)                                    \n//     U = zuuid_t * (creates a zuuid with the data)                       \n//     h = zhashx_t ** (creates zhashx)                                    \n//     p = void ** (stores pointer)                                        \n//     m = zmsg_t ** (creates a zmsg with the remaing frames)              \n//     z = null, asserts empty frame (0 arguments)                         \n//     u = uint * (stores unsigned integer, deprecated)                    \n//                                                                         \n// Note that zsock_recv creates the returned objects, and the caller must  \n// destroy them when finished with them. The supplied pointers do not need \n// to be initialized. Returns 0 if successful, or -1 if it failed to recv  \n// a message, in which case the pointers are not modified. When message    \n// frames are truncated (a short message), sets return values to zero/null.\n// If an argument pointer is NULL, does not store any value (skips it).    \n// An 'n' picture matches an empty frame; if the message does not match,   \n// the method will return -1.                                              \nint\n    zsock_recv (void *self, const char *picture, ...);\n\n// Receive a 'picture' message from the socket (or actor). This is a    \n// va_list version of zsock_recv (), so please consult its documentation\n// for the details.                                                     \nint\n    zsock_vrecv (void *self, const char *picture, va_list argptr);\n\n// Send a binary encoded 'picture' message to the socket (or actor). This \n// method is similar to zsock_send, except the arguments are encoded in a \n// binary format that is compatible with zproto, and is designed to reduce\n// memory allocations. The pattern argument is a string that defines the  \n// type of each argument. Supports these argument types:                  \n//                                                                        \n//  pattern    C type                  zproto type:                       \n//     1       uint8_t                 type = \"number\" size = \"1\"         \n//     2       uint16_t                type = \"number\" size = \"2\"         \n//     4       uint32_t                type = \"number\" size = \"3\"         \n//     8       uint64_t                type = \"number\" size = \"4\"         \n//     s       char *, 0-255 chars     type = \"string\"                    \n//     S       char *, 0-2^32-1 chars  type = \"longstr\"                   \n//     c       zchunk_t *              type = \"chunk\"                     \n//     f       zframe_t *              type = \"frame\"                     \n//     u       zuuid_t *               type = \"uuid\"                      \n//     m       zmsg_t *                type = \"msg\"                       \n//     p       void *, sends pointer value, only over inproc              \n//                                                                        \n// Does not change or take ownership of any arguments. Returns 0 if       \n// successful, -1 if sending failed for any reason.                       \nint\n    zsock_bsend (void *self, const char *picture, ...);\n\n// Receive a binary encoded 'picture' message from the socket (or actor).  \n// This method is similar to zsock_recv, except the arguments are encoded  \n// in a binary format that is compatible with zproto, and is designed to   \n// reduce memory allocations. The pattern argument is a string that defines\n// the type of each argument. See zsock_bsend for the supported argument   \n// types. All arguments must be pointers; this call sets them to point to  \n// values held on a per-socket basis.                                      \n// Note that zsock_brecv creates the returned objects, and the caller must \n// destroy them when finished with them. The supplied pointers do not need \n// to be initialized. Returns 0 if successful, or -1 if it failed to read  \n// a message.                                                              \nint\n    zsock_brecv (void *self, const char *picture, ...);\n\n// Return socket routing ID if any. This returns 0 if the socket is not\n// of type ZMQ_SERVER or if no request was already received on it.     \nuint32_t\n    zsock_routing_id (zsock_t *self);\n\n// Set routing ID on socket. The socket MUST be of type ZMQ_SERVER.        \n// This will be used when sending messages on the socket via the zsock API.\nvoid\n    zsock_set_routing_id (zsock_t *self, uint32_t routing_id);\n\n// Set socket to use unbounded pipes (HWM=0); use this in cases when you are\n// totally certain the message volume can fit in memory. This method works  \n// across all versions of ZeroMQ. Takes a polymorphic socket reference.     \nvoid\n    zsock_set_unbounded (void *self);\n\n// Send a signal over a socket. A signal is a short message carrying a   \n// success/failure code (by convention, 0 means OK). Signals are encoded \n// to be distinguishable from \"normal\" messages. Accepts a zsock_t or a  \n// zactor_t argument, and returns 0 if successful, -1 if the signal could\n// not be sent. Takes a polymorphic socket reference.                    \nint\n    zsock_signal (void *self, byte status);\n\n// Wait on a signal. Use this to coordinate between threads, over pipe  \n// pairs. Blocks until the signal is received. Returns -1 on error, 0 or\n// greater on success. Accepts a zsock_t or a zactor_t as argument.     \n// Takes a polymorphic socket reference.                                \nint\n    zsock_wait (void *self);\n\n// If there is a partial message still waiting on the socket, remove and    \n// discard it. This is useful when reading partial messages, to get specific\n// message types.                                                           \nvoid\n    zsock_flush (void *self);\n\n// Join a group for the RADIO-DISH pattern. Call only on ZMQ_DISH.\n// Returns 0 if OK, -1 if failed.                                 \nint\n    zsock_join (void *self, const char *group);\n\n// Leave a group for the RADIO-DISH pattern. Call only on ZMQ_DISH.\n// Returns 0 if OK, -1 if failed.                                  \nint\n    zsock_leave (void *self, const char *group);\n\n// Probe the supplied object, and report if it looks like a zsock_t.\n// Takes a polymorphic socket reference.                            \nbool\n    zsock_is (void *self);\n\n// Probe the supplied reference. If it looks like a zsock_t instance, return\n// the underlying libzmq socket handle; else if it looks like a file        \n// descriptor, return NULL; else if it looks like a libzmq socket handle,   \n// return the supplied value. Takes a polymorphic socket reference.         \nvoid *\n    zsock_resolve (void *self);\n\n// Get socket option `heartbeat_ivl`.\n// Available from libzmq 4.2.0.      \nint\n    zsock_heartbeat_ivl (void *self);\n\n// Set socket option `heartbeat_ivl`.\n// Available from libzmq 4.2.0.      \nvoid\n    zsock_set_heartbeat_ivl (void *self, int heartbeat_ivl);\n\n// Get socket option `heartbeat_ttl`.\n// Available from libzmq 4.2.0.      \nint\n    zsock_heartbeat_ttl (void *self);\n\n// Set socket option `heartbeat_ttl`.\n// Available from libzmq 4.2.0.      \nvoid\n    zsock_set_heartbeat_ttl (void *self, int heartbeat_ttl);\n\n// Get socket option `heartbeat_timeout`.\n// Available from libzmq 4.2.0.          \nint\n    zsock_heartbeat_timeout (void *self);\n\n// Set socket option `heartbeat_timeout`.\n// Available from libzmq 4.2.0.          \nvoid\n    zsock_set_heartbeat_timeout (void *self, int heartbeat_timeout);\n\n// Get socket option `use_fd`. \n// Available from libzmq 4.2.0.\nint\n    zsock_use_fd (void *self);\n\n// Set socket option `use_fd`. \n// Available from libzmq 4.2.0.\nvoid\n    zsock_set_use_fd (void *self, int use_fd);\n\n// Set socket option `xpub_manual`.\n// Available from libzmq 4.2.0.    \nvoid\n    zsock_set_xpub_manual (void *self, int xpub_manual);\n\n// Set socket option `xpub_welcome_msg`.\n// Available from libzmq 4.2.0.         \nvoid\n    zsock_set_xpub_welcome_msg (void *self, const char *xpub_welcome_msg);\n\n// Set socket option `stream_notify`.\n// Available from libzmq 4.2.0.      \nvoid\n    zsock_set_stream_notify (void *self, int stream_notify);\n\n// Get socket option `invert_matching`.\n// Available from libzmq 4.2.0.        \nint\n    zsock_invert_matching (void *self);\n\n// Set socket option `invert_matching`.\n// Available from libzmq 4.2.0.        \nvoid\n    zsock_set_invert_matching (void *self, int invert_matching);\n\n// Set socket option `xpub_verboser`.\n// Available from libzmq 4.2.0.      \nvoid\n    zsock_set_xpub_verboser (void *self, int xpub_verboser);\n\n// Get socket option `connect_timeout`.\n// Available from libzmq 4.2.0.        \nint\n    zsock_connect_timeout (void *self);\n\n// Set socket option `connect_timeout`.\n// Available from libzmq 4.2.0.        \nvoid\n    zsock_set_connect_timeout (void *self, int connect_timeout);\n\n// Get socket option `tcp_maxrt`.\n// Available from libzmq 4.2.0.  \nint\n    zsock_tcp_maxrt (void *self);\n\n// Set socket option `tcp_maxrt`.\n// Available from libzmq 4.2.0.  \nvoid\n    zsock_set_tcp_maxrt (void *self, int tcp_maxrt);\n\n// Get socket option `thread_safe`.\n// Available from libzmq 4.2.0.    \nint\n    zsock_thread_safe (void *self);\n\n// Get socket option `multicast_maxtpdu`.\n// Available from libzmq 4.2.0.          \nint\n    zsock_multicast_maxtpdu (void *self);\n\n// Set socket option `multicast_maxtpdu`.\n// Available from libzmq 4.2.0.          \nvoid\n    zsock_set_multicast_maxtpdu (void *self, int multicast_maxtpdu);\n\n// Get socket option `vmci_buffer_size`.\n// Available from libzmq 4.2.0.         \nint\n    zsock_vmci_buffer_size (void *self);\n\n// Set socket option `vmci_buffer_size`.\n// Available from libzmq 4.2.0.         \nvoid\n    zsock_set_vmci_buffer_size (void *self, int vmci_buffer_size);\n\n// Get socket option `vmci_buffer_min_size`.\n// Available from libzmq 4.2.0.             \nint\n    zsock_vmci_buffer_min_size (void *self);\n\n// Set socket option `vmci_buffer_min_size`.\n// Available from libzmq 4.2.0.             \nvoid\n    zsock_set_vmci_buffer_min_size (void *self, int vmci_buffer_min_size);\n\n// Get socket option `vmci_buffer_max_size`.\n// Available from libzmq 4.2.0.             \nint\n    zsock_vmci_buffer_max_size (void *self);\n\n// Set socket option `vmci_buffer_max_size`.\n// Available from libzmq 4.2.0.             \nvoid\n    zsock_set_vmci_buffer_max_size (void *self, int vmci_buffer_max_size);\n\n// Get socket option `vmci_connect_timeout`.\n// Available from libzmq 4.2.0.             \nint\n    zsock_vmci_connect_timeout (void *self);\n\n// Set socket option `vmci_connect_timeout`.\n// Available from libzmq 4.2.0.             \nvoid\n    zsock_set_vmci_connect_timeout (void *self, int vmci_connect_timeout);\n\n// Get socket option `tos`.    \n// Available from libzmq 4.1.0.\nint\n    zsock_tos (void *self);\n\n// Set socket option `tos`.    \n// Available from libzmq 4.1.0.\nvoid\n    zsock_set_tos (void *self, int tos);\n\n// Set socket option `router_handover`.\n// Available from libzmq 4.1.0.        \nvoid\n    zsock_set_router_handover (void *self, int router_handover);\n\n// Set socket option `connect_rid`.\n// Available from libzmq 4.1.0.    \nvoid\n    zsock_set_connect_rid (void *self, const char *connect_rid);\n\n// Set socket option `connect_rid` from 32-octet binary\n// Available from libzmq 4.1.0.                        \nvoid\n    zsock_set_connect_rid_bin (void *self, const byte *connect_rid);\n\n// Get socket option `handshake_ivl`.\n// Available from libzmq 4.1.0.      \nint\n    zsock_handshake_ivl (void *self);\n\n// Set socket option `handshake_ivl`.\n// Available from libzmq 4.1.0.      \nvoid\n    zsock_set_handshake_ivl (void *self, int handshake_ivl);\n\n// Get socket option `socks_proxy`.\n// Available from libzmq 4.1.0.    \nchar *\n    zsock_socks_proxy (void *self);\n\n// Set socket option `socks_proxy`.\n// Available from libzmq 4.1.0.    \nvoid\n    zsock_set_socks_proxy (void *self, const char *socks_proxy);\n\n// Set socket option `xpub_nodrop`.\n// Available from libzmq 4.1.0.    \nvoid\n    zsock_set_xpub_nodrop (void *self, int xpub_nodrop);\n\n// Set socket option `router_mandatory`.\n// Available from libzmq 4.0.0.         \nvoid\n    zsock_set_router_mandatory (void *self, int router_mandatory);\n\n// Set socket option `probe_router`.\n// Available from libzmq 4.0.0.     \nvoid\n    zsock_set_probe_router (void *self, int probe_router);\n\n// Set socket option `req_relaxed`.\n// Available from libzmq 4.0.0.    \nvoid\n    zsock_set_req_relaxed (void *self, int req_relaxed);\n\n// Set socket option `req_correlate`.\n// Available from libzmq 4.0.0.      \nvoid\n    zsock_set_req_correlate (void *self, int req_correlate);\n\n// Set socket option `conflate`.\n// Available from libzmq 4.0.0. \nvoid\n    zsock_set_conflate (void *self, int conflate);\n\n// Get socket option `zap_domain`.\n// Available from libzmq 4.0.0.   \nchar *\n    zsock_zap_domain (void *self);\n\n// Set socket option `zap_domain`.\n// Available from libzmq 4.0.0.   \nvoid\n    zsock_set_zap_domain (void *self, const char *zap_domain);\n\n// Get socket option `mechanism`.\n// Available from libzmq 4.0.0.  \nint\n    zsock_mechanism (void *self);\n\n// Get socket option `plain_server`.\n// Available from libzmq 4.0.0.     \nint\n    zsock_plain_server (void *self);\n\n// Set socket option `plain_server`.\n// Available from libzmq 4.0.0.     \nvoid\n    zsock_set_plain_server (void *self, int plain_server);\n\n// Get socket option `plain_username`.\n// Available from libzmq 4.0.0.       \nchar *\n    zsock_plain_username (void *self);\n\n// Set socket option `plain_username`.\n// Available from libzmq 4.0.0.       \nvoid\n    zsock_set_plain_username (void *self, const char *plain_username);\n\n// Get socket option `plain_password`.\n// Available from libzmq 4.0.0.       \nchar *\n    zsock_plain_password (void *self);\n\n// Set socket option `plain_password`.\n// Available from libzmq 4.0.0.       \nvoid\n    zsock_set_plain_password (void *self, const char *plain_password);\n\n// Get socket option `curve_server`.\n// Available from libzmq 4.0.0.     \nint\n    zsock_curve_server (void *self);\n\n// Set socket option `curve_server`.\n// Available from libzmq 4.0.0.     \nvoid\n    zsock_set_curve_server (void *self, int curve_server);\n\n// Get socket option `curve_publickey`.\n// Available from libzmq 4.0.0.        \nchar *\n    zsock_curve_publickey (void *self);\n\n// Set socket option `curve_publickey`.\n// Available from libzmq 4.0.0.        \nvoid\n    zsock_set_curve_publickey (void *self, const char *curve_publickey);\n\n// Set socket option `curve_publickey` from 32-octet binary\n// Available from libzmq 4.0.0.                            \nvoid\n    zsock_set_curve_publickey_bin (void *self, const byte *curve_publickey);\n\n// Get socket option `curve_secretkey`.\n// Available from libzmq 4.0.0.        \nchar *\n    zsock_curve_secretkey (void *self);\n\n// Set socket option `curve_secretkey`.\n// Available from libzmq 4.0.0.        \nvoid\n    zsock_set_curve_secretkey (void *self, const char *curve_secretkey);\n\n// Set socket option `curve_secretkey` from 32-octet binary\n// Available from libzmq 4.0.0.                            \nvoid\n    zsock_set_curve_secretkey_bin (void *self, const byte *curve_secretkey);\n\n// Get socket option `curve_serverkey`.\n// Available from libzmq 4.0.0.        \nchar *\n    zsock_curve_serverkey (void *self);\n\n// Set socket option `curve_serverkey`.\n// Available from libzmq 4.0.0.        \nvoid\n    zsock_set_curve_serverkey (void *self, const char *curve_serverkey);\n\n// Set socket option `curve_serverkey` from 32-octet binary\n// Available from libzmq 4.0.0.                            \nvoid\n    zsock_set_curve_serverkey_bin (void *self, const byte *curve_serverkey);\n\n// Get socket option `gssapi_server`.\n// Available from libzmq 4.0.0.      \nint\n    zsock_gssapi_server (void *self);\n\n// Set socket option `gssapi_server`.\n// Available from libzmq 4.0.0.      \nvoid\n    zsock_set_gssapi_server (void *self, int gssapi_server);\n\n// Get socket option `gssapi_plaintext`.\n// Available from libzmq 4.0.0.         \nint\n    zsock_gssapi_plaintext (void *self);\n\n// Set socket option `gssapi_plaintext`.\n// Available from libzmq 4.0.0.         \nvoid\n    zsock_set_gssapi_plaintext (void *self, int gssapi_plaintext);\n\n// Get socket option `gssapi_principal`.\n// Available from libzmq 4.0.0.         \nchar *\n    zsock_gssapi_principal (void *self);\n\n// Set socket option `gssapi_principal`.\n// Available from libzmq 4.0.0.         \nvoid\n    zsock_set_gssapi_principal (void *self, const char *gssapi_principal);\n\n// Get socket option `gssapi_service_principal`.\n// Available from libzmq 4.0.0.                 \nchar *\n    zsock_gssapi_service_principal (void *self);\n\n// Set socket option `gssapi_service_principal`.\n// Available from libzmq 4.0.0.                 \nvoid\n    zsock_set_gssapi_service_principal (void *self, const char *gssapi_service_principal);\n\n// Get socket option `ipv6`.   \n// Available from libzmq 4.0.0.\nint\n    zsock_ipv6 (void *self);\n\n// Set socket option `ipv6`.   \n// Available from libzmq 4.0.0.\nvoid\n    zsock_set_ipv6 (void *self, int ipv6);\n\n// Get socket option `immediate`.\n// Available from libzmq 4.0.0.  \nint\n    zsock_immediate (void *self);\n\n// Set socket option `immediate`.\n// Available from libzmq 4.0.0.  \nvoid\n    zsock_set_immediate (void *self, int immediate);\n\n// Get socket option `type`.   \n// Available from libzmq 3.0.0.\nint\n    zsock_type (void *self);\n\n// Get socket option `sndhwm`. \n// Available from libzmq 3.0.0.\nint\n    zsock_sndhwm (void *self);\n\n// Set socket option `sndhwm`. \n// Available from libzmq 3.0.0.\nvoid\n    zsock_set_sndhwm (void *self, int sndhwm);\n\n// Get socket option `rcvhwm`. \n// Available from libzmq 3.0.0.\nint\n    zsock_rcvhwm (void *self);\n\n// Set socket option `rcvhwm`. \n// Available from libzmq 3.0.0.\nvoid\n    zsock_set_rcvhwm (void *self, int rcvhwm);\n\n// Get socket option `affinity`.\n// Available from libzmq 3.0.0. \nint\n    zsock_affinity (void *self);\n\n// Set socket option `affinity`.\n// Available from libzmq 3.0.0. \nvoid\n    zsock_set_affinity (void *self, int affinity);\n\n// Set socket option `subscribe`.\n// Available from libzmq 3.0.0.  \nvoid\n    zsock_set_subscribe (void *self, const char *subscribe);\n\n// Set socket option `unsubscribe`.\n// Available from libzmq 3.0.0.    \nvoid\n    zsock_set_unsubscribe (void *self, const char *unsubscribe);\n\n// Get socket option `identity`.\n// Available from libzmq 3.0.0. \nchar *\n    zsock_identity (void *self);\n\n// Set socket option `identity`.\n// Available from libzmq 3.0.0. \nvoid\n    zsock_set_identity (void *self, const char *identity);\n\n// Get socket option `rate`.   \n// Available from libzmq 3.0.0.\nint\n    zsock_rate (void *self);\n\n// Set socket option `rate`.   \n// Available from libzmq 3.0.0.\nvoid\n    zsock_set_rate (void *self, int rate);\n\n// Get socket option `recovery_ivl`.\n// Available from libzmq 3.0.0.     \nint\n    zsock_recovery_ivl (void *self);\n\n// Set socket option `recovery_ivl`.\n// Available from libzmq 3.0.0.     \nvoid\n    zsock_set_recovery_ivl (void *self, int recovery_ivl);\n\n// Get socket option `sndbuf`. \n// Available from libzmq 3.0.0.\nint\n    zsock_sndbuf (void *self);\n\n// Set socket option `sndbuf`. \n// Available from libzmq 3.0.0.\nvoid\n    zsock_set_sndbuf (void *self, int sndbuf);\n\n// Get socket option `rcvbuf`. \n// Available from libzmq 3.0.0.\nint\n    zsock_rcvbuf (void *self);\n\n// Set socket option `rcvbuf`. \n// Available from libzmq 3.0.0.\nvoid\n    zsock_set_rcvbuf (void *self, int rcvbuf);\n\n// Get socket option `linger`. \n// Available from libzmq 3.0.0.\nint\n    zsock_linger (void *self);\n\n// Set socket option `linger`. \n// Available from libzmq 3.0.0.\nvoid\n    zsock_set_linger (void *self, int linger);\n\n// Get socket option `reconnect_ivl`.\n// Available from libzmq 3.0.0.      \nint\n    zsock_reconnect_ivl (void *self);\n\n// Set socket option `reconnect_ivl`.\n// Available from libzmq 3.0.0.      \nvoid\n    zsock_set_reconnect_ivl (void *self, int reconnect_ivl);\n\n// Get socket option `reconnect_ivl_max`.\n// Available from libzmq 3.0.0.          \nint\n    zsock_reconnect_ivl_max (void *self);\n\n// Set socket option `reconnect_ivl_max`.\n// Available from libzmq 3.0.0.          \nvoid\n    zsock_set_reconnect_ivl_max (void *self, int reconnect_ivl_max);\n\n// Get socket option `backlog`.\n// Available from libzmq 3.0.0.\nint\n    zsock_backlog (void *self);\n\n// Set socket option `backlog`.\n// Available from libzmq 3.0.0.\nvoid\n    zsock_set_backlog (void *self, int backlog);\n\n// Get socket option `maxmsgsize`.\n// Available from libzmq 3.0.0.   \nint\n    zsock_maxmsgsize (void *self);\n\n// Set socket option `maxmsgsize`.\n// Available from libzmq 3.0.0.   \nvoid\n    zsock_set_maxmsgsize (void *self, int maxmsgsize);\n\n// Get socket option `multicast_hops`.\n// Available from libzmq 3.0.0.       \nint\n    zsock_multicast_hops (void *self);\n\n// Set socket option `multicast_hops`.\n// Available from libzmq 3.0.0.       \nvoid\n    zsock_set_multicast_hops (void *self, int multicast_hops);\n\n// Get socket option `rcvtimeo`.\n// Available from libzmq 3.0.0. \nint\n    zsock_rcvtimeo (void *self);\n\n// Set socket option `rcvtimeo`.\n// Available from libzmq 3.0.0. \nvoid\n    zsock_set_rcvtimeo (void *self, int rcvtimeo);\n\n// Get socket option `sndtimeo`.\n// Available from libzmq 3.0.0. \nint\n    zsock_sndtimeo (void *self);\n\n// Set socket option `sndtimeo`.\n// Available from libzmq 3.0.0. \nvoid\n    zsock_set_sndtimeo (void *self, int sndtimeo);\n\n// Set socket option `xpub_verbose`.\n// Available from libzmq 3.0.0.     \nvoid\n    zsock_set_xpub_verbose (void *self, int xpub_verbose);\n\n// Get socket option `tcp_keepalive`.\n// Available from libzmq 3.0.0.      \nint\n    zsock_tcp_keepalive (void *self);\n\n// Set socket option `tcp_keepalive`.\n// Available from libzmq 3.0.0.      \nvoid\n    zsock_set_tcp_keepalive (void *self, int tcp_keepalive);\n\n// Get socket option `tcp_keepalive_idle`.\n// Available from libzmq 3.0.0.           \nint\n    zsock_tcp_keepalive_idle (void *self);\n\n// Set socket option `tcp_keepalive_idle`.\n// Available from libzmq 3.0.0.           \nvoid\n    zsock_set_tcp_keepalive_idle (void *self, int tcp_keepalive_idle);\n\n// Get socket option `tcp_keepalive_cnt`.\n// Available from libzmq 3.0.0.          \nint\n    zsock_tcp_keepalive_cnt (void *self);\n\n// Set socket option `tcp_keepalive_cnt`.\n// Available from libzmq 3.0.0.          \nvoid\n    zsock_set_tcp_keepalive_cnt (void *self, int tcp_keepalive_cnt);\n\n// Get socket option `tcp_keepalive_intvl`.\n// Available from libzmq 3.0.0.            \nint\n    zsock_tcp_keepalive_intvl (void *self);\n\n// Set socket option `tcp_keepalive_intvl`.\n// Available from libzmq 3.0.0.            \nvoid\n    zsock_set_tcp_keepalive_intvl (void *self, int tcp_keepalive_intvl);\n\n// Get socket option `tcp_accept_filter`.\n// Available from libzmq 3.0.0.          \nchar *\n    zsock_tcp_accept_filter (void *self);\n\n// Set socket option `tcp_accept_filter`.\n// Available from libzmq 3.0.0.          \nvoid\n    zsock_set_tcp_accept_filter (void *self, const char *tcp_accept_filter);\n\n// Get socket option `rcvmore`.\n// Available from libzmq 3.0.0.\nint\n    zsock_rcvmore (void *self);\n\n// Get socket option `fd`.     \n// Available from libzmq 3.0.0.\nSOCKET\n    zsock_fd (void *self);\n\n// Get socket option `events`. \n// Available from libzmq 3.0.0.\nint\n    zsock_events (void *self);\n\n// Get socket option `last_endpoint`.\n// Available from libzmq 3.0.0.      \nchar *\n    zsock_last_endpoint (void *self);\n\n// Set socket option `router_raw`.\n// Available from libzmq 3.0.0.   \nvoid\n    zsock_set_router_raw (void *self, int router_raw);\n\n// Get socket option `ipv4only`.\n// Available from libzmq 3.0.0. \nint\n    zsock_ipv4only (void *self);\n\n// Set socket option `ipv4only`.\n// Available from libzmq 3.0.0. \nvoid\n    zsock_set_ipv4only (void *self, int ipv4only);\n\n// Set socket option `delay_attach_on_connect`.\n// Available from libzmq 3.0.0.                \nvoid\n    zsock_set_delay_attach_on_connect (void *self, int delay_attach_on_connect);\n\n// Self test of this class.\nvoid\n    zsock_test (bool verbose);\n\n// CLASS: zstr\n// Receive C string from socket. Caller must free returned string using\n// zstr_free(). Returns NULL if the context is being terminated or the \n// process was interrupted.                                            \nchar *\n    zstr_recv (void *source);\n\n// Receive a series of strings (until NULL) from multipart data.    \n// Each string is allocated and filled with string data; if there   \n// are not enough frames, unallocated strings are set to NULL.      \n// Returns -1 if the message could not be read, else returns the    \n// number of strings filled, zero or more. Free each returned string\n// using zstr_free(). If not enough strings are provided, remaining \n// multipart frames in the message are dropped.                     \nint\n    zstr_recvx (void *source, char **string_p, ...);\n\n// Send a C string to a socket, as a frame. The string is sent without \n// trailing null byte; to read this you can use zstr_recv, or a similar\n// method that adds a null terminator on the received string. String   \n// may be NULL, which is sent as \"\".                                   \nint\n    zstr_send (void *dest, const char *string);\n\n// Send a C string to a socket, as zstr_send(), with a MORE flag, so that\n// you can send further strings in the same multi-part message.          \nint\n    zstr_sendm (void *dest, const char *string);\n\n// Send a formatted string to a socket. Note that you should NOT use\n// user-supplied strings in the format (they may contain '%' which  \n// will create security holes).                                     \nint\n    zstr_sendf (void *dest, const char *format, ...);\n\n// Send a formatted string to a socket, as for zstr_sendf(), with a      \n// MORE flag, so that you can send further strings in the same multi-part\n// message.                                                              \nint\n    zstr_sendfm (void *dest, const char *format, ...);\n\n// Send a series of strings (until NULL) as multipart data   \n// Returns 0 if the strings could be sent OK, or -1 on error.\nint\n    zstr_sendx (void *dest, const char *string, ...);\n\n// Accepts a void pointer and returns a fresh character string. If source\n// is null, returns an empty string.                                     \nchar *\n    zstr_str (void *source);\n\n// Free a provided string, and nullify the parent pointer. Safe to call on\n// a null pointer.                                                        \nvoid\n    zstr_free (char **string_p);\n\n// Self test of this class.\nvoid\n    zstr_test (bool verbose);\n\n// CLASS: ztimerset\n// Create new timer set.\nztimerset_t *\n    ztimerset_new (void);\n\n// Destroy a timer set\nvoid\n    ztimerset_destroy (ztimerset_t **self_p);\n\n// Add a timer to the set. Returns timer id if OK, -1 on failure.\nint\n    ztimerset_add (ztimerset_t *self, size_t interval, ztimerset_fn handler, void *arg);\n\n// Cancel a timer. Returns 0 if OK, -1 on failure.\nint\n    ztimerset_cancel (ztimerset_t *self, int timer_id);\n\n// Set timer interval. Returns 0 if OK, -1 on failure.                                    \n// This method is slow, canceling the timer and adding a new one yield better performance.\nint\n    ztimerset_set_interval (ztimerset_t *self, int timer_id, size_t interval);\n\n// Reset timer to start interval counting from current time. Returns 0 if OK, -1 on failure.\n// This method is slow, canceling the timer and adding a new one yield better performance.  \nint\n    ztimerset_reset (ztimerset_t *self, int timer_id);\n\n// Return the time until the next interval.                        \n// Should be used as timeout parameter for the zpoller wait method.\n// The timeout is in msec.                                         \nint\n    ztimerset_timeout (ztimerset_t *self);\n\n// Invoke callback function of all timers which their interval has elapsed.\n// Should be call after zpoller wait method.                               \n// Returns 0 if OK, -1 on failure.                                         \nint\n    ztimerset_execute (ztimerset_t *self);\n\n// Self test of this class.\nvoid\n    ztimerset_test (bool verbose);\n\n// CLASS: ztrie\n// Creates a new ztrie.\nztrie_t *\n    ztrie_new (char delimiter);\n\n// Destroy the ztrie.\nvoid\n    ztrie_destroy (ztrie_t **self_p);\n\n// Inserts a new route into the tree and attaches the data. Returns -1     \n// if the route already exists, otherwise 0. This method takes ownership of\n// the provided data if a destroy_data_fn is provided.                     \nint\n    ztrie_insert_route (ztrie_t *self, const char *path, void *data, ztrie_destroy_data_fn destroy_data_fn);\n\n// Removes a route from the trie and destroys its data. Returns -1 if the\n// route does not exists, otherwise 0.                                   \n// the start of the list call zlist_first (). Advances the cursor.       \nint\n    ztrie_remove_route (ztrie_t *self, const char *path);\n\n// Returns true if the path matches a route in the tree, otherwise false.\nbool\n    ztrie_matches (ztrie_t *self, const char *path);\n\n// Returns the data of a matched route from last ztrie_matches. If the path\n// did not match, returns NULL. Do not delete the data as it's owned by    \n// ztrie.                                                                  \nvoid *\n    ztrie_hit_data (ztrie_t *self);\n\n// Returns the count of parameters that a matched route has.\nsize_t\n    ztrie_hit_parameter_count (ztrie_t *self);\n\n// Returns the parameters of a matched route with named regexes from last   \n// ztrie_matches. If the path did not match or the route did not contain any\n// named regexes, returns NULL.                                             \nzhashx_t *\n    ztrie_hit_parameters (ztrie_t *self);\n\n// Returns the asterisk matched part of a route, if there has been no match\n// or no asterisk match, returns NULL.                                     \nconst char *\n    ztrie_hit_asterisk_match (ztrie_t *self);\n\n// Print the trie\nvoid\n    ztrie_print (ztrie_t *self);\n\n// Self test of this class.\nvoid\n    ztrie_test (bool verbose);\n\n// CLASS: zuuid\n// Create a new UUID object.\nzuuid_t *\n    zuuid_new (void);\n\n// Destroy a specified UUID object.\nvoid\n    zuuid_destroy (zuuid_t **self_p);\n\n// Create UUID object from supplied ZUUID_LEN-octet value.\nzuuid_t *\n    zuuid_new_from (const byte *source);\n\n// Set UUID to new supplied ZUUID_LEN-octet value.\nvoid\n    zuuid_set (zuuid_t *self, const byte *source);\n\n// Set UUID to new supplied string value skipping '-' and '{' '}'\n// optional delimiters. Return 0 if OK, else returns -1.         \nint\n    zuuid_set_str (zuuid_t *self, const char *source);\n\n// Return UUID binary data.\nconst byte *\n    zuuid_data (zuuid_t *self);\n\n// Return UUID binary size\nsize_t\n    zuuid_size (zuuid_t *self);\n\n// Returns UUID as string\nconst char *\n    zuuid_str (zuuid_t *self);\n\n// Return UUID in the canonical string format: 8-4-4-4-12, in lower\n// case. Caller does not modify or free returned value. See        \n// http://en.wikipedia.org/wiki/Universally_unique_identifier      \nconst char *\n    zuuid_str_canonical (zuuid_t *self);\n\n// Store UUID blob in target array\nvoid\n    zuuid_export (zuuid_t *self, byte *target);\n\n// Check if UUID is same as supplied value\nbool\n    zuuid_eq (zuuid_t *self, const byte *compare);\n\n// Check if UUID is different from supplied value\nbool\n    zuuid_neq (zuuid_t *self, const byte *compare);\n\n// Make copy of UUID object; if uuid is null, or memory was exhausted,\n// returns null.                                                      \nzuuid_t *\n    zuuid_dup (zuuid_t *self);\n\n// Self test of this class.\nvoid\n    zuuid_test (bool verbose);\n\n'''\ncdefs = re.sub(r';[^;]*\\bva_list\\b[^;]*;', ';', cdefs, flags=re.S) # we don't support anything with a va_list arg\n\nffi.cdef(cdefs)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-czmq-4.0.2-zfoicjaila2umpuugu7wnnojijtppicg/spack-src/images/README_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-czmq-4.0.2-zfoicjaila2umpuugu7wnnojijtppicg/spack-src/bindings/jni/gradle/wrapper/gradle-wrapper.jar"
    ],
    "total_files": 585
}