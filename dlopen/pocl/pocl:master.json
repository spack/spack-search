{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/CMakeLists.txt": "#=============================================================================\n#   CMake build system files\n#\n#   Copyright (c) 2014-2018 pocl developers\n#\n#   Permission is hereby granted, free of charge, to any person obtaining a copy\n#   of this software and associated documentation files (the \"Software\"), to deal\n#   in the Software without restriction, including without limitation the rights\n#   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n#   copies of the Software, and to permit persons to whom the Software is\n#   furnished to do so, subject to the following conditions:\n#\n#   The above copyright notice and this permission notice shall be included in\n#   all copies or substantial portions of the Software.\n#\n#   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n#   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n#   THE SOFTWARE.\n#\n#=============================================================================\n\ncmake_minimum_required(VERSION 3.3 FATAL_ERROR)\n\nproject(pocl)\nset(CMAKE_PROJECT_DESCRIPTION \"pocl is a portable OpenCl runtime.\")\n\nset(LATEST_KNOWN_CXX_STD_VERSION \"20\")\nset(SUPPORTED_CXX_STD_VERSION \"11\")\n\noption(ENABLE_LATEST_CXX_STD \"Upgrade C++ standard version to ${LATEST_KNOWN_CXX_STD_VERSION}. Required to get rid of unused variables warnings in compilers not supporting [[gnu::*]] attributes. Can bring other benefits, including performance and efficiency ones. Before a pull request build with this disabled.\" OFF)\nif(ENABLE_LATEST_CXX_STD)\n\tset(CMAKE_CXX_STANDARD \"${LATEST_KNOWN_CXX_STD_VERSION}\")\nelse()\n\tset(CMAKE_CXX_STANDARD \"${SUPPORTED_CXX_STD_VERSION}\")\nendif()\n\n# Fix behavior of CMAKE_CXX_STANDARD when targeting macOS.\nif(POLICY CMP0025)\n  cmake_policy(SET CMP0025 NEW)\nendif()\n\ninclude(CheckCCompilerFlag)\ninclude(CPackComponent)\nmacro(pass_through_cpack_vars)\n  get_cmake_property(cpackVarsToPassthrough VARIABLES)\n  foreach(varName ${cpackVarsToPassthrough})\n    if(varName MATCHES \"^CPACK_DEBIAN_\")\n      message(STATUS \"${varName}\")\n      set(\"${varName}\" \"${${varName}}\" PARENT_SCOPE)\n    endif()\n  endforeach()\nendmacro()\n\n# don't allow implicit function declarations\nif(UNIX)\n  if((CMAKE_C_COMPILER_ID STREQUAL \"GNU\") OR\n     (CMAKE_C_COMPILER_ID STREQUAL \"Clang\"))\n\n    add_compile_options(\"$<$<COMPILE_LANGUAGE:C>:-Werror=implicit-function-declaration>\")\n\n    check_c_compiler_flag(\"-Wincompatible-pointer-types\" HAVE_WARN_INCOMPATIBLE_POINTER_TYPES)\n    if (HAVE_WARN_INCOMPATIBLE_POINTER_TYPES)\n      add_compile_options(\"$<$<COMPILE_LANGUAGE:C>:-Wincompatible-pointer-types>\")\n    endif()\n\n  else()\n    message(WARNING \"Don't know how to forbid this compiler from allowing implicit function declarations.\")\n  endif()\n\nendif()\n\n\nset(MAJOR_VERSION 1)\nset(MINOR_VERSION 7)\nset(VERSION_SUFFIX_FIXED_TEXT \"-pre\")\nset(VERSION_SUFFIX \"${VERSION_SUFFIX_FIXED_TEXT}\")\nset(VERSION_STRING ${MAJOR_VERSION}.${MINOR_VERSION}${VERSION_SUFFIX})\nset(POCL_VERSION ${VERSION_STRING})\n\n# required b/c SHARED libs defaults to ON while OBJECT defaults to OFF\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\n\nenable_testing()\n\n#####################################################\n\nif(EXISTS \"${CMAKE_SOURCE_DIR}/.git\")\n  set(DEFAULT_BUILD_TYPE \"Debug\")\nelse()\n  set(DEFAULT_BUILD_TYPE \"RelWithDebInfo\")\nendif()\n\nif(NOT CMAKE_BUILD_TYPE)\n  message(STATUS \"Setting build type to '${DEFAULT_BUILD_TYPE}' as none was specified.\")\n  set(CMAKE_BUILD_TYPE \"${DEFAULT_BUILD_TYPE}\" CACHE\n      STRING \"Choose the type of build.\" FORCE)\n  # Set the possible values of build type for cmake-gui\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n    \"Debug\" \"Release\" \"MinSizeRel\" \"RelWithDebInfo\")\nendif()\n\n##################################################################################\n\nmacro(set_expr VAR)\n  if(${ARGN})\n    set(${VAR} 1)\n  else()\n    set(${VAR} 0)\n  endif()\nendmacro()\n\nfind_program(BASH \"bash\")\nfind_program(MAKE_PROGRAM NAMES \"make\")\nfind_program(GIT_CMD \"git\")\nset_expr(HAVE_GIT GIT_CMD)\n\nif(HAVE_GIT AND (VERSION_SUFFIX MATCHES \"pre\"))\n  execute_process(COMMAND \"${GIT_CMD}\" \"rev-parse\" \"HEAD\"\n                  OUTPUT_VARIABLE GIT_COMMIT\n                  RESULT_VARIABLE EXITCODE\n                  WORKING_DIRECTORY \"${CMAKE_SOURCE_DIR}\"\n                  OUTPUT_STRIP_TRAILING_WHITESPACE)\n  message(STATUS \"Pocl source Git commit: ${GIT_COMMIT}\")\n\n  execute_process(COMMAND \"${GIT_CMD}\" \"branch\" \"--contains\" \"${GIT_COMMIT}\"\n                  OUTPUT_VARIABLE GIT_BRANCH\n                  RESULT_VARIABLE EXITCODE\n                  WORKING_DIRECTORY \"${CMAKE_SOURCE_DIR}\"\n                  OUTPUT_STRIP_TRAILING_WHITESPACE)\n  message(STATUS \"Pocl source Git branch: ${GIT_BRANCH}\")\n\n  execute_process(COMMAND \"${GIT_CMD}\" describe \"--always\" \"--long\" \"--all\" \"${GIT_COMMIT}\"\n                  OUTPUT_VARIABLE GIT_DESCRIBE\n                  RESULT_VARIABLE EXITCODE\n                  WORKING_DIRECTORY \"${CMAKE_SOURCE_DIR}\"\n                  OUTPUT_STRIP_TRAILING_WHITESPACE)\n\n  string(REPLACE \"heads/\" \"\" GIT_DESCRIBE \"${GIT_DESCRIBE}\")\n  message(STATUS \"Pocl source Git describe: ${GIT_DESCRIBE}\")\n  set(VERSION_SUFFIX \"${VERSION_SUFFIX_FIXED_TEXT} ${GIT_DESCRIBE}\")\n  set(VERSION_STRING ${MAJOR_VERSION}.${MINOR_VERSION}${VERSION_SUFFIX})\n  set(POCL_VERSION ${VERSION_STRING})\nelse()\n  message(STATUS \"No git and/or not a prerelease -> not adding git commit to version.\")\nendif()\n\nset(CPACK_PACKAGE_NAME pocl)\nset(CPACK_PACKAGE_VENDOR pocl)\nset(CPACK_PACKAGE_VERSION_MAJOR \"${MAJOR_VERSION}\")\nset(CPACK_PACKAGE_VERSION_MINOR \"${MINOR_VERSION}\")\nset(CPACK_PACKAGE_VERSION \"${MAJOR_VERSION}.${MINOR_VERSION}~${VERSION_SUFFIX_FIXED_TEXT}\")\nif(HAVE_GIT)\n\tset(CPACK_PACKAGE_VERSION \"${CPACK_PACKAGE_VERSION}.${GIT_COMMIT}\")\nendif()\n\n##################################################################################\n\noption(OCS_AVAILABLE \"Online compiler support available to build pocl with. Default is available.\" ON)\n\noption(STATIC_LLVM \"If ON, link to static LLVM libraries. OFF (default) = link to shared LLVM libraries.\" OFF)\n\noption(BUILD_SHARED_LIBS \"ON=Build shared libs, OFF=static libs\" ON)\n\noption(POCL_DEBUG_MESSAGES\n  \"Enable debug messages from pocl (useful for OpenCL developers), must be enabled at runtime, with env var POCL_DEBUG\"\n  ON)\n\noption(ENABLE_HSA \"Enable the HSA base profile runtime device driver\" OFF)\n\noption(ENABLE_CUDA \"Enable the CUDA device driver for NVIDIA devices\" OFF)\n\noption(KERNEL_CACHE_DEFAULT \"Default value for the kernel compile cache. If disabled, pocl will still use the kernel cache, but will delete cachefiles on exit. You can still enable keeping the files it at runtime with an env var.\" ON)\n\noption(POCL_ICD_ABSOLUTE_PATH \"Use absolute path in pocl.icd\" ON)\n\noption(ENABLE_POCL_BUILDING \"When OFF, env var POCL_BUILDING has no effect. Defaults to ON\" ON)\n\noption(VISIBILITY_HIDDEN \"Build with -fvisibility=hidden -fvisibility-inlines-hidden\" OFF)\nif(VISIBILITY_HIDDEN)\n  add_compile_options(-fvisibility=hidden)\n  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:-fvisibility-inlines-hidden>)\nendif()\n\n#### these are mostly useful for pocl developers\n\noption(DEVELOPER_MODE \"This will SIGNIFICANTLY slow down pocl (but speed up its compilation). Only turn on if you know what you're doing.\" OFF)\n\noption(USE_POCL_MEMMANAGER \"Enables custom memory manager. Except for special circumstances, this should be disabled.\" OFF)\n\noption(EXAMPLES_USE_GIT_MASTER \"If enabled, some of the external testsuites in examples/ will try to use sources from Git master, instead of releases. This may result in failure to build or run the examples\" OFF)\n\noption(ENABLE_HOST_CPU_DEVICES \"Add host CPUs as OpenCL devices (basic and pthread).\" ON)\n\noption(ENABLE_HOST_CPU_DEVICE_CL20 \"Enable reporting OpenCL 2.0 for the CPU device\" OFF)\n\noption(ENABLE_ACCEL_DEVICE \"Enable the generic hardware accelerator device driver.\" OFF)\n\n####\n\n# currently only works with gcc as host compiler\nif (CMAKE_C_COMPILER_ID STREQUAL \"GNU\")\n  if (CMAKE_C_COMPILER_VERSION VERSION_GREATER \"4.7.99\")\n    option(ENABLE_ASAN \"Enable AddressSanitizer\" OFF)\n    option(ENABLE_TSAN \"Enable ThreadSanitizer\" OFF)\n  else()\n    set(ENABLE_ASAN OFF CACHE INTERNAL \"Enable AddressSanitizer\")\n    set(ENABLE_TSAN OFF CACHE INTERNAL \"Enable ThreadSanitizer\")\n  endif()\n\n  if (CMAKE_C_COMPILER_VERSION VERSION_GREATER \"4.8.99\")\n    option(ENABLE_UBSAN \"Enable UBSanitizer\" OFF)\n  else()\n    set(ENABLE_UBSAN OFF CACHE INTERNAL \"Enable UBSanitizer\")\n  endif()\n\n  if (CMAKE_C_COMPILER_VERSION VERSION_GREATER \"5.0.99\")\n    option(ENABLE_LSAN \"Enable LeakSanitizer\" OFF)\n  else()\n    set(ENABLE_LSAN OFF CACHE INTERNAL \"Enable LeakSanitizer\")\n  endif()\n\nelse()\n  set(ENABLE_ASAN OFF CACHE INTERNAL \"Enable AddressSanitizer\")\n  set(ENABLE_TSAN OFF CACHE INTERNAL \"Enable ThreadSanitizer\")\nendif()\n\n# Unfortunately the way CMake tests work, if they're given\n# a pass/fail expression, they don't check for exit status.\n# This was causing some false negatives with ASan (test was\n# returning with 1, but CMake reported it as pass because\n# the pass expression was present in output).\nif(ENABLE_ASAN OR ENABLE_TSAN OR ENABLE_UBSAN OR ENABLE_LSAN)\n  set(ENABLE_ANYSAN 1)\nendif()\n\n##########################################################\n\nif(CMAKE_SIZEOF_VOID_P EQUAL 8)\n  set(HOST_DEVICE_ADDRESS_BITS 64)\nelseif(CMAKE_SIZEOF_VOID_P EQUAL 4)\n  set(HOST_DEVICE_ADDRESS_BITS 32)\nelse()\n  message(FATAL_ERROR \"Cannot figure out HOST_DEVICE_ADDRESS_BITS\")\nendif()\n\n# printf buffer size, in KB\nif(NOT DEFINED PRINTF_BUFFER_SIZE)\n  set(PRINTF_BUFFER_SIZE 16384 CACHE STRING \"printf buffer size, in KB\")\nendif()\n\n##################################################################################\n\nif(CMAKE_SYSTEM_PROCESSOR MATCHES \"ppc64le\")\n  set(POWERPC 1)\n  set(POWERPC64LE 1)\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"ppc\")\n  set(POWERPC 1)\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"mips\")\n  set(MIPS 1)\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"(arm|aarch64)\")\n  set(ARM 1)\n  if(HOST_DEVICE_ADDRESS_BITS MATCHES \"32\")\n    set(ARM32 1)\n  else()\n    set(ARM64 1)\n  endif()\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"(i.86|AMD64|x86_64|amd64)\")\n  set(X86 1)\n  if(HOST_DEVICE_ADDRESS_BITS MATCHES \"32\")\n    set(I386 1)\n  else()\n    set(X86_64 1)\n  endif()\nendif()\n\nif(CMAKE_MAJOR_VERSION GREATER 2)\n  include(ProcessorCount)\n  ProcessorCount(CORECOUNT)\n  if(CORECOUNT LESS 1)\n    set(CORECOUNT 1)\n  endif()\nelse()\n  set(CORECOUNT 1)\nendif()\nmessage(STATUS \"Host CPU cores: ${CORECOUNT}\")\n\n######################################################################################\n\nfunction(rename_if_different SRC DST)\n  if(EXISTS \"${DST}\")\n    file(MD5 \"${SRC}\" OLD_MD5)\n    file(MD5 \"${DST}\" NEW_MD5)\n    if(NOT OLD_MD5 STREQUAL NEW_MD5)\n      file(RENAME \"${SRC}\" \"${DST}\")\n    endif()\n  else()\n    file(RENAME \"${SRC}\" \"${DST}\")\n  endif()\nendfunction()\n\n######################################################################################\n\n# Recent versions of CMake can make use of Ninja's console pool to avoid\n# buffering the output of particular commands.\nif(CMAKE_VERSION VERSION_LESS 3.2.0)\n  set(COMMAND_USES_TERMINAL)\nelse()\n  set(COMMAND_USES_TERMINAL USES_TERMINAL)\nendif()\n\nif(UNIX)\n  include(GNUInstallDirs)\nelse()\n  if (WIN32)\n    set(${CMAKE_INSTALL_LIBDIR} \"lib\")\n    set(${CMAKE_INSTALL_DATADIR} \"share\")\n    set(${CMAKE_INSTALL_INCLUDEDIR} \"include\")\n    set(${CMAKE_INSTALL_BINDIR} \"bin\")\n    message(STATUS \"Setting installation destination on Windows to: ${CMAKE_INSTALL_PREFIX}\")\n  else()\n    message(FATAL_ERROR \"System not UNIX nor WIN32 - not implemented yet\")\n  endif()\nendif()\n\n# for libpocl.so\nset(POCL_INSTALL_PUBLIC_LIBDIR \"${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}\" CACHE PATH \"POCL public libdir\")\n\n# for llvmopencl.so\nset(POCL_INSTALL_PRIVATE_LIBDIR \"${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}/pocl\" CACHE PATH \"POCL private libdir\")\n\n# for pocl.icd\nif(UNIX AND (NOT CMAKE_CROSSCOMPILING) AND (CMAKE_INSTALL_PREFIX STREQUAL \"/usr\"))\n  set(POCL_INSTALL_ICD_VENDORDIR \"/etc/OpenCL/vendors\" CACHE PATH \"POCL ICD file destination\")\nelse()\n  set(POCL_INSTALL_ICD_VENDORDIR \"${CMAKE_INSTALL_PREFIX}/etc/OpenCL/vendors\" CACHE PATH \"POCL ICD file destination\")\nendif()\n\n# for kernel-<target>.bc\nset(POCL_INSTALL_PRIVATE_DATADIR \"${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}/pocl\" CACHE PATH \"POCL private datadir\")\n\n# for poclu.h\nset(POCL_INSTALL_PUBLIC_HEADER_DIR \"${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR}\" CACHE PATH \"POCL public header dir\")\n\n# for _kernel.h et al\nset(POCL_INSTALL_PRIVATE_HEADER_DIR \"${POCL_INSTALL_PRIVATE_DATADIR}/include\" CACHE PATH \"POCL private header dir\")\n\n# for pocl-standalone et al\nset(POCL_INSTALL_PUBLIC_BINDIR \"${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_BINDIR}\" CACHE PATH \"POCL public bindir\")\n\n# for PoclConfig.cmake & stuff\nset(POCL_INSTALL_CMAKE_CONFIG_DIR \"${POCL_INSTALL_PRIVATE_LIBDIR}\" CACHE PATH   \"Installation directory for CMake files\")\n\n# TODO maybe use output of pkg-config --variable=pc_path pkg-config ?\nset(POCL_INSTALL_PKGCONFIG_DIR \"${POCL_INSTALL_PUBLIC_LIBDIR}/pkgconfig\" CACHE PATH \"Destination for pocl.pc\")\n\nif(APPLE)\n  set(CMAKE_MACOSX_RPATH ON)\n  set(POCL_INSTALL_OPENCL_HEADER_DIR \"${POCL_INSTALL_PUBLIC_HEADER_DIR}/OpenCL\" CACHE PATH \"POCL header dir for OpenCL headers\")\nelse()\n  set(POCL_INSTALL_OPENCL_HEADER_DIR \"${POCL_INSTALL_PUBLIC_HEADER_DIR}/CL\" CACHE PATH \"POCL header dir for OpenCL headers\")\nendif()\n\n######################################################################################\n\n\n######################################################################################\n\nset(CMAKE_MODULE_PATH \"${CMAKE_SOURCE_DIR}/cmake\")\noption(HARDENING_ENABLE \"Enable hardening against various attacks. May worsen performance\" OFF)\nif(HARDENING_ENABLE)\n  include(Hardening)\nelse()\n  function(harden target)\n  endfunction()\nendif()\n\nif(UNIX AND (NOT CMAKE_CROSSCOMPILING))\n  find_package(PkgConfig MODULE REQUIRED)\n  find_package(Hwloc)\n\n  if(NOT Hwloc_FOUND)\n    message(WARNING \"hwloc package not found\")\n  else()\n      if(\"${Hwloc_VERSION}\" VERSION_LESS \"1.0\")\n        message(FATAL_ERROR \"Hwloc version must be >= 1.0 !\")\n      endif()\n\n      message(STATUS \"Hwloc_VERSION ${Hwloc_VERSION}\")\n      message(STATUS \"Hwloc_LDFLAGS ${Hwloc_LDFLAGS}\")\n      message(STATUS \"Hwloc_CFLAGS ${Hwloc_CFLAGS}\")\n\n      set(ENABLE_HWLOC ON CACHE BOOL \"Hwloc\" FORCE)\n  endif()\n\nelse()\n\n  message(STATUS \"Not on UNIX or cross-compiling -> building without HWLOC\")\n  set(ENABLE_HWLOC OFF CACHE BOOL \"Hwloc\" FORCE)\n\nendif()\n\n\n\n\n\n######################################################################################\n\nif(NOT HOST_CPU_CACHELINE_SIZE)\n\n  set(CL_SIZE 0)\n  if(UNIX)\n    find_program(GETCONF \"getconf\")\n    if(GETCONF)\n      execute_process(COMMAND \"getconf\" \"LEVEL1_DCACHE_LINESIZE\"\n                      RESULT_VARIABLE RES OUTPUT_VARIABLE CL_SIZE)\n      if(RES)\n        message(WARNING \"getconf exited with nonzero status!\")\n        set(CL_SIZE 0)\n      else()\n        # getconf sometimes just returns zero\n        if(NOT (CL_SIZE EQUAL 0))\n          string(STRIP \"${CL_SIZE}\" CL_SIZE)\n          message(STATUS \"L1D Cacheline size detected: ${CL_SIZE}\")\n          set(HOST_CPU_CACHELINE_SIZE \"${CL_SIZE}\" CACHE STRING \"L1D Cacheline size\")\n        endif()\n      endif()\n    endif()\n  endif()\n\n  if(CL_SIZE EQUAL 0)\n    message(WARNING \"Unable to detect cacheline size - assuming 64byte cacheline, override with -DHOST_CPU_CACHELINE_SIZE=<number> (Note: this is merely used for optimization, at worst pocl will be slightly slower)\")\n    set(HOST_CPU_CACHELINE_SIZE \"64\" CACHE STRING \"L1D Cacheline size\")\n  endif()\nendif()\n\n######################################################################################\n#\n# Find executables to few tools required during build\n#\n\nfind_program(PATCH_EXEC\n  NAMES patch${CMAKE_EXECUTABLE_SUFFIX}\n  HINTS ENV PATH\n)\n\nfind_program(XARGS_EXEC\n  NAMES xargs${CMAKE_EXECUTABLE_SUFFIX}\n  HINTS ENV PATH\n)\n\nif(NOT PATCH_EXEC)\n  message(FATAL_ERROR \"Could not find patch command.\")\nendif()\n\nif(NOT XARGS_EXEC)\n  message(FATAL_ERROR \"Could not find xargs command.\")\nendif()\n\n######################################################################################\n\nif (OCS_AVAILABLE)\n\n  include(LLVM RESULT_VARIABLE RES)\n  if(NOT RES)\n    message(FATAL_ERROR \"Could not load LLVM.cmake\")\n  endif()\n\n  if(ENABLE_HOST_CPU_DEVICES)\n  if(NOT DEFINED HOST_DEVICE_BUILD_HASH)\n    if(KERNELLIB_HOST_CPU_VARIANTS STREQUAL \"distro\")\n      set(HOST_DEVICE_BUILD_HASH \"${LLC_TRIPLE}\")\n    else()\n      set(HOST_DEVICE_BUILD_HASH \"${LLC_TRIPLE}-${LLC_HOST_CPU}\")\n    endif()\n  endif()\n\n  if(INTEL_SDE_AVX512)\n    set(HOST_CPU_FORCED 1 CACHE INTERNAL \"CPU is forced by user\" FORCE)\n    set(LLC_HOST_CPU \"skylake-avx512\" CACHE STRING \"The Host CPU to use with llc\" FORCE)\n  endif()\n  endif()\n\nelse()\n\n  if(ENABLE_HOST_CPU_DEVICES AND (NOT DEFINED HOST_DEVICE_BUILD_HASH))\n    message(FATAL_ERROR \"For compiler-less builds of CPU backend, you must define HOST_DEVICE_BUILD_HASH\")\n  endif()\n\nendif()\n\n######################################################################################\n\nif(ENABLE_HSA)\n  include(HSA RESULT_VARIABLE RES)\n  if(NOT RES)\n    message(FATAL_ERROR \"Could not load HSA.cmake\")\n  endif()\nendif()\n\n######################################################################################\n\nif (NOT MSVC)\n  find_program(LINK_COMMAND\n    NAMES ld${CMAKE_EXECUTABLE_SUFFIX}\n    HINTS ENV PATH\n  )\nelse()\n    set(LINK_COMMAND \"${CLANGXX}\")\nendif()\n\n######################################################################################\n\n# if variable FEATURE_X isn't defined, sets it to DEFAULT_FEATURE_X;\n# also, if DEFAULT_FEATURE_X is 0, prevents FEATURE_X being 1\n# since it takes DEFAULT_FEATURE_X=0 to mean \"FEATURE_X is unavailable\"\nmacro(setup_cached_var VARNAME DESCRIPTION DOCS_FEATURE_IS_UNAVAILABLE DOCS_REQUESTED_DISABLING_FEATURE)\n\n  if(DEFINED ${VARNAME})\n    set(_CACHED \"(cached)\")\n  else()\n    set(_CACHED \"\")\n    set(${VARNAME} ${DEFAULT_${VARNAME}})\n  endif()\n\n  if(${VARNAME} AND (NOT ${DEFAULT_${VARNAME}}))\n    message(WARNING \"${DOCS_FEATURE_IS_UNAVAILABLE}\")\n    set(${VARNAME} 0)\n    set(_CACHED \"(override)\")\n  endif()\n  if((NOT ${VARNAME}) AND ${DEFAULT_${VARNAME}} )\n    message(STATUS \"${DOCS_REQUESTED_DISABLING_FEATURE}\")\n  endif()\n  if(${VARNAME})\n    message(STATUS \"${DESCRIPTION} ${_CACHED}: 1\")\n  else()\n    message(STATUS \"${DESCRIPTION} ${_CACHED}: 0\")\n  endif()\nendmacro()\n\n######################################################################################\n\nif(UNIX)\n  include(CheckCSourceCompiles)\n  include(CheckSymbolExists)\n\n  # don't allow implicit function declarations\n  set(CMAKE_REQUIRED_FLAGS \"-std=c99 ${FORBIT_IMPLICIT_FUNCTIONS}\")\n  if (CMAKE_SYSTEM_NAME MATCHES \"Linux\")\n    set(CMAKE_REQUIRED_LIBRARIES \"rt\")\n  endif ()\n\n  CHECK_SYMBOL_EXISTS(\"fork\"\n                      \"sys/types.h;unistd.h\"\n                      HAVE_FORK)\n\n  CHECK_SYMBOL_EXISTS(\"fsync\"\n                      \"unistd.h\"\n                      HAVE_FSYNC)\n\n  CHECK_SYMBOL_EXISTS(\"sleep\"\n                      \"unistd.h\"\n                      HAVE_SLEEP)\n\n  CHECK_SYMBOL_EXISTS(\"getrlimit\"\n                      \"sys/time.h;sys/resource.h\"\n                      HAVE_GETRLIMIT)\n\n  CHECK_SYMBOL_EXISTS(\"utime\"\n                      \"sys/types.h;utime.h\"\n                      HAVE_UTIME)\n\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D_POSIX_C_SOURCE=200809L\")\n  CHECK_SYMBOL_EXISTS(\"futimens\"\n                      \"fcntl.h;sys/stat.h\"\n                      HAVE_FUTIMENS)\n\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D_POSIX_C_SOURCE=200112L\")\n  CHECK_SYMBOL_EXISTS(\"posix_memalign\"\n                      \"stdlib.h\"\n                      HAVE_POSIX_MEMALIGN)\n\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D_POSIX_C_SOURCE=199309L\")\n  CHECK_SYMBOL_EXISTS(\"clock_gettime\"\n                      \"time.h\"\n                      HAVE_CLOCK_GETTIME)\n\n  CHECK_SYMBOL_EXISTS(\"fdatasync\"\n                      \"unistd.h\"\n                      HAVE_FDATASYNC)\n\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D_BSD_SOURCE\" \"-D_DEFAULT_SOURCE\")\n  CHECK_SYMBOL_EXISTS(\"mkdtemp\"\n                      \"stdlib.h;unistd.h\"\n                      HAVE_MKDTEMP)\n\n  CHECK_SYMBOL_EXISTS(\"mkstemps\"\n                      \"stdlib.h;unistd.h\"\n                      HAVE_MKSTEMPS)\n\n  CHECK_SYMBOL_EXISTS(\"vfork\"\n                      \"sys/types.h;unistd.h\"\n                      HAVE_VFORK)\n\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D_GNU_SOURCE\")\n  CHECK_SYMBOL_EXISTS(\"mkostemps\"\n                      \"stdlib.h\"\n                      HAVE_MKOSTEMPS)\n\n  set(CMAKE_REQUIRED_LIBRARIES \"dl\")\n  CHECK_SYMBOL_EXISTS(\"dladdr\"\n                      \"dlfcn.h\"\n                      HAVE_DLADDR)\n\n  unset(CMAKE_REQUIRED_DEFINITIONS)\n  unset(CMAKE_REQUIRED_FLAGS)\n  unset(CMAKE_REQUIRED_LIBRARIES)\n\nelse()\n  set(HAVE_CLOCK_GETTIME 0)\n  set(HAVE_FDATASYNC 0)\n  set(HAVE_FSYNC 0)\n  set(HAVE_SLEEP 0)\n  set(HAVE_MKOSTEMPS 0)\n  set(HAVE_MKSTEMPS 0)\n  set(HAVE_MKDTEMP 0)\n  set(HAVE_FUTIMENS 0)\n  set(HAVE_FORK 0)\n  set(HAVE_GETRLIMIT 0)\n  set(HAVE_VFORK 0)\n  set(HAVE_UTIME 0)\n  set(HAVE_DLADDR 0)\nendif()\n\n######################################################################################\n\nif(UNIX AND OCS_AVAILABLE AND HAVE_DLADDR)\n    option(ENABLE_RELOCATION \"make libpocl relocatable\" ON)\nelse()\n    message(STATUS \"Relocation not available\")\n    set(ENABLE_RELOCATION OFF CACHE INTERNAL \"libpocl relocatable\" FORCE)\nendif()\n\nif(ENABLE_RELOCATION)\n  file(RELATIVE_PATH POCL_INSTALL_PRIVATE_DATADIR_REL ${POCL_INSTALL_PUBLIC_LIBDIR} ${POCL_INSTALL_PRIVATE_DATADIR})\n  message(STATUS \"Private Datadir Relative path: ${POCL_INSTALL_PRIVATE_DATADIR_REL}\")\n  install(FILES ${CLANG_OPENCL_HEADERS}\n          DESTINATION \"${POCL_INSTALL_PRIVATE_DATADIR}/include\" COMPONENT \"dev\")\nendif()\n\nfile(RELATIVE_PATH POCL_INSTALL_PRIVATE_LIBDIR_REL ${POCL_INSTALL_PUBLIC_LIBDIR} ${POCL_INSTALL_PRIVATE_LIBDIR})\n\n######################################################################################\n\noption(ENABLE_SLEEF \"Use SLEEF for kernel library\" ON)\n\noption(ENABLE_CONFORMANCE \"Enable conformance to OpenCL standard. Disabling this may enable slightly faster kernel library functions (at a price of range/precision). Note that enabling this does not guarantee conformance (depends on hardware)\" ON)\n\nif(ENABLE_CONFORMANCE AND (NOT ENABLE_SLEEF))\n  message(FATAL_ERROR \"conformance needs enabled SLEEF\")\nendif()\n\n######################################################################################\n\n# fully device-side printf on devices which support it (only CPU backend ATM), disabled by default.\n# this requires 128bit integer support because of the code in \"errol\" float-to-string conversion routine\n# the output is not 100% compatible with glibc's printf (%f with large argument prints zeroes after\n# last significant digit - 16-18th digit or so, unlike glibc which prints digits up to decimal point).\nif(CLANG_HAS_128B_MATH)\n  option(ENABLE_POCL_FLOAT_CONVERSION \"Enable use of pocl's own float-to-decimal conversion code in OpenCL printf(). Defaults to OFF (uses snprintf from C library). Requires compiler-rt.\" OFF)\nelse()\n  set(ENABLE_POCL_FLOAT_CONVERSION OFF CACHE INTERNAL \"pocl's own float-to-decimal conversion code\")\nendif()\n\nunset(FLOATCONV_FLAG)\nif(ENABLE_POCL_FLOAT_CONVERSION)\n  # force link with Clang; otherwise not needed on x86 but in this case we need rtlib\n  set(FLOATCONV_FLAG \"-DENABLE_POCL_FLOAT_CONVERSION\")\nendif()\n\n######################################################################################\n\n# for kernel code, disable PIC & stack protector\n#\n# it seems PIC and stack-protector defaults somehow depend on\n# clang build type or environment. PIC causes problems with\n# constant addrspace variables, and stack protector likely slows\n# down the kernels, so it needs to be determined whether it's worth\n# the trouble.\nset(DEFAULT_KERNEL_CL_FLAGS  \"-xcl -fno-stack-protector -fPIC ${FLOATCONV_FLAG}\")\nset(DEFAULT_KERNEL_C_FLAGS \"-xc -std=c11 -D__CBUILD__ -fno-math-errno -fno-stack-protector -fPIC ${FLOATCONV_FLAG}\")\nset(DEFAULT_KERNEL_CXX_FLAGS \"-xc++ -std=c++11 -fno-stack-protector -fPIC ${FLOATCONV_FLAG}\")\n\nset(EXTRA_KERNEL_FLAGS \"\" CACHE STRING \"Extra arguments to all kernel compilation commands (defaults to empty)\")\nset(EXTRA_KERNEL_CL_FLAGS \"\" CACHE STRING \"Extra arguments to kernel CL compiler (defaults to empty)\")\nset(EXTRA_KERNEL_CXX_FLAGS \"\" CACHE STRING \"Extra arguments to kernel CXX compiler (defaults to empty)\")\nset(EXTRA_KERNEL_C_FLAGS \"\" CACHE STRING \"Extra arguments to kernel C compiler (defaults to empty)\")\n\nset(KERNEL_CXX_FLAGS \"${DEFAULT_KERNEL_CXX_FLAGS}${EXTRA_KERNEL_FLAGS}${EXTRA_KERNEL_CXX_FLAGS}\")\nset(KERNEL_CL_FLAGS \"${DEFAULT_KERNEL_CL_FLAGS}${EXTRA_KERNEL_FLAGS}${EXTRA_KERNEL_CL_FLAGS}\")\nset(KERNEL_C_FLAGS \"${DEFAULT_KERNEL_C_FLAGS}${EXTRA_KERNEL_FLAGS}${EXTRA_KERNEL_C_FLAGS}\")\n\n######################################################################################\n\nif(UNIX)\n  if(APPLE)\n    # MacOS ld outputs useless warnings like\n    # ld: warning: -macosx_version_min not specificed, assuming 10.7\n    # suppress them with -w.\n    set(DEFAULT_HOST_LD_FLAGS \"-dynamiclib -w -lm\")\n  elseif(ANDROID)\n    set(DEFAULT_HOST_LD_FLAGS \"-L/system/lib/ -shared -ldl -lc /system/lib/crtbegin_so.o /system/lib/crtend_so.o\")\n  else()\n    set(DEFAULT_HOST_LD_FLAGS \"-shared\")\n  endif()\n  set(LIBMATH \"-lm\")\nelseif(WIN32)\n  set(LIBMATH)\nendif()\n\nif(CLANG_NEEDS_RTLIB)\n  set(DEFAULT_HOST_LD_FLAGS \"${DEFAULT_HOST_LD_FLAGS} --rtlib=compiler-rt\")\nendif()\n\n######################################################################################\n\nif(UNIX)\n  if(APPLE)\n    # TODO MACOSX_BUNDLE target prop\n    set(ICD_LD_FLAGS \"-single_module\")\n  else()\n    set(ICD_LD_FLAGS \"-Wl,-Bsymbolic\")\n  endif()\nendif()\n\n######################################################################################\n\nset(SPIRV OFF)\n\nif(OCS_AVAILABLE AND X86 AND (NOT KERNELLIB_HOST_CPU_VARIANTS STREQUAL \"distro\"))\n  option(ENABLE_SPIR \"Enable SPIR support (default ON when available)\" ON)\nelse()\n  set(ENABLE_SPIR OFF CACHE INTERNAL \"SPIR enabled\" FORCE)\nendif()\n\nif(ENABLE_SPIR)\n\n  message(WARNING \"SPIR support is available but highly experimental; use at your own risk.\")\n\n  if(LLVM_SPIRV AND (EXISTS \"${LLVM_SPIRV}\"))\n    message(WARNING \"SPIR-V support enabled but highly experimental; you must use a llvm-spirv \"\n      \"converter that produces bitcode FOR YOUR LLVM VERSION. \"\n      \"E.g. if you're compiling pocl against LLVM 5 then using Khronos' \"\n      \"llvm-spirv based on LLVM 3.6 branch WILL NOT WORK.\")\n    set(SPIRV ON)\n  endif()\n\nendif()\n\nset(ENABLE_SPIRV ${SPIRV} CACHE INTERNAL \"SPIR-V enabled\" FORCE)\n\n\n\n######################################################################################\n\nadd_definitions(-DCL_USE_DEPRECATED_OPENCL_1_0_APIS -DCL_USE_DEPRECATED_OPENCL_1_1_APIS\n                -DCL_USE_DEPRECATED_OPENCL_1_2_APIS -DCL_USE_DEPRECATED_OPENCL_2_0_APIS\n                -DCL_USE_DEPRECATED_OPENCL_2_1_APIS )\n\nadd_definitions(-DCL_TARGET_OPENCL_VERSION=220)\n\ncpack_add_component(\"dev\")\n\ninclude_directories(\"include\")\n\n######################################################################################\n\nset(HAVE_LIBDL OFF CACHE BOOL \"dlopen\" FORCE)\n\nif(WIN32)\n  message(STATUS \"Using LoadLibrary/FreeLibrary in Windows, libltdl not needed.\")\n\nelseif(UNIX)\n\n  if (CMAKE_CROSSCOMPILING AND (NOT ENABLE_HOST_CPU_DEVICES) AND (NOT ENABLE_HSA))\n    message(STATUS \"Cross-compiling without CPU/HSA devices -> skipping LIBDL search\")\n  else()\n\n    find_library(DL_LIB \"dl\")\n    find_file(DL_H \"dlfcn.h\")\n    if(DL_LIB AND DL_H)\n      message(STATUS \"libdl found\")\n\n      get_filename_component(DL_H_INCLUDE_DIR \"${DL_H}\" DIRECTORY)\n      string(FIND \"${CMAKE_C_IMPLICIT_INCLUDE_DIRECTORIES}\" \"${DL_H_INCLUDE_DIR}\" LTPOSITION)\n      # include the directory of dlfcn.h, if its not in the default system include dirs\n      # also when cross-compiling this includes <cross-compile-root>/usr/include, which screws things up\n      if((LTPOSITION LESS \"0\") AND (NOT CMAKE_CROSSCOMPILING))\n        include_directories(\"${DL_H_INCLUDE_DIR}\")\n      endif()\n      set(HAVE_LIBDL ON CACHE BOOL \"dlopen\" FORCE)\n    else()\n      message(FATAL_ERROR \"Could not find DL library!\")\n    endif()\n  endif()\n\nelse()\n  message(STATUS \"Unknown OS, don't know how to load a dynamic library\")\nendif()\n\n######################################################################################\n\nset(CMAKE_THREAD_PREFER_PTHREAD TRUE)\nset(THREADS_PREFER_PTHREAD_FLAG TRUE)\nfind_package(Threads REQUIRED)\n\nif(CMAKE_VERSION VERSION_GREATER \"3.0.99\")\n  set(PTHREAD_LIBRARY Threads::Threads)\nelse()\n  set(PTHREAD_LIBRARY ${CMAKE_THREAD_LIBS_INIT})\nendif()\n\n######################################################################################\n# LTTNG\n\nif((NOT MSVC) AND (NOT ANDROID))\n  pkg_check_modules(LTTNG_UST lttng-ust>=2.7)\n  if(LTTNG_UST_FOUND)\n    set(HAVE_LTTNG_UST 1)\n  else()\n    set(HAVE_LTTNG_UST 0)\n  endif()\nendif()\n\n######################################################################################\n\nif(NOT DEFINED DEFAULT_ENABLE_ICD)\n\nif (MSVC)\n  message(STATUS \"Building ICD not yet supported on Windows.\")\n  set(DEFAULT_ENABLE_ICD 0 CACHE INTERNAL \"Going to use ICD loader\")\n\nelse()\n\n  # pkg-config doesn't work with cross-compiling\n  if (NOT CMAKE_CROSSCOMPILING)\n    pkg_check_modules(OCL_ICD ocl-icd>=1.3)\n  endif()\n\n  if (CMAKE_CROSSCOMPILING OR (NOT OCL_ICD_FOUND))\n    find_path(OCL_ICD_INCLUDE_DIR\n      NAMES\n        ocl_icd.h\n    )\n    find_library(OCL_ICD_LIBRARIES\n      NAMES\n        OpenCL\n    )\n    if(OCL_ICD_INCLUDE_DIR AND OCL_ICD_LIBRARIES)\n      set(OCL_ICD_FOUND 1)\n    endif()\n  endif()\n\n\n  if(OCL_ICD_FOUND)\n\n    set(HAVE_OCL_ICD 1 CACHE INTERNAL \"ICL library is ocl-icd\")\n    set(OPENCL_FOUND 1 CACHE INTERNAL \"opencl ICD/library found\")\n    # duh, why doesn't ocl-icd set this in its .pc file ??\n    if (CMAKE_CROSSCOMPILING)\n      set(OPENCL_LIBRARIES \"${OCL_ICD_LIBRARIES}\" CACHE INTERNAL \"opencl ICD/library link flags\")\n    else()\n      separate_arguments(OCL_LDFLAGS UNIX_COMMAND \"${OCL_ICD_LDFLAGS}\")\n      list(APPEND OCL_LDFLAGS \"OpenCL\")\n      set(OPENCL_LIBRARIES \"${OCL_LDFLAGS}\" CACHE INTERNAL \"opencl ICD/library link flags\")\n    endif()\n    set(DEFAULT_ENABLE_ICD 1 CACHE INTERNAL \"ICD loader availability\")\n\n  else()\n\n    set(HAVE_OCL_ICD 0 CACHE INTERNAL \"ICL library is ocl-icd\")\n    unset (OPENCL_FOUND CACHE)\n\n    if (NOT CMAKE_CROSSCOMPILING)\n      # fallback to other ICD loaders\n      message(STATUS \"ocl-icd not found -> trying fallback ICD implementations\")\n      pkg_check_modules(OPENCL OpenCL>=1.2)\n      if(NOT OPENCL_FOUND)\n        find_library(OPENCL_LIBRARIES OpenCL)\n        # version check the found library\n        if(OPENCL_LIBRARIES)\n          set(CMAKE_REQUIRED_LIBRARIES \"${OPENCL_LIBRARIES}\")\n          include(CheckFunctionExists)\n          unset (OPENCL_FOUND CACHE)\n          CHECK_FUNCTION_EXISTS(\"clEnqueueFillImage\" OPENCL_FOUND)\n        endif()\n      endif()\n    endif()\n\n    if(OPENCL_FOUND)\n      # no ocl-icd, but libopencl\n      message(STATUS \"libOpenCL (unknown ICD loader) found\")\n      set(DEFAULT_ENABLE_ICD 1 CACHE INTERNAL \"ICD loader availability\")\n    else()\n      message(STATUS \"No ICD loader of any kind found (or its OpenCL version is <1.2)\")\n      # no ocl-icd, no libopencl\n      set(DEFAULT_ENABLE_ICD 0 CACHE INTERNAL \"no ICL loader found availability\")\n    endif()\n\n  endif()\n\nendif()\n\nendif()\n\nsetup_cached_var(ENABLE_ICD \"Using an ICD loader\"\n  \"Requested build with icd, but ICD loader not found! some examples will not work..\"\n  \"ICD loader found, but requested build without it\")\n\nif(ENABLE_ICD)\n  # only meaningful to link tests with ocl-icd\n  set(TESTS_USE_ICD ${HAVE_OCL_ICD})\n  set(POCL_LIBRARY_NAME \"pocl\")\nelse()\n  set(TESTS_USE_ICD 0)\n  set(POCL_LIBRARY_NAME \"OpenCL\")\nendif()\n\nmessage(STATUS \"Run tests with ICD: ${TESTS_USE_ICD}\")\n\n######################################################################################\n\nif(INSTALL_OPENCL_HEADERS)\n  message(STATUS \"Install POCL's OpenCL headers: ${INSTALL_OPENCL_HEADERS}\")\nelseif(DEFINED INSTALL_OPENCL_HEADERS AND NOT INSTALL_OPENCL_HEADERS)\n  message(STATUS \"Not installing OpenCL headers.\")\nelse() # Undefined = auto -> check\n  find_file(OPENCL_H opencl.h PATH_SUFFIXES CL OpenCL)\n  if(OPENCL_H)\n    message(STATUS \"OpenCL.h found, NOT installing our headers\")\n    set(IOH 0)\n  else()\n    message(STATUS \"OpenCL.h not found, installing our headers\")\n    set(IOH 1)\n  endif()\n  set(INSTALL_OPENCL_HEADERS ${IOH} CACHE BOOL \"Install POCL's OpenCL headers. (Ones from Khronos should be installed instead)\")\nendif()\n\n######################################################################################\n\noption(PEDANTIC \"Compile host library with stricter compiler flags.\" OFF)\nif(PEDANTIC)\n  add_compile_options(\"-Wno-unused-result\" \"-Werror\") # maybe \"-Wimplicit\"\nendif()\n\n######################################################################################\n\nset_expr(POCL_KERNEL_CACHE_DEFAULT KERNEL_CACHE_DEFAULT)\n\nstring(TIMESTAMP POCL_BUILD_TIMESTAMP \"%d%m%Y%H%M%S\")\nfile(WRITE \"${CMAKE_BINARY_DIR}/pocl_build_timestamp.h\" \"#define POCL_BUILD_TIMESTAMP \\\"${POCL_BUILD_TIMESTAMP}\\\"\")\n\n####################################################################\n\n# Host (basic/pthread) driver setup\n\nset(DEFAULT_HOST_CLANG_FLAGS \"${CLANG_TARGET_OPTION}${LLC_TRIPLE}\")\nset(DEFAULT_HOST_LLC_FLAGS \"-relocation-model=pic -mtriple=${LLC_TRIPLE}\")\n\nif(ARM)\n  option(ENABLE_FP64 \"Enable FP64 on ARM32 - if you have at least VFP support for doubles, you can leave it ON\" ON )\nelse()\n  set(ENABLE_FP64 ON CACHE INTERNAL \"FP64, always on except ARM\")\nendif()\n\nif(ARM32 OR (LLC_TRIPLE MATCHES \"^arm\"))\n  if(LLC_TRIPLE MATCHES \"gnueabihf\")\n    # hardfloat\n    set(DEFAULT_HOST_LLC_FLAGS \"${DEFAULT_HOST_LLC_FLAGS} -float-abi=hard\")\n    set(DEFAULT_HOST_CLANG_FLAGS \"${DEFAULT_HOST_CLANG_FLAGS} -mfloat-abi=hard\")\n    set(DEFAULT_HOST_AS_FLAGS \"${DEFAULT_HOST_AS_FLAGS} -mfloat-abi=hard\")\n  else()\n    # softfloat\n    set(HOST_FLOAT_SOFT_ABI 1)\n    set(DEFAULT_HOST_LLC_FLAGS \"${DEFAULT_HOST_LLC_FLAGS} -float-abi=soft\")\n    set(DEFAULT_HOST_CLANG_FLAGS \"${DEFAULT_HOST_CLANG_FLAGS} -mfloat-abi=soft\")\n    set(DEFAULT_HOST_AS_FLAGS \"${DEFAULT_HOST_AS_FLAGS} -mfloat-abi=soft\")\n  endif()\nendif()\n\nif(CL_DISABLE_HALF)\n  set(DEFAULT_HOST_CLANG_FLAGS \"${DEFAULT_HOST_CLANG_FLAGS} -D_CL_DISABLE_HALF\")\nendif()\n\nif(ENABLE_HOST_CPU_DEVICE_CL20)\n  set(HOST_DEVICE_CL_VERSION \"200\")\n  set(HOST_DEVICE_CL_STD \"2.0\")\n  set(HOST_DEVICE_CL_VERSION_MAJOR 2)\n  set(HOST_DEVICE_CL_VERSION_MINOR 0)\nelse()\n  set(HOST_DEVICE_CL_VERSION \"120\")\n  set(HOST_DEVICE_CL_STD \"1.2\")\n  set(HOST_DEVICE_CL_VERSION_MAJOR 1)\n  set(HOST_DEVICE_CL_VERSION_MINOR 2)\nendif()\n\n# define it here, b/c we'll need these both at runtime and buildtime\nif(X86 OR ARM)\n  set(HOST_DEVICE_EXTENSIONS \"cl_khr_byte_addressable_store cl_khr_global_int32_base_atomics cl_khr_global_int32_extended_atomics cl_khr_local_int32_base_atomics cl_khr_local_int32_extended_atomics cl_khr_3d_image_writes\")\nelse()\n  # set some conservative defaults\n  set(HOST_DEVICE_EXTENSIONS \"cl_khr_global_int32_base_atomics cl_khr_local_int32_base_atomics cl_khr_3d_image_writes\")\nendif()\n\nif(ENABLE_SPIR)\n  set(HOST_DEVICE_EXTENSIONS \"${HOST_DEVICE_EXTENSIONS} cl_khr_spir\")\n  set(DEFAULT_DEVICE_EXTENSIONS \"${DEFAULT_DEVICE_EXTENSIONS} cl_khr_spir\")\nendif()\n\nif(NOT CL_DISABLE_HALF)\n  set(HOST_DEVICE_EXTENSIONS \"${HOST_DEVICE_EXTENSIONS} cl_khr_fp16\")\n  set(DEFAULT_DEVICE_EXTENSIONS \"${DEFAULT_DEVICE_EXTENSIONS} cl_khr_fp16\")\nendif()\n\n# must not be defined in HOST_DEVICE_EXTENSIONS list, because\n# this extension doesn't exist in official extension list\n# there is \"cles_khr_int64\" which indicates int64 support for embedded profiles\nset(HOST_DEVICE_EXTENSION_DEFINES \"-Dcl_khr_int64\")\n\nif(X86)\n  set(HOST_DEVICE_EXTENSIONS \"${HOST_DEVICE_EXTENSIONS} cl_khr_fp64 cl_khr_int64_base_atomics cl_khr_int64_extended_atomics\")\nendif()\n\nif(ENABLE_FP64)\n  set(HOST_DEVICE_EXTENSIONS \"${HOST_DEVICE_EXTENSIONS} cl_khr_fp64\")\n  set(_CL_DISABLE_DOUBLE 0)\nelse()\n  set(_CL_DISABLE_DOUBLE 1)\nendif()\n\nset(TEMP_EXT \"${HOST_DEVICE_EXTENSIONS}\")\nseparate_arguments(TEMP_EXT)\nset(TEMP_CLEXT \"-Xclang -cl-ext=-all,\")\nforeach(EXT ${TEMP_EXT})\n  set(HOST_DEVICE_EXTENSION_DEFINES \"${HOST_DEVICE_EXTENSION_DEFINES} -D${EXT}\")\n  set(TEMP_CLEXT \"${TEMP_CLEXT}+${EXT},\")\nendforeach()\n\nset(HOST_DEVICE_EXTENSION_DEFINES \"${HOST_DEVICE_EXTENSION_DEFINES} ${TEMP_CLEXT}\")\n\nif(NOT DEFINED KERNELLIB_HOST_CPU_VARIANTS)\n  set(KERNELLIB_HOST_CPU_VARIANTS \"native\")\n# else TODO test cpu list for unknown values\nendif()\n\nset(KERNELLIB_HOST_DISTRO_VARIANTS 0)\nif(KERNELLIB_HOST_CPU_VARIANTS STREQUAL \"distro\")\n  if(HOST_CPU_FORCED)\n    message(FATAL_ERROR \"Cannot build with CPU autodetection distro variants build, and enforce LLC_HOST_CPU at the same time. Please pick one\")\n  endif()\n  if(X86_64 OR I386)\n    set(KERNELLIB_HOST_CPU_VARIANTS sse2 ssse3 sse41 avx avx_f16c avx_fma4 avx2 avx512)\n  elseif(POWERPC64LE)\n    set(KERNELLIB_HOST_CPU_VARIANTS pwr8 pwr9)\n  else()\n    message(FATAL_ERROR \"Don't know what CPU variants to use for kernel library on this platform.\")\n  endif()\n  set(KERNELLIB_HOST_DISTRO_VARIANTS 1)\nendif()\n\n####################################################################\n\nset(EXTRA_HOST_AS_FLAGS \"\" CACHE STRING \"Extra parameters to as for code generation in the host. (default: empty)\")\nset(EXTRA_HOST_LD_FLAGS \"\" CACHE STRING \"Extra parameter to compiler to generate loadable module. (default: empty)\")\nset(EXTRA_HOST_CLANG_FLAGS \"\" CACHE STRING \"Extra parameters to clang for host compilation. (default: empty)\")\nset(EXTRA_HOST_LLC_FLAGS \"\" CACHE STRING \"Extra parameters to llc for code generation in the host. (default: empty)\")\n\n####################################################################\n\nset(HOST_AS_FLAGS \"${DEFAULT_HOST_AS_FLAGS} ${EXTRA_HOST_AS_FLAGS}\")\nset(HOST_LD_FLAGS \"${DEFAULT_HOST_LD_FLAGS} ${EXTRA_HOST_LD_FLAGS}\" )\nstring(STRIP \"${HOST_LD_FLAGS}\" HOST_LD_FLAGS_STRIPPED)\nstring(REGEX REPLACE \"[\\r\\n\\t ]+\" \"\\\", \\\"\" HOST_LD_FLAGS_ARRAY \"${HOST_LD_FLAGS_STRIPPED}\")\n# string(REPLACE \"###, ###\" \" oo \\\", \\\" oo \" HOST_LD_FLAGS_ARRAY \"${HOST_LD_FLAGS_ARRAY_1}\")\n\nset(HOST_CLANG_FLAGS \"${DEFAULT_HOST_CLANG_FLAGS} ${EXTRA_HOST_CLANG_FLAGS}\")\nset(HOST_LLC_FLAGS \"${DEFAULT_HOST_LLC_FLAGS} ${EXTRA_HOST_LLC_FLAGS}\")\n\n# HSA and pthread drivers require basic driver\nif(ENABLE_HSA OR ENABLE_HOST_CPU_DEVICES)\n  set(BUILD_BASIC 1)\nendif()\n\nif(ENABLE_HOST_CPU_DEVICES)\n  set(OCL_TARGETS \"host\")\n  set(OCL_DRIVERS \"basic pthreads\")\n  # TODO OCL_KERNEL_TARGET -> CPU_TARGET_TRIPLE\n  # TODO OCL_KERNEL_TARGET_CPU -> OCL_KERNEL_TARGET_CPU\n  set(OCL_KERNEL_TARGET \"${LLC_TRIPLE}\") #The kernel target triplet.\n  set(OCL_KERNEL_TARGET_CPU \"${LLC_HOST_CPU}\") #The kernel target CPU variant.\n  set(BUILD_PTHREAD 1)\nendif()\n\n# The accel device could be built by default, but it's implemented in C++,\n# thus requires a C++ compiler, so let's not.\nif(ENABLE_ACCEL_DEVICE)\n  set(BUILD_BASIC 1)\n  set(BUILD_ACCEL 1)\n  set(OCL_DRIVERS \"${OCL_DRIVERS} accel\")\nendif()\n\nif(DEFINED EXTRA_OCL_TARGETS)\n  set(OCL_TARGETS \"${OCL_TARGETS} ${EXTRA_OCL_TARGETS}\")\nendif()\n\n\n####################################################################\n\n# Determine which device drivers to build.\n\nif(NOT DEFINED DEFAULT_ENABLE_TCE)\n\n  set(HAVE_TCE 0)\n  set(HAVE_TCEMC 0)\n\n  if (NOT WITH_TCE)\n    set(WITH_TCE ENV PATH)\n  endif()\n\n  # THESE are only used in makefile.am & scripts/pocl*\n  set(TCE_TARGET_CLANG_FLAGS \"\" CACHE STRING \"Extra parameters to Clang for TCE compilation.\")\n  set(TCE_TARGET_LLC_FLAGS \"\" CACHE STRING \"Extra parameters to LLVM's llc for TCE compilation.\")\n\n  find_program(TCE_CONFIG NAMES \"tce-config\" HINTS ${WITH_TCE})\n  find_program(TCECC NAMES \"tcecc\" HINTS ${WITH_TCE})\n  find_program(TTASIM NAMES \"ttasim\" HINTS ${WITH_TCE})\n\n  if(TCE_CONFIG AND TCECC AND TTASIM)\n\n    message(STATUS \"Found tcecc + tce-config + ttasim, testing setup\")\n\n    get_filename_component(TCE_BASEDIR \"${TCE_CONFIG}\" DIRECTORY)\n    find_library(TCE_LIBS \"tce\" HINTS \"${TCE_BASEDIR}/../lib\" ENV PATH)\n    if(NOT TCE_LIBS)\n      execute_process(COMMAND \"${TCE_CONFIG}\" --libs OUTPUT_VARIABLE TCE_LIBS RESULT_VARIABLE RESV1 OUTPUT_STRIP_TRAILING_WHITESPACE)\n    endif()\n    execute_process(COMMAND \"${TCE_CONFIG}\" --includes OUTPUT_VARIABLE TCE_INCLUDES RESULT_VARIABLE RESV2 OUTPUT_STRIP_TRAILING_WHITESPACE)\n    execute_process(COMMAND \"${TCE_CONFIG}\" --version OUTPUT_VARIABLE TCE_VERSION RESULT_VARIABLE RESV3 OUTPUT_STRIP_TRAILING_WHITESPACE)\n    execute_process(COMMAND \"${TCE_CONFIG}\" --cxxflags OUTPUT_VARIABLE TCE_CXXFLAGS RESULT_VARIABLE RESV4 OUTPUT_STRIP_TRAILING_WHITESPACE)\n    execute_process(COMMAND \"${TCE_CONFIG}\" --prefix OUTPUT_VARIABLE TCE_PREFIX RESULT_VARIABLE RESV5 OUTPUT_STRIP_TRAILING_WHITESPACE)\n    execute_process(COMMAND \"${TCE_CONFIG}\" --llvm-config OUTPUT_VARIABLE TCE_LLVM_CONFIG RESULT_VARIABLE RESV6 OUTPUT_STRIP_TRAILING_WHITESPACE)\n    execute_process(COMMAND \"${TTASIM}\" --help OUTPUT_VARIABLE TTASIM_HELP RESULT_VARIABLE RESV9)\n\n\n    if(NOT (LLVM_CONFIG STREQUAL TCE_LLVM_CONFIG))\n      message(WARNING \"tce-config returned llvm-config is ${TCE_LLVM_CONFIG} but LLVM_CONFIG given to pocl is ${LLVM_CONFIG}\")\n    endif()\n\n    if (RESV1 OR RESV2 OR RESV3 OR RESV4 OR RESV5)\n      message(WARNING \"tce-config: Nonzero exit status, disabling TCE\")\n    elseif (RESV9)\n      message(WARNING \"ttasim: Nonzero exit status, disabling TCE\")\n    else()\n\n    string(STRIP \"${TCE_LIBS}\" TCE_LIBS)\n    separate_arguments(TCE_LIBS)\n    string(STRIP \"${TCE_INCLUDES}\" TCE_INCLUDES)\n    separate_arguments(TCE_INCLUDES)\n    string(STRIP \"${TCE_CXXFLAGS}\" TCE_CXXFLAGS)\n    separate_arguments(TCE_CXXFLAGS)\n    string(STRIP \"${TCE_VERSION}\" TCE_VERSION)\n    string(STRIP \"${TCE_PREFIX}\" TCE_PREFIX)\n\n    set(TCE_LIBS \"${TCE_LIBS}\" CACHE INTERNAL \"tce-config --libs\")\n    set(TCE_INCLUDES \"${TCE_INCLUDES}\" CACHE INTERNAL \"tce-config --includes\")\n    set(TCE_VERSION \"${TCE_VERSION}\" CACHE INTERNAL \"tce-config --version\")\n    set(TCE_CXXFLAGS \"${TCE_CXXFLAGS}\" CACHE INTERNAL \"tce-config --cxxflags\")\n    set(TCE_PREFIX \"${TCE_PREFIX}\" CACHE INTERNAL \"tce-config --prefix\")\n\n    set(HAVE_TCE 1)\n    if(TCE_VERSION MATCHES \"trunk\")\n      set(HAVE_TCEMC 1)\n    endif()\n\n    endif()\n\n  else()\n    message(STATUS \"Failed to find tcecc or tce-config, disabling TCE\")\n  endif()\n\n  set(DEFAULT_ENABLE_TCE ${HAVE_TCE} CACHE INTERNAL \"TCE available\")\n  set(DEFAULT_ENABLE_TCEMC ${HAVE_TCEMC} CACHE INTERNAL \"TCEMC available\")\n\nendif()\n\nsetup_cached_var(ENABLE_TCE \"TCE support\"\n  \"Requested enabling TCE, but no usable TCE installation found !\"\n  \"TCE is available, but requested disabling it\")\n\nif(ENABLE_TCE)\n  set(OCL_DRIVERS \"${OCL_DRIVERS} tce\")\n  set(OCL_TARGETS \"${OCL_TARGETS} tce\")\n  if(DEFAULT_ENABLE_TCEMC)\n    set(ENABLE_TCEMC 1)\n    set(OCL_DRIVERS \"${OCL_DRIVERS} tcemc\") # TCEMC is a \"superset\" of TCE (lp:tce) features.\n  endif()\n  set(TCE_DEVICE_EXTENSIONS \"cl_khr_byte_addressable_store cl_khr_global_int32_base_atomics cl_khr_global_int32_extended_atomics cl_khr_local_int32_base_atomics cl_khr_local_int32_extended_atomics cl_khr_fp16 cl_khr_spir\")\n  set(TEMP_EXT \"${TCE_DEVICE_EXTENSIONS}\")\n  set(TCE_DEVICE_EXTENSION_DEFINES \"\")\n  separate_arguments(TEMP_EXT)\n  foreach(EXT ${TEMP_EXT})\n    set(TCE_DEVICE_EXTENSION_DEFINES \"${TCE_DEVICE_EXTENSION_DEFINES} -D${EXT}\")\n  endforeach()\n\n  set(TCE_DEVICE_CL_VERSION \"120\")\n  set(TCE_DEVICE_CL_STD \"1.2\")\n\n  if(\"${LLVM_CXXFLAGS}\" MATCHES \"-fno-rtti\")\n    message(WARNING \"TCE is enabled but your LLVM was not built with RTTI. You should rebuild LLVM with 'make REQUIRES_RTTI=1'. See the INSTALL file for more information.\")\n  endif()\n\nelse()\n  set(ENABLE_TCEMC 0)\nendif()\n\n##########################################################\n\nif(ENABLE_HSA)\n  set(OCL_DRIVERS \"${OCL_DRIVERS} hsa\")\n  if (HSAIL_ENABLED)\n    set(OCL_TARGETS \"${OCL_TARGETS} hsail64\")\n  endif()\n  # this is for config.h\n\n  set(HSA_DEVICE_EXTENSIONS \"cl_khr_byte_addressable_store cl_khr_global_int32_base_atomics cl_khr_global_int32_extended_atomics cl_khr_local_int32_base_atomics cl_khr_local_int32_extended_atomics cl_khr_fp64 cl_khr_int64_base_atomics cl_khr_int64_extended_atomics\")\n  set(HSA_DEVICE_CL_VERSION \"120\")\n  set(HSA_DEVICE_CL_STD \"1.2\")\n  find_path(HAVE_HSA_EXT_AMD_H \"hsa_ext_amd.h\" HINTS \"${HSA_INCLUDEDIR}\" ENV PATH)\nendif()\n\n##########################################################\n\nif(ENABLE_CUDA)\n\n  if(NOT \"${LLVM_ALL_TARGETS}\" MATCHES \"NVPTX\")\n    message(FATAL_ERROR \"CUDA build requested but LLVM does not support NVPTX target!\")\n  endif()\n\n  set(OCL_DRIVERS \"${OCL_DRIVERS} cuda\")\n  set(OCL_TARGETS \"${OCL_TARGETS} cuda\")\n  # this is for config.h\n  # TODO unify with autotools\n  set(BUILD_CUDA 1)\n\n  set(CUDA_DEVICE_EXTENSIONS \"cl_khr_byte_addressable_store cl_khr_global_int32_base_atomics cl_khr_global_int32_extended_atomics cl_khr_local_int32_base_atomics cl_khr_local_int32_extended_atomics cl_khr_fp64 cl_khr_int64_base_atomics cl_khr_int64_extended_atomics cl_nv_device_attribute_query\")\n  if(ENABLE_SPIR)\n    set(CUDA_DEVICE_EXTENSIONS \"${CUDA_DEVICE_EXTENSIONS} cl_khr_spir\")\n  endif()\n  set(CUDA_DEVICE_CL_VERSION \"120\")\n  set(CUDA_DEVICE_CL_STD \"1.2\")\nendif()\n\n##########################################################\n\nmessage(STATUS \"Building the following device drivers: ${OCL_DRIVERS}\")\n\nset(BUILDDIR \"${CMAKE_BINARY_DIR}\")\nset(SRCDIR \"${CMAKE_SOURCE_DIR}\")\n\n##########################################################\n\n# Checks for library features.\n\nif(NOT CMAKE_CROSSCOMPILING)\n  # AC_C_BIGENDIAN\n  include(TestBigEndian)\n  TEST_BIG_ENDIAN(WORDS_BIGENDIAN)\nelse()\n  # Set default as little-endian\n  set(WORDS_BIGENDIAN 0)\nendif()\n\n##########################################################\n\nif (OCS_AVAILABLE)\n  CHECK_ALIGNOF(\"double16\" \"typedef double double16  __attribute__((__ext_vector_type__(16)));\" ALIGNOF_DOUBLE16)\nelse()\n  set(ALIGNOF_DOUBLE16 128)\nendif()\n\nif(ALIGNOF_DOUBLE16 LESS 128)\n  set(ALIGNOF_DOUBLE16 128)\nendif()\n\nset(MAX_EXTENDED_ALIGNMENT \"${ALIGNOF_DOUBLE16}\")\n\n##########################################################\n\n\nstring(TOUPPER \"${CMAKE_BUILD_TYPE}\" BTYPE)\nif(\"${CMAKE_C_FLAGS_${BTYPE}}\" MATCHES \"DNDEBUG\")\n  set(POCL_ASSERTS_BUILD 0)\nelse()\n  set(POCL_ASSERTS_BUILD 1)\nendif()\n\n##########################################################\n\n\n# cmake docs:\n# SOVERSION: What version number is this target.\n\n# For shared libraries VERSION and SOVERSION can be used to specify the\n#  build version and API version respectively. When building or installing\n#  appropriate symlinks are created if the platform supports symlinks and\n#  the linker  supports so-names. If only one of both is specified the\n#  missing is assumed to have the same version number.\n#\n# For executables VERSION can be used to specify the build version.\n# SOVERSION is ignored if NO_SONAME property is set. For shared libraries\n# and executables on Windows the VERSION attribute is parsed to extract\n#  a \"major.minor\" version number. These numbers are used as the\n#  image version of the binary.\n\n# cmake usage:\n# SET_TARGET_PROPERTIES(pocl PROPERTIES SOVERSION 1.6.3 VERSION 4) ...\n\n\n\n# The libtool library version string to use (passed to -version-info).\n# See: http://www.nondot.org/sabre/Mirrored/libtool-2.1a/libtool_6.html\n# libpocl.so should get only API additions as we are implementing a standard.\n#\n# The library version encodings into the library file name are platform\n# dependent. Therefore we need to be a bit verbose here for the pocl.icd file\n# creation to succeed (see Makefile.am).\n# Chiefly, GNU differs from BSD, and others are untested. See e.g.\n# http://en.opensuse.org/openSUSE%3aShared_library_packaging_policy#Versioning_schemes\n#\n# 0:0:0 == 0.6\n# 1:0:0 == 0.7 (not backwards compatible with 0:0:0 due to the ICD)\n# 2:0:1 == 0.8 (currently backwards compatible with 0.7, thus age = 1).\n# 3:0:2 == 0.9 (currently backwards compatible with 0.7, thus age = 2).\n# 4:0:3 == 0.10 (currently backwards compatible with 0.7, thus age = 3).\n# 5:0:4 == 0.11 (currently backwards compatible with 0.7, thus age = 4).\n# 6:0:5 == 0.12 (currently backwards compatible with 0.7, thus age = 5).\n# 7:0:6 == 0.13 (currently backwards compatible with 0.7, thus age = 6).\n# 8:0:7 == 0.14 (currently backwards compatible with 0.7, thus age = 7).\n# pocl 1.0 bumped the API version:\n# 2:0:0 == 1.0 (the libpocl.so will be named libpocl.so.2.0.X )\n# 3:0:1 == 1.1 (the libpocl.so will be named libpocl.so.2.1.X )\n# 4:0:2 == 1.2 (the libpocl.so will be named libpocl.so.2.2.X )\n# 5:0:3 == 1.3 (the libpocl.so will be named libpocl.so.2.3.X )\n# 6:0:4 == 1.4 (the libpocl.so will be named libpocl.so.2.4.X )\n# 7:0:5 == 1.5 (the libpocl.so will be named libpocl.so.2.5.X )\n# 8:0:6 == 1.6 (the libpocl.so will be named libpocl.so.2.6.X )\n# 9:0:7 == 1.7 (the libpocl.so will be named libpocl.so.2.7.X )\n\nset(LIB_CURRENT_VERSION 9)\nset(LIB_REVISION_VERSION 0)\nset(LIB_AGE_VERSION 7)\n\nmath(EXPR LIB_FIRST_VERSION \"${LIB_CURRENT_VERSION} - ${LIB_AGE_VERSION}\")\n\n# libtool takes \"c:r:a\" arguments, but the result is \"<lib>.so.(c-a).a.r\"\n# cmake has \"build version\" and \"API version\"\n# these vars map libtool -> cmake\n# for set_target_properties\nset(LIB_BUILD_VERSION \"${LIB_FIRST_VERSION}.${LIB_AGE_VERSION}.${LIB_REVISION_VERSION}\")\nset(LIB_API_VERSION \"${LIB_FIRST_VERSION}\")\n\n# The kernel compiler opt plugin shared library, however, changes more\n# drastically. Let's try to follow the similar 'current' numbering as\n# the pocl host API library and perhaps tune the 'revision' and 'age' later.\n\nmath(EXPR KER_LIB_CURRENT_VERSION \"${LIB_CURRENT_VERSION} + 7\")\nset(KERNEL_COMPILER_LIB_VERSION \"${KER_LIB_CURRENT_VERSION}.0.0\")\n\n##########################################################\n\n#TODO\n# these vars are copies b/c tons of sources use BUILD_ICD etc\nset(BUILD_ICD ${ENABLE_ICD})\nset(BUILD_HSA ${ENABLE_HSA})\nset(TCE_AVAILABLE ${ENABLE_TCE})\nset(TCEMC_AVAILABLE ${ENABLE_TCEMC})\nset(_CL_DISABLE_HALF ${CL_DISABLE_HALF})\nset(PACKAGE_VERSION \"${POCL_VERSION}\")\n\nconfigure_file(\"config.h.in.cmake\" \"config.h.new\" ESCAPE_QUOTES)\nrename_if_different(\"${CMAKE_BINARY_DIR}/config.h.new\" \"${CMAKE_BINARY_DIR}/config.h\")\n\nconfigure_file(\"config2.h.in.cmake\" \"config2.h.new\")\nrename_if_different(\"${CMAKE_BINARY_DIR}/config2.h.new\" \"${CMAKE_BINARY_DIR}/config2.h\")\n\ninclude_directories(\"${CMAKE_BINARY_DIR}\")\n\n# This is used to generate the compiler feature detection header.\n# Currently it's not enabled because it requires CMake > 3.x and\n# also the autogenerated header needs some editing by hand\n# (it errors on all compilers except gcc > 4 and clang > 3)\n#\n#\n#include(WriteCompilerDetectionHeader)\n#write_compiler_detection_header(\n#  FILE \"${CMAKE_BINARY_DIR}/compiler_features.h\"\n#  PREFIX POCL\n#  COMPILERS GNU Clang\n#  FEATURES\n#    c_function_prototypes\n#    c_restrict\n#    c_static_assert\n#    c_variadic_macros\n#)\n\n##########################################################\n\nif(ENABLE_ICD)\n  if(POCL_ICD_ABSOLUTE_PATH)\n    set(CONTENT \"${POCL_INSTALL_PUBLIC_LIBDIR}/$<TARGET_FILE_NAME:pocl>\")\n  else()\n    set(CONTENT \"$<TARGET_FILE_NAME:pocl>\")\n  endif()\n  file(GENERATE OUTPUT \"${CMAKE_BINARY_DIR}/pocl.icd\" CONTENT \"${CONTENT}\" CONDITION 1)\n  install(FILES \"${CMAKE_BINARY_DIR}/pocl.icd\"\n         DESTINATION \"${POCL_INSTALL_ICD_VENDORDIR}\" COMPONENT \"icd\")\n\n  # write icd file for pocl testing\n  file(MAKE_DIRECTORY \"${CMAKE_BINARY_DIR}/ocl-vendors\")\n  file(GENERATE OUTPUT \"${CMAKE_BINARY_DIR}/ocl-vendors/pocl-tests.icd\" CONTENT \"$<TARGET_FILE:pocl>\" CONDITION 1)\n\n  cpack_add_component(\"icd\")\n  set(\"CPACK_DEBIAN_ICD_PACKAGE_NAME\" \"pocl-opencl-icd\")\n  list(APPEND CPACK_DEBIAN_ICD_PACKAGE_DEPENDS \"libpocl2 (>= ${CPACK_PACKAGE_VERSION}~)\")\n  set(CPACK_DEBIAN_ICD_PACKAGE_PROVIDES \"opencl-icd,opencl-icd-1.1-1,opencl-icd-1.2-1\")\n  set(CPACK_DEBIAN_ICD_PACKAGE_RECOMMENDS \"poclcc\")\nendif()\n\nif(ENABLE_ASAN OR ENABLE_LSAN)\n  file(GENERATE OUTPUT \"${CMAKE_BINARY_DIR}/lsan.supp\" CONTENT \"leak:${LLVM_SRC_ROOT}/lib/Support/Unix/Signals.inc\")\n  set(SAN_EXTRA \"set(ENV{LSAN_OPTIONS} \\\"suppressions=${CMAKE_BINARY_DIR}/lsan.supp\\\")\")\nendif()\n\nfile(GENERATE OUTPUT \"${CMAKE_BINARY_DIR}/CTestCustom.cmake\" CONTENT \"\n  ${SAN_EXTRA}\n  set(ENV{POCL_ENABLE_UNINIT} \\\"1\\\")\n  set(ENV{POCL_BUILDING} \\\"1\\\")\n  set(ENV{OCL_ICD_VENDORS} \\\"${CMAKE_BINARY_DIR}/ocl-vendors\\\")\n\")\n\n##########################################################\n\nif(UNIX)\n\n  configure_file(\"${CMAKE_SOURCE_DIR}/pocl.pc.in.cmake\" \"${CMAKE_BINARY_DIR}/pocl.pc\" @ONLY)\n  install(FILES \"${CMAKE_BINARY_DIR}/pocl.pc\"\n         DESTINATION \"${POCL_INSTALL_PKGCONFIG_DIR}\" COMPONENT \"dev\")\n\nendif()\n\n# For now always use a mirror copy of ocml, but allow overriding\n# this path later to point to an out-of-tree copy.\nset(OCML_SOURCE_DIR \"${CMAKE_SOURCE_DIR}/lib/kernel/ocml\")\n\n#############################################################\n\nadd_subdirectory(\"include\")\n\nadd_subdirectory(\"lib\")\n\n# these are set in lib/cmakelists.txt\nmessage(STATUS \"OPENCL_LIBS: ${OPENCL_LIBS}\")\nmessage(STATUS \"OPENCL_CFLAGS: ${OPENCL_CFLAGS}\")\n\n# for tests / examples\nset(POCLU_LINK_OPTIONS poclu ${OPENCL_LIBS} ${LIBMATH})\nmessage(STATUS \"POCLU LINK OPTS: ${POCLU_LINK_OPTIONS}\")\n\n# poclcc bin\nadd_subdirectory(\"bin\")\n\ninclude(add_test_pocl)\n\nadd_subdirectory(\"tests\")\nadd_subdirectory(\"examples\")\n\n# make check & make check_tier1\n\nadd_custom_target(check COMMAND ${CMAKE_CTEST_COMMAND} \"--output-on-failure\" -j ${CORECOUNT} ${COMMAND_USES_TERMINAL})\nadd_custom_target(check_tier1 COMMAND ${CMAKE_CTEST_COMMAND} \"--output-on-failure\" -L \"'internal|amdsdk_30|piglit|PyOpenCL|conformance_suite_micro|shoc'\" -j ${CORECOUNT} ${COMMAND_USES_TERMINAL})\n\nset(CPACK_PACKAGE_DESCRIPTION_FILE \"${CMAKE_SOURCE_DIR}/CPack.pocl.description.txt\")\nset(CPACK_PACKAGE_ICON \"${CMAKE_SOURCE_DIR}/doc/www/img/pocl-80x60.png\")\nset(CPACK_PACKAGE_HOMEPAGE_URL \"https://github.com/pocl/pocl\")\nset(CPACK_PACKAGE_CONTACT \"https://github.com/pocl/pocl\")\nset(CPACK_PACKAGE_CHECKSUM \"SHA512\")\nset(CPACK_RESOURCE_FILE_README \"${CMAKE_SOURCE_DIR}/README\")\nset(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_SOURCE_DIR}/COPYING\")\nset(CPACK_GENERATOR \"DEB\")\n\nset(\"CPACK_DEBIAN_DEV_PACKAGE_NAME\" \"libpocl-dev\")\nlist(APPEND CPACK_DEBIAN_DEV_PACKAGE_DEPENDS \"libpocl2 (>= ${CPACK_PACKAGE_VERSION}~)\")\nset(CPACK_DEBIAN_DEV_PACKAGE_BREAKS \"libpocl1-common (<< 0.13-9)\")\nset(CPACK_DEBIAN_DEV_PACKAGE_REPLACES \"libpocl1-common (<< 0.13-9)\")\n\nset(CPACK_RPM_COMPONENT_INSTALL ON)\nset(CPACK_DEB_COMPONENT_INSTALL ON)\n\ninclude(CPack)\n\n\n##########################################################\n\nMESSAGE(STATUS \" \")\nMESSAGE(STATUS \"*********************** SUMMARY ***************************\")\nMESSAGE(STATUS \" \")\nMESSAGE(STATUS \"******* Directories:\")\nMESSAGE(STATUS \" \")\n\nMESSAGE(STATUS \"CMAKE_INSTALL_PREFIX: ${CMAKE_INSTALL_PREFIX}\")\nMESSAGE(STATUS \"POCL_INSTALL_CMAKE_CONFIG_DIR: ${POCL_INSTALL_CMAKE_CONFIG_DIR}\")\nMESSAGE(STATUS \"POCL_INSTALL_ICD_VENDORDIR: ${POCL_INSTALL_ICD_VENDORDIR}\")\nMESSAGE(STATUS \"POCL_INSTALL_OPENCL_HEADER_DIR: ${POCL_INSTALL_OPENCL_HEADER_DIR}\")\nMESSAGE(STATUS \"POCL_INSTALL_PKGCONFIG_DIR: ${POCL_INSTALL_PKGCONFIG_DIR}\")\nMESSAGE(STATUS \"POCL_INSTALL_PRIVATE_DATADIR: ${POCL_INSTALL_PRIVATE_DATADIR}\")\nMESSAGE(STATUS \"POCL_INSTALL_PRIVATE_HEADER_DIR: ${POCL_INSTALL_PRIVATE_HEADER_DIR}\")\nMESSAGE(STATUS \"POCL_INSTALL_PRIVATE_LIBDIR: ${POCL_INSTALL_PRIVATE_LIBDIR}\")\nMESSAGE(STATUS \"POCL_INSTALL_PUBLIC_BINDIR: ${POCL_INSTALL_PUBLIC_BINDIR}\")\nMESSAGE(STATUS \"POCL_INSTALL_PUBLIC_HEADER_DIR: ${POCL_INSTALL_PUBLIC_HEADER_DIR}\")\nMESSAGE(STATUS \"POCL_INSTALL_PUBLIC_LIBDIR: ${POCL_INSTALL_PUBLIC_LIBDIR}\")\n\nMESSAGE(STATUS \" \")\n\nif (OCS_AVAILABLE)\n  MESSAGE(STATUS \" \")\n  MESSAGE(STATUS \"******* LLVM Programs:\")\n  MESSAGE(STATUS \" \")\n  MESSAGE(STATUS \"LLVM_CONFIG: ${LLVM_CONFIG}\")\n  MESSAGE(STATUS \"LLVM_OPT: ${LLVM_OPT}\")\n  MESSAGE(STATUS \"LLVM_LLC: ${LLVM_LLC}\")\n  MESSAGE(STATUS \"LLVM_AS: ${LLVM_AS}\")\n  MESSAGE(STATUS \"LLVM_LINK: ${LLVM_LINK}\")\n  MESSAGE(STATUS \"LLVM_LLI: ${LLVM_LLI}\")\n  MESSAGE(STATUS \"WITH_LLVM_CONFIG (User preferred llvm-config): ${WITH_LLVM_CONFIG}\")\nendif()\n\nMESSAGE(STATUS \" \")\nMESSAGE(STATUS \"******* Various Flags:\")\nMESSAGE(STATUS \" \")\n\nMESSAGE(STATUS \"CL_DISABLE_HALF: ${CL_DISABLE_HALF}\")\nMESSAGE(STATUS \"HAVE_CLOCK_GETTIME: ${HAVE_CLOCK_GETTIME}\")\nMESSAGE(STATUS \"HAVE_GLEW: ${HAVE_GLEW}\")\nMESSAGE(STATUS \"HAVE_LTTNG_UST: ${HAVE_LTTNG_UST}\")\nMESSAGE(STATUS \"HOST_AS_FLAGS: ${HOST_AS_FLAGS}\")\nMESSAGE(STATUS \"HOST_CLANG_FLAGS: ${HOST_CLANG_FLAGS}\")\nMESSAGE(STATUS \"HOST_LD_FLAGS: ${HOST_LD_FLAGS}\")\nMESSAGE(STATUS \"HOST_LLC_FLAGS: ${HOST_LLC_FLAGS}\")\nif (ENABLE_HSA)\n  MESSAGE(STATUS \"\")\n  MESSAGE(STATUS \"HSA_INCLUDES: ${HSA_INCLUDES}\")\n  MESSAGE(STATUS \"HSALIB: ${HSALIB}\")\n  MESSAGE(STATUS \"HSAIL_ASM: ${HSAIL_ASM}\")\nendif()\nMESSAGE(STATUS \"\")\nMESSAGE(STATUS \"LIB_API_VERSION: ${LIB_API_VERSION}\")\nMESSAGE(STATUS \"LIB_BUILD_VERSION: ${LIB_BUILD_VERSION}\")\nMESSAGE(STATUS \"ICD_LD_FLAGS: ${ICD_LD_FLAGS}\")\n\nMESSAGE(STATUS \"EXTRA_KERNEL_FLAGS: ${EXTRA_KERNEL_FLAGS}\")\nMESSAGE(STATUS \"EXTRA_KERNEL_CXX_FLAGS: ${EXTRA_KERNEL_CXX_FLAGS}\")\nMESSAGE(STATUS \"EXTRA_KERNEL_CL_FLAGS: ${EXTRA_KERNEL_CL_FLAGS}\")\nMESSAGE(STATUS \"EXTRA_KERNEL_C_FLAGS: ${EXTRA_KERNEL_C_FLAGS}\")\n\nMESSAGE(STATUS \"final KERNEL_CXX_FLAGS: ${KERNEL_CXX_FLAGS}\")\nMESSAGE(STATUS \"final KERNEL_CL_FLAGS: ${KERNEL_CL_FLAGS}\")\nMESSAGE(STATUS \"final KERNEL_C_FLAGS: ${KERNEL_C_FLAGS}\")\n\nif (OCS_AVAILABLE)\n  MESSAGE(STATUS \"\")\n  MESSAGE(STATUS \"CLANG_HAS_64B_MATH: ${CLANG_HAS_64B_MATH}\")\n  MESSAGE(STATUS \"CLANG_HAS_128B_MATH: ${CLANG_HAS_128B_MATH}\")\n  MESSAGE(STATUS \"CLANG_NEEDS_RTLIB: ${CLANG_NEEDS_RTLIB}\")\n  MESSAGE(STATUS \"CLANG_MARCH_FLAG: ${CLANG_MARCH_FLAG}\")\n  MESSAGE(STATUS \"CLANG_TARGET_OPTION: ${CLANG_TARGET_OPTION}\")\n  MESSAGE(STATUS \"LLVM_VERSION: ${LLVM_VERSION}\")\n  MESSAGE(STATUS \"LLVM_LIB_IS_SHARED: ${LLVM_LIB_IS_SHARED}\")\n  MESSAGE(STATUS \"LLVM_HAS_RTTI: ${LLVM_HAS_RTTI}\")\n  MESSAGE(STATUS \"LLVM_LIB_MODE: ${LLVM_LIB_MODE}\")\n  MESSAGE(STATUS \"LLVM_ASSERTS_BUILD: ${LLVM_ASSERTS_BUILD}\")\n  MESSAGE(STATUS \"LLVM_BUILD_MODE: ${LLVM_BUILD_MODE}\")\n  MESSAGE(STATUS \"LLVM_CFLAGS: ${LLVM_CFLAGS}\")\n  MESSAGE(STATUS \"LLVM_CXXFLAGS: ${LLVM_CXXFLAGS}\")\n  MESSAGE(STATUS \"LLVM_CPPFLAGS: ${LLVM_CPPFLAGS}\")\n  MESSAGE(STATUS \"LLVM_LDFLAGS: ${LLVM_LDFLAGS}\")\n  MESSAGE(STATUS \"LLVM_LIBDIR: ${LLVM_LIBDIR}\")\n  MESSAGE(STATUS \"LLVM_INCLUDEDIR: ${LLVM_INCLUDEDIR}\")\n  MESSAGE(STATUS \"LLVM_SRC_ROOT: ${LLVM_SRC_ROOT}\")\n  MESSAGE(STATUS \"LLVM_OBJ_ROOT: ${LLVM_OBJ_ROOT}\")\n  MESSAGE(STATUS \"LLVM_INCLUDE_DIRS: ${LLVM_INCLUDE_DIRS}\")\n  MESSAGE(STATUS \"LLVM_ALL_TARGETS: ${LLVM_ALL_TARGETS}\")\n  MESSAGE(STATUS \"LLVM_HOST_TARGET: ${LLVM_HOST_TARGET}\")\n  MESSAGE(STATUS \"LLC_TRIPLE: ${LLC_TRIPLE}\")\n  MESSAGE(STATUS \"LLC_HOST_CPU: ${LLC_HOST_CPU}\")\n  MESSAGE(STATUS \"\")\nendif()\nMESSAGE(STATUS \"MAX_EXTENDED_ALIGNMENT: ${MAX_EXTENDED_ALIGNMENT}\")\nMESSAGE(STATUS \"OCL_KERNEL_TARGET: ${OCL_KERNEL_TARGET}\")\nMESSAGE(STATUS \"OCL_KERNEL_TARGET_CPU: ${OCL_KERNEL_TARGET_CPU}\")\nMESSAGE(STATUS \"HOST_DEVICE_ADDRESS_BITS: ${HOST_DEVICE_ADDRESS_BITS}\")\nif (ENABLE_TCE)\n  MESSAGE(STATUS \"\")\n  MESSAGE(STATUS \"TCE_TARGET_CLANG_FLAGS: ${TCE_TARGET_CLANG_FLAGS}\")\n  MESSAGE(STATUS \"TCE_TARGET_LLC_FLAGS: ${TCE_TARGET_LLC_FLAGS}\")\n  MESSAGE(STATUS \"TCE_CXXFLAGS: ${TCE_CXXFLAGS}\")\n  MESSAGE(STATUS \"TCE_INCLUDES: ${TCE_INCLUDES}\")\n  MESSAGE(STATUS \"TCE_LIBS: ${TCE_LIBS}\")\n  MESSAGE(STATUS \"TCE_VERSION: ${TCE_VERSION}\")\n  MESSAGE(STATUS \"TCE_PREFIX: ${TCE_PREFIX}\")\nendif()\nMESSAGE(STATUS \"\")\n\nif (OCS_AVAILABLE)\nMESSAGE(STATUS \"----------- -------------------------------- --------\")\nMESSAGE(STATUS \"llvm libs libpocl will be linked to (POCL_LLVM_LIBS):\")\nMESSAGE(STATUS \"${POCL_LLVM_LIBS}\")\nMESSAGE(STATUS \"----------- -------------------------------- --------\")\nMESSAGE(STATUS \"clang libs libpocl will be linked to (CLANG_LIBFILES):\")\nMESSAGE(STATUS \"${CLANG_LIBFILES}\")\nMESSAGE(STATUS \"----------- -------------------------------- --------\")\nMESSAGE(STATUS \"system libs libpocl will be linked to (LLVM_SYSLIBS):\")\nMESSAGE(STATUS \"${LLVM_SYSLIBS}\")\nMESSAGE(STATUS \"----------- -------------------------------- --------\")\nendif()\n\nMESSAGE(STATUS \"******* Enabled features:\")\nMESSAGE(STATUS \" \")\n\nMESSAGE(STATUS \"DEVELOPER_MODE: ${DEVELOPER_MODE}\")\nMESSAGE(STATUS \"ENABLE_CONFORMANCE: ${ENABLE_CONFORMANCE}\")\nif(ARM)\nMESSAGE(STATUS \"ENABLE_FP64: ${ENABLE_FP64}\")\nendif()\nMESSAGE(STATUS \"ENABLE_ICD: ${ENABLE_ICD}\")\nMESSAGE(STATUS \"ENABLE_TCE: ${ENABLE_TCE}\")\nMESSAGE(STATUS \"ENABLE_TCEMC: ${ENABLE_TCEMC}\")\nMESSAGE(STATUS \"ENABLE_HSA: ${ENABLE_HSA}\")\nMESSAGE(STATUS \"ENABLE_CUDA: ${ENABLE_CUDA}\")\nMESSAGE(STATUS \"ENABLE_ASAN (address sanitizer): ${ENABLE_ASAN}\")\nMESSAGE(STATUS \"ENABLE_LSAN (leak sanitizer): ${ENABLE_LSAN}\")\nMESSAGE(STATUS \"ENABLE_TSAN (thread sanitizer): ${ENABLE_TSAN}\")\nMESSAGE(STATUS \"ENABLE_UBSAN (UB sanitizer): ${ENABLE_UBSAN}\")\nMESSAGE(STATUS \"ENABLE_POCL_FLOAT_CONVERSION: ${ENABLE_POCL_FLOAT_CONVERSION}\")\nMESSAGE(STATUS \"ENABLE_RELOCATION: ${ENABLE_RELOCATION}\")\nMESSAGE(STATUS \"ENABLE_SLEEF: ${ENABLE_SLEEF}\")\nMESSAGE(STATUS \"ENABLE_SPIR: ${ENABLE_SPIR}\")\nMESSAGE(STATUS \"ENABLE_SPIRV: ${ENABLE_SPIRV}\")\nMESSAGE(STATUS \"ENABLE_POCL_BUILDING: ${ENABLE_POCL_BUILDING}\")\nMESSAGE(STATUS \"INSTALL_OPENCL_HEADERS (Install our headers): ${INSTALL_OPENCL_HEADERS}\")\nMESSAGE(STATUS \"OCL_DRIVERS (Drivers built): ${OCL_DRIVERS}\")\nMESSAGE(STATUS \"OCL_TARGETS (Targets built): ${OCL_TARGETS}\")\nMESSAGE(STATUS \"OCS_AVAILABLE: ${OCS_AVAILABLE}\")\nMESSAGE(STATUS \"POCL_ICD_ABSOLUTE_PATH: ${POCL_ICD_ABSOLUTE_PATH}\")\nMESSAGE(STATUS \"POCL_ASSERTS_BUILD: ${POCL_ASSERTS_BUILD}\")\nMESSAGE(STATUS \"TESTS_USE_ICD: ${TESTS_USE_ICD}\")\nMESSAGE(STATUS \"Available testsuites: ${ALL_TESTSUITES}\")\nMESSAGE(STATUS \"Enabled testsuites: ${ACTUALLY_ENABLED_TESTSUITES}\")\nMESSAGE(STATUS \"Disabled testsuites: ${DISABLED_TESTSUITES}\")\nMESSAGE(STATUS \"Testsuites are built from git master: ${EXAMPLES_USE_GIT_MASTER}\")\nMESSAGE(STATUS \"Kernel caching: ${KERNEL_CACHE_DEFAULT}\")\nMESSAGE(STATUS \"Kernel library CPU variants: ${KERNELLIB_HOST_CPU_VARIANTS}\")\nMESSAGE(STATUS \"Kernel library distro build: ${KERNELLIB_HOST_DISTRO_VARIANTS}\")\nMESSAGE(STATUS \"Use pocl custom memory allocator: ${USE_POCL_MEMMANAGER}\")\nMESSAGE(STATUS \"L1d cacheline size: ${HOST_CPU_CACHELINE_SIZE}\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/lib/CL/pocl_llvm_api.h": "/* pocl_llvm_api.cc: internally used header for pocl's LLVM API sources.\n\n   Copyright (c) 2013 Kalle Raiskila\n                 2013-2017 Pekka J\u00e4\u00e4skel\u00e4inen\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in\n   all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   THE SOFTWARE.\n*/\n\n#include \"pocl_llvm.h\"\n\n#include \"CompilerWarnings.h\"\nIGNORE_COMPILER_WARNING (\"-Wunused-parameter\")\n\n#include <llvm/IR/Module.h>\n#include <map>\n#include <string>\n\ntypedef struct _cl_device_id *cl_device_id;\n\n#ifdef __GNUC__\n#pragma GCC visibility push(hidden)\n#endif\n\n/* The LLVM API interface functions are not thread safe at the moment;\n * Pocl needs to ensure only one thread is using this layer at the time.\n *\n * Pocl used a llvm::sys::Mutex class variable before, unfortunately,\n * using llvm::sys::Mutex is not safe. Reason:\n *\n * if pocl is dlopened from a C++ program, pocl's C++ object destructors\n * are called before the program's dtors. This causes the Mutex to be destroyed,\n * and if the program's dtors call clReleaseProgram()\n * -> pocl_free_llvm_irs() -> llvm::PoclMutexGuard guard_variable(Mutex)\n * ... the program will freeze/segfault.\n *\n * This happens with many ViennaCL examples.\n *\n * This class is a replacement that uses a simple pthread lock\n */\n\nclass PoclCompilerMutexGuard {\n  PoclCompilerMutexGuard(const PoclCompilerMutexGuard &) = delete;\n  void operator=(const PoclCompilerMutexGuard &) = delete;\n\npublic:\n  // an unused argument is required, otherwise compiler optimizes out the object\n  PoclCompilerMutexGuard(void *unused);\n  ~PoclCompilerMutexGuard();\n};\n\n\nPOCL_EXPORT\nextern cl_device_id currentPoclDevice;\n\nvoid InitializeLLVM();\nllvm::LLVMContext &GlobalContext();\nextern long numberOfIRs;\n\nllvm::Module *parseModuleIR(const char *path);\nvoid writeModuleIR(const llvm::Module *mod, std::string &str);\nllvm::Module *parseModuleIRMem(const char *input_stream, size_t size);\nint getModuleTriple(const char *input_stream, size_t size, std::string &triple);\nstd::string getDiagString();\n\nvoid clearKernelPasses();\nvoid clearTargetMachines();\nvoid cleanKernelLibrary();\n\nextern std::string currentWgMethod;\n\n#ifdef __GNUC__\n#pragma GCC visibility pop\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/lib/CL/devices/common.c": "/* common.c - common code that can be reused between device driver\n              implementations\n\n   Copyright (c) 2011-2013 Universidad Rey Juan Carlos\n                 2011-2019 Pekka J\u00e4\u00e4skel\u00e4inen\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to\n   deal in the Software without restriction, including without limitation the\n   rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n   sell copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in\n   all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n   IN THE SOFTWARE.\n*/\n\n/* for posix_memalign and strdup */\n#define _BSD_SOURCE\n#define _DEFAULT_SOURCE\n#define _POSIX_C_SOURCE 200809L\n\n#include <assert.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <utlist.h>\n\n#ifdef _MSC_VER\n#include \"vccompat.hpp\"\n#endif\n\n#include \"common.h\"\n#include \"pocl_shared.h\"\n\n#include \"config.h\"\n#include \"config2.h\"\n#include \"devices.h\"\n#include \"pocl_cache.h\"\n#include \"pocl_debug.h\"\n#include \"pocl_file_util.h\"\n#include \"pocl_image_util.h\"\n#include \"pocl_mem_management.h\"\n#include \"pocl_runtime_config.h\"\n#include \"pocl_timing.h\"\n#include \"pocl_util.h\"\n\n#ifdef HAVE_GETRLIMIT\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <unistd.h>\n#endif\n\n#ifdef HAVE_LIBDL\n#if defined(__APPLE__)\n#define _DARWIN_C_SOURCE\n#endif\n#include <dlfcn.h>\n#endif\n\n#ifdef OCS_AVAILABLE\n#include \"pocl_llvm.h\"\n#endif\n\n#include \"_kernel_constants.h\"\n\n#if defined(__x86_64__) || defined(__i386__)\n#define CPU_IS_X86 1\n#endif\n\n#define WORKGROUP_STRING_LENGTH 1024\n\n/**\n * Generate code from the final bitcode using the LLVM\n * tools.\n *\n * Uses an existing (cached) one, if available.\n */\n\n#ifdef OCS_AVAILABLE\nint\nllvm_codegen (char *output, unsigned device_i, cl_kernel kernel,\n              cl_device_id device, _cl_command_node *command, int specialize)\n{\n  POCL_MEASURE_START (llvm_codegen);\n  int error = 0;\n  void *llvm_module = NULL;\n\n  char tmp_module[POCL_FILENAME_LENGTH];\n  char tmp_objfile[POCL_FILENAME_LENGTH];\n\n  char *objfile = NULL;\n  uint64_t objfile_size = 0;\n\n  cl_program program = kernel->program;\n\n  const char *kernel_name = kernel->name;\n\n  /* $/parallel.bc */\n  char parallel_bc_path[POCL_FILENAME_LENGTH];\n  pocl_cache_work_group_function_path (parallel_bc_path, program, device_i,\n                                       kernel, command, specialize);\n\n  /* $/kernel.so */\n  char final_binary_path[POCL_FILENAME_LENGTH];\n  pocl_cache_final_binary_path (final_binary_path, program, device_i, kernel,\n                                command, specialize);\n\n  if (pocl_exists (final_binary_path))\n    goto FINISH;\n\n  assert (strlen (final_binary_path) < (POCL_FILENAME_LENGTH - 3));\n\n  error = pocl_llvm_generate_workgroup_function_nowrite (\n      device_i, device, kernel, command, &llvm_module, specialize);\n  if (error)\n    {\n      POCL_MSG_PRINT_LLVM (\"pocl_llvm_generate_workgroup_function() failed\"\n                           \" for kernel %s\\n\",\n                           kernel_name);\n      goto FINISH;\n    }\n  assert (llvm_module != NULL);\n\n  if (pocl_get_bool_option (\"POCL_LEAVE_KERNEL_COMPILER_TEMP_FILES\", 0))\n    {\n      POCL_MSG_PRINT_LLVM (\"Writing parallel.bc to %s.\\n\", parallel_bc_path);\n      error = pocl_cache_write_kernel_parallel_bc (\n          llvm_module, program, device_i, kernel, command, specialize);\n    }\n  else\n    {\n      char kernel_parallel_path[POCL_FILENAME_LENGTH];\n      pocl_cache_kernel_cachedir_path (kernel_parallel_path, program, device_i,\n                                       kernel, \"\", command, specialize);\n      error = pocl_mkdir_p (kernel_parallel_path);\n    }\n  if (error)\n    {\n      POCL_MSG_PRINT_GENERAL (\"writing parallel.bc failed for kernel %s\\n\",\n                              kernel->name);\n      goto FINISH;\n    }\n\n  /* May happen if another thread is building the same program & wins the llvm\n     lock. */\n  if (pocl_exists (final_binary_path))\n    goto FINISH;\n\n  error = pocl_llvm_codegen (device, llvm_module, &objfile, &objfile_size);\n  if (error)\n    {\n      POCL_MSG_PRINT_LLVM (\"pocl_llvm_codegen() failed for kernel %s\\n\",\n                           kernel_name);\n      goto FINISH;\n    }\n\n  if (pocl_exists (final_binary_path))\n    goto FINISH;\n\n  /* Write temporary kernel.so.o, required for the final linking step.\n     Use append-write because tmp_objfile is already temporary, thus\n     we don't need to create new temporary... */\n  error = pocl_cache_write_kernel_objfile (tmp_objfile, objfile, objfile_size);\n  if (error)\n    {\n      POCL_MSG_PRINT_LLVM (\"writing %s failed for kernel %s\\n\",\n                           tmp_objfile, kernel_name);\n      goto FINISH;\n    }\n  else\n    {\n      POCL_MSG_PRINT_LLVM (\"written %s size %zu\\n\",\n                          tmp_objfile, (size_t)objfile_size);\n    }\n\n  /* temporary filename for kernel.so */\n  if (pocl_cache_tempname (tmp_module, \".so\", NULL))\n    {\n      POCL_MSG_PRINT_LLVM (\"Creating temporary kernel.so file\"\n                           \" for kernel %s FAILED\\n\",\n                           kernel_name);\n      goto FINISH;\n    }\n  else\n    POCL_MSG_PRINT_LLVM (\"Temporary kernel.so file\"\n                         \" for kernel %s : %s\\n\",\n                         kernel_name, tmp_module);\n\n  POCL_MSG_PRINT_INFO (\"Linking final module\\n\");\n\n  /* Link through Clang driver interface who knows the correct toolchains\n     for all of its targets.  */\n  const char *cmd_line[64] =\n    {CLANG, \"-o\", tmp_module, tmp_objfile};\n  const char **device_ld_arg = device->final_linkage_flags;\n  const char **pos = &cmd_line[4];\n  while ((*pos++ = *device_ld_arg++)) {}\n\n  error = pocl_invoke_clang (device, cmd_line);\n\n  if (error)\n    {\n      POCL_MSG_PRINT_LLVM (\"Linking kernel.so.o -> kernel.so has failed\\n\");\n      goto FINISH;\n    }\n\n  /* rename temporary kernel.so */\n  error = pocl_rename (tmp_module, final_binary_path);\n  if (error)\n    {\n      POCL_MSG_PRINT_LLVM (\"Renaming temporary kernel.so to final has failed.\\n\");\n      goto FINISH;\n    }\n\n  /* if LEAVE_COMPILER_FILES, rename temporary kernel.so.o, else delete it */\n  if (pocl_get_bool_option (\"POCL_LEAVE_KERNEL_COMPILER_TEMP_FILES\", 0))\n    {\n      char objfile_path[POCL_FILENAME_LENGTH];\n      strcpy (objfile_path, final_binary_path);\n      strcat (objfile_path, \".o\");\n      error = pocl_rename (tmp_objfile, objfile_path);\n      if (error)\n        POCL_MSG_PRINT_LLVM (\"Renaming temporary kernel.so.o to final .o has failed.\\n\");\n    }\n  else\n    {\n      error = pocl_remove (tmp_objfile);\n      if (error)\n        POCL_MSG_PRINT_LLVM (\"Removing temporary kernel.so.o has failed.\\n\");\n    }\n\nFINISH:\n  pocl_destroy_llvm_module (llvm_module);\n  POCL_MEM_FREE (objfile);\n  POCL_MEASURE_FINISH (llvm_codegen);\n\n  if (error)\n    return error;\n  else\n    {\n      memcpy (output, final_binary_path, POCL_FILENAME_LENGTH);\n      return 0;\n    }\n}\n#endif\n\n\n/**\n * Populates the device specific image data structure used by kernel\n * from given kernel image argument\n */\nvoid\npocl_fill_dev_image_t (dev_image_t *di, struct pocl_argument *parg,\n                       cl_device_id device)\n{\n  cl_mem mem = *(cl_mem *)parg->value;\n  di->_width = mem->image_width;\n  di->_height = mem->image_height;\n  di->_depth = mem->image_depth;\n  di->_row_pitch = mem->image_row_pitch;\n  di->_slice_pitch = mem->image_slice_pitch;\n  di->_order = mem->image_channel_order;\n  di->_image_array_size = mem->image_array_size;\n  di->_data_type = mem->image_channel_data_type;\n  pocl_get_image_information (mem->image_channel_order,\n                              mem->image_channel_data_type,\n                              &(di->_num_channels), &(di->_elem_size));\n\n  IMAGE1D_TO_BUFFER (mem);\n  di->_data = (mem->device_ptrs[device->dev_id].mem_ptr);\n}\n\nvoid\npocl_copy_mem_object (cl_device_id dest_dev, cl_mem dest,\n                      size_t dest_offset,\n                      cl_device_id source_dev, cl_mem source,\n                      size_t source_offset, size_t cb)\n{\n  /* if source_dev is NULL -> src and dest dev must be the same */\n  cl_device_id src_dev = (source_dev) ? source_dev : dest_dev;\n\n  /* if source and destination are on the same global mem  */\n  if (src_dev->global_mem_id == dest_dev->global_mem_id)\n    {\n      src_dev->ops->copy \n        (dest_dev->data, \n         &dest->device_ptrs[dest_dev->dev_id],\n         dest,\n         &source->device_ptrs[src_dev->dev_id],\n         source,\n         dest_offset, source_offset,\n         cb);\n    }\n  else\n    {\n      void* tofree = NULL;\n      void* tmp = NULL;\n      if (source->flags & CL_MEM_USE_HOST_PTR)\n        tmp = source->mem_host_ptr;\n      else if (dest->flags & CL_MEM_USE_HOST_PTR)\n        tmp = dest->mem_host_ptr;\n      else\n        {\n          tmp = malloc (dest->size);\n          tofree = tmp;\n        }\n      \n      src_dev->ops->read \n        (src_dev->data, tmp, \n          &source->device_ptrs[src_dev->dev_id],\n          source,\n          source_offset, cb);\n      dest_dev->ops->write \n        (dest_dev->data, tmp, \n         &dest->device_ptrs[dest_dev->dev_id],\n          dest, dest_offset,\n         cb);\n      free (tofree);\n    }\n  return;\n}\n\nvoid\npocl_migrate_mem_objects (_cl_command_node * volatile node)\n{\n  size_t i;\n  cl_mem *mem_objects = node->command.migrate.mem_objects;\n  \n  for (i = 0; i < node->command.migrate.num_mem_objects; ++i)\n    {\n      pocl_copy_mem_object (node->device,\n                            mem_objects[i], 0,\n                            node->command.migrate.source_devices[i], \n                            mem_objects[i], 0, mem_objects[i]->size);\n      \n      return;\n    }\n}\n\nvoid\npocl_ndrange_node_cleanup(_cl_command_node *node)\n{\n  cl_uint i;\n  for (i = 0; i < node->command.run.kernel->meta->num_args; ++i)\n    {\n      pocl_aligned_free (node->command.run.arguments[i].value);\n    }\n  free (node->command.run.arguments);\n\n  POname(clReleaseKernel)(node->command.run.kernel);\n}\n\nvoid\npocl_mem_objs_cleanup (cl_event event)\n{\n  size_t i;\n  for (i = 0; i < event->num_buffers; ++i)\n    {\n      assert(event->mem_objs[i] != NULL);\n      POname(clReleaseMemObject) (event->mem_objs[i]);\n    }\n  free (event->mem_objs);\n  event->mem_objs = NULL;\n  event->num_buffers = 0;\n}\n\n/**\n * executes given command. Call with node->event UNLOCKED.\n */\nvoid\npocl_exec_command (_cl_command_node * volatile node)\n{\n  unsigned i;\n  /* because of POCL_UPDATE_EVENT_ */\n  cl_event event = node->event;\n  cl_device_id dev = node->device;\n  _cl_command_t *cmd = &node->command;\n  switch (node->type)\n    {\n    case CL_COMMAND_READ_BUFFER:\n      pocl_update_event_running (event);\n      assert (dev->ops->read);\n      dev->ops->read\n        (dev->data,\n         cmd->read.dst_host_ptr,\n         cmd->read.src_mem_id,\n         event->mem_objs[0],\n         cmd->read.offset,\n         cmd->read.size);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Read Buffer           \");\n      break;\n\n    case CL_COMMAND_WRITE_BUFFER:\n      pocl_update_event_running (event);\n      assert (dev->ops->write);\n      dev->ops->write\n        (dev->data,\n         cmd->write.src_host_ptr,\n         cmd->write.dst_mem_id,\n         event->mem_objs[0],\n         cmd->write.offset,\n         cmd->write.size);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Write Buffer          \");\n      break;\n\n    case CL_COMMAND_COPY_BUFFER:\n      pocl_update_event_running (event);\n      assert (dev->ops->copy);\n      dev->ops->copy\n        (dev->data,\n         cmd->copy.dst_mem_id,\n         event->mem_objs[1],\n         cmd->copy.src_mem_id,\n         event->mem_objs[0],\n         cmd->copy.dst_offset,\n         cmd->copy.src_offset,\n         cmd->copy.size);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Copy Buffer           \");\n      break;\n\n    case CL_COMMAND_FILL_BUFFER:\n      pocl_update_event_running (event);\n      assert (dev->ops->memfill);\n      dev->ops->memfill\n        (dev->data,\n         cmd->memfill.dst_mem_id,\n         event->mem_objs[0],\n         cmd->memfill.size,\n         cmd->memfill.offset,\n         cmd->memfill.pattern,\n         cmd->memfill.pattern_size);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Fill Buffer           \");\n      pocl_aligned_free (cmd->memfill.pattern);\n      break;\n\n    case CL_COMMAND_READ_BUFFER_RECT:\n      pocl_update_event_running (event);\n      assert (dev->ops->read_rect);\n      dev->ops->read_rect\n        (dev->data,\n         cmd->read_rect.dst_host_ptr,\n         cmd->read_rect.src_mem_id,\n         event->mem_objs[0],\n         cmd->read_rect.buffer_origin,\n         cmd->read_rect.host_origin,\n         cmd->read_rect.region,\n         cmd->read_rect.buffer_row_pitch,\n         cmd->read_rect.buffer_slice_pitch,\n         cmd->read_rect.host_row_pitch,\n         cmd->read_rect.host_slice_pitch);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Read Buffer Rect      \");\n      break;\n\n    case CL_COMMAND_COPY_BUFFER_RECT:\n      pocl_update_event_running (event);\n      assert (dev->ops->copy_rect);\n      dev->ops->copy_rect\n        (dev->data,\n         cmd->copy_rect.dst_mem_id,\n         event->mem_objs[1],\n         cmd->copy_rect.src_mem_id,\n         event->mem_objs[0],\n         cmd->copy_rect.dst_origin,\n         cmd->copy_rect.src_origin,\n         cmd->copy_rect.region,\n         cmd->copy_rect.dst_row_pitch,\n         cmd->copy_rect.dst_slice_pitch,\n         cmd->copy_rect.src_row_pitch,\n         cmd->copy_rect.src_slice_pitch);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Copy Buffer Rect      \");\n      break;\n\n    case CL_COMMAND_WRITE_BUFFER_RECT:\n      pocl_update_event_running (event);\n      assert (dev->ops->write_rect);\n      dev->ops->write_rect\n        (dev->data,\n         cmd->write_rect.src_host_ptr,\n         cmd->write_rect.dst_mem_id,\n         event->mem_objs[0],\n         cmd->write_rect.buffer_origin,\n         cmd->write_rect.host_origin,\n         cmd->write_rect.region,\n         cmd->write_rect.buffer_row_pitch,\n         cmd->write_rect.buffer_slice_pitch,\n         cmd->write_rect.host_row_pitch,\n         cmd->write_rect.host_slice_pitch);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Write Buffer Rect     \");\n      break;\n\n    case CL_COMMAND_MIGRATE_MEM_OBJECTS:\n      pocl_update_event_running (event);\n      pocl_migrate_mem_objects (node);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Migrate Buffer        \");\n      break;\n\n    case CL_COMMAND_MAP_BUFFER:\n      pocl_update_event_running (event);\n      assert (dev->ops->map_mem);\n      POCL_LOCK_OBJ (event->mem_objs[0]);\n        dev->ops->map_mem (dev->data,\n                           cmd->map.mem_id,\n                           event->mem_objs[0],\n                           cmd->map.mapping);\n      (event->mem_objs[0])->map_count++;\n      POCL_UNLOCK_OBJ (event->mem_objs[0]);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Map Buffer            \");\n      break;\n\n    case CL_COMMAND_COPY_IMAGE_TO_BUFFER:\n      pocl_update_event_running (event);\n      assert (dev->ops->read_image_rect);\n      dev->ops->read_image_rect (\n          dev->data,\n          event->mem_objs[0],\n          cmd->read_image.src_mem_id,\n          NULL,\n          cmd->read_image.dst_mem_id,\n          cmd->read_image.origin,\n          cmd->read_image.region,\n          cmd->read_image.dst_row_pitch,\n          cmd->read_image.dst_slice_pitch,\n          cmd->read_image.dst_offset);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event CopyImageToBuffer       \");\n      break;\n\n    case CL_COMMAND_READ_IMAGE:\n      pocl_update_event_running (event);\n      assert (dev->ops->read_image_rect);\n      dev->ops->read_image_rect (\n          dev->data,\n          event->mem_objs[0],\n          cmd->read_image.src_mem_id,\n          cmd->read_image.dst_host_ptr,\n          NULL,\n          cmd->read_image.origin,\n          cmd->read_image.region,\n          cmd->read_image.dst_row_pitch,\n          cmd->read_image.dst_slice_pitch,\n          cmd->read_image.dst_offset);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Read Image            \");\n      break;\n\n    case CL_COMMAND_COPY_BUFFER_TO_IMAGE:\n      pocl_update_event_running (event);\n      assert (dev->ops->write_image_rect);\n      dev->ops->write_image_rect (\n          dev->data,\n          event->mem_objs[1],\n          cmd->write_image.dst_mem_id,\n          NULL,\n          cmd->write_image.src_mem_id,\n          cmd->write_image.origin,\n          cmd->write_image.region,\n          cmd->write_image.src_row_pitch,\n          cmd->write_image.src_slice_pitch,\n          cmd->write_image.src_offset);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event CopyBufferToImage       \");\n      break;\n\n    case CL_COMMAND_WRITE_IMAGE:\n        pocl_update_event_running (event);\n        assert (dev->ops->write_image_rect);\n        dev->ops->write_image_rect (\n            dev->data,\n            event->mem_objs[0],\n            cmd->write_image.dst_mem_id,\n            cmd->write_image.src_host_ptr,\n            NULL,\n            cmd->write_image.origin,\n            cmd->write_image.region,\n            cmd->write_image.src_row_pitch,\n            cmd->write_image.src_slice_pitch,\n            cmd->write_image.src_offset);\n        POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Write Image           \");\n        break;\n\n    case CL_COMMAND_COPY_IMAGE:\n        pocl_update_event_running (event);\n        assert (dev->ops->copy_image_rect);\n        dev->ops->copy_image_rect(\n              dev->data,\n              event->mem_objs[0],\n              event->mem_objs[1],\n              cmd->copy_image.src_mem_id,\n              cmd->copy_image.dst_mem_id,\n              cmd->copy_image.src_origin,\n              cmd->copy_image.dst_origin,\n              cmd->copy_image.region);\n        POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Copy Image            \");\n        break;\n\n    case CL_COMMAND_FILL_IMAGE:\n      pocl_update_event_running (event);\n      assert (dev->ops->fill_image);\n      dev->ops->fill_image\n        (dev->data,\n         event->mem_objs[0],\n         cmd->fill_image.mem_id,\n         cmd->fill_image.origin,\n         cmd->fill_image.region,\n         cmd->fill_image.fill_pixel,\n         cmd->fill_image.pixel_size);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Fill Image            \");\n      POCL_MEM_FREE (cmd->fill_image.fill_pixel);\n      break;\n\n    case CL_COMMAND_MAP_IMAGE:\n      pocl_update_event_running (event);\n      POCL_LOCK_OBJ (event->mem_objs[0]);\n      assert (dev->ops->map_image != NULL);\n      dev->ops->map_image (dev->data,\n                           cmd->map.mem_id,\n                           event->mem_objs[0],\n                           cmd->map.mapping);\n     (event->mem_objs[0])->map_count++;\n      POCL_UNLOCK_OBJ (event->mem_objs[0]);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Map Image             \");\n      break;\n\n    case CL_COMMAND_UNMAP_MEM_OBJECT:\n      pocl_update_event_running (event);\n      POCL_LOCK_OBJ (event->mem_objs[0]);\n      if (event->mem_objs[0]->is_image == CL_FALSE\n          || IS_IMAGE1D_BUFFER (event->mem_objs[0]))\n        {\n          assert (dev->ops->unmap_mem != NULL);\n          dev->ops->unmap_mem (dev->data,\n                               cmd->unmap.mem_id,\n                               event->mem_objs[0],\n                               cmd->unmap.mapping);\n        }\n      else\n        {\n          assert (dev->ops->unmap_image != NULL);\n          dev->ops->unmap_image (dev->data,\n                                 cmd->unmap.mem_id,\n                                 event->mem_objs[0],\n                                 cmd->unmap.mapping);\n        }\n      assert ((cmd->unmap.mapping)->unmap_requested > 0);\n      DL_DELETE((event->mem_objs[0])->mappings,\n                cmd->unmap.mapping);\n      (event->mem_objs[0])->map_count--;\n      POCL_MEM_FREE (cmd->unmap.mapping);\n      POCL_UNLOCK_OBJ (event->mem_objs[0]);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Unmap Mem obj         \");\n      break;\n\n    case CL_COMMAND_NDRANGE_KERNEL:\n      pocl_update_event_running (event);\n      assert (event == node->event);\n      assert (dev->ops->run);\n      dev->ops->run (dev->data, node);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Enqueue NDRange       \");\n      pocl_ndrange_node_cleanup(node);\n      break;\n\n    case CL_COMMAND_NATIVE_KERNEL:\n      pocl_update_event_running (event);\n      assert (dev->ops->run_native);\n      dev->ops->run_native (dev->data, node);\n      POCL_MEM_FREE (node->command.native.args);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event Native Kernel         \");\n      break;\n\n    case CL_COMMAND_MARKER:\n      pocl_update_event_running (event);\n      POCL_UPDATE_EVENT_COMPLETE(event);\n      break;\n\n    case CL_COMMAND_BARRIER:\n      pocl_update_event_running (event);\n      POCL_UPDATE_EVENT_COMPLETE(event);\n      break;\n\n    case CL_COMMAND_SVM_FREE:\n      pocl_update_event_running (event);\n      if (cmd->svm_free.pfn_free_func)\n        cmd->svm_free.pfn_free_func(\n           cmd->svm_free.queue,\n           cmd->svm_free.num_svm_pointers,\n           cmd->svm_free.svm_pointers,\n           cmd->svm_free.data);\n      else\n        for (i = 0; i < cmd->svm_free.num_svm_pointers; i++)\n          dev->ops->svm_free (dev, cmd->svm_free.svm_pointers[i]);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event SVM Free              \");\n      break;\n\n    case CL_COMMAND_SVM_MAP:\n      pocl_update_event_running (event);\n      if (DEVICE_MMAP_IS_NOP (dev))\n        ; // no-op\n      else\n        {\n          assert (dev->ops->svm_map);\n          dev->ops->svm_map (dev, cmd->svm_map.svm_ptr);\n        }\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event SVM Map              \");\n      break;\n\n    case CL_COMMAND_SVM_UNMAP:\n      pocl_update_event_running (event);\n      if (DEVICE_MMAP_IS_NOP (dev))\n        ; // no-op\n      else\n        {\n          assert (dev->ops->svm_unmap);\n          dev->ops->svm_unmap (dev, cmd->svm_unmap.svm_ptr);\n        }\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event SVM Unmap             \");\n      break;\n\n    case CL_COMMAND_SVM_MEMCPY:\n      pocl_update_event_running (event);\n      assert (dev->ops->svm_copy);\n      dev->ops->svm_copy (dev,\n                          cmd->svm_memcpy.dst,\n                          cmd->svm_memcpy.src,\n                          cmd->svm_memcpy.size);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event SVM Memcpy            \");\n      break;\n\n    case CL_COMMAND_SVM_MEMFILL:\n      pocl_update_event_running (event);\n      assert (dev->ops->svm_fill);\n      dev->ops->svm_fill (dev,\n                          cmd->svm_fill.svm_ptr,\n                          cmd->svm_fill.size,\n                          cmd->svm_fill.pattern,\n                          cmd->svm_fill.pattern_size);\n      POCL_UPDATE_EVENT_COMPLETE_MSG (event, \"Event SVM MemFill           \");\n      pocl_aligned_free (cmd->svm_fill.pattern);\n      break;\n\n    default:\n      POCL_ABORT_UNIMPLEMENTED(\"\");\n      break;\n    }   \n  pocl_mem_manager_free_command (node);\n}\n\n/* call with brc_event UNLOCKED. */\nvoid\npocl_broadcast (cl_event brc_event)\n{\n  event_node *target;\n  event_node *tmp;\n\n  while ((target = brc_event->notify_list))\n    {\n      pocl_lock_events_inorder (brc_event, target->event);\n      /* remove event from wait list */\n      LL_FOREACH (target->event->wait_list, tmp)\n        {\n          if (tmp->event == brc_event)\n            {\n              LL_DELETE (target->event->wait_list, tmp);\n              pocl_mem_manager_free_event_node (tmp);\n              break;\n            }\n        }\n\n        if ((target->event->status == CL_SUBMITTED)\n            || (target->event->status == CL_QUEUED))\n          {\n            target->event->command->device->ops->notify (\n                target->event->command->device, target->event, brc_event);\n          }\n\n        LL_DELETE (brc_event->notify_list, target);\n        pocl_unlock_events_inorder (brc_event, target->event);\n        pocl_mem_manager_free_event_node (target);\n    }\n}\n\n/**\n * Populates the device specific sampler data structure used by kernel\n * from given kernel sampler argument\n */\nvoid\npocl_fill_dev_sampler_t (dev_sampler_t *ds, struct pocl_argument *parg)\n{\n  cl_sampler sampler = *(cl_sampler *)parg->value;\n\n  *ds = (sampler->normalized_coords == CL_TRUE) ? CLK_NORMALIZED_COORDS_TRUE\n                                                : CLK_NORMALIZED_COORDS_FALSE;\n\n  switch (sampler->addressing_mode)\n    {\n    case CL_ADDRESS_NONE:\n      *ds |= CLK_ADDRESS_NONE; break;\n    case CL_ADDRESS_CLAMP_TO_EDGE:\n      *ds |= CLK_ADDRESS_CLAMP_TO_EDGE; break;\n    case CL_ADDRESS_CLAMP:\n      *ds |= CLK_ADDRESS_CLAMP; break;\n    case CL_ADDRESS_REPEAT:\n      *ds |= CLK_ADDRESS_REPEAT; break;\n    case CL_ADDRESS_MIRRORED_REPEAT:\n      *ds |= CLK_ADDRESS_MIRRORED_REPEAT; break;\n  }\n\n  switch (sampler->filter_mode)\n    {\n    case CL_FILTER_NEAREST:\n      *ds |= CLK_FILTER_NEAREST; break;\n    case CL_FILTER_LINEAR :\n      *ds |= CLK_FILTER_LINEAR; break;\n  }\n}\n\n/* CPU driver stuff */\ntypedef struct pocl_dlhandle_cache_item pocl_dlhandle_cache_item;\nstruct pocl_dlhandle_cache_item\n{\n  pocl_kernel_hash_t hash;\n\n  /* The specialization properties. */\n  /* The local dimensions. */\n  size_t local_wgs[3];\n  /* If global offset must be zero for this WG function version. */\n  int goffs_zero;\n  /* Maximum grid dimension this WG function works with. */\n  size_t max_grid_dim_width;\n\n  void *wg;\n  void *dlhandle;\n  pocl_dlhandle_cache_item *next;\n  pocl_dlhandle_cache_item *prev;\n  unsigned ref_count;\n};\n\nstatic pocl_dlhandle_cache_item *pocl_dlhandle_cache;\nstatic pocl_lock_t pocl_llvm_codegen_lock;\nstatic pocl_lock_t pocl_dlhandle_lock;\nstatic int pocl_dlhandle_cache_initialized;\n\n/* only to be called in basic/pthread/<other cpu driver> init */\nvoid\npocl_init_dlhandle_cache ()\n{\n  if (!pocl_dlhandle_cache_initialized)\n    {\n      POCL_INIT_LOCK (pocl_llvm_codegen_lock);\n      POCL_INIT_LOCK (pocl_dlhandle_lock);\n      pocl_dlhandle_cache_initialized = 1;\n   }\n}\n\nstatic unsigned handle_count = 0;\n#define MAX_CACHE_ITEMS 128\n\n/* must be called with pocl_dlhandle_lock LOCKED */\nstatic pocl_dlhandle_cache_item *\nget_new_dlhandle_cache_item ()\n{\n  pocl_dlhandle_cache_item *ci = NULL;\n  const char *dl_error = NULL;\n\n  if (pocl_dlhandle_cache)\n    {\n      ci = pocl_dlhandle_cache->prev;\n      while (ci->ref_count > 0 && ci != pocl_dlhandle_cache)\n        ci = ci->prev;\n    }\n\n  if ((handle_count >= MAX_CACHE_ITEMS) && ci && (ci != pocl_dlhandle_cache))\n    {\n      DL_DELETE (pocl_dlhandle_cache, ci);\n      dlclose (ci->dlhandle);\n      dl_error = dlerror ();\n      if (dl_error != NULL)\n        POCL_ABORT (\"dlclose() failed with error: %s\\n\", dl_error);\n      memset (ci, 0, sizeof (pocl_dlhandle_cache_item));\n    }\n  else\n    {\n      ++handle_count;\n      ci = (pocl_dlhandle_cache_item *)calloc (\n          1, sizeof (pocl_dlhandle_cache_item));\n    }\n\n  return ci;\n}\n\nvoid\npocl_release_dlhandle_cache (_cl_command_node *cmd)\n{\n  pocl_dlhandle_cache_item *ci = NULL, *found = NULL;\n\n  POCL_LOCK (pocl_dlhandle_lock);\n  DL_FOREACH (pocl_dlhandle_cache, ci)\n  {\n    if ((memcmp (ci->hash, cmd->command.run.hash, sizeof (pocl_kernel_hash_t))\n         == 0)\n        && (ci->local_wgs[0] == cmd->command.run.pc.local_size[0])\n        && (ci->local_wgs[1] == cmd->command.run.pc.local_size[1])\n        && (ci->local_wgs[2] == cmd->command.run.pc.local_size[2]))\n      {\n        found = ci;\n        break;\n      }\n  }\n\n  assert (found != NULL);\n  assert (found->ref_count > 0);\n  --found->ref_count;\n  POCL_UNLOCK (pocl_dlhandle_lock);\n}\n\n/**\n * Checks if a built binary is found in the disk for the given kernel command,\n * if not, builds the kernel, caches it, and returns the file name of the\n * end result.\n *\n * @param command The kernel run command.\n * @param specialized 1 if should check the per-command specialized one instead\n * of the generic one.\n * @returns The filename of the built binary in the disk.\n */\nchar *\npocl_check_kernel_disk_cache (_cl_command_node *command, int specialized)\n{\n  char *module_fn = NULL;\n  _cl_command_run *run_cmd = &command->command.run;\n  cl_kernel k = run_cmd->kernel;\n  cl_program p = k->program;\n  unsigned dev_i = command->device_i;\n\n  /* First try to find a static WG binary for the local size as they\n     are always more efficient than the dynamic ones.  Also, in case\n     of reqd_wg_size, there might not be a dynamic sized one at all.  */\n  module_fn = malloc (POCL_FILENAME_LENGTH);\n  pocl_cache_final_binary_path (module_fn, p, dev_i, k, command, specialized);\n\n  if (pocl_exists (module_fn))\n    {\n      POCL_MSG_PRINT_INFO (\"Using a cached WG function: %s\\n\", module_fn);\n      return module_fn;\n    }\n\n  /* static WG binary for the local size does not exist. If we have the LLVM IR\n   * (program.bc), try to compile a new parallel.bc and static binary */\n  if (p->binaries[dev_i])\n    {\n#ifdef OCS_AVAILABLE\n      POCL_LOCK (pocl_llvm_codegen_lock);\n      int error = llvm_codegen (module_fn, dev_i, k, command->device, command,\n                                specialized);\n      POCL_UNLOCK (pocl_llvm_codegen_lock);\n      if (error)\n        POCL_ABORT (\"Final linking of kernel %s failed.\\n\", k->name);\n      POCL_MSG_PRINT_INFO (\"Built a WG function: %s\\n\", module_fn);\n      return module_fn;\n#else\n      /* TODO: This should be caught earlier. */\n      if (!p->pocl_binaries[dev_i])\n        POCL_ABORT (\"pocl device without online compilation support\"\n                    \" cannot compile LLVM IRs to machine code!\\n\");\n#endif\n    }\n  else\n    {\n      module_fn = malloc (POCL_FILENAME_LENGTH);\n      /* First try to find a specialized WG binary, if allowed by the\n         command. */\n      if (!run_cmd->force_generic_wg_func)\n        pocl_cache_final_binary_path (module_fn, p, dev_i, k, command, 0);\n\n      if (run_cmd->force_generic_wg_func || !pocl_exists (module_fn))\n        {\n          /* Then check for a dynamic (non-specialized) kernel. */\n          pocl_cache_final_binary_path (module_fn, p, dev_i, k, command, 1);\n          if (!pocl_exists (module_fn))\n            POCL_ABORT (\"Generic WG function binary does not exist.\\n\");\n          POCL_MSG_PRINT_INFO (\"Using a cached generic WG function: %s\\n\",\n                               module_fn);\n        }\n      else\n        POCL_MSG_PRINT_INFO (\"Using a cached specialized WG function: %s\\n\",\n                             module_fn);\n    }\n  return module_fn;\n}\n\n/* Returns the width of the widest dimension in the grid of the given\n   run command. */\nsize_t\npocl_cmd_max_grid_dim_width (_cl_command_run *cmd)\n{\n  return max (max (cmd->pc.local_size[0] * cmd->pc.num_groups[0],\n                   cmd->pc.local_size[1] * cmd->pc.num_groups[1]),\n              cmd->pc.local_size[2] * cmd->pc.local_size[2]);\n}\n\n/* Look for a dlhandle in the dlhandle cache for the given kernel command.\n   If found, push the handle up in the cache to improve cache hit speed,\n   and return it. Otherwise return NULL. The caller should hold\n   pocl_dlhandle_lock. */\nstatic pocl_dlhandle_cache_item *\nfetch_dlhandle_cache_item (_cl_command_run *run_cmd)\n{\n  pocl_dlhandle_cache_item *ci = NULL, *tmp = NULL;\n  size_t max_grid_width = pocl_cmd_max_grid_dim_width (run_cmd);\n  DL_FOREACH_SAFE (pocl_dlhandle_cache, ci, tmp)\n  {\n    if ((memcmp (ci->hash, run_cmd->hash, sizeof (pocl_kernel_hash_t)) == 0)\n        && (ci->local_wgs[0] == run_cmd->pc.local_size[0])\n        && (ci->local_wgs[1] == run_cmd->pc.local_size[1])\n        && (ci->local_wgs[2] == run_cmd->pc.local_size[2])\n        && (max_grid_width <= ci->max_grid_dim_width)\n        && (!ci->goffs_zero\n            || (run_cmd->pc.global_offset[0] == 0\n                && run_cmd->pc.global_offset[1] == 0\n                && run_cmd->pc.global_offset[2] == 0)))\n      {\n        /* move to the front of the line */\n        DL_DELETE (pocl_dlhandle_cache, ci);\n        DL_PREPEND (pocl_dlhandle_cache, ci);\n        ++ci->ref_count;\n        run_cmd->wg = ci->wg;\n        return ci;\n      }\n  }\n  return NULL;\n}\n\n/**\n * Checks if the kernel command has been built and has been loaded with\n * dlopen, and reuses its handle. If not, checks if a built binary is found\n * in the disk, if not, builds the kernel and puts it to respective\n * caches.\n *\n * The initial refcount may be 0, in case we're just pre-compiling kernels\n * (or compiling them for binaries), and not actually need them immediately.\n *\n * TODO: This function is really specific to CPU (host) drivers since dlhandles\n * imply program loading to the same process as the host. Move to basic.c? */\nvoid\npocl_check_kernel_dlhandle_cache (_cl_command_node *command,\n                                  unsigned initial_refcount, int specialize)\n{\n  char workgroup_string[WORKGROUP_STRING_LENGTH];\n  pocl_dlhandle_cache_item *ci = NULL, *tmp = NULL;\n  const char *dl_error = NULL;\n  _cl_command_run *run_cmd = &command->command.run;\n\n  POCL_LOCK (pocl_dlhandle_lock);\n  ci = fetch_dlhandle_cache_item (run_cmd);\n  if (ci != NULL)\n    {\n      POCL_UNLOCK (pocl_dlhandle_lock);\n      return;\n    }\n\n  /* Not found, build a new kernel and cache its dlhandle. */\n  ci = get_new_dlhandle_cache_item ();\n  memcpy (ci->hash, run_cmd->hash, sizeof (pocl_kernel_hash_t));\n  ci->local_wgs[0] = run_cmd->pc.local_size[0];\n  ci->local_wgs[1] = run_cmd->pc.local_size[1];\n  ci->local_wgs[2] = run_cmd->pc.local_size[2];\n  ci->ref_count = initial_refcount;\n\n  ci->goffs_zero = run_cmd->pc.global_offset[0] == 0\n                   && run_cmd->pc.global_offset[1] == 0\n                   && run_cmd->pc.global_offset[2] == 0;\n\n  size_t max_grid_width = pocl_cmd_max_grid_dim_width (run_cmd);\n  ci->max_grid_dim_width = max_grid_width;\n\n  char *module_fn = pocl_check_kernel_disk_cache (command, specialize);\n\n  // reset possibly existing error from calls from an ICD loader\n  (void)dlerror();\n  ci->dlhandle = dlopen (module_fn, RTLD_NOW | RTLD_LOCAL);\n  dl_error = dlerror ();\n\n  if (ci->dlhandle == NULL || dl_error != NULL)\n    POCL_ABORT (\"dlopen(\\\"%s\\\") failed with '%s'.\\n\"\n                \"note: missing symbols in the kernel binary might be\"\n                \" reported as 'file not found' errors.\\n\",\n                module_fn, dl_error);\n\n  snprintf (workgroup_string, WORKGROUP_STRING_LENGTH,\n            \"_pocl_kernel_%s_workgroup\", run_cmd->kernel->name);\n\n  ci->wg = dlsym (ci->dlhandle, workgroup_string);\n  dl_error = dlerror ();\n\n  if (ci->wg == NULL || dl_error != NULL)\n    {\n      // Older OSX dyld APIs need the name without the underscore.\n      snprintf (workgroup_string, WORKGROUP_STRING_LENGTH,\n                \"pocl_kernel_%s_workgroup\", run_cmd->kernel->name);\n      ci->wg = dlsym (ci->dlhandle, workgroup_string);\n      dl_error = dlerror ();\n\n      if (ci->wg == NULL || dl_error != NULL)\n        POCL_ABORT (\"dlsym(\\\"%s\\\", \\\"%s\\\") failed with '%s'.\\n\"\n                    \"note: missing symbols in the kernel binary might be\"\n                    \" reported as 'file not found' errors.\\n\",\n                    module_fn, workgroup_string, dl_error);\n    }\n\n  run_cmd->wg = ci->wg;\n  DL_PREPEND (pocl_dlhandle_cache, ci);\n\n  POCL_UNLOCK (pocl_dlhandle_lock);\n  /***************************************************************************/\n  POCL_MEM_FREE (module_fn);\n}\n\n#define MIN_MAX_MEM_ALLOC_SIZE (128*1024*1024)\n\n/* accounting object for the main memory */\nstatic pocl_global_mem_t system_memory = {POCL_LOCK_INITIALIZER, 0, 0, 0};\n\nvoid\npocl_setup_device_for_system_memory (cl_device_id device)\n{\n  /* set up system memory limits, if required */\n  if (system_memory.total_alloc_limit == 0)\n  {\n      /* global_mem_size contains the entire memory size,\n       * and we need to leave some available for OS & other programs\n       * this sets it to 3/4 for systems with <=7gig mem,\n       * for >7 it sets to (total-2gigs)\n       */\n      cl_ulong alloc_limit = device->global_mem_size;\n      if (alloc_limit > ((cl_ulong)7 << 30))\n        system_memory.total_alloc_limit = alloc_limit - ((cl_ulong)2 << 30);\n      else\n        {\n          cl_ulong temp = (alloc_limit >> 2);\n          system_memory.total_alloc_limit = alloc_limit - temp;\n        }\n\n      system_memory.max_ever_allocated =\n          system_memory.currently_allocated = 0;\n\n      /* in some cases (e.g. ARM32 pocl on ARM64 system with >4G ram),\n       * global memory is correctly reported but larger than can be\n       * used; limit to pointer size */\n      if (system_memory.total_alloc_limit > UINTPTR_MAX)\n        system_memory.total_alloc_limit = UINTPTR_MAX;\n\n      /* apply rlimit settings */\n#ifdef HAVE_GETRLIMIT\n      struct rlimit limits;\n      int ret = getrlimit (RLIMIT_DATA, &limits);\n      if ((ret == 0) && (system_memory.total_alloc_limit > limits.rlim_cur))\n        system_memory.total_alloc_limit = limits.rlim_cur;\n#endif\n  }\n\n  device->global_mem_size = system_memory.total_alloc_limit;\n\n  int limit_memory_gb = pocl_get_int_option (\"POCL_MEMORY_LIMIT\", 0);\n  if (limit_memory_gb > 0)\n    {\n      cl_ulong limited_memory = (cl_ulong)limit_memory_gb << 30;\n      if (device->global_mem_size > limited_memory)\n        device->global_mem_size = limited_memory;\n      else\n        POCL_MSG_WARN (\"requested POCL_MEMORY_LIMIT %i GBs is larger than\"\n                       \" physical memory size (%u) GBs, ignoring\\n\",\n                       limit_memory_gb,\n                       (unsigned)(device->global_mem_size >> 30));\n    }\n\n  if (device->global_mem_size < MIN_MAX_MEM_ALLOC_SIZE)\n    POCL_ABORT(\"Not enough memory to run on this device.\\n\");\n\n  /* Maximum allocation size: we don't have hardware limits, so we\n   * can potentially allocate the whole memory for a single buffer, unless\n   * of course there are limits set at the operating system level. Of course\n   * we still have to respect the OpenCL-commanded minimum */\n\n  cl_ulong alloc_limit = pocl_size_ceil2_64 (device->global_mem_size / 4);\n\n  if (alloc_limit < MIN_MAX_MEM_ALLOC_SIZE)\n    alloc_limit = MIN_MAX_MEM_ALLOC_SIZE;\n\n  // set up device properties..\n  device->global_memory = &system_memory;\n  device->max_mem_alloc_size = alloc_limit;\n\n  // TODO in theory now if alloc_limit was > rlim_cur and < rlim_max\n  // we should try and setrlimit to alloc_limit, or allocations might fail\n}\n\nvoid\npocl_reinit_system_memory()\n{\n  system_memory.currently_allocated = 0;\n  system_memory.max_ever_allocated = 0;\n}\n\n/* set maximum allocation sizes for buffers and images */\nvoid\npocl_set_buffer_image_limits(cl_device_id device)\n{\n  pocl_setup_device_for_system_memory(device);\n\n  assert (device->global_mem_size > 0);\n  assert (device->max_compute_units > 0);\n  assert (device->max_mem_alloc_size > 0);\n\n  /* these should be ideally setup by hwloc or proc/cpuinfo;\n   * if not, set them to some reasonable values\n   */\n  if (device->local_mem_size == 0)\n    {\n      cl_ulong s = pocl_size_ceil2_64 (device->global_mem_size / 1024);\n      s = min (s, 512UL * 1024);\n      device->local_mem_size = s;\n      device->max_constant_buffer_size = s;\n    }\n\n  /* We don't have hardware limitations on the buffer-backed image sizes,\n   * so we set the maximum size in terms of the maximum amount of pixels\n   * that fix in max_mem_alloc_size. A single pixel can take up to 4 32-bit channels,\n   * i.e. 16 bytes.\n   */\n  size_t max_pixels = device->max_mem_alloc_size/16;\n  if (max_pixels > device->image_max_buffer_size)\n    device->image_max_buffer_size = max_pixels;\n\n  /* Similarly, we can take the 2D image size limit to be the largest power of 2\n   * whose square fits in image_max_buffer_size; since the 2D image size limit\n   * starts at a power of 2, it's a simple matter of doubling.\n   * This is actually completely arbitrary, another equally valid option\n   * would be to have each maximum dimension match the image_max_buffer_size.\n   */\n  max_pixels = device->image2d_max_width;\n  // keep doubing until we go over\n  while (max_pixels <= device->image_max_buffer_size/max_pixels)\n    max_pixels *= 2;\n  // halve before assignment\n  max_pixels /= 2;\n  if (max_pixels > device->image2d_max_width)\n    device->image2d_max_width = device->image2d_max_height = max_pixels;\n\n  /* Same thing for 3D images, of course with cubes. Again, totally arbitrary. */\n  max_pixels = device->image3d_max_width;\n  // keep doubing until we go over\n  while (max_pixels*max_pixels <= device->image_max_buffer_size/max_pixels)\n    max_pixels *= 2;\n  // halve before assignment\n  max_pixels /= 2;\n  if (max_pixels > device->image3d_max_width)\n  device->image3d_max_width = device->image3d_max_height =\n    device->image3d_max_depth = max_pixels;\n\n}\n\nvoid*\npocl_aligned_malloc_global_mem(cl_device_id device, size_t align, size_t size)\n{\n  pocl_global_mem_t *mem = device->global_memory;\n  void *retval = NULL;\n\n  POCL_LOCK (mem->pocl_lock);\n  if ((mem->total_alloc_limit - mem->currently_allocated) < size)\n    goto ERROR;\n\n  retval = pocl_aligned_malloc (align, size);\n  if (!retval)\n    goto ERROR;\n\n  mem->currently_allocated += size;\n  if (mem->max_ever_allocated < mem->currently_allocated)\n    mem->max_ever_allocated = mem->currently_allocated;\n  assert(mem->currently_allocated <= mem->total_alloc_limit);\n\nERROR:\n  POCL_UNLOCK (mem->pocl_lock);\n\n  return retval;\n}\n\nvoid\npocl_free_global_mem(cl_device_id device, void* ptr, size_t size)\n{\n  pocl_global_mem_t *mem = device->global_memory;\n\n  POCL_LOCK (mem->pocl_lock);\n  assert(mem->currently_allocated >= size);\n  mem->currently_allocated -= size;\n  POCL_UNLOCK (mem->pocl_lock);\n\n  POCL_MEM_FREE(ptr);\n}\n\n\nvoid\npocl_print_system_memory_stats()\n{\n  POCL_MSG_PRINT_F (MEMORY, INFO, \"\",\n                    \"____ Total available system memory  : %10\" PRIu64 \" KB\\n\"\n                    \" ____ Currently used system memory   : %10\" PRIu64 \" KB\\n\"\n                    \" ____ Max used system memory         : %10\" PRIu64\n                    \" KB\\n\",\n                    system_memory.total_alloc_limit >> 10,\n                    system_memory.currently_allocated >> 10,\n                    system_memory.max_ever_allocated >> 10);\n}\n\n/* Unique hash for a device + program build + kernel name combination.\n   NOTE: this does NOT take into account the local WG sizes or other\n   specialization properties. */\nvoid\npocl_calculate_kernel_hash (cl_program program, unsigned kernel_i,\n                            unsigned device_i)\n{\n  SHA1_CTX hash_ctx;\n  pocl_SHA1_Init (&hash_ctx);\n\n  char *n = program->kernel_meta[kernel_i].name;\n  pocl_SHA1_Update (&hash_ctx, (uint8_t *)program->build_hash[device_i],\n                    sizeof (SHA1_digest_t));\n  pocl_SHA1_Update (&hash_ctx, (uint8_t *)n, strlen (n));\n\n  uint8_t digest[SHA1_DIGEST_SIZE];\n  pocl_SHA1_Final (&hash_ctx, digest);\n\n  memcpy (program->kernel_meta[kernel_i].build_hash[device_i], digest,\n          sizeof (pocl_kernel_hash_t));\n}\n\n/* default WG size in each dimension & total WG size.\n * this should be reasonable for CPU */\n#define DEFAULT_WG_SIZE 4096\n\nstatic const char *final_ld_flags[] =\n  {\"-lm\", \"-nostartfiles\", HOST_LD_FLAGS_ARRAY, NULL};\n\nstatic cl_device_partition_property basic_partition_properties[1] = { 0 };\nstatic const cl_image_format supported_image_formats[] = {\n  { CL_A, CL_SNORM_INT8 },\n  { CL_A, CL_SNORM_INT16 },\n  { CL_A, CL_UNORM_INT8 },\n  { CL_A, CL_UNORM_INT16 },\n  { CL_A, CL_SIGNED_INT8 },\n  { CL_A, CL_SIGNED_INT16 },\n  { CL_A, CL_SIGNED_INT32 },\n  { CL_A, CL_UNSIGNED_INT8 },\n  { CL_A, CL_UNSIGNED_INT16 },\n  { CL_A, CL_UNSIGNED_INT32 },\n  { CL_A, CL_FLOAT },\n  { CL_RGBA, CL_SNORM_INT8 },\n  { CL_RGBA, CL_SNORM_INT16 },\n  { CL_RGBA, CL_UNORM_INT8 },\n  { CL_RGBA, CL_UNORM_INT16 },\n  { CL_RGBA, CL_SIGNED_INT8 },\n  { CL_RGBA, CL_SIGNED_INT16 },\n  { CL_RGBA, CL_SIGNED_INT32 },\n  { CL_RGBA, CL_UNSIGNED_INT8 },\n  { CL_RGBA, CL_UNSIGNED_INT16 },\n  { CL_RGBA, CL_UNSIGNED_INT32 },\n  { CL_RGBA, CL_HALF_FLOAT },\n  { CL_RGBA, CL_FLOAT },\n  { CL_ARGB, CL_SNORM_INT8 },\n  { CL_ARGB, CL_UNORM_INT8 },\n  { CL_ARGB, CL_SIGNED_INT8 },\n  { CL_ARGB, CL_UNSIGNED_INT8 },\n  { CL_BGRA, CL_SNORM_INT8 },\n  { CL_BGRA, CL_UNORM_INT8 },\n  { CL_BGRA, CL_SIGNED_INT8 },\n  { CL_BGRA, CL_UNSIGNED_INT8 }\n};\n\nvoid\npocl_init_default_device_infos (cl_device_id dev)\n{\n  size_t i;\n\n  dev->type = CL_DEVICE_TYPE_CPU;\n  dev->max_work_item_dimensions = 3;\n  dev->final_linkage_flags = final_ld_flags;\n  dev->extensions = DEFAULT_DEVICE_EXTENSIONS;\n\n  SETUP_DEVICE_CL_VERSION(HOST_DEVICE_CL_VERSION_MAJOR, HOST_DEVICE_CL_VERSION_MINOR)\n  /*\n    The hard restriction will be the context data which is\n    stored in stack that can be as small as 8K in Linux.\n    Thus, there should be enough work-items alive to fill up\n    the SIMD lanes times the vector units, but not more than\n    that to avoid stack overflow and cache trashing.\n  */\n  int max_wg\n      = pocl_get_int_option (\"POCL_MAX_WORK_GROUP_SIZE\", DEFAULT_WG_SIZE);\n  assert (max_wg > 0);\n  max_wg = min (max_wg, DEFAULT_WG_SIZE);\n  if (max_wg < 0)\n    max_wg = DEFAULT_WG_SIZE;\n\n  dev->max_work_item_sizes[0] = dev->max_work_item_sizes[1]\n      = dev->max_work_item_sizes[2] = dev->max_work_group_size = max_wg;\n\n  dev->preferred_wg_size_multiple = 8;\n#ifdef OCS_AVAILABLE\n  cpu_setup_vector_widths (dev);\n#else\n  dev->preferred_vector_width_char = POCL_DEVICES_PREFERRED_VECTOR_WIDTH_CHAR;\n  dev->preferred_vector_width_short = POCL_DEVICES_PREFERRED_VECTOR_WIDTH_SHORT;\n  dev->preferred_vector_width_int = POCL_DEVICES_PREFERRED_VECTOR_WIDTH_INT;\n  dev->preferred_vector_width_long = POCL_DEVICES_PREFERRED_VECTOR_WIDTH_LONG;\n  dev->preferred_vector_width_float = POCL_DEVICES_PREFERRED_VECTOR_WIDTH_FLOAT;\n  /* TODO: figure out what the difference between preferred and native widths are */\n  dev->native_vector_width_char = POCL_DEVICES_NATIVE_VECTOR_WIDTH_CHAR;\n  dev->native_vector_width_short = POCL_DEVICES_NATIVE_VECTOR_WIDTH_SHORT;\n  dev->native_vector_width_int = POCL_DEVICES_NATIVE_VECTOR_WIDTH_INT;\n  dev->native_vector_width_long = POCL_DEVICES_NATIVE_VECTOR_WIDTH_LONG;\n  dev->native_vector_width_float = POCL_DEVICES_NATIVE_VECTOR_WIDTH_FLOAT;\n\n#ifdef _CL_DISABLE_DOUBLE\n  dev->native_vector_width_double = 0;\n  dev->preferred_vector_width_double = 0;\n#else\n  dev->native_vector_width_double = POCL_DEVICES_NATIVE_VECTOR_WIDTH_DOUBLE;\n  dev->preferred_vector_width_double = POCL_DEVICES_PREFERRED_VECTOR_WIDTH_DOUBLE;\n#endif\n#ifdef _CL_DISABLE_HALF\n  dev->preferred_vector_width_half = 0;\n  dev->native_vector_width_half = 0;\n#else\n  dev->preferred_vector_width_half = POCL_DEVICES_PREFERRED_VECTOR_WIDTH_HALF;\n  dev->native_vector_width_half = POCL_DEVICES_NATIVE_VECTOR_WIDTH_HALF;\n#endif\n\n#endif\n\n  dev->grid_width_specialization_limit = USHRT_MAX;\n  dev->address_bits = HOST_DEVICE_ADDRESS_BITS;\n  dev->image_support = CL_TRUE;\n  /* Use the minimum values until we get a more sensible upper limit from\n     somewhere. */\n  dev->max_read_image_args = dev->max_write_image_args\n      = dev->max_read_write_image_args = 128;\n  dev->image2d_max_width = dev->image2d_max_height = 8192;\n  dev->image3d_max_width = dev->image3d_max_height = dev->image3d_max_depth = 2048;\n  dev->max_samplers = 16;\n\n  for (i = 0; i < NUM_OPENCL_IMAGE_TYPES; ++i)\n    {\n      dev->num_image_formats[i]\n          = sizeof (supported_image_formats) / sizeof (cl_image_format);\n      dev->image_formats[i] = supported_image_formats;\n    }\n\n  dev->image_max_buffer_size = 65536;\n  dev->image_max_array_size = 2048;\n  dev->max_constant_args = 8;\n  dev->max_mem_alloc_size = 0;\n  dev->max_parameter_size = 1024;\n  dev->min_data_type_align_size = MAX_EXTENDED_ALIGNMENT;\n  dev->mem_base_addr_align = MAX_EXTENDED_ALIGNMENT;\n  dev->half_fp_config = 0;\n  dev->single_fp_config = CL_FP_ROUND_TO_NEAREST | CL_FP_INF_NAN;\n#ifdef __x86_64__\n  dev->single_fp_config |= (CL_FP_DENORM | CL_FP_ROUND_TO_INF\n                            | CL_FP_ROUND_TO_ZERO\n                            | CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT);\n#ifdef OCS_AVAILABLE\n  if (cpu_has_fma())\n    dev->single_fp_config |= CL_FP_FMA;\n#endif\n#endif\n\n#ifdef _CL_DISABLE_DOUBLE\n  dev->double_fp_config = 0;\n#else\n  /* TODO: all of these are the minimum mandated, but not all CPUs may actually\n   * support all of them. */\n  dev->double_fp_config = CL_FP_FMA | CL_FP_ROUND_TO_NEAREST\n                          | CL_FP_ROUND_TO_ZERO | CL_FP_ROUND_TO_INF\n                          | CL_FP_INF_NAN | CL_FP_DENORM;\n  /* this is a workaround for issue 28 in https://github.com/Oblomov/clinfo\n   * https://github.com/Oblomov/clinfo/issues/28 */\n  dev->double_fp_config |= CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT;\n#endif\n\n  dev->global_mem_cache_type = CL_NONE;\n  dev->global_mem_cacheline_size = 0;\n  dev->global_mem_cache_size = 0;\n  dev->global_mem_size = 0;\n  dev->max_constant_buffer_size = 0;\n  dev->max_constant_args = 8;\n  dev->local_mem_type = CL_GLOBAL;\n  dev->local_mem_size = 0;\n  dev->error_correction_support = CL_FALSE;\n  dev->host_unified_memory = CL_TRUE;\n\n  dev->profiling_timer_resolution = pocl_timer_resolution;\n\n  dev->endian_little = !(WORDS_BIGENDIAN);\n  dev->available = CL_TRUE;\n  dev->compiler_available = CL_TRUE;\n  dev->spmd = CL_FALSE;\n  dev->arg_buffer_launcher = CL_FALSE;\n  dev->workgroup_pass = CL_TRUE;\n  dev->execution_capabilities = CL_EXEC_KERNEL | CL_EXEC_NATIVE_KERNEL;\n  dev->platform = 0;\n\n  dev->parent_device = NULL;\n  /* These two are only used for subdevices.\n   * Each subdevice has these two setup when created.\n   * The subdevice will then use these CUs:\n   *  [start, start+1, ..., start+count-1]\n   * this may not work with more complicated partitioning schemes,\n   * but is good enough for now. */\n  dev->core_start = 0;\n  dev->core_count = 0;\n  /* basic does not support partitioning */\n  dev->max_sub_devices = 1;\n  dev->num_partition_properties = 1;\n  dev->partition_properties = basic_partition_properties;\n  dev->num_partition_types = 0;\n  dev->partition_type = NULL;\n\n  dev->device_side_printf = 1;\n  dev->printf_buffer_size = PRINTF_BUFFER_SIZE * 1024;\n\n  dev->vendor = \"pocl\";\n  dev->profile = \"FULL_PROFILE\";\n  /* Note: The specification describes identifiers being delimited by\n     only a single space character. Some programs that check the device's\n     extension  string assume this rule. Future extension additions should\n     ensure that there is no more than a single space between\n     identifiers. */\n  dev->global_as_id = dev->local_as_id = dev->constant_as_id = 0;\n\n  dev->should_allocate_svm = 0;\n  /* OpenCL 2.0 properties */\n  dev->svm_caps = CL_DEVICE_SVM_COARSE_GRAIN_BUFFER\n                  | CL_DEVICE_SVM_FINE_GRAIN_BUFFER\n                  | CL_DEVICE_SVM_ATOMICS;\n  /* TODO these are minimums, figure out whats a reasonable value */\n  dev->max_events = 1024;\n  dev->max_queues = 1;\n  dev->max_pipe_args = 16;\n  dev->max_pipe_active_res = 1;\n  dev->max_pipe_packet_size = 1024;\n  dev->dev_queue_pref_size = 16 * 1024;\n  dev->dev_queue_max_size = 256 * 1024;\n  dev->on_dev_queue_props = CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\n                               | CL_QUEUE_PROFILING_ENABLE;\n  dev->on_host_queue_props = CL_QUEUE_PROFILING_ENABLE;\n  dev->has_64bit_long = 1;\n  dev->autolocals_to_args = POCL_AUTOLOCALS_TO_ARGS_ALWAYS;\n  dev->device_alloca_locals = 0;\n\n#ifdef OCS_AVAILABLE\n\n  dev->llvm_target_triplet = OCL_KERNEL_TARGET;\n#ifdef HOST_CPU_FORCED\n  dev->llvm_cpu = OCL_KERNEL_TARGET_CPU;\n#else\n  dev->llvm_cpu = get_llvm_cpu_name ();\n#endif\n\n  dev->spirv_version = \"SPIR-V_1.2\";\n#else /* No compiler, no CPU info */\n  dev->llvm_cpu = NULL;\n  dev->llvm_target_triplet = \"\";\n#endif\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/lib/CL/devices/devices.c": "/* Definition of available OpenCL devices.\n\n   Copyright (c) 2011 Universidad Rey Juan Carlos and\n                 2012-2018 Pekka J\u00e4\u00e4skel\u00e4inen\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in\n   all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   THE SOFTWARE.\n*/\n\n#define _GNU_SOURCE\n\n#include <string.h>\n#include <ctype.h>\n\n#ifdef __linux__\n#include <limits.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <ucontext.h>\n#endif\n\n#ifndef _MSC_VER\n#  include <unistd.h>\n#else\n#  include \"vccompat.hpp\"\n#endif\n\n#include \"common.h\"\n#include \"config.h\"\n#include \"devices.h\"\n#include \"pocl_cache.h\"\n#include \"pocl_debug.h\"\n#include \"pocl_runtime_config.h\"\n#include \"pocl_tracing.h\"\n\n#ifdef OCS_AVAILABLE\n#include \"pocl_llvm.h\"\n#endif\n\n#if defined(TCE_AVAILABLE)\n#include \"tce/ttasim/ttasim.h\"\n#endif\n\n#include \"hsa/pocl-hsa.h\"\n\n#if defined(BUILD_ACCEL)\n#include \"accel/accel.h\"\n#endif\n\n#define MAX_DEV_NAME_LEN 64\n\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#ifdef HAVE_LIBDL\n#if defined(__APPLE__)\n#define _DARWIN_C_SOURCE\n#endif\n#include <dlfcn.h>\n#endif\n\n/* the enabled devices */\nstatic struct _cl_device_id* pocl_devices = NULL;\nunsigned int pocl_num_devices = 0;\n\n/* Init function prototype */\ntypedef void (*init_device_ops)(struct pocl_device_ops*);\n\n/* All init function for device operations available to pocl */\nstatic init_device_ops pocl_devices_init_ops[] = {\n#ifdef BUILD_BASIC\n  NULL,\n#endif\n#ifdef BUILD_PTHREAD\n  NULL,\n#endif\n#if defined(TCE_AVAILABLE)\n  NULL,\n#endif\n#if defined(BUILD_HSA)\n  NULL,\n#endif\n#if defined(BUILD_CUDA)\n  NULL,\n#endif\n#if defined(BUILD_ACCEL)\n  NULL,\n#endif\n};\n\n#define POCL_NUM_DEVICE_TYPES (sizeof(pocl_devices_init_ops) / sizeof((pocl_devices_init_ops)[0]))\n\nchar pocl_device_types[POCL_NUM_DEVICE_TYPES][30] = {\n#ifdef BUILD_BASIC\n  \"basic\",\n#endif\n#ifdef BUILD_PTHREAD\n  \"pthread\",\n#endif\n#if defined(TCE_AVAILABLE)\n  \"ttasim\",\n#endif\n#if defined(BUILD_HSA)\n  \"hsa\",\n#endif\n#if defined(BUILD_CUDA)\n  \"cuda\",\n#endif\n#if defined(BUILD_ACCEL)\n  \"accel\",\n#endif\n};\n\nstatic struct pocl_device_ops pocl_device_ops[POCL_NUM_DEVICE_TYPES];\n\n// first setup\nstatic unsigned first_init_done = 0;\nstatic unsigned init_in_progress = 0;\nstatic unsigned device_count[POCL_NUM_DEVICE_TYPES];\n\n// after calling drivers uninit, we may have to re-init the devices.\nstatic unsigned devices_active = 0;\n\nstatic pocl_lock_t pocl_init_lock = POCL_LOCK_INITIALIZER;\n\nstatic void *pocl_device_handles[POCL_NUM_DEVICE_TYPES];\n\n#ifndef _MSC_VER\n#define POCL_PATH_SEPARATOR \"/\"\n#else\n#define POCL_PATH_SEPARATOR \"\\\\\"\n#endif\n\nstatic void\nget_pocl_device_lib_path (char *result, char *device_name)\n{\n  Dl_info info;\n  if (dladdr ((void *)get_pocl_device_lib_path, &info))\n    {\n      char const *soname = info.dli_fname;\n      strcpy (result, soname);\n      char *last_slash = strrchr (result, POCL_PATH_SEPARATOR[0]);\n      *(++last_slash) = '\\0';\n      if (strlen (result) > 0)\n        {\n#ifdef ENABLE_POCL_BUILDING\n          if (pocl_get_bool_option (\"POCL_BUILDING\", 0))\n            {\n              strcat (result, \"devices\");\n              strcat (result, POCL_PATH_SEPARATOR);\n              if (strncmp(device_name, \"ttasim\", 6) == 0)\n                {\n                  strcat (result, \"tce\");\n                }\n              else\n                {\n                  strcat (result, device_name);\n                }\n              strcat (result, POCL_PATH_SEPARATOR);\n            }\n          else\n#endif\n            {\n              strcat (result, POCL_INSTALL_PRIVATE_LIBDIR_REL);\n            }\n          strcat (result, POCL_PATH_SEPARATOR);\n          strcat (result, \"libpocl-devices-\");\n          strcat (result, device_name);\n          strcat (result, \".so\");\n          return;\n        }\n    }\n}\n\n/**\n * Get the number of specified devices from environment\n */\nint pocl_device_get_env_count(const char *dev_type)\n{\n  const char *dev_env = getenv(POCL_DEVICES_ENV);\n  char *ptr, *saveptr = NULL, *tofree, *token;\n  unsigned int dev_count = 0;\n  if (dev_env == NULL)\n    {\n      return -1;\n    }\n  ptr = tofree = strdup(dev_env);\n  while ((token = strtok_r (ptr, \" \", &saveptr)) != NULL)\n    {\n      if(strcmp(token, dev_type) == 0)\n        dev_count++;\n      ptr = NULL;\n    }\n  POCL_MEM_FREE(tofree);\n\n  return dev_count;\n}\n\nunsigned int\npocl_get_devices(cl_device_type device_type, struct _cl_device_id **devices, unsigned int num_devices)\n{\n  unsigned int i, dev_added = 0;\n\n  int offline_compile = pocl_get_bool_option(\"POCL_OFFLINE_COMPILE\", 0);\n\n  for (i = 0; i < pocl_num_devices; ++i)\n    {\n      if (!offline_compile && (pocl_devices[i].available != CL_TRUE))\n        continue;\n\n      if (device_type == CL_DEVICE_TYPE_DEFAULT)\n        {\n          devices[dev_added] = &pocl_devices[i];\n          ++dev_added;\n          break;\n        }\n\n      if (pocl_devices[i].type & device_type)\n        {\n            if (dev_added < num_devices)\n              {\n                devices[dev_added] = &pocl_devices[i];\n                ++dev_added;\n              }\n            else\n              {\n                break;\n              }\n        }\n    }\n  return dev_added;\n}\n\nunsigned int\npocl_get_device_type_count(cl_device_type device_type)\n{\n  int count = 0;\n  unsigned int i;\n\n  int offline_compile = pocl_get_bool_option(\"POCL_OFFLINE_COMPILE\", 0);\n\n  for (i = 0; i < pocl_num_devices; ++i)\n    {\n      if (!offline_compile && (pocl_devices[i].available != CL_TRUE))\n        continue;\n\n      if (device_type == CL_DEVICE_TYPE_DEFAULT)\n        return 1;\n\n      if (pocl_devices[i].type & device_type)\n        {\n           ++count;\n        }\n    }\n\n  return count;\n}\n\n\nstatic inline void\nstr_toupper(char *out, const char *in)\n{\n  int i;\n\n  for (i = 0; in[i] != '\\0'; i++)\n    out[i] = toupper(in[i]);\n  out[i] = '\\0';\n}\n\n/* This ugly hack is required because:\n *\n * OpenCL 1.2 specification, 6.3 Operators :\n *\n * A divide by zero with integer types does not cause an exception\n * but will result in an unspecified value. Division by zero for\n * floating-point types will result in \u00b1infinity or NaN as\n * prescribed by the IEEE-754 standard.\n *\n * FPU exceptions are masked by default on x86 linux, but integer divide\n * is not and there doesn't seem any sane way to mask it.\n *\n * This *might* be possible to fix with a LLVM pass (either check divisor\n * for 0, or perhaps some vector extension has a suitable instruction), but\n * it's likely to ruin the performance.\n */\n\n#ifdef ENABLE_HOST_CPU_DEVICES\n#ifdef __linux__\n#ifdef __x86_64__\n\n#define DIV_OPCODE_SIZE 1\n#define DIV_OPCODE_MASK 0xf6\n\n/* F6 /6, F6 /7, F7 /6, F7 /7 */\n#define DIV_OPCODE_1 0xf6\n#define DIV_OPCODE_2 0xf7\n#define DIV_MODRM_OPCODE_EXT_1 0x38 //  /7\n#define DIV_MODRM_OPCODE_EXT_2 0x30 //  /6\n\n#define MODRM_SIZE 1\n#define MODRM_MASK 0xC0\n#define REG2_MASK 0x38\n#define REG1_MASK 0x07\n#define ADDR_MODE_INDIRECT_ONE_BYTE_OFFSET 0x40\n#define ADDR_MODE_INDIRECT_FOUR_BYTE_OFFSET 0x80\n#define ADDR_MODE_INDIRECT 0x0\n#define ADDR_MODE_REGISTER_ONLY 0xC0\n#define REG_SP 0x4\n#define REG_BP 0x5\n#define SIB_BYTE 1\n#define IP_RELATIVE_INDEXING 4\n\nstatic struct sigaction sigfpe_action, old_sigfpe_action;\n\nstatic void\nsigfpe_signal_handler (int signo, siginfo_t *si, void *data)\n{\n  ucontext_t *uc;\n  uc = (ucontext_t *)data;\n  unsigned char *eip = (unsigned char *)(uc->uc_mcontext.gregs[REG_RIP]);\n\n  if ((signo == SIGFPE)\n      && ((si->si_code == FPE_INTDIV) || (si->si_code == FPE_INTOVF)))\n    {\n      /* Luckily for us, div-by-0 exceptions do NOT advance the IP register,\n       * so we have to disassemble the instruction (to know its length)\n       * and move IP past it. */\n      unsigned n = 0;\n\n      /* skip all prefixes */\n      while ((n < 4) && ((eip[n] & DIV_OPCODE_MASK) != DIV_OPCODE_MASK))\n        ++n;\n\n      /* too much prefixes = decoding failed */\n      if (n >= 4)\n        goto ORIGINAL_HANDLER;\n\n      /* check opcode */\n      unsigned opcode = eip[n];\n      if ((opcode != DIV_OPCODE_1) && (opcode != DIV_OPCODE_2))\n        goto ORIGINAL_HANDLER;\n      n += DIV_OPCODE_SIZE;\n\n      unsigned modrm = eip[n];\n      unsigned modmask = modrm & MODRM_MASK;\n      unsigned reg1mask = modrm & REG1_MASK;\n      unsigned reg2mask = modrm & REG2_MASK;\n      /* check opcode extension in ModR/M reg2 */\n      if ((reg2mask != DIV_MODRM_OPCODE_EXT_1)\n          && (reg2mask != DIV_MODRM_OPCODE_EXT_2))\n        goto ORIGINAL_HANDLER;\n      n += MODRM_SIZE;\n\n      /* handle immediates/registers */\n      if (modmask == ADDR_MODE_INDIRECT_ONE_BYTE_OFFSET)\n        n += 1;\n      if (modmask == ADDR_MODE_INDIRECT_FOUR_BYTE_OFFSET)\n        n += 4;\n      if (modmask == ADDR_MODE_INDIRECT)\n        n += 0;\n      if (modmask != ADDR_MODE_REGISTER_ONLY)\n        {\n          if (reg1mask == REG_SP)\n            n += SIB_BYTE;\n          if (reg1mask == REG_BP)\n            n += IP_RELATIVE_INDEXING;\n        }\n\n      uc->uc_mcontext.gregs[REG_RIP] += n;\n      return;\n    }\n  else\n    {\n    ORIGINAL_HANDLER:\n      (*old_sigfpe_action.sa_sigaction) (signo, si, data);\n    }\n}\n\n#endif\n#endif\n#endif\n\ncl_int\npocl_uninit_devices ()\n{\n  cl_int retval = CL_SUCCESS;\n\n  POCL_LOCK (pocl_init_lock);\n  if ((!devices_active) || (pocl_num_devices == 0))\n    goto FINISH;\n\n  POCL_MSG_PRINT_GENERAL (\"UNINIT all devices\\n\");\n\n  unsigned i, j, dev_index;\n\n  dev_index = 0;\n  cl_device_id d;\n  for (i = 0; i < POCL_NUM_DEVICE_TYPES; ++i)\n    {\n      if (pocl_devices_init_ops[i] == NULL)\n        continue;\n      assert (pocl_device_ops[i].init);\n      for (j = 0; j < device_count[i]; ++j)\n        {\n          d = &pocl_devices[dev_index];\n          if (d->available == 0)\n            continue;\n          if (d->ops->reinit == NULL || d->ops->uninit == NULL)\n            continue;\n          cl_int ret = d->ops->uninit (j, d);\n          if (ret != CL_SUCCESS)\n            {\n              retval = ret;\n              goto FINISH;\n            }\n          if (pocl_device_handles[i] != NULL)\n            {\n              dlclose (pocl_device_handles[i]);\n            }\n          ++dev_index;\n        }\n    }\n\nFINISH:\n  devices_active = 0;\n  POCL_UNLOCK (pocl_init_lock);\n\n  return retval;\n}\n\nstatic cl_int\npocl_reinit_devices ()\n{\n  assert (first_init_done);\n  cl_int retval = CL_SUCCESS;\n\n  if (devices_active)\n    return retval;\n\n  if (pocl_num_devices == 0)\n    return CL_DEVICE_NOT_FOUND;\n\n  POCL_MSG_WARN (\"REINIT all devices\\n\");\n\n  unsigned i, j, dev_index;\n\n  dev_index = 0;\n  cl_device_id d;\n  /* Init infos for each probed devices */\n  for (i = 0; i < POCL_NUM_DEVICE_TYPES; ++i)\n    {\n      assert (pocl_device_ops[i].init);\n      for (j = 0; j < device_count[i]; ++j)\n        {\n          d = &pocl_devices[dev_index];\n          if (d->available == 0)\n            continue;\n          if (d->ops->reinit == NULL || d->ops->uninit == NULL)\n            continue;\n          cl_int ret = d->ops->reinit (j, d);\n          if (ret != CL_SUCCESS)\n            {\n              retval = ret;\n              goto FINISH;\n            }\n\n          ++dev_index;\n        }\n    }\n\nFINISH:\n\n  devices_active = 1;\n  return retval;\n}\n\ncl_int\npocl_init_devices ()\n{\n  int errcode = CL_SUCCESS;\n\n  /* This is a workaround to a nasty problem with libhwloc: When\n     initializing basic, it calls libhwloc to query device info.\n     In case libhwloc has the OpenCL plugin installed, it initializes\n     it and it leads to initializing pocl again which leads to an\n     infinite loop. This only protects against recursive calls of\n     pocl_init_devices(), so must be done without pocl_init_lock held. */\n  if (init_in_progress)\n    return CL_SUCCESS; /* debatable, but what else can we do ? */\n\n  POCL_LOCK (pocl_init_lock);\n  init_in_progress = 1;\n\n  if (first_init_done)\n    {\n      if (!devices_active)\n        {\n          POCL_MSG_PRINT_GENERAL (\"FIRST INIT done; REINIT all devices\\n\");\n          pocl_reinit_devices (); // TODO err check\n        }\n      errcode = pocl_num_devices ? CL_SUCCESS : CL_DEVICE_NOT_FOUND;\n      goto ERROR;\n    }\n\n  /* first time initialization */\n  unsigned i, j, dev_index;\n  char env_name[1024];\n  char dev_name[MAX_DEV_NAME_LEN] = { 0 };\n\n  /* Set a global debug flag, so we don't have to call pocl_get_bool_option\n   * everytime we use the debug macros */\n#ifdef POCL_DEBUG_MESSAGES\n  const char* debug = pocl_get_string_option (\"POCL_DEBUG\", \"0\");\n  pocl_debug_messages_setup (debug);\n  pocl_stderr_is_a_tty = isatty(fileno(stderr));\n#endif\n\n  POCL_GOTO_ERROR_ON ((pocl_cache_init_topdir ()), CL_DEVICE_NOT_FOUND,\n                      \"Cache directory initialization failed\");\n\n  pocl_tracing_init ();\n\n#ifdef HAVE_SLEEP\n  int delay = pocl_get_int_option (\"POCL_STARTUP_DELAY\", 0);\n  if (delay > 0)\n    sleep (delay);\n#endif\n\n\n#ifdef ENABLE_HOST_CPU_DEVICES\n#ifdef __linux__\n#ifdef __x86_64__\n\n  if (pocl_get_bool_option (\"POCL_SIGFPE_HANDLER\", 1))\n    {\n\n#ifdef OCS_AVAILABLE\n      /* This is required to force LLVM to register its signal\n       * handlers, before pocl registers its own SIGFPE handler.\n       * LLVM otherwise calls this via\n       *    pocl_llvm_build_program ->\n       *    clang::PrintPreprocessedAction ->\n       *    CreateOutputFile -> RemoveFileOnSignal\n       * Registering our handlers before LLVM creates its sigaltstack\n       * leads to interesting crashes & bugs later.\n       */\n      char random_empty_file[POCL_FILENAME_LENGTH];\n      pocl_cache_tempname (random_empty_file, NULL, NULL);\n      pocl_llvm_remove_file_on_signal (random_empty_file);\n#endif\n\n      POCL_MSG_PRINT_GENERAL (\"Installing SIGFPE handler...\\n\");\n      sigfpe_action.sa_flags = SA_RESTART | SA_SIGINFO;\n      sigfpe_action.sa_sigaction = sigfpe_signal_handler;\n      int res = sigaction (SIGFPE, &sigfpe_action, &old_sigfpe_action);\n      assert (res == 0);\n    }\n\n#endif\n#endif\n#endif\n\n  /* Init operations */\n  for (i = 0; i < POCL_NUM_DEVICE_TYPES; ++i)\n    {\n      if (pocl_devices_init_ops[i] == NULL)\n        {\n          char device_library[PATH_MAX] = \"\";\n          get_pocl_device_lib_path (device_library, pocl_device_types[i]);\n          pocl_device_handles[i] = dlopen (device_library, RTLD_LAZY);\n          char init_device_ops_name[MAX_DEV_NAME_LEN + 21] = \"\";\n          strcat (init_device_ops_name, \"pocl_\");\n          strcat (init_device_ops_name, pocl_device_types[i]);\n          strcat (init_device_ops_name, \"_init_device_ops\");\n          if (pocl_device_handles[i] != NULL)\n            {\n              pocl_devices_init_ops[i] = (init_device_ops)dlsym (\n                  pocl_device_handles[i], init_device_ops_name);\n              if (pocl_devices_init_ops[i] != NULL)\n                {\n                  pocl_devices_init_ops[i](&pocl_device_ops[i]);\n                }\n              else\n                {\n                  POCL_MSG_ERR (\"Loading symbol %s from %s failed: %s\\n\",\n                                init_device_ops_name, device_library,\n                                dlerror ());\n                  device_count[i] = 0;\n                  continue;\n                }\n            }\n          else\n            {\n              POCL_MSG_WARN (\"Loading %s failed: %s\\n\", device_library,\n                             dlerror ());\n              device_count[i] = 0;\n              continue;\n            }\n        }\n      else\n        {\n          pocl_device_handles[i] = NULL;\n        }\n      pocl_devices_init_ops[i](&pocl_device_ops[i]);\n      assert(pocl_device_ops[i].device_name != NULL);\n\n      /* Probe and add the result to the number of probed devices */\n      assert(pocl_device_ops[i].probe);\n      device_count[i] = pocl_device_ops[i].probe(&pocl_device_ops[i]);\n      pocl_num_devices += device_count[i];\n    }\n\n  const char *dev_env = pocl_get_string_option (POCL_DEVICES_ENV, NULL);\n  POCL_GOTO_ERROR_ON ((pocl_num_devices == 0), CL_DEVICE_NOT_FOUND,\n                      \"no devices found. %s=%s\\n\", POCL_DEVICES_ENV, dev_env);\n\n  pocl_devices = (struct _cl_device_id*) calloc(pocl_num_devices, sizeof(struct _cl_device_id));\n  POCL_GOTO_ERROR_ON ((pocl_devices == NULL), CL_OUT_OF_HOST_MEMORY,\n                      \"Can not allocate memory for devices\\n\");\n\n  dev_index = 0;\n  /* Init infos for each probed devices */\n  for (i = 0; i < POCL_NUM_DEVICE_TYPES; ++i)\n    {\n      if (pocl_devices_init_ops[i] == NULL)\n        continue;\n      str_toupper (dev_name, pocl_device_ops[i].device_name);\n      assert(pocl_device_ops[i].init);\n      for (j = 0; j < device_count[i]; ++j)\n        {\n          cl_device_id dev = &pocl_devices[dev_index];\n          dev->ops = &pocl_device_ops[i];\n          dev->dev_id = dev_index;\n          POCL_INIT_OBJECT (dev);\n          dev->driver_version = PACKAGE_VERSION;\n          if (dev->version == NULL)\n            dev->version = \"OpenCL 2.0 pocl\";\n          dev->short_name = strdup (dev->ops->device_name);\n          /* The default value for the global memory space identifier is\n             the same as the device id. The device instance can then override\n             it to point to some other device's global memory id in case of\n             a shared global memory. */\n          pocl_devices[dev_index].global_mem_id = dev_index;\n\n          /* Check if there are device-specific parameters set in the\n             POCL_DEVICEn_PARAMETERS env. */\n          POCL_GOTO_ERROR_ON (\n              (snprintf (env_name, 1024, \"POCL_%s%d_PARAMETERS\", dev_name, j)\n               < 0),\n              CL_OUT_OF_HOST_MEMORY, \"Unable to generate the env string.\");\n          errcode = pocl_devices[dev_index].ops->init (\n              j, &pocl_devices[dev_index], getenv (env_name));\n          POCL_GOTO_ERROR_ON ((errcode != CL_SUCCESS), CL_DEVICE_NOT_AVAILABLE,\n                              \"Device %i / %s initialization failed!\", j,\n                              dev_name);\n\n          ++dev_index;\n        }\n    }\n\n  first_init_done = 1;\n  devices_active = 1;\nERROR:\n  init_in_progress = 0;\n  POCL_UNLOCK (pocl_init_lock);\n  return errcode;\n}\n\nint pocl_get_unique_global_mem_id ()\n{\n  static int global_id_counter = 1;\n  return global_id_counter++;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/include/vccompat.hpp": "/* pocl/include/vccompat.h - Compatibility header to provide some functions \n   which are not found from VC++. \n\n   All functions should be static inline so that they can be included in many places\n   without having problem of symbol collision.\n\n   Copyright (c) 2014 Mikael Lepist\u00f6 <elhigu@gmail.com>\n   \n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n   \n   The above copyright notice and this permission notice shall be included in\n   all copies or substantial portions of the Software.\n   \n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   THE SOFTWARE.\n*/\n\n#ifndef VCCOMPAT_HPP\n#define VCCOMPAT_HPP\n\n#include <Windows.h>\n#define __restrict__ __restrict\n#define restrict __restrict\n\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n\n// ERROR is used as label for goto in some OCL API functions\n#undef ERROR\n\n// if this causes linking problems, use inline function below...\n#define snprintf _snprintf\n\n/*\nstatic inline int snprintf(char *str, size_t size, const char *format, ...) {\n  va_list args;\n  va_start(args, format);\n  _snprintf(str, size, format, args);\n  va_end(args);\n}\n*/\n\nstatic inline char* strtok_r(char *str, const char *delim, char **saveptr) {\n  return strtok_s(str, delim, saveptr);\n}\n\n#define _USE_MATH_DEFINES\n\n#define srand48(x) srand(x)\n#define drand48() (double(rand()) / RAND_MAX)\n\n#include <sys/utime.h>\n#define utime _utime;\n\n#define RTLD_NOW 1\n#define RTLD_LOCAL 1\n\n/**\n * dl compatibility functions\n */\n\nstatic inline void* dlopen(const char* filename, int flags) {\n  return (void*)LoadLibrary(filename);\n}\n\nstatic inline int dlerror(void) {\n  return GetLastError();\n}\n\nstatic inline void *dlsym(void* handle, const char *symbol) {\n  return GetProcAddress((HMODULE)handle, symbol);\n}\n\n/**\n * Filesystem stuff\n */\n#include <io.h>\n#define R_OK    4       /* Test for read permission.  */\n#define W_OK    2       /* Test for write permission.  */\n#define F_OK    0       /* Test for existence.  */\n\n#include <stdlib.h>\n#include <direct.h>\n#include <process.h>\n\n#define mkdir(a,b) mkdir(a)\n\n/**\n * TODO: test these implementations...\n */\n\n/* Commented out: unused, and actually incorrect/unsafe.\nstatic inline void gen_random(char *s, const int len) {\n  static const char alphanum[] =\n    \"0123456789\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\";\n\n  for (int i = 0; i < len; ++i) {\n    s[i] = alphanum[rand() % (sizeof(alphanum)-1)];\n  }\n  s[len] = 0;\n}\n\nstatic inline void mkdtemp(char *temp) {\n  int rnd_start = strlen(temp) - 6;\n  gen_random(&temp[rnd_start], 6);\n  mkdir(temp);\n}\n*/\n\n/**\n * Memory allocation functions\n */\n#include <malloc.h>\n\nstatic int posix_memalign(void **p, size_t align, size_t size) { \n   void *buf = _aligned_malloc(size, align);\n   if (buf == NULL) return errno;\n   *p = buf;\n   return 0;\n}\n\n#define alloca _alloca\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/tests/CMakeLists.txt": "#=============================================================================\n#   CMake build system files\n#\n#   Copyright (c) 2014 pocl developers\n#\n#   Permission is hereby granted, free of charge, to any person obtaining a copy\n#   of this software and associated documentation files (the \"Software\"), to deal\n#   in the Software without restriction, including without limitation the rights\n#   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n#   copies of the Software, and to permit persons to whom the Software is\n#   furnished to do so, subject to the following conditions:\n#\n#   The above copyright notice and this permission notice shall be included in\n#   all copies or substantial portions of the Software.\n#\n#   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n#   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n#   THE SOFTWARE.\n#\n#=============================================================================\n\nadd_test(\"pocl_version_check\" \"runtime/test_version\")\n\nif(ENABLE_HOST_CPU_DEVICES)\n    # If basic OpenCL device is not included, we assume the device is chosen using\n    # the POCL_DEVICES env. Otherwise, use the basic dev to check that we are using\n    # pocl.\n    set_tests_properties(\"pocl_version_check\"\n      PROPERTIES\n      ENVIRONMENT \"POCL_DEVICES=basic\"\n      PASS_REGULAR_EXPRESSION \"basic\"\n      LABELS \"internal;cuda\")\nendif()\n\n#######################################################################\n\nadd_test(\"pocl_test_dlopen_libpocl\" \"runtime/test_dlopen\")\nset_property(TEST \"pocl_version_check\" APPEND PROPERTY DEPENDS \"pocl_test_dlopen_libpocl\")\n\nif(BUILD_BASIC)\n  add_test(\"pocl_test_dlopen_device_basic\" \"runtime/test_dlopen\" \"basic\")\n  set_property(TEST \"pocl_version_check\" APPEND PROPERTY DEPENDS \"pocl_test_dlopen_device_basic\")\nendif()\n\nif(BUILD_PTHREAD)\n  add_test(\"pocl_test_dlopen_device_pthread\" \"runtime/test_dlopen\" \"pthread\")\n  set_property(TEST \"pocl_version_check\" APPEND PROPERTY DEPENDS \"pocl_test_dlopen_device_pthread\")\nendif()\n\nif(BUILD_ACCEL)\n  add_test(\"pocl_test_dlopen_device_accel\" \"runtime/test_dlopen\" \"accel\")\n  set_property(TEST \"pocl_version_check\" APPEND PROPERTY DEPENDS \"pocl_test_dlopen_device_accel\")\nendif()\n\nif(ENABLE_TCE)\n  add_test(\"pocl_test_dlopen_device_tce\" \"runtime/test_dlopen\" \"tce\")\n  set_property(TEST \"pocl_version_check\" APPEND PROPERTY DEPENDS \"pocl_test_dlopen_device_tce\")\nendif()\n\nif(ENABLE_HSA)\n  add_test(\"pocl_test_dlopen_device_hsa\" \"runtime/test_dlopen\" \"hsa\")\n  set_property(TEST \"pocl_version_check\" APPEND PROPERTY DEPENDS \"pocl_test_dlopen_device_hsa\")\nendif()\n\nif(ENABLE_CUDA)\n  add_test(\"pocl_test_dlopen_device_cuda\" \"runtime/test_dlopen\" \"cuda\")\n  set_property(TEST \"pocl_version_check\" APPEND PROPERTY DEPENDS \"pocl_test_dlopen_device_cuda\")\nendif()\n\n#######################################################################\n\nadd_subdirectory(\"kernel\")\nadd_subdirectory(\"regression\")\nadd_subdirectory(\"runtime\")\nadd_subdirectory(\"workgroup\")\nif(ENABLE_TCE)\n  add_subdirectory(\"tce\")\nendif()\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/tests/runtime/test_dlopen.c": "/* Test that pocl libraries can be dlopen()ed\n\n   Copyright (c) 2021 pocl developers\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to\n   deal in the Software without restriction, including without limitation the\n   rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n   sell copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in\n   all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n   IN THE SOFTWARE.\n*/\n\n#include <dlfcn.h>\n#include <stdio.h>\n\nint\nmain (int argc, char **argv)\n{\n  int ret = 0;\n  const char *libpocl = \"$ORIGIN/../../lib/CL/libpocl.so\";\n  char libdevice[4096] = \"\";\n  if (argc > 1)\n    snprintf (libdevice, sizeof (libdevice),\n              \"$ORIGIN/../../lib/CL/devices/%s/libpocl-devices-%s.so\", argv[1],\n              argv[1]);\n\n  void *handle_libpocl = dlopen (libpocl, RTLD_NOW | RTLD_GLOBAL);\n  if (!handle_libpocl)\n    {\n      fprintf (stderr, \"dlopen(%s, RTLD_NOW | RTLD_GLOBAL) failed: %s\\n\",\n               libpocl, dlerror ());\n      ret = 1;\n    }\n\n  if (ret == 0 && argc > 1)\n    {\n      void *handle_device = dlopen (libdevice, RTLD_NOW);\n      if (!handle_device)\n        {\n          fprintf (stderr, \"dlopen(%s, RTLD_NOW) failed: %s\\n\", libdevice,\n                   dlerror ());\n          ret = 1;\n        }\n      if (handle_device)\n        dlclose (handle_device);\n    }\n\n  if (handle_libpocl)\n    dlclose (handle_libpocl);\n\n  return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/tests/runtime/CMakeLists.txt": "#=============================================================================\n#   CMake build system files\n#\n#   Copyright (c) 2014 pocl developers\n#\n#   Permission is hereby granted, free of charge, to any person obtaining a copy\n#   of this software and associated documentation files (the \"Software\"), to deal\n#   in the Software without restriction, including without limitation the rights\n#   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n#   copies of the Software, and to permit persons to whom the Software is\n#   furnished to do so, subject to the following conditions:\n#\n#   The above copyright notice and this permission notice shall be included in\n#   all copies or substantial portions of the Software.\n#\n#   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n#   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n#   THE SOFTWARE.\n#\n#=============================================================================\n\n\n# do not link test_dlopen with -lOpenCL\nadd_executable(\"test_dlopen\" \"test_dlopen.c\")\ntarget_link_libraries(\"test_dlopen\" ${DL_LIB})\n\nset(PROGRAMS_TO_BUILD test_clFinish test_clGetDeviceInfo test_clGetEventInfo\n  test_clCreateProgramWithBinary test_clGetSupportedImageFormats\n  test_clSetEventCallback test_clEnqueueNativeKernel test_clBuildProgram\n  test_clCreateKernelsInProgram test_clCreateKernel test_clGetKernelArgInfo\n  test_version test_kernel_cache_includes test_event_cycle test_link_error\n  test_read-copy-write-buffer test_buffer-image-copy test_clCreateSubDevices test_event_free\n  test_event_double_wait\n  test_enqueue_kernel_from_binary test_user_event test_fill-buffer\n  test_clSetMemObjectDestructorCallback)\n\nadd_compile_options(${OPENCL_CFLAGS})\n\nforeach(PROG ${PROGRAMS_TO_BUILD})\n  if(MSVC)\n    set_source_files_properties( \"${PROG}.c\" PROPERTIES LANGUAGE CXX )\n  endif(MSVC)\n  add_executable(\"${PROG}\" \"${PROG}.c\")\n  target_link_libraries(\"${PROG}\" ${POCLU_LINK_OPTIONS})\nendforeach()\n\n#######################################################################\n\n\nadd_test_pocl(NAME \"runtime/clGetDeviceInfo\" COMMAND \"test_clGetDeviceInfo\")\n\nadd_test_pocl(NAME \"runtime/clEnqueueNativeKernel\" COMMAND \"test_clEnqueueNativeKernel\")\n\nadd_test_pocl(NAME \"runtime/clGetEventInfo\" COMMAND \"test_clGetEventInfo\")\n\nadd_test_pocl(NAME \"runtime/clCreateProgramWithBinary\" COMMAND \"test_clCreateProgramWithBinary\")\n\nadd_test_pocl(NAME \"runtime/clBuildProgram\"\n              WORKING_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\"\n              COMMAND \"test_clBuildProgram\")\n\nadd_test_pocl(NAME \"runtime/test_kernel_cache_includes\"\n              WORKING_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}\"\n              COMMAND \"test_kernel_cache_includes\")\n\nadd_test_pocl(NAME \"runtime/clFinish\" COMMAND \"test_clFinish\")\n\nadd_test_pocl(NAME \"runtime/test_event_cycle\" COMMAND \"test_event_cycle\")\n\nadd_test_pocl(NAME \"runtime/test_link_error\" COMMAND \"test_link_error\")\n\nadd_test_pocl(NAME \"runtime/test_read-copy-write-buffer\" COMMAND \"test_read-copy-write-buffer\")\n\nadd_test_pocl(NAME \"runtime/test_fill-buffer\" COMMAND \"test_fill-buffer\")\n\nadd_test_pocl(NAME \"runtime/test_buffer-image-copy\" COMMAND \"test_buffer-image-copy\")\n\nadd_test_pocl(NAME \"runtime/clCreateKernel\" COMMAND \"test_clCreateKernel\")\n\nadd_test_pocl(NAME \"runtime/clGetKernelArgInfo\" COMMAND \"test_clGetKernelArgInfo\")\n\nadd_test_pocl(NAME \"runtime/clSetEventCallback\"\n              COMMAND \"test_clSetEventCallback\"\n              EXPECTED_OUTPUT \"test_clSetEventCallback_expout.txt\" )\n\nadd_test_pocl(NAME \"runtime/clGetSupportedImageFormats\" COMMAND \"test_clGetSupportedImageFormats\")\n\nadd_test_pocl(NAME \"runtime/clCreateKernelsInProgram\" COMMAND \"test_clCreateKernelsInProgram\")\n\nadd_test_pocl(NAME \"runtime/clCreateSubDevices\" COMMAND  \"test_clCreateSubDevices\")\n\nadd_test_pocl(NAME \"runtime/test_event_free\" COMMAND  \"test_event_free\")\n\nadd_test_pocl(NAME \"runtime/test_event_double_wait\" COMMAND  \"test_event_double_wait\")\n\nadd_test_pocl(NAME \"runtime/test_enqueue_kernel_from_binary\" COMMAND \"test_enqueue_kernel_from_binary\")\n\nadd_test_pocl(NAME \"runtime/test_user_event\" COMMAND  \"test_user_event\")\n\nadd_test_pocl(NAME \"runtime/clSetMemObjectDestructorCallback\" COMMAND  \"test_clSetMemObjectDestructorCallback\")\n\nset_tests_properties( \"runtime/clGetDeviceInfo\" \"runtime/clEnqueueNativeKernel\"\n  \"runtime/clGetEventInfo\" \"runtime/clCreateProgramWithBinary\"\n  \"runtime/clBuildProgram\" \"runtime/clFinish\" \"runtime/clSetEventCallback\"\n  \"runtime/clGetSupportedImageFormats\" \"runtime/clCreateKernelsInProgram\"\n  \"runtime/clCreateKernel\" \"runtime/clGetKernelArgInfo\"\n  \"runtime/test_kernel_cache_includes\" \"runtime/test_event_cycle\"\n  \"runtime/test_read-copy-write-buffer\" \"runtime/test_buffer-image-copy\"\n  \"runtime/test_fill-buffer\"\n  \"runtime/test_event_free\" \"runtime/test_event_double_wait\" \"runtime/clCreateSubDevices\"\n  \"runtime/test_enqueue_kernel_from_binary\" \"runtime/test_user_event\"\n  \"runtime/clSetMemObjectDestructorCallback\" \"runtime/test_link_error\"\n  PROPERTIES\n    COST 2.0\n    PROCESSORS 1\n    DEPENDS \"pocl_version_check\"\n    LABELS \"internal;runtime\")\n\nif(NOT ENABLE_ANYSAN)\n  set_tests_properties(\"runtime/clCreateKernelsInProgram\"\n  PROPERTIES\n    PASS_REGULAR_EXPRESSION \"Hello\\nWorld\")\n\n  set_tests_properties(\"runtime/clFinish\"\n  PROPERTIES\n    PASS_REGULAR_EXPRESSION \"ABABC\")\n\n  set_tests_properties(\"runtime/test_kernel_cache_includes\"\n  PROPERTIES PASS_REGULAR_EXPRESSION\n  \"function 1.*first include.*function 2.*second include\")\nendif()\n\n# Label tests that work with CUDA backend\nset_property(TEST\n  \"runtime/clGetDeviceInfo\"\n  \"runtime/clGetEventInfo\"\n  \"runtime/clCreateProgramWithBinary\"\n  \"runtime/test_kernel_cache_includes\"\n  \"runtime/clFinish\"\n  \"runtime/test_read-copy-write-buffer\"\n  \"runtime/test_fill-buffer\"\n  \"runtime/test_buffer-image-copy\"\n  \"runtime/clSetEventCallback\"\n  \"runtime/clGetSupportedImageFormats\"\n  \"runtime/clCreateKernelsInProgram\"\n  \"runtime/test_event_cycle\"\n  \"runtime/test_event_free\"\n  \"runtime/test_event_double_wait\"\n  \"runtime/test_user_event\"\n  \"runtime/clSetMemObjectDestructorCallback\"\n  APPEND PROPERTY LABELS \"cuda\")\n\nset_property(TEST\n  \"runtime/clGetDeviceInfo\"\n  \"runtime/clGetEventInfo\"\n  \"runtime/clCreateProgramWithBinary\"\n  \"runtime/clBuildProgram\"\n  \"runtime/test_kernel_cache_includes\"\n  \"runtime/test_event_cycle\"\n  \"runtime/test_link_error\"\n  \"runtime/test_buffer-image-copy\"\n  \"runtime/clCreateKernel\"\n  \"runtime/clGetKernelArgInfo\"\n  \"runtime/clGetSupportedImageFormats\"\n  \"runtime/clSetEventCallback\"\n  \"runtime/clCreateKernelsInProgram\"\n  \"runtime/clFinish\"\n  \"runtime/test_enqueue_kernel_from_binary\"\n  \"runtime/test_user_event\"\n  \"runtime/clSetMemObjectDestructorCallback\"\n  APPEND PROPERTY LABELS \"hsa-native\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/doc/sphinx/source/faq.rst": "Frequently asked questions\n==========================\n\nCommon problems and questions related to using and developing pocl\nare listed here.\n\nUsing pocl\n----------\n\n.. _supported-compilers:\n\nSupported compilers and compiler combinations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPocl usually uses two different compilers (though may be built\nusing only one). One is used to compile C and C++ files - this is usually\nthe \"system compiler\". It's specified by CC and CXX vars to configure\nscript, or CMAKE_C{,XX}_COMPILER variables to cmake, but usually just\nleft to default. The second compiler is used to build OpenCL files - this\nis always clang+llvm. It's specified by LLVM_CONFIG=<path> to configure,\nor -DWITH_LLVM_CONFIG=<path> to cmake.\n\nYou may use clang as both \"system\" and OpenCL compiler for pocl.\nNote however that pocl uses the CXX_FLAGS *which the 2nd compiler (clang)\nwas built with*, to build parts of pocl that link with that compiler. This\nmay cause some issues, if you try to build pocl with a different compiler\nas the one used to build the 2nd compiler - because gcc and clang are not\n100% compatible with each other in flags. So far though we've only seen\nwarnings about unknown flags, not actual bugs.\n\nAnyway, the most trouble-free solution is to use the same \"system\" compiler\nto build pocl, as the one that was used to build the 2nd compiler. Note that\nwhile most Linux distributions use gcc to build their clang/llvm,\nthe official downloads from llvm.org are built using clang.\n\nPocl is not listed by clinfo / is not found\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOccasionally, proprietary implementations rewrite the ICD loader by their own\nversion. E.g. Intel SDK installer silently replaces\n``/usr/lib/x86_64-linux-gnu/libOpenCL.so`` with a link to\n``/etc/alternatives/opencl-libOpenCL.so`` which itself is a link to the intel's\nlibOpenCL implementation. The fix is to remove the symlinks manually\nand reinstall the ICD loader after which both pocl and the Intel SDK\ncan be used through the ICD loader.\n\nDeadlocks (freezes) on FreeBSD\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe issue here is that a library may not initialize the threading on BSD\nindependently. \nThis will cause pocl to stall on some uninitialized internal mutex.\nSee: http://www.freebsd.org/cgi/query-pr.cgi?pr=163512\n\nA simple work-around is to compile the OpenCL application with \"-pthread\", \nbut this of course cannot be enforced from pocl, especially if an ICD loader \nis used. The internal testsuite works only if \"-pthread\" is passed \nto ./configure in CFLAGS and CXXFLAGS, even if an ICD loader is used.\n\nclReleaseDevice or clCreateImage missing when linking against -lOpenCL (ICD)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThese functions were introduced in OpenCL 1.2. If you have built your ICD\nloader against 1.1 headers, you cannot access the pocl implementations of\nthem because they are missing from the ICD dispatcher.\n\nThe solution is to rebuild the ICD loader against OpenCL 1.2 headers.\n\nSee: https://github.com/pocl/pocl/issues/27\n\n\"Two passes with the same argument (-barriers) attempted to be registered!\"\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf you see this error::\n\n  Two passes with the same argument (-barriers) attempted to be registered!\n  UNREACHABLE executed at <path..>/include/llvm/Support/PassNameParser.h:73!\n\nIt's caused by initializers of static variables (like pocl's LLVM Pass names)\ncalled more than once. This happens for example when you link libpocl twice\nto your program.\n\nOne way that could happen, is building pocl with ``--disable-icd`` while having\nhwloc \"plugins\" package installed (with the opencl plugin). What happens is:\n\n* libpocl.so gets built, and also libOpenCL.so which is it's copy\n* program gets linked to the built libOpenCL.so; that is linked to hwloc\n* at runtime, hwloc will try to open the hwloc-opencl plugin; that links to\n  system-installed libOpenCL.so (usually the ICD loader);\n* the ICD loader will try to dlopen libpocl.so -> you get the error.\n\nThe solution is either to use ``--enable-icd --disable-direct-linkage``, or\nto uninstall the hwloc \"plugins\" package.\n\nWhy is pocl slow?\n^^^^^^^^^^^^^^^^^\n\nIf pocl's kernel build seems really slow, it is very possible you have\nbuilt your LLVM with Debug+Asserts on (not configure --enable-optimized).\nThis should result in up to 10x kernel compiler slow downs. You can\nreally feel it when running 'make check', for example.\n\nThe kernel compiler cache often removes that overhead when you\nrun your OpenCL app the next time.\n\nIf pocl is otherwise slower than other OpenCL implementations, it's normal. \npocl is known to run certain benchmarks faster, certain ones slower, \nwhen comparing against the Intel and AMD OpenCL SDKs. We hope to improve \nthe performance in each release, so if you encounter performance \nregressions (an older pocl/LLVM version used to run an app faster), \nplease report a bug.\n\npocl source code\n----------------\n\nWhy C99 in host library?\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe kernel compiler passes and some of the driver implementations are in C++11\nand it's much faster to implement things in C++11. Why require using C99 in\nthe host library?\n\npocl is meant to be very portable to various type of devices, also\nto those with very little resources (no operating system at all and with pruned\nruntime libraries). C has better portability to low end CPUs and VMs.\n\nThus, in order for a CPU to act as an OpenCL host without online kernel\ncompilation support, only C99 support is required from the target,\nno C++ compiler, runtime or STL is needed. Also, C programs are said to\nsometimes produce more \"lightweight\" binaries, but that is debatable.\nBenchmarks\n==============\n\nCLPeak issues\n----------------\n\nCurrently (Dec 2017) does not work. First, there's a global memory size\ndetection bug in CLPeak which makes it fail on all OpenCL calls (this\ncan be workarounded by using POCL_MEMORY_LIMIT=1). Second, compilation\ntakes forever - this can't be fixed in pocl and needs to be fixed in\neither CLPeak or LLVM. CLPeak sources use recursive macros to create\na giant stream of instructions. Certain optimization passes\nin LLVM seem to explode exponentially on this code. The second\nconsequence of giant instruction stream is, it easily overflows the\ninstruction caches of a CPU, therefore CLPeak results are highly\ndependent on whether the compiler manages to fit the code into icache,\nperhaps using loop re-rolling, and as such are not a reliable measure\nof peak device FLOPS.\n\nLuxmark issues\n---------------\n\n* Using the binary downloaded from www.luxmark.info might lead to pocl\n  abort on creating cache directory. This is not a bug in Pocl, it's a\n  consequence of the two programs (pocl & luxmark) having been compiled\n  with different libstdc++. Using a distribution packaged Luxmark\n  fixes this problem.\n\n* It's recommended to remove luxmark cache (~/.config/luxrender.net)\n  after updating pocl version.\n\n* There's another bug (http://www.luxrender.net/mantis/view.php?id=1640)\n  - it crashes after compiling kernels, because it doesn't recognize\n  an OpenCL device. This requires editing scenes/<name>/render.cfg,\n  you must add ``opencl.cpu.use = 0`` and ``film.opencl.device = 0``\n\n* All scenes (Microphone, Luxball and Hotel) should compile & run\n  with LLVM 6 and newer.\n",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/doc/sphinx/source/install.rst": ".. _pocl-install:\n\n============\nInstallation\n============\n\nRequirements\n------------\n\nIn order to build pocl, you need the following support libraries and\ntools:\n\n  * Latest released version of LLVM & Clang\n  * development files for LLVM & Clang + their transitive dependencies\n    (e.g. libclang-dev, libllvm-dev, zlib1g-dev, libtinfo-dev...)\n  * GNU make or ninja\n  * pthread (should be installed by default)\n  * Optional: hwloc v1.0 or newer (e.g. libhwloc-dev)\n  * pkg-config\n  * cmake\n\nInstalling requirements for Ubuntu::\n\n    apt install -y build-essential ocl-icd-libopencl1 cmake git pkg-config libclang-dev clang llvm make ninja-build ocl-icd-libopencl1 ocl-icd-dev ocl-icd-opencl-dev libhwloc-dev zlib1g zlib1g-dev clinfo dialog apt-utils libxml2-dev\n\nIf you're using LLVM 10 or newer, additionally you must::\n\n    apt install -y libclang-cpp${LLVM_VERSION}-dev libclang-cpp${LLVM_VERSION} llvm-${LLVM_VERSION}-dev\n\nInstalling requirements for Arch Linux::\n\n    pacman -S gcc patch hwloc cmake git pkg-config make ninja ocl-icd clang llvm llvm-libs clinfo opencl-headers\n\nInstalling requirements for Fedora::\n\n    dnf install gcc gcc-c++ clinfo hwloc-devel hwloc-libs cmake git-core pkgconfig make ninja-build ocl-icd ocl-icd-devel clang clang-devel clang-libs llvm llvm-devel llvm-libs patch redhat-rpm-config findutils\n\nThere are also Dockerfiles available for a few most common linux\ndistributions in ``tools/docker``, looking into them might be helpful.\n\nClang / LLVM Notes\n------------------\n\n**IMPORTANT NOTE!** Some targets (TCE and possibly HSA) require that\nyou compile & build LLVM with RTTI on. It can be enabled on cmake command\nline, as follows::\n\n    cmake [other CMake options] -DLLVM_ENABLE_RTTI=ON -DLLVM_ENABLE_EH=ON <llvm-source-directory>\n\nSupported LLVM versions\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n  Note that pocl aims to support **the latest LLVM version** at the time\n  of pocl release, **plus the previous** LLVM version. All older LLVM\n  versions are supported with \"best effort\" basis; there might not be\n  build bots continuously testing the code base nor anyone fixing their\n  possible breakage.\n\nConfigure & Build\n-----------------\n\nCMake version 2.8.12 or higher is required.\n\nThe build+install is the usual CMake way::\n\n  cd <directory-with-pocl-sources>\n  mkdir build\n  cd build\n  cmake [-D<option>=<value> ...] ..\n  make && make install\n\nTo see the default detected values, run ``cmake ..`` without any options,\nit will produce a summary.\n\nCMake variables\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nSince pocl includes a compiler for the kernels, it both compiles (producing\ncode) and is compiled (it consists of code). This distinction typically called\n\"host\" and \"target\": The host is where pocl is running, the target is\nwhere the OpenCL code will be running. These two systems can be wildly\ndifferent.\n\nHost compiler used to compile pocl can be GCC or Clang; the target\ncompiler is always Clang+LLVM since pocl uses Clang/LLVM internally.\nFor host compiler, you should use the one which your LLVM was compiled\nwith (because the LLVM-related parts of pocl take LLVM's CXXFLAGS from\nllvm-config and pass them to the host compiler).\n\nCMake host flags\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nCompile C:\n  CMAKE_C_FLAGS\n  CMAKE_C_FLAGS_<build-type>\n\nCompile C++:\n  CMAKE_CXX_FLAGS\n  CMAKE_CXX_FLAGS_<build-type>\n\nBuilding kernels and the kernel library, i.e. target flags\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nAll of these empty by default. There are hardcoded defaults which may\nbe overridden by setting these variables (rarely needed).\n\nExtra parameters to llc\n   EXTRA_HOST_LLC_FLAGS\n\nExtra parameters to clang\n   EXTRA_HOST_CLANG_FLAGS\n\nExtra parameters to linker (links kernel to shared library\nwhich is then dlopened):\n\nEXTRA_HOST_LD_FLAGS\n\nEXTRA_KERNEL_FLAGS\n  is applied to all kernel library compilation commands, IOW it's for\n  language-independent options\n\nEXTRA_KERNEL_{C,CL,CXX}_FLAGS\n  cmake variables for per-language options for kernel library compilation\n\n\n\nCMake: other options & features\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNote that there are a few more packaging-related options described\nin ``README.packaging``.\n\nFor multiple-item options like KERNELLIB_HOST_CPU_VARIANTS,\nuse \";\" as separator (you'll have to escape it for bash).\n\n- ``-DWITH_LLVM_CONFIG=<path-to-llvm-config>``\n  **IMPORTANT** Path to a llvm-config binary.\n  This determines the LLVM installation used by pocl.\n  If not specified, pocl will try to find and link against\n  llvm-config in PATH env var (usually means your system LLVM).\n\n- ``-DSINGLE_LLVM_LIB`` this is deprecated and has no effect (pocl now uses\n  llvm-config exclusively to get the LLVM library list)\n\n- ``-DSTATIC_LLVM`` pocl uses ``llvm-config --libs`` to get list of LLVM libraries\n  it should link to. With this flag enabled, it additionally passes ``--link-static``\n  to ``llvm-config``; otherwise it passes ``--link-shared``. Default is OFF (=shared).\n\n- ``-DENABLE_ICD`` By default pocl's buildsystem will try to find an ICD\n  and build pocl as a dynamic library named \"libpocl\". This option is useful\n  if you want to avoid ICD and build pocl directly as libOpenCL library.\n  See also :ref:`linking-with-icd`\n\n- ``-DENABLE_FP64`` - for ARM platform only. If your CPU doesn't support any\n  doubles (VFP is enough), disable this. Defaults to OFF when LLVM is older\n  than 4.0, otherwise defaults to ON.\n\n- ``-DPOCL_INSTALL_<something>_DIR`` The equivalent of ``--bindir``,\n  ``--sbindir`` etc fine-tuning of paths for autotools. See the beginning\n  of toplevel CMakeLists.txt for all the variables.\n\n  Note that if ``CMAKE_INSTALL_PREFIX`` equals ``/usr`` then pocl.icd is\n  installed to ``/etc/OpenCL/vendors``, otherwise it's installed to\n  ``${CMAKE_INSTALL_PREFIX}/etc/OpenCL/vendors``.\n\n- ``-DLLC_HOST_CPU=<something>``\n  Defaults to auto-detection via ``llc``. Run ``llc -mcpu=help``\n  for valid values. The CPU type is required to compile\n  the \"target\" (kernel library) part of CPU backend.\n\n  This variable overrides LLVM's autodetected host CPU at configure time.\n  Useful when llc fails to detect the CPU (often happens on non-x86\n  platforms, or x86 with CPU newer than LLVM).\n\n  Note that when this is set (set by default) and the\n  KERNELLIB_HOST_CPU_VARIANTS variable is not ``distro``,\n  pocl will first try to find compiled kernel library\n  for runtime-detected CPU then fallback to LLC_HOST_CPU.\n  This works well if pocl is run where it was built,\n  or the actual CPU is in the KERNELLIB_HOST_CPU_VARIANTS list,\n  or the actual CPU is >= LLC_HOST_CPU feature-wise;\n  otherwise it will likely fail with illegal instruction at runtime.\n\n- ``-DKERNELLIB_HOST_CPU_VARIANTS`` You can control which CPUs the\n  \"target\" part of CPU backend will be built for.\n  Unlike LLC_HOST_CPU, this variable is useful if you plan\n  to build for multiple CPUs. Defaults to \"native\" which is\n  automagically replaced by LLC_HOST_CPU.\n  Available CPUs are listed by ``llc -mcpu=help``. See above for\n  runtime CPU detection rules.\n\n  Note that there's another valid value on x86(64) platforms.\n  If set to ``distro``, the KERNELLIB_HOST_CPU_VARIANTS variable will be\n  set up with a few preselected sse/avx variants covering 99.99% of x86\n  processors, and the runtime CPU detection is slightly altered: pocl\n  will find the suitable compiled library based on detected CPU features,\n  so it cannot fail (at worst it'll degrade to SSE2 library).\n\n- ``-DLLC_TRIPLE=<something>`` Controls what target triple pocl is built for.\n  You can set this manually in case the autodetection fails.\n  Example value: ``x86_64-pc-linux-gnu``\n\n- ``-DENABLE_TESTSUITES`` Which external (source outside pocl) testsuites to enable.\n  For the list of testsuites, see examples/CMakeLists.txt or the ``examples``\n  directory. Set to ``all`` and pocl will try to autodetect & enable everything\n  it can.\n\n  Note that you may build testsuites outside pocl's build tree, and test\n  multiple pocl builds with a single testsuite directory. To use this,\n  run cmake with ``-DTESTSUITE_BASEDIR=<tests-builddir>`` and ``-DTESTSUITE_SOURCE_BASEDIR=<tests-sourcedir>``.\n  The directory structure mirrors that of ``pocl/examples``. So to build e.g. AMD SDK 2.9\n  with ``-DTESTSUITE_BASEDIR=/home/pocltest-build -DTESTSUITE_SOURCE_BASEDIR=/home/pocltest-src``,\n  place the ``AMD-APP-SDK-v2.9-RC-lnx64.tgz`` file into ``/home/pocltest-src/AMDSDK2.9`` directory.\n\n- ``-DENABLE_CONFORMANCE=ON/OFF``\n  Ensures that certain build options which would result in non-conformant pocl\n  build stay disabled. Defaults to ON. Note that this does not quarantee a\n  fully conformant build of pocl by itself. See :ref:`pocl-conformance` for details.\n\n- ``-DENABLE_{A,L,T,UB}SAN`` - compiles pocl's host code (and tests\n  + examples) with various sanitizers. Using more than one sanitizer at\n  a time is untested. Using together with ``-DENABLE_ICD=OFF`` is highly\n  recommended to avoid issues with loading order of sanitizer libraries.\n\n- ``-DENABLE_{CUDA,TCE,HSA}=ON/OFF`` - enable various (non-CPU) backends.\n  Usually requires some extra setup; see their documentation.\n\n- ``-DPOCL_DEBUG_MESSAGES=ON`` - when disabled, pocl is compiled without\n  debug messages (POCL_DEBUG env var) support.\n\n- ``-DEXAMPLES_USE_GIT_MASTER=ON`` - when enabled, examples (external\n  programs in ``examples/`` directory) are built from their git branches\n  (if available), as opposed to default: building from release tars.\n\n- ``-DENABLE_POCL_FLOAT_CONVERSION=ON/OFF``\n  When enabled, OpenCL printf() call's f/e/g formatters are handled by pocl.\n  When disabled (default), these are handled by system C library. Can only\n  be enabled when Clang's compiler-rt library is present.\n\n- ``-DINTEL_SDE_AVX512=<PATH>``\n  Path to Intel\u00ae Software Development Emulator. When this option is given,\n  the LLVM host CPU is forcibly set to 'skylake-avx512', and the internal\n  tests are run through the Emulator. Mostly useful to test AVX512.\n\n.. _pocl-without-llvm:\n\nLLVM-less build\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can build a runtime-only pocl to run prebuilt pocl binaries on a device.\nTo do this\n\n* First, build a pocl with LLVM somewhere.\n* on that machine, set up env vars required for your device (if any), then\n  run ``bin/poclcc -l``. That should print something like::\n\n    LIST OF DEVICES:\n    0:\n     Vendor:   AuthenticAMD\n       Name:   pthread-AMD A10-7800 Radeon R7, 12 Compute Cores 4C+8G\n    Version:   OpenCL 2.0 pocl HSTR: pthread-x86_64-unknown-linux-gnu-bdver3\n\nThe string after \"HSTR:\" is the device build hash.\n\n* now build the LLVM-less pocl. You will need the device build hash from\n  previous step:\n\n  ``cmake -DOCS_AVAILABLE=0 -DHOST_DEVICE_BUILD_HASH=<something> ...``\n\n  This is required because pocl binaries contain a device hash, and the LLVM-less\n  pocl needs to know which binaries it can load.\n\n\nCross-compile pocl LLVM-less build\n-----------------------------------\nIt's now possible to cross-compile pocl on x86-64 to run on ARM/MIPS/etc,\nbut only the LLVM-less build. There is a ToolchainExample.cmake file;\ncopy it under different name, then follow the instructions in the file.\n\n\nKnown build-time issues\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nThere are unsolved issues and bugs in pocl. See the bug listing\nfor a complete listing at https://github.com/pocl/pocl/issues\n\nKnown issues not related to pocl are listed below.\n\n- Using Clang compiled with gcc 4.7 causes indeterminism in the\n  kernel compilation results. See LLVM bug report:\n  http://llvm.org/bugs/show_bug.cgi?id=12945\n\nbuilding / running in Docker\n--------------------------------\n\nInstall Docker\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n* install docker for your distribution\n* start the docker daemon\n* make sure you have enough space (default location is usually ``/var/lib/docker``,\n  required storage for standard pocl build is about 1.5 GB per container,\n  and more than 10GB for TCE/PHSA builds)\n\nBuild & start Pocl container\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n* create an empty directory <D>\n* copy Dockerfile of your choice (any file from tools/docker/) to ``<D>/Dockerfile``\n* ``cd <D> ; sudo docker build -t TAG .`` .. where TAG is a name you can choose for the build.\n* ``sudo docker run -t TAG``\n* this will by default use master branch of pocl git; to use a different branch/commit,\n  run docker build with ``--build-arg GIT_COMMIT=<branch/commit>``\n\nDockerfiles\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNote that some images (e.g. RHEL and PHSA) may be impossible to build,\ndue to not having a sufficiently new version of LLVM available.\n\nDockerfiles are named according to what they build, or the release they're based on:\n\n* `default`: builds pocl, then runs the internal tests from build dir.\n   Uses latest release of a distribution, with whatever is the default version of LLVM.\n* `distro`: does a distribution-friendly build: enables runtime detection of CPU,\n   installs pocl into system path, then runs the internal tests\n* `<release>`: same as above, except uses specific release and specific LLVM version\n  (the latest available in that release).\n* `X.32bit`: same as X but sets up i386 environment\n* `conformance`: builds & installs Pocl, then runs conformance test suite\n  (the shortest version of it)\n\nSome additional notes:\n\n* TCE is built using three stages (LLVM, TCE, pocl)\n* PHSA built using three stages (LLVM, PHSA runtime, pocl)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/.git/objects/pack/pack-9314dd2eca6c8d38896aa377ee3d72ab50b8273b.pack",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/.git/objects/pack/pack-9314dd2eca6c8d38896aa377ee3d72ab50b8273b.idx",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/tests/runtime/clGetKernelArgInfo.spir64_nometa",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/tests/runtime/clGetKernelArgInfo.spir64_meta",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/tests/runtime/clGetKernelArgInfo.spir32_meta",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/tests/runtime/clGetKernelArgInfo.spir32_nometa",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example0/example0.spirv32",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example0/example0.spirv64",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example0/example0.spir64",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example0/example0.spir32",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/matrix1/matrix1.spir64",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/matrix1/matrix1.spir32",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example2/example2.spir64",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example2/example2.spir32",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example1/example1.spirv64",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example1/example1.spir64",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example1/example1.spir32",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example2a/example2a.spir64",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/example2a/example2a.spir32",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/pocl-android-sample/res/drawable-mdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/pocl-android-sample/res/drawable-hdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/pocl-android-sample/res/drawable-xhdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/examples/pocl-android-sample/res/drawable-xxhdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/doc/www/img/pocl-nvidia-SHOC-April17.png",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/doc/www/img/pocl-nvidia-SHOC-October20.png",
        "/tmp/vanessa/spack-stage/spack-stage-pocl-master-qdpky7urexpxgwr3rfjoewrvfpwmn3zu/spack-src/doc/www/img/pocl-80x60.png"
    ],
    "total_files": 1753
}