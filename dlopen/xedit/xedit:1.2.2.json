{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-xedit-1.2.2-556ajlguprknxqtlunwmcjbqrobn4wzd/spack-src/lisp/require.c": "/*\n * Copyright (c) 2001 by The XFree86 Project, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *  \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF\n * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * Except as contained in this notice, the name of the XFree86 Project shall\n * not be used in advertising or otherwise to promote the sale, use or other\n * dealings in this Software without prior written authorization from the\n * XFree86 Project.\n *\n * Author: Paulo C\u00e9sar Pereira de Andrade\n */\n\n/* $XFree86: xc/programs/xedit/lisp/require.c,v 1.17tsi Exp $ */\n\n#include \"lisp/require.h\"\n\n/*\n * Implementation\n */\nLispObj *\nLisp_Load(LispBuiltin *builtin)\n/*\n load filename &key verbose print if-does-not-exist\n */\n{\n    LispObj *filename, *verbose, *print, *if_does_not_exist;\n\n    if_does_not_exist = ARGUMENT(3);\n    print = ARGUMENT(2);\n    verbose = ARGUMENT(1);\n    filename = ARGUMENT(0);\n\n    if (PATHNAMEP(filename))\n\tfilename = CAR(filename->data.pathname);\n    else {\n\tCHECK_STRING(filename);\n    }\n\n    return (LispLoadFile(filename,\n\t\t\t verbose != UNSPEC && verbose != NIL,\n\t\t\t print != UNSPEC && print != NIL,\n\t\t\t if_does_not_exist != UNSPEC &&\n\t\t\t if_does_not_exist != NIL));\n}\n\nLispObj *\nLisp_Require(LispBuiltin *builtin)\n/*\n require module &optional pathname\n */\n{\n    char filename[1024], *ext;\n    int len;\n\n    LispObj *obj, *module, *pathname;\n\n    pathname = ARGUMENT(1);\n    module = ARGUMENT(0);\n\n    CHECK_STRING(module);\n    if (pathname != UNSPEC) {\n\tif (PATHNAMEP(pathname))\n\t    pathname = CAR(pathname->data.pathname);\n\telse {\n\t    CHECK_STRING(pathname);\n\t}\n    }\n    else\n\tpathname = module;\n\n    for (obj = MOD; CONSP(obj); obj = CDR(obj)) {\n\tif (strcmp(THESTR(CAR(obj)), THESTR(module)) == 0)\n\t    return (module);\n    }\n\n    if (THESTR(pathname)[0] != '/') {\n#ifdef LISPDIR\n\tsnprintf(filename, sizeof(filename), \"%s\", LISPDIR);\n#else\n\tgetcwd(filename, sizeof(filename));\n#endif\n    }\n    else\n\tfilename[0] = '\\0';\n    *(filename + sizeof(filename) - 5) = '\\0';\t/* make sure there is place for ext */\n    len = strlen(filename);\n    if (!len || filename[len - 1] != '/') {\n\tstrcat(filename, \"/\");\n\t++len;\n    }\n\n    snprintf(filename + len, sizeof(filename) - len - 5, \"%s\", THESTR(pathname));\n\n    ext = filename + strlen(filename);\n\n#ifdef SHARED_MODULES\n    strcpy(ext, \".so\");\n    if (access(filename, R_OK) == 0) {\n\tLispModule *lisp_module;\n\tchar data[64];\n\tint len;\n\n\tif (lisp__data.module == NULL) {\n\t    /* export our own symbols */\n\t    if (dlopen(NULL, RTLD_LAZY | RTLD_GLOBAL) == NULL)\n\t\tLispDestroy(\"%s: \", STRFUN(builtin), dlerror());\n\t}\n\n\tlisp_module = (LispModule*)LispMalloc(sizeof(LispModule));\n\tif ((lisp_module->handle =\n\t     dlopen(filename, RTLD_LAZY | RTLD_GLOBAL)) == NULL)\n\t    LispDestroy(\"%s: dlopen: %s\", STRFUN(builtin), dlerror());\n\tsnprintf(data, sizeof(data), \"%sLispModuleData\", THESTR(module));\n\tif ((lisp_module->data =\n\t     (LispModuleData*)dlsym(lisp_module->handle, data)) == NULL) {\n\t    dlclose(lisp_module->handle);\n\t    LispDestroy(\"%s: cannot find LispModuleData for %s\",\n\t\t\tSTRFUN(builtin), STROBJ(module));\n\t}\n\tLispMused(lisp_module);\n\tlisp_module->next = lisp__data.module;\n\tlisp__data.module = lisp_module;\n\tif (lisp_module->data->load)\n\t    (lisp_module->data->load)();\n\n\tif (MOD == NIL)\n\t    MOD = CONS(module, NIL);\n\telse {\n\t    RPLACD(MOD, CONS(CAR(MOD), CDR(MOD)));\n\t    RPLACA(MOD, module);\n\t}\n\tLispSetVar(lisp__data.modules, MOD);\n\n\treturn (module);\n    }\n#endif\n\n    strcpy(ext, \".lsp\");\n    (void)LispLoadFile(STRING(filename), 0, 0, 0);\n\n    return (module);\n}\n"
    },
    "skipped": [],
    "total_files": 114
}