{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-guacamole-server-1.1.0-argaczfjofiwgfbbyr6a5emw7qfwkfjw/spack-src/configure.ac": "#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nAC_PREREQ([2.61])\nAC_INIT([guacamole-server], [1.1.0])\nAC_CONFIG_AUX_DIR([build-aux])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign subdir-objects])\nAM_SILENT_RULES([yes])\n\nLT_PREREQ([2.2])\nLT_INIT([dlopen])\n\nAC_CONFIG_HEADER([config.h])\nAC_CONFIG_MACRO_DIR([m4])\n\n# Use TAP test driver for tests (part of automake)\nAC_REQUIRE_AUX_FILE([tap-driver.sh])\n\n# Programs\nAC_PROG_CC\nAC_PROG_CC_C99\nAC_PROG_LIBTOOL\n\n# Headers\nAC_CHECK_HEADERS([fcntl.h stdlib.h string.h sys/socket.h time.h sys/time.h syslog.h unistd.h cairo/cairo.h pngstruct.h])\n\n# Source characteristics\nAC_DEFINE([_XOPEN_SOURCE], [700], [Uses X/Open and POSIX APIs])\nAC_DEFINE([__BSD_VISIBLE], [1], [Uses BSD-specific APIs (if available)])\n\n# Check for whether math library is required\nAC_CHECK_LIB([m], [cos],\n             [MATH_LIBS=-lm],\n             [AC_CHECK_DECL([cos],,\n                            AC_MSG_ERROR(\"Complex math functions are missing and no libm was found\")\n                            [#include <math.h>])])\n\n# libpng\nAC_CHECK_LIB([png], [png_write_png], [PNG_LIBS=-lpng],\n             AC_MSG_ERROR(\"libpng is required for writing png messages\"))\n\n# libjpeg\nAC_CHECK_LIB([jpeg], [jpeg_start_compress], [JPEG_LIBS=-ljpeg],\n             AC_MSG_ERROR(\"libjpeg is required for writing jpeg messages\"))\n\n# Cairo\nAC_CHECK_LIB([cairo], [cairo_create], [CAIRO_LIBS=-lcairo],\n             AC_MSG_ERROR(\"Cairo is required for drawing instructions\"))\n\n# libpthread\nAC_CHECK_LIB([pthread], [pthread_create], [PTHREAD_LIBS=-lpthread\n              AC_DEFINE([HAVE_LIBPTHREAD],,\n                        [Whether libpthread was found])])\n\n# Include libdl for dlopen() if necessary\nAC_CHECK_LIB([dl], [dlopen],\n             [DL_LIBS=-ldl],\n             [AC_CHECK_DECL([dlopen],,\n                            AC_MSG_ERROR(\"libdl is required on systems which do not otherwise provide dlopen()\"),\n                            [#include <dlfcn.h>])])\n\n# OSSP UUID\nAC_CHECK_LIB([ossp-uuid], [uuid_make], [UUID_LIBS=-lossp-uuid],\n             AC_CHECK_LIB([uuid], [uuid_make], [UUID_LIBS=-luuid],\n                          AC_MSG_ERROR(\"The OSSP UUID library is required\")))\n\n# Check for and validate OSSP uuid.h header\nAC_CHECK_HEADERS([ossp/uuid.h])\nAC_CHECK_DECL([uuid_make],,\n              AC_MSG_ERROR(\"No OSSP uuid.h found in include path\"),\n              [#ifdef HAVE_OSSP_UUID_H\n               #include <ossp/uuid.h>\n               #else\n               #include <uuid.h>\n               #endif\n               ])\n\n# cunit\nAC_CHECK_LIB([cunit], [CU_run_test], [CUNIT_LIBS=-lcunit])\n\nAC_SUBST(DL_LIBS)\nAC_SUBST(MATH_LIBS)\nAC_SUBST(PNG_LIBS)\nAC_SUBST(JPEG_LIBS)\nAC_SUBST(CAIRO_LIBS)\nAC_SUBST(PTHREAD_LIBS)\nAC_SUBST(UUID_LIBS)\nAC_SUBST(CUNIT_LIBS)\n\n# Library functions\nAC_CHECK_FUNCS([clock_gettime gettimeofday memmove memset select strdup nanosleep])\n\nAC_CHECK_DECL([png_get_io_ptr],\n\t[AC_DEFINE([HAVE_PNG_GET_IO_PTR],,\n               [Whether png_get_io_ptr() is defined])],,\n\t[#include <png.h>])\n\nAC_CHECK_DECL([cairo_format_stride_for_width],\n\t[AC_DEFINE([HAVE_CAIRO_FORMAT_STRIDE_FOR_WIDTH],,\n               [Whether cairo_format_stride_for_width() is defined])],,\n\t[#include <cairo/cairo.h>])\n\nAC_CHECK_DECL([poll],\n\t[AC_DEFINE([HAVE_POLL],,\n               [Whether poll() is defined])],,\n\t[#include <poll.h>])\n\nAC_CHECK_DECL([strlcpy],\n\t[AC_DEFINE([HAVE_STRLCPY],,\n               [Whether strlcpy() is defined])],,\n\t[#include <string.h>])\n\nAC_CHECK_DECL([strlcat],\n\t[AC_DEFINE([HAVE_STRLCAT],,\n               [Whether strlcat() is defined])],,\n\t[#include <string.h>])\n\n# Typedefs\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\n\n# Bundled libguac\nAC_SUBST([LIBGUAC_LTLIB],   '$(top_builddir)/src/libguac/libguac.la')\nAC_SUBST([LIBGUAC_INCLUDE], '-I$(top_srcdir)/src/libguac')\n\n# Common non-libguac utility library\nAC_SUBST([COMMON_LTLIB],   '$(top_builddir)/src/common/libguac_common.la')\nAC_SUBST([COMMON_INCLUDE], '-I$(top_srcdir)/src/common')\n\n# Common PulseAudio utility library\nAC_SUBST([PULSE_LTLIB],   '$(top_builddir)/src/pulse/libguac_pulse.la')\nAC_SUBST([PULSE_INCLUDE], '-I$(top_srcdir)/src/pulse')\n\n# Common base SSH client\nAC_SUBST([COMMON_SSH_LTLIB],   '$(top_builddir)/src/common-ssh/libguac_common_ssh.la')\nAC_SUBST([COMMON_SSH_INCLUDE], '-I$(top_srcdir)/src/common-ssh')\n\n# RDP support\nAC_SUBST([LIBGUAC_CLIENT_RDP_LTLIB],   '$(top_builddir)/src/protocols/rdp/libguac-client-rdp.la')\nAC_SUBST([LIBGUAC_CLIENT_RDP_INCLUDE], '-I$(top_srcdir)/src/protocols/rdp')\n\n# Terminal emulator\nAC_SUBST([TERMINAL_LTLIB],   '$(top_builddir)/src/terminal/libguac_terminal.la')\nAC_SUBST([TERMINAL_INCLUDE], '-I$(top_srcdir)/src/terminal $(PANGO_CFLAGS) $(PANGOCAIRO_CFLAGS) $(COMMON_INCLUDE)')\n\n# Init directory\nAC_ARG_WITH(init_dir,\n            [AS_HELP_STRING([--with-init-dir=<path>],\n                            [install init scripts to the given directory])\n            ],init_dir=$withval)\nAM_CONDITIONAL([ENABLE_INIT], [test \"x${init_dir}\" != \"x\"])\nAC_SUBST(init_dir)\n\n# Systemd directory\nAC_ARG_WITH(systemd_dir,\n            [AS_HELP_STRING([--with-systemd-dir=<path>],\n                            [install systemd units to the given directory])\n            ],systemd_dir=$withval)\nAM_CONDITIONAL([ENABLE_SYSTEMD], [test \"x${systemd_dir}\" != \"x\"])\nAC_SUBST(systemd_dir)\n\n# guacd config file\nAC_ARG_WITH(guacd_conf,\n            [AS_HELP_STRING([--with-guacd-conf=<path>],\n                            [the full path to the guacd config file @<:@default=/etc/guacamole/guacd.conf@:>@])],\n            [guacd_conf=$withval],\n            [guacd_conf=/etc/guacamole/guacd.conf])\nAC_DEFINE_UNQUOTED([GUACD_CONF_FILE], [\"$guacd_conf\"], [The full path to the guacd config file])\n\n#\n# libavcodec\n#\n\nhave_libavcodec=disabled\nAC_ARG_WITH([libavcodec],\n            [AS_HELP_STRING([--with-libavcodec],\n                            [use libavcodec when encoding video @<:@default=check@:>@])],\n            [],\n            [with_libavcodec=check])\n\nif test \"x$with_libavcodec\" != \"xno\"\nthen\n    have_libavcodec=yes\n    PKG_CHECK_MODULES([AVCODEC], [libavcodec],, [have_libavcodec=no]);\nfi\n\nAM_CONDITIONAL([ENABLE_AVCODEC], [test \"x${have_libavcodec}\" = \"xyes\"])\n\n#\n# libavutil\n#\n\nhave_libavutil=disabled\nAC_ARG_WITH([libavutil],\n            [AS_HELP_STRING([--with-libavutil],\n                            [use libavutil when encoding video @<:@default=check@:>@])],\n            [],\n            [with_libavutil=check])\n\nif test \"x$with_libavutil\" != \"xno\"\nthen\n    have_libavutil=yes\n    PKG_CHECK_MODULES([AVUTIL], [libavutil],, [have_libavutil=no]);\nfi\n\nAM_CONDITIONAL([ENABLE_AVUTIL], [test \"x${have_libavutil}\" = \"xyes\"])\n\n#\n# libswscale\n#\n\nhave_libswscale=disabled\nAC_ARG_WITH([libswscale],\n            [AS_HELP_STRING([--with-libswscale],\n                            [use libswscale when encoding video @<:@default=check@:>@])],\n            [],\n            [with_libswscale=check])\n\nif test \"x$with_libswscale\" != \"xno\"\nthen\n    have_libswscale=yes\n    PKG_CHECK_MODULES([SWSCALE], [libswscale],, [have_libswscale=no]);\nfi\n\nAM_CONDITIONAL([ENABLE_SWSCALE], [test \"x${have_libswscale}\" = \"xyes\"])\n\n#\n# libssl\n#\n\nhave_ssl=disabled\nSSL_LIBS=\nAC_ARG_WITH([ssl],\n            [AS_HELP_STRING([--with-ssl],\n                            [support SSL encryption @<:@default=check@:>@])],\n            [],\n            [with_ssl=check])\n\nif test \"x$with_ssl\" != \"xno\"\nthen\n    have_ssl=yes\n\n    AC_CHECK_HEADER(openssl/ssl.h,, [have_ssl=no])\n    AC_CHECK_LIB([ssl], [SSL_CTX_new], [SSL_LIBS=\"$SSL_LIBS -lssl -lcrypto\"], [have_ssl=no])\n\n    if test \"x${have_ssl}\" = \"xno\"\n    then\n        AC_MSG_WARN([\n  --------------------------------------------\n   Unable to find libssl.\n   guacd will not support SSL connections.\n  --------------------------------------------])\n    else\n        AC_DEFINE([ENABLE_SSL],, [Whether SSL-related support is enabled])\n\n        # OpenSSL 1.1 accessor function for DSA signature values\n        AC_CHECK_DECL([DSA_SIG_get0],\n            [AC_DEFINE([HAVE_DSA_SIG_GET0],,\n                       [Whether libssl provides DSA_SIG_get0()])],,\n            [#include <openssl/dsa.h>])\n\n        # OpenSSL 1.1 accessor function for DSA public key parameters\n        AC_CHECK_DECL([DSA_get0_pqg],\n            [AC_DEFINE([HAVE_DSA_GET0_PQG],,\n                       [Whether libssl provides DSA_get0_pqg()])],,\n            [#include <openssl/dsa.h>])\n\n        # OpenSSL 1.1 accessor function for DSA public/private key values\n        AC_CHECK_DECL([DSA_get0_key],\n            [AC_DEFINE([HAVE_DSA_GET0_KEY],,\n                       [Whether libssl provides DSA_get0_key()])],,\n            [#include <openssl/dsa.h>])\n\n        # OpenSSL 1.1 accessor function for RSA public/private key values\n        AC_CHECK_DECL([RSA_get0_key],\n            [AC_DEFINE([HAVE_RSA_GET0_KEY],,\n                       [Whether libssl provides RSA_get0_key()])],,\n            [#include <openssl/rsa.h>])\n\n        # OpenSSL 1.1 does away with explicit threading callbacks\n        AC_MSG_CHECKING([whether libssl requires threading callbacks])\n        AC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n\n            #include <openssl/opensslv.h>\n\n            #if OPENSSL_VERSION_NUMBER < 0x10100000L\n            #error Threading callbacks required.\n            #endif\n\n            int main() {\n                return 0;\n            }\n\n          ]])],\n          [AC_MSG_RESULT([no])],\n          [AC_MSG_RESULT([yes])\n           AC_DEFINE([OPENSSL_REQUIRES_THREADING_CALLBACKS],,\n                     [Whether OpenSSL requires explicit threading callbacks for threadsafety])])\n\n    fi\nfi\n\nAM_CONDITIONAL([ENABLE_SSL], [test \"x${have_ssl}\" = \"xyes\"])\nAC_SUBST(SSL_LIBS)\n\n#\n# Winsock\n#\n\nhave_winsock=disabled\nWINSOCK_LIBS=\nAC_ARG_WITH([winsock],\n            [AS_HELP_STRING([--with-winsock],\n                            [support Windows Sockets API @<:@default=check@:>@])],\n            [],\n            [with_winsock=check])\n\nif test \"x$with_winsock\" != \"xno\"\nthen\n    have_winsock=yes\n    AC_CHECK_LIB([wsock32], [main],\n                 [WINSOCK_LIBS=\"-lwsock32\"]\n                 [AC_DEFINE([ENABLE_WINSOCK],,\n                            [Whether Windows Socket API support is enabled])],\n                 [have_winsock=no])\nfi\n\nAM_CONDITIONAL([ENABLE_WINSOCK], [test \"x${have_winsock}\" = \"xyes\"])\nAC_SUBST(WINSOCK_LIBS)\n\n#\n# Ogg Vorbis\n#\n\nhave_vorbis=disabled\nVORBIS_LIBS=\nAC_ARG_WITH([vorbis],\n            [AS_HELP_STRING([--with-vorbis],\n                            [support Ogg Vorbis @<:@default=check@:>@])],\n            [],\n            [with_vorbis=check])\n\nif test \"x$with_vorbis\" != \"xno\"\nthen\n    have_vorbis=yes\n\n    AC_CHECK_HEADER(vorbis/vorbisenc.h,, [have_vorbis=no])\n    AC_CHECK_LIB([ogg], [ogg_stream_init], [VORBIS_LIBS=\"$VORBIS_LIBS -logg\"], [have_vorbis=no])\n    AC_CHECK_LIB([vorbis], [vorbis_block_init], [VORBIS_LIBS=\"$VORBIS_LIBS -lvorbis\"], [have_vorbis=no])\n    AC_CHECK_LIB([vorbisenc], [vorbis_encode_init], [VORBIS_LIBS=\"$VORBIS_LIBS -lvorbisenc\"], [have_vorbis=no])\n\n    if test \"x${have_vorbis}\" = \"xno\"\n    then\n        AC_MSG_WARN([\n  --------------------------------------------\n   Unable to find libogg / libvorbis / libvorbisenc.\n   Sound will not be encoded with Ogg Vorbis.\n  --------------------------------------------])\n    else\n        AC_DEFINE([ENABLE_OGG],,\n                  [Whether support for Ogg Vorbis is enabled])\n    fi\nfi\n\nAM_CONDITIONAL([ENABLE_OGG], [test \"x${have_vorbis}\" = \"xyes\"])\nAC_SUBST(VORBIS_LIBS)\n\n#\n# PulseAudio\n#\n\nhave_pulse=disabled\nPULSE_LIBS=\nAC_ARG_WITH([pulse],\n            [AS_HELP_STRING([--with-pulse],\n                            [support PulseAudio @<:@default=check@:>@])],\n            [],\n            [with_pulse=check])\n\nif test \"x$with_pulse\" != \"xno\"\nthen\n    have_pulse=yes\n\n    AC_CHECK_LIB([pulse], [pa_context_new], [PULSE_LIBS=\"$PULSE_LIBS -lpulse\"], [have_pulse=no])\n\n    if test \"x${have_pulse}\" = \"xno\"\n    then\n        AC_MSG_WARN([\n  --------------------------------------------\n   Unable to find libpulse\n   Sound support for VNC will be disabled\n  --------------------------------------------])\n    else\n        AC_DEFINE([ENABLE_PULSE],, [Whether PulseAudio support is enabled])\n    fi\nfi\n\nAM_CONDITIONAL([ENABLE_PULSE], [test \"x${have_pulse}\" = \"xyes\"])\nAC_SUBST(PULSE_LIBS)\n\n#\n# PANGO\n#\n\nhave_pango=disabled\nAC_ARG_WITH([pango],\n            [AS_HELP_STRING([--with-pango],\n                            [support Pango text layout @<:@default=check@:>@])],\n            [],\n            [with_pango=check])\n\nif test \"x$with_pango\" != \"xno\"\nthen\n    have_pango=yes\n    PKG_CHECK_MODULES([PANGO], [pango],, [have_pango=no]);\n    PKG_CHECK_MODULES([PANGOCAIRO], [pangocairo],, [have_pango=no]);\nfi\n\n#\n# Terminal emulator\n#\n\nhave_terminal=disabled\nAC_ARG_WITH([terminal],\n            [AS_HELP_STRING([--with-terminal],\n                            [support text-based protocols @<:@default=check@:>@])],\n            [],\n            [with_terminal=check])\n\nif test \"x$with_terminal\" != \"xno\"\nthen\n    have_terminal=yes\n    if test \"x${have_pango}\" != \"xyes\"\n    then\n        have_terminal=no\n    fi\nfi\n\nAM_CONDITIONAL([ENABLE_TERMINAL], [test \"x${have_terminal}\" = \"xyes\"])\n\n#\n# libVNCServer\n#\n\nhave_libvncserver=disabled\nVNC_LIBS=\nAC_ARG_WITH([vnc],\n            [AS_HELP_STRING([--with-vnc],\n                            [support VNC @<:@default=check@:>@])],\n            [],\n            [with_vnc=check])\n\nif test \"x$with_vnc\" != \"xno\"\nthen\n    have_libvncserver=yes\n    AC_CHECK_LIB([vncclient], [rfbInitClient], [VNC_LIBS=\"$VNC_LIBS -lvncclient\"], [have_libvncserver=no])\nfi\n\nAM_CONDITIONAL([ENABLE_VNC], [test \"x${have_libvncserver}\" = \"xyes\"])\nAC_SUBST(VNC_LIBS)\n\n#\n# Repeater support within libVNCServer\n#\n\nif test \"x${have_libvncserver}\" = \"xyes\"\nthen\n\n    have_vnc_repeater=yes\n    AC_CHECK_MEMBERS([rfbClient.destHost, rfbClient.destPort],\n                     [], [have_vnc_repeater=no],\n                      [[#include <rfb/rfbclient.h>]])\n\n    if test \"x${have_vnc_repeater}\" = \"xno\"\n    then\n        AC_MSG_WARN([\n      --------------------------------------------\n       No repeater support found in libvncclient.\n       Support for VNC repeaters will not be built.\n      --------------------------------------------])\n    else\n        AC_DEFINE([ENABLE_VNC_REPEATER],,\n                  [Whether support for VNC repeaters is enabled.])\n    fi\n\nfi\n\n#\n# Listening support within libVNCServer\n#\n\nif test \"x${have_libvncserver}\" = \"xyes\"\nthen\n\n    have_vnc_listen=yes\n    AC_CHECK_DECL([listenForIncomingConnectionsNoFork],\n                  [], [have_vnc_listen=no],\n                  [[#include <rfb/rfbclient.h>]])\n\n    if test \"x${have_vnc_listen}\" = \"xno\"\n    then\n        AC_MSG_WARN([\n      --------------------------------------------\n       No listening support found in libvncclient.\n       Support for listen-mode connections will not be built.\n      --------------------------------------------])\n    else\n        AC_DEFINE([ENABLE_VNC_LISTEN],,\n                  [Whether support for listen-mode VNC connections is enabled.])\n    fi\n\nfi\n\n#\n# FreeRDP 2 (libfreerdp2, libfreerdp-client2, and libwinpr2)\n#\n\nhave_freerdp2=disabled\nFREERDP2_PLUGIN_DIR=\n\nAC_ARG_WITH([rdp],\n            [AS_HELP_STRING([--with-rdp],\n                            [support RDP @<:@default=check@:>@])],\n            [],\n            [with_rdp=check])\n\n# FreeRDP plugin directory\nAC_ARG_WITH(freerdp_plugin_dir,\n            [AS_HELP_STRING([--with-freerdp-plugin-dir=<path>],\n                            [install FreeRDP plugins to the given directory @<:@default=check@:>@])\n            ],FREERDP2_PLUGIN_DIR=$withval)\n\n# Preserve CPPFLAGS so it can be restored later, following the addition of\n# options specific to FreeRDP tests\nOLDCPPFLAGS=\"$CPPFLAGS\"\n\nif test \"x$with_rdp\" != \"xno\"\nthen\n    have_freerdp2=yes\n    PKG_CHECK_MODULES([RDP], [freerdp2 freerdp-client2 winpr2],\n                      [CPPFLAGS=\"${RDP_CFLAGS} -Werror $CPPFLAGS\"]\n                      [AS_IF([test \"x${FREERDP2_PLUGIN_DIR}\" = \"x\"],\n                             [FREERDP2_PLUGIN_DIR=\"`$PKG_CONFIG --variable=libdir freerdp2`/freerdp2\"])],\n                      [AC_MSG_WARN([\n  --------------------------------------------\n   Unable to find FreeRDP (libfreerdp2 / libfreerdp-client2 / libwinpr2)\n   RDP will be disabled.\n  --------------------------------------------])\n                       have_freerdp2=no])\nfi\n\n# Available color conversion functions\nif test \"x$have_freerdp2\" = \"xyes\"\nthen\n\n    # FreeRDP 2.0.0-rc3 and older referred to FreeRDPConvertColor() as\n    # ConvertColor()\n    AC_CHECK_DECL([FreeRDPConvertColor],\n                  [AC_DEFINE([HAVE_FREERDPCONVERTCOLOR],,\n                             [Whether FreeRDPConvertColor() is defined])],,\n                  [#include <freerdp/codec/color.h>])\n\nfi\n\n# Variation in memory internal allocation/free behavior\nif test \"x${have_freerdp2}\" = \"xyes\"\nthen\n\n    # FreeRDP 2.0.0-rc0 and older automatically free rdpBitmap and its\n    # associated data member within Bitmap_Free(), relying on the\n    # implementation-specific free handler to free only implementation-specific\n    # data. This changed in commit 2cf10cc, and implementations must now\n    # manually free all data associated with the rdpBitmap, even data which\n    # was not allocated by the implementation.\n    AC_MSG_CHECKING([whether Bitmap_Free() frees the rdpBitmap and its image data])\n    AC_EGREP_CPP([\\\"2\\\\.0\\\\.0-dev\\\"], [\n\n        #include <freerdp/version.h>\n        FREERDP_VERSION_FULL\n\n    ],\n    [AC_MSG_RESULT([yes])]\n    [AC_DEFINE([FREERDP_BITMAP_FREE_FREES_BITMAP],,\n               [Whether Bitmap_Free() frees the rdpBitmap and its image data])],\n    [AC_MSG_RESULT([no])])\n\nfi\n\n# Glyph callback variants\nif test \"x${have_freerdp2}\" = \"xyes\"\nthen\n\n    # FreeRDP 2.0.0-rc3 and older used UINT32 for integer parameters to all\n    # rdpGlyph callbacks\n    AC_MSG_CHECKING([whether rdpGlyph callbacks accept INT32 integer parameters])\n    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n\n        #include <freerdp/freerdp.h>\n        #include <freerdp/graphics.h>\n        #include <winpr/wtypes.h>\n\n        BOOL test_begindraw(rdpContext* context, INT32 x, INT32 y,\n                INT32 width, INT32 height, UINT32 fgcolor, UINT32 bgcolor,\n                BOOL redundant);\n\n        rdpGlyph glyph = {\n            .BeginDraw = test_begindraw\n        };\n\n        int main() {\n            return (int) glyph.BeginDraw(NULL, 0, 0, 0, 0, 0, 0, FALSE);\n        }\n\n    ]])],\n    [AC_MSG_RESULT([yes])]\n    [AC_DEFINE([FREERDP_GLYPH_CALLBACKS_ACCEPT_INT32],,\n               [Whether rdpGlyph callbacks accept INT32 integer parameters])],\n    [AC_MSG_RESULT([no])])\n\nfi\n\n# CLIPRDR callback variants\nif test \"x${have_freerdp2}\" = \"xyes\"\nthen\n\n    # FreeRDP 2.0.0-rc3 and older did not use const for CLIPRDR callbacks\n    AC_MSG_CHECKING([whether CLIPRDR callbacks require const for their final parameter])\n    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n\n        #include <freerdp/client/cliprdr.h>\n        #include <winpr/wtypes.h>\n\n        UINT test_monitor_ready(CliprdrClientContext* cliprdr,\n                const CLIPRDR_MONITOR_READY* monitor_ready);\n\n        CliprdrClientContext context = {\n            .MonitorReady = test_monitor_ready\n        };\n\n        int main() {\n            return (int) context.MonitorReady(NULL, NULL);\n        }\n\n    ]])],\n    [AC_MSG_RESULT([yes])]\n    [AC_DEFINE([FREERDP_CLIPRDR_CALLBACKS_REQUIRE_CONST],,\n               [Whether CLIPRDR callbacks require const for the final parameter])],\n    [AC_MSG_RESULT([no])])\n\nfi\n\n# RAIL callback variants\nif test \"x${have_freerdp2}\" = \"xyes\"\nthen\n\n    # FreeRDP 2.0.0-rc3 and older did not use const for RAIL callbacks\n    AC_MSG_CHECKING([whether RAIL callbacks require const for their final parameter])\n    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n\n        #include <freerdp/client/rail.h>\n        #include <winpr/wtypes.h>\n\n        UINT test_server_handshake(RailClientContext* rail,\n                const RAIL_HANDSHAKE_ORDER* handshake);\n\n        RailClientContext context = {\n            .ServerHandshake = test_server_handshake\n        };\n\n        int main() {\n            return (int) context.ServerHandshake(NULL, NULL);\n        }\n\n    ]])],\n    [AC_MSG_RESULT([yes])]\n    [AC_DEFINE([FREERDP_RAIL_CALLBACKS_REQUIRE_CONST],,\n               [Whether RAIL callbacks require const for the final parameter])],\n    [AC_MSG_RESULT([no])])\n\nfi\n\n# Restore CPPFLAGS, removing FreeRDP-specific options needed for testing\nCPPFLAGS=\"$OLDCPPFLAGS\"\n\nAC_SUBST(FREERDP2_PLUGIN_DIR)\nAM_CONDITIONAL([ENABLE_RDP], [test \"x${have_freerdp2}\" = \"xyes\"])\n\n#\n# libssh2\n#\n\nhave_libssh2=disabled\nSSH_LIBS=\nAC_ARG_WITH([ssh],\n            [AS_HELP_STRING([--with-ssh],\n                            [support SSH @<:@default=check@:>@])],\n            [],\n            [with_ssh=check])\n\nAC_ARG_ENABLE(ssh_agent,\n              [AS_HELP_STRING([--enable-ssh-agent],\n                              [enable built-in ssh-agent])\n              ],enable_ssh_agent=yes)\n\nif test \"x$with_ssh\" != \"xno\"\nthen\n    have_libssh2=yes\n\n    AC_CHECK_LIB([ssh2], [libssh2_session_init_ex],\n                         [SSH_LIBS=\"$SSH_LIBS -lssh2\"],\n                         [have_libssh2=no])\nfi\n\nAM_CONDITIONAL([ENABLE_COMMON_SSH], [test \"x${have_libssh2}\"  = \"xyes\" \\\n                                       -a \"x${have_ssl}\"      = \"xyes\"])\nAM_COND_IF([ENABLE_COMMON_SSH],\n           [AC_DEFINE([ENABLE_COMMON_SSH],,\n                      [Whether support for the common SSH core is enabled])])\n\nAM_CONDITIONAL([ENABLE_SSH], [test \"x${have_libssh2}\"  = \"xyes\" \\\n                                -a \"x${have_terminal}\" = \"xyes\" \\\n                                -a \"x${have_ssl}\"      = \"xyes\"])\n\nAC_SUBST(SSH_LIBS)\n\n#\n# Underlying crypto library usage of libssh2\n#\n\nif test \"x${have_libssh2}\" = \"xyes\"\nthen\n\n    # Whether libssh2 was built against libgcrypt\n    AC_CHECK_LIB([ssh2], [gcry_control],\n                         [AC_CHECK_HEADER(gcrypt.h,\n                                          [AC_DEFINE([LIBSSH2_USES_GCRYPT],,\n                                                     [Whether libssh2 was built against libgcrypt])],\n                                          [AC_MSG_WARN([\n  --------------------------------------------\n   libssh2 appears to be built against libgcrypt, but the libgcrypt headers\n   could not be found. SSH will be disabled.\n  --------------------------------------------])\n                                           have_libssh2=no])])\n\nfi\n\n#\n# Agent forwarding support within libssh2\n#\n\nhave_ssh_agent=no\nif test \"x${have_libssh2}\" = \"xyes\" -a \"x${enable_ssh_agent}\" = \"xyes\"\nthen\n\n    AC_CHECK_DECL([libssh2_channel_request_auth_agent],\n                  [have_ssh_agent=yes], [],\n                  [[#include <libssh2.h>]])\n\n    if test \"x${have_ssh_agent}\" = \"xno\"\n    then\n        AC_MSG_ERROR([\n      --------------------------------------------\n       Agent forwarding support was requested but no such support was found\n       in libssh2.\n      --------------------------------------------])\n    else\n        AC_DEFINE([ENABLE_SSH_AGENT],,\n                  [Whether agent forwarding support for SSH is enabled])\n    fi\n\nfi\n\nAM_CONDITIONAL([ENABLE_SSH_AGENT],\n\t   [test \"x${have_ssh_agent}\"   = \"xyes\" \\\n\t      -a \"x${enable_ssh_agent}\" = \"xyes\"])\n\n#\n# libtelnet\n#\n\nhave_libtelnet=disabled\nTELNET_LIBS=\nAC_ARG_WITH([telnet],\n            [AS_HELP_STRING([--with-telnet],\n                            [support Telnet @<:@default=check@:>@])],\n            [],\n            [with_telnet=check])\n\nif test \"x$with_telnet\" != \"xno\"\nthen\n    have_libtelnet=yes\n    AC_CHECK_LIB([telnet], [telnet_init],\n                           [TELNET_LIBS=\"$TELNET_LIBS -ltelnet\"],\n                           [have_libtelnet=no])\nfi\n\nAM_CONDITIONAL([ENABLE_TELNET], [test \"x${have_libtelnet}\"  = \"xyes\" \\\n                                   -a \"x${have_terminal}\" = \"xyes\"])\n\nAC_SUBST(TELNET_LIBS)\n\n#\n# libwebp\n#\n\nhave_webp=disabled\nWEBP_LIBS=\nAC_ARG_WITH([webp],\n            [AS_HELP_STRING([--with-webp],\n                            [support WebP image encoding @<:@default=check@:>@])],\n            [],\n            [with_webp=check])\n\nif test \"x$with_webp\" != \"xno\"\nthen\n    have_webp=yes\n\n    AC_CHECK_HEADER(webp/encode.h,, [have_webp=no])\n    AC_CHECK_LIB([webp], [WebPEncode], [WEBP_LIBS=\"$WEBP_LIBS -lwebp\"], [have_webp=no])\n\n    if test \"x${have_webp}\" = \"xno\"\n    then\n        AC_MSG_WARN([\n  --------------------------------------------\n   Unable to find libwebp.\n   Images will not be encoded using WebP.\n  --------------------------------------------])\n    else\n        AC_DEFINE([ENABLE_WEBP],, [Whether WebP support is enabled])\n    fi\nfi\n\nAM_CONDITIONAL([ENABLE_WEBP], [test \"x${have_webp}\" = \"xyes\"])\nAC_SUBST(WEBP_LIBS)\n\n#\n# libwebsockets\n#\n\nhave_libwebsockets=disabled\nWEBSOCKETS_LIBS=\nAC_ARG_WITH([websockets],\n            [AS_HELP_STRING([--with-websockets],\n                            [support WebSockets @<:@default=check@:>@])],\n            [],\n            [with_websockets=check])\n\nif test \"x$with_websockets\" != \"xno\"\nthen\n    have_libwebsockets=yes\n    AC_CHECK_LIB([websockets],\n                 [lws_create_context],\n                 [WEBSOCKETS_LIBS=\"$WEBSOCKETS_LIBS -lwebsockets\"],\n                 [AC_MSG_WARN([\n  --------------------------------------------\n   Unable to find libwebsockets.\n   Support for Kubernetes will be disabled.\n  --------------------------------------------])\n                 have_libwebsockets=no])\nfi\n\nif test \"x$with_websockets\" != \"xno\"\nthen\n\n    # Check for client-specific closed event, which must be used in favor of\n    # the generic closed event if libwebsockets is recent enough to provide\n    # this\n    AC_CHECK_DECL([LWS_CALLBACK_CLIENT_CLOSED],\n        [AC_DEFINE([HAVE_LWS_CALLBACK_CLIENT_CLOSED],,\n                   [Whether LWS_CALLBACK_CLIENT_CLOSED is defined])],,\n        [#include <libwebsockets.h>])\n\n    # Older versions of libwebsockets may not define a flag for requesting\n    # global initialization of OpenSSL, instead performing that initialization\n    # by default\n    AC_CHECK_DECL([LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT],\n        [AC_DEFINE([HAVE_LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT],,\n                   [Whether LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT is defined])],,\n        [#include <libwebsockets.h>])\n\n    # Older versions of libwebsockets do not define special macros for SSL\n    # connection flags, instead relying on documented integer values\n    AC_CHECK_DECL([LCCSCF_USE_SSL],\n        [AC_DEFINE([HAVE_LCCSCF_USE_SSL],,\n                   [Whether LCCSCF_USE_SSL is defined])],,\n        [#include <libwebsockets.h>])\n\n    # Older versions of libwebsockets do not define a dummy callback which\n    # must be invoked after the main event callback is invoked; the main event\n    # callback must instead manually return zero\n    AC_CHECK_DECL([lws_callback_http_dummy],\n        [AC_DEFINE([HAVE_LWS_CALLBACK_HTTP_DUMMY],,\n                   [Whether lws_callback_http_dummy() is defined])],,\n        [#include <libwebsockets.h>])\n\nfi\n\nAM_CONDITIONAL([ENABLE_WEBSOCKETS],\n               [test \"x${have_libwebsockets}\"  = \"xyes\"])\n\nAC_SUBST(WEBSOCKETS_LIBS)\n\n#\n# Kubernetes\n#\n\nAC_ARG_ENABLE([kubernetes],\n              [AS_HELP_STRING([--disable-kubernetes],\n                              [do not build support for attaching to Kubernetes pods])],\n              [],\n              [enable_kubernetes=yes])\n\nAM_CONDITIONAL([ENABLE_KUBERNETES], [test \"x${enable_kubernetes}\"  = \"xyes\" \\\n                                       -a \"x${have_libwebsockets}\" = \"xyes\" \\\n                                       -a \"x${have_ssl}\"           = \"xyes\" \\\n                                       -a \"x${have_terminal}\"      = \"xyes\"])\n\n#\n# guacd\n#\n\nAC_ARG_ENABLE([guacd],\n              [AS_HELP_STRING([--disable-guacd],\n                              [do not build the Guacamole proxy daemon])],\n              [],\n              [enable_guacd=yes])\n\nAM_CONDITIONAL([ENABLE_GUACD], [test \"x${enable_guacd}\"  = \"xyes\"])\n\n#\n# guacenc\n#\n\nAC_ARG_ENABLE([guacenc],\n              [AS_HELP_STRING([--disable-guacenc],\n                              [do not build the Guacamole video encoding tool])],\n              [],\n              [enable_guacenc=yes])\n\nAM_CONDITIONAL([ENABLE_GUACENC], [test \"x${enable_guacenc}\"  = \"xyes\" \\\n                                    -a \"x${have_libavcodec}\" = \"xyes\" \\\n                                    -a \"x${have_libavutil}\"  = \"xyes\" \\\n                                    -a \"x${have_libswscale}\" = \"xyes\"])\n\n#\n# guaclog\n#\n\nAC_ARG_ENABLE([guaclog],\n              [AS_HELP_STRING([--disable-guaclog],\n                              [do not build the Guacamole input logging tool])],\n              [],\n              [enable_guaclog=yes])\n\nAM_CONDITIONAL([ENABLE_GUACLOG], [test \"x${enable_guaclog}\"  = \"xyes\"])\n\n#\n# Output Makefiles\n#\n\nAC_CONFIG_FILES([Makefile\n                 doc/Doxyfile\n                 src/common/Makefile\n                 src/common/tests/Makefile\n                 src/common-ssh/Makefile\n                 src/common-ssh/tests/Makefile\n                 src/terminal/Makefile\n                 src/libguac/Makefile\n                 src/libguac/tests/Makefile\n                 src/guacd/Makefile\n                 src/guacd/man/guacd.8\n                 src/guacd/man/guacd.conf.5\n                 src/guacenc/Makefile\n                 src/guacenc/man/guacenc.1\n                 src/guaclog/Makefile\n                 src/guaclog/man/guaclog.1\n                 src/pulse/Makefile\n                 src/protocols/kubernetes/Makefile\n                 src/protocols/rdp/Makefile\n                 src/protocols/rdp/tests/Makefile\n                 src/protocols/ssh/Makefile\n                 src/protocols/telnet/Makefile\n                 src/protocols/vnc/Makefile])\nAC_OUTPUT\n\n#\n# Protocol build status\n#\n\nAM_COND_IF([ENABLE_KUBERNETES], [build_kubernetes=yes], [build_kubernetes=no])\nAM_COND_IF([ENABLE_RDP],        [build_rdp=yes],        [build_rdp=no])\nAM_COND_IF([ENABLE_SSH],        [build_ssh=yes],        [build_ssh=no])\nAM_COND_IF([ENABLE_TELNET],     [build_telnet=yes],     [build_telnet=no])\nAM_COND_IF([ENABLE_VNC],        [build_vnc=yes],        [build_vnc=no])\n\n#\n# Service / tool build status\n#\n\nAM_COND_IF([ENABLE_GUACD],   [build_guacd=yes],   [build_guacd=no])\nAM_COND_IF([ENABLE_GUACENC], [build_guacenc=yes], [build_guacenc=no])\nAM_COND_IF([ENABLE_GUACLOG], [build_guaclog=yes], [build_guaclog=no])\n\n#\n# Init scripts\n#\n\nAM_COND_IF([ENABLE_INIT], [build_init=\"${init_dir}\"], [build_init=no])\n\n#\n# Systemd units\n#\n\nAM_COND_IF([ENABLE_SYSTEMD], [build_systemd=\"${systemd_dir}\"], [build_systemd=no])\n\n#\n# FreeRDP plugins\n#\n\nAM_COND_IF([ENABLE_RDP], [build_rdp_plugins=\"${FREERDP2_PLUGIN_DIR}\"], [build_rdp_plugins=no])\n\n#\n# Display summary\n#\n\necho \"\n------------------------------------------------\n$PACKAGE_NAME version $PACKAGE_VERSION\n------------------------------------------------\n\n   Library status:\n\n     freerdp2 ............ ${have_freerdp2}\n     pango ............... ${have_pango}\n     libavcodec .......... ${have_libavcodec}\n     libavutil ........... ${have_libavutil}\n     libssh2 ............. ${have_libssh2}\n     libssl .............. ${have_ssl}\n     libswscale .......... ${have_libswscale}\n     libtelnet ........... ${have_libtelnet}\n     libVNCServer ........ ${have_libvncserver}\n     libvorbis ........... ${have_vorbis}\n     libpulse ............ ${have_pulse}\n     libwebsockets ....... ${have_libwebsockets}\n     libwebp ............. ${have_webp}\n     wsock32 ............. ${have_winsock}\n\n   Protocol support:\n\n      Kubernetes .... ${build_kubernetes}\n      RDP ........... ${build_rdp}\n      SSH ........... ${build_ssh}\n      Telnet ........ ${build_telnet}\n      VNC ........... ${build_vnc}\n\n   Services / tools:\n\n      guacd ...... ${build_guacd}\n      guacenc .... ${build_guacenc}\n      guaclog .... ${build_guaclog}\n\n   FreeRDP plugins: ${build_rdp_plugins}\n   Init scripts: ${build_init}\n   Systemd units: ${build_systemd}\n\nType \\\"make\\\" to compile $PACKAGE_NAME.\n\"\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-guacamole-server-1.1.0-argaczfjofiwgfbbyr6a5emw7qfwkfjw/spack-src/src/libguac/client.c": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n#include \"config.h\"\n\n#include \"encode-jpeg.h\"\n#include \"encode-png.h\"\n#include \"encode-webp.h\"\n#include \"guacamole/client.h\"\n#include \"guacamole/error.h\"\n#include \"guacamole/layer.h\"\n#include \"guacamole/plugin.h\"\n#include \"guacamole/pool.h\"\n#include \"guacamole/protocol.h\"\n#include \"guacamole/socket.h\"\n#include \"guacamole/stream.h\"\n#include \"guacamole/string.h\"\n#include \"guacamole/timestamp.h\"\n#include \"guacamole/user.h\"\n#include \"id.h\"\n\n#include <dlfcn.h>\n#include <inttypes.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/**\n * Empty NULL-terminated array of argument names.\n */\nconst char* __GUAC_CLIENT_NO_ARGS[] = { NULL };\n\nguac_layer __GUAC_DEFAULT_LAYER = {\n    .index = 0\n};\n\nconst guac_layer* GUAC_DEFAULT_LAYER = &__GUAC_DEFAULT_LAYER;\n\nguac_layer* guac_client_alloc_layer(guac_client* client) {\n\n    /* Init new layer */\n    guac_layer* allocd_layer = malloc(sizeof(guac_layer));\n    allocd_layer->index = guac_pool_next_int(client->__layer_pool)+1;\n\n    return allocd_layer;\n\n}\n\nguac_layer* guac_client_alloc_buffer(guac_client* client) {\n\n    /* Init new layer */\n    guac_layer* allocd_layer = malloc(sizeof(guac_layer));\n    allocd_layer->index = -guac_pool_next_int(client->__buffer_pool) - 1;\n\n    return allocd_layer;\n\n}\n\nvoid guac_client_free_buffer(guac_client* client, guac_layer* layer) {\n\n    /* Release index to pool */\n    guac_pool_free_int(client->__buffer_pool, -layer->index - 1);\n\n    /* Free layer */\n    free(layer);\n\n}\n\nvoid guac_client_free_layer(guac_client* client, guac_layer* layer) {\n\n    /* Release index to pool */\n    guac_pool_free_int(client->__layer_pool, layer->index);\n\n    /* Free layer */\n    free(layer);\n\n}\n\nguac_stream* guac_client_alloc_stream(guac_client* client) {\n\n    guac_stream* allocd_stream;\n    int stream_index;\n\n    /* Refuse to allocate beyond maximum */\n    if (client->__stream_pool->active == GUAC_CLIENT_MAX_STREAMS)\n        return NULL;\n\n    /* Allocate stream */\n    stream_index = guac_pool_next_int(client->__stream_pool);\n\n    /* Initialize stream with odd index (even indices are user-level) */\n    allocd_stream = &(client->__output_streams[stream_index]);\n    allocd_stream->index = (stream_index * 2) + 1;\n    allocd_stream->data = NULL;\n    allocd_stream->ack_handler = NULL;\n    allocd_stream->blob_handler = NULL;\n    allocd_stream->end_handler = NULL;\n\n    return allocd_stream;\n\n}\n\nvoid guac_client_free_stream(guac_client* client, guac_stream* stream) {\n\n    /* Release index to pool */\n    guac_pool_free_int(client->__stream_pool, (stream->index - 1) / 2);\n\n    /* Mark stream as closed */\n    stream->index = GUAC_CLIENT_CLOSED_STREAM_INDEX;\n\n}\n\nguac_client* guac_client_alloc() {\n\n    int i;\n    pthread_rwlockattr_t lock_attributes;\n\n    /* Allocate new client */\n    guac_client* client = malloc(sizeof(guac_client));\n    if (client == NULL) {\n        guac_error = GUAC_STATUS_NO_MEMORY;\n        guac_error_message = \"Could not allocate memory for client\";\n        return NULL;\n    }\n\n    /* Init new client */\n    memset(client, 0, sizeof(guac_client));\n\n    client->args = __GUAC_CLIENT_NO_ARGS;\n    client->state = GUAC_CLIENT_RUNNING;\n    client->last_sent_timestamp = guac_timestamp_current();\n\n    /* Generate ID */\n    client->connection_id = guac_generate_id(GUAC_CLIENT_ID_PREFIX);\n    if (client->connection_id == NULL) {\n        free(client);\n        return NULL;\n    }\n\n    /* Allocate buffer and layer pools */\n    client->__buffer_pool = guac_pool_alloc(GUAC_BUFFER_POOL_INITIAL_SIZE);\n    client->__layer_pool = guac_pool_alloc(GUAC_BUFFER_POOL_INITIAL_SIZE);\n\n    /* Allocate stream pool */\n    client->__stream_pool = guac_pool_alloc(0);\n\n    /* Initialize streams */\n    client->__output_streams = malloc(sizeof(guac_stream) * GUAC_CLIENT_MAX_STREAMS);\n\n    for (i=0; i<GUAC_CLIENT_MAX_STREAMS; i++) {\n        client->__output_streams[i].index = GUAC_CLIENT_CLOSED_STREAM_INDEX;\n    }\n\n\n    /* Init locks */\n    pthread_rwlockattr_init(&lock_attributes);\n    pthread_rwlockattr_setpshared(&lock_attributes, PTHREAD_PROCESS_SHARED);\n\n    pthread_rwlock_init(&(client->__users_lock), &lock_attributes);\n\n    /* Set up socket to broadcast to all users */\n    client->socket = guac_socket_broadcast(client);\n\n    return client;\n\n}\n\nvoid guac_client_free(guac_client* client) {\n\n    /* Remove all users */\n    while (client->__users != NULL)\n        guac_client_remove_user(client, client->__users);\n\n    if (client->free_handler) {\n\n        /* FIXME: Errors currently ignored... */\n        client->free_handler(client);\n\n    }\n\n    /* Free socket */\n    guac_socket_free(client->socket);\n\n    /* Free layer pools */\n    guac_pool_free(client->__buffer_pool);\n    guac_pool_free(client->__layer_pool);\n\n    /* Free streams */\n    free(client->__output_streams);\n\n    /* Free stream pool */\n    guac_pool_free(client->__stream_pool);\n\n    /* Close associated plugin */\n    if (client->__plugin_handle != NULL) {\n        if (dlclose(client->__plugin_handle))\n            guac_client_log(client, GUAC_LOG_ERROR, \"Unable to close plugin: %s\", dlerror());\n    }\n\n    pthread_rwlock_destroy(&(client->__users_lock));\n    free(client->connection_id);\n    free(client);\n}\n\nvoid vguac_client_log(guac_client* client, guac_client_log_level level,\n        const char* format, va_list ap) {\n\n    /* Call handler if defined */\n    if (client->log_handler != NULL)\n        client->log_handler(client, level, format, ap);\n\n}\n\nvoid guac_client_log(guac_client* client, guac_client_log_level level,\n        const char* format, ...) {\n\n    va_list args;\n    va_start(args, format);\n\n    vguac_client_log(client, level, format, args);\n\n    va_end(args);\n\n}\n\nvoid guac_client_stop(guac_client* client) {\n    client->state = GUAC_CLIENT_STOPPING;\n}\n\nvoid vguac_client_abort(guac_client* client, guac_protocol_status status,\n        const char* format, va_list ap) {\n\n    /* Only relevant if client is running */\n    if (client->state == GUAC_CLIENT_RUNNING) {\n\n        /* Log detail of error */\n        vguac_client_log(client, GUAC_LOG_ERROR, format, ap);\n\n        /* Send error immediately, limit information given */\n        guac_protocol_send_error(client->socket, \"Aborted. See logs.\", status);\n        guac_socket_flush(client->socket);\n\n        /* Stop client */\n        guac_client_stop(client);\n\n    }\n\n}\n\nvoid guac_client_abort(guac_client* client, guac_protocol_status status,\n        const char* format, ...) {\n\n    va_list args;\n    va_start(args, format);\n\n    vguac_client_abort(client, status, format, args);\n\n    va_end(args);\n\n}\n\nint guac_client_add_user(guac_client* client, guac_user* user, int argc, char** argv) {\n\n    int retval = 0;\n\n    /* Call handler, if defined */\n    if (client->join_handler)\n        retval = client->join_handler(user, argc, argv);\n\n    pthread_rwlock_wrlock(&(client->__users_lock));\n\n    /* Add to list if join was successful */\n    if (retval == 0) {\n\n        user->__prev = NULL;\n        user->__next = client->__users;\n\n        if (client->__users != NULL)\n            client->__users->__prev = user;\n\n        client->__users = user;\n        client->connected_users++;\n\n        /* Update owner pointer if user is owner */\n        if (user->owner)\n            client->__owner = user;\n\n    }\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n    return retval;\n\n}\n\nvoid guac_client_remove_user(guac_client* client, guac_user* user) {\n\n    pthread_rwlock_wrlock(&(client->__users_lock));\n\n    /* Update prev / head */\n    if (user->__prev != NULL)\n        user->__prev->__next = user->__next;\n    else\n        client->__users = user->__next;\n\n    /* Update next */\n    if (user->__next != NULL)\n        user->__next->__prev = user->__prev;\n\n    client->connected_users--;\n\n    /* Update owner pointer if user was owner */\n    if (user->owner)\n        client->__owner = NULL;\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n    /* Call handler, if defined */\n    if (user->leave_handler)\n        user->leave_handler(user);\n    else if (client->leave_handler)\n        client->leave_handler(user);\n\n}\n\nvoid guac_client_foreach_user(guac_client* client, guac_user_callback* callback, void* data) {\n\n    guac_user* current;\n\n    pthread_rwlock_rdlock(&(client->__users_lock));\n\n    /* Call function on each user */\n    current = client->__users;\n    while (current != NULL) {\n        callback(current, data);\n        current = current->__next;\n    }\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n}\n\nvoid* guac_client_for_owner(guac_client* client, guac_user_callback* callback,\n        void* data) {\n\n    void* retval;\n\n    pthread_rwlock_rdlock(&(client->__users_lock));\n\n    /* Invoke callback with current owner */\n    retval = callback(client->__owner, data);\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n    /* Return value from callback */\n    return retval;\n\n}\n\nvoid* guac_client_for_user(guac_client* client, guac_user* user,\n        guac_user_callback* callback, void* data) {\n\n    guac_user* current;\n\n    int user_valid = 0;\n    void* retval;\n\n    pthread_rwlock_rdlock(&(client->__users_lock));\n\n    /* Loop through all users, searching for a pointer to the given user */\n    current = client->__users;\n    while (current != NULL) {\n\n        /* If the user's pointer exists in the list, they are indeed valid */\n        if (current == user) {\n            user_valid = 1;\n            break;\n        }\n\n        current = current->__next;\n    }\n\n    /* Use NULL if user does not actually exist */\n    if (!user_valid)\n        user = NULL;\n\n    /* Invoke callback with requested user (if they exist) */\n    retval = callback(user, data);\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n    /* Return value from callback */\n    return retval;\n\n}\n\nint guac_client_end_frame(guac_client* client) {\n\n    /* Update and send timestamp */\n    client->last_sent_timestamp = guac_timestamp_current();\n\n    /* Log received timestamp and calculated lag (at TRACE level only) */\n    guac_client_log(client, GUAC_LOG_TRACE, \"Server completed \"\n            \"frame %\" PRIu64 \"ms.\", client->last_sent_timestamp);\n\n    return guac_protocol_send_sync(client->socket, client->last_sent_timestamp);\n\n}\n\nint guac_client_load_plugin(guac_client* client, const char* protocol) {\n\n    /* Reference to dlopen()'d plugin */\n    void* client_plugin_handle;\n\n    /* Pluggable client */\n    char protocol_lib[GUAC_PROTOCOL_LIBRARY_LIMIT] =\n        GUAC_PROTOCOL_LIBRARY_PREFIX;\n\n    /* Type-pun for the sake of dlsym() - cannot typecast a void* to a function\n     * pointer otherwise */ \n    union {\n        guac_client_init_handler* client_init;\n        void* obj;\n    } alias;\n\n    /* Add protocol and .so suffix to protocol_lib */\n    guac_strlcat(protocol_lib, protocol, sizeof(protocol_lib));\n    if (guac_strlcat(protocol_lib, GUAC_PROTOCOL_LIBRARY_SUFFIX,\n                sizeof(protocol_lib)) >= sizeof(protocol_lib)) {\n        guac_error = GUAC_STATUS_NO_MEMORY;\n        guac_error_message = \"Protocol name is too long\";\n        return -1;\n    }\n\n    /* Load client plugin */\n    client_plugin_handle = dlopen(protocol_lib, RTLD_LAZY);\n    if (!client_plugin_handle) {\n        guac_error = GUAC_STATUS_NOT_FOUND;\n        guac_error_message = dlerror();\n        return -1;\n    }\n\n    dlerror(); /* Clear errors */\n\n    /* Get init function */\n    alias.obj = dlsym(client_plugin_handle, \"guac_client_init\");\n\n    /* Fail if cannot find guac_client_init */\n    if (dlerror() != NULL) {\n        guac_error = GUAC_STATUS_INTERNAL_ERROR;\n        guac_error_message = dlerror();\n        dlclose(client_plugin_handle);\n        return -1;\n    }\n\n    /* Init client */\n    client->__plugin_handle = client_plugin_handle;\n\n    return alias.client_init(client);\n\n}\n\n/**\n * Updates the provided approximate processing lag, taking into account the\n * processing lag of the given user.\n *\n * @param user\n *     The guac_user to use to update the approximate processing lag.\n *\n * @param data\n *     Pointer to an int containing the current approximate processing lag.\n *     The int will be updated according to the processing lag of the given\n *     user.\n *\n * @return\n *     Always NULL.\n */\nstatic void* __calculate_lag(guac_user* user, void* data) {\n\n    int* processing_lag = (int*) data;\n\n    /* Simply find maximum */\n    if (user->processing_lag > *processing_lag)\n        *processing_lag = user->processing_lag;\n\n    return NULL;\n\n}\n\nint guac_client_get_processing_lag(guac_client* client) {\n\n    int processing_lag = 0;\n\n    /* Approximate the processing lag of all users */\n    guac_client_foreach_user(client, __calculate_lag, &processing_lag);\n\n    return processing_lag;\n\n}\n\nvoid guac_client_stream_argv(guac_client* client, guac_socket* socket,\n        const char* mimetype, const char* name, const char* value) {\n\n    /* Allocate new stream for argument value */\n    guac_stream* stream = guac_client_alloc_stream(client);\n\n    /* Declare stream as containing connection parameter data */\n    guac_protocol_send_argv(socket, stream, mimetype, name);\n\n    /* Write parameter data */\n    guac_protocol_send_blobs(socket, stream, value, strlen(value));\n\n    /* Terminate stream */\n    guac_protocol_send_end(socket, stream);\n\n    /* Free allocated stream */\n    guac_client_free_stream(client, stream);\n\n}\n\nvoid guac_client_stream_png(guac_client* client, guac_socket* socket,\n        guac_composite_mode mode, const guac_layer* layer, int x, int y,\n        cairo_surface_t* surface) {\n\n    /* Allocate new stream for image */\n    guac_stream* stream = guac_client_alloc_stream(client);\n\n    /* Declare stream as containing image data */\n    guac_protocol_send_img(socket, stream, mode, layer, \"image/png\", x, y);\n\n    /* Write PNG data */\n    guac_png_write(socket, stream, surface);\n\n    /* Terminate stream */\n    guac_protocol_send_end(socket, stream);\n\n    /* Free allocated stream */\n    guac_client_free_stream(client, stream);\n\n}\n\nvoid guac_client_stream_jpeg(guac_client* client, guac_socket* socket,\n        guac_composite_mode mode, const guac_layer* layer, int x, int y,\n        cairo_surface_t* surface, int quality) {\n\n    /* Allocate new stream for image */\n    guac_stream* stream = guac_client_alloc_stream(client);\n\n    /* Declare stream as containing image data */\n    guac_protocol_send_img(socket, stream, mode, layer, \"image/jpeg\", x, y);\n\n    /* Write JPEG data */\n    guac_jpeg_write(socket, stream, surface, quality);\n\n    /* Terminate stream */\n    guac_protocol_send_end(socket, stream);\n\n    /* Free allocated stream */\n    guac_client_free_stream(client, stream);\n\n}\n\nvoid guac_client_stream_webp(guac_client* client, guac_socket* socket,\n        guac_composite_mode mode, const guac_layer* layer, int x, int y,\n        cairo_surface_t* surface, int quality, int lossless) {\n\n#ifdef ENABLE_WEBP\n    /* Allocate new stream for image */\n    guac_stream* stream = guac_client_alloc_stream(client);\n\n    /* Declare stream as containing image data */\n    guac_protocol_send_img(socket, stream, mode, layer, \"image/webp\", x, y);\n\n    /* Write WebP data */\n    guac_webp_write(socket, stream, surface, quality, lossless);\n\n    /* Terminate stream */\n    guac_protocol_send_end(socket, stream);\n\n    /* Free allocated stream */\n    guac_client_free_stream(client, stream);\n#else\n    /* Do nothing if WebP support is not built in */\n#endif\n\n}\n\n#ifdef ENABLE_WEBP\n/**\n * Callback which is invoked by guac_client_supports_webp() for each user\n * associated with the given client, thus updating an overall support flag\n * describing the WebP support state for the client as a whole.\n *\n * @param user\n *     The user to check for WebP support.\n *\n * @param data\n *     Pointer to an int containing the current WebP support status for the\n *     client associated with the given user. This flag will be 0 if any user\n *     already checked has lacked WebP support, or 1 otherwise.\n *\n * @return\n *     Always NULL.\n */\nstatic void* __webp_support_callback(guac_user* user, void* data) {\n\n    int* webp_supported = (int*) data;\n\n    /* Check whether current user supports WebP */\n    if (*webp_supported)\n        *webp_supported = guac_user_supports_webp(user);\n\n    return NULL;\n\n}\n#endif\n\nint guac_client_supports_webp(guac_client* client) {\n\n#ifdef ENABLE_WEBP\n    int webp_supported = 1;\n\n    /* WebP is supported for entire client only if each user supports it */\n    guac_client_foreach_user(client, __webp_support_callback, &webp_supported);\n\n    return webp_supported;\n#else\n    /* Support for WebP is completely absent */\n    return 0;\n#endif\n\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-guacamole-server-1.1.0-argaczfjofiwgfbbyr6a5emw7qfwkfjw/spack-src/src/libguac/guacamole/client.h": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n#ifndef _GUAC_CLIENT_H\n#define _GUAC_CLIENT_H\n\n/**\n * Functions and structure contents for the Guacamole proxy client.\n *\n * @file client.h\n */\n\n#include \"client-fntypes.h\"\n#include \"client-types.h\"\n#include \"client-constants.h\"\n#include \"layer-types.h\"\n#include \"object-types.h\"\n#include \"pool-types.h\"\n#include \"socket-types.h\"\n#include \"stream-types.h\"\n#include \"timestamp-types.h\"\n#include \"user-fntypes.h\"\n#include \"user-types.h\"\n\n#include <cairo/cairo.h>\n\n#include <pthread.h>\n#include <stdarg.h>\n\nstruct guac_client {\n\n    /**\n     * The guac_socket structure to be used to communicate with all connected\n     * web-clients (users). Unlike the user-level guac_socket, this guac_socket\n     * will broadcast instructions to all connected users simultaneously.  It\n     * is expected that the implementor of any Guacamole proxy client will\n     * provide their own mechanism of I/O for their protocol. The guac_socket\n     * structure is used only to communicate conveniently with the Guacamole\n     * web-client.\n     */\n    guac_socket* socket;\n\n    /**\n     * The current state of the client. When the client is first allocated,\n     * this will be initialized to GUAC_CLIENT_RUNNING. It will remain at\n     * GUAC_CLIENT_RUNNING until an event occurs which requires the client to\n     * shutdown, at which point the state becomes GUAC_CLIENT_STOPPING.\n     */\n    guac_client_state state;\n\n    /**\n     * Arbitrary reference to proxy client-specific data. Implementors of a\n     * Guacamole proxy client can store any data they want here, which can then\n     * be retrieved as necessary in the message handlers.\n     */\n    void* data;\n\n    /**\n     * The time (in milliseconds) that the last sync message was sent to the\n     * client.\n     */\n    guac_timestamp last_sent_timestamp;\n\n    /**\n     * Handler for freeing data when the client is being unloaded.\n     *\n     * This handler will be called when the client needs to be unloaded\n     * by the proxy, and any data allocated by the proxy client should be\n     * freed.\n     *\n     * Note that this handler will NOT be called if the client's\n     * guac_client_init() function fails.\n     *\n     * Implement this handler if you store data inside the client.\n     *\n     * Example:\n     * @code\n     *     int free_handler(guac_client* client);\n     *\n     *     int guac_client_init(guac_client* client) {\n     *         client->free_handler = free_handler;\n     *     }\n     * @endcode\n     */\n    guac_client_free_handler* free_handler;\n\n    /**\n     * Logging handler. This handler will be called via guac_client_log() when\n     * the client needs to log messages of any type.\n     *\n     * In general, only programs loading the client should implement this\n     * handler, as those are the programs that would provide the logging\n     * facilities.\n     *\n     * Client implementations should expect these handlers to already be\n     * set.\n     *\n     * Example:\n     * @code\n     *     void log_handler(guac_client* client, guac_client_log_level level, const char* format, va_list args);\n     *\n     *     void function_of_daemon() {\n     *\n     *         guac_client* client = [pass log_handler to guac_client_plugin_get_client()];\n     *\n     *     }\n     * @endcode\n     */\n    guac_client_log_handler* log_handler;\n\n    /**\n     * Pool of buffer indices. Buffers are simply layers with negative indices.\n     * Note that because guac_pool always gives non-negative indices starting\n     * at 0, the output of this guac_pool will be adjusted.\n     */\n    guac_pool* __buffer_pool;\n\n    /**\n     * Pool of layer indices. Note that because guac_pool always gives\n     * non-negative indices starting at 0, the output of this guac_pool will\n     * be adjusted.\n     */\n    guac_pool* __layer_pool;\n\n    /**\n     * Pool of stream indices.\n     */\n    guac_pool* __stream_pool;\n\n    /**\n     * All available client-level output streams (data going to all connected\n     * users).\n     */\n    guac_stream* __output_streams;\n\n    /**\n     * The unique identifier allocated for the connection, which may\n     * be used within the Guacamole protocol to refer to this connection.\n     * This identifier is guaranteed to be unique from all existing\n     * connections and will not collide with any available protocol\n     * names.\n     */\n    char* connection_id;\n\n    /**\n     * Lock which is acquired when the users list is being manipulated, or when\n     * the users list is being iterated.\n     */\n    pthread_rwlock_t __users_lock;\n\n    /**\n     * The first user within the list of all connected users, or NULL if no\n     * users are currently connected.\n     */\n    guac_user* __users;\n\n    /**\n     * The user that first created this connection. This user will also have\n     * their \"owner\" flag set to a non-zero value. If the owner has left the\n     * connection, this will be NULL.\n     */\n    guac_user* __owner;\n\n    /**\n     * The number of currently-connected users. This value may include inactive\n     * users if cleanup of those users has not yet finished.\n     */\n    int connected_users;\n\n    /**\n     * Handler for join events, called whenever a new user is joining an active\n     * connection. Note that because users may leave the connection at any\n     * time, a reference to a guac_user can become invalid at any time and\n     * should never be maintained outside the scope of a function invoked by\n     * libguac to which that guac_user was passed (the scope in which the\n     * guac_user reference is guaranteed to be valid) UNLESS that reference is\n     * properly invalidated within the leave_handler.\n     *\n     * The handler is given a pointer to a newly-allocated guac_user which\n     * must then be initialized, if needed.\n     *\n     * Example:\n     * @code\n     *     int join_handler(guac_user* user, int argc, char** argv);\n     *\n     *     int guac_client_init(guac_client* client) {\n     *         client->join_handler = join_handler;\n     *     }\n     * @endcode\n     */\n    guac_user_join_handler* join_handler;\n\n    /**\n     * Handler for leave events, called whenever a new user is leaving an\n     * active connection.\n     *\n     * The handler is given a pointer to the leaving guac_user whose custom\n     * data and associated resources must now be freed, if any.\n     *\n     * Example:\n     * @code\n     *     int leave_handler(guac_user* user);\n     *\n     *     int guac_client_init(guac_client* client) {\n     *         client->leave_handler = leave_handler;\n     *     }\n     * @endcode\n     */\n    guac_user_leave_handler* leave_handler;\n\n    /**\n     * NULL-terminated array of all arguments accepted by this client , in\n     * order. New users will specify these arguments when they join the\n     * connection, and the values of those arguments will be made available to\n     * the function initializing newly-joined users.\n     *\n     * The guac_client_init entry point is expected to initialize this, if\n     * arguments are expected.\n     *\n     * Example:\n     * @code\n     *     const char* __my_args[] = {\n     *         \"hostname\",\n     *         \"port\",\n     *         \"username\",\n     *         \"password\",\n     *         NULL\n     *     };\n     *\n     *     int guac_client_init(guac_client* client) {\n     *         client->args = __my_args;\n     *     }\n     * @endcode\n     */\n    const char** args;\n\n    /**\n     * Handle to the dlopen()'d plugin, which should be given to dlclose() when\n     * this client is freed. This is only assigned if guac_client_load_plugin()\n     * is used.\n     */\n    void* __plugin_handle;\n\n};\n\n/**\n * Returns a new, barebones guac_client. This new guac_client has no handlers\n * set, but is otherwise usable.\n *\n * @return A pointer to the new client.\n */\nguac_client* guac_client_alloc();\n\n/**\n * Free all resources associated with the given client.\n *\n * @param client The proxy client to free all reasources of.\n */\nvoid guac_client_free(guac_client* client);\n\n/**\n * Writes a message in the log used by the given client. The logger used will\n * normally be defined by guacd (or whichever program loads the proxy client)\n * by setting the logging handlers of the client when it is loaded.\n *\n * @param client The proxy client logging this message.\n * @param level The level at which to log this message.\n * @param format A printf-style format string to log.\n * @param ... Arguments to use when filling the format string for printing.\n */\nvoid guac_client_log(guac_client* client, guac_client_log_level level,\n        const char* format, ...);\n\n/**\n * Writes a message in the log used by the given client. The logger used will\n * normally be defined by guacd (or whichever program loads the proxy client)\n * by setting the logging handlers of the client when it is loaded.\n *\n * @param client The proxy client logging this message.\n * @param level The level at which to log this message.\n * @param format A printf-style format string to log.\n * @param ap The va_list containing the arguments to be used when filling the\n *           format string for printing.\n */\nvoid vguac_client_log(guac_client* client, guac_client_log_level level,\n        const char* format, va_list ap);\n\n/**\n * Signals the given client to stop gracefully. This is a completely\n * cooperative signal, and can be ignored by the client or the hosting\n * daemon.\n *\n * @param client The proxy client to signal to stop.\n */\nvoid guac_client_stop(guac_client* client);\n\n/**\n * Signals the given client to stop gracefully, while also signalling via the\n * Guacamole protocol that an error has occurred. Note that this is a completely\n * cooperative signal, and can be ignored by the client or the hosting\n * daemon. The message given will be logged to the system logs.\n *\n * @param client The proxy client to signal to stop.\n * @param status The status to send over the Guacamole protocol.\n * @param format A printf-style format string to log.\n * @param ... Arguments to use when filling the format string for printing.\n */\nvoid guac_client_abort(guac_client* client, guac_protocol_status status,\n        const char* format, ...);\n\n/**\n * Signals the given client to stop gracefully, while also signalling via the\n * Guacamole protocol that an error has occurred. Note that this is a completely\n * cooperative signal, and can be ignored by the client or the hosting\n * daemon. The message given will be logged to the system logs.\n *\n * @param client The proxy client to signal to stop.\n * @param status The status to send over the Guacamole protocol.\n * @param format A printf-style format string to log.\n * @param ap The va_list containing the arguments to be used when filling the\n *           format string for printing.\n */\nvoid vguac_client_abort(guac_client* client, guac_protocol_status status,\n        const char* format, va_list ap);\n\n/**\n * Allocates a new buffer (invisible layer). An arbitrary index is\n * automatically assigned if no existing buffer is available for use.\n *\n * @param client The proxy client to allocate the buffer for.\n * @return The next available buffer, or a newly allocated buffer.\n */\nguac_layer* guac_client_alloc_buffer(guac_client* client);\n\n/**\n * Allocates a new layer. An arbitrary index is automatically assigned\n * if no existing layer is available for use.\n *\n * @param client The proxy client to allocate the layer buffer for.\n * @return The next available layer, or a newly allocated layer.\n */\nguac_layer* guac_client_alloc_layer(guac_client* client);\n\n/**\n * Returns the given buffer to the pool of available buffers, such that it\n * can be reused by any subsequent call to guac_client_allow_buffer().\n *\n * @param client The proxy client to return the buffer to.\n * @param layer The buffer to return to the pool of available buffers.\n */\nvoid guac_client_free_buffer(guac_client* client, guac_layer* layer);\n\n/**\n * Returns the given layer to the pool of available layers, such that it\n * can be reused by any subsequent call to guac_client_allow_layer().\n *\n * @param client The proxy client to return the layer to.\n * @param layer The buffer to return to the pool of available layer.\n */\nvoid guac_client_free_layer(guac_client* client, guac_layer* layer);\n\n/**\n * Allocates a new stream. An arbitrary index is automatically assigned\n * if no previously-allocated stream is available for use.\n *\n * @param client\n *     The client to allocate the stream for.\n *\n * @return\n *     The next available stream, or a newly allocated stream, or NULL if the\n *     maximum number of active streams has been reached.\n */\nguac_stream* guac_client_alloc_stream(guac_client* client);\n\n/**\n * Returns the given stream to the pool of available streams, such that it\n * can be reused by any subsequent call to guac_client_alloc_stream().\n *\n * @param client\n *     The client to return the stream to.\n *\n * @param stream\n *     The stream to return to the pool of available stream.\n */\nvoid guac_client_free_stream(guac_client* client, guac_stream* stream);\n\n/**\n * Adds the given user to the internal list of connected users. Future writes\n * to the broadcast socket stored within guac_client will also write to this\n * user. The join handler of this guac_client will be called.\n *\n * @param client The proxy client to add the user to.\n * @param user The user to add.\n * @param argc The number of arguments to pass to the new user.\n * @param argv An array of strings containing the argument values being passed.\n * @return Zero if the user was added successfully, non-zero if the user could\n *         not join the connection.\n */\nint guac_client_add_user(guac_client* client, guac_user* user, int argc, char** argv);\n\n/**\n * Removes the given user, removing the user from the internally-tracked list\n * of connected users, and calling any appropriate leave handler.\n *\n * @param client The proxy client to return the buffer to.\n * @param user The user to remove.\n */\nvoid guac_client_remove_user(guac_client* client, guac_user* user);\n\n/**\n * Calls the given function on all currently-connected users of the given\n * client. The function will be given a reference to a guac_user and the\n * specified arbitrary data. The value returned by the callback will be\n * ignored.\n *\n * This function is reentrant, but the user list MUST NOT be manipulated\n * within the same thread as a callback to this function. Though the callback\n * MAY invoke guac_client_foreach_user(), doing so should not be necessary, and\n * may indicate poor design choices.\n *\n * @param client\n *     The client whose users should be iterated.\n *\n * @param callback\n *     The function to call for each user.\n *\n * @param data\n *     Arbitrary data to pass to the callback each time it is invoked.\n */\nvoid guac_client_foreach_user(guac_client* client,\n        guac_user_callback* callback, void* data);\n\n/**\n * Calls the given function with the currently-connected user that is marked as\n * the owner. The owner of a connection is the user that established the\n * initial connection that created the connection (the first user to connect\n * and join). The function will be given a reference to the guac_user and the\n * specified arbitrary data. If the owner has since left the connection, the\n * function will instead be invoked with NULL as the guac_user. The value\n * returned by the callback will be returned by this function.\n *\n * This function is reentrant, but the user list MUST NOT be manipulated\n * within the same thread as a callback to this function.\n *\n * @param client\n *     The client to retrieve the owner from.\n *\n * @param callback\n *     The callback to invoke on the user marked as the owner of the\n *     connection. NULL will be passed to this callback instead if there is no\n *     owner.\n *\n * @param data\n *     Arbitrary data to pass to the given callback.\n *\n * @return\n *     The value returned by the callback.\n */\nvoid* guac_client_for_owner(guac_client* client, guac_user_callback* callback,\n        void* data);\n\n/**\n * Calls the given function with the given user ONLY if they are currently\n * connected. The function will be given a reference to the guac_user and the\n * specified arbitrary data. If the provided user doesn't exist or has since\n * left the connection, the function will instead be invoked with NULL as the\n * guac_user. The value returned by the callback will be returned by this\n * function.\n *\n * This function is reentrant, but the user list MUST NOT be manipulated\n * within the same thread as a callback to this function.\n *\n * @param client\n *     The client that the given user is expected to be associated with.\n *\n * @param user\n *     The user to provide to the given callback if valid. The pointer need not\n *     even point to properly allocated memory; the user will only be passed to\n *     the callback function if they are valid, and the provided user pointer\n *     will not be dereferenced during this process.\n *\n * @param callback\n *     The callback to invoke on the given user if they are valid. NULL will be\n *     passed to this callback instead if the user is not valid.\n *\n * @param data\n *     Arbitrary data to pass to the given callback.\n *\n * @return\n *     The value returned by the callback.\n */\nvoid* guac_client_for_user(guac_client* client, guac_user* user,\n        guac_user_callback* callback, void* data);\n\n/**\n * Marks the end of the current frame by sending a \"sync\" instruction to\n * all connected users. This instruction will contain the current timestamp.\n * The last_sent_timestamp member of guac_client will be updated accordingly.\n *\n * If an error occurs sending the instruction, a non-zero value is\n * returned, and guac_error is set appropriately.\n *\n * @param client The guac_client which has finished a frame.\n * @return Zero on success, non-zero on error.\n */\nint guac_client_end_frame(guac_client* client);\n\n/**\n * Initializes the given guac_client using the initialization routine provided\n * by the plugin corresponding to the named protocol. This will automatically\n * invoke guac_client_init within the plugin for the given protocol.\n *\n * Note that the connection will likely not be established until the first\n * user (the \"owner\") is added to the client.\n *\n * @param client The guac_client to initialize.\n * @param protocol The name of the protocol to use.\n * @return Zero if initialization was successful, non-zero otherwise.\n */\nint guac_client_load_plugin(guac_client* client, const char* protocol);\n\n/**\n * Calculates and returns the approximate processing lag experienced by the\n * pool of users. The processing lag is the difference in time between server\n * and client due purely to data processing and excluding network delays.\n *\n * @param client\n *     The guac_client to calculate the processing lag of.\n *\n * @return\n *     The approximate processing lag of the pool of users associated with the\n *     given guac_client, in milliseconds.\n */\nint guac_client_get_processing_lag(guac_client* client);\n\n/**\n * Streams the given connection parameter value over an argument value stream\n * (\"argv\" instruction), exposing the current value of the named connection\n * parameter to all users of the given client. The argument value stream will\n * be automatically allocated and freed.\n *\n * @param client\n *     The Guacamole client for which the argument value stream should be\n *     allocated.\n *\n * @param socket\n *     The socket over which instructions associated with the argument value\n *     stream should be sent.\n *\n * @param mimetype\n *     The mimetype of the data within the connection parameter value being\n *     sent.\n *\n * @param name\n *     The name of the connection parameter being sent.\n *\n * @param value\n *     The current value of the connection parameter being sent.\n */\nvoid guac_client_stream_argv(guac_client* client, guac_socket* socket,\n        const char* mimetype, const char* name, const char* value);\n\n/**\n * Streams the image data of the given surface over an image stream (\"img\"\n * instruction) as PNG-encoded data. The image stream will be automatically\n * allocated and freed.\n *\n * @param client\n *     The Guacamole client for which the image stream should be allocated.\n *\n * @param socket\n *     The socket over which instructions associated with the image stream\n *     should be sent.\n *\n * @param mode\n *     The composite mode to use when rendering the image over the given layer.\n *\n * @param layer\n *     The destination layer.\n *\n * @param x\n *     The X coordinate of the upper-left corner of the destination rectangle\n *     within the given layer.\n *\n * @param y\n *     The Y coordinate of the upper-left corner of the destination rectangle\n *     within the given layer.\n *\n * @param surface\n *     A Cairo surface containing the image data to be streamed.\n */\nvoid guac_client_stream_png(guac_client* client, guac_socket* socket,\n        guac_composite_mode mode, const guac_layer* layer, int x, int y,\n        cairo_surface_t* surface);\n\n/**\n * Streams the image data of the given surface over an image stream (\"img\"\n * instruction) as JPEG-encoded data at the given quality. The image stream\n * will be automatically allocated and freed.\n *\n * @param client\n *     The Guacamole client for which the image stream should be allocated.\n *\n * @param socket\n *     The socket over which instructions associated with the image stream\n *     should be sent.\n *\n * @param mode\n *     The composite mode to use when rendering the image over the given layer.\n *\n * @param layer\n *     The destination layer.\n *\n * @param x\n *     The X coordinate of the upper-left corner of the destination rectangle\n *     within the given layer.\n *\n * @param y\n *     The Y coordinate of the upper-left corner of the destination rectangle\n *     within the given layer.\n *\n * @param surface\n *     A Cairo surface containing the image data to be streamed.\n *\n * @param quality\n *     The JPEG image quality, which must be an integer value between 0 and 100\n *     inclusive. Larger values indicate improving quality at the expense of\n *     larger file size.\n */\nvoid guac_client_stream_jpeg(guac_client* client, guac_socket* socket,\n        guac_composite_mode mode, const guac_layer* layer, int x, int y,\n        cairo_surface_t* surface, int quality);\n\n/**\n * Streams the image data of the given surface over an image stream (\"img\"\n * instruction) as WebP-encoded data at the given quality. The image stream\n * will be automatically allocated and freed. If the server does not support\n * WebP, this function has no effect, so be sure to check the result of\n * guac_client_supports_webp() prior to calling this function.\n *\n * @param client\n *     The Guacamole client for whom the image stream should be allocated.\n *\n * @param socket\n *     The socket over which instructions associated with the image stream\n *     should be sent.\n *\n * @param mode\n *     The composite mode to use when rendering the image over the given layer.\n *\n * @param layer\n *     The destination layer.\n *\n * @param x\n *     The X coordinate of the upper-left corner of the destination rectangle\n *     within the given layer.\n *\n * @param y\n *     The Y coordinate of the upper-left corner of the destination rectangle\n *     within the given layer.\n *\n * @param surface\n *     A Cairo surface containing the image data to be streamed.\n *\n * @param quality\n *     The WebP image quality, which must be an integer value between 0 and 100\n *     inclusive. For lossy images, larger values indicate improving quality at\n *     the expense of larger file size. For lossless images, this dictates the\n *     quality of compression, with larger values producing smaller files at\n *     the expense of speed.\n *\n * @param lossless\n *     Zero to encode a lossy image, non-zero to encode losslessly.\n */\nvoid guac_client_stream_webp(guac_client* client, guac_socket* socket,\n        guac_composite_mode mode, const guac_layer* layer, int x, int y,\n        cairo_surface_t* surface, int quality, int lossless);\n\n/**\n * Returns whether all users of the given client support WebP. If any user does\n * not support WebP, or the server cannot encode WebP images, zero is returned.\n *\n * @param client\n *     The Guacamole client whose users should be checked for WebP support.\n *\n * @return\n *     Non-zero if the all users of the given client claim to support WebP and\n *     the server has been built with WebP support, zero otherwise.\n */\nint guac_client_supports_webp(guac_client* client);\n\n/**\n * The default Guacamole client layer, layer 0.\n */\nextern const guac_layer* GUAC_DEFAULT_LAYER;\n\n#endif\n\n"
    },
    "skipped": [],
    "total_files": 490
}