{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/src/arm/linux/init.c": "#include <stdint.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <cpuinfo.h>\n#include <arm/linux/api.h>\n#if defined(__ANDROID__)\n\t#include <arm/android/api.h>\n#endif\n#include <arm/api.h>\n#include <arm/midr.h>\n#include <linux/api.h>\n#include <cpuinfo/internal-api.h>\n#include <cpuinfo/log.h>\n\n\nstruct cpuinfo_arm_isa cpuinfo_isa = { 0 };\n\nstatic struct cpuinfo_package package = { { 0 } };\n\nstatic inline bool bitmask_all(uint32_t bitfield, uint32_t mask) {\n\treturn (bitfield & mask) == mask;\n}\n\nstatic inline uint32_t min(uint32_t a, uint32_t b) {\n\treturn a < b ? a : b;\n}\n\nstatic inline int cmp(uint32_t a, uint32_t b) {\n\treturn (a > b) - (a < b);\n}\n\nstatic bool cluster_siblings_parser(\n\tuint32_t processor, uint32_t siblings_start, uint32_t siblings_end,\n\tstruct cpuinfo_arm_linux_processor* processors)\n{\n\tprocessors[processor].flags |= CPUINFO_LINUX_FLAG_PACKAGE_CLUSTER;\n\tuint32_t package_leader_id = processors[processor].package_leader_id;\n\n\tfor (uint32_t sibling = siblings_start; sibling < siblings_end; sibling++) {\n\t\tif (!bitmask_all(processors[sibling].flags, CPUINFO_LINUX_FLAG_VALID)) {\n\t\t\tcpuinfo_log_info(\"invalid processor %\"PRIu32\" reported as a sibling for processor %\"PRIu32,\n\t\t\t\tsibling, processor);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst uint32_t sibling_package_leader_id = processors[sibling].package_leader_id;\n\t\tif (sibling_package_leader_id < package_leader_id) {\n\t\t\tpackage_leader_id = sibling_package_leader_id;\n\t\t}\n\n\t\tprocessors[sibling].package_leader_id = package_leader_id;\n\t\tprocessors[sibling].flags |= CPUINFO_LINUX_FLAG_PACKAGE_CLUSTER;\n\t}\n\n\tprocessors[processor].package_leader_id = package_leader_id;\n\n\treturn true;\n}\n\nstatic int cmp_arm_linux_processor(const void* ptr_a, const void* ptr_b) {\n\tconst struct cpuinfo_arm_linux_processor* processor_a = (const struct cpuinfo_arm_linux_processor*) ptr_a;\n\tconst struct cpuinfo_arm_linux_processor* processor_b = (const struct cpuinfo_arm_linux_processor*) ptr_b;\n\n\t/* Move usable processors towards the start of the array */\n\tconst bool usable_a = bitmask_all(processor_a->flags, CPUINFO_LINUX_FLAG_VALID);\n\tconst bool usable_b = bitmask_all(processor_b->flags, CPUINFO_LINUX_FLAG_VALID);\n\tif (usable_a != usable_b) {\n\t\treturn (int) usable_b - (int) usable_a;\n\t}\n\n\t/* Compare based on core type (e.g. Cortex-A57 < Cortex-A53) */\n\tconst uint32_t midr_a = processor_a->midr;\n\tconst uint32_t midr_b = processor_b->midr;\n\tif (midr_a != midr_b) {\n\t\tconst uint32_t score_a = midr_score_core(midr_a);\n\t\tconst uint32_t score_b = midr_score_core(midr_b);\n\t\tif (score_a != score_b) {\n\t\t\treturn score_a > score_b ? -1 : 1;\n\t\t}\n\t}\n\n\t/* Compare based on core frequency (e.g. 2.0 GHz < 1.2 GHz) */\n\tconst uint32_t frequency_a = processor_a->max_frequency;\n\tconst uint32_t frequency_b = processor_b->max_frequency;\n\tif (frequency_a != frequency_b) {\n\t\treturn frequency_a > frequency_b ? -1 : 1;\n\t}\n\n\t/* Compare based on cluster leader id (i.e. cluster 1 < cluster 0) */\n\tconst uint32_t cluster_a = processor_a->package_leader_id;\n\tconst uint32_t cluster_b = processor_b->package_leader_id;\n\tif (cluster_a != cluster_b) {\n\t\treturn cluster_a > cluster_b ? -1 : 1;\n\t}\n\n\t/* Compare based on system processor id (i.e. processor 0 < processor 1) */\n\tconst uint32_t id_a = processor_a->system_processor_id;\n\tconst uint32_t id_b = processor_b->system_processor_id;\n\treturn cmp(id_a, id_b);\n}\n\nvoid cpuinfo_arm_linux_init(void) {\n\tstruct cpuinfo_arm_linux_processor* arm_linux_processors = NULL;\n\tstruct cpuinfo_processor* processors = NULL;\n\tstruct cpuinfo_core* cores = NULL;\n\tstruct cpuinfo_cluster* clusters = NULL;\n\tstruct cpuinfo_uarch_info* uarchs = NULL;\n\tstruct cpuinfo_cache* l1i = NULL;\n\tstruct cpuinfo_cache* l1d = NULL;\n\tstruct cpuinfo_cache* l2 = NULL;\n\tstruct cpuinfo_cache* l3 = NULL;\n\tconst struct cpuinfo_processor** linux_cpu_to_processor_map = NULL;\n\tconst struct cpuinfo_core** linux_cpu_to_core_map = NULL;\n\tuint32_t* linux_cpu_to_uarch_index_map = NULL;\n\n\tconst uint32_t max_processors_count = cpuinfo_linux_get_max_processors_count();\n\tcpuinfo_log_debug(\"system maximum processors count: %\"PRIu32, max_processors_count);\n\n\tconst uint32_t max_possible_processors_count = 1 +\n\t\tcpuinfo_linux_get_max_possible_processor(max_processors_count);\n\tcpuinfo_log_debug(\"maximum possible processors count: %\"PRIu32, max_possible_processors_count);\n\tconst uint32_t max_present_processors_count = 1 +\n\t\tcpuinfo_linux_get_max_present_processor(max_processors_count);\n\tcpuinfo_log_debug(\"maximum present processors count: %\"PRIu32, max_present_processors_count);\n\n\tuint32_t valid_processor_mask = 0;\n\tuint32_t arm_linux_processors_count = max_processors_count;\n\tif (max_present_processors_count != 0) {\n\t\tarm_linux_processors_count = min(arm_linux_processors_count, max_present_processors_count);\n\t\tvalid_processor_mask = CPUINFO_LINUX_FLAG_PRESENT;\n\t}\n\tif (max_possible_processors_count != 0) {\n\t\tarm_linux_processors_count = min(arm_linux_processors_count, max_possible_processors_count);\n\t\tvalid_processor_mask |= CPUINFO_LINUX_FLAG_POSSIBLE;\n\t}\n\tif ((max_present_processors_count | max_possible_processors_count) == 0) {\n\t\tcpuinfo_log_error(\"failed to parse both lists of possible and present processors\");\n\t\treturn;\n\t}\n\n\tarm_linux_processors = calloc(arm_linux_processors_count, sizeof(struct cpuinfo_arm_linux_processor));\n\tif (arm_linux_processors == NULL) {\n\t\tcpuinfo_log_error(\n\t\t\t\"failed to allocate %zu bytes for descriptions of %\"PRIu32\" ARM logical processors\",\n\t\t\tarm_linux_processors_count * sizeof(struct cpuinfo_arm_linux_processor),\n\t\t\tarm_linux_processors_count);\n\t\treturn;\n\t}\n\n\tif (max_possible_processors_count) {\n\t\tcpuinfo_linux_detect_possible_processors(\n\t\t\tarm_linux_processors_count, &arm_linux_processors->flags,\n\t\t\tsizeof(struct cpuinfo_arm_linux_processor),\n\t\t\tCPUINFO_LINUX_FLAG_POSSIBLE);\n\t}\n\n\tif (max_present_processors_count) {\n\t\tcpuinfo_linux_detect_present_processors(\n\t\t\tarm_linux_processors_count, &arm_linux_processors->flags,\n\t\t\tsizeof(struct cpuinfo_arm_linux_processor),\n\t\t\tCPUINFO_LINUX_FLAG_PRESENT);\n\t}\n\n#if defined(__ANDROID__)\n\tstruct cpuinfo_android_properties android_properties;\n\tcpuinfo_arm_android_parse_properties(&android_properties);\n#else\n\tchar proc_cpuinfo_hardware[CPUINFO_HARDWARE_VALUE_MAX];\n#endif\n\tchar proc_cpuinfo_revision[CPUINFO_REVISION_VALUE_MAX];\n\n\tif (!cpuinfo_arm_linux_parse_proc_cpuinfo(\n#if defined(__ANDROID__)\n\t\t\tandroid_properties.proc_cpuinfo_hardware,\n#else\n\t\t\tproc_cpuinfo_hardware,\n#endif\n\t\t\tproc_cpuinfo_revision,\n\t\t\tarm_linux_processors_count,\n\t\t\tarm_linux_processors)) {\n\t\tcpuinfo_log_error(\"failed to parse processor information from /proc/cpuinfo\");\n\t\treturn;\n\t}\n\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tif (bitmask_all(arm_linux_processors[i].flags, valid_processor_mask)) {\n\t\t\tarm_linux_processors[i].flags |= CPUINFO_LINUX_FLAG_VALID;\n\t\t\tcpuinfo_log_debug(\"parsed processor %\"PRIu32\" MIDR 0x%08\"PRIx32,\n\t\t\t\ti, arm_linux_processors[i].midr);\n\t\t}\n\t}\n\n\tuint32_t valid_processors = 0, last_midr = 0;\n\t#if CPUINFO_ARCH_ARM\n\tuint32_t last_architecture_version = 0, last_architecture_flags = 0;\n\t#endif\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tarm_linux_processors[i].system_processor_id = i;\n\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID)) {\n\t\t\tvalid_processors += 1;\n\n\t\t\tif (!(arm_linux_processors[i].flags & CPUINFO_ARM_LINUX_VALID_PROCESSOR)) {\n\t\t\t\t/*\n\t\t\t\t * Processor is in possible and present lists, but not reported in /proc/cpuinfo.\n\t\t\t\t * This is fairly common: high-index processors can be not reported if they are offline.\n\t\t\t\t */\n\t\t\t\tcpuinfo_log_info(\"processor %\"PRIu32\" is not listed in /proc/cpuinfo\", i);\n\t\t\t}\n\n\t\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_ARM_LINUX_VALID_MIDR)) {\n\t\t\t\tlast_midr = arm_linux_processors[i].midr;\n\t\t\t}\n\t\t\t#if CPUINFO_ARCH_ARM\n\t\t\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_ARM_LINUX_VALID_ARCHITECTURE)) {\n\t\t\t\t\tlast_architecture_version = arm_linux_processors[i].architecture_version;\n\t\t\t\t\tlast_architecture_flags   = arm_linux_processors[i].architecture_flags;\n\t\t\t\t}\n\t\t\t#endif\n\t\t} else {\n\t\t\t/* Processor reported in /proc/cpuinfo, but not in possible and/or present lists: log and ignore */\n\t\t\tif (!(arm_linux_processors[i].flags & CPUINFO_ARM_LINUX_VALID_PROCESSOR)) {\n\t\t\t\tcpuinfo_log_warning(\"invalid processor %\"PRIu32\" reported in /proc/cpuinfo\", i);\n\t\t\t}\n\t\t}\n\t}\n\n#if defined(__ANDROID__)\n\tconst struct cpuinfo_arm_chipset chipset =\n\t\tcpuinfo_arm_android_decode_chipset(&android_properties, valid_processors, 0);\n#else\n\tconst struct cpuinfo_arm_chipset chipset =\n\t\tcpuinfo_arm_linux_decode_chipset(proc_cpuinfo_hardware, proc_cpuinfo_revision, valid_processors, 0);\n#endif\n\n\t#if CPUINFO_ARCH_ARM\n\t\tuint32_t isa_features = 0, isa_features2 = 0;\n\t\t#ifdef __ANDROID__\n\t\t\t/*\n\t\t\t * On Android before API 20, libc.so does not provide getauxval function.\n\t\t\t * Thus, we try to dynamically find it, or use two fallback mechanisms:\n\t\t\t * 1. dlopen libc.so, and try to find getauxval\n\t\t\t * 2. Parse /proc/self/auxv procfs file\n\t\t\t * 3. Use features reported in /proc/cpuinfo\n\t\t\t */\n\t\t\tif (!cpuinfo_arm_linux_hwcap_from_getauxval(&isa_features, &isa_features2)) {\n\t\t\t\t/* getauxval can't be used, fall back to parsing /proc/self/auxv */\n\t\t\t\tif (!cpuinfo_arm_linux_hwcap_from_procfs(&isa_features, &isa_features2)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Reading /proc/self/auxv failed, probably due to file permissions.\n\t\t\t\t\t * Use information from /proc/cpuinfo to detect ISA.\n\t\t\t\t\t *\n\t\t\t\t\t * If different processors report different ISA features, take the intersection.\n\t\t\t\t\t */\n\t\t\t\t\tuint32_t processors_with_features = 0;\n\t\t\t\t\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\t\t\t\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID | CPUINFO_ARM_LINUX_VALID_FEATURES)) {\n\t\t\t\t\t\t\tif (processors_with_features == 0) {\n\t\t\t\t\t\t\t\tisa_features = arm_linux_processors[i].features;\n\t\t\t\t\t\t\t\tisa_features2 = arm_linux_processors[i].features2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tisa_features &= arm_linux_processors[i].features;\n\t\t\t\t\t\t\t\tisa_features2 &= arm_linux_processors[i].features2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprocessors_with_features += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t#else\n\t\t\t/* On GNU/Linux getauxval is always available */\n\t\t\tcpuinfo_arm_linux_hwcap_from_getauxval(&isa_features, &isa_features2);\n\t\t#endif\n\t\tcpuinfo_arm_linux_decode_isa_from_proc_cpuinfo(\n\t\t\tisa_features, isa_features2,\n\t\t\tlast_midr, last_architecture_version, last_architecture_flags,\n\t\t\t&chipset, &cpuinfo_isa);\n\t#elif CPUINFO_ARCH_ARM64\n\t\tuint32_t isa_features = 0, isa_features2 = 0;\n\t\t/* getauxval is always available on ARM64 Android */\n\t\tcpuinfo_arm_linux_hwcap_from_getauxval(&isa_features, &isa_features2);\n\t\tcpuinfo_arm64_linux_decode_isa_from_proc_cpuinfo(\n\t\t\tisa_features, isa_features2, last_midr, &chipset, &cpuinfo_isa);\n\t#endif\n\n\t/* Detect min/max frequency and package ID */\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID)) {\n\t\t\tconst uint32_t max_frequency = cpuinfo_linux_get_processor_max_frequency(i);\n\t\t\tif (max_frequency != 0) {\n\t\t\t\tarm_linux_processors[i].max_frequency = max_frequency;\n\t\t\t\tarm_linux_processors[i].flags |= CPUINFO_LINUX_FLAG_MAX_FREQUENCY;\n\t\t\t}\n\n\t\t\tconst uint32_t min_frequency = cpuinfo_linux_get_processor_min_frequency(i);\n\t\t\tif (min_frequency != 0) {\n\t\t\t\tarm_linux_processors[i].min_frequency = min_frequency;\n\t\t\t\tarm_linux_processors[i].flags |= CPUINFO_LINUX_FLAG_MIN_FREQUENCY;\n\t\t\t}\n\n\t\t\tif (cpuinfo_linux_get_processor_package_id(i, &arm_linux_processors[i].package_id)) {\n\t\t\t\tarm_linux_processors[i].flags |= CPUINFO_LINUX_FLAG_PACKAGE_ID;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Initialize topology group IDs */\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tarm_linux_processors[i].package_leader_id = i;\n\t}\n\n\t/* Propagate topology group IDs among siblings */\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tif (!bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (arm_linux_processors[i].flags & CPUINFO_LINUX_FLAG_PACKAGE_ID) {\n\t\t\tcpuinfo_linux_detect_core_siblings(\n\t\t\t\tarm_linux_processors_count, i,\n\t\t\t\t(cpuinfo_siblings_callback) cluster_siblings_parser,\n\t\t\t\tarm_linux_processors);\n\t\t}\n\t}\n\n\t/* Propagate all cluster IDs */\n\tuint32_t clustered_processors = 0;\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID | CPUINFO_LINUX_FLAG_PACKAGE_CLUSTER)) {\n\t\t\tclustered_processors += 1;\n\n\t\t\tconst uint32_t package_leader_id = arm_linux_processors[i].package_leader_id;\n\t\t\tif (package_leader_id < i) {\n\t\t\t\tarm_linux_processors[i].package_leader_id = arm_linux_processors[package_leader_id].package_leader_id;\n\t\t\t}\n\n\t\t\tcpuinfo_log_debug(\"processor %\"PRIu32\" clustered with processor %\"PRIu32\" as inferred from system siblings lists\",\n\t\t\t\ti, arm_linux_processors[i].package_leader_id);\n\t\t}\n\t}\n\n\tif (clustered_processors != valid_processors) {\n\t\t/*\n\t\t * Topology information about some or all logical processors may be unavailable, for the following reasons:\n\t\t * - Linux kernel is too old, or configured without support for topology information in sysfs.\n\t\t * - Core is offline, and Linux kernel is configured to not report topology for offline cores.\n\t\t *\n\t\t * In this case, we assign processors to clusters using two methods:\n\t\t * - Try heuristic cluster configurations (e.g. 6-core SoC usually has 4+2 big.LITTLE configuration).\n\t\t * - If heuristic failed, assign processors to core clusters in a sequential scan.\n\t\t */\n\t\tif (!cpuinfo_arm_linux_detect_core_clusters_by_heuristic(valid_processors, arm_linux_processors_count, arm_linux_processors)) {\n\t\t\tcpuinfo_arm_linux_detect_core_clusters_by_sequential_scan(arm_linux_processors_count, arm_linux_processors);\n\t\t}\n\t}\n\n\tcpuinfo_arm_linux_count_cluster_processors(arm_linux_processors_count, arm_linux_processors);\n\n\tconst uint32_t cluster_count = cpuinfo_arm_linux_detect_cluster_midr(\n\t\t&chipset,\n\t\tarm_linux_processors_count, valid_processors, arm_linux_processors);\n\n\t/* Initialize core vendor, uarch, MIDR, and frequency for every logical processor */\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID)) {\n\t\t\tconst uint32_t cluster_leader = arm_linux_processors[i].package_leader_id;\n\t\t\tif (cluster_leader == i) {\n\t\t\t\t/* Cluster leader: decode core vendor and uarch */\n\t\t\t\tcpuinfo_arm_decode_vendor_uarch(\n\t\t\t\tarm_linux_processors[cluster_leader].midr,\n#if CPUINFO_ARCH_ARM\n\t\t\t\t!!(arm_linux_processors[cluster_leader].features & CPUINFO_ARM_LINUX_FEATURE_VFPV4),\n#endif\n\t\t\t\t&arm_linux_processors[cluster_leader].vendor,\n\t\t\t\t&arm_linux_processors[cluster_leader].uarch);\n\t\t\t} else {\n\t\t\t\t/* Cluster non-leader: copy vendor, uarch, MIDR, and frequency from cluster leader */\n\t\t\t\tarm_linux_processors[i].flags |= arm_linux_processors[cluster_leader].flags &\n\t\t\t\t\t(CPUINFO_ARM_LINUX_VALID_MIDR | CPUINFO_LINUX_FLAG_MAX_FREQUENCY);\n\t\t\t\tarm_linux_processors[i].midr = arm_linux_processors[cluster_leader].midr;\n\t\t\t\tarm_linux_processors[i].vendor = arm_linux_processors[cluster_leader].vendor;\n\t\t\t\tarm_linux_processors[i].uarch = arm_linux_processors[cluster_leader].uarch;\n\t\t\t\tarm_linux_processors[i].max_frequency = arm_linux_processors[cluster_leader].max_frequency;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID)) {\n\t\t\tcpuinfo_log_debug(\"post-analysis processor %\"PRIu32\": MIDR %08\"PRIx32\" frequency %\"PRIu32,\n\t\t\t\ti, arm_linux_processors[i].midr, arm_linux_processors[i].max_frequency);\n\t\t}\n\t}\n\n\tqsort(arm_linux_processors, arm_linux_processors_count,\n\t\tsizeof(struct cpuinfo_arm_linux_processor), cmp_arm_linux_processor);\n\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID)) {\n\t\t\tcpuinfo_log_debug(\"post-sort processor %\"PRIu32\": system id %\"PRIu32\" MIDR %08\"PRIx32\" frequency %\"PRIu32,\n\t\t\t\ti, arm_linux_processors[i].system_processor_id, arm_linux_processors[i].midr, arm_linux_processors[i].max_frequency);\n\t\t}\n\t}\n\n\tuint32_t uarchs_count = 0;\n\tenum cpuinfo_uarch last_uarch;\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID)) {\n\t\t\tif (uarchs_count == 0 || arm_linux_processors[i].uarch != last_uarch) {\n\t\t\t\tlast_uarch = arm_linux_processors[i].uarch;\n\t\t\t\tuarchs_count += 1;\n\t\t\t}\n\t\t\tarm_linux_processors[i].uarch_index = uarchs_count - 1;\n\t\t}\n\t}\n\n\t/*\n\t * Assumptions:\n\t * - No SMP (i.e. each core supports only one hardware thread).\n\t * - Level 1 instruction and data caches are private to the core clusters.\n\t * - Level 2 and level 3 cache is shared between cores in the same cluster.\n\t */\n\tcpuinfo_arm_chipset_to_string(&chipset, package.name);\n\tpackage.processor_count = valid_processors;\n\tpackage.core_count = valid_processors;\n\tpackage.cluster_count = cluster_count;\n\n\tprocessors = calloc(valid_processors, sizeof(struct cpuinfo_processor));\n\tif (processors == NULL) {\n\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for descriptions of %\"PRIu32\" logical processors\",\n\t\t\tvalid_processors * sizeof(struct cpuinfo_processor), valid_processors);\n\t\tgoto cleanup;\n\t}\n\n\tcores = calloc(valid_processors, sizeof(struct cpuinfo_core));\n\tif (cores == NULL) {\n\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for descriptions of %\"PRIu32\" cores\",\n\t\t\tvalid_processors * sizeof(struct cpuinfo_core), valid_processors);\n\t\tgoto cleanup;\n\t}\n\n\tclusters = calloc(cluster_count, sizeof(struct cpuinfo_cluster));\n\tif (clusters == NULL) {\n\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for descriptions of %\"PRIu32\" core clusters\",\n\t\t\tcluster_count * sizeof(struct cpuinfo_cluster), cluster_count);\n\t\tgoto cleanup;\n\t}\n\n\tuarchs = calloc(uarchs_count, sizeof(struct cpuinfo_uarch_info));\n\tif (uarchs == NULL) {\n\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for descriptions of %\"PRIu32\" microarchitectures\",\n\t\t\tuarchs_count * sizeof(struct cpuinfo_uarch_info), uarchs_count);\n\t\tgoto cleanup;\n\t}\n\n\tlinux_cpu_to_processor_map = calloc(arm_linux_processors_count, sizeof(struct cpuinfo_processor*));\n\tif (linux_cpu_to_processor_map == NULL) {\n\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for %\"PRIu32\" logical processor mapping entries\",\n\t\t\tarm_linux_processors_count * sizeof(struct cpuinfo_processor*), arm_linux_processors_count);\n\t\tgoto cleanup;\n\t}\n\n\tlinux_cpu_to_core_map = calloc(arm_linux_processors_count, sizeof(struct cpuinfo_core*));\n\tif (linux_cpu_to_core_map == NULL) {\n\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for %\"PRIu32\" core mapping entries\",\n\t\t\tarm_linux_processors_count * sizeof(struct cpuinfo_core*), arm_linux_processors_count);\n\t\tgoto cleanup;\n\t}\n\n\tif (uarchs_count > 1) {\n\t\tlinux_cpu_to_uarch_index_map = calloc(arm_linux_processors_count, sizeof(uint32_t));\n\t\tif (linux_cpu_to_uarch_index_map == NULL) {\n\t\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for %\"PRIu32\" uarch index mapping entries\",\n\t\t\t\tarm_linux_processors_count * sizeof(uint32_t), arm_linux_processors_count);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tl1i = calloc(valid_processors, sizeof(struct cpuinfo_cache));\n\tif (l1i == NULL) {\n\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for descriptions of %\"PRIu32\" L1I caches\",\n\t\t\tvalid_processors * sizeof(struct cpuinfo_cache), valid_processors);\n\t\tgoto cleanup;\n\t}\n\n\tl1d = calloc(valid_processors, sizeof(struct cpuinfo_cache));\n\tif (l1d == NULL) {\n\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for descriptions of %\"PRIu32\" L1D caches\",\n\t\t\tvalid_processors * sizeof(struct cpuinfo_cache), valid_processors);\n\t\tgoto cleanup;\n\t}\n\n\tuint32_t uarchs_index = 0;\n\tfor (uint32_t i = 0; i < arm_linux_processors_count; i++) {\n\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_LINUX_FLAG_VALID)) {\n\t\t\tif (uarchs_index == 0 || arm_linux_processors[i].uarch != last_uarch) {\n\t\t\t\tlast_uarch = arm_linux_processors[i].uarch;\n\t\t\t\tuarchs[uarchs_index] = (struct cpuinfo_uarch_info) {\n\t\t\t\t\t.uarch = arm_linux_processors[i].uarch,\n\t\t\t\t\t.midr = arm_linux_processors[i].midr,\n\t\t\t\t};\n\t\t\t\tuarchs_index += 1;\n\t\t\t}\n\t\t\tuarchs[uarchs_index - 1].processor_count += 1;\n\t\t\tuarchs[uarchs_index - 1].core_count += 1;\n\t\t}\n\t}\n\n\tuint32_t l2_count = 0, l3_count = 0, big_l3_size = 0, cluster_id = UINT32_MAX;\n\t/* Indication whether L3 (if it exists) is shared between all cores */\n\tbool shared_l3 = true;\n\t/* Populate cache infromation structures in l1i, l1d */\n\tfor (uint32_t i = 0; i < valid_processors; i++) {\n\t\tif (arm_linux_processors[i].package_leader_id == arm_linux_processors[i].system_processor_id) {\n\t\t\tcluster_id += 1;\n\t\t\tclusters[cluster_id] = (struct cpuinfo_cluster) {\n\t\t\t\t.processor_start = i,\n\t\t\t\t.processor_count = arm_linux_processors[i].package_processor_count,\n\t\t\t\t.core_start = i,\n\t\t\t\t.core_count = arm_linux_processors[i].package_processor_count,\n\t\t\t\t.cluster_id = cluster_id,\n\t\t\t\t.package = &package,\n\t\t\t\t.vendor = arm_linux_processors[i].vendor,\n\t\t\t\t.uarch = arm_linux_processors[i].uarch,\n\t\t\t\t.midr = arm_linux_processors[i].midr,\n\t\t\t};\n\t\t}\n\n\t\tprocessors[i].smt_id = 0;\n\t\tprocessors[i].core = cores + i;\n\t\tprocessors[i].cluster = clusters + cluster_id;\n\t\tprocessors[i].package = &package;\n\t\tprocessors[i].linux_id = (int) arm_linux_processors[i].system_processor_id;\n\t\tprocessors[i].cache.l1i = l1i + i;\n\t\tprocessors[i].cache.l1d = l1d + i;\n\t\tlinux_cpu_to_processor_map[arm_linux_processors[i].system_processor_id] = &processors[i];\n\n\t\tcores[i].processor_start = i;\n\t\tcores[i].processor_count = 1;\n\t\tcores[i].core_id = i;\n\t\tcores[i].cluster = clusters + cluster_id;\n\t\tcores[i].package = &package;\n\t\tcores[i].vendor = arm_linux_processors[i].vendor;\n\t\tcores[i].uarch = arm_linux_processors[i].uarch;\n\t\tcores[i].midr = arm_linux_processors[i].midr;\n\t\tlinux_cpu_to_core_map[arm_linux_processors[i].system_processor_id] = &cores[i];\n\n\t\tif (linux_cpu_to_uarch_index_map != NULL) {\n\t\t\tlinux_cpu_to_uarch_index_map[arm_linux_processors[i].system_processor_id] =\n\t\t\t\tarm_linux_processors[i].uarch_index;\n\t\t}\n\n\t\tstruct cpuinfo_cache temp_l2 = { 0 }, temp_l3 = { 0 };\n\t\tcpuinfo_arm_decode_cache(\n\t\t\tarm_linux_processors[i].uarch,\n\t\t\tarm_linux_processors[i].package_processor_count,\n\t\t\tarm_linux_processors[i].midr,\n\t\t\t&chipset,\n\t\t\tcluster_id,\n\t\t\tarm_linux_processors[i].architecture_version,\n\t\t\t&l1i[i], &l1d[i], &temp_l2, &temp_l3);\n\t\tl1i[i].processor_start = l1d[i].processor_start = i;\n\t\tl1i[i].processor_count = l1d[i].processor_count = 1;\n\t\t#if CPUINFO_ARCH_ARM\n\t\t\t/* L1I reported in /proc/cpuinfo overrides defaults */\n\t\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_ARM_LINUX_VALID_ICACHE)) {\n\t\t\t\tl1i[i] = (struct cpuinfo_cache) {\n\t\t\t\t\t.size = arm_linux_processors[i].proc_cpuinfo_cache.i_size,\n\t\t\t\t\t.associativity = arm_linux_processors[i].proc_cpuinfo_cache.i_assoc,\n\t\t\t\t\t.sets = arm_linux_processors[i].proc_cpuinfo_cache.i_sets,\n\t\t\t\t\t.partitions = 1,\n\t\t\t\t\t.line_size = arm_linux_processors[i].proc_cpuinfo_cache.i_line_length\n\t\t\t\t};\n\t\t\t}\n\t\t\t/* L1D reported in /proc/cpuinfo overrides defaults */\n\t\t\tif (bitmask_all(arm_linux_processors[i].flags, CPUINFO_ARM_LINUX_VALID_DCACHE)) {\n\t\t\t\tl1d[i] = (struct cpuinfo_cache) {\n\t\t\t\t\t.size = arm_linux_processors[i].proc_cpuinfo_cache.d_size,\n\t\t\t\t\t.associativity = arm_linux_processors[i].proc_cpuinfo_cache.d_assoc,\n\t\t\t\t\t.sets = arm_linux_processors[i].proc_cpuinfo_cache.d_sets,\n\t\t\t\t\t.partitions = 1,\n\t\t\t\t\t.line_size = arm_linux_processors[i].proc_cpuinfo_cache.d_line_length\n\t\t\t\t};\n\t\t\t}\n\t\t#endif\n\n\t\tif (temp_l3.size != 0) {\n\t\t\t/*\n\t\t\t * Assumptions:\n\t\t\t * - L2 is private to each core\n\t\t\t * - L3 is shared by cores in the same cluster\n\t\t\t * - If cores in different clusters report the same L3, it is shared between all cores.\n\t\t\t */\n\t\t\tl2_count += 1;\n\t\t\tif (arm_linux_processors[i].package_leader_id == arm_linux_processors[i].system_processor_id) {\n\t\t\t\tif (cluster_id == 0) {\n\t\t\t\t\tbig_l3_size = temp_l3.size;\n\t\t\t\t\tl3_count = 1;\n\t\t\t\t} else if (temp_l3.size != big_l3_size) {\n\t\t\t\t\t/* If some cores have different L3 size, L3 is not shared between all cores */\n\t\t\t\t\tshared_l3 = false;\n\t\t\t\t\tl3_count += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* If some cores don't have L3 cache, L3 is not shared between all cores */\n\t\t\tshared_l3 = false;\n\t\t\tif (temp_l2.size != 0) {\n\t\t\t\t/* Assume L2 is shared by cores in the same cluster */\n\t\t\t\tif (arm_linux_processors[i].package_leader_id == arm_linux_processors[i].system_processor_id) {\n\t\t\t\t\tl2_count += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (l2_count != 0) {\n\t\tl2 = calloc(l2_count, sizeof(struct cpuinfo_cache));\n\t\tif (l2 == NULL) {\n\t\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for descriptions of %\"PRIu32\" L2 caches\",\n\t\t\t\tl2_count * sizeof(struct cpuinfo_cache), l2_count);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (l3_count != 0) {\n\t\t\tl3 = calloc(l3_count, sizeof(struct cpuinfo_cache));\n\t\t\tif (l3 == NULL) {\n\t\t\t\tcpuinfo_log_error(\"failed to allocate %zu bytes for descriptions of %\"PRIu32\" L3 caches\",\n\t\t\t\t\tl3_count * sizeof(struct cpuinfo_cache), l3_count);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\n\tcluster_id = UINT32_MAX;\n\tuint32_t l2_index = UINT32_MAX, l3_index = UINT32_MAX;\n\tfor (uint32_t i = 0; i < valid_processors; i++) {\n\t\tif (arm_linux_processors[i].package_leader_id == arm_linux_processors[i].system_processor_id) {\n\t\t\tcluster_id++;\n\t\t}\n\n\t\tstruct cpuinfo_cache dummy_l1i, dummy_l1d, temp_l2 = { 0 }, temp_l3 = { 0 };\n\t\tcpuinfo_arm_decode_cache(\n\t\t\tarm_linux_processors[i].uarch,\n\t\t\tarm_linux_processors[i].package_processor_count,\n\t\t\tarm_linux_processors[i].midr,\n\t\t\t&chipset,\n\t\t\tcluster_id,\n\t\t\tarm_linux_processors[i].architecture_version,\n\t\t\t&dummy_l1i, &dummy_l1d, &temp_l2, &temp_l3);\n\n\t\tif (temp_l3.size != 0) {\n\t\t\t/*\n\t\t\t * Assumptions:\n\t\t\t * - L2 is private to each core\n\t\t\t * - L3 is shared by cores in the same cluster\n\t\t\t * - If cores in different clusters report the same L3, it is shared between all cores.\n\t\t\t */\n\t\t\tl2_index += 1;\n\t\t\tl2[l2_index] = (struct cpuinfo_cache) {\n\t\t\t\t.size            = temp_l2.size,\n\t\t\t\t.associativity   = temp_l2.associativity,\n\t\t\t\t.sets            = temp_l2.sets,\n\t\t\t\t.partitions      = 1,\n\t\t\t\t.line_size       = temp_l2.line_size,\n\t\t\t\t.flags           = temp_l2.flags,\n\t\t\t\t.processor_start = i,\n\t\t\t\t.processor_count = 1,\n\t\t\t};\n\t\t\tprocessors[i].cache.l2 = l2 + l2_index;\n\t\t\tif (arm_linux_processors[i].package_leader_id == arm_linux_processors[i].system_processor_id) {\n\t\t\t\tl3_index += 1;\n\t\t\t\tif (l3_index < l3_count) {\n\t\t\t\t\tl3[l3_index] = (struct cpuinfo_cache) {\n\t\t\t\t\t\t.size            = temp_l3.size,\n\t\t\t\t\t\t.associativity   = temp_l3.associativity,\n\t\t\t\t\t\t.sets            = temp_l3.sets,\n\t\t\t\t\t\t.partitions      = 1,\n\t\t\t\t\t\t.line_size       = temp_l3.line_size,\n\t\t\t\t\t\t.flags           = temp_l3.flags,\n\t\t\t\t\t\t.processor_start = i,\n\t\t\t\t\t\t.processor_count =\n\t\t\t\t\t\t\tshared_l3 ? valid_processors : arm_linux_processors[i].package_processor_count,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (shared_l3) {\n\t\t\t\tprocessors[i].cache.l3 = l3;\n\t\t\t} else if (l3_index < l3_count) {\n\t\t\t\tprocessors[i].cache.l3 = l3 + l3_index;\n\t\t\t}\n\t\t} else if (temp_l2.size != 0) {\n\t\t\t/* Assume L2 is shared by cores in the same cluster */\n\t\t\tif (arm_linux_processors[i].package_leader_id == arm_linux_processors[i].system_processor_id) {\n\t\t\t\tl2_index += 1;\n\t\t\t\tl2[l2_index] = (struct cpuinfo_cache) {\n\t\t\t\t\t.size            = temp_l2.size,\n\t\t\t\t\t.associativity   = temp_l2.associativity,\n\t\t\t\t\t.sets            = temp_l2.sets,\n\t\t\t\t\t.partitions      = 1,\n\t\t\t\t\t.line_size       = temp_l2.line_size,\n\t\t\t\t\t.flags           = temp_l2.flags,\n\t\t\t\t\t.processor_start = i,\n\t\t\t\t\t.processor_count = arm_linux_processors[i].package_processor_count,\n\t\t\t\t};\n\t\t\t}\n\t\t\tprocessors[i].cache.l2 = l2 + l2_index;\n\t\t}\n\t}\n\n\t/* Commit */\n\tcpuinfo_processors = processors;\n\tcpuinfo_cores = cores;\n\tcpuinfo_clusters = clusters;\n\tcpuinfo_packages = &package;\n\tcpuinfo_uarchs = uarchs;\n\tcpuinfo_cache[cpuinfo_cache_level_1i] = l1i;\n\tcpuinfo_cache[cpuinfo_cache_level_1d] = l1d;\n\tcpuinfo_cache[cpuinfo_cache_level_2]  = l2;\n\tcpuinfo_cache[cpuinfo_cache_level_3]  = l3;\n\n\tcpuinfo_processors_count = valid_processors;\n\tcpuinfo_cores_count = valid_processors;\n\tcpuinfo_clusters_count = cluster_count;\n\tcpuinfo_packages_count = 1;\n\tcpuinfo_uarchs_count = uarchs_count;\n\tcpuinfo_cache_count[cpuinfo_cache_level_1i] = valid_processors;\n\tcpuinfo_cache_count[cpuinfo_cache_level_1d] = valid_processors;\n\tcpuinfo_cache_count[cpuinfo_cache_level_2]  = l2_count;\n\tcpuinfo_cache_count[cpuinfo_cache_level_3]  = l3_count;\n\tcpuinfo_max_cache_size = cpuinfo_arm_compute_max_cache_size(&processors[0]);\n\n\tcpuinfo_linux_cpu_max = arm_linux_processors_count;\n\tcpuinfo_linux_cpu_to_processor_map = linux_cpu_to_processor_map;\n\tcpuinfo_linux_cpu_to_core_map = linux_cpu_to_core_map;\n\tcpuinfo_linux_cpu_to_uarch_index_map = linux_cpu_to_uarch_index_map;\n\n\t__sync_synchronize();\n\n\tcpuinfo_is_initialized = true;\n\n\tprocessors = NULL;\n\tcores = NULL;\n\tclusters = NULL;\n\tuarchs = NULL;\n\tl1i = l1d = l2 = l3 = NULL;\n\tlinux_cpu_to_processor_map = NULL;\n\tlinux_cpu_to_core_map = NULL;\n\tlinux_cpu_to_uarch_index_map = NULL;\n\ncleanup:\n\tfree(arm_linux_processors);\n\tfree(processors);\n\tfree(cores);\n\tfree(clusters);\n\tfree(uarchs);\n\tfree(l1i);\n\tfree(l1d);\n\tfree(l2);\n\tfree(l3);\n\tfree(linux_cpu_to_processor_map);\n\tfree(linux_cpu_to_core_map);\n\tfree(linux_cpu_to_uarch_index_map);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/src/arm/linux/hwcap.c": "#include <string.h>\n\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <elf.h>\n\n#if CPUINFO_MOCK\n\t#include <cpuinfo-mock.h>\n#endif\n#include <cpuinfo.h>\n#include <arm/linux/api.h>\n#include <cpuinfo/log.h>\n\n#if CPUINFO_ARCH_ARM64 || CPUINFO_ARCH_ARM && !defined(__ANDROID__)\n\t#include <sys/auxv.h>\n#else\n\t#define AT_HWCAP 16\n\t#define AT_HWCAP2 26\n#endif\n\n\n#if CPUINFO_MOCK\n\tstatic uint32_t mock_hwcap = 0;\n\tvoid cpuinfo_set_hwcap(uint32_t hwcap) {\n\t\tmock_hwcap = hwcap;\n\t}\n\n\tstatic uint32_t mock_hwcap2 = 0;\n\tvoid cpuinfo_set_hwcap2(uint32_t hwcap2) {\n\t\tmock_hwcap2 = hwcap2;\n\t}\n#endif\n\n\n#if CPUINFO_ARCH_ARM\n\ttypedef unsigned long (*getauxval_function_t)(unsigned long);\n\n\tbool cpuinfo_arm_linux_hwcap_from_getauxval(\n\t\tuint32_t hwcap[restrict static 1],\n\t\tuint32_t hwcap2[restrict static 1])\n\t{\n\t\t#if CPUINFO_MOCK\n\t\t\t*hwcap  = mock_hwcap;\n\t\t\t*hwcap2 = mock_hwcap2;\n\t\t\treturn true;\n\t\t#elif defined(__ANDROID__)\n\t\t\t/* Android: dynamically check if getauxval is supported */\n\t\t\tvoid* libc = NULL;\n\t\t\tgetauxval_function_t getauxval = NULL;\n\n\t\t\tdlerror();\n\t\t\tlibc = dlopen(\"libc.so\", RTLD_LAZY);\n\t\t\tif (libc == NULL) {\n\t\t\t\tcpuinfo_log_warning(\"failed to load libc.so: %s\", dlerror());\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tgetauxval = (getauxval_function_t) dlsym(libc, \"getauxval\");\n\t\t\tif (getauxval == NULL) {\n\t\t\t\tcpuinfo_log_info(\"failed to locate getauxval in libc.so: %s\", dlerror());\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t*hwcap  = getauxval(AT_HWCAP);\n\t\t\t*hwcap2 = getauxval(AT_HWCAP2);\n\n\t\tcleanup:\n\t\t\tif (libc != NULL) {\n\t\t\t\tdlclose(libc);\n\t\t\t\tlibc = NULL;\n\t\t\t}\n\t\t\treturn getauxval != NULL;\n\t\t#else\n\t\t\t/* GNU/Linux: getauxval is always supported */\n\t\t\t*hwcap  = getauxval(AT_HWCAP);\n\t\t\t*hwcap2 = getauxval(AT_HWCAP2);\n\t\t\treturn true;\n\t\t#endif\n\t}\n\n\t#ifdef __ANDROID__\n\t\tbool cpuinfo_arm_linux_hwcap_from_procfs(\n\t\t\tuint32_t hwcap[restrict static 1],\n\t\t\tuint32_t hwcap2[restrict static 1])\n\t\t{\n\t\t\t#if CPUINFO_MOCK\n\t\t\t\t*hwcap  = mock_hwcap;\n\t\t\t\t*hwcap2 = mock_hwcap2;\n\t\t\t\treturn true;\n\t\t\t#else\n\t\t\t\tuint32_t hwcaps[2] = { 0, 0 };\n\t\t\t\tbool result = false;\n\t\t\t\tint file = -1;\n\n\t\t\t\tfile = open(\"/proc/self/auxv\", O_RDONLY);\n\t\t\t\tif (file == -1) {\n\t\t\t\t\tcpuinfo_log_warning(\"failed to open /proc/self/auxv: %s\", strerror(errno));\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tssize_t bytes_read;\n\t\t\t\tdo {\n\t\t\t\t\tElf32_auxv_t elf_auxv;\n\t\t\t\t\tbytes_read = read(file, &elf_auxv, sizeof(Elf32_auxv_t));\n\t\t\t\t\tif (bytes_read < 0) {\n\t\t\t\t\t\tcpuinfo_log_warning(\"failed to read /proc/self/auxv: %s\", strerror(errno));\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t} else if (bytes_read > 0) {\n\t\t\t\t\t\tif (bytes_read == sizeof(elf_auxv)) {\n\t\t\t\t\t\t\tswitch (elf_auxv.a_type) {\n\t\t\t\t\t\t\t\tcase AT_HWCAP:\n\t\t\t\t\t\t\t\t\thwcaps[0] = (uint32_t) elf_auxv.a_un.a_val;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase AT_HWCAP2:\n\t\t\t\t\t\t\t\t\thwcaps[1] = (uint32_t) elf_auxv.a_un.a_val;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcpuinfo_log_warning(\n\t\t\t\t\t\t\t\t\"failed to read %zu bytes from /proc/self/auxv: %zu bytes available\",\n\t\t\t\t\t\t\t\tsizeof(elf_auxv), (size_t) bytes_read);\n\t\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (bytes_read == sizeof(Elf32_auxv_t));\n\n\t\t\t\t/* Success, commit results */\n\t\t\t\t*hwcap  = hwcaps[0];\n\t\t\t\t*hwcap2 = hwcaps[1];\n\t\t\t\tresult = true;\n\n\t\t\tcleanup:\n\t\t\t\tif (file != -1) {\n\t\t\t\t\tclose(file);\n\t\t\t\t\tfile = -1;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t#endif\n\t\t}\n\t#endif /* __ANDROID__ */\n#elif CPUINFO_ARCH_ARM64\n\tvoid cpuinfo_arm_linux_hwcap_from_getauxval(\n\t\tuint32_t hwcap[restrict static 1],\n\t\tuint32_t hwcap2[restrict static 1])\n\t{\n\t\t#if CPUINFO_MOCK\n\t\t\t*hwcap  = mock_hwcap;\n\t\t\t*hwcap2 = mock_hwcap2;\n\t\t#else\n\t\t\t*hwcap  = (uint32_t) getauxval(AT_HWCAP);\n\t\t\t*hwcap2 = (uint32_t) getauxval(AT_HWCAP2);\n\t\t\treturn ;\n\t\t#endif\n\t}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/tools/auxv-dump.c": "#include <stdlib.h>\n#include <stdio.h>\n\n#include <sys/auxv.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n#include <cpuinfo.h>\n\n\ntypedef unsigned long (*getauxval_function_t)(unsigned long);\n\nint main(int argc, char** argv) {\n\tvoid* libc = dlopen(\"libc.so\", RTLD_NOW);\n\tif (libc == NULL) {\n\t\tfprintf(stderr, \"Error: failed to load libc.so: %s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tgetauxval_function_t getauxval = (getauxval_function_t) dlsym(libc, \"getauxval\");\n\tif (getauxval == NULL) {\n\t\tfprintf(stderr, \"Error: failed to locate getauxval in libc.so: %s\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tprintf(\"AT_HWCAP = 0x%08lX\\n\", getauxval(AT_HWCAP));\n\t#if CPUINFO_ARCH_ARM\n\t\tprintf(\"AT_HWCAP2 = 0x%08lX\\n\", getauxval(AT_HWCAP2));\n\t#endif\n\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/tools/gpu-dump.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <dlfcn.h>\n\n#include <EGL/egl.h>\n#include <GLES2/gl2.h>\n\n\n#define COUNT_OF(x) (sizeof(x) / sizeof(0[x]))\n\n\nstruct egl_enum_item {\n\tEGLint id;\n\tconst char* name;\n};\n\nstruct egl_enum_item egl_enum_boolean[] = {\n\t{\n\t\t.id = EGL_TRUE,\n\t\t.name = \"EGL_TRUE\",\n\t},\n\t{\n\t\t.id = EGL_FALSE,\n\t\t.name = \"EGL_FALSE\",\n\t},\n};\n\nstruct egl_enum_item egl_enum_caveat[] = {\n\t{\n\t\t.id = EGL_NONE,\n\t\t.name = \"EGL_NONE\",\n\t},\n\t{\n\t\t.id = EGL_SLOW_CONFIG,\n\t\t.name = \"EGL_SLOW_CONFIG\",\n\t},\n\t{\n\t\t.id = EGL_NON_CONFORMANT_CONFIG,\n\t\t.name = \"EGL_NON_CONFORMANT_CONFIG\",\n\t},\n};\n\nstruct egl_enum_item egl_enum_transparency[] = {\n\t{\n\t\t.id = EGL_NONE,\n\t\t.name = \"EGL_NONE\",\n\t},\n\t{\n\t\t.id = EGL_TRANSPARENT_RGB,\n\t\t.name = \"EGL_TRANSPARENT_RGB\",\n\t},\n};\n\nstruct egl_enum_item egl_enum_color_buffer[] = {\n\t{\n\t\t.id = EGL_RGB_BUFFER,\n\t\t.name = \"EGL_RGB_BUFFER\",\n\t},\n\t{\n\t\t.id = EGL_LUMINANCE_BUFFER,\n\t\t.name = \"EGL_LUMINANCE_BUFFER\",\n\t},\n};\n\n#ifndef EGL_OPENGL_ES3_BIT\n\t#define EGL_OPENGL_ES3_BIT 0x40\n#endif\n\nstruct egl_enum_item egl_enum_conformant[] = {\n\t{\n\t\t.id = EGL_OPENGL_BIT,\n\t\t.name = \"EGL_OPENGL_BIT\",\n\t},\n\t{\n\t\t.id = EGL_OPENGL_ES_BIT,\n\t\t.name = \"EGL_OPENGL_ES_BIT\",\n\t},\n\t{\n\t\t.id = EGL_OPENGL_ES2_BIT,\n\t\t.name = \"EGL_OPENGL_ES2_BIT\",\n\t},\n\t{\n\t\t.id = EGL_OPENGL_ES3_BIT,\n\t\t.name = \"EGL_OPENGL_ES3_BIT\",\n\t},\n\t{\n\t\t.id = EGL_OPENVG_BIT,\n\t\t.name = \"EGL_OPENVG_BIT\",\n\t},\n};\n\nstruct egl_enum_item egl_enum_surface_type[] = {\n\t{\n\t\t.id = EGL_PBUFFER_BIT,\n\t\t.name = \"EGL_PBUFFER_BIT\",\n\t},\n\t{\n\t\t.id = EGL_PIXMAP_BIT,\n\t\t.name = \"EGL_PIXMAP_BIT\",\n\t},\n\t{\n\t\t.id = EGL_WINDOW_BIT,\n\t\t.name = \"EGL_WINDOW_BIT\",\n\t},\n\t{\n\t\t.id = EGL_VG_COLORSPACE_LINEAR_BIT,\n\t\t.name = \"EGL_VG_COLORSPACE_LINEAR_BIT\",\n\t},\n\t{\n\t\t.id = EGL_VG_ALPHA_FORMAT_PRE_BIT,\n\t\t.name = \"EGL_VG_ALPHA_FORMAT_PRE_BIT\",\n\t},\n\t{\n\t\t.id = EGL_MULTISAMPLE_RESOLVE_BOX_BIT,\n\t\t.name = \"EGL_MULTISAMPLE_RESOLVE_BOX_BIT\",\n\t},\n\t{\n\t\t.id = EGL_SWAP_BEHAVIOR_PRESERVED_BIT,\n\t\t.name = \"EGL_SWAP_BEHAVIOR_PRESERVED_BIT\",\n\t},\n};\n\nstruct egl_enum_item egl_enum_renderable_type[] = {\n\t{\n\t\t.id = EGL_OPENGL_ES_BIT,\n\t\t.name = \"EGL_OPENGL_ES_BIT\",\n\t},\n\t{\n\t\t.id = EGL_OPENVG_BIT,\n\t\t.name = \"EGL_OPENVG_BIT\",\n\t},\n\t{\n\t\t.id = EGL_OPENGL_ES2_BIT,\n\t\t.name = \"EGL_OPENGL_ES2_BIT\",\n\t},\n\t{\n\t\t.id = EGL_OPENGL_BIT,\n\t\t.name = \"EGL_OPENGL_BIT\",\n\t},\n\t{\n\t\t.id = EGL_OPENGL_ES3_BIT,\n\t\t.name = \"EGL_OPENGL_ES3_BIT\",\n\t},\n};\n\nstruct egl_config_attribute {\n\tEGLint id;\n\tconst char* name;\n\tint32_t cardinality;\n\tconst struct egl_enum_item* values;\n};\n\nstruct egl_config_attribute egl_config_attributes[] = {\n\t{\n\t\t.id = EGL_CONFIG_ID,\n\t\t.name = \"EGL_CONFIG_ID\",\n\t},\n\t{\n\t\t.id = EGL_CONFIG_CAVEAT,\n\t\t.name = \"EGL_CONFIG_CAVEAT\",\n\t\t.cardinality = COUNT_OF(egl_enum_caveat),\n\t\t.values = egl_enum_caveat,\n\t},\n\t{\n\t\t.id = EGL_LUMINANCE_SIZE,\n\t\t.name = \"EGL_LUMINANCE_SIZE\",\n\t},\n\t{\n\t\t.id = EGL_RED_SIZE,\n\t\t.name = \"EGL_RED_SIZE\",\n\t},\n\t{\n\t\t.id = EGL_GREEN_SIZE,\n\t\t.name = \"EGL_GREEN_SIZE\",\n\t},\n\t{\n\t\t.id = EGL_BLUE_SIZE,\n\t\t.name = \"EGL_BLUE_SIZE\",\n\t},\n\t{\n\t\t.id = EGL_ALPHA_SIZE,\n\t\t.name = \"EGL_ALPHA_SIZE\",\n\t},\n\t{\n\t\t.id = EGL_DEPTH_SIZE,\n\t\t.name = \"EGL_DEPTH_SIZE\",\n\t},\n\t{\n\t\t.id = EGL_STENCIL_SIZE,\n\t\t.name = \"EGL_STENCIL_SIZE\",\n\t},\n\t{\n\t\t.id = EGL_ALPHA_MASK_SIZE,\n\t\t.name = \"EGL_ALPHA_MASK_SIZE\",\n\t},\n\t{\n\t\t.id = EGL_BIND_TO_TEXTURE_RGB,\n\t\t.name = \"EGL_BIND_TO_TEXTURE_RGB\",\n\t\t.cardinality = COUNT_OF(egl_enum_boolean),\n\t\t.values = egl_enum_boolean,\n\t},\n\t{\n\t\t.id = EGL_BIND_TO_TEXTURE_RGBA,\n\t\t.name = \"EGL_BIND_TO_TEXTURE_RGBA\",\n\t\t.cardinality = COUNT_OF(egl_enum_boolean),\n\t\t.values = egl_enum_boolean,\n\t},\n\t{\n\t\t.id = EGL_MAX_PBUFFER_WIDTH,\n\t\t.name = \"EGL_MAX_PBUFFER_WIDTH\",\n\t},\n\t{\n\t\t.id = EGL_MAX_PBUFFER_HEIGHT,\n\t\t.name = \"EGL_MAX_PBUFFER_HEIGHT\",\n\t},\n\t{\n\t\t.id = EGL_MAX_PBUFFER_PIXELS,\n\t\t.name = \"EGL_MAX_PBUFFER_PIXELS\",\n\t},\n\t{\n\t\t.id = EGL_TRANSPARENT_RED_VALUE,\n\t\t.name = \"EGL_TRANSPARENT_RED_VALUE\",\n\t},\n\t{\n\t\t.id = EGL_TRANSPARENT_GREEN_VALUE,\n\t\t.name = \"EGL_TRANSPARENT_GREEN_VALUE\",\n\t},\n\t{\n\t\t.id = EGL_TRANSPARENT_BLUE_VALUE,\n\t\t.name = \"EGL_TRANSPARENT_BLUE_VALUE\",\n\t},\n\t{\n\t\t.id = EGL_SAMPLE_BUFFERS,\n\t\t.name = \"EGL_SAMPLE_BUFFERS\",\n\t},\n\t{\n\t\t.id = EGL_SAMPLES,\n\t\t.name = \"EGL_SAMPLES\",\n\t},\n\t{\n\t\t.id = EGL_LEVEL,\n\t\t.name = \"EGL_LEVEL\",\n\t},\n\t{\n\t\t.id = EGL_MAX_SWAP_INTERVAL,\n\t\t.name = \"EGL_MAX_SWAP_INTERVAL\",\n\t},\n\t{\n\t\t.id = EGL_MIN_SWAP_INTERVAL,\n\t\t.name = \"EGL_MIN_SWAP_INTERVAL\",\n\t},\n\t{\n\t\t.id = EGL_SURFACE_TYPE,\n\t\t.name = \"EGL_SURFACE_TYPE\",\n\t\t.cardinality = -(int32_t) COUNT_OF(egl_enum_surface_type),\n\t\t.values = egl_enum_surface_type,\n\t},\n\t{\n\t\t.id = EGL_RENDERABLE_TYPE,\n\t\t.name = \"EGL_RENDERABLE_TYPE\",\n\t\t.cardinality = -(int32_t) COUNT_OF(egl_enum_renderable_type),\n\t\t.values = egl_enum_renderable_type,\n\t},\n\t{\n\t\t.id = EGL_CONFORMANT,\n\t\t.name = \"EGL_CONFORMANT\",\n\t\t.cardinality = -(int32_t) COUNT_OF(egl_enum_conformant),\n\t\t.values = egl_enum_conformant,\n\t},\n\t{\n\t\t.id = EGL_TRANSPARENT_TYPE,\n\t\t.name = \"EGL_TRANSPARENT_TYPE\",\n\t\t.cardinality = COUNT_OF(egl_enum_transparency),\n\t\t.values = egl_enum_transparency,\n\t},\n\t{\n\t\t.id = EGL_COLOR_BUFFER_TYPE,\n\t\t.name = \"EGL_COLOR_BUFFER_TYPE\",\n\t\t.cardinality = COUNT_OF(egl_enum_color_buffer),\n\t\t.values = egl_enum_color_buffer,\n\t},\n};\n\nvoid report_gles_attributes(void) {\n\tvoid* libEGL = NULL;\n\tEGLConfig* configs = NULL;\n\tEGLDisplay display = EGL_NO_DISPLAY;\n\tEGLSurface surface = EGL_NO_SURFACE;\n\tEGLContext context = EGL_NO_CONTEXT;\n\tEGLBoolean egl_init_status = EGL_FALSE;\n\tEGLBoolean egl_make_current_status = EGL_FALSE;\n\tEGLBoolean egl_status;\n\n\tlibEGL = dlopen(\"libEGL.so\", RTLD_LAZY | RTLD_LOCAL);\n\n\tdisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n\tif (display == EGL_NO_DISPLAY) {\n\t\tfprintf(stderr, \"failed to get default EGL display\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tEGLint egl_major = 0, egl_minor = 0;\n\tegl_init_status = eglInitialize(display, &egl_major, &egl_minor);\n\tif (egl_init_status != EGL_TRUE) {\n\t\tfprintf(stderr, \"failed to initialize EGL display connection\\n\");\n\t\tgoto cleanup;\n\t}\n\tprintf(\"initialized display connection with EGL %d.%d\\n\", (int) egl_major, (int) egl_minor);\n\n\tEGLint configs_count = 0;\n\tegl_status = eglGetConfigs(display, NULL, 0, &configs_count);\n\tif (egl_status != EGL_TRUE) {\n\t\tfprintf(stderr, \"failed to get the number of EGL frame buffer configurations\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tconfigs = (EGLConfig*) malloc(configs_count * sizeof(EGLConfig));\n\tif (configs == NULL) {\n\t\tfprintf(stderr, \"failed to allocate %zu bytes for %d frame buffer configurations\\n\",\n\t\t\tconfigs_count * sizeof(EGLConfig), configs_count);\n\t\tgoto cleanup;\n\t}\n\n\tegl_status = eglGetConfigs(display, configs, configs_count, &configs_count);\n\tif (egl_status != EGL_TRUE || configs_count == 0) {\n\t\tfprintf(stderr, \"failed to get EGL frame buffer configurations\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tprintf(\"EGL framebuffer configurations:\\n\");\n\tfor (EGLint i = 0; i < configs_count; i++) {\n\t\tprintf(\"\\tConfiguration #%d:\\n\", (int) i);\n\t\tfor (size_t n = 0; n < COUNT_OF(egl_config_attributes); n++) {\n\t\t\tEGLint value = 0;\n\t\t\tegl_status = eglGetConfigAttrib(display, configs[i], egl_config_attributes[n].id, &value);\n\t\t\tif (egl_config_attributes[n].cardinality == 0) {\n\t\t\t\tprintf(\"\\t\\t%s: %d\\n\", egl_config_attributes[n].name, (int) value);\n\t\t\t} else if (egl_config_attributes[n].cardinality > 0) {\n\t\t\t\t/* Enumeration */\n\t\t\t\tbool known_value = false;\n\t\t\t\tfor (size_t k = 0; k < (size_t) egl_config_attributes[n].cardinality; k++) {\n\t\t\t\t\tif (egl_config_attributes[n].values[k].id == value) {\n\t\t\t\t\t\tprintf(\"\\t\\t%s: %s\\n\", egl_config_attributes[n].name, egl_config_attributes[n].values[k].name);\n\t\t\t\t\t\tknown_value = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!known_value) {\n\t\t\t\t\tprintf(\"\\t\\t%s: unknown (%d)\\n\", egl_config_attributes[n].name, value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Bitfield */\n\t\t\t\tprintf(\"\\t\\t%s: \", egl_config_attributes[n].name);\n\t\t\t\tif (value == 0) {\n\t\t\t\t\tprintf(\"none\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tfor (size_t k = 0; k < (size_t) -egl_config_attributes[n].cardinality; k++) {\n\t\t\t\t\t\tif (egl_config_attributes[n].values[k].id & value) {\n\t\t\t\t\t\t\tvalue &= ~egl_config_attributes[n].values[k].id;\n\t\t\t\t\t\t\tif (value != 0) {\n\t\t\t\t\t\t\t\tprintf(\"%s | \", egl_config_attributes[n].values[k].name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprintf(\"%s\\n\", egl_config_attributes[n].values[k].name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (value != 0) {\n\t\t\t\t\t\tprintf(\"0x%08X\\n\", (int) value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tEGLint const config_attributes[] = {\n\t\tEGL_BIND_TO_TEXTURE_RGBA, EGL_TRUE,\n\t\tEGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,\n\t\tEGL_CONFORMANT, EGL_OPENGL_ES2_BIT,\n\t\tEGL_SURFACE_TYPE, EGL_PBUFFER_BIT,\n\t\tEGL_NONE,\n\t};\n\tEGLConfig config = NULL;\n\tEGLint config_count = 0;\n\tegl_status = eglChooseConfig(display, config_attributes, &config, 1, &config_count);\n\tif (egl_status != EGL_TRUE || config_count == 0 || config == NULL) {\n\t\tfprintf(stderr, \"failed to find EGL frame buffer configuration that match required attributes\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tEGLint const surface_attributes[] = {\n\t\tEGL_HEIGHT, 1,\n\t\tEGL_WIDTH, 1,\n\t\tEGL_TEXTURE_FORMAT, EGL_TEXTURE_RGBA,\n\t\tEGL_TEXTURE_TARGET, EGL_TEXTURE_2D,\n\t\tEGL_NONE,\n\t};\n\tsurface = eglCreatePbufferSurface(display, config, surface_attributes);\n\tif (surface == EGL_NO_SURFACE) {\n\t\tfprintf(stderr, \"failed to create PBuffer surface\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tEGLint const context_attributes[] = {\n\t\tEGL_CONTEXT_CLIENT_VERSION, 2,\n\t\tEGL_NONE,\n\t};\n\tcontext = eglCreateContext(display, config, EGL_NO_CONTEXT, context_attributes);\n\tif (context == EGL_NO_CONTEXT) {\n\t\tfprintf(stderr, \"failed to create OpenGL ES context\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tegl_make_current_status = eglMakeCurrent(display, surface, surface, context);\n\tif (egl_make_current_status != EGL_TRUE) {\n\t\tfprintf(stderr, \"failed to attach OpenGL ES rendering context\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tprintf(\"OpenGL ES Attributes:\\n\");\n\tprintf(\"\\t%s: \\\"%s\\\"\\n\", \"GL_VENDOR\", glGetString(GL_VENDOR));\n\tprintf(\"\\t%s: \\\"%s\\\"\\n\", \"GL_RENDERER\", glGetString(GL_RENDERER));\n\tprintf(\"\\t%s: \\\"%s\\\"\\n\", \"GL_VERSION\", glGetString(GL_VERSION));\n\tprintf(\"\\t%s: \\\"%s\\\"\\n\", \"GL_SHADING_LANGUAGE_VERSION\", glGetString(GL_SHADING_LANGUAGE_VERSION));\n\tprintf(\"\\t%s: \\\"%s\\\"\\n\", \"GL_EXTENSIONS\", glGetString(GL_EXTENSIONS));\n\ncleanup:\n\tif (egl_make_current_status == EGL_TRUE) {\n\t\teglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n\t}\n\tif (context != EGL_NO_CONTEXT) {\n\t\teglDestroyContext(display, context);\n\t}\n\tif (surface != EGL_NO_SURFACE) {\n\t\teglDestroySurface(display, surface);\n\t}\n\tif (egl_init_status == EGL_TRUE) {\n\t\teglTerminate(display);\n\t}\n\tfree(configs);\n\n\tif (libEGL != NULL) {\n\t\tdlclose(libEGL);\n\t}\n}\n\nint main(int argc, char** argv) {\n\treport_gles_attributes();\n\treturn 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/.git/objects/pack/pack-7b3b0e461bb86157bcbc158b2de86149c06d818c.idx",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/.git/objects/pack/pack-7b3b0e461bb86157bcbc158b2de86149c06d818c.pack",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/test/dmesg/huawei-mate-8.log",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/test/dmesg/huawei-mate-9.log",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/test/dmesg/alldocube-iwork8.log",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/test/dmesg/huawei-p9-lite.log",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/test/dmesg/galaxy-grand-prime-value-edition.log",
        "/tmp/vanessa/spack-stage/spack-stage-cpuinfo-master-ylvdztubiiyrspxppfa5572qrc2t7vdj/spack-src/test/build.prop/padcod-10.1.log"
    ],
    "total_files": 547
}