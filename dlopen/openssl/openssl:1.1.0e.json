{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/Makefile.shared": "#\n# Helper makefile to link shared libraries in a portable way.\n# This is much simpler than libtool, and hopefully not too error-prone.\n#\n# The following variables need to be set on the command line to build\n# properly\n\n# CC contains the current compiler.  This one MUST be defined\nCC=cc\nCFLAGS=$(CFLAG)\n# LDFLAGS contains flags to be used when temporary object files (when building\n# shared libraries) are created, or when an application is linked.\n# SHARED_LDFLAGS contains flags to be used when the shared library is created.\nLDFLAGS=$(LDFLAG)\nSHARED_LDFLAGS=$(SHARED_LDFLAG)\n\nRC=windres\n# SHARED_RCFLAGS are flags used with windres, i.e. when build for Cygwin\n# or Mingw.\nSHARED_RCFLAGS=$(SHARED_RCFLAG)\n\nNM=nm\n\n# LIBNAME contains just the name of the library, without prefix (\"lib\"\n# on Unix, \"cyg\" for certain forms under Cygwin...) or suffix (.a, .so,\n# .dll, ...).  This one MUST have a value when using this makefile to\n# build shared libraries.\n# For example, to build libfoo.so, you need to do the following:\n#LIBNAME=foo\nLIBNAME=\n\n# APPNAME contains just the name of the application, without suffix (\"\"\n# on Unix, \".exe\" on Windows, ...).  This one MUST have a value when using\n# this makefile to build applications.\n# For example, to build foo, you need to do the following:\n#APPNAME=foo\nAPPNAME=\n\n# DSTDIR is the directory where the built file should end up in.\nDSTDIR=.\n\n# SRCDIR is the top directory of the source tree.\nSRCDIR=.\n\n# OBJECTS contains all the object files to link together into the application.\n# This must contain at least one object file.\n#OBJECTS=foo.o\nOBJECTS=\n\n# LIBEXTRAS contains extra modules to link together with the library.\n# For example, if a second library, say libbar.a needs to be linked into\n# libfoo.so, you need to do the following:\n#LIBEXTRAS=libbar.a\n# Note that this MUST be used when using the link_dso targets, to hold the\n# names of all object files that go into the target shared object.\nLIBEXTRAS=\n\n# LIBVERSION contains the current version of the library.\n# For example, to build libfoo.so.1.2, you need to do the following:\n#LIBVERSION=1.2\nLIBVERSION=\n\n# LIBCOMPATVERSIONS contains the compatibility versions (a list) of\n# the library.  They MUST be in decreasing order.\n# For example, if libfoo.so.1.2.1 is backward compatible with libfoo.so.1.2\n# and libfoo.so.1, you need to do the following:\n#LIBCOMPATVERSIONS=1.2 1\n# Note that on systems that use sonames, the last number will appear as\n# part of it.\n# It's also possible, for systems that support it (Tru64, for example),\n# to add extra compatibility info with more precision, by adding a second\n# list of versions, separated from the first with a semicolon, like this:\n#LIBCOMPATVERSIONS=1.2 1;1.2.0 1.1.2 1.1.1 1.1.0 1.0.0\nLIBCOMPATVERSIONS=\n\n# LIBDEPS contains all the flags necessary to cover all necessary\n# dependencies to other libraries.\nLIBDEPS=\n\n#------------------------------------------------------------------------------\n# The rest is private to this makefile.\n\nSET_X=:\n#SET_X=set -x\n\ntop:\n\techo \"Trying to use this makefile interactively?  Don't.\"\n\nCALC_VERSIONS=\t\\\n\tSHLIB_COMPAT=; SHLIB_SOVER=; \\\n\tif [ -n \"$(LIBVERSION)$(LIBCOMPATVERSIONS)\" ]; then \\\n\t\tprev=\"\"; \\\n\t\tfor v in `echo \"$(LIBVERSION) $(LIBCOMPATVERSIONS)\" | cut -d';' -f1`; do \\\n\t\t\tSHLIB_SOVER_NODOT=$$v; \\\n\t\t\tSHLIB_SOVER=.$$v; \\\n\t\t\tif [ -n \"$$prev\" ]; then \\\n\t\t\t\tSHLIB_COMPAT=\"$$SHLIB_COMPAT .$$prev\"; \\\n\t\t\tfi; \\\n\t\t\tprev=$$v; \\\n\t\tdone; \\\n\tfi\n\nLINK_APP=\t\\\n  ( $(SET_X);   \\\n    LIBDEPS=\"$${LIBDEPS:-$(LIBDEPS)}\"; \\\n    LDCMD=\"$${LDCMD:-$(CC)}\"; LDFLAGS=\"$${LDFLAGS:-$(CFLAGS) $(LDFLAGS)}\"; \\\n    LIBPATH=`for x in $$LIBDEPS; do echo $$x; done | sed -e 's/^ *-L//;t' -e d | uniq`; \\\n    LIBPATH=`echo $$LIBPATH | sed -e 's/ /:/g'`; \\\n    echo LD_LIBRARY_PATH=$$LIBPATH:$$LD_LIBRARY_PATH \\\n        $${LDCMD} $${LDFLAGS} -o $${APPNAME:=$(APPNAME)} $(OBJECTS) $${LIBDEPS}; \\\n    LD_LIBRARY_PATH=$$LIBPATH:$$LD_LIBRARY_PATH \\\n    $${LDCMD} $${LDFLAGS} -o $${APPNAME:=$(APPNAME)} $(OBJECTS) $${LIBDEPS} )\n\nLINK_SO=\t\\\n  ( $(SET_X);   \\\n    LIBDEPS=\"$${LIBDEPS:-$(LIBDEPS)}\"; \\\n    SHAREDCMD=\"$${SHAREDCMD:-$(CC)}\"; \\\n    SHAREDFLAGS=\"$${SHAREDFLAGS:-$(CFLAGS) $(SHARED_LDFLAGS)}\"; \\\n    LIBPATH=`for x in $$LIBDEPS; do echo $$x; done | sed -e 's/^ *-L//;t' -e d | uniq`; \\\n    LIBPATH=`echo $$LIBPATH | sed -e 's/ /:/g'`; \\\n    echo LD_LIBRARY_PATH=$$LIBPATH:$$LD_LIBRARY_PATH \\\n         $${SHAREDCMD} $${SHAREDFLAGS} \\\n\t     -o $(DSTDIR)/$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX \\\n\t     $$ALLSYMSFLAGS $$SHOBJECTS $$NOALLSYMSFLAGS $$LIBDEPS; \\\n    LD_LIBRARY_PATH=$$LIBPATH:$$LD_LIBRARY_PATH \\\n    $${SHAREDCMD} $${SHAREDFLAGS} \\\n\t-o $(DSTDIR)/$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX \\\n\t$$ALLSYMSFLAGS $$SHOBJECTS $$NOALLSYMSFLAGS $$LIBDEPS \\\n  ) && $(SYMLINK_SO)\n\nSYMLINK_SO=\t\\\n\tif [ -n \"$$INHIBIT_SYMLINKS\" ]; then :; else \\\n\t\tprev=$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX; \\\n\t\tif [ -n \"$$SHLIB_COMPAT\" ]; then \\\n\t\t\tfor x in $$SHLIB_COMPAT; do \\\n\t\t\t\t( $(SET_X); rm -f $(DSTDIR)/$$SHLIB$$x$$SHLIB_SUFFIX; \\\n\t\t\t\t  ln -s $$prev $(DSTDIR)/$$SHLIB$$x$$SHLIB_SUFFIX ); \\\n\t\t\t\tprev=$$SHLIB$$x$$SHLIB_SUFFIX; \\\n\t\t\tdone; \\\n\t\tfi; \\\n\t\tif [ -n \"$$SHLIB_SOVER\" ]; then \\\n\t\t\t( $(SET_X); rm -f $(DSTDIR)/$$SHLIB$$SHLIB_SUFFIX; \\\n\t\t\t  ln -s $$prev $(DSTDIR)/$$SHLIB$$SHLIB_SUFFIX ); \\\n\t\tfi; \\\n\tfi\n\nLINK_SO_SHLIB=\tSHOBJECTS=\"$(DSTDIR)/lib$(LIBNAME).a $(LIBEXTRAS)\"; $(LINK_SO)\nLINK_SO_DSO=\tINHIBIT_SYMLINKS=yes; SHOBJECTS=\"$(LIBEXTRAS)\"; $(LINK_SO)\n\nLINK_SO_SHLIB_VIA_O=\t\\\n  SHOBJECTS=$(DSTDIR)/lib$(LIBNAME).o; \\\n  ALL=$$ALLSYMSFLAGS; ALLSYMSFLAGS=; NOALLSYMSFLAGS=; \\\n  ( echo ld $(LDFLAGS) -r -o $$SHOBJECTS $$ALL lib$(LIBNAME).a $(LIBEXTRAS); \\\n    ld $(LDFLAGS) -r -o $$SHOBJECTS $$ALL $(DSTDIR)/lib$(LIBNAME).a $(LIBEXTRAS) ); \\\n  $(LINK_SO) && ( echo rm -f $$SHOBJECTS; rm -f $$SHOBJECTS )\n\nLINK_SO_SHLIB_UNPACKED=\t\\\n  UNPACKDIR=link_tmp.$$$$; rm -rf $$UNPACKDIR; mkdir $$UNPACKDIR; \\\n  (cd $$UNPACKDIR; ar x ../$(DSTDIR)/lib$(LIBNAME).a) && \\\n  ([ -z \"$(LIBEXTRAS)\" ] || cp $(LIBEXTRAS) $$UNPACKDIR) && \\\n  SHOBJECTS=$$UNPACKDIR/*.o; \\\n  $(LINK_SO) && rm -rf $$UNPACKDIR\n\nDETECT_GNU_LD=($(CC) -Wl,-V /dev/null 2>&1 | grep '^GNU ld' )>/dev/null\n\nDO_GNU_SO_COMMON=\\\n\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-Bsymbolic -Wl,-soname=$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX\"\nDO_GNU_DSO=\\\n\tSHLIB=$(LIBNAME).so; \\\n\tSHLIB_SOVER=; \\\n\tSHLIB_SUFFIX=; \\\n\t$(DO_GNU_SO_COMMON)\nDO_GNU_SO=\\\n\t$(CALC_VERSIONS); \\\n\tSHLIB=lib$(LIBNAME).so; \\\n\tALLSYMSFLAGS='-Wl,--whole-archive'; \\\n\tNOALLSYMSFLAGS='-Wl,--no-whole-archive'; \\\n\t$(DO_GNU_SO_COMMON)\nDO_GNU_APP=LDFLAGS=\"$(CFLAGS) $(LDFLAGS)\"\n\n#This is rather special.  It's a special target with which one can link\n#applications without bothering with any features that have anything to\n#do with shared libraries, for example when linking against static\n#libraries.  It's mostly here to avoid a lot of conditionals everywhere\n#else...\nlink_app.:\n\t$(LINK_APP)\n\nlink_dso.gnu:\n\t@ $(DO_GNU_DSO); $(LINK_SO_DSO)\nlink_shlib.gnu:\n\t@ $(DO_GNU_SO); $(LINK_SO_SHLIB)\nlink_app.gnu:\n\t@ $(DO_GNU_APP); $(LINK_APP)\n\nlink_shlib.linux-shared:\n\t@$(PERL) $(SRCDIR)/util/mkdef.pl $(LIBNAME) linux >$(LIBNAME).map; \\\n\t$(DO_GNU_SO); \\\n\tALLSYMSFLAGS='-Wl,--whole-archive,--version-script=$(LIBNAME).map'; \\\n\t$(LINK_SO_SHLIB)\n\nlink_dso.bsd:\n\t@if $(DETECT_GNU_LD); then $(DO_GNU_DSO); else \\\n\tSHLIB=$(LIBNAME).so; \\\n\tSHLIB_SUFFIX=; \\\n\tLIBDEPS=\" \"; \\\n\tALLSYMSFLAGS=; \\\n\tNOALLSYMSFLAGS=; \\\n\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib\"; \\\n\tfi; $(LINK_SO_DSO)\nlink_shlib.bsd:\n\t@if $(DETECT_GNU_LD); then $(DO_GNU_SO); else \\\n\t$(CALC_VERSIONS); \\\n\tSHLIB=lib$(LIBNAME).so; \\\n\tSHLIB_SUFFIX=; \\\n\tLIBDEPS=\" \"; \\\n\tALLSYMSFLAGS=\"-Wl,-Bforcearchive\"; \\\n\tNOALLSYMSFLAGS=; \\\n\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib\"; \\\n\tfi; $(LINK_SO_SHLIB)\nlink_app.bsd:\n\t@if $(DETECT_GNU_LD); then $(DO_GNU_APP); else \\\n\tLDFLAGS=\"$(CFLAGS) $(LDFLAGS)\"; \\\n\tfi; $(LINK_APP)\n\n# For Darwin AKA Mac OS/X (dyld)\n# Originally link_dso.darwin produced .so, because it was hard-coded\n# in dso_dlfcn module. At later point dso_dlfcn switched to .dylib\n# extension in order to allow for run-time linking with vendor-\n# supplied shared libraries such as libz, so that link_dso.darwin had\n# to be harmonized with it. This caused minor controversy, because\n# it was believed that dlopen can't be used to dynamically load\n# .dylib-s, only so called bundle modules (ones linked with -bundle\n# flag). The belief seems to be originating from pre-10.4 release,\n# where dlfcn functionality was emulated by dlcompat add-on. In\n# 10.4 dlopen was rewritten as native part of dyld and is documented\n# to be capable of loading both dynamic libraries and bundles. In\n# order to provide compatibility with pre-10.4 dlopen, modules are\n# linked with -bundle flag, which makes .dylib extension misleading.\n# It works, because dlopen is [and always was] extension-agnostic.\n# Alternative to this heuristic approach is to develop specific\n# MacOS X dso module relying on whichever \"native\" dyld interface.\nlink_dso.darwin:\n\t@ SHLIB=$(LIBNAME); \\\n\tSHLIB_SUFFIX=.dylib; \\\n\tALLSYMSFLAGS=''; \\\n\tNOALLSYMSFLAGS=''; \\\n\tSHAREDFLAGS=\"$(CFLAGS) `echo $(SHARED_LDFLAGS) | sed s/dynamiclib/bundle/`\"; \\\n\t$(LINK_SO_DSO)\nlink_shlib.darwin:\n\t@ $(CALC_VERSIONS); \\\n\tSHLIB=lib$(LIBNAME); \\\n\tSHLIB_SUFFIX=.dylib; \\\n\tALLSYMSFLAGS='-all_load'; \\\n\tNOALLSYMSFLAGS=''; \\\n\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS)\"; \\\n\tif [ -n \"$(LIBVERSION)\" ]; then \\\n\t\tSHAREDFLAGS=\"$$SHAREDFLAGS -current_version $(LIBVERSION)\"; \\\n\tfi; \\\n\tif [ -n \"$$SHLIB_SOVER_NODOT\" ]; then \\\n\t\tSHAREDFLAGS=\"$$SHAREDFLAGS -compatibility_version $$SHLIB_SOVER_NODOT\"; \\\n\tfi; \\\n\tSHAREDFLAGS=\"$$SHAREDFLAGS -install_name $(INSTALLTOP)/$(LIBDIR)/$$SHLIB$(SHLIB_EXT)\"; \\\n\t$(LINK_SO_SHLIB)\nlink_app.darwin:\t# is there run-path on darwin?\n\t$(LINK_APP)\n\nlink_dso.cygwin:\n\t@SHLIB=$(LIBNAME); \\\n\tSHLIB_SUFFIX=.dll; \\\n\tALLSYMSFLAGS=''; \\\n\tNOALLSYMSFLAGS=''; \\\n\tbase=-Wl,--enable-auto-image-base; \\\n\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared $$base -Wl,-Bsymbolic\"; \\\n\t$(LINK_SO_DSO)\nlink_shlib.cygwin:\n\t@ $(CALC_VERSIONS); \\\n\tINHIBIT_SYMLINKS=yes; \\\n\tSHLIB=cyg$(LIBNAME); SHLIB_SOVER=-$(LIBVERSION); SHLIB_SUFFIX=.dll; \\\n\tdll_name=$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX; \\\n\techo \"$(PERL) $(SRCDIR)/util/mkrc.pl $$dll_name |\" \\\n\t\t     \"$(RC) $(SHARED_RCFLAGS) -o rc.o\"; \\\n\t$(PERL) $(SRCDIR)/util/mkrc.pl $$dll_name | \\\n\t\t$(RC) $(SHARED_RCFLAGS) -o rc.o; \\\n\tALLSYMSFLAGS='-Wl,--whole-archive'; \\\n\tNOALLSYMSFLAGS='-Wl,--no-whole-archive'; \\\n\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,--enable-auto-image-base -Wl,-Bsymbolic -Wl,--out-implib,lib$(LIBNAME).dll.a rc.o\"; \\\n\t$(LINK_SO_SHLIB) || exit 1; \\\n\trm rc.o\nlink_app.cygwin:\n\t$(LINK_APP)\n\n# link_dso.mingw-shared and link_app.mingw-shared are mapped to the\n# corresponding cygwin targets, as they do the exact same thing.\nlink_shlib.mingw:\n\t@ $(CALC_VERSIONS); \\\n\tINHIBIT_SYMLINKS=yes; \\\n\tarch=; \\\n\tif expr $(PLATFORM) : mingw64 > /dev/null; then arch=-x64; fi; \\\n\tsover=`echo $(LIBVERSION) | sed -e 's/\\./_/g'` ; \\\n\tSHLIB=lib$(LIBNAME); \\\n\tSHLIB_SOVER=-$$sover$$arch; \\\n\tSHLIB_SUFFIX=.dll; \\\n\tdll_name=$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX; \\\n\tbase=; [ $(LIBNAME) = \"crypto\" -a -n \"$(FIPSCANLIB)\" ] && base=-Wl,--image-base,0x63000000; \\\n\t$(PERL) $(SRCDIR)/util/mkdef.pl 32 $(LIBNAME) \\\n\t\t| sed -e 's|^\\(LIBRARY  *\\)$(LIBNAME)32|\\1'\"$$dll_name\"'|' \\\n\t\t> $(LIBNAME).def; \\\n\techo \"$(PERL) $(SRCDIR)/util/mkrc.pl $$dll_name |\" \\\n\t\t\"$(RC) $(SHARED_RCFLAGS) -o rc.o\"; \\\n\t$(PERL) $(SRCDIR)/util/mkrc.pl $$dll_name | \\\n\t\t$(RC) $(SHARED_RCFLAGS) -o rc.o; \\\n\tALLSYMSFLAGS='-Wl,--whole-archive'; \\\n\tNOALLSYMSFLAGS='-Wl,--no-whole-archive'; \\\n\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared $$base -Wl,-Bsymbolic -Wl,--out-implib,lib$(LIBNAME).dll.a $(LIBNAME).def rc.o\"; \\\n\t$(LINK_SO_SHLIB) || exit 1; \\\n\trm $(LIBNAME).def rc.o\n\nlink_dso.alpha-osf1:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_DSO); \\\n\telse \\\n\t\tSHLIB=$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=; \\\n\t\tALLSYMSFLAGS=''; \\\n\t\tNOALLSYMSFLAGS=''; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic\"; \\\n\tfi; \\\n\t$(LINK_SO_DSO)\nlink_shlib.alpha-osf1:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_SO); \\\n\telse \\\n\t\tSHLIB=lib$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=; \\\n\t\tSHLIB_HIST=`echo \"$(LIBCOMPATVERSIONS)\" | cut -d';' -f2 | sed -e 's/ */:/'`; \\\n\t\tif [ -n \"$$SHLIB_HIST\" ]; then \\\n\t\t\tSHLIB_HIST=\"$${SHLIB_HIST}:$(LIBVERSION)\"; \\\n\t\telse \\\n\t\t\tSHLIB_HIST=\"$(LIBVERSION)\"; \\\n\t\tfi; \\\n\t\tSHLIB_SOVER=; \\\n\t\tALLSYMSFLAGS='-all'; \\\n\t\tNOALLSYMSFLAGS='-none'; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic\"; \\\n\t\tif [ -n \"$$SHLIB_HIST\" ]; then \\\n\t\t\tSHAREDFLAGS=\"$$SHAREDFLAGS -set_version $$SHLIB_HIST\"; \\\n\t\tfi; \\\n\tfi; \\\n\t$(LINK_SO_SHLIB)\nlink_app.alpha-osf1:\n\t@if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_APP); \\\n\telse \\\n\t\tLDFLAGS=\"$(CFLAGS) $(LDFLAGS)\"; \\\n\tfi; \\\n\t$(LINK_APP)\n\nlink_dso.solaris:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_DSO); \\\n\telse \\\n\t\t$(CALC_VERSIONS); \\\n\t\tSHLIB=$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=; \\\n\t\tALLSYMSFLAGS=\"\"; \\\n\t\tNOALLSYMSFLAGS=\"\"; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -h $$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX -Wl,-Bsymbolic\"; \\\n\tfi; \\\n\t$(LINK_SO_DSO)\nlink_shlib.solaris:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_SO); \\\n\telse \\\n\t\t$(CALC_VERSIONS); \\\n\t\tSHLIB=lib$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=;\\\n\t\t$(PERL) $(SRCDIR)/util/mkdef.pl $(LIBNAME) linux >$(LIBNAME).map; \\\n\t\tALLSYMSFLAGS=\"-Wl,-z,allextract,-M,$(LIBNAME).map\"; \\\n\t\tNOALLSYMSFLAGS=\"-Wl,-z,defaultextract\"; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -h $$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX -Wl,-Bsymbolic\"; \\\n\tfi; \\\n\t$(LINK_SO_SHLIB)\nlink_app.solaris:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_APP); \\\n\telse \\\n\t\tLDFLAGS=\"$(CFLAGS) $(LDFLAGS)\"; \\\n\tfi; \\\n\t$(LINK_APP)\n\n# OpenServer 5 native compilers used\nlink_dso.svr3:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_DSO); \\\n\telse \\\n\t\t$(CALC_VERSIONS); \\\n\t\tSHLIB=$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=; \\\n\t\tALLSYMSFLAGS=''; \\\n\t\tNOALLSYMSFLAGS=''; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) -G -h $$SHLIB$$SHLIB_SUFFIX\"; \\\n\tfi; \\\n\t$(LINK_SO_DSO)\nlink_shlib.svr3:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_SO); \\\n\telse \\\n\t\t$(CALC_VERSIONS); \\\n\t\tSHLIB=lib$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=; \\\n\t\tALLSYMSFLAGS=''; \\\n\t\tNOALLSYMSFLAGS=''; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) -G -h $$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX\"; \\\n\tfi; \\\n\t$(LINK_SO_SHLIB_UNPACKED)\nlink_app.svr3:\n\t@$(DETECT_GNU_LD) && $(DO_GNU_APP); \\\n\t$(LINK_APP)\n\n# UnixWare 7 and OpenUNIX 8 native compilers used\nlink_dso.svr5:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_DSO); \\\n\telse \\\n\t\tSHARE_FLAG='-G'; \\\n\t\t($(CC) -v 2>&1 | grep gcc) > /dev/null && SHARE_FLAG='-shared'; \\\n\t\tSHLIB=$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=; \\\n\t\tALLSYMSFLAGS=''; \\\n\t\tNOALLSYMSFLAGS=''; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) $${SHARE_FLAG} -h $$SHLIB$$SHLIB_SUFFIX\"; \\\n\tfi; \\\n\t$(LINK_SO_DSO)\nlink_shlib.svr5:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_SO); \\\n\telse \\\n\t\t$(CALC_VERSIONS); \\\n\t\tSHARE_FLAG='-G'; \\\n\t\t($(CC) -v 2>&1 | grep gcc) > /dev/null && SHARE_FLAG='-shared'; \\\n\t\tSHLIB=lib$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=; \\\n\t\tALLSYMSFLAGS=''; \\\n\t\tNOALLSYMSFLAGS=''; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) $${SHARE_FLAG} -h $$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX\"; \\\n\tfi; \\\n\t$(LINK_SO_SHLIB_UNPACKED)\nlink_app.svr5:\n\t@$(DETECT_GNU_LD) && $(DO_GNU_APP); \\\n\t$(LINK_APP)\n\nlink_dso.irix:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_DSO); \\\n\telse \\\n\t\tSHLIB=$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=; \\\n\t\tALLSYMSFLAGS=\"\"; \\\n\t\tNOALLSYMSFLAGS=\"\"; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$$SHLIB$$SHLIB_SUFFIX,-B,symbolic\"; \\\n\tfi; \\\n\t$(LINK_SO_DSO)\nlink_shlib.irix:\n\t@ if $(DETECT_GNU_LD); then \\\n\t\t$(DO_GNU_SO); \\\n\telse \\\n\t\t$(CALC_VERSIONS); \\\n\t\tSHLIB=lib$(LIBNAME).so; \\\n\t\tSHLIB_SUFFIX=; \\\n\t\tMINUSWL=\"\"; \\\n\t\t($(CC) -v 2>&1 | grep gcc) > /dev/null && MINUSWL=\"-Wl,\"; \\\n\t\tALLSYMSFLAGS=\"$${MINUSWL}-all\"; \\\n\t\tNOALLSYMSFLAGS=\"$${MINUSWL}-none\"; \\\n\t\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX,-B,symbolic\"; \\\n\tfi; \\\n\t$(LINK_SO_SHLIB)\nlink_app.irix:\n\t@LDFLAGS=\"$(CFLAGS) $(LDFLAGS)\"; \\\n\t$(LINK_APP)\n\n# 32-bit PA-RISC HP-UX embeds the -L pathname of libs we link with, so\n# we compensate for it with +cdp ../: and +cdp ./:. Yes, these rewrite\n# rules imply that we can only link one level down in catalog structure,\n# but that's what takes place for the moment of this writing. +cdp option\n# was introduced in HP-UX 11.x and applies in 32-bit PA-RISC link\n# editor context only [it's simply ignored in other cases, which are all\n# ELFs by the way].\n#\nlink_dso.hpux:\n\t@if $(DETECT_GNU_LD); then $(DO_GNU_DSO); else \\\n\tSHLIB=$(LIBNAME).sl; \\\n\texpr \"$(CFLAGS)\" : '.*DSO_DLFCN' > /dev/null && SHLIB=$(LIBNAME).so; \\\n\tSHLIB_SUFFIX=; \\\n\tALLSYMSFLAGS=''; \\\n\tNOALLSYMSFLAGS=''; \\\n\texpr $(PLATFORM) : 'hpux64' > /dev/null && ALLSYMSFLAGS='-Wl,+forceload'; \\\n\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$$SHLIB$$SHLIB_SUFFIX,+cdp,../:,+cdp,./:\"; \\\n\tfi; \\\n\trm -f $(DSTDIR)/$$SHLIB$$SHLIB_SUFFIX || :; \\\n\t$(LINK_SO_DSO) && chmod a=rx $(DSTDIR)/$$SHLIB$$SHLIB_SUFFIX\nlink_shlib.hpux:\n\t@if $(DETECT_GNU_LD); then $(DO_GNU_SO); else \\\n\t$(CALC_VERSIONS); \\\n\tSHLIB=lib$(LIBNAME).sl; \\\n\texpr $(PLATFORM) : '.*ia64' > /dev/null && SHLIB=lib$(LIBNAME).so; \\\n\tSHLIB_SUFFIX=; \\\n\tALLSYMSFLAGS='-Wl,-Fl'; \\\n\tNOALLSYMSFLAGS=''; \\\n\texpr $(PLATFORM) : 'hpux64' > /dev/null && ALLSYMSFLAGS='-Wl,+forceload'; \\\n\tSHAREDFLAGS=\"$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX,+cdp,../:,+cdp,./:\"; \\\n\tfi; \\\n\trm -f $(DSTDIR)/$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX || :; \\\n\t$(LINK_SO_SHLIB) && chmod a=rx $(DSTDIR)/$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX\nlink_app.hpux:\n\t@if $(DETECT_GNU_LD); then $(DO_GNU_APP); else \\\n\tLDFLAGS=\"$(CFLAGS) $(LDFLAGS) -Wl,+s,+cdp,../:,+cdp,./:\"; \\\n\tfi; \\\n\t$(LINK_APP)\n\nlink_dso.aix:\n\t@OBJECT_MODE=`expr \"x$(SHARED_LDFLAGS)\" : 'x\\-[a-z]*\\(64\\)'` || :; \\\n\tOBJECT_MODE=$${OBJECT_MODE:-32}; export OBJECT_MODE; \\\n\tSHLIB=$(LIBNAME).so; \\\n\tSHLIB_SUFFIX=; \\\n\tALLSYMSFLAGS=''; \\\n\tNOALLSYMSFLAGS=''; \\\n\tSHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-bexpall,-bnolibpath,-bM:SRE'; \\\n\trm -f $(DSTDIR)/$$SHLIB$$SHLIB_SOVER 2>&1 > /dev/null ; \\\n\t$(LINK_SO_DSO);\nlink_shlib.aix:\n\t@ $(CALC_VERSIONS); \\\n\tOBJECT_MODE=`expr \"x$(SHARED_LDFLAGS)\" : 'x\\-[a-z]*\\(64\\)'` || : ; \\\n\tOBJECT_MODE=$${OBJECT_MODE:-32}; export OBJECT_MODE; \\\n\tSHLIB=lib$(LIBNAME).so; \\\n\tSHLIB_SUFFIX=; \\\n\tALLSYMSFLAGS='-bnogc'; \\\n\tNOALLSYMSFLAGS=''; \\\n\tSHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-bexpall,-bnolibpath,-bM:SRE'; \\\n\trm -f $(DSTDIR)/$$SHLIB$$SHLIB_SOVER 2>&1 > /dev/null ; \\\n\t$(LINK_SO_SHLIB_VIA_O)\nlink_app.aix:\n\tLDFLAGS=\"$(CFLAGS) -Wl,-bsvr4 $(LDFLAGS)\"; \\\n\t$(LINK_APP)\n\n\n# Targets to build symbolic links when needed\nsymlink.gnu symlink.solaris symlink.svr3 symlink.svr5 symlink.irix \\\nsymlink.aix:\n\t@ $(CALC_VERSIONS); \\\n\tSHLIB=lib$(LIBNAME).so; \\\n\t$(SYMLINK_SO)\nsymlink.darwin:\n\t@ $(CALC_VERSIONS); \\\n\tSHLIB=lib$(LIBNAME); \\\n\tSHLIB_SUFFIX=.dylib; \\\n\t$(SYMLINK_SO)\nsymlink.hpux:\n\t@ $(CALC_VERSIONS); \\\n\tSHLIB=lib$(LIBNAME).sl; \\\n\texpr $(PLATFORM) : '.*ia64' > /dev/null && SHLIB=lib$(LIBNAME).so; \\\n\t$(SYMLINK_SO)\n# The following lines means those specific architectures do no symlinks\nsymlink.cygwin symlink.alpha-osf1 symlink.tru64 symlink.tru64-rpath:\n\n# Compatibility targets\nlink_dso.bsd-gcc-shared link_dso.linux-shared link_dso.gnu-shared: link_dso.gnu\nlink_shlib.bsd-gcc-shared: link_shlib.linux-shared\nlink_shlib.gnu-shared: link_shlib.gnu\nlink_app.bsd-gcc-shared link_app.linux-shared link_app.gnu-shared: link_app.gnu\nsymlink.bsd-gcc-shared symlink.bsd-shared symlink.linux-shared symlink.gnu-shared: symlink.gnu\nlink_dso.bsd-shared: link_dso.bsd\nlink_shlib.bsd-shared: link_shlib.bsd\nlink_app.bsd-shared: link_app.bsd\nlink_dso.darwin-shared: link_dso.darwin\nlink_shlib.darwin-shared: link_shlib.darwin\nlink_app.darwin-shared: link_app.darwin\nsymlink.darwin-shared: symlink.darwin\nlink_dso.cygwin-shared: link_dso.cygwin\nlink_shlib.cygwin-shared: link_shlib.cygwin\nlink_app.cygwin-shared: link_app.cygwin\nsymlink.cygwin-shared: symlink.cygwin\nlink_dso.mingw-shared: link_dso.cygwin\nlink_shlib.mingw-shared: link_shlib.mingw\nlink_app.mingw-shared: link_app.cygwin\nsymlink.mingw-shared: symlink.cygwin\nlink_dso.alpha-osf1-shared: link_dso.alpha-osf1\nlink_shlib.alpha-osf1-shared: link_shlib.alpha-osf1\nlink_app.alpha-osf1-shared: link_app.alpha-osf1\nsymlink.alpha-osf1-shared: symlink.alpha-osf1\nlink_dso.tru64-shared: link_dso.tru64\nlink_shlib.tru64-shared: link_shlib.tru64\nlink_app.tru64-shared: link_app.tru64\nsymlink.tru64-shared: symlink.tru64\nlink_dso.tru64-shared-rpath: link_dso.tru64-rpath\nlink_shlib.tru64-shared-rpath: link_shlib.tru64-rpath\nlink_app.tru64-shared-rpath: link_app.tru64-rpath\nsymlink.tru64-shared-rpath: symlink.tru64-rpath\nlink_dso.solaris-shared: link_dso.solaris\nlink_shlib.solaris-shared: link_shlib.solaris\nlink_app.solaris-shared: link_app.solaris\nsymlink.solaris-shared: symlink.solaris\nlink_dso.svr3-shared: link_dso.svr3\nlink_shlib.svr3-shared: link_shlib.svr3\nlink_app.svr3-shared: link_app.svr3\nsymlink.svr3-shared: symlink.svr3\nlink_dso.svr5-shared: link_dso.svr5\nlink_shlib.svr5-shared: link_shlib.svr5\nlink_app.svr5-shared: link_app.svr5\nsymlink.svr5-shared: symlink.svr5\nlink_dso.irix-shared: link_dso.irix\nlink_shlib.irix-shared: link_shlib.irix\nlink_app.irix-shared: link_app.irix\nsymlink.irix-shared: symlink.irix\nlink_dso.hpux-shared: link_dso.hpux\nlink_shlib.hpux-shared: link_shlib.hpux\nlink_app.hpux-shared: link_app.hpux\nsymlink.hpux-shared: symlink.hpux\nlink_dso.aix-shared: link_dso.aix\nlink_shlib.aix-shared: link_shlib.aix\nlink_app.aix-shared: link_app.aix\nsymlink.aix-shared: symlink.aix\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/crypto/dso/dso_locl.h": "/*\n * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include \"internal/cryptlib.h\"\n#include \"internal/dso.h\"\n#include \"internal/dso_conf.h\"\n\n/**********************************************************************/\n/* The low-level handle type used to refer to a loaded shared library */\n\nstruct dso_st {\n    DSO_METHOD *meth;\n    /*\n     * Standard dlopen uses a (void *). Win32 uses a HANDLE. VMS doesn't use\n     * anything but will need to cache the filename for use in the dso_bind\n     * handler. All in all, let each method control its own destiny.\n     * \"Handles\" and such go in a STACK.\n     */\n    STACK_OF(void) *meth_data;\n    int references;\n    int flags;\n    /*\n     * For use by applications etc ... use this for your bits'n'pieces, don't\n     * touch meth_data!\n     */\n    CRYPTO_EX_DATA ex_data;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_name_converter. NB: This\n     * should normally set using DSO_set_name_converter().\n     */\n    DSO_NAME_CONVERTER_FUNC name_converter;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_merger. NB: This should\n     * normally set using DSO_set_merger().\n     */\n    DSO_MERGER_FUNC merger;\n    /*\n     * This is populated with (a copy of) the platform-independent filename\n     * used for this DSO.\n     */\n    char *filename;\n    /*\n     * This is populated with (a copy of) the translated filename by which\n     * the DSO was actually loaded. It is NULL iff the DSO is not currently\n     * loaded. NB: This is here because the filename translation process may\n     * involve a callback being invoked more than once not only to convert to\n     * a platform-specific form, but also to try different filenames in the\n     * process of trying to perform a load. As such, this variable can be\n     * used to indicate (a) whether this DSO structure corresponds to a\n     * loaded library or not, and (b) the filename with which it was actually\n     * loaded.\n     */\n    char *loaded_filename;\n    CRYPTO_RWLOCK *lock;\n};\n\nstruct dso_meth_st {\n    const char *name;\n    /*\n     * Loads a shared library, NB: new DSO_METHODs must ensure that a\n     * successful load populates the loaded_filename field, and likewise a\n     * successful unload OPENSSL_frees and NULLs it out.\n     */\n    int (*dso_load) (DSO *dso);\n    /* Unloads a shared library */\n    int (*dso_unload) (DSO *dso);\n    /*\n     * Binds a function - assumes a return type of DSO_FUNC_TYPE. This should\n     * be cast to the real function prototype by the caller. Platforms that\n     * don't have compatible representations for different prototypes (this\n     * is possible within ANSI C) are highly unlikely to have shared\n     * libraries at all, let alone a DSO_METHOD implemented for them.\n     */\n    DSO_FUNC_TYPE (*dso_bind_func) (DSO *dso, const char *symname);\n    /*\n     * The generic (yuck) \"ctrl()\" function. NB: Negative return values\n     * (rather than zero) indicate errors.\n     */\n    long (*dso_ctrl) (DSO *dso, int cmd, long larg, void *parg);\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_NAME_CONVERTER_FUNC dso_name_converter;\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_MERGER_FUNC dso_merger;\n    /* [De]Initialisation handlers. */\n    int (*init) (DSO *dso);\n    int (*finish) (DSO *dso);\n    /* Return pathname of the module containing location */\n    int (*pathbyaddr) (void *addr, char *path, int sz);\n    /* Perform global symbol lookup, i.e. among *all* modules */\n    void *(*globallookup) (const char *symname);\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/crypto/dso/dso_dlfcn.c": "/*\n * Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n/*\n * We need to do this early, because stdio.h includes the header files that\n * handle _GNU_SOURCE and other similar macros.  Defining it later is simply\n * too late, because those headers are protected from re- inclusion.\n */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE            /* make sure dladdr is declared */\n#endif\n\n#include \"dso_locl.h\"\n\n#ifdef DSO_DLFCN\n\n# ifdef HAVE_DLFCN_H\n#  ifdef __osf__\n#   define __EXTENSIONS__\n#  endif\n#  include <dlfcn.h>\n#  define HAVE_DLINFO 1\n#  if defined(_AIX) || defined(__CYGWIN__) || \\\n     defined(__SCO_VERSION__) || defined(_SCO_ELF) || \\\n     (defined(__osf__) && !defined(RTLD_NEXT))     || \\\n     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \\\n        defined(__ANDROID__)\n#   undef HAVE_DLINFO\n#  endif\n# endif\n\n/* Part of the hack in \"dlfcn_load\" ... */\n# define DSO_MAX_TRANSLATED_SIZE 256\n\nstatic int dlfcn_load(DSO *dso);\nstatic int dlfcn_unload(DSO *dso);\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname);\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename);\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2);\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz);\nstatic void *dlfcn_globallookup(const char *name);\n\nstatic DSO_METHOD dso_meth_dlfcn = {\n    \"OpenSSL 'dlfcn' shared library method\",\n    dlfcn_load,\n    dlfcn_unload,\n    dlfcn_bind_func,\n    NULL,                       /* ctrl */\n    dlfcn_name_converter,\n    dlfcn_merger,\n    NULL,                       /* init */\n    NULL,                       /* finish */\n    dlfcn_pathbyaddr,\n    dlfcn_globallookup\n};\n\nDSO_METHOD *DSO_METHOD_openssl(void)\n{\n    return &dso_meth_dlfcn;\n}\n\n/*\n * Prior to using the dlopen() function, we should decide on the flag we\n * send. There's a few different ways of doing this and it's a messy\n * venn-diagram to match up which platforms support what. So as we don't have\n * autoconf yet, I'm implementing a hack that could be hacked further\n * relatively easily to deal with cases as we find them. Initially this is to\n * cope with OpenBSD.\n */\n# if defined(__OpenBSD__) || defined(__NetBSD__)\n#  ifdef DL_LAZY\n#   define DLOPEN_FLAG DL_LAZY\n#  else\n#   ifdef RTLD_NOW\n#    define DLOPEN_FLAG RTLD_NOW\n#   else\n#    define DLOPEN_FLAG 0\n#   endif\n#  endif\n# else\n#  define DLOPEN_FLAG RTLD_NOW  /* Hope this works everywhere else */\n# endif\n\n/*\n * For this DSO_METHOD, our meth_data STACK will contain; (i) the handle\n * (void*) returned from dlopen().\n */\n\nstatic int dlfcn_load(DSO *dso)\n{\n    void *ptr = NULL;\n    /* See applicable comments in dso_dl.c */\n    char *filename = DSO_convert_filename(dso, NULL);\n    int flags = DLOPEN_FLAG;\n\n    if (filename == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);\n        goto err;\n    }\n# ifdef RTLD_GLOBAL\n    if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\n        flags |= RTLD_GLOBAL;\n# endif\n    ptr = dlopen(filename, flags);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);\n        ERR_add_error_data(4, \"filename(\", filename, \"): \", dlerror());\n        goto err;\n    }\n    if (!sk_void_push(dso->meth_data, (char *)ptr)) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);\n        goto err;\n    }\n    /* Success */\n    dso->loaded_filename = filename;\n    return (1);\n err:\n    /* Cleanup! */\n    OPENSSL_free(filename);\n    if (ptr != NULL)\n        dlclose(ptr);\n    return (0);\n}\n\nstatic int dlfcn_unload(DSO *dso)\n{\n    void *ptr;\n    if (dso == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\n        return (0);\n    }\n    if (sk_void_num(dso->meth_data) < 1)\n        return (1);\n    ptr = sk_void_pop(dso->meth_data);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);\n        /*\n         * Should push the value back onto the stack in case of a retry.\n         */\n        sk_void_push(dso->meth_data, ptr);\n        return (0);\n    }\n    /* For now I'm not aware of any errors associated with dlclose() */\n    dlclose(ptr);\n    return (1);\n}\n\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)\n{\n    void *ptr;\n    union {\n        DSO_FUNC_TYPE sym;\n        void *dlret;\n    } u;\n\n    if ((dso == NULL) || (symname == NULL)) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    if (sk_void_num(dso->meth_data) < 1) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR);\n        return (NULL);\n    }\n    ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE);\n        return (NULL);\n    }\n    u.dlret = dlsym(ptr, symname);\n    if (u.dlret == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE);\n        ERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n        return (NULL);\n    }\n    return u.sym;\n}\n\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2)\n{\n    char *merged;\n\n    if (!filespec1 && !filespec2) {\n        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    /*\n     * If the first file specification is a rooted path, it rules. same goes\n     * if the second file specification is missing.\n     */\n    if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\n        merged = OPENSSL_strdup(filespec1);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n    }\n    /*\n     * If the first file specification is missing, the second one rules.\n     */\n    else if (!filespec1) {\n        merged = OPENSSL_strdup(filespec2);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n    } else {\n        /*\n         * This part isn't as trivial as it looks.  It assumes that the\n         * second file specification really is a directory, and makes no\n         * checks whatsoever.  Therefore, the result becomes the\n         * concatenation of filespec2 followed by a slash followed by\n         * filespec1.\n         */\n        int spec2len, len;\n\n        spec2len = strlen(filespec2);\n        len = spec2len + strlen(filespec1);\n\n        if (spec2len && filespec2[spec2len - 1] == '/') {\n            spec2len--;\n            len--;\n        }\n        merged = OPENSSL_malloc(len + 2);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n        strcpy(merged, filespec2);\n        merged[spec2len] = '/';\n        strcpy(&merged[spec2len + 1], filespec1);\n    }\n    return (merged);\n}\n\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename)\n{\n    char *translated;\n    int len, rsize, transform;\n\n    len = strlen(filename);\n    rsize = len + 1;\n    transform = (strstr(filename, \"/\") == NULL);\n    if (transform) {\n        /* We will convert this to \"%s.so\" or \"lib%s.so\" etc */\n        rsize += strlen(DSO_EXTENSION);    /* The length of \".so\" */\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            rsize += 3;         /* The length of \"lib\" */\n    }\n    translated = OPENSSL_malloc(rsize);\n    if (translated == NULL) {\n        DSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);\n        return (NULL);\n    }\n    if (transform) {\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            sprintf(translated, \"lib%s\" DSO_EXTENSION, filename);\n        else\n            sprintf(translated, \"%s\" DSO_EXTENSION, filename);\n    } else\n        sprintf(translated, \"%s\", filename);\n    return (translated);\n}\n\n# ifdef __sgi\n/*-\nThis is a quote from IRIX manual for dladdr(3c):\n\n     <dlfcn.h> does not contain a prototype for dladdr or definition of\n     Dl_info.  The #include <dlfcn.h>  in the SYNOPSIS line is traditional,\n     but contains no dladdr prototype and no IRIX library contains an\n     implementation.  Write your own declaration based on the code below.\n\n     The following code is dependent on internal interfaces that are not\n     part of the IRIX compatibility guarantee; however, there is no future\n     intention to change this interface, so on a practical level, the code\n     below is safe to use on IRIX.\n*/\n#  include <rld_interface.h>\n#  ifndef _RLD_INTERFACE_DLFCN_H_DLADDR\n#   define _RLD_INTERFACE_DLFCN_H_DLADDR\ntypedef struct Dl_info {\n    const char *dli_fname;\n    void *dli_fbase;\n    const char *dli_sname;\n    void *dli_saddr;\n    int dli_version;\n    int dli_reserved1;\n    long dli_reserved[4];\n} Dl_info;\n#  else\ntypedef struct Dl_info Dl_info;\n#  endif\n#  define _RLD_DLADDR             14\n\nstatic int dladdr(void *address, Dl_info *dl)\n{\n    void *v;\n    v = _rld_new_interface(_RLD_DLADDR, address, dl);\n    return (int)v;\n}\n# endif                         /* __sgi */\n\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz)\n{\n# ifdef HAVE_DLINFO\n    Dl_info dli;\n    int len;\n\n    if (addr == NULL) {\n        union {\n            int (*f) (void *, char *, int);\n            void *p;\n        } t = {\n            dlfcn_pathbyaddr\n        };\n        addr = t.p;\n    }\n\n    if (dladdr(addr, &dli)) {\n        len = (int)strlen(dli.dli_fname);\n        if (sz <= 0)\n            return len + 1;\n        if (len >= sz)\n            len = sz - 1;\n        memcpy(path, dli.dli_fname, len);\n        path[len++] = 0;\n        return len;\n    }\n\n    ERR_add_error_data(2, \"dlfcn_pathbyaddr(): \", dlerror());\n# endif\n    return -1;\n}\n\nstatic void *dlfcn_globallookup(const char *name)\n{\n    void *ret = NULL, *handle = dlopen(NULL, RTLD_LAZY);\n\n    if (handle) {\n        ret = dlsym(handle, name);\n        dlclose(handle);\n    }\n\n    return ret;\n}\n#endif                          /* DSO_DLFCN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/test/shlibloadtest.c": "/*\n * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <openssl/opensslv.h>\n\n/* The test is only currently implemented for DSO_DLFCN and DSO_WIN32 */\n#if defined(DSO_DLFCN) || defined(DSO_WIN32)\n\n#define SSL_CTX_NEW \"SSL_CTX_new\"\n#define SSL_CTX_FREE \"SSL_CTX_free\"\n#define TLS_METHOD \"TLS_method\"\n\n#define ERR_GET_ERROR \"ERR_get_error\"\n#define OPENSSL_VERSION_NUM_FUNC \"OpenSSL_version_num\"\n\ntypedef struct ssl_ctx_st SSL_CTX;\ntypedef struct ssl_method_st SSL_METHOD;\ntypedef const SSL_METHOD * (*TLS_method_t)(void);\ntypedef SSL_CTX * (*SSL_CTX_new_t)(const SSL_METHOD *meth);\ntypedef void (*SSL_CTX_free_t)(SSL_CTX *);\n\ntypedef unsigned long (*ERR_get_error_t)(void);\ntypedef unsigned long (*OpenSSL_version_num_t)(void);\n\nstatic TLS_method_t TLS_method;\nstatic SSL_CTX_new_t SSL_CTX_new;\nstatic SSL_CTX_free_t SSL_CTX_free;\n\nstatic ERR_get_error_t ERR_get_error;\nstatic OpenSSL_version_num_t OpenSSL_version_num;\n\n#ifdef DSO_DLFCN\n\n# include <dlfcn.h>\n\ntypedef void * SHLIB;\ntypedef void * SHLIB_SYM;\n# define SHLIB_INIT NULL\n\nstatic int shlib_load(const char *filename, SHLIB *lib)\n{\n    *lib = dlopen(filename, RTLD_GLOBAL | RTLD_LAZY);\n\n    if (*lib == NULL)\n        return 0;\n\n    return 1;\n}\n\nstatic int shlib_sym(SHLIB lib, const char *symname, SHLIB_SYM *sym)\n{\n    *sym = dlsym(lib, symname);\n\n    return *sym != NULL;\n}\n\nstatic int shlib_close(SHLIB lib)\n{\n    if (dlclose(lib) != 0)\n        return 0;\n\n    return 1;\n}\n\n#elif defined(DSO_WIN32)\n\n# include <windows.h>\n\ntypedef HINSTANCE SHLIB;\ntypedef void * SHLIB_SYM;\n# define SHLIB_INIT 0\n\nstatic int shlib_load(const char *filename, SHLIB *lib)\n{\n    *lib = LoadLibraryA(filename);\n    if (*lib == NULL)\n        return 0;\n\n    return 1;\n}\n\nstatic int shlib_sym(SHLIB lib, const char *symname, SHLIB_SYM *sym)\n{\n    *sym = (SHLIB_SYM)GetProcAddress(lib, symname);\n\n    return *sym != NULL;\n}\n\nstatic int shlib_close(SHLIB lib)\n{\n    if (FreeLibrary(lib) == 0)\n        return 0;\n\n    return 1;\n}\n\n#endif\n\n# define CRYPTO_FIRST_OPT    \"-crypto_first\"\n# define SSL_FIRST_OPT       \"-ssl_first\"\n# define JUST_CRYPTO_OPT     \"-just_crypto\"\n\nenum test_types_en {\n    CRYPTO_FIRST,\n    SSL_FIRST,\n    JUST_CRYPTO\n};\n\nint main(int argc, char **argv)\n{\n    SHLIB ssllib = SHLIB_INIT, cryptolib = SHLIB_INIT;\n    SSL_CTX *ctx;\n    union {\n        void (*func) (void);\n        SHLIB_SYM sym;\n    } tls_method_sym, ssl_ctx_new_sym, ssl_ctx_free_sym, err_get_error_sym,\n    openssl_version_num_sym;\n    enum test_types_en test_type;\n    int i;\n\n    if (argc != 4) {\n        printf(\"Unexpected number of arguments\\n\");\n        return 1;\n    }\n\n    if (strcmp(argv[1], CRYPTO_FIRST_OPT) == 0) {\n        test_type = CRYPTO_FIRST;\n    } else if (strcmp(argv[1], SSL_FIRST_OPT) == 0) {\n            test_type = SSL_FIRST;\n    } else if (strcmp(argv[1], JUST_CRYPTO_OPT) == 0) {\n            test_type = JUST_CRYPTO;\n    } else {\n        printf(\"Unrecognised argument\\n\");\n        return 1;\n    }\n\n    for (i = 0; i < 2; i++) {\n        if ((i == 0 && (test_type == CRYPTO_FIRST\n                       || test_type == JUST_CRYPTO))\n               || (i == 1 && test_type == SSL_FIRST)) {\n            if (!shlib_load(argv[2], &cryptolib)) {\n                printf(\"Unable to load libcrypto\\n\");\n                return 1;\n            }\n        }\n        if ((i == 0 && test_type == SSL_FIRST)\n                || (i == 1 && test_type == CRYPTO_FIRST)) {\n            if (!shlib_load(argv[3], &ssllib)) {\n                printf(\"Unable to load libssl\\n\");\n                return 1;\n            }\n        }\n    }\n\n    if (test_type != JUST_CRYPTO) {\n        if (!shlib_sym(ssllib, TLS_METHOD, &tls_method_sym.sym)\n                || !shlib_sym(ssllib, SSL_CTX_NEW, &ssl_ctx_new_sym.sym)\n                || !shlib_sym(ssllib, SSL_CTX_FREE, &ssl_ctx_free_sym.sym)) {\n            printf(\"Unable to load ssl symbols\\n\");\n            return 1;\n        }\n\n        TLS_method = (TLS_method_t)tls_method_sym.func;\n        SSL_CTX_new = (SSL_CTX_new_t)ssl_ctx_new_sym.func;\n        SSL_CTX_free = (SSL_CTX_free_t)ssl_ctx_free_sym.func;\n\n        ctx = SSL_CTX_new(TLS_method());\n        if (ctx == NULL) {\n            printf(\"Unable to create SSL_CTX\\n\");\n            return 1;\n        }\n        SSL_CTX_free(ctx);\n    }\n\n    if (!shlib_sym(cryptolib, ERR_GET_ERROR, &err_get_error_sym.sym)\n            || !shlib_sym(cryptolib, OPENSSL_VERSION_NUM_FUNC,\n                          &openssl_version_num_sym.sym)) {\n        printf(\"Unable to load crypto symbols\\n\");\n        return 1;\n    }\n\n    ERR_get_error = (ERR_get_error_t)err_get_error_sym.func;\n    OpenSSL_version_num = (OpenSSL_version_num_t)openssl_version_num_sym.func;\n\n    if (ERR_get_error() != 0) {\n        printf(\"Unexpected error in error queue\\n\");\n        return 1;\n    }\n\n    if (OpenSSL_version_num() != OPENSSL_VERSION_NUMBER) {\n        printf(\"Unexpected library version loaded\\n\");\n        return 1;\n    }\n\n    for (i = 0; i < 2; i++) {\n        if ((i == 0 && test_type == CRYPTO_FIRST)\n                || (i == 1 && test_type == SSL_FIRST)) {\n            if (!shlib_close(ssllib)) {\n                printf(\"Unable to close libssl\\n\");\n                return 1;\n            }\n        }\n        if ((i == 0 && (test_type == SSL_FIRST\n                       || test_type == JUST_CRYPTO))\n                || (i == 1 && test_type == CRYPTO_FIRST)) {\n            if (!shlib_close(cryptolib)) {\n                printf(\"Unable to close libcrypto\\n\");\n                return 1;\n            }\n        }\n    }\n\n    printf(\"Success\\n\");\n    return 0;\n}\n#else\nint main(void)\n{\n    printf(\"Test not implemented on this platform\\n\");\n    return 0;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/doc/crypto/OPENSSL_init_crypto.pod": "=pod\n\n=head1 NAME\n\nOPENSSL_init_new, OPENSSL_INIT_set_config_appname, OPENSSL_INIT_free,\nOPENSSL_init_crypto, OPENSSL_cleanup,\nOPENSSL_atexit, OPENSSL_thread_stop - OpenSSL\ninitialisation and deinitialisation functions\n\n=head1 SYNOPSIS\n\n #include <openssl/crypto.h>\n\n void OPENSSL_cleanup(void);\n int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings);\n int OPENSSL_atexit(void (*handler)(void));\n void OPENSSL_thread_stop(void);\n\n OPENSSL_INIT_SETTINGS *OPENSSL_init_new(void);\n int OPENSSL_INIT_set_config_appname(OPENSSL_INIT_SETTINGS *init,\n                                     const char* name);\n void OPENSSL_INIT_free(OPENSSL_INIT_SETTINGS *init);\n\n=head1 DESCRIPTION\n\nDuring normal operation OpenSSL (libcrypto) will allocate various resources at\nstart up that must, subsequently, be freed on close down of the library.\nAdditionally some resources are allocated on a per thread basis (if the\napplication is multi-threaded), and these resources must be freed prior to the\nthread closing.\n\nAs of version 1.1.0 OpenSSL will automatically allocate all resources that it\nneeds so no explicit initialisation is required. Similarly it will also\nautomatically deinitialise as required.\n\nHowever, there way be situations when explicit initialisation is desirable or\nneeded, for example when some non-default initialisation is required. The\nfunction OPENSSL_init_crypto() can be used for this purpose for\nlibcrypto (see also L<OPENSSL_init_ssl(3)> for the libssl\nequivalent).\n\nNumerous internal OpenSSL functions call OPENSSL_init_crypto().\nTherefore, in order to perform non-default initialisation,\nOPENSSL_init_crypto() MUST be called by application code prior to\nany other OpenSSL function calls.\n\nThe B<opts> parameter specifies which aspects of libcrypto should be\ninitialised. Valid options are:\n\n=over 4\n\n=item OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS\n\nSuppress automatic loading of the libcrypto error strings. This option is\nnot a default option. Once selected subsequent calls to\nOPENSSL_init_crypto() with the option\nB<OPENSSL_INIT_LOAD_CRYPTO_STRINGS> will be ignored.\n\n=item OPENSSL_INIT_LOAD_CRYPTO_STRINGS\n\nAutomatic loading of the libcrypto error strings. With this option the\nlibrary will automatically load the libcrypto error strings.\nThis option is a default option. Once selected subsequent calls to\nOPENSSL_init_crypto() with the option\nB<OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS> will be ignored.\n\n=item OPENSSL_INIT_ADD_ALL_CIPHERS\n\nWith this option the library will automatically load and make available all\nlibcrypto ciphers. This option is a default option. Once selected subsequent\ncalls to OPENSSL_init_crypto() with the option\nB<OPENSSL_INIT_NO_ADD_ALL_CIPHERS> will be ignored.\n\n=item OPENSSL_INIT_ADD_ALL_DIGESTS\n\nWith this option the library will automatically load and make available all\nlibcrypto digests. This option is a default option. Once selected subsequent\ncalls to OPENSSL_init_crypto() with the option\nB<OPENSSL_INIT_NO_ADD_ALL_CIPHERS> will be ignored.\n\n=item OPENSSL_INIT_NO_ADD_ALL_CIPHERS\n\nWith this option the library will suppress automatic loading of libcrypto\nciphers. This option is not a default option. Once selected subsequent\ncalls to OPENSSL_init_crypto() with the option\nB<OPENSSL_INIT_ADD_ALL_CIPHERS> will be ignored.\n\n=item OPENSSL_INIT_NO_ADD_ALL_DIGESTS\n\nWith this option the library will suppress automatic loading of libcrypto\ndigests. This option is not a default option. Once selected subsequent\ncalls to OPENSSL_init_crypto() with the option\nB<OPENSSL_INIT_ADD_ALL_DIGESTS> will be ignored.\n\n=item OPENSSL_INIT_LOAD_CONFIG\n\nWith this option an OpenSSL configuration file will be automatically loaded and\nused by calling OPENSSL_config(). This is not a default option.\nSee the description of OPENSSL_init_new(), below.\n\n=item OPENSSL_INIT_NO_LOAD_CONFIG\n\nWith this option the loading of OpenSSL configuration files will be suppressed.\nIt is the equivalent of calling OPENSSL_no_config(). This is not a default\noption.\n\n=item OPENSSL_INIT_ASYNC\n\nWith this option the library with automatically initialise the libcrypto async\nsub-library (see L<ASYNC_start_job(3)>). This is a default option.\n\n=item OPENSSL_INIT_ENGINE_RDRAND\n\nWith this option the library will automatically load and initialise the\nRDRAND engine (if available). This not a default option.\n\n=item OPENSSL_INIT_ENGINE_DYNAMIC\n\nWith this option the library will automatically load and initialise the\ndynamic engine. This not a default option.\n\n=item OPENSSL_INIT_ENGINE_OPENSSL\n\nWith this option the library will automatically load and initialise the\nopenssl engine. This not a default option.\n\n=item OPENSSL_INIT_ENGINE_CRYPTODEV\n\nWith this option the library will automatically load and initialise the\ncryptodev engine (if available). This not a default option.\n\n=item OPENSSL_INIT_ENGINE_CAPI\n\nWith this option the library will automatically load and initialise the\nCAPI engine (if available). This not a default option.\n\n=item OPENSSL_INIT_ENGINE_PADLOCK\n\nWith this option the library will automatically load and initialise the\npadlock engine (if available). This not a default option.\n\n=item OPENSSL_INIT_ENGINE_DASYNC\n\nWith this option the library will automatically load and initialise the\nDASYNC engine. This not a default option.\n\n=item OPENSSL_INIT_ENGINE_ALL_BUILTIN\n\nWith this option the library will automatically load and initialise all the\nbuilt in engines listed above with the exception of the openssl and dasync\nengines. This not a default option.\n\n=back\n\nMultiple options may be combined together in a single call to\nOPENSSL_init_crypto(). For example:\n\n OPENSSL_init_crypto(OPENSSL_INIT_NO_ADD_ALL_CIPHERS\n                     | OPENSSL_INIT_NO_ADD_ALL_DIGESTS, NULL);\n\nThe OPENSSL_cleanup() function deinitialises OpenSSL (both libcrypto\nand libssl). All resources allocated by OpenSSL are freed. Typically there\nshould be no need to call this function directly as it is initiated\nautomatically on application exit. This is done via the standard C library\nL<atexit(3)> function. In the event that the application will close in a manner\nthat will not call the registered atexit() handlers then the application should\ncall OPENSSL_cleanup() directly. Developers of libraries using OpenSSL\nare discouraged from calling this function and should instead, typically, rely\non auto-deinitialisation. This is to avoid error conditions where both an\napplication and a library it depends on both use OpenSSL, and the library\ndeinitialises it before the application has finished using it.\n\nOnce OPENSSL_cleanup() has been called the library cannot be reinitialised.\nAttempts to call OPENSSL_init_crypto() will fail and an ERR_R_INIT_FAIL error\nwill be added to the error stack. Note that because initialisation has failed\nOpenSSL error strings will not be available, only an error code. This code can\nbe put through the openssl errstr command line application to produce a human\nreadable error (see L<errstr(1)>).\n\nThe OPENSSL_atexit() function enables the registration of a\nfunction to be called during OPENSSL_cleanup(). Stop handlers are\ncalled after deinitialisation of resources local to a thread, but before other\nprocess wide resources are freed. In the event that multiple stop handlers are\nregistered, no guarantees are made about the order of execution.\n\nThe OPENSSL_thread_stop() function deallocates resources associated\nwith the current thread. Typically this function will be called automatically by\nthe library when the thread exits. This should only be called directly if\nresources should be freed at an earlier time, or under the circumstances\ndescribed in the NOTES section below.\n\nThe B<OPENSSL_INIT_LOAD_CONFIG> flag will load a default configuration\nfile.  To specify a different file, an B<OPENSSL_INIT_SETTINGS> must\nbe created and used. The routines\nOPENSSL_init_new() and OPENSSL_INIT_set_config_appname() can be used to\nallocate the object and set the application name, and then the\nobject can be released with OPENSSL_INIT_free() when done.\n\n=head1 NOTES\n\nResources local to a thread are deallocated automatically when the thread exits\n(e.g. in a pthreads environment, when pthread_exit() is called). On Windows\nplatforms this is done in response to a DLL_THREAD_DETACH message being sent to\nthe libcrypto32.dll entry point. Some windows functions may cause threads to exit\nwithout sending this message (for example ExitProcess()). If the application\nuses such functions, then the application must free up OpenSSL resources\ndirectly via a call to OPENSSL_thread_stop() on each thread. Similarly this\nmessage will also not be sent if OpenSSL is linked statically, and therefore\napplications using static linking should also call OPENSSL_thread_stop() on each\nthread. Additionally if OpenSSL is loaded dynamically via LoadLibrary() and the\nthreads are not destroyed until after FreeLibrary() is called then each thread\nshould call OPENSSL_thread_stop() prior to the FreeLibrary() call.\n\nOn Linux/Unix where OpenSSL has been loaded via dlopen() and the application is\nmulti-threaded and if dlclose() is subsequently called prior to the threads\nbeing destroyed then OpenSSL will not be able to deallocate resources associated\nwith those threads. The application should either call OPENSSL_thread_stop() on\neach thread prior to the dlclose() call, or alternatively the original dlopen()\ncall should use the RTLD_NODELETE flag (where available on the platform).\n\n=head1 RETURN VALUES\n\nThe functions OPENSSL_init_crypto, OPENSSL_atexit() and\nOPENSSL_INIT_set_config_appname() return 1 on success or 0 on error.\n\n=head1 SEE ALSO\n\nL<OPENSSL_init_ssl(3)>\n\n=head1 HISTORY\n\nThe OPENSSL_init_crypto(), OPENSSL_cleanup(), OPENSSL_atexit(),\nOPENSSL_thread_stop(), OPENSSL_init_new(), OPENSSL_INIT_set_config_appname()\nand OPENSSL_INIT_free() functions were added in OpenSSL 1.1.0.\n\n=head1 COPYRIGHT\n\nCopyright 2016 The OpenSSL Project Authors. All Rights Reserved.\n\nLicensed under the OpenSSL license (the \"License\").  You may not use\nthis file except in compliance with the License.  You can obtain a copy\nin the file LICENSE in the source distribution or at\nL<https://www.openssl.org/source/license.html>.\n\n=cut\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/test/shibboleth.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/test/d2i-tests/bad-cms.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/test/d2i-tests/high_tag.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/test/d2i-tests/intminus1.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/test/d2i-tests/bad_bio.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/test/d2i-tests/bad_cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/test/d2i-tests/bad_generalname.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0e-tonltm6gaqigs5gxd4iepwkd2nxje4du/spack-src/test/d2i-tests/bad-int-padminus1.der"
    ],
    "total_files": 2351
}