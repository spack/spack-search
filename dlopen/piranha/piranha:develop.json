{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-piranha-develop-3u53oweo3x6xysaxui5jehsrygtbs7ec/spack-src/cmake_modules/yacma/YACMAPythonSetup.cmake": "if(YACMAPythonSetupIncluded)\n    return()\nendif()\n\n# NOTE: this is a heuristic to determine whether we need to link to the Python library.\n# In theory, Python extensions don't need to, as they are dlopened() by the Python process\n# and thus they don't need to be linked to the Python library at compile time. However,\n# the dependency on Boost.Python muddies the waters, as BP itself does link to the Python\n# library, at least on some platforms. The following configuration seems to be working fine\n# on various CI setups.\n# NOTE: apparently homebrew requires NOT to link to the Python library. We might want\n# to add a config option to accommodate that eventually.\nif(WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES \"Darwin\")\n  message(STATUS \"Python modules require linking to the Python library.\")\n  set(_YACMA_PYTHON_MODULE_NEED_LINK TRUE)\nelse()\n  message(STATUS \"Python modules do NOT require linking to the Python library.\")\n  set(_YACMA_PYTHON_MODULE_NEED_LINK FALSE)\nendif()\n\n# Find Python interpreter.\nfind_package(PythonInterp REQUIRED)\n\nif(_YACMA_PYTHON_MODULE_NEED_LINK)\n  # NOTE: this will give us both the Python lib and the Python include dir.\n  find_package(PythonLibs REQUIRED)\n  if(NOT YACMA_PYTHON_INCLUDE_DIR)\n    set(YACMA_PYTHON_INCLUDE_DIR \"${PYTHON_INCLUDE_DIRS}\" CACHE PATH \"Path to the Python include dir.\")\n  endif()\nelse()\n  # NOTE: we need to determine the include dir on our own.\n  if(NOT YACMA_PYTHON_INCLUDE_DIR)\n    execute_process(COMMAND ${PYTHON_EXECUTABLE} -c \"from __future__ import print_function\\nfrom distutils import sysconfig\\nprint(sysconfig.get_python_inc())\"\n      OUTPUT_VARIABLE _YACMA_PYTHON_INCLUDE_DIR OUTPUT_STRIP_TRAILING_WHITESPACE)\n    if(_YACMA_PYTHON_INCLUDE_DIR)\n      set(YACMA_PYTHON_INCLUDE_DIR \"${_YACMA_PYTHON_INCLUDE_DIR}\" CACHE PATH \"Path to the Python include dir.\")\n    endif()\n  endif()\n  if(NOT YACMA_PYTHON_INCLUDE_DIR)\n      message(FATAL_ERROR \"Could not determine the Python include dir.\")\n  endif()\nendif()\nmark_as_advanced(YACMA_PYTHON_INCLUDE_DIR)\n\nmessage(STATUS \"Python interpreter: ${PYTHON_EXECUTABLE}\")\nmessage(STATUS \"Python interpreter version: ${PYTHON_VERSION_STRING}\")\nif(_YACMA_PYTHON_MODULE_NEED_LINK)\n  message(STATUS \"Python libraries: ${PYTHON_LIBRARIES}\")\nendif()\nmessage(STATUS \"Python include dir: ${YACMA_PYTHON_INCLUDE_DIR}\")\n\n# An imported target to be used when building extension modules.\nif(_YACMA_PYTHON_MODULE_NEED_LINK)\n  add_library(YACMA::PythonModule UNKNOWN IMPORTED)\n  set_target_properties(YACMA::PythonModule PROPERTIES INTERFACE_INCLUDE_DIRECTORIES \"${YACMA_PYTHON_INCLUDE_DIR}\"\n    IMPORTED_LOCATION \"${PYTHON_LIBRARIES}\" IMPORTED_LINK_INTERFACE_LANGUAGES \"C\")\nelse()\n  add_library(YACMA::PythonModule INTERFACE IMPORTED)\n  set_target_properties(YACMA::PythonModule PROPERTIES INTERFACE_INCLUDE_DIRECTORIES \"${YACMA_PYTHON_INCLUDE_DIR}\")\nendif()\n\n# This flag is used to signal the need to override the default extension of the Python modules\n# depending on the architecture. Under Windows, for instance, CMake produces shared objects as\n# .dll files, but Python from 2.5 onwards requires .pyd files (hence the need to override).\nset(_YACMA_PY_MODULE_EXTENSION \"\")\n\n# Platform-specific setup.\nif(UNIX)\n  if(${CMAKE_SYSTEM_NAME} MATCHES \"Darwin\")\n    message(STATUS \"OS X platform detected.\")\n    # Apparently on OS X Python expects the .so extension for compiled modules.\n\t  message(STATUS \"Output extension for compiled modules will be '.so'.\")\n    set(_YACMA_PY_MODULE_EXTENSION \"so\")\n  else()\n    message(STATUS \"Generic UNIX platform detected.\")\n  endif()\n  if(NOT YACMA_PYTHON_MODULES_INSTALL_PATH)\n    # NOTE: here we use this contraption (instead of the simple method below for Win32) because like this we can\n    # support installation into the CMake prefix (e.g., in the user's home dir).\n    execute_process(COMMAND ${PYTHON_EXECUTABLE} -c \"from __future__ import print_function\\nimport distutils.sysconfig\\nimport os\\nprint(os.path.split(distutils.sysconfig.get_python_lib())[-1])\"\n      OUTPUT_VARIABLE _YACMA_PY_PACKAGES_DIR OUTPUT_STRIP_TRAILING_WHITESPACE)\n    message(STATUS \"Python packages dir is: ${_YACMA_PY_PACKAGES_DIR}\")\n    set(YACMA_PYTHON_MODULES_INSTALL_PATH \"lib/python${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR}/${_YACMA_PY_PACKAGES_DIR}\" CACHE PATH \"Install path for Python modules.\")\n    mark_as_advanced(YACMA_PYTHON_MODULES_INSTALL_PATH)\n  endif()\nelseif(WIN32)\n  message(STATUS \"Windows platform detected.\")\n  message(STATUS \"Output extension for compiled modules will be '.pyd'.\")\n  set(_YACMA_PY_MODULE_EXTENSION \"pyd\")\n  if(NOT YACMA_PYTHON_MODULES_INSTALL_PATH)\n    # On Windows, we will install directly into the install path of the Python interpreter.\n    execute_process(COMMAND ${PYTHON_EXECUTABLE} -c \"from distutils.sysconfig import get_python_lib; print(get_python_lib())\"\n      OUTPUT_VARIABLE _YACMA_PYTHON_MODULES_INSTALL_PATH OUTPUT_STRIP_TRAILING_WHITESPACE)\n    set(YACMA_PYTHON_MODULES_INSTALL_PATH \"${_YACMA_PYTHON_MODULES_INSTALL_PATH}\" CACHE PATH \"Install path for Python modules.\")\n    mark_as_advanced(YACMA_PYTHON_MODULES_INSTALL_PATH)\n  endif()\nelse()\n  message(FATAL_ERROR \"Platform not supported.\")\nendif()\n\n# Check the install path was actually detected.\nif(\"${YACMA_PYTHON_MODULES_INSTALL_PATH}\" STREQUAL \"\")\n  message(FATAL_ERROR \"Python module install path not detected correctly.\")\nendif()\n\nmessage(STATUS \"Python modules install path: ${YACMA_PYTHON_MODULES_INSTALL_PATH}\")\n\nfunction(YACMA_PYTHON_MODULE name)\n    message(STATUS \"Setting up the compilation of the Python module '${name}'.\")\n    # If we need an explicit link to the Python library, we compile it as a normal shared library.\n    # Otherwise, we compile it as a module.\n    if(_YACMA_PYTHON_MODULE_NEED_LINK)\n      add_library(\"${name}\" SHARED ${ARGN})\n    else()\n      add_library(\"${name}\" MODULE ${ARGN})\n    endif()\n    # Any \"lib\" prefix normally added by CMake must be removed.\n    set_target_properties(\"${name}\" PROPERTIES PREFIX \"\")\n    if(NOT ${_YACMA_PY_MODULE_EXTENSION} STREQUAL \"\")\n        # If needed, set a custom extension for the module.\n        message(STATUS \"Setting up custom extension '${_YACMA_PY_MODULE_EXTENSION}' for the Python module '${name}'.\")\n        set_target_properties(\"${name}\" PROPERTIES SUFFIX \".${_YACMA_PY_MODULE_EXTENSION}\")\n    endif()\n    # We need extra flags to be set when compiling Python modules, at least\n    # with clang and gcc. See:\n    # https://bugs.python.org/issue11149\n    # http://www.python.org/dev/peps/pep-3123/\n    # NOTE: not sure here how we should set flags up for MSVC or clang on windows, need\n    # to check in the future.\n    # NOTE: do not use the yacma compiler linker settings bits, so this module\n    # can be used stand-alone.\n    if(CMAKE_COMPILER_IS_GNUCXX OR ${CMAKE_CXX_COMPILER_ID} MATCHES \"Clang\")\n        message(STATUS \"Setting up extra compiler flag '-fwrapv' for the Python module '${name}'.\")\n        target_compile_options(${name} PRIVATE \"-fwrapv\")\n        if(${PYTHON_VERSION_MAJOR} LESS 3)\n            message(STATUS \"Python < 3 detected, setting up extra compiler flag '-fno-strict-aliasing' for the Python module '${name}'.\")\n            target_compile_options(${name} PRIVATE \"-fno-strict-aliasing\")\n        endif()\n    endif()\n    target_link_libraries(\"${name}\" PRIVATE YACMA::PythonModule)\nendfunction()\n\n# Mark as included.\nset(YACMAPythonSetupIncluded YES)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-piranha-develop-3u53oweo3x6xysaxui5jehsrygtbs7ec/spack-src/.git/objects/pack/pack-f1d046ab947bcc511192302c3d9af04e078d2856.idx",
        "/tmp/vanessa/spack-stage/spack-stage-piranha-develop-3u53oweo3x6xysaxui5jehsrygtbs7ec/spack-src/.git/objects/pack/pack-f1d046ab947bcc511192302c3d9af04e078d2856.pack",
        "/tmp/vanessa/spack-stage/spack-stage-piranha-develop-3u53oweo3x6xysaxui5jehsrygtbs7ec/spack-src/benchmarks/data/sl1l3.mpackp.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-piranha-develop-3u53oweo3x6xysaxui5jehsrygtbs7ec/spack-src/benchmarks/data/s2l1.mpackp.bz2"
    ],
    "total_files": 350
}