{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ffmpeg-1.0.10-ggwvgpzorieko7332epwc5znp55xiwtk/spack-src/ffserver.c": "/*\n * Copyright (c) 2000, 2001, 2002 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * multiple format streaming server based on the FFmpeg libraries\n */\n\n#include \"config.h\"\n#if !HAVE_CLOSESOCKET\n#define closesocket close\n#endif\n#include <string.h>\n#include <stdlib.h>\n#include \"libavformat/avformat.h\"\n// FIXME those are internal headers, ffserver _really_ shouldn't use them\n#include \"libavformat/ffm.h\"\n#include \"libavformat/network.h\"\n#include \"libavformat/os_support.h\"\n#include \"libavformat/rtpdec.h\"\n#include \"libavformat/rtsp.h\"\n#include \"libavformat/avio_internal.h\"\n#include \"libavformat/internal.h\"\n#include \"libavformat/url.h\"\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/lfg.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/random_seed.h\"\n#include \"libavutil/parseutils.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/time.h\"\n\n#include <stdarg.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#if HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <errno.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <signal.h>\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include \"cmdutils.h\"\n\nconst char program_name[] = \"ffserver\";\nconst int program_birth_year = 2000;\n\nstatic const OptionDef options[];\n\nenum HTTPState {\n    HTTPSTATE_WAIT_REQUEST,\n    HTTPSTATE_SEND_HEADER,\n    HTTPSTATE_SEND_DATA_HEADER,\n    HTTPSTATE_SEND_DATA,          /* sending TCP or UDP data */\n    HTTPSTATE_SEND_DATA_TRAILER,\n    HTTPSTATE_RECEIVE_DATA,\n    HTTPSTATE_WAIT_FEED,          /* wait for data from the feed */\n    HTTPSTATE_READY,\n\n    RTSPSTATE_WAIT_REQUEST,\n    RTSPSTATE_SEND_REPLY,\n    RTSPSTATE_SEND_PACKET,\n};\n\nstatic const char *http_state[] = {\n    \"HTTP_WAIT_REQUEST\",\n    \"HTTP_SEND_HEADER\",\n\n    \"SEND_DATA_HEADER\",\n    \"SEND_DATA\",\n    \"SEND_DATA_TRAILER\",\n    \"RECEIVE_DATA\",\n    \"WAIT_FEED\",\n    \"READY\",\n\n    \"RTSP_WAIT_REQUEST\",\n    \"RTSP_SEND_REPLY\",\n    \"RTSP_SEND_PACKET\",\n};\n\n#define MAX_STREAMS 20\n\n#define IOBUFFER_INIT_SIZE 8192\n\n/* timeouts are in ms */\n#define HTTP_REQUEST_TIMEOUT (15 * 1000)\n#define RTSP_REQUEST_TIMEOUT (3600 * 24 * 1000)\n\n#define SYNC_TIMEOUT (10 * 1000)\n\ntypedef struct RTSPActionServerSetup {\n    uint32_t ipaddr;\n    char transport_option[512];\n} RTSPActionServerSetup;\n\ntypedef struct {\n    int64_t count1, count2;\n    int64_t time1, time2;\n} DataRateData;\n\n/* context associated with one connection */\ntypedef struct HTTPContext {\n    enum HTTPState state;\n    int fd; /* socket file descriptor */\n    struct sockaddr_in from_addr; /* origin */\n    struct pollfd *poll_entry; /* used when polling */\n    int64_t timeout;\n    uint8_t *buffer_ptr, *buffer_end;\n    int http_error;\n    int post;\n    int chunked_encoding;\n    int chunk_size;               /* 0 if it needs to be read */\n    struct HTTPContext *next;\n    int got_key_frame; /* stream 0 => 1, stream 1 => 2, stream 2=> 4 */\n    int64_t data_count;\n    /* feed input */\n    int feed_fd;\n    /* input format handling */\n    AVFormatContext *fmt_in;\n    int64_t start_time;            /* In milliseconds - this wraps fairly often */\n    int64_t first_pts;            /* initial pts value */\n    int64_t cur_pts;             /* current pts value from the stream in us */\n    int64_t cur_frame_duration;  /* duration of the current frame in us */\n    int cur_frame_bytes;       /* output frame size, needed to compute\n                                  the time at which we send each\n                                  packet */\n    int pts_stream_index;        /* stream we choose as clock reference */\n    int64_t cur_clock;           /* current clock reference value in us */\n    /* output format handling */\n    struct FFStream *stream;\n    /* -1 is invalid stream */\n    int feed_streams[MAX_STREAMS]; /* index of streams in the feed */\n    int switch_feed_streams[MAX_STREAMS]; /* index of streams in the feed */\n    int switch_pending;\n    AVFormatContext fmt_ctx; /* instance of FFStream for one user */\n    int last_packet_sent; /* true if last data packet was sent */\n    int suppress_log;\n    DataRateData datarate;\n    int wmp_client_id;\n    char protocol[16];\n    char method[16];\n    char url[128];\n    int buffer_size;\n    uint8_t *buffer;\n    int is_packetized; /* if true, the stream is packetized */\n    int packet_stream_index; /* current stream for output in state machine */\n\n    /* RTSP state specific */\n    uint8_t *pb_buffer; /* XXX: use that in all the code */\n    AVIOContext *pb;\n    int seq; /* RTSP sequence number */\n\n    /* RTP state specific */\n    enum RTSPLowerTransport rtp_protocol;\n    char session_id[32]; /* session id */\n    AVFormatContext *rtp_ctx[MAX_STREAMS];\n\n    /* RTP/UDP specific */\n    URLContext *rtp_handles[MAX_STREAMS];\n\n    /* RTP/TCP specific */\n    struct HTTPContext *rtsp_c;\n    uint8_t *packet_buffer, *packet_buffer_ptr, *packet_buffer_end;\n} HTTPContext;\n\n/* each generated stream is described here */\nenum StreamType {\n    STREAM_TYPE_LIVE,\n    STREAM_TYPE_STATUS,\n    STREAM_TYPE_REDIRECT,\n};\n\nenum IPAddressAction {\n    IP_ALLOW = 1,\n    IP_DENY,\n};\n\ntypedef struct IPAddressACL {\n    struct IPAddressACL *next;\n    enum IPAddressAction action;\n    /* These are in host order */\n    struct in_addr first;\n    struct in_addr last;\n} IPAddressACL;\n\n/* description of each stream of the ffserver.conf file */\ntypedef struct FFStream {\n    enum StreamType stream_type;\n    char filename[1024];     /* stream filename */\n    struct FFStream *feed;   /* feed we are using (can be null if\n                                coming from file) */\n    AVDictionary *in_opts;   /* input parameters */\n    AVInputFormat *ifmt;       /* if non NULL, force input format */\n    AVOutputFormat *fmt;\n    IPAddressACL *acl;\n    char dynamic_acl[1024];\n    int nb_streams;\n    int prebuffer;      /* Number of millseconds early to start */\n    int64_t max_time;      /* Number of milliseconds to run */\n    int send_on_key;\n    AVStream *streams[MAX_STREAMS];\n    int feed_streams[MAX_STREAMS]; /* index of streams in the feed */\n    char feed_filename[1024]; /* file name of the feed storage, or\n                                 input file name for a stream */\n    char author[512];\n    char title[512];\n    char copyright[512];\n    char comment[512];\n    pid_t pid;  /* Of ffmpeg process */\n    time_t pid_start;  /* Of ffmpeg process */\n    char **child_argv;\n    struct FFStream *next;\n    unsigned bandwidth; /* bandwidth, in kbits/s */\n    /* RTSP options */\n    char *rtsp_option;\n    /* multicast specific */\n    int is_multicast;\n    struct in_addr multicast_ip;\n    int multicast_port; /* first port used for multicast */\n    int multicast_ttl;\n    int loop; /* if true, send the stream in loops (only meaningful if file) */\n\n    /* feed specific */\n    int feed_opened;     /* true if someone is writing to the feed */\n    int is_feed;         /* true if it is a feed */\n    int readonly;        /* True if writing is prohibited to the file */\n    int truncate;        /* True if feeder connection truncate the feed file */\n    int conns_served;\n    int64_t bytes_served;\n    int64_t feed_max_size;      /* maximum storage size, zero means unlimited */\n    int64_t feed_write_index;   /* current write position in feed (it wraps around) */\n    int64_t feed_size;          /* current size of feed */\n    struct FFStream *next_feed;\n} FFStream;\n\ntypedef struct FeedData {\n    long long data_count;\n    float avg_frame_size;   /* frame size averaged over last frames with exponential mean */\n} FeedData;\n\nstatic struct sockaddr_in my_http_addr;\nstatic struct sockaddr_in my_rtsp_addr;\n\nstatic char logfilename[1024];\nstatic HTTPContext *first_http_ctx;\nstatic FFStream *first_feed;   /* contains only feeds */\nstatic FFStream *first_stream; /* contains all streams, including feeds */\n\nstatic void new_connection(int server_fd, int is_rtsp);\nstatic void close_connection(HTTPContext *c);\n\n/* HTTP handling */\nstatic int handle_connection(HTTPContext *c);\nstatic int http_parse_request(HTTPContext *c);\nstatic int http_send_data(HTTPContext *c);\nstatic void compute_status(HTTPContext *c);\nstatic int open_input_stream(HTTPContext *c, const char *info);\nstatic int http_start_receive_data(HTTPContext *c);\nstatic int http_receive_data(HTTPContext *c);\n\n/* RTSP handling */\nstatic int rtsp_parse_request(HTTPContext *c);\nstatic void rtsp_cmd_describe(HTTPContext *c, const char *url);\nstatic void rtsp_cmd_options(HTTPContext *c, const char *url);\nstatic void rtsp_cmd_setup(HTTPContext *c, const char *url, RTSPMessageHeader *h);\nstatic void rtsp_cmd_play(HTTPContext *c, const char *url, RTSPMessageHeader *h);\nstatic void rtsp_cmd_pause(HTTPContext *c, const char *url, RTSPMessageHeader *h);\nstatic void rtsp_cmd_teardown(HTTPContext *c, const char *url, RTSPMessageHeader *h);\n\n/* SDP handling */\nstatic int prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,\n                                   struct in_addr my_ip);\n\n/* RTP handling */\nstatic HTTPContext *rtp_new_connection(struct sockaddr_in *from_addr,\n                                       FFStream *stream, const char *session_id,\n                                       enum RTSPLowerTransport rtp_protocol);\nstatic int rtp_new_av_stream(HTTPContext *c,\n                             int stream_index, struct sockaddr_in *dest_addr,\n                             HTTPContext *rtsp_c);\n\nstatic const char *my_program_name;\nstatic const char *my_program_dir;\n\nstatic const char *config_filename = \"/etc/ffserver.conf\";\n\nstatic int ffserver_debug;\nstatic int ffserver_daemon;\nstatic int no_launch;\nstatic int need_to_start_children;\n\n/* maximum number of simultaneous HTTP connections */\nstatic unsigned int nb_max_http_connections = 2000;\nstatic unsigned int nb_max_connections = 5;\nstatic unsigned int nb_connections;\n\nstatic uint64_t max_bandwidth = 1000;\nstatic uint64_t current_bandwidth;\n\nstatic int64_t cur_time;           // Making this global saves on passing it around everywhere\n\nstatic AVLFG random_state;\n\nstatic FILE *logfile = NULL;\n\n/* FIXME: make ffserver work with IPv6 */\nvoid av_noreturn exit_program(int ret)\n{\n    exit(ret);\n}\n\n/* resolve host with also IP address parsing */\nstatic int resolve_host(struct in_addr *sin_addr, const char *hostname)\n{\n\n    if (!ff_inet_aton(hostname, sin_addr)) {\n#if HAVE_GETADDRINFO\n        struct addrinfo *ai, *cur;\n        struct addrinfo hints = { 0 };\n        hints.ai_family = AF_INET;\n        if (getaddrinfo(hostname, NULL, &hints, &ai))\n            return -1;\n        /* getaddrinfo returns a linked list of addrinfo structs.\n         * Even if we set ai_family = AF_INET above, make sure\n         * that the returned one actually is of the correct type. */\n        for (cur = ai; cur; cur = cur->ai_next) {\n            if (cur->ai_family == AF_INET) {\n                *sin_addr = ((struct sockaddr_in *)cur->ai_addr)->sin_addr;\n                freeaddrinfo(ai);\n                return 0;\n            }\n        }\n        freeaddrinfo(ai);\n        return -1;\n#else\n        struct hostent *hp;\n        hp = gethostbyname(hostname);\n        if (!hp)\n            return -1;\n        memcpy(sin_addr, hp->h_addr_list[0], sizeof(struct in_addr));\n#endif\n    }\n    return 0;\n}\n\nstatic char *ctime1(char *buf2)\n{\n    time_t ti;\n    char *p;\n\n    ti = time(NULL);\n    p = ctime(&ti);\n    strcpy(buf2, p);\n    p = buf2 + strlen(p) - 1;\n    if (*p == '\\n')\n        *p = '\\0';\n    return buf2;\n}\n\nstatic void http_vlog(const char *fmt, va_list vargs)\n{\n    static int print_prefix = 1;\n    if (logfile) {\n        if (print_prefix) {\n            char buf[32];\n            ctime1(buf);\n            fprintf(logfile, \"%s \", buf);\n        }\n        print_prefix = strstr(fmt, \"\\n\") != NULL;\n        vfprintf(logfile, fmt, vargs);\n        fflush(logfile);\n    }\n}\n\n#ifdef __GNUC__\n__attribute__ ((format (printf, 1, 2)))\n#endif\nstatic void http_log(const char *fmt, ...)\n{\n    va_list vargs;\n    va_start(vargs, fmt);\n    http_vlog(fmt, vargs);\n    va_end(vargs);\n}\n\nstatic void http_av_log(void *ptr, int level, const char *fmt, va_list vargs)\n{\n    static int print_prefix = 1;\n    AVClass *avc = ptr ? *(AVClass**)ptr : NULL;\n    if (level > av_log_get_level())\n        return;\n    if (print_prefix && avc)\n        http_log(\"[%s @ %p]\", avc->item_name(ptr), ptr);\n    print_prefix = strstr(fmt, \"\\n\") != NULL;\n    http_vlog(fmt, vargs);\n}\n\nstatic void log_connection(HTTPContext *c)\n{\n    if (c->suppress_log)\n        return;\n\n    http_log(\"%s - - [%s] \\\"%s %s\\\" %d %\"PRId64\"\\n\",\n             inet_ntoa(c->from_addr.sin_addr), c->method, c->url,\n             c->protocol, (c->http_error ? c->http_error : 200), c->data_count);\n}\n\nstatic void update_datarate(DataRateData *drd, int64_t count)\n{\n    if (!drd->time1 && !drd->count1) {\n        drd->time1 = drd->time2 = cur_time;\n        drd->count1 = drd->count2 = count;\n    } else if (cur_time - drd->time2 > 5000) {\n        drd->time1 = drd->time2;\n        drd->count1 = drd->count2;\n        drd->time2 = cur_time;\n        drd->count2 = count;\n    }\n}\n\n/* In bytes per second */\nstatic int compute_datarate(DataRateData *drd, int64_t count)\n{\n    if (cur_time == drd->time1)\n        return 0;\n\n    return ((count - drd->count1) * 1000) / (cur_time - drd->time1);\n}\n\n\nstatic void start_children(FFStream *feed)\n{\n    if (no_launch)\n        return;\n\n    for (; feed; feed = feed->next) {\n        if (feed->child_argv && !feed->pid) {\n            feed->pid_start = time(0);\n\n            feed->pid = fork();\n\n            if (feed->pid < 0) {\n                http_log(\"Unable to create children\\n\");\n                exit(1);\n            }\n            if (!feed->pid) {\n                /* In child */\n                char pathname[1024];\n                char *slash;\n                int i;\n\n                av_strlcpy(pathname, my_program_name, sizeof(pathname));\n\n                slash = strrchr(pathname, '/');\n                if (!slash)\n                    slash = pathname;\n                else\n                    slash++;\n                strcpy(slash, \"ffmpeg\");\n\n                http_log(\"Launch command line: \");\n                http_log(\"%s \", pathname);\n                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)\n                    http_log(\"%s \", feed->child_argv[i]);\n                http_log(\"\\n\");\n\n                for (i = 3; i < 256; i++)\n                    close(i);\n\n                if (!ffserver_debug) {\n                    i = open(\"/dev/null\", O_RDWR);\n                    if (i != -1) {\n                        dup2(i, 0);\n                        dup2(i, 1);\n                        dup2(i, 2);\n                        close(i);\n                    }\n                }\n\n                /* This is needed to make relative pathnames work */\n                if (chdir(my_program_dir) < 0) {\n                    http_log(\"chdir failed\\n\");\n                    exit(1);\n                }\n\n                signal(SIGPIPE, SIG_DFL);\n\n                execvp(pathname, feed->child_argv);\n\n                _exit(1);\n            }\n        }\n    }\n}\n\n/* open a listening socket */\nstatic int socket_open_listen(struct sockaddr_in *my_addr)\n{\n    int server_fd, tmp;\n\n    server_fd = socket(AF_INET,SOCK_STREAM,0);\n    if (server_fd < 0) {\n        perror (\"socket\");\n        return -1;\n    }\n\n    tmp = 1;\n    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &tmp, sizeof(tmp));\n\n    my_addr->sin_family = AF_INET;\n    if (bind (server_fd, (struct sockaddr *) my_addr, sizeof (*my_addr)) < 0) {\n        char bindmsg[32];\n        snprintf(bindmsg, sizeof(bindmsg), \"bind(port %d)\", ntohs(my_addr->sin_port));\n        perror (bindmsg);\n        closesocket(server_fd);\n        return -1;\n    }\n\n    if (listen (server_fd, 5) < 0) {\n        perror (\"listen\");\n        closesocket(server_fd);\n        return -1;\n    }\n    ff_socket_nonblock(server_fd, 1);\n\n    return server_fd;\n}\n\n/* start all multicast streams */\nstatic void start_multicast(void)\n{\n    FFStream *stream;\n    char session_id[32];\n    HTTPContext *rtp_c;\n    struct sockaddr_in dest_addr;\n    int default_port, stream_index;\n\n    default_port = 6000;\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n        if (stream->is_multicast) {\n            unsigned random0 = av_lfg_get(&random_state);\n            unsigned random1 = av_lfg_get(&random_state);\n            /* open the RTP connection */\n            snprintf(session_id, sizeof(session_id), \"%08x%08x\",\n                     random0, random1);\n\n            /* choose a port if none given */\n            if (stream->multicast_port == 0) {\n                stream->multicast_port = default_port;\n                default_port += 100;\n            }\n\n            dest_addr.sin_family = AF_INET;\n            dest_addr.sin_addr = stream->multicast_ip;\n            dest_addr.sin_port = htons(stream->multicast_port);\n\n            rtp_c = rtp_new_connection(&dest_addr, stream, session_id,\n                                       RTSP_LOWER_TRANSPORT_UDP_MULTICAST);\n            if (!rtp_c)\n                continue;\n\n            if (open_input_stream(rtp_c, \"\") < 0) {\n                http_log(\"Could not open input stream for stream '%s'\\n\",\n                         stream->filename);\n                continue;\n            }\n\n            /* open each RTP stream */\n            for(stream_index = 0; stream_index < stream->nb_streams;\n                stream_index++) {\n                dest_addr.sin_port = htons(stream->multicast_port +\n                                           2 * stream_index);\n                if (rtp_new_av_stream(rtp_c, stream_index, &dest_addr, NULL) < 0) {\n                    http_log(\"Could not open output stream '%s/streamid=%d'\\n\",\n                             stream->filename, stream_index);\n                    exit(1);\n                }\n            }\n\n            /* change state to send data */\n            rtp_c->state = HTTPSTATE_SEND_DATA;\n        }\n    }\n}\n\n/* main loop of the http server */\nstatic int http_server(void)\n{\n    int server_fd = 0, rtsp_server_fd = 0;\n    int ret, delay, delay1;\n    struct pollfd *poll_table, *poll_entry;\n    HTTPContext *c, *c_next;\n\n    if(!(poll_table = av_mallocz((nb_max_http_connections + 2)*sizeof(*poll_table)))) {\n        http_log(\"Impossible to allocate a poll table handling %d connections.\\n\", nb_max_http_connections);\n        return -1;\n    }\n\n    if (my_http_addr.sin_port) {\n        server_fd = socket_open_listen(&my_http_addr);\n        if (server_fd < 0)\n            return -1;\n    }\n\n    if (my_rtsp_addr.sin_port) {\n        rtsp_server_fd = socket_open_listen(&my_rtsp_addr);\n        if (rtsp_server_fd < 0)\n            return -1;\n    }\n\n    if (!rtsp_server_fd && !server_fd) {\n        http_log(\"HTTP and RTSP disabled.\\n\");\n        return -1;\n    }\n\n    http_log(\"FFserver started.\\n\");\n\n    start_children(first_feed);\n\n    start_multicast();\n\n    for(;;) {\n        poll_entry = poll_table;\n        if (server_fd) {\n            poll_entry->fd = server_fd;\n            poll_entry->events = POLLIN;\n            poll_entry++;\n        }\n        if (rtsp_server_fd) {\n            poll_entry->fd = rtsp_server_fd;\n            poll_entry->events = POLLIN;\n            poll_entry++;\n        }\n\n        /* wait for events on each HTTP handle */\n        c = first_http_ctx;\n        delay = 1000;\n        while (c != NULL) {\n            int fd;\n            fd = c->fd;\n            switch(c->state) {\n            case HTTPSTATE_SEND_HEADER:\n            case RTSPSTATE_SEND_REPLY:\n            case RTSPSTATE_SEND_PACKET:\n                c->poll_entry = poll_entry;\n                poll_entry->fd = fd;\n                poll_entry->events = POLLOUT;\n                poll_entry++;\n                break;\n            case HTTPSTATE_SEND_DATA_HEADER:\n            case HTTPSTATE_SEND_DATA:\n            case HTTPSTATE_SEND_DATA_TRAILER:\n                if (!c->is_packetized) {\n                    /* for TCP, we output as much as we can (may need to put a limit) */\n                    c->poll_entry = poll_entry;\n                    poll_entry->fd = fd;\n                    poll_entry->events = POLLOUT;\n                    poll_entry++;\n                } else {\n                    /* when ffserver is doing the timing, we work by\n                       looking at which packet need to be sent every\n                       10 ms */\n                    delay1 = 10; /* one tick wait XXX: 10 ms assumed */\n                    if (delay1 < delay)\n                        delay = delay1;\n                }\n                break;\n            case HTTPSTATE_WAIT_REQUEST:\n            case HTTPSTATE_RECEIVE_DATA:\n            case HTTPSTATE_WAIT_FEED:\n            case RTSPSTATE_WAIT_REQUEST:\n                /* need to catch errors */\n                c->poll_entry = poll_entry;\n                poll_entry->fd = fd;\n                poll_entry->events = POLLIN;/* Maybe this will work */\n                poll_entry++;\n                break;\n            default:\n                c->poll_entry = NULL;\n                break;\n            }\n            c = c->next;\n        }\n\n        /* wait for an event on one connection. We poll at least every\n           second to handle timeouts */\n        do {\n            ret = poll(poll_table, poll_entry - poll_table, delay);\n            if (ret < 0 && ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                return -1;\n        } while (ret < 0);\n\n        cur_time = av_gettime() / 1000;\n\n        if (need_to_start_children) {\n            need_to_start_children = 0;\n            start_children(first_feed);\n        }\n\n        /* now handle the events */\n        for(c = first_http_ctx; c != NULL; c = c_next) {\n            c_next = c->next;\n            if (handle_connection(c) < 0) {\n                /* close and free the connection */\n                log_connection(c);\n                close_connection(c);\n            }\n        }\n\n        poll_entry = poll_table;\n        if (server_fd) {\n            /* new HTTP connection request ? */\n            if (poll_entry->revents & POLLIN)\n                new_connection(server_fd, 0);\n            poll_entry++;\n        }\n        if (rtsp_server_fd) {\n            /* new RTSP connection request ? */\n            if (poll_entry->revents & POLLIN)\n                new_connection(rtsp_server_fd, 1);\n        }\n    }\n}\n\n/* start waiting for a new HTTP/RTSP request */\nstatic void start_wait_request(HTTPContext *c, int is_rtsp)\n{\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = c->buffer + c->buffer_size - 1; /* leave room for '\\0' */\n\n    if (is_rtsp) {\n        c->timeout = cur_time + RTSP_REQUEST_TIMEOUT;\n        c->state = RTSPSTATE_WAIT_REQUEST;\n    } else {\n        c->timeout = cur_time + HTTP_REQUEST_TIMEOUT;\n        c->state = HTTPSTATE_WAIT_REQUEST;\n    }\n}\n\nstatic void http_send_too_busy_reply(int fd)\n{\n    char buffer[400];\n    int len = snprintf(buffer, sizeof(buffer),\n                       \"HTTP/1.0 503 Server too busy\\r\\n\"\n                       \"Content-type: text/html\\r\\n\"\n                       \"\\r\\n\"\n                       \"<html><head><title>Too busy</title></head><body>\\r\\n\"\n                       \"<p>The server is too busy to serve your request at this time.</p>\\r\\n\"\n                       \"<p>The number of current connections is %d, and this exceeds the limit of %d.</p>\\r\\n\"\n                       \"</body></html>\\r\\n\",\n                       nb_connections, nb_max_connections);\n    av_assert0(len < sizeof(buffer));\n    send(fd, buffer, len, 0);\n}\n\n\nstatic void new_connection(int server_fd, int is_rtsp)\n{\n    struct sockaddr_in from_addr;\n    int fd, len;\n    HTTPContext *c = NULL;\n\n    len = sizeof(from_addr);\n    fd = accept(server_fd, (struct sockaddr *)&from_addr,\n                &len);\n    if (fd < 0) {\n        http_log(\"error during accept %s\\n\", strerror(errno));\n        return;\n    }\n    ff_socket_nonblock(fd, 1);\n\n    if (nb_connections >= nb_max_connections) {\n        http_send_too_busy_reply(fd);\n        goto fail;\n    }\n\n    /* add a new connection */\n    c = av_mallocz(sizeof(HTTPContext));\n    if (!c)\n        goto fail;\n\n    c->fd = fd;\n    c->poll_entry = NULL;\n    c->from_addr = from_addr;\n    c->buffer_size = IOBUFFER_INIT_SIZE;\n    c->buffer = av_malloc(c->buffer_size);\n    if (!c->buffer)\n        goto fail;\n\n    c->next = first_http_ctx;\n    first_http_ctx = c;\n    nb_connections++;\n\n    start_wait_request(c, is_rtsp);\n\n    return;\n\n fail:\n    if (c) {\n        av_free(c->buffer);\n        av_free(c);\n    }\n    closesocket(fd);\n}\n\nstatic void close_connection(HTTPContext *c)\n{\n    HTTPContext **cp, *c1;\n    int i, nb_streams;\n    AVFormatContext *ctx;\n    URLContext *h;\n    AVStream *st;\n\n    /* remove connection from list */\n    cp = &first_http_ctx;\n    while ((*cp) != NULL) {\n        c1 = *cp;\n        if (c1 == c)\n            *cp = c->next;\n        else\n            cp = &c1->next;\n    }\n\n    /* remove references, if any (XXX: do it faster) */\n    for(c1 = first_http_ctx; c1 != NULL; c1 = c1->next) {\n        if (c1->rtsp_c == c)\n            c1->rtsp_c = NULL;\n    }\n\n    /* remove connection associated resources */\n    if (c->fd >= 0)\n        closesocket(c->fd);\n    if (c->fmt_in) {\n        /* close each frame parser */\n        for(i=0;i<c->fmt_in->nb_streams;i++) {\n            st = c->fmt_in->streams[i];\n            if (st->codec->codec)\n                avcodec_close(st->codec);\n        }\n        avformat_close_input(&c->fmt_in);\n    }\n\n    /* free RTP output streams if any */\n    nb_streams = 0;\n    if (c->stream)\n        nb_streams = c->stream->nb_streams;\n\n    for(i=0;i<nb_streams;i++) {\n        ctx = c->rtp_ctx[i];\n        if (ctx) {\n            av_write_trailer(ctx);\n            av_dict_free(&ctx->metadata);\n            av_free(ctx->streams[0]);\n            av_free(ctx);\n        }\n        h = c->rtp_handles[i];\n        if (h)\n            ffurl_close(h);\n    }\n\n    ctx = &c->fmt_ctx;\n\n    if (!c->last_packet_sent && c->state == HTTPSTATE_SEND_DATA_TRAILER) {\n        if (ctx->oformat) {\n            /* prepare header */\n            if (avio_open_dyn_buf(&ctx->pb) >= 0) {\n                av_write_trailer(ctx);\n                av_freep(&c->pb_buffer);\n                avio_close_dyn_buf(ctx->pb, &c->pb_buffer);\n            }\n        }\n    }\n\n    for(i=0; i<ctx->nb_streams; i++)\n        av_free(ctx->streams[i]);\n\n    if (c->stream && !c->post && c->stream->stream_type == STREAM_TYPE_LIVE)\n        current_bandwidth -= c->stream->bandwidth;\n\n    /* signal that there is no feed if we are the feeder socket */\n    if (c->state == HTTPSTATE_RECEIVE_DATA && c->stream) {\n        c->stream->feed_opened = 0;\n        close(c->feed_fd);\n    }\n\n    av_freep(&c->pb_buffer);\n    av_freep(&c->packet_buffer);\n    av_free(c->buffer);\n    av_free(c);\n    nb_connections--;\n}\n\nstatic int handle_connection(HTTPContext *c)\n{\n    int len, ret;\n\n    switch(c->state) {\n    case HTTPSTATE_WAIT_REQUEST:\n    case RTSPSTATE_WAIT_REQUEST:\n        /* timeout ? */\n        if ((c->timeout - cur_time) < 0)\n            return -1;\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            return -1;\n\n        /* no need to read if no events */\n        if (!(c->poll_entry->revents & POLLIN))\n            return 0;\n        /* read the data */\n    read_loop:\n        len = recv(c->fd, c->buffer_ptr, 1, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                return -1;\n        } else if (len == 0) {\n            return -1;\n        } else {\n            /* search for end of request. */\n            uint8_t *ptr;\n            c->buffer_ptr += len;\n            ptr = c->buffer_ptr;\n            if ((ptr >= c->buffer + 2 && !memcmp(ptr-2, \"\\n\\n\", 2)) ||\n                (ptr >= c->buffer + 4 && !memcmp(ptr-4, \"\\r\\n\\r\\n\", 4))) {\n                /* request found : parse it and reply */\n                if (c->state == HTTPSTATE_WAIT_REQUEST) {\n                    ret = http_parse_request(c);\n                } else {\n                    ret = rtsp_parse_request(c);\n                }\n                if (ret < 0)\n                    return -1;\n            } else if (ptr >= c->buffer_end) {\n                /* request too long: cannot do anything */\n                return -1;\n            } else goto read_loop;\n        }\n        break;\n\n    case HTTPSTATE_SEND_HEADER:\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            return -1;\n\n        /* no need to write if no events */\n        if (!(c->poll_entry->revents & POLLOUT))\n            return 0;\n        len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                /* error : close connection */\n                av_freep(&c->pb_buffer);\n                return -1;\n            }\n        } else {\n            c->buffer_ptr += len;\n            if (c->stream)\n                c->stream->bytes_served += len;\n            c->data_count += len;\n            if (c->buffer_ptr >= c->buffer_end) {\n                av_freep(&c->pb_buffer);\n                /* if error, exit */\n                if (c->http_error)\n                    return -1;\n                /* all the buffer was sent : synchronize to the incoming stream */\n                c->state = HTTPSTATE_SEND_DATA_HEADER;\n                c->buffer_ptr = c->buffer_end = c->buffer;\n            }\n        }\n        break;\n\n    case HTTPSTATE_SEND_DATA:\n    case HTTPSTATE_SEND_DATA_HEADER:\n    case HTTPSTATE_SEND_DATA_TRAILER:\n        /* for packetized output, we consider we can always write (the\n           input streams sets the speed). It may be better to verify\n           that we do not rely too much on the kernel queues */\n        if (!c->is_packetized) {\n            if (c->poll_entry->revents & (POLLERR | POLLHUP))\n                return -1;\n\n            /* no need to read if no events */\n            if (!(c->poll_entry->revents & POLLOUT))\n                return 0;\n        }\n        if (http_send_data(c) < 0)\n            return -1;\n        /* close connection if trailer sent */\n        if (c->state == HTTPSTATE_SEND_DATA_TRAILER)\n            return -1;\n        break;\n    case HTTPSTATE_RECEIVE_DATA:\n        /* no need to read if no events */\n        if (c->poll_entry->revents & (POLLERR | POLLHUP))\n            return -1;\n        if (!(c->poll_entry->revents & POLLIN))\n            return 0;\n        if (http_receive_data(c) < 0)\n            return -1;\n        break;\n    case HTTPSTATE_WAIT_FEED:\n        /* no need to read if no events */\n        if (c->poll_entry->revents & (POLLIN | POLLERR | POLLHUP))\n            return -1;\n\n        /* nothing to do, we'll be waken up by incoming feed packets */\n        break;\n\n    case RTSPSTATE_SEND_REPLY:\n        if (c->poll_entry->revents & (POLLERR | POLLHUP)) {\n            av_freep(&c->pb_buffer);\n            return -1;\n        }\n        /* no need to write if no events */\n        if (!(c->poll_entry->revents & POLLOUT))\n            return 0;\n        len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                /* error : close connection */\n                av_freep(&c->pb_buffer);\n                return -1;\n            }\n        } else {\n            c->buffer_ptr += len;\n            c->data_count += len;\n            if (c->buffer_ptr >= c->buffer_end) {\n                /* all the buffer was sent : wait for a new request */\n                av_freep(&c->pb_buffer);\n                start_wait_request(c, 1);\n            }\n        }\n        break;\n    case RTSPSTATE_SEND_PACKET:\n        if (c->poll_entry->revents & (POLLERR | POLLHUP)) {\n            av_freep(&c->packet_buffer);\n            return -1;\n        }\n        /* no need to write if no events */\n        if (!(c->poll_entry->revents & POLLOUT))\n            return 0;\n        len = send(c->fd, c->packet_buffer_ptr,\n                    c->packet_buffer_end - c->packet_buffer_ptr, 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR)) {\n                /* error : close connection */\n                av_freep(&c->packet_buffer);\n                return -1;\n            }\n        } else {\n            c->packet_buffer_ptr += len;\n            if (c->packet_buffer_ptr >= c->packet_buffer_end) {\n                /* all the buffer was sent : wait for a new request */\n                av_freep(&c->packet_buffer);\n                c->state = RTSPSTATE_WAIT_REQUEST;\n            }\n        }\n        break;\n    case HTTPSTATE_READY:\n        /* nothing to do */\n        break;\n    default:\n        return -1;\n    }\n    return 0;\n}\n\nstatic int extract_rates(char *rates, int ratelen, const char *request)\n{\n    const char *p;\n\n    for (p = request; *p && *p != '\\r' && *p != '\\n'; ) {\n        if (av_strncasecmp(p, \"Pragma:\", 7) == 0) {\n            const char *q = p + 7;\n\n            while (*q && *q != '\\n' && isspace(*q))\n                q++;\n\n            if (av_strncasecmp(q, \"stream-switch-entry=\", 20) == 0) {\n                int stream_no;\n                int rate_no;\n\n                q += 20;\n\n                memset(rates, 0xff, ratelen);\n\n                while (1) {\n                    while (*q && *q != '\\n' && *q != ':')\n                        q++;\n\n                    if (sscanf(q, \":%d:%d\", &stream_no, &rate_no) != 2)\n                        break;\n\n                    stream_no--;\n                    if (stream_no < ratelen && stream_no >= 0)\n                        rates[stream_no] = rate_no;\n\n                    while (*q && *q != '\\n' && !isspace(*q))\n                        q++;\n                }\n\n                return 1;\n            }\n        }\n        p = strchr(p, '\\n');\n        if (!p)\n            break;\n\n        p++;\n    }\n\n    return 0;\n}\n\nstatic int find_stream_in_feed(FFStream *feed, AVCodecContext *codec, int bit_rate)\n{\n    int i;\n    int best_bitrate = 100000000;\n    int best = -1;\n\n    for (i = 0; i < feed->nb_streams; i++) {\n        AVCodecContext *feed_codec = feed->streams[i]->codec;\n\n        if (feed_codec->codec_id != codec->codec_id ||\n            feed_codec->sample_rate != codec->sample_rate ||\n            feed_codec->width != codec->width ||\n            feed_codec->height != codec->height)\n            continue;\n\n        /* Potential stream */\n\n        /* We want the fastest stream less than bit_rate, or the slowest\n         * faster than bit_rate\n         */\n\n        if (feed_codec->bit_rate <= bit_rate) {\n            if (best_bitrate > bit_rate || feed_codec->bit_rate > best_bitrate) {\n                best_bitrate = feed_codec->bit_rate;\n                best = i;\n            }\n        } else {\n            if (feed_codec->bit_rate < best_bitrate) {\n                best_bitrate = feed_codec->bit_rate;\n                best = i;\n            }\n        }\n    }\n\n    return best;\n}\n\nstatic int modify_current_stream(HTTPContext *c, char *rates)\n{\n    int i;\n    FFStream *req = c->stream;\n    int action_required = 0;\n\n    /* Not much we can do for a feed */\n    if (!req->feed)\n        return 0;\n\n    for (i = 0; i < req->nb_streams; i++) {\n        AVCodecContext *codec = req->streams[i]->codec;\n\n        switch(rates[i]) {\n            case 0:\n                c->switch_feed_streams[i] = req->feed_streams[i];\n                break;\n            case 1:\n                c->switch_feed_streams[i] = find_stream_in_feed(req->feed, codec, codec->bit_rate / 2);\n                break;\n            case 2:\n                /* Wants off or slow */\n                c->switch_feed_streams[i] = find_stream_in_feed(req->feed, codec, codec->bit_rate / 4);\n#ifdef WANTS_OFF\n                /* This doesn't work well when it turns off the only stream! */\n                c->switch_feed_streams[i] = -2;\n                c->feed_streams[i] = -2;\n#endif\n                break;\n        }\n\n        if (c->switch_feed_streams[i] >= 0 && c->switch_feed_streams[i] != c->feed_streams[i])\n            action_required = 1;\n    }\n\n    return action_required;\n}\n\n/* XXX: factorize in utils.c ? */\n/* XXX: take care with different space meaning */\nstatic void skip_spaces(const char **pp)\n{\n    const char *p;\n    p = *pp;\n    while (*p == ' ' || *p == '\\t')\n        p++;\n    *pp = p;\n}\n\nstatic void get_word(char *buf, int buf_size, const char **pp)\n{\n    const char *p;\n    char *q;\n\n    p = *pp;\n    skip_spaces(&p);\n    q = buf;\n    while (!isspace(*p) && *p != '\\0') {\n        if ((q - buf) < buf_size - 1)\n            *q++ = *p;\n        p++;\n    }\n    if (buf_size > 0)\n        *q = '\\0';\n    *pp = p;\n}\n\nstatic void get_arg(char *buf, int buf_size, const char **pp)\n{\n    const char *p;\n    char *q;\n    int quote;\n\n    p = *pp;\n    while (isspace(*p)) p++;\n    q = buf;\n    quote = 0;\n    if (*p == '\\\"' || *p == '\\'')\n        quote = *p++;\n    for(;;) {\n        if (quote) {\n            if (*p == quote)\n                break;\n        } else {\n            if (isspace(*p))\n                break;\n        }\n        if (*p == '\\0')\n            break;\n        if ((q - buf) < buf_size - 1)\n            *q++ = *p;\n        p++;\n    }\n    *q = '\\0';\n    if (quote && *p == quote)\n        p++;\n    *pp = p;\n}\n\nstatic void parse_acl_row(FFStream *stream, FFStream* feed, IPAddressACL *ext_acl,\n                         const char *p, const char *filename, int line_num)\n{\n    char arg[1024];\n    IPAddressACL acl;\n    int errors = 0;\n\n    get_arg(arg, sizeof(arg), &p);\n    if (av_strcasecmp(arg, \"allow\") == 0)\n        acl.action = IP_ALLOW;\n    else if (av_strcasecmp(arg, \"deny\") == 0)\n        acl.action = IP_DENY;\n    else {\n        fprintf(stderr, \"%s:%d: ACL action '%s' is not ALLOW or DENY\\n\",\n                filename, line_num, arg);\n        errors++;\n    }\n\n    get_arg(arg, sizeof(arg), &p);\n\n    if (resolve_host(&acl.first, arg) != 0) {\n        fprintf(stderr, \"%s:%d: ACL refers to invalid host or ip address '%s'\\n\",\n                filename, line_num, arg);\n        errors++;\n    } else\n        acl.last = acl.first;\n\n    get_arg(arg, sizeof(arg), &p);\n\n    if (arg[0]) {\n        if (resolve_host(&acl.last, arg) != 0) {\n            fprintf(stderr, \"%s:%d: ACL refers to invalid host or ip address '%s'\\n\",\n                    filename, line_num, arg);\n            errors++;\n        }\n    }\n\n    if (!errors) {\n        IPAddressACL *nacl = av_mallocz(sizeof(*nacl));\n        IPAddressACL **naclp = 0;\n\n        acl.next = 0;\n        *nacl = acl;\n\n        if (stream)\n            naclp = &stream->acl;\n        else if (feed)\n            naclp = &feed->acl;\n        else if (ext_acl)\n            naclp = &ext_acl;\n        else {\n            fprintf(stderr, \"%s:%d: ACL found not in <stream> or <feed>\\n\",\n                    filename, line_num);\n            errors++;\n        }\n\n        if (naclp) {\n            while (*naclp)\n                naclp = &(*naclp)->next;\n\n            *naclp = nacl;\n        }\n    }\n}\n\n\nstatic IPAddressACL* parse_dynamic_acl(FFStream *stream, HTTPContext *c)\n{\n    FILE* f;\n    char line[1024];\n    char  cmd[1024];\n    IPAddressACL *acl = NULL;\n    int line_num = 0;\n    const char *p;\n\n    f = fopen(stream->dynamic_acl, \"r\");\n    if (!f) {\n        perror(stream->dynamic_acl);\n        return NULL;\n    }\n\n    acl = av_mallocz(sizeof(IPAddressACL));\n\n    /* Build ACL */\n    for(;;) {\n        if (fgets(line, sizeof(line), f) == NULL)\n            break;\n        line_num++;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '\\0' || *p == '#')\n            continue;\n        get_arg(cmd, sizeof(cmd), &p);\n\n        if (!av_strcasecmp(cmd, \"ACL\"))\n            parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);\n    }\n    fclose(f);\n    return acl;\n}\n\n\nstatic void free_acl_list(IPAddressACL *in_acl)\n{\n    IPAddressACL *pacl,*pacl2;\n\n    pacl = in_acl;\n    while(pacl) {\n        pacl2 = pacl;\n        pacl = pacl->next;\n        av_freep(pacl2);\n    }\n}\n\nstatic int validate_acl_list(IPAddressACL *in_acl, HTTPContext *c)\n{\n    enum IPAddressAction last_action = IP_DENY;\n    IPAddressACL *acl;\n    struct in_addr *src = &c->from_addr.sin_addr;\n    unsigned long src_addr = src->s_addr;\n\n    for (acl = in_acl; acl; acl = acl->next) {\n        if (src_addr >= acl->first.s_addr && src_addr <= acl->last.s_addr)\n            return (acl->action == IP_ALLOW) ? 1 : 0;\n        last_action = acl->action;\n    }\n\n    /* Nothing matched, so return not the last action */\n    return (last_action == IP_DENY) ? 1 : 0;\n}\n\nstatic int validate_acl(FFStream *stream, HTTPContext *c)\n{\n    int ret = 0;\n    IPAddressACL *acl;\n\n\n    /* if stream->acl is null validate_acl_list will return 1 */\n    ret = validate_acl_list(stream->acl, c);\n\n    if (stream->dynamic_acl[0]) {\n        acl = parse_dynamic_acl(stream, c);\n\n        ret = validate_acl_list(acl, c);\n\n        free_acl_list(acl);\n    }\n\n    return ret;\n}\n\n/* compute the real filename of a file by matching it without its\n   extensions to all the stream filenames */\nstatic void compute_real_filename(char *filename, int max_size)\n{\n    char file1[1024];\n    char file2[1024];\n    char *p;\n    FFStream *stream;\n\n    /* compute filename by matching without the file extensions */\n    av_strlcpy(file1, filename, sizeof(file1));\n    p = strrchr(file1, '.');\n    if (p)\n        *p = '\\0';\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n        av_strlcpy(file2, stream->filename, sizeof(file2));\n        p = strrchr(file2, '.');\n        if (p)\n            *p = '\\0';\n        if (!strcmp(file1, file2)) {\n            av_strlcpy(filename, stream->filename, max_size);\n            break;\n        }\n    }\n}\n\nenum RedirType {\n    REDIR_NONE,\n    REDIR_ASX,\n    REDIR_RAM,\n    REDIR_ASF,\n    REDIR_RTSP,\n    REDIR_SDP,\n};\n\n/* parse http request and prepare header */\nstatic int http_parse_request(HTTPContext *c)\n{\n    char *p;\n    enum RedirType redir_type;\n    char cmd[32];\n    char info[1024], filename[1024];\n    char url[1024], *q;\n    char protocol[32];\n    char msg[1024];\n    const char *mime_type;\n    FFStream *stream;\n    int i;\n    char ratebuf[32];\n    char *useragent = 0;\n\n    p = c->buffer;\n    get_word(cmd, sizeof(cmd), (const char **)&p);\n    av_strlcpy(c->method, cmd, sizeof(c->method));\n\n    if (!strcmp(cmd, \"GET\"))\n        c->post = 0;\n    else if (!strcmp(cmd, \"POST\"))\n        c->post = 1;\n    else\n        return -1;\n\n    get_word(url, sizeof(url), (const char **)&p);\n    av_strlcpy(c->url, url, sizeof(c->url));\n\n    get_word(protocol, sizeof(protocol), (const char **)&p);\n    if (strcmp(protocol, \"HTTP/1.0\") && strcmp(protocol, \"HTTP/1.1\"))\n        return -1;\n\n    av_strlcpy(c->protocol, protocol, sizeof(c->protocol));\n\n    if (ffserver_debug)\n        http_log(\"%s - - New connection: %s %s\\n\", inet_ntoa(c->from_addr.sin_addr), cmd, url);\n\n    /* find the filename and the optional info string in the request */\n    p = strchr(url, '?');\n    if (p) {\n        av_strlcpy(info, p, sizeof(info));\n        *p = '\\0';\n    } else\n        info[0] = '\\0';\n\n    av_strlcpy(filename, url + ((*url == '/') ? 1 : 0), sizeof(filename)-1);\n\n    for (p = c->buffer; *p && *p != '\\r' && *p != '\\n'; ) {\n        if (av_strncasecmp(p, \"User-Agent:\", 11) == 0) {\n            useragent = p + 11;\n            if (*useragent && *useragent != '\\n' && isspace(*useragent))\n                useragent++;\n            break;\n        }\n        p = strchr(p, '\\n');\n        if (!p)\n            break;\n\n        p++;\n    }\n\n    redir_type = REDIR_NONE;\n    if (av_match_ext(filename, \"asx\")) {\n        redir_type = REDIR_ASX;\n        filename[strlen(filename)-1] = 'f';\n    } else if (av_match_ext(filename, \"asf\") &&\n        (!useragent || av_strncasecmp(useragent, \"NSPlayer\", 8) != 0)) {\n        /* if this isn't WMP or lookalike, return the redirector file */\n        redir_type = REDIR_ASF;\n    } else if (av_match_ext(filename, \"rpm,ram\")) {\n        redir_type = REDIR_RAM;\n        strcpy(filename + strlen(filename)-2, \"m\");\n    } else if (av_match_ext(filename, \"rtsp\")) {\n        redir_type = REDIR_RTSP;\n        compute_real_filename(filename, sizeof(filename) - 1);\n    } else if (av_match_ext(filename, \"sdp\")) {\n        redir_type = REDIR_SDP;\n        compute_real_filename(filename, sizeof(filename) - 1);\n    }\n\n    // \"redirect\" / request to index.html\n    if (!strlen(filename))\n        av_strlcpy(filename, \"index.html\", sizeof(filename) - 1);\n\n    stream = first_stream;\n    while (stream != NULL) {\n        if (!strcmp(stream->filename, filename) && validate_acl(stream, c))\n            break;\n        stream = stream->next;\n    }\n    if (stream == NULL) {\n        snprintf(msg, sizeof(msg), \"File '%s' not found\", url);\n        http_log(\"File '%s' not found\\n\", url);\n        goto send_error;\n    }\n\n    c->stream = stream;\n    memcpy(c->feed_streams, stream->feed_streams, sizeof(c->feed_streams));\n    memset(c->switch_feed_streams, -1, sizeof(c->switch_feed_streams));\n\n    if (stream->stream_type == STREAM_TYPE_REDIRECT) {\n        c->http_error = 301;\n        q = c->buffer;\n        snprintf(q, c->buffer_size,\n                      \"HTTP/1.0 301 Moved\\r\\n\"\n                      \"Location: %s\\r\\n\"\n                      \"Content-type: text/html\\r\\n\"\n                      \"\\r\\n\"\n                      \"<html><head><title>Moved</title></head><body>\\r\\n\"\n                      \"You should be <a href=\\\"%s\\\">redirected</a>.\\r\\n\"\n                      \"</body></html>\\r\\n\", stream->feed_filename, stream->feed_filename);\n        q += strlen(q);\n        /* prepare output buffer */\n        c->buffer_ptr = c->buffer;\n        c->buffer_end = q;\n        c->state = HTTPSTATE_SEND_HEADER;\n        return 0;\n    }\n\n    /* If this is WMP, get the rate information */\n    if (extract_rates(ratebuf, sizeof(ratebuf), c->buffer)) {\n        if (modify_current_stream(c, ratebuf)) {\n            for (i = 0; i < FF_ARRAY_ELEMS(c->feed_streams); i++) {\n                if (c->switch_feed_streams[i] >= 0)\n                    c->switch_feed_streams[i] = -1;\n            }\n        }\n    }\n\n    if (c->post == 0 && stream->stream_type == STREAM_TYPE_LIVE)\n        current_bandwidth += stream->bandwidth;\n\n    /* If already streaming this feed, do not let start another feeder. */\n    if (stream->feed_opened) {\n        snprintf(msg, sizeof(msg), \"This feed is already being received.\");\n        http_log(\"Feed '%s' already being received\\n\", stream->feed_filename);\n        goto send_error;\n    }\n\n    if (c->post == 0 && max_bandwidth < current_bandwidth) {\n        c->http_error = 503;\n        q = c->buffer;\n        snprintf(q, c->buffer_size,\n                      \"HTTP/1.0 503 Server too busy\\r\\n\"\n                      \"Content-type: text/html\\r\\n\"\n                      \"\\r\\n\"\n                      \"<html><head><title>Too busy</title></head><body>\\r\\n\"\n                      \"<p>The server is too busy to serve your request at this time.</p>\\r\\n\"\n                      \"<p>The bandwidth being served (including your stream) is %\"PRIu64\"kbit/sec, \"\n                      \"and this exceeds the limit of %\"PRIu64\"kbit/sec.</p>\\r\\n\"\n                      \"</body></html>\\r\\n\", current_bandwidth, max_bandwidth);\n        q += strlen(q);\n        /* prepare output buffer */\n        c->buffer_ptr = c->buffer;\n        c->buffer_end = q;\n        c->state = HTTPSTATE_SEND_HEADER;\n        return 0;\n    }\n\n    if (redir_type != REDIR_NONE) {\n        char *hostinfo = 0;\n\n        for (p = c->buffer; *p && *p != '\\r' && *p != '\\n'; ) {\n            if (av_strncasecmp(p, \"Host:\", 5) == 0) {\n                hostinfo = p + 5;\n                break;\n            }\n            p = strchr(p, '\\n');\n            if (!p)\n                break;\n\n            p++;\n        }\n\n        if (hostinfo) {\n            char *eoh;\n            char hostbuf[260];\n\n            while (isspace(*hostinfo))\n                hostinfo++;\n\n            eoh = strchr(hostinfo, '\\n');\n            if (eoh) {\n                if (eoh[-1] == '\\r')\n                    eoh--;\n\n                if (eoh - hostinfo < sizeof(hostbuf) - 1) {\n                    memcpy(hostbuf, hostinfo, eoh - hostinfo);\n                    hostbuf[eoh - hostinfo] = 0;\n\n                    c->http_error = 200;\n                    q = c->buffer;\n                    switch(redir_type) {\n                    case REDIR_ASX:\n                        snprintf(q, c->buffer_size,\n                                      \"HTTP/1.0 200 ASX Follows\\r\\n\"\n                                      \"Content-type: video/x-ms-asf\\r\\n\"\n                                      \"\\r\\n\"\n                                      \"<ASX Version=\\\"3\\\">\\r\\n\"\n                                      //\"<!-- Autogenerated by ffserver -->\\r\\n\"\n                                      \"<ENTRY><REF HREF=\\\"http://%s/%s%s\\\"/></ENTRY>\\r\\n\"\n                                      \"</ASX>\\r\\n\", hostbuf, filename, info);\n                        q += strlen(q);\n                        break;\n                    case REDIR_RAM:\n                        snprintf(q, c->buffer_size,\n                                      \"HTTP/1.0 200 RAM Follows\\r\\n\"\n                                      \"Content-type: audio/x-pn-realaudio\\r\\n\"\n                                      \"\\r\\n\"\n                                      \"# Autogenerated by ffserver\\r\\n\"\n                                      \"http://%s/%s%s\\r\\n\", hostbuf, filename, info);\n                        q += strlen(q);\n                        break;\n                    case REDIR_ASF:\n                        snprintf(q, c->buffer_size,\n                                      \"HTTP/1.0 200 ASF Redirect follows\\r\\n\"\n                                      \"Content-type: video/x-ms-asf\\r\\n\"\n                                      \"\\r\\n\"\n                                      \"[Reference]\\r\\n\"\n                                      \"Ref1=http://%s/%s%s\\r\\n\", hostbuf, filename, info);\n                        q += strlen(q);\n                        break;\n                    case REDIR_RTSP:\n                        {\n                            char hostname[256], *p;\n                            /* extract only hostname */\n                            av_strlcpy(hostname, hostbuf, sizeof(hostname));\n                            p = strrchr(hostname, ':');\n                            if (p)\n                                *p = '\\0';\n                            snprintf(q, c->buffer_size,\n                                          \"HTTP/1.0 200 RTSP Redirect follows\\r\\n\"\n                                          /* XXX: incorrect mime type ? */\n                                          \"Content-type: application/x-rtsp\\r\\n\"\n                                          \"\\r\\n\"\n                                          \"rtsp://%s:%d/%s\\r\\n\", hostname, ntohs(my_rtsp_addr.sin_port), filename);\n                            q += strlen(q);\n                        }\n                        break;\n                    case REDIR_SDP:\n                        {\n                            uint8_t *sdp_data;\n                            int sdp_data_size, len;\n                            struct sockaddr_in my_addr;\n\n                            snprintf(q, c->buffer_size,\n                                          \"HTTP/1.0 200 OK\\r\\n\"\n                                          \"Content-type: application/sdp\\r\\n\"\n                                          \"\\r\\n\");\n                            q += strlen(q);\n\n                            len = sizeof(my_addr);\n                            getsockname(c->fd, (struct sockaddr *)&my_addr, &len);\n\n                            /* XXX: should use a dynamic buffer */\n                            sdp_data_size = prepare_sdp_description(stream,\n                                                                    &sdp_data,\n                                                                    my_addr.sin_addr);\n                            if (sdp_data_size > 0) {\n                                memcpy(q, sdp_data, sdp_data_size);\n                                q += sdp_data_size;\n                                *q = '\\0';\n                                av_free(sdp_data);\n                            }\n                        }\n                        break;\n                    default:\n                        abort();\n                        break;\n                    }\n\n                    /* prepare output buffer */\n                    c->buffer_ptr = c->buffer;\n                    c->buffer_end = q;\n                    c->state = HTTPSTATE_SEND_HEADER;\n                    return 0;\n                }\n            }\n        }\n\n        snprintf(msg, sizeof(msg), \"ASX/RAM file not handled\");\n        goto send_error;\n    }\n\n    stream->conns_served++;\n\n    /* XXX: add there authenticate and IP match */\n\n    if (c->post) {\n        /* if post, it means a feed is being sent */\n        if (!stream->is_feed) {\n            /* However it might be a status report from WMP! Let us log the\n             * data as it might come in handy one day. */\n            char *logline = 0;\n            int client_id = 0;\n\n            for (p = c->buffer; *p && *p != '\\r' && *p != '\\n'; ) {\n                if (av_strncasecmp(p, \"Pragma: log-line=\", 17) == 0) {\n                    logline = p;\n                    break;\n                }\n                if (av_strncasecmp(p, \"Pragma: client-id=\", 18) == 0)\n                    client_id = strtol(p + 18, 0, 10);\n                p = strchr(p, '\\n');\n                if (!p)\n                    break;\n\n                p++;\n            }\n\n            if (logline) {\n                char *eol = strchr(logline, '\\n');\n\n                logline += 17;\n\n                if (eol) {\n                    if (eol[-1] == '\\r')\n                        eol--;\n                    http_log(\"%.*s\\n\", (int) (eol - logline), logline);\n                    c->suppress_log = 1;\n                }\n            }\n\n#ifdef DEBUG\n            http_log(\"\\nGot request:\\n%s\\n\", c->buffer);\n#endif\n\n            if (client_id && extract_rates(ratebuf, sizeof(ratebuf), c->buffer)) {\n                HTTPContext *wmpc;\n\n                /* Now we have to find the client_id */\n                for (wmpc = first_http_ctx; wmpc; wmpc = wmpc->next) {\n                    if (wmpc->wmp_client_id == client_id)\n                        break;\n                }\n\n                if (wmpc && modify_current_stream(wmpc, ratebuf))\n                    wmpc->switch_pending = 1;\n            }\n\n            snprintf(msg, sizeof(msg), \"POST command not handled\");\n            c->stream = 0;\n            goto send_error;\n        }\n        if (http_start_receive_data(c) < 0) {\n            snprintf(msg, sizeof(msg), \"could not open feed\");\n            goto send_error;\n        }\n        c->http_error = 0;\n        c->state = HTTPSTATE_RECEIVE_DATA;\n        return 0;\n    }\n\n#ifdef DEBUG\n    if (strcmp(stream->filename + strlen(stream->filename) - 4, \".asf\") == 0)\n        http_log(\"\\nGot request:\\n%s\\n\", c->buffer);\n#endif\n\n    if (c->stream->stream_type == STREAM_TYPE_STATUS)\n        goto send_status;\n\n    /* open input stream */\n    if (open_input_stream(c, info) < 0) {\n        snprintf(msg, sizeof(msg), \"Input stream corresponding to '%s' not found\", url);\n        goto send_error;\n    }\n\n    /* prepare http header */\n    c->buffer[0] = 0;\n    av_strlcatf(c->buffer, c->buffer_size, \"HTTP/1.0 200 OK\\r\\n\");\n    mime_type = c->stream->fmt->mime_type;\n    if (!mime_type)\n        mime_type = \"application/x-octet-stream\";\n    av_strlcatf(c->buffer, c->buffer_size, \"Pragma: no-cache\\r\\n\");\n\n    /* for asf, we need extra headers */\n    if (!strcmp(c->stream->fmt->name,\"asf_stream\")) {\n        /* Need to allocate a client id */\n\n        c->wmp_client_id = av_lfg_get(&random_state);\n\n        av_strlcatf(c->buffer, c->buffer_size, \"Server: Cougar 4.1.0.3923\\r\\nCache-Control: no-cache\\r\\nPragma: client-id=%d\\r\\nPragma: features=\\\"broadcast\\\"\\r\\n\", c->wmp_client_id);\n    }\n    av_strlcatf(c->buffer, c->buffer_size, \"Content-Type: %s\\r\\n\", mime_type);\n    av_strlcatf(c->buffer, c->buffer_size, \"\\r\\n\");\n    q = c->buffer + strlen(c->buffer);\n\n    /* prepare output buffer */\n    c->http_error = 0;\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = q;\n    c->state = HTTPSTATE_SEND_HEADER;\n    return 0;\n send_error:\n    c->http_error = 404;\n    q = c->buffer;\n    snprintf(q, c->buffer_size,\n                  \"HTTP/1.0 404 Not Found\\r\\n\"\n                  \"Content-type: text/html\\r\\n\"\n                  \"\\r\\n\"\n                  \"<html>\\n\"\n                  \"<head><title>404 Not Found</title></head>\\n\"\n                  \"<body>%s</body>\\n\"\n                  \"</html>\\n\", msg);\n    q += strlen(q);\n    /* prepare output buffer */\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = q;\n    c->state = HTTPSTATE_SEND_HEADER;\n    return 0;\n send_status:\n    compute_status(c);\n    c->http_error = 200; /* horrible : we use this value to avoid\n                            going to the send data state */\n    c->state = HTTPSTATE_SEND_HEADER;\n    return 0;\n}\n\nstatic void fmt_bytecount(AVIOContext *pb, int64_t count)\n{\n    static const char suffix[] = \" kMGTP\";\n    const char *s;\n\n    for (s = suffix; count >= 100000 && s[1]; count /= 1000, s++);\n\n    avio_printf(pb, \"%\"PRId64\"%c\", count, *s);\n}\n\nstatic void compute_status(HTTPContext *c)\n{\n    HTTPContext *c1;\n    FFStream *stream;\n    char *p;\n    time_t ti;\n    int i, len;\n    AVIOContext *pb;\n\n    if (avio_open_dyn_buf(&pb) < 0) {\n        /* XXX: return an error ? */\n        c->buffer_ptr = c->buffer;\n        c->buffer_end = c->buffer;\n        return;\n    }\n\n    avio_printf(pb, \"HTTP/1.0 200 OK\\r\\n\");\n    avio_printf(pb, \"Content-type: %s\\r\\n\", \"text/html\");\n    avio_printf(pb, \"Pragma: no-cache\\r\\n\");\n    avio_printf(pb, \"\\r\\n\");\n\n    avio_printf(pb, \"<html><head><title>%s Status</title>\\n\", program_name);\n    if (c->stream->feed_filename[0])\n        avio_printf(pb, \"<link rel=\\\"shortcut icon\\\" href=\\\"%s\\\">\\n\", c->stream->feed_filename);\n    avio_printf(pb, \"</head>\\n<body>\");\n    avio_printf(pb, \"<h1>%s Status</h1>\\n\", program_name);\n    /* format status */\n    avio_printf(pb, \"<h2>Available Streams</h2>\\n\");\n    avio_printf(pb, \"<table cellspacing=0 cellpadding=4>\\n\");\n    avio_printf(pb, \"<tr><th valign=top>Path<th align=left>Served<br>Conns<th><br>bytes<th valign=top>Format<th>Bit rate<br>kbits/s<th align=left>Video<br>kbits/s<th><br>Codec<th align=left>Audio<br>kbits/s<th><br>Codec<th align=left valign=top>Feed\\n\");\n    stream = first_stream;\n    while (stream != NULL) {\n        char sfilename[1024];\n        char *eosf;\n\n        if (stream->feed != stream) {\n            av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);\n            eosf = sfilename + strlen(sfilename);\n            if (eosf - sfilename >= 4) {\n                if (strcmp(eosf - 4, \".asf\") == 0)\n                    strcpy(eosf - 4, \".asx\");\n                else if (strcmp(eosf - 3, \".rm\") == 0)\n                    strcpy(eosf - 3, \".ram\");\n                else if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n                    /* generate a sample RTSP director if\n                       unicast. Generate an SDP redirector if\n                       multicast */\n                    eosf = strrchr(sfilename, '.');\n                    if (!eosf)\n                        eosf = sfilename + strlen(sfilename);\n                    if (stream->is_multicast)\n                        strcpy(eosf, \".sdp\");\n                    else\n                        strcpy(eosf, \".rtsp\");\n                }\n            }\n\n            avio_printf(pb, \"<tr><td><a href=\\\"/%s\\\">%s</a> \",\n                         sfilename, stream->filename);\n            avio_printf(pb, \"<td align=right> %d <td align=right> \",\n                        stream->conns_served);\n            fmt_bytecount(pb, stream->bytes_served);\n            switch(stream->stream_type) {\n            case STREAM_TYPE_LIVE: {\n                    int audio_bit_rate = 0;\n                    int video_bit_rate = 0;\n                    const char *audio_codec_name = \"\";\n                    const char *video_codec_name = \"\";\n                    const char *audio_codec_name_extra = \"\";\n                    const char *video_codec_name_extra = \"\";\n\n                    for(i=0;i<stream->nb_streams;i++) {\n                        AVStream *st = stream->streams[i];\n                        AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n                        switch(st->codec->codec_type) {\n                        case AVMEDIA_TYPE_AUDIO:\n                            audio_bit_rate += st->codec->bit_rate;\n                            if (codec) {\n                                if (*audio_codec_name)\n                                    audio_codec_name_extra = \"...\";\n                                audio_codec_name = codec->name;\n                            }\n                            break;\n                        case AVMEDIA_TYPE_VIDEO:\n                            video_bit_rate += st->codec->bit_rate;\n                            if (codec) {\n                                if (*video_codec_name)\n                                    video_codec_name_extra = \"...\";\n                                video_codec_name = codec->name;\n                            }\n                            break;\n                        case AVMEDIA_TYPE_DATA:\n                            video_bit_rate += st->codec->bit_rate;\n                            break;\n                        default:\n                            abort();\n                        }\n                    }\n                    avio_printf(pb, \"<td align=center> %s <td align=right> %d <td align=right> %d <td> %s %s <td align=right> %d <td> %s %s\",\n                                 stream->fmt->name,\n                                 stream->bandwidth,\n                                 video_bit_rate / 1000, video_codec_name, video_codec_name_extra,\n                                 audio_bit_rate / 1000, audio_codec_name, audio_codec_name_extra);\n                    if (stream->feed)\n                        avio_printf(pb, \"<td>%s\", stream->feed->filename);\n                    else\n                        avio_printf(pb, \"<td>%s\", stream->feed_filename);\n                    avio_printf(pb, \"\\n\");\n                }\n                break;\n            default:\n                avio_printf(pb, \"<td align=center> - <td align=right> - <td align=right> - <td><td align=right> - <td>\\n\");\n                break;\n            }\n        }\n        stream = stream->next;\n    }\n    avio_printf(pb, \"</table>\\n\");\n\n    stream = first_stream;\n    while (stream != NULL) {\n        if (stream->feed == stream) {\n            avio_printf(pb, \"<h2>Feed %s</h2>\", stream->filename);\n            if (stream->pid) {\n                avio_printf(pb, \"Running as pid %d.\\n\", stream->pid);\n\n#if defined(linux) && !defined(CONFIG_NOCUTILS)\n                {\n                    FILE *pid_stat;\n                    char ps_cmd[64];\n\n                    /* This is somewhat linux specific I guess */\n                    snprintf(ps_cmd, sizeof(ps_cmd),\n                             \"ps -o \\\"%%cpu,cputime\\\" --no-headers %d\",\n                             stream->pid);\n\n                    pid_stat = popen(ps_cmd, \"r\");\n                    if (pid_stat) {\n                        char cpuperc[10];\n                        char cpuused[64];\n\n                        if (fscanf(pid_stat, \"%9s %63s\", cpuperc,\n                                   cpuused) == 2) {\n                            avio_printf(pb, \"Currently using %s%% of the cpu. Total time used %s.\\n\",\n                                         cpuperc, cpuused);\n                        }\n                        fclose(pid_stat);\n                    }\n                }\n#endif\n\n                avio_printf(pb, \"<p>\");\n            }\n            avio_printf(pb, \"<table cellspacing=0 cellpadding=4><tr><th>Stream<th>type<th>kbits/s<th align=left>codec<th align=left>Parameters\\n\");\n\n            for (i = 0; i < stream->nb_streams; i++) {\n                AVStream *st = stream->streams[i];\n                AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n                const char *type = \"unknown\";\n                char parameters[64];\n\n                parameters[0] = 0;\n\n                switch(st->codec->codec_type) {\n                case AVMEDIA_TYPE_AUDIO:\n                    type = \"audio\";\n                    snprintf(parameters, sizeof(parameters), \"%d channel(s), %d Hz\", st->codec->channels, st->codec->sample_rate);\n                    break;\n                case AVMEDIA_TYPE_VIDEO:\n                    type = \"video\";\n                    snprintf(parameters, sizeof(parameters), \"%dx%d, q=%d-%d, fps=%d\", st->codec->width, st->codec->height,\n                                st->codec->qmin, st->codec->qmax, st->codec->time_base.den / st->codec->time_base.num);\n                    break;\n                default:\n                    abort();\n                }\n                avio_printf(pb, \"<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\\n\",\n                        i, type, st->codec->bit_rate/1000, codec ? codec->name : \"\", parameters);\n            }\n            avio_printf(pb, \"</table>\\n\");\n\n        }\n        stream = stream->next;\n    }\n\n    /* connection status */\n    avio_printf(pb, \"<h2>Connection Status</h2>\\n\");\n\n    avio_printf(pb, \"Number of connections: %d / %d<br>\\n\",\n                 nb_connections, nb_max_connections);\n\n    avio_printf(pb, \"Bandwidth in use: %\"PRIu64\"k / %\"PRIu64\"k<br>\\n\",\n                 current_bandwidth, max_bandwidth);\n\n    avio_printf(pb, \"<table>\\n\");\n    avio_printf(pb, \"<tr><th>#<th>File<th>IP<th>Proto<th>State<th>Target bits/sec<th>Actual bits/sec<th>Bytes transferred\\n\");\n    c1 = first_http_ctx;\n    i = 0;\n    while (c1 != NULL) {\n        int bitrate;\n        int j;\n\n        bitrate = 0;\n        if (c1->stream) {\n            for (j = 0; j < c1->stream->nb_streams; j++) {\n                if (!c1->stream->feed)\n                    bitrate += c1->stream->streams[j]->codec->bit_rate;\n                else if (c1->feed_streams[j] >= 0)\n                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate;\n            }\n        }\n\n        i++;\n        p = inet_ntoa(c1->from_addr.sin_addr);\n        avio_printf(pb, \"<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td align=right>\",\n                    i,\n                    c1->stream ? c1->stream->filename : \"\",\n                    c1->state == HTTPSTATE_RECEIVE_DATA ? \"(input)\" : \"\",\n                    p,\n                    c1->protocol,\n                    http_state[c1->state]);\n        fmt_bytecount(pb, bitrate);\n        avio_printf(pb, \"<td align=right>\");\n        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);\n        avio_printf(pb, \"<td align=right>\");\n        fmt_bytecount(pb, c1->data_count);\n        avio_printf(pb, \"\\n\");\n        c1 = c1->next;\n    }\n    avio_printf(pb, \"</table>\\n\");\n\n    /* date */\n    ti = time(NULL);\n    p = ctime(&ti);\n    avio_printf(pb, \"<hr size=1 noshade>Generated at %s\", p);\n    avio_printf(pb, \"</body>\\n</html>\\n\");\n\n    len = avio_close_dyn_buf(pb, &c->pb_buffer);\n    c->buffer_ptr = c->pb_buffer;\n    c->buffer_end = c->pb_buffer + len;\n}\n\nstatic int open_input_stream(HTTPContext *c, const char *info)\n{\n    char buf[128];\n    char input_filename[1024];\n    AVFormatContext *s = NULL;\n    int buf_size, i, ret;\n    int64_t stream_pos;\n\n    /* find file name */\n    if (c->stream->feed) {\n        strcpy(input_filename, c->stream->feed->feed_filename);\n        buf_size = FFM_PACKET_SIZE;\n        /* compute position (absolute time) */\n        if (av_find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            if ((ret = av_parse_time(&stream_pos, buf, 0)) < 0)\n                return ret;\n        } else if (av_find_info_tag(buf, sizeof(buf), \"buffer\", info)) {\n            int prebuffer = strtol(buf, 0, 10);\n            stream_pos = av_gettime() - prebuffer * (int64_t)1000000;\n        } else\n            stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000;\n    } else {\n        strcpy(input_filename, c->stream->feed_filename);\n        buf_size = 0;\n        /* compute position (relative time) */\n        if (av_find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            if ((ret = av_parse_time(&stream_pos, buf, 1)) < 0)\n                return ret;\n        } else\n            stream_pos = 0;\n    }\n    if (input_filename[0] == '\\0')\n        return -1;\n\n    /* open stream */\n    if ((ret = avformat_open_input(&s, input_filename, c->stream->ifmt, &c->stream->in_opts)) < 0) {\n        http_log(\"could not open %s: %d\\n\", input_filename, ret);\n        return -1;\n    }\n\n    /* set buffer size */\n    if (buf_size > 0) ffio_set_buf_size(s->pb, buf_size);\n\n    s->flags |= AVFMT_FLAG_GENPTS;\n    c->fmt_in = s;\n    if (strcmp(s->iformat->name, \"ffm\") && avformat_find_stream_info(c->fmt_in, NULL) < 0) {\n        http_log(\"Could not find stream info '%s'\\n\", input_filename);\n        avformat_close_input(&s);\n        return -1;\n    }\n\n    /* choose stream as clock source (we favorize video stream if\n       present) for packet sending */\n    c->pts_stream_index = 0;\n    for(i=0;i<c->stream->nb_streams;i++) {\n        if (c->pts_stream_index == 0 &&\n            c->stream->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n            c->pts_stream_index = i;\n        }\n    }\n\n    if (c->fmt_in->iformat->read_seek)\n        av_seek_frame(c->fmt_in, -1, stream_pos, 0);\n    /* set the start time (needed for maxtime and RTP packet timing) */\n    c->start_time = cur_time;\n    c->first_pts = AV_NOPTS_VALUE;\n    return 0;\n}\n\n/* return the server clock (in us) */\nstatic int64_t get_server_clock(HTTPContext *c)\n{\n    /* compute current pts value from system time */\n    return (cur_time - c->start_time) * 1000;\n}\n\n/* return the estimated time at which the current packet must be sent\n   (in us) */\nstatic int64_t get_packet_send_clock(HTTPContext *c)\n{\n    int bytes_left, bytes_sent, frame_bytes;\n\n    frame_bytes = c->cur_frame_bytes;\n    if (frame_bytes <= 0)\n        return c->cur_pts;\n    else {\n        bytes_left = c->buffer_end - c->buffer_ptr;\n        bytes_sent = frame_bytes - bytes_left;\n        return c->cur_pts + (c->cur_frame_duration * bytes_sent) / frame_bytes;\n    }\n}\n\n\nstatic int http_prepare_data(HTTPContext *c)\n{\n    int i, len, ret;\n    AVFormatContext *ctx;\n\n    av_freep(&c->pb_buffer);\n    switch(c->state) {\n    case HTTPSTATE_SEND_DATA_HEADER:\n        memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));\n        av_dict_set(&c->fmt_ctx.metadata, \"author\"   , c->stream->author   , 0);\n        av_dict_set(&c->fmt_ctx.metadata, \"comment\"  , c->stream->comment  , 0);\n        av_dict_set(&c->fmt_ctx.metadata, \"copyright\", c->stream->copyright, 0);\n        av_dict_set(&c->fmt_ctx.metadata, \"title\"    , c->stream->title    , 0);\n\n        c->fmt_ctx.streams = av_mallocz(sizeof(AVStream *) * c->stream->nb_streams);\n\n        for(i=0;i<c->stream->nb_streams;i++) {\n            AVStream *src;\n            c->fmt_ctx.streams[i] = av_mallocz(sizeof(AVStream));\n            /* if file or feed, then just take streams from FFStream struct */\n            if (!c->stream->feed ||\n                c->stream->feed == c->stream)\n                src = c->stream->streams[i];\n            else\n                src = c->stream->feed->streams[c->stream->feed_streams[i]];\n\n            *(c->fmt_ctx.streams[i]) = *src;\n            c->fmt_ctx.streams[i]->priv_data = 0;\n            c->fmt_ctx.streams[i]->codec->frame_number = 0; /* XXX: should be done in\n                                           AVStream, not in codec */\n        }\n        /* set output format parameters */\n        c->fmt_ctx.oformat = c->stream->fmt;\n        c->fmt_ctx.nb_streams = c->stream->nb_streams;\n\n        c->got_key_frame = 0;\n\n        /* prepare header and save header data in a stream */\n        if (avio_open_dyn_buf(&c->fmt_ctx.pb) < 0) {\n            /* XXX: potential leak */\n            return -1;\n        }\n        c->fmt_ctx.pb->seekable = 0;\n\n        /*\n         * HACK to avoid mpeg ps muxer to spit many underflow errors\n         * Default value from FFmpeg\n         * Try to set it use configuration option\n         */\n        c->fmt_ctx.max_delay = (int)(0.7*AV_TIME_BASE);\n\n        if (avformat_write_header(&c->fmt_ctx, NULL) < 0) {\n            http_log(\"Error writing output header\\n\");\n            return -1;\n        }\n        av_dict_free(&c->fmt_ctx.metadata);\n\n        len = avio_close_dyn_buf(c->fmt_ctx.pb, &c->pb_buffer);\n        c->buffer_ptr = c->pb_buffer;\n        c->buffer_end = c->pb_buffer + len;\n\n        c->state = HTTPSTATE_SEND_DATA;\n        c->last_packet_sent = 0;\n        break;\n    case HTTPSTATE_SEND_DATA:\n        /* find a new packet */\n        /* read a packet from the input stream */\n        if (c->stream->feed)\n            ffm_set_write_index(c->fmt_in,\n                                c->stream->feed->feed_write_index,\n                                c->stream->feed->feed_size);\n\n        if (c->stream->max_time &&\n            c->stream->max_time + c->start_time - cur_time < 0)\n            /* We have timed out */\n            c->state = HTTPSTATE_SEND_DATA_TRAILER;\n        else {\n            AVPacket pkt;\n        redo:\n            ret = av_read_frame(c->fmt_in, &pkt);\n            if (ret < 0) {\n                if (c->stream->feed) {\n                    /* if coming from feed, it means we reached the end of the\n                       ffm file, so must wait for more data */\n                    c->state = HTTPSTATE_WAIT_FEED;\n                    return 1; /* state changed */\n                } else if (ret == AVERROR(EAGAIN)) {\n                    /* input not ready, come back later */\n                    return 0;\n                } else {\n                    if (c->stream->loop) {\n                        avformat_close_input(&c->fmt_in);\n                        if (open_input_stream(c, \"\") < 0)\n                            goto no_loop;\n                        goto redo;\n                    } else {\n                    no_loop:\n                        /* must send trailer now because eof or error */\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n                    }\n                }\n            } else {\n                int source_index = pkt.stream_index;\n                /* update first pts if needed */\n                if (c->first_pts == AV_NOPTS_VALUE) {\n                    c->first_pts = av_rescale_q(pkt.dts, c->fmt_in->streams[pkt.stream_index]->time_base, AV_TIME_BASE_Q);\n                    c->start_time = cur_time;\n                }\n                /* send it to the appropriate stream */\n                if (c->stream->feed) {\n                    /* if coming from a feed, select the right stream */\n                    if (c->switch_pending) {\n                        c->switch_pending = 0;\n                        for(i=0;i<c->stream->nb_streams;i++) {\n                            if (c->switch_feed_streams[i] == pkt.stream_index)\n                                if (pkt.flags & AV_PKT_FLAG_KEY)\n                                    c->switch_feed_streams[i] = -1;\n                            if (c->switch_feed_streams[i] >= 0)\n                                c->switch_pending = 1;\n                        }\n                    }\n                    for(i=0;i<c->stream->nb_streams;i++) {\n                        if (c->stream->feed_streams[i] == pkt.stream_index) {\n                            AVStream *st = c->fmt_in->streams[source_index];\n                            pkt.stream_index = i;\n                            if (pkt.flags & AV_PKT_FLAG_KEY &&\n                                (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||\n                                 c->stream->nb_streams == 1))\n                                c->got_key_frame = 1;\n                            if (!c->stream->send_on_key || c->got_key_frame)\n                                goto send_it;\n                        }\n                    }\n                } else {\n                    AVCodecContext *codec;\n                    AVStream *ist, *ost;\n                send_it:\n                    ist = c->fmt_in->streams[source_index];\n                    /* specific handling for RTP: we use several\n                       output stream (one for each RTP\n                       connection). XXX: need more abstract handling */\n                    if (c->is_packetized) {\n                        /* compute send time and duration */\n                        c->cur_pts = av_rescale_q(pkt.dts, ist->time_base, AV_TIME_BASE_Q);\n                        c->cur_pts -= c->first_pts;\n                        c->cur_frame_duration = av_rescale_q(pkt.duration, ist->time_base, AV_TIME_BASE_Q);\n                        /* find RTP context */\n                        c->packet_stream_index = pkt.stream_index;\n                        ctx = c->rtp_ctx[c->packet_stream_index];\n                        if(!ctx) {\n                            av_free_packet(&pkt);\n                            break;\n                        }\n                        codec = ctx->streams[0]->codec;\n                        /* only one stream per RTP connection */\n                        pkt.stream_index = 0;\n                    } else {\n                        ctx = &c->fmt_ctx;\n                        /* Fudge here */\n                        codec = ctx->streams[pkt.stream_index]->codec;\n                    }\n\n                    if (c->is_packetized) {\n                        int max_packet_size;\n                        if (c->rtp_protocol == RTSP_LOWER_TRANSPORT_TCP)\n                            max_packet_size = RTSP_TCP_MAX_PACKET_SIZE;\n                        else\n                            max_packet_size = c->rtp_handles[c->packet_stream_index]->max_packet_size;\n                        ret = ffio_open_dyn_packet_buf(&ctx->pb, max_packet_size);\n                    } else {\n                        ret = avio_open_dyn_buf(&ctx->pb);\n                    }\n                    if (ret < 0) {\n                        /* XXX: potential leak */\n                        return -1;\n                    }\n                    ost = ctx->streams[pkt.stream_index];\n\n                    ctx->pb->seekable = 0;\n                    if (pkt.dts != AV_NOPTS_VALUE)\n                        pkt.dts = av_rescale_q(pkt.dts, ist->time_base, ost->time_base);\n                    if (pkt.pts != AV_NOPTS_VALUE)\n                        pkt.pts = av_rescale_q(pkt.pts, ist->time_base, ost->time_base);\n                    pkt.duration = av_rescale_q(pkt.duration, ist->time_base, ost->time_base);\n                    if (av_write_frame(ctx, &pkt) < 0) {\n                        http_log(\"Error writing frame to output\\n\");\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n                    }\n\n                    len = avio_close_dyn_buf(ctx->pb, &c->pb_buffer);\n                    c->cur_frame_bytes = len;\n                    c->buffer_ptr = c->pb_buffer;\n                    c->buffer_end = c->pb_buffer + len;\n\n                    codec->frame_number++;\n                    if (len == 0) {\n                        av_free_packet(&pkt);\n                        goto redo;\n                    }\n                }\n                av_free_packet(&pkt);\n            }\n        }\n        break;\n    default:\n    case HTTPSTATE_SEND_DATA_TRAILER:\n        /* last packet test ? */\n        if (c->last_packet_sent || c->is_packetized)\n            return -1;\n        ctx = &c->fmt_ctx;\n        /* prepare header */\n        if (avio_open_dyn_buf(&ctx->pb) < 0) {\n            /* XXX: potential leak */\n            return -1;\n        }\n        c->fmt_ctx.pb->seekable = 0;\n        av_write_trailer(ctx);\n        len = avio_close_dyn_buf(ctx->pb, &c->pb_buffer);\n        c->buffer_ptr = c->pb_buffer;\n        c->buffer_end = c->pb_buffer + len;\n\n        c->last_packet_sent = 1;\n        break;\n    }\n    return 0;\n}\n\n/* should convert the format at the same time */\n/* send data starting at c->buffer_ptr to the output connection\n   (either UDP or TCP connection) */\nstatic int http_send_data(HTTPContext *c)\n{\n    int len, ret;\n\n    for(;;) {\n        if (c->buffer_ptr >= c->buffer_end) {\n            ret = http_prepare_data(c);\n            if (ret < 0)\n                return -1;\n            else if (ret != 0)\n                /* state change requested */\n                break;\n        } else {\n            if (c->is_packetized) {\n                /* RTP data output */\n                len = c->buffer_end - c->buffer_ptr;\n                if (len < 4) {\n                    /* fail safe - should never happen */\n                fail1:\n                    c->buffer_ptr = c->buffer_end;\n                    return 0;\n                }\n                len = (c->buffer_ptr[0] << 24) |\n                    (c->buffer_ptr[1] << 16) |\n                    (c->buffer_ptr[2] << 8) |\n                    (c->buffer_ptr[3]);\n                if (len > (c->buffer_end - c->buffer_ptr))\n                    goto fail1;\n                if ((get_packet_send_clock(c) - get_server_clock(c)) > 0) {\n                    /* nothing to send yet: we can wait */\n                    return 0;\n                }\n\n                c->data_count += len;\n                update_datarate(&c->datarate, c->data_count);\n                if (c->stream)\n                    c->stream->bytes_served += len;\n\n                if (c->rtp_protocol == RTSP_LOWER_TRANSPORT_TCP) {\n                    /* RTP packets are sent inside the RTSP TCP connection */\n                    AVIOContext *pb;\n                    int interleaved_index, size;\n                    uint8_t header[4];\n                    HTTPContext *rtsp_c;\n\n                    rtsp_c = c->rtsp_c;\n                    /* if no RTSP connection left, error */\n                    if (!rtsp_c)\n                        return -1;\n                    /* if already sending something, then wait. */\n                    if (rtsp_c->state != RTSPSTATE_WAIT_REQUEST)\n                        break;\n                    if (avio_open_dyn_buf(&pb) < 0)\n                        goto fail1;\n                    interleaved_index = c->packet_stream_index * 2;\n                    /* RTCP packets are sent at odd indexes */\n                    if (c->buffer_ptr[1] == 200)\n                        interleaved_index++;\n                    /* write RTSP TCP header */\n                    header[0] = '$';\n                    header[1] = interleaved_index;\n                    header[2] = len >> 8;\n                    header[3] = len;\n                    avio_write(pb, header, 4);\n                    /* write RTP packet data */\n                    c->buffer_ptr += 4;\n                    avio_write(pb, c->buffer_ptr, len);\n                    size = avio_close_dyn_buf(pb, &c->packet_buffer);\n                    /* prepare asynchronous TCP sending */\n                    rtsp_c->packet_buffer_ptr = c->packet_buffer;\n                    rtsp_c->packet_buffer_end = c->packet_buffer + size;\n                    c->buffer_ptr += len;\n\n                    /* send everything we can NOW */\n                    len = send(rtsp_c->fd, rtsp_c->packet_buffer_ptr,\n                                rtsp_c->packet_buffer_end - rtsp_c->packet_buffer_ptr, 0);\n                    if (len > 0)\n                        rtsp_c->packet_buffer_ptr += len;\n                    if (rtsp_c->packet_buffer_ptr < rtsp_c->packet_buffer_end) {\n                        /* if we could not send all the data, we will\n                           send it later, so a new state is needed to\n                           \"lock\" the RTSP TCP connection */\n                        rtsp_c->state = RTSPSTATE_SEND_PACKET;\n                        break;\n                    } else\n                        /* all data has been sent */\n                        av_freep(&c->packet_buffer);\n                } else {\n                    /* send RTP packet directly in UDP */\n                    c->buffer_ptr += 4;\n                    ffurl_write(c->rtp_handles[c->packet_stream_index],\n                                c->buffer_ptr, len);\n                    c->buffer_ptr += len;\n                    /* here we continue as we can send several packets per 10 ms slot */\n                }\n            } else {\n                /* TCP data output */\n                len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);\n                if (len < 0) {\n                    if (ff_neterrno() != AVERROR(EAGAIN) &&\n                        ff_neterrno() != AVERROR(EINTR))\n                        /* error : close connection */\n                        return -1;\n                    else\n                        return 0;\n                } else\n                    c->buffer_ptr += len;\n\n                c->data_count += len;\n                update_datarate(&c->datarate, c->data_count);\n                if (c->stream)\n                    c->stream->bytes_served += len;\n                break;\n            }\n        }\n    } /* for(;;) */\n    return 0;\n}\n\nstatic int http_start_receive_data(HTTPContext *c)\n{\n    int fd;\n\n    if (c->stream->feed_opened)\n        return -1;\n\n    /* Don't permit writing to this one */\n    if (c->stream->readonly)\n        return -1;\n\n    /* open feed */\n    fd = open(c->stream->feed_filename, O_RDWR);\n    if (fd < 0) {\n        http_log(\"Error opening feeder file: %s\\n\", strerror(errno));\n        return -1;\n    }\n    c->feed_fd = fd;\n\n    if (c->stream->truncate) {\n        /* truncate feed file */\n        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);\n        http_log(\"Truncating feed file '%s'\\n\", c->stream->feed_filename);\n        if (ftruncate(c->feed_fd, FFM_PACKET_SIZE) < 0) {\n            http_log(\"Error truncating feed file: %s\\n\", strerror(errno));\n            return -1;\n        }\n    } else {\n        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {\n            http_log(\"Error reading write index from feed file: %s\\n\", strerror(errno));\n            return -1;\n        }\n    }\n\n    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n    c->stream->feed_size = lseek(fd, 0, SEEK_END);\n    lseek(fd, 0, SEEK_SET);\n\n    /* init buffer input */\n    c->buffer_ptr = c->buffer;\n    c->buffer_end = c->buffer + FFM_PACKET_SIZE;\n    c->stream->feed_opened = 1;\n    c->chunked_encoding = !!av_stristr(c->buffer, \"Transfer-Encoding: chunked\");\n    return 0;\n}\n\nstatic int http_receive_data(HTTPContext *c)\n{\n    HTTPContext *c1;\n    int len, loop_run = 0;\n\n    while (c->chunked_encoding && !c->chunk_size &&\n           c->buffer_end > c->buffer_ptr) {\n        /* read chunk header, if present */\n        len = recv(c->fd, c->buffer_ptr, 1, 0);\n\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                /* error : close connection */\n                goto fail;\n            return 0;\n        } else if (len == 0) {\n            /* end of connection : close it */\n            goto fail;\n        } else if (c->buffer_ptr - c->buffer >= 2 &&\n                   !memcmp(c->buffer_ptr - 1, \"\\r\\n\", 2)) {\n            c->chunk_size = strtol(c->buffer, 0, 16);\n            if (c->chunk_size == 0) // end of stream\n                goto fail;\n            c->buffer_ptr = c->buffer;\n            break;\n        } else if (++loop_run > 10) {\n            /* no chunk header, abort */\n            goto fail;\n        } else {\n            c->buffer_ptr++;\n        }\n    }\n\n    if (c->buffer_end > c->buffer_ptr) {\n        len = recv(c->fd, c->buffer_ptr,\n                   FFMIN(c->chunk_size, c->buffer_end - c->buffer_ptr), 0);\n        if (len < 0) {\n            if (ff_neterrno() != AVERROR(EAGAIN) &&\n                ff_neterrno() != AVERROR(EINTR))\n                /* error : close connection */\n                goto fail;\n        } else if (len == 0)\n            /* end of connection : close it */\n            goto fail;\n        else {\n            c->chunk_size -= len;\n            c->buffer_ptr += len;\n            c->data_count += len;\n            update_datarate(&c->datarate, c->data_count);\n        }\n    }\n\n    if (c->buffer_ptr - c->buffer >= 2 && c->data_count > FFM_PACKET_SIZE) {\n        if (c->buffer[0] != 'f' ||\n            c->buffer[1] != 'm') {\n            http_log(\"Feed stream has become desynchronized -- disconnecting\\n\");\n            goto fail;\n        }\n    }\n\n    if (c->buffer_ptr >= c->buffer_end) {\n        FFStream *feed = c->stream;\n        /* a packet has been received : write it in the store, except\n           if header */\n        if (c->data_count > FFM_PACKET_SIZE) {\n\n            //            printf(\"writing pos=0x%\"PRIx64\" size=0x%\"PRIx64\"\\n\", feed->feed_write_index, feed->feed_size);\n            /* XXX: use llseek or url_seek */\n            lseek(c->feed_fd, feed->feed_write_index, SEEK_SET);\n            if (write(c->feed_fd, c->buffer, FFM_PACKET_SIZE) < 0) {\n                http_log(\"Error writing to feed file: %s\\n\", strerror(errno));\n                goto fail;\n            }\n\n            feed->feed_write_index += FFM_PACKET_SIZE;\n            /* update file size */\n            if (feed->feed_write_index > c->stream->feed_size)\n                feed->feed_size = feed->feed_write_index;\n\n            /* handle wrap around if max file size reached */\n            if (c->stream->feed_max_size && feed->feed_write_index >= c->stream->feed_max_size)\n                feed->feed_write_index = FFM_PACKET_SIZE;\n\n            /* write index */\n            if (ffm_write_write_index(c->feed_fd, feed->feed_write_index) < 0) {\n                http_log(\"Error writing index to feed file: %s\\n\", strerror(errno));\n                goto fail;\n            }\n\n            /* wake up any waiting connections */\n            for(c1 = first_http_ctx; c1 != NULL; c1 = c1->next) {\n                if (c1->state == HTTPSTATE_WAIT_FEED &&\n                    c1->stream->feed == c->stream->feed)\n                    c1->state = HTTPSTATE_SEND_DATA;\n            }\n        } else {\n            /* We have a header in our hands that contains useful data */\n            AVFormatContext *s = avformat_alloc_context();\n            AVIOContext *pb;\n            AVInputFormat *fmt_in;\n            int i;\n\n            if (!s)\n                goto fail;\n\n            /* use feed output format name to find corresponding input format */\n            fmt_in = av_find_input_format(feed->fmt->name);\n            if (!fmt_in)\n                goto fail;\n\n            pb = avio_alloc_context(c->buffer, c->buffer_end - c->buffer,\n                                    0, NULL, NULL, NULL, NULL);\n            pb->seekable = 0;\n\n            s->pb = pb;\n            if (avformat_open_input(&s, c->stream->feed_filename, fmt_in, NULL) < 0) {\n                av_free(pb);\n                goto fail;\n            }\n\n            /* Now we have the actual streams */\n            if (s->nb_streams != feed->nb_streams) {\n                avformat_close_input(&s);\n                av_free(pb);\n                http_log(\"Feed '%s' stream number does not match registered feed\\n\",\n                         c->stream->feed_filename);\n                goto fail;\n            }\n\n            for (i = 0; i < s->nb_streams; i++) {\n                AVStream *fst = feed->streams[i];\n                AVStream *st = s->streams[i];\n                avcodec_copy_context(fst->codec, st->codec);\n            }\n\n            avformat_close_input(&s);\n            av_free(pb);\n        }\n        c->buffer_ptr = c->buffer;\n    }\n\n    return 0;\n fail:\n    c->stream->feed_opened = 0;\n    close(c->feed_fd);\n    /* wake up any waiting connections to stop waiting for feed */\n    for(c1 = first_http_ctx; c1 != NULL; c1 = c1->next) {\n        if (c1->state == HTTPSTATE_WAIT_FEED &&\n            c1->stream->feed == c->stream->feed)\n            c1->state = HTTPSTATE_SEND_DATA_TRAILER;\n    }\n    return -1;\n}\n\n/********************************************************************/\n/* RTSP handling */\n\nstatic void rtsp_reply_header(HTTPContext *c, enum RTSPStatusCode error_number)\n{\n    const char *str;\n    time_t ti;\n    struct tm *tm;\n    char buf2[32];\n\n    switch(error_number) {\n    case RTSP_STATUS_OK:\n        str = \"OK\";\n        break;\n    case RTSP_STATUS_METHOD:\n        str = \"Method Not Allowed\";\n        break;\n    case RTSP_STATUS_BANDWIDTH:\n        str = \"Not Enough Bandwidth\";\n        break;\n    case RTSP_STATUS_SESSION:\n        str = \"Session Not Found\";\n        break;\n    case RTSP_STATUS_STATE:\n        str = \"Method Not Valid in This State\";\n        break;\n    case RTSP_STATUS_AGGREGATE:\n        str = \"Aggregate operation not allowed\";\n        break;\n    case RTSP_STATUS_ONLY_AGGREGATE:\n        str = \"Only aggregate operation allowed\";\n        break;\n    case RTSP_STATUS_TRANSPORT:\n        str = \"Unsupported transport\";\n        break;\n    case RTSP_STATUS_INTERNAL:\n        str = \"Internal Server Error\";\n        break;\n    case RTSP_STATUS_SERVICE:\n        str = \"Service Unavailable\";\n        break;\n    case RTSP_STATUS_VERSION:\n        str = \"RTSP Version not supported\";\n        break;\n    default:\n        str = \"Unknown Error\";\n        break;\n    }\n\n    avio_printf(c->pb, \"RTSP/1.0 %d %s\\r\\n\", error_number, str);\n    avio_printf(c->pb, \"CSeq: %d\\r\\n\", c->seq);\n\n    /* output GMT time */\n    ti = time(NULL);\n    tm = gmtime(&ti);\n    strftime(buf2, sizeof(buf2), \"%a, %d %b %Y %H:%M:%S\", tm);\n    avio_printf(c->pb, \"Date: %s GMT\\r\\n\", buf2);\n}\n\nstatic void rtsp_reply_error(HTTPContext *c, enum RTSPStatusCode error_number)\n{\n    rtsp_reply_header(c, error_number);\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic int rtsp_parse_request(HTTPContext *c)\n{\n    const char *p, *p1, *p2;\n    char cmd[32];\n    char url[1024];\n    char protocol[32];\n    char line[1024];\n    int len;\n    RTSPMessageHeader header1 = { 0 }, *header = &header1;\n\n    c->buffer_ptr[0] = '\\0';\n    p = c->buffer;\n\n    get_word(cmd, sizeof(cmd), &p);\n    get_word(url, sizeof(url), &p);\n    get_word(protocol, sizeof(protocol), &p);\n\n    av_strlcpy(c->method, cmd, sizeof(c->method));\n    av_strlcpy(c->url, url, sizeof(c->url));\n    av_strlcpy(c->protocol, protocol, sizeof(c->protocol));\n\n    if (avio_open_dyn_buf(&c->pb) < 0) {\n        /* XXX: cannot do more */\n        c->pb = NULL; /* safety */\n        return -1;\n    }\n\n    /* check version name */\n    if (strcmp(protocol, \"RTSP/1.0\") != 0) {\n        rtsp_reply_error(c, RTSP_STATUS_VERSION);\n        goto the_end;\n    }\n\n    /* parse each header line */\n    /* skip to next line */\n    while (*p != '\\n' && *p != '\\0')\n        p++;\n    if (*p == '\\n')\n        p++;\n    while (*p != '\\0') {\n        p1 = memchr(p, '\\n', (char *)c->buffer_ptr - p);\n        if (!p1)\n            break;\n        p2 = p1;\n        if (p2 > p && p2[-1] == '\\r')\n            p2--;\n        /* skip empty line */\n        if (p2 == p)\n            break;\n        len = p2 - p;\n        if (len > sizeof(line) - 1)\n            len = sizeof(line) - 1;\n        memcpy(line, p, len);\n        line[len] = '\\0';\n        ff_rtsp_parse_line(header, line, NULL, NULL);\n        p = p1 + 1;\n    }\n\n    /* handle sequence number */\n    c->seq = header->seq;\n\n    if (!strcmp(cmd, \"DESCRIBE\"))\n        rtsp_cmd_describe(c, url);\n    else if (!strcmp(cmd, \"OPTIONS\"))\n        rtsp_cmd_options(c, url);\n    else if (!strcmp(cmd, \"SETUP\"))\n        rtsp_cmd_setup(c, url, header);\n    else if (!strcmp(cmd, \"PLAY\"))\n        rtsp_cmd_play(c, url, header);\n    else if (!strcmp(cmd, \"PAUSE\"))\n        rtsp_cmd_pause(c, url, header);\n    else if (!strcmp(cmd, \"TEARDOWN\"))\n        rtsp_cmd_teardown(c, url, header);\n    else\n        rtsp_reply_error(c, RTSP_STATUS_METHOD);\n\n the_end:\n    len = avio_close_dyn_buf(c->pb, &c->pb_buffer);\n    c->pb = NULL; /* safety */\n    if (len < 0) {\n        /* XXX: cannot do more */\n        return -1;\n    }\n    c->buffer_ptr = c->pb_buffer;\n    c->buffer_end = c->pb_buffer + len;\n    c->state = RTSPSTATE_SEND_REPLY;\n    return 0;\n}\n\nstatic int prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,\n                                   struct in_addr my_ip)\n{\n    AVFormatContext *avc;\n    AVStream *avs = NULL;\n    AVOutputFormat *rtp_format = av_guess_format(\"rtp\", NULL, NULL);\n    int i;\n\n    avc =  avformat_alloc_context();\n    if (avc == NULL || !rtp_format) {\n        return -1;\n    }\n    avc->oformat = rtp_format;\n    av_dict_set(&avc->metadata, \"title\",\n               stream->title[0] ? stream->title : \"No Title\", 0);\n    avc->nb_streams = stream->nb_streams;\n    if (stream->is_multicast) {\n        snprintf(avc->filename, 1024, \"rtp://%s:%d?multicast=1?ttl=%d\",\n                 inet_ntoa(stream->multicast_ip),\n                 stream->multicast_port, stream->multicast_ttl);\n    } else {\n        snprintf(avc->filename, 1024, \"rtp://0.0.0.0\");\n    }\n\n    if (avc->nb_streams >= INT_MAX/sizeof(*avc->streams) ||\n        !(avc->streams = av_malloc(avc->nb_streams * sizeof(*avc->streams))))\n        goto sdp_done;\n    if (avc->nb_streams >= INT_MAX/sizeof(*avs) ||\n        !(avs = av_malloc(avc->nb_streams * sizeof(*avs))))\n        goto sdp_done;\n\n    for(i = 0; i < stream->nb_streams; i++) {\n        avc->streams[i] = &avs[i];\n        avc->streams[i]->codec = stream->streams[i]->codec;\n    }\n    *pbuffer = av_mallocz(2048);\n    av_sdp_create(&avc, 1, *pbuffer, 2048);\n\n sdp_done:\n    av_free(avc->streams);\n    av_dict_free(&avc->metadata);\n    av_free(avc);\n    av_free(avs);\n\n    return strlen(*pbuffer);\n}\n\nstatic void rtsp_cmd_options(HTTPContext *c, const char *url)\n{\n//    rtsp_reply_header(c, RTSP_STATUS_OK);\n    avio_printf(c->pb, \"RTSP/1.0 %d %s\\r\\n\", RTSP_STATUS_OK, \"OK\");\n    avio_printf(c->pb, \"CSeq: %d\\r\\n\", c->seq);\n    avio_printf(c->pb, \"Public: %s\\r\\n\", \"OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE\");\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic void rtsp_cmd_describe(HTTPContext *c, const char *url)\n{\n    FFStream *stream;\n    char path1[1024];\n    const char *path;\n    uint8_t *content;\n    int content_length, len;\n    struct sockaddr_in my_addr;\n\n    /* find which url is asked */\n    av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url);\n    path = path1;\n    if (*path == '/')\n        path++;\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n        if (!stream->is_feed &&\n            stream->fmt && !strcmp(stream->fmt->name, \"rtp\") &&\n            !strcmp(path, stream->filename)) {\n            goto found;\n        }\n    }\n    /* no stream found */\n    rtsp_reply_error(c, RTSP_STATUS_SERVICE); /* XXX: right error ? */\n    return;\n\n found:\n    /* prepare the media description in sdp format */\n\n    /* get the host IP */\n    len = sizeof(my_addr);\n    getsockname(c->fd, (struct sockaddr *)&my_addr, &len);\n    content_length = prepare_sdp_description(stream, &content, my_addr.sin_addr);\n    if (content_length < 0) {\n        rtsp_reply_error(c, RTSP_STATUS_INTERNAL);\n        return;\n    }\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    avio_printf(c->pb, \"Content-Base: %s/\\r\\n\", url);\n    avio_printf(c->pb, \"Content-Type: application/sdp\\r\\n\");\n    avio_printf(c->pb, \"Content-Length: %d\\r\\n\", content_length);\n    avio_printf(c->pb, \"\\r\\n\");\n    avio_write(c->pb, content, content_length);\n    av_free(content);\n}\n\nstatic HTTPContext *find_rtp_session(const char *session_id)\n{\n    HTTPContext *c;\n\n    if (session_id[0] == '\\0')\n        return NULL;\n\n    for(c = first_http_ctx; c != NULL; c = c->next) {\n        if (!strcmp(c->session_id, session_id))\n            return c;\n    }\n    return NULL;\n}\n\nstatic RTSPTransportField *find_transport(RTSPMessageHeader *h, enum RTSPLowerTransport lower_transport)\n{\n    RTSPTransportField *th;\n    int i;\n\n    for(i=0;i<h->nb_transports;i++) {\n        th = &h->transports[i];\n        if (th->lower_transport == lower_transport)\n            return th;\n    }\n    return NULL;\n}\n\nstatic void rtsp_cmd_setup(HTTPContext *c, const char *url,\n                           RTSPMessageHeader *h)\n{\n    FFStream *stream;\n    int stream_index, rtp_port, rtcp_port;\n    char buf[1024];\n    char path1[1024];\n    const char *path;\n    HTTPContext *rtp_c;\n    RTSPTransportField *th;\n    struct sockaddr_in dest_addr;\n    RTSPActionServerSetup setup;\n\n    /* find which url is asked */\n    av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url);\n    path = path1;\n    if (*path == '/')\n        path++;\n\n    /* now check each stream */\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n        if (!stream->is_feed &&\n            stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n            /* accept aggregate filenames only if single stream */\n            if (!strcmp(path, stream->filename)) {\n                if (stream->nb_streams != 1) {\n                    rtsp_reply_error(c, RTSP_STATUS_AGGREGATE);\n                    return;\n                }\n                stream_index = 0;\n                goto found;\n            }\n\n            for(stream_index = 0; stream_index < stream->nb_streams;\n                stream_index++) {\n                snprintf(buf, sizeof(buf), \"%s/streamid=%d\",\n                         stream->filename, stream_index);\n                if (!strcmp(path, buf))\n                    goto found;\n            }\n        }\n    }\n    /* no stream found */\n    rtsp_reply_error(c, RTSP_STATUS_SERVICE); /* XXX: right error ? */\n    return;\n found:\n\n    /* generate session id if needed */\n    if (h->session_id[0] == '\\0') {\n        unsigned random0 = av_lfg_get(&random_state);\n        unsigned random1 = av_lfg_get(&random_state);\n        snprintf(h->session_id, sizeof(h->session_id), \"%08x%08x\",\n                 random0, random1);\n    }\n\n    /* find rtp session, and create it if none found */\n    rtp_c = find_rtp_session(h->session_id);\n    if (!rtp_c) {\n        /* always prefer UDP */\n        th = find_transport(h, RTSP_LOWER_TRANSPORT_UDP);\n        if (!th) {\n            th = find_transport(h, RTSP_LOWER_TRANSPORT_TCP);\n            if (!th) {\n                rtsp_reply_error(c, RTSP_STATUS_TRANSPORT);\n                return;\n            }\n        }\n\n        rtp_c = rtp_new_connection(&c->from_addr, stream, h->session_id,\n                                   th->lower_transport);\n        if (!rtp_c) {\n            rtsp_reply_error(c, RTSP_STATUS_BANDWIDTH);\n            return;\n        }\n\n        /* open input stream */\n        if (open_input_stream(rtp_c, \"\") < 0) {\n            rtsp_reply_error(c, RTSP_STATUS_INTERNAL);\n            return;\n        }\n    }\n\n    /* test if stream is OK (test needed because several SETUP needs\n       to be done for a given file) */\n    if (rtp_c->stream != stream) {\n        rtsp_reply_error(c, RTSP_STATUS_SERVICE);\n        return;\n    }\n\n    /* test if stream is already set up */\n    if (rtp_c->rtp_ctx[stream_index]) {\n        rtsp_reply_error(c, RTSP_STATUS_STATE);\n        return;\n    }\n\n    /* check transport */\n    th = find_transport(h, rtp_c->rtp_protocol);\n    if (!th || (th->lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n                th->client_port_min <= 0)) {\n        rtsp_reply_error(c, RTSP_STATUS_TRANSPORT);\n        return;\n    }\n\n    /* setup default options */\n    setup.transport_option[0] = '\\0';\n    dest_addr = rtp_c->from_addr;\n    dest_addr.sin_port = htons(th->client_port_min);\n\n    /* setup stream */\n    if (rtp_new_av_stream(rtp_c, stream_index, &dest_addr, c) < 0) {\n        rtsp_reply_error(c, RTSP_STATUS_TRANSPORT);\n        return;\n    }\n\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n\n    switch(rtp_c->rtp_protocol) {\n    case RTSP_LOWER_TRANSPORT_UDP:\n        rtp_port = ff_rtp_get_local_rtp_port(rtp_c->rtp_handles[stream_index]);\n        rtcp_port = ff_rtp_get_local_rtcp_port(rtp_c->rtp_handles[stream_index]);\n        avio_printf(c->pb, \"Transport: RTP/AVP/UDP;unicast;\"\n                    \"client_port=%d-%d;server_port=%d-%d\",\n                    th->client_port_min, th->client_port_max,\n                    rtp_port, rtcp_port);\n        break;\n    case RTSP_LOWER_TRANSPORT_TCP:\n        avio_printf(c->pb, \"Transport: RTP/AVP/TCP;interleaved=%d-%d\",\n                    stream_index * 2, stream_index * 2 + 1);\n        break;\n    default:\n        break;\n    }\n    if (setup.transport_option[0] != '\\0')\n        avio_printf(c->pb, \";%s\", setup.transport_option);\n    avio_printf(c->pb, \"\\r\\n\");\n\n\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\n\n/* find an rtp connection by using the session ID. Check consistency\n   with filename */\nstatic HTTPContext *find_rtp_session_with_url(const char *url,\n                                              const char *session_id)\n{\n    HTTPContext *rtp_c;\n    char path1[1024];\n    const char *path;\n    char buf[1024];\n    int s, len;\n\n    rtp_c = find_rtp_session(session_id);\n    if (!rtp_c)\n        return NULL;\n\n    /* find which url is asked */\n    av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url);\n    path = path1;\n    if (*path == '/')\n        path++;\n    if(!strcmp(path, rtp_c->stream->filename)) return rtp_c;\n    for(s=0; s<rtp_c->stream->nb_streams; ++s) {\n      snprintf(buf, sizeof(buf), \"%s/streamid=%d\",\n        rtp_c->stream->filename, s);\n      if(!strncmp(path, buf, sizeof(buf))) {\n    // XXX: Should we reply with RTSP_STATUS_ONLY_AGGREGATE if nb_streams>1?\n        return rtp_c;\n      }\n    }\n    len = strlen(path);\n    if (len > 0 && path[len - 1] == '/' &&\n        !strncmp(path, rtp_c->stream->filename, len - 1))\n        return rtp_c;\n    return NULL;\n}\n\nstatic void rtsp_cmd_play(HTTPContext *c, const char *url, RTSPMessageHeader *h)\n{\n    HTTPContext *rtp_c;\n\n    rtp_c = find_rtp_session_with_url(url, h->session_id);\n    if (!rtp_c) {\n        rtsp_reply_error(c, RTSP_STATUS_SESSION);\n        return;\n    }\n\n    if (rtp_c->state != HTTPSTATE_SEND_DATA &&\n        rtp_c->state != HTTPSTATE_WAIT_FEED &&\n        rtp_c->state != HTTPSTATE_READY) {\n        rtsp_reply_error(c, RTSP_STATUS_STATE);\n        return;\n    }\n\n    rtp_c->state = HTTPSTATE_SEND_DATA;\n\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic void rtsp_cmd_pause(HTTPContext *c, const char *url, RTSPMessageHeader *h)\n{\n    HTTPContext *rtp_c;\n\n    rtp_c = find_rtp_session_with_url(url, h->session_id);\n    if (!rtp_c) {\n        rtsp_reply_error(c, RTSP_STATUS_SESSION);\n        return;\n    }\n\n    if (rtp_c->state != HTTPSTATE_SEND_DATA &&\n        rtp_c->state != HTTPSTATE_WAIT_FEED) {\n        rtsp_reply_error(c, RTSP_STATUS_STATE);\n        return;\n    }\n\n    rtp_c->state = HTTPSTATE_READY;\n    rtp_c->first_pts = AV_NOPTS_VALUE;\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n    avio_printf(c->pb, \"\\r\\n\");\n}\n\nstatic void rtsp_cmd_teardown(HTTPContext *c, const char *url, RTSPMessageHeader *h)\n{\n    HTTPContext *rtp_c;\n\n    rtp_c = find_rtp_session_with_url(url, h->session_id);\n    if (!rtp_c) {\n        rtsp_reply_error(c, RTSP_STATUS_SESSION);\n        return;\n    }\n\n    /* now everything is OK, so we can send the connection parameters */\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n    /* session ID */\n    avio_printf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n    avio_printf(c->pb, \"\\r\\n\");\n\n    /* abort the session */\n    close_connection(rtp_c);\n}\n\n\n/********************************************************************/\n/* RTP handling */\n\nstatic HTTPContext *rtp_new_connection(struct sockaddr_in *from_addr,\n                                       FFStream *stream, const char *session_id,\n                                       enum RTSPLowerTransport rtp_protocol)\n{\n    HTTPContext *c = NULL;\n    const char *proto_str;\n\n    /* XXX: should output a warning page when coming\n       close to the connection limit */\n    if (nb_connections >= nb_max_connections)\n        goto fail;\n\n    /* add a new connection */\n    c = av_mallocz(sizeof(HTTPContext));\n    if (!c)\n        goto fail;\n\n    c->fd = -1;\n    c->poll_entry = NULL;\n    c->from_addr = *from_addr;\n    c->buffer_size = IOBUFFER_INIT_SIZE;\n    c->buffer = av_malloc(c->buffer_size);\n    if (!c->buffer)\n        goto fail;\n    nb_connections++;\n    c->stream = stream;\n    av_strlcpy(c->session_id, session_id, sizeof(c->session_id));\n    c->state = HTTPSTATE_READY;\n    c->is_packetized = 1;\n    c->rtp_protocol = rtp_protocol;\n\n    /* protocol is shown in statistics */\n    switch(c->rtp_protocol) {\n    case RTSP_LOWER_TRANSPORT_UDP_MULTICAST:\n        proto_str = \"MCAST\";\n        break;\n    case RTSP_LOWER_TRANSPORT_UDP:\n        proto_str = \"UDP\";\n        break;\n    case RTSP_LOWER_TRANSPORT_TCP:\n        proto_str = \"TCP\";\n        break;\n    default:\n        proto_str = \"???\";\n        break;\n    }\n    av_strlcpy(c->protocol, \"RTP/\", sizeof(c->protocol));\n    av_strlcat(c->protocol, proto_str, sizeof(c->protocol));\n\n    current_bandwidth += stream->bandwidth;\n\n    c->next = first_http_ctx;\n    first_http_ctx = c;\n    return c;\n\n fail:\n    if (c) {\n        av_free(c->buffer);\n        av_free(c);\n    }\n    return NULL;\n}\n\n/* add a new RTP stream in an RTP connection (used in RTSP SETUP\n   command). If RTP/TCP protocol is used, TCP connection 'rtsp_c' is\n   used. */\nstatic int rtp_new_av_stream(HTTPContext *c,\n                             int stream_index, struct sockaddr_in *dest_addr,\n                             HTTPContext *rtsp_c)\n{\n    AVFormatContext *ctx;\n    AVStream *st;\n    char *ipaddr;\n    URLContext *h = NULL;\n    uint8_t *dummy_buf;\n    int max_packet_size;\n\n    /* now we can open the relevant output stream */\n    ctx = avformat_alloc_context();\n    if (!ctx)\n        return -1;\n    ctx->oformat = av_guess_format(\"rtp\", NULL, NULL);\n\n    st = av_mallocz(sizeof(AVStream));\n    if (!st)\n        goto fail;\n    ctx->nb_streams = 1;\n    ctx->streams = av_mallocz(sizeof(AVStream *) * ctx->nb_streams);\n    if (!ctx->streams)\n      goto fail;\n    ctx->streams[0] = st;\n\n    if (!c->stream->feed ||\n        c->stream->feed == c->stream)\n        memcpy(st, c->stream->streams[stream_index], sizeof(AVStream));\n    else\n        memcpy(st,\n               c->stream->feed->streams[c->stream->feed_streams[stream_index]],\n               sizeof(AVStream));\n    st->priv_data = NULL;\n\n    /* build destination RTP address */\n    ipaddr = inet_ntoa(dest_addr->sin_addr);\n\n    switch(c->rtp_protocol) {\n    case RTSP_LOWER_TRANSPORT_UDP:\n    case RTSP_LOWER_TRANSPORT_UDP_MULTICAST:\n        /* RTP/UDP case */\n\n        /* XXX: also pass as parameter to function ? */\n        if (c->stream->is_multicast) {\n            int ttl;\n            ttl = c->stream->multicast_ttl;\n            if (!ttl)\n                ttl = 16;\n            snprintf(ctx->filename, sizeof(ctx->filename),\n                     \"rtp://%s:%d?multicast=1&ttl=%d\",\n                     ipaddr, ntohs(dest_addr->sin_port), ttl);\n        } else {\n            snprintf(ctx->filename, sizeof(ctx->filename),\n                     \"rtp://%s:%d\", ipaddr, ntohs(dest_addr->sin_port));\n        }\n\n        if (ffurl_open(&h, ctx->filename, AVIO_FLAG_WRITE, NULL, NULL) < 0)\n            goto fail;\n        c->rtp_handles[stream_index] = h;\n        max_packet_size = h->max_packet_size;\n        break;\n    case RTSP_LOWER_TRANSPORT_TCP:\n        /* RTP/TCP case */\n        c->rtsp_c = rtsp_c;\n        max_packet_size = RTSP_TCP_MAX_PACKET_SIZE;\n        break;\n    default:\n        goto fail;\n    }\n\n    http_log(\"%s:%d - - \\\"PLAY %s/streamid=%d %s\\\"\\n\",\n             ipaddr, ntohs(dest_addr->sin_port),\n             c->stream->filename, stream_index, c->protocol);\n\n    /* normally, no packets should be output here, but the packet size may be checked */\n    if (ffio_open_dyn_packet_buf(&ctx->pb, max_packet_size) < 0) {\n        /* XXX: close stream */\n        goto fail;\n    }\n    if (avformat_write_header(ctx, NULL) < 0) {\n    fail:\n        if (h)\n            ffurl_close(h);\n        av_free(ctx);\n        return -1;\n    }\n    avio_close_dyn_buf(ctx->pb, &dummy_buf);\n    av_free(dummy_buf);\n\n    c->rtp_ctx[stream_index] = ctx;\n    return 0;\n}\n\n/********************************************************************/\n/* ffserver initialization */\n\nstatic AVStream *add_av_stream1(FFStream *stream, AVCodecContext *codec, int copy)\n{\n    AVStream *fst;\n\n    fst = av_mallocz(sizeof(AVStream));\n    if (!fst)\n        return NULL;\n    if (copy) {\n        fst->codec = avcodec_alloc_context3(NULL);\n        memcpy(fst->codec, codec, sizeof(AVCodecContext));\n        if (codec->extradata_size) {\n            fst->codec->extradata = av_malloc(codec->extradata_size);\n            memcpy(fst->codec->extradata, codec->extradata,\n                codec->extradata_size);\n        }\n    } else {\n        /* live streams must use the actual feed's codec since it may be\n         * updated later to carry extradata needed by the streams.\n         */\n        fst->codec = codec;\n    }\n    fst->priv_data = av_mallocz(sizeof(FeedData));\n    fst->index = stream->nb_streams;\n    avpriv_set_pts_info(fst, 33, 1, 90000);\n    fst->sample_aspect_ratio = codec->sample_aspect_ratio;\n    stream->streams[stream->nb_streams++] = fst;\n    return fst;\n}\n\n/* return the stream number in the feed */\nstatic int add_av_stream(FFStream *feed, AVStream *st)\n{\n    AVStream *fst;\n    AVCodecContext *av, *av1;\n    int i;\n\n    av = st->codec;\n    for(i=0;i<feed->nb_streams;i++) {\n        st = feed->streams[i];\n        av1 = st->codec;\n        if (av1->codec_id == av->codec_id &&\n            av1->codec_type == av->codec_type &&\n            av1->bit_rate == av->bit_rate) {\n\n            switch(av->codec_type) {\n            case AVMEDIA_TYPE_AUDIO:\n                if (av1->channels == av->channels &&\n                    av1->sample_rate == av->sample_rate)\n                    return i;\n                break;\n            case AVMEDIA_TYPE_VIDEO:\n                if (av1->width == av->width &&\n                    av1->height == av->height &&\n                    av1->time_base.den == av->time_base.den &&\n                    av1->time_base.num == av->time_base.num &&\n                    av1->gop_size == av->gop_size)\n                    return i;\n                break;\n            default:\n                abort();\n            }\n        }\n    }\n\n    fst = add_av_stream1(feed, av, 0);\n    if (!fst)\n        return -1;\n    return feed->nb_streams - 1;\n}\n\nstatic void remove_stream(FFStream *stream)\n{\n    FFStream **ps;\n    ps = &first_stream;\n    while (*ps != NULL) {\n        if (*ps == stream)\n            *ps = (*ps)->next;\n        else\n            ps = &(*ps)->next;\n    }\n}\n\n/* specific mpeg4 handling : we extract the raw parameters */\nstatic void extract_mpeg4_header(AVFormatContext *infile)\n{\n    int mpeg4_count, i, size;\n    AVPacket pkt;\n    AVStream *st;\n    const uint8_t *p;\n\n    mpeg4_count = 0;\n    for(i=0;i<infile->nb_streams;i++) {\n        st = infile->streams[i];\n        if (st->codec->codec_id == AV_CODEC_ID_MPEG4 &&\n            st->codec->extradata_size == 0) {\n            mpeg4_count++;\n        }\n    }\n    if (!mpeg4_count)\n        return;\n\n    printf(\"MPEG4 without extra data: trying to find header in %s\\n\", infile->filename);\n    while (mpeg4_count > 0) {\n        if (av_read_packet(infile, &pkt) < 0)\n            break;\n        st = infile->streams[pkt.stream_index];\n        if (st->codec->codec_id == AV_CODEC_ID_MPEG4 &&\n            st->codec->extradata_size == 0) {\n            av_freep(&st->codec->extradata);\n            /* fill extradata with the header */\n            /* XXX: we make hard suppositions here ! */\n            p = pkt.data;\n            while (p < pkt.data + pkt.size - 4) {\n                /* stop when vop header is found */\n                if (p[0] == 0x00 && p[1] == 0x00 &&\n                    p[2] == 0x01 && p[3] == 0xb6) {\n                    size = p - pkt.data;\n                    //                    av_hex_dump_log(infile, AV_LOG_DEBUG, pkt.data, size);\n                    st->codec->extradata = av_malloc(size);\n                    st->codec->extradata_size = size;\n                    memcpy(st->codec->extradata, pkt.data, size);\n                    break;\n                }\n                p++;\n            }\n            mpeg4_count--;\n        }\n        av_free_packet(&pkt);\n    }\n}\n\n/* compute the needed AVStream for each file */\nstatic void build_file_streams(void)\n{\n    FFStream *stream, *stream_next;\n    int i, ret;\n\n    /* gather all streams */\n    for(stream = first_stream; stream != NULL; stream = stream_next) {\n        AVFormatContext *infile = NULL;\n        stream_next = stream->next;\n        if (stream->stream_type == STREAM_TYPE_LIVE &&\n            !stream->feed) {\n            /* the stream comes from a file */\n            /* try to open the file */\n            /* open stream */\n            if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n                /* specific case : if transport stream output to RTP,\n                   we use a raw transport stream reader */\n                av_dict_set(&stream->in_opts, \"mpeg2ts_compute_pcr\", \"1\", 0);\n            }\n\n            http_log(\"Opening file '%s'\\n\", stream->feed_filename);\n            if ((ret = avformat_open_input(&infile, stream->feed_filename, stream->ifmt, &stream->in_opts)) < 0) {\n                http_log(\"Could not open '%s': %d\\n\", stream->feed_filename, ret);\n                /* remove stream (no need to spend more time on it) */\n            fail:\n                remove_stream(stream);\n            } else {\n                /* find all the AVStreams inside and reference them in\n                   'stream' */\n                if (avformat_find_stream_info(infile, NULL) < 0) {\n                    http_log(\"Could not find codec parameters from '%s'\\n\",\n                             stream->feed_filename);\n                    avformat_close_input(&infile);\n                    goto fail;\n                }\n                extract_mpeg4_header(infile);\n\n                for(i=0;i<infile->nb_streams;i++)\n                    add_av_stream1(stream, infile->streams[i]->codec, 1);\n\n                avformat_close_input(&infile);\n            }\n        }\n    }\n}\n\n/* compute the needed AVStream for each feed */\nstatic void build_feed_streams(void)\n{\n    FFStream *stream, *feed;\n    int i;\n\n    /* gather all streams */\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n        feed = stream->feed;\n        if (feed) {\n            if (stream->is_feed) {\n                for(i=0;i<stream->nb_streams;i++)\n                    stream->feed_streams[i] = i;\n            } else {\n                /* we handle a stream coming from a feed */\n                for(i=0;i<stream->nb_streams;i++)\n                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n            }\n        }\n    }\n\n    /* create feed files if needed */\n    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {\n        int fd;\n\n        if (avio_check(feed->feed_filename, AVIO_FLAG_READ) > 0) {\n            /* See if it matches */\n            AVFormatContext *s = NULL;\n            int matches = 0;\n\n            if (avformat_open_input(&s, feed->feed_filename, NULL, NULL) >= 0) {\n                /* set buffer size */\n                ffio_set_buf_size(s->pb, FFM_PACKET_SIZE);\n                /* Now see if it matches */\n                if (s->nb_streams == feed->nb_streams) {\n                    matches = 1;\n                    for(i=0;i<s->nb_streams;i++) {\n                        AVStream *sf, *ss;\n                        sf = feed->streams[i];\n                        ss = s->streams[i];\n\n                        if (sf->index != ss->index ||\n                            sf->id != ss->id) {\n                            http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n                                   i, feed->feed_filename);\n                            matches = 0;\n                        } else {\n                            AVCodecContext *ccf, *ccs;\n\n                            ccf = sf->codec;\n                            ccs = ss->codec;\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n                                http_log(\"Codecs do not match for stream %d\\n\", i);\n                                matches = 0;\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n                                http_log(\"Codec bitrates do not match for stream %d\\n\", i);\n                                matches = 0;\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {\n                                if (CHECK_CODEC(time_base.den) ||\n                                    CHECK_CODEC(time_base.num) ||\n                                    CHECK_CODEC(width) ||\n                                    CHECK_CODEC(height)) {\n                                    http_log(\"Codec width, height and framerate do not match for stream %d\\n\", i);\n                                    matches = 0;\n                                }\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {\n                                if (CHECK_CODEC(sample_rate) ||\n                                    CHECK_CODEC(channels) ||\n                                    CHECK_CODEC(frame_size)) {\n                                    http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", i);\n                                    matches = 0;\n                                }\n                            } else {\n                                http_log(\"Unknown codec type\\n\");\n                                matches = 0;\n                            }\n                        }\n                        if (!matches)\n                            break;\n                    }\n                } else\n                    http_log(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\",\n                        feed->feed_filename, s->nb_streams, feed->nb_streams);\n\n                avformat_close_input(&s);\n            } else\n                http_log(\"Deleting feed file '%s' as it appears to be corrupt\\n\",\n                        feed->feed_filename);\n\n            if (!matches) {\n                if (feed->readonly) {\n                    http_log(\"Unable to delete feed file '%s' as it is marked readonly\\n\",\n                        feed->feed_filename);\n                    exit(1);\n                }\n                unlink(feed->feed_filename);\n            }\n        }\n        if (avio_check(feed->feed_filename, AVIO_FLAG_WRITE) <= 0) {\n            AVFormatContext s1 = {0}, *s = &s1;\n\n            if (feed->readonly) {\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n                    feed->feed_filename);\n                exit(1);\n            }\n\n            /* only write the header of the ffm file */\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n                http_log(\"Could not open output feed file '%s'\\n\",\n                         feed->feed_filename);\n                exit(1);\n            }\n            s->oformat = feed->fmt;\n            s->nb_streams = feed->nb_streams;\n            s->streams = feed->streams;\n            if (avformat_write_header(s, NULL) < 0) {\n                http_log(\"Container doesn't support the required parameters\\n\");\n                exit(1);\n            }\n            /* XXX: need better api */\n            av_freep(&s->priv_data);\n            avio_close(s->pb);\n        }\n        /* get feed size and write index */\n        fd = open(feed->feed_filename, O_RDONLY);\n        if (fd < 0) {\n            http_log(\"Could not open output feed file '%s'\\n\",\n                    feed->feed_filename);\n            exit(1);\n        }\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n        /* ensure that we do not wrap before the end of file */\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n            feed->feed_max_size = feed->feed_size;\n\n        close(fd);\n    }\n}\n\n/* compute the bandwidth used by each stream */\nstatic void compute_bandwidth(void)\n{\n    unsigned bandwidth;\n    int i;\n    FFStream *stream;\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n        bandwidth = 0;\n        for(i=0;i<stream->nb_streams;i++) {\n            AVStream *st = stream->streams[i];\n            switch(st->codec->codec_type) {\n            case AVMEDIA_TYPE_AUDIO:\n            case AVMEDIA_TYPE_VIDEO:\n                bandwidth += st->codec->bit_rate;\n                break;\n            default:\n                break;\n            }\n        }\n        stream->bandwidth = (bandwidth + 999) / 1000;\n    }\n}\n\n/* add a codec and set the default parameters */\nstatic void add_codec(FFStream *stream, AVCodecContext *av)\n{\n    AVStream *st;\n\n    /* compute default parameters */\n    switch(av->codec_type) {\n    case AVMEDIA_TYPE_AUDIO:\n        if (av->bit_rate == 0)\n            av->bit_rate = 64000;\n        if (av->sample_rate == 0)\n            av->sample_rate = 22050;\n        if (av->channels == 0)\n            av->channels = 1;\n        break;\n    case AVMEDIA_TYPE_VIDEO:\n        if (av->bit_rate == 0)\n            av->bit_rate = 64000;\n        if (av->time_base.num == 0){\n            av->time_base.den = 5;\n            av->time_base.num = 1;\n        }\n        if (av->width == 0 || av->height == 0) {\n            av->width = 160;\n            av->height = 128;\n        }\n        /* Bitrate tolerance is less for streaming */\n        if (av->bit_rate_tolerance == 0)\n            av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,\n                      (int64_t)av->bit_rate*av->time_base.num/av->time_base.den);\n        if (av->qmin == 0)\n            av->qmin = 3;\n        if (av->qmax == 0)\n            av->qmax = 31;\n        if (av->max_qdiff == 0)\n            av->max_qdiff = 3;\n        av->qcompress = 0.5;\n        av->qblur = 0.5;\n\n        if (!av->nsse_weight)\n            av->nsse_weight = 8;\n\n        av->frame_skip_cmp = FF_CMP_DCTMAX;\n        if (!av->me_method)\n            av->me_method = ME_EPZS;\n        av->rc_buffer_aggressivity = 1.0;\n\n        if (!av->rc_eq)\n            av->rc_eq = \"tex^qComp\";\n        if (!av->i_quant_factor)\n            av->i_quant_factor = -0.8;\n        if (!av->b_quant_factor)\n            av->b_quant_factor = 1.25;\n        if (!av->b_quant_offset)\n            av->b_quant_offset = 1.25;\n        if (!av->rc_max_rate)\n            av->rc_max_rate = av->bit_rate * 2;\n\n        if (av->rc_max_rate && !av->rc_buffer_size) {\n            av->rc_buffer_size = av->rc_max_rate;\n        }\n\n\n        break;\n    default:\n        abort();\n    }\n\n    st = av_mallocz(sizeof(AVStream));\n    if (!st)\n        return;\n    st->codec = avcodec_alloc_context3(NULL);\n    stream->streams[stream->nb_streams++] = st;\n    memcpy(st->codec, av, sizeof(AVCodecContext));\n}\n\nstatic enum AVCodecID opt_audio_codec(const char *arg)\n{\n    AVCodec *p= avcodec_find_encoder_by_name(arg);\n\n    if (p == NULL || p->type != AVMEDIA_TYPE_AUDIO)\n        return AV_CODEC_ID_NONE;\n\n    return p->id;\n}\n\nstatic enum AVCodecID opt_video_codec(const char *arg)\n{\n    AVCodec *p= avcodec_find_encoder_by_name(arg);\n\n    if (p == NULL || p->type != AVMEDIA_TYPE_VIDEO)\n        return AV_CODEC_ID_NONE;\n\n    return p->id;\n}\n\n/* simplistic plugin support */\n\n#if HAVE_DLOPEN\nstatic void load_module(const char *filename)\n{\n    void *dll;\n    void (*init_func)(void);\n    dll = dlopen(filename, RTLD_NOW);\n    if (!dll) {\n        fprintf(stderr, \"Could not load module '%s' - %s\\n\",\n                filename, dlerror());\n        return;\n    }\n\n    init_func = dlsym(dll, \"ffserver_module_init\");\n    if (!init_func) {\n        fprintf(stderr,\n                \"%s: init function 'ffserver_module_init()' not found\\n\",\n                filename);\n        dlclose(dll);\n    }\n\n    init_func();\n}\n#endif\n\nstatic int ffserver_opt_default(const char *opt, const char *arg,\n                       AVCodecContext *avctx, int type)\n{\n    int ret = 0;\n    const AVOption *o = av_opt_find(avctx, opt, NULL, type, 0);\n    if(o)\n        ret = av_opt_set(avctx, opt, arg, 0);\n    return ret;\n}\n\nstatic int ffserver_opt_preset(const char *arg,\n                       AVCodecContext *avctx, int type,\n                       enum AVCodecID *audio_id, enum AVCodecID *video_id)\n{\n    FILE *f=NULL;\n    char filename[1000], tmp[1000], tmp2[1000], line[1000];\n    int ret = 0;\n    AVCodec *codec = avcodec_find_encoder(avctx->codec_id);\n\n    if (!(f = get_preset_file(filename, sizeof(filename), arg, 0,\n                              codec ? codec->name : NULL))) {\n        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);\n        return 1;\n    }\n\n    while(!feof(f)){\n        int e= fscanf(f, \"%999[^\\n]\\n\", line) - 1;\n        if(line[0] == '#' && !e)\n            continue;\n        e|= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;\n        if(e){\n            fprintf(stderr, \"%s: Invalid syntax: '%s'\\n\", filename, line);\n            ret = 1;\n            break;\n        }\n        if(!strcmp(tmp, \"acodec\")){\n            *audio_id = opt_audio_codec(tmp2);\n        }else if(!strcmp(tmp, \"vcodec\")){\n            *video_id = opt_video_codec(tmp2);\n        }else if(!strcmp(tmp, \"scodec\")){\n            /* opt_subtitle_codec(tmp2); */\n        }else if(ffserver_opt_default(tmp, tmp2, avctx, type) < 0){\n            fprintf(stderr, \"%s: Invalid option or argument: '%s', parsed as '%s' = '%s'\\n\", filename, line, tmp, tmp2);\n            ret = 1;\n            break;\n        }\n    }\n\n    fclose(f);\n\n    return ret;\n}\n\nstatic AVOutputFormat *ffserver_guess_format(const char *short_name, const char *filename,\n                                             const char *mime_type)\n{\n    AVOutputFormat *fmt = av_guess_format(short_name, filename, mime_type);\n\n    if (fmt) {\n        AVOutputFormat *stream_fmt;\n        char stream_format_name[64];\n\n        snprintf(stream_format_name, sizeof(stream_format_name), \"%s_stream\", fmt->name);\n        stream_fmt = av_guess_format(stream_format_name, NULL, NULL);\n\n        if (stream_fmt)\n            fmt = stream_fmt;\n    }\n\n    return fmt;\n}\n\nstatic void report_config_error(const char *filename, int line_num, int *errors, const char *fmt, ...)\n{\n    va_list vl;\n    va_start(vl, fmt);\n    fprintf(stderr, \"%s:%d: \", filename, line_num);\n    vfprintf(stderr, fmt, vl);\n    va_end(vl);\n\n    (*errors)++;\n}\n\nstatic int parse_ffconfig(const char *filename)\n{\n    FILE *f;\n    char line[1024];\n    char cmd[64];\n    char arg[1024];\n    const char *p;\n    int val, errors, line_num;\n    FFStream **last_stream, *stream, *redirect;\n    FFStream **last_feed, *feed, *s;\n    AVCodecContext audio_enc, video_enc;\n    enum AVCodecID audio_id, video_id;\n\n    f = fopen(filename, \"r\");\n    if (!f) {\n        perror(filename);\n        return -1;\n    }\n\n    errors = 0;\n    line_num = 0;\n    first_stream = NULL;\n    last_stream = &first_stream;\n    first_feed = NULL;\n    last_feed = &first_feed;\n    stream = NULL;\n    feed = NULL;\n    redirect = NULL;\n    audio_id = AV_CODEC_ID_NONE;\n    video_id = AV_CODEC_ID_NONE;\n\n#define ERROR(...) report_config_error(filename, line_num, &errors, __VA_ARGS__)\n    for(;;) {\n        if (fgets(line, sizeof(line), f) == NULL)\n            break;\n        line_num++;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '\\0' || *p == '#')\n            continue;\n\n        get_arg(cmd, sizeof(cmd), &p);\n\n        if (!av_strcasecmp(cmd, \"Port\")) {\n            get_arg(arg, sizeof(arg), &p);\n            val = atoi(arg);\n            if (val < 1 || val > 65536) {\n                ERROR(\"Invalid_port: %s\\n\", arg);\n            }\n            my_http_addr.sin_port = htons(val);\n        } else if (!av_strcasecmp(cmd, \"BindAddress\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (resolve_host(&my_http_addr.sin_addr, arg) != 0) {\n                ERROR(\"%s:%d: Invalid host/IP address: %s\\n\", arg);\n            }\n        } else if (!av_strcasecmp(cmd, \"NoDaemon\")) {\n            ffserver_daemon = 0;\n        } else if (!av_strcasecmp(cmd, \"RTSPPort\")) {\n            get_arg(arg, sizeof(arg), &p);\n            val = atoi(arg);\n            if (val < 1 || val > 65536) {\n                ERROR(\"%s:%d: Invalid port: %s\\n\", arg);\n            }\n            my_rtsp_addr.sin_port = htons(atoi(arg));\n        } else if (!av_strcasecmp(cmd, \"RTSPBindAddress\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (resolve_host(&my_rtsp_addr.sin_addr, arg) != 0) {\n                ERROR(\"Invalid host/IP address: %s\\n\", arg);\n            }\n        } else if (!av_strcasecmp(cmd, \"MaxHTTPConnections\")) {\n            get_arg(arg, sizeof(arg), &p);\n            val = atoi(arg);\n            if (val < 1 || val > 65536) {\n                ERROR(\"Invalid MaxHTTPConnections: %s\\n\", arg);\n            }\n            nb_max_http_connections = val;\n        } else if (!av_strcasecmp(cmd, \"MaxClients\")) {\n            get_arg(arg, sizeof(arg), &p);\n            val = atoi(arg);\n            if (val < 1 || val > nb_max_http_connections) {\n                ERROR(\"Invalid MaxClients: %s\\n\", arg);\n            } else {\n                nb_max_connections = val;\n            }\n        } else if (!av_strcasecmp(cmd, \"MaxBandwidth\")) {\n            int64_t llval;\n            get_arg(arg, sizeof(arg), &p);\n            llval = atoll(arg);\n            if (llval < 10 || llval > 10000000) {\n                ERROR(\"Invalid MaxBandwidth: %s\\n\", arg);\n            } else\n                max_bandwidth = llval;\n        } else if (!av_strcasecmp(cmd, \"CustomLog\")) {\n            if (!ffserver_debug)\n                get_arg(logfilename, sizeof(logfilename), &p);\n        } else if (!av_strcasecmp(cmd, \"<Feed\")) {\n            /*********************************************/\n            /* Feed related options */\n            char *q;\n            if (stream || feed) {\n                ERROR(\"Already in a tag\\n\");\n            } else {\n                feed = av_mallocz(sizeof(FFStream));\n                get_arg(feed->filename, sizeof(feed->filename), &p);\n                q = strrchr(feed->filename, '>');\n                if (*q)\n                    *q = '\\0';\n\n                for (s = first_feed; s; s = s->next) {\n                    if (!strcmp(feed->filename, s->filename)) {\n                        ERROR(\"Feed '%s' already registered\\n\", s->filename);\n                    }\n                }\n\n                feed->fmt = av_guess_format(\"ffm\", NULL, NULL);\n                /* defaut feed file */\n                snprintf(feed->feed_filename, sizeof(feed->feed_filename),\n                         \"/tmp/%s.ffm\", feed->filename);\n                feed->feed_max_size = 5 * 1024 * 1024;\n                feed->is_feed = 1;\n                feed->feed = feed; /* self feeding :-) */\n\n                /* add in stream list */\n                *last_stream = feed;\n                last_stream = &feed->next;\n                /* add in feed list */\n                *last_feed = feed;\n                last_feed = &feed->next_feed;\n            }\n        } else if (!av_strcasecmp(cmd, \"Launch\")) {\n            if (feed) {\n                int i;\n\n                feed->child_argv = av_mallocz(64 * sizeof(char *));\n\n                for (i = 0; i < 62; i++) {\n                    get_arg(arg, sizeof(arg), &p);\n                    if (!arg[0])\n                        break;\n\n                    feed->child_argv[i] = av_strdup(arg);\n                }\n\n                feed->child_argv[i] = av_malloc(30 + strlen(feed->filename));\n\n                snprintf(feed->child_argv[i], 30+strlen(feed->filename),\n                    \"http://%s:%d/%s\",\n                        (my_http_addr.sin_addr.s_addr == INADDR_ANY) ? \"127.0.0.1\" :\n                    inet_ntoa(my_http_addr.sin_addr),\n                    ntohs(my_http_addr.sin_port), feed->filename);\n            }\n        } else if (!av_strcasecmp(cmd, \"ReadOnlyFile\")) {\n            if (feed) {\n                get_arg(feed->feed_filename, sizeof(feed->feed_filename), &p);\n                feed->readonly = 1;\n            } else if (stream) {\n                get_arg(stream->feed_filename, sizeof(stream->feed_filename), &p);\n            }\n        } else if (!av_strcasecmp(cmd, \"File\")) {\n            if (feed) {\n                get_arg(feed->feed_filename, sizeof(feed->feed_filename), &p);\n            } else if (stream)\n                get_arg(stream->feed_filename, sizeof(stream->feed_filename), &p);\n        } else if (!av_strcasecmp(cmd, \"Truncate\")) {\n            if (feed) {\n                get_arg(arg, sizeof(arg), &p);\n                feed->truncate = strtod(arg, NULL);\n            }\n        } else if (!av_strcasecmp(cmd, \"FileMaxSize\")) {\n            if (feed) {\n                char *p1;\n                double fsize;\n\n                get_arg(arg, sizeof(arg), &p);\n                p1 = arg;\n                fsize = strtod(p1, &p1);\n                switch(toupper(*p1)) {\n                case 'K':\n                    fsize *= 1024;\n                    break;\n                case 'M':\n                    fsize *= 1024 * 1024;\n                    break;\n                case 'G':\n                    fsize *= 1024 * 1024 * 1024;\n                    break;\n                }\n                feed->feed_max_size = (int64_t)fsize;\n                if (feed->feed_max_size < FFM_PACKET_SIZE*4) {\n                    ERROR(\"Feed max file size is too small, must be at least %d\\n\", FFM_PACKET_SIZE*4);\n                }\n            }\n        } else if (!av_strcasecmp(cmd, \"</Feed>\")) {\n            if (!feed) {\n                ERROR(\"No corresponding <Feed> for </Feed>\\n\");\n            }\n            feed = NULL;\n        } else if (!av_strcasecmp(cmd, \"<Stream\")) {\n            /*********************************************/\n            /* Stream related options */\n            char *q;\n            if (stream || feed) {\n                ERROR(\"Already in a tag\\n\");\n            } else {\n                FFStream *s;\n                stream = av_mallocz(sizeof(FFStream));\n                get_arg(stream->filename, sizeof(stream->filename), &p);\n                q = strrchr(stream->filename, '>');\n                if (*q)\n                    *q = '\\0';\n\n                for (s = first_stream; s; s = s->next) {\n                    if (!strcmp(stream->filename, s->filename)) {\n                        ERROR(\"Stream '%s' already registered\\n\", s->filename);\n                    }\n                }\n\n                stream->fmt = ffserver_guess_format(NULL, stream->filename, NULL);\n                avcodec_get_context_defaults3(&video_enc, NULL);\n                avcodec_get_context_defaults3(&audio_enc, NULL);\n\n                audio_id = AV_CODEC_ID_NONE;\n                video_id = AV_CODEC_ID_NONE;\n                if (stream->fmt) {\n                    audio_id = stream->fmt->audio_codec;\n                    video_id = stream->fmt->video_codec;\n                }\n\n                *last_stream = stream;\n                last_stream = &stream->next;\n            }\n        } else if (!av_strcasecmp(cmd, \"Feed\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                FFStream *sfeed;\n\n                sfeed = first_feed;\n                while (sfeed != NULL) {\n                    if (!strcmp(sfeed->filename, arg))\n                        break;\n                    sfeed = sfeed->next_feed;\n                }\n                if (!sfeed)\n                    ERROR(\"feed '%s' not defined\\n\", arg);\n                else\n                    stream->feed = sfeed;\n            }\n        } else if (!av_strcasecmp(cmd, \"Format\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                if (!strcmp(arg, \"status\")) {\n                    stream->stream_type = STREAM_TYPE_STATUS;\n                    stream->fmt = NULL;\n                } else {\n                    stream->stream_type = STREAM_TYPE_LIVE;\n                    /* jpeg cannot be used here, so use single frame jpeg */\n                    if (!strcmp(arg, \"jpeg\"))\n                        strcpy(arg, \"mjpeg\");\n                    stream->fmt = ffserver_guess_format(arg, NULL, NULL);\n                    if (!stream->fmt) {\n                        ERROR(\"Unknown Format: %s\\n\", arg);\n                    }\n                }\n                if (stream->fmt) {\n                    audio_id = stream->fmt->audio_codec;\n                    video_id = stream->fmt->video_codec;\n                }\n            }\n        } else if (!av_strcasecmp(cmd, \"InputFormat\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                stream->ifmt = av_find_input_format(arg);\n                if (!stream->ifmt) {\n                    ERROR(\"Unknown input format: %s\\n\", arg);\n                }\n            }\n        } else if (!av_strcasecmp(cmd, \"FaviconURL\")) {\n            if (stream && stream->stream_type == STREAM_TYPE_STATUS) {\n                get_arg(stream->feed_filename, sizeof(stream->feed_filename), &p);\n            } else {\n                ERROR(\"FaviconURL only permitted for status streams\\n\");\n            }\n        } else if (!av_strcasecmp(cmd, \"Author\")) {\n            if (stream)\n                get_arg(stream->author, sizeof(stream->author), &p);\n        } else if (!av_strcasecmp(cmd, \"Comment\")) {\n            if (stream)\n                get_arg(stream->comment, sizeof(stream->comment), &p);\n        } else if (!av_strcasecmp(cmd, \"Copyright\")) {\n            if (stream)\n                get_arg(stream->copyright, sizeof(stream->copyright), &p);\n        } else if (!av_strcasecmp(cmd, \"Title\")) {\n            if (stream)\n                get_arg(stream->title, sizeof(stream->title), &p);\n        } else if (!av_strcasecmp(cmd, \"Preroll\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                stream->prebuffer = atof(arg) * 1000;\n        } else if (!av_strcasecmp(cmd, \"StartSendOnKey\")) {\n            if (stream)\n                stream->send_on_key = 1;\n        } else if (!av_strcasecmp(cmd, \"AudioCodec\")) {\n            get_arg(arg, sizeof(arg), &p);\n            audio_id = opt_audio_codec(arg);\n            if (audio_id == AV_CODEC_ID_NONE) {\n                ERROR(\"Unknown AudioCodec: %s\\n\", arg);\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoCodec\")) {\n            get_arg(arg, sizeof(arg), &p);\n            video_id = opt_video_codec(arg);\n            if (video_id == AV_CODEC_ID_NONE) {\n                ERROR(\"Unknown VideoCodec: %s\\n\", arg);\n            }\n        } else if (!av_strcasecmp(cmd, \"MaxTime\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                stream->max_time = atof(arg) * 1000;\n        } else if (!av_strcasecmp(cmd, \"AudioBitRate\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                audio_enc.bit_rate = lrintf(atof(arg) * 1000);\n        } else if (!av_strcasecmp(cmd, \"AudioChannels\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                audio_enc.channels = atoi(arg);\n        } else if (!av_strcasecmp(cmd, \"AudioSampleRate\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                audio_enc.sample_rate = atoi(arg);\n        } else if (!av_strcasecmp(cmd, \"AudioQuality\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n//                audio_enc.quality = atof(arg) * 1000;\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoBitRateRange\")) {\n            if (stream) {\n                int minrate, maxrate;\n\n                get_arg(arg, sizeof(arg), &p);\n\n                if (sscanf(arg, \"%d-%d\", &minrate, &maxrate) == 2) {\n                    video_enc.rc_min_rate = minrate * 1000;\n                    video_enc.rc_max_rate = maxrate * 1000;\n                } else {\n                    ERROR(\"Incorrect format for VideoBitRateRange -- should be <min>-<max>: %s\\n\", arg);\n                }\n            }\n        } else if (!av_strcasecmp(cmd, \"Debug\")) {\n            if (stream) {\n                get_arg(arg, sizeof(arg), &p);\n                video_enc.debug = strtol(arg,0,0);\n            }\n        } else if (!av_strcasecmp(cmd, \"Strict\")) {\n            if (stream) {\n                get_arg(arg, sizeof(arg), &p);\n                video_enc.strict_std_compliance = atoi(arg);\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoBufferSize\")) {\n            if (stream) {\n                get_arg(arg, sizeof(arg), &p);\n                video_enc.rc_buffer_size = atoi(arg) * 8*1024;\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoBitRateTolerance\")) {\n            if (stream) {\n                get_arg(arg, sizeof(arg), &p);\n                video_enc.bit_rate_tolerance = atoi(arg) * 1000;\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoBitRate\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                video_enc.bit_rate = atoi(arg) * 1000;\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoSize\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                av_parse_video_size(&video_enc.width, &video_enc.height, arg);\n                if ((video_enc.width % 16) != 0 ||\n                    (video_enc.height % 16) != 0) {\n                    ERROR(\"Image size must be a multiple of 16\\n\");\n                }\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoFrameRate\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                AVRational frame_rate;\n                if (av_parse_video_rate(&frame_rate, arg) < 0) {\n                    ERROR(\"Incorrect frame rate: %s\\n\", arg);\n                } else {\n                    video_enc.time_base.num = frame_rate.den;\n                    video_enc.time_base.den = frame_rate.num;\n                }\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoGopSize\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                video_enc.gop_size = atoi(arg);\n        } else if (!av_strcasecmp(cmd, \"VideoIntraOnly\")) {\n            if (stream)\n                video_enc.gop_size = 1;\n        } else if (!av_strcasecmp(cmd, \"VideoHighQuality\")) {\n            if (stream)\n                video_enc.mb_decision = FF_MB_DECISION_BITS;\n        } else if (!av_strcasecmp(cmd, \"Video4MotionVector\")) {\n            if (stream) {\n                video_enc.mb_decision = FF_MB_DECISION_BITS; //FIXME remove\n                video_enc.flags |= CODEC_FLAG_4MV;\n            }\n        } else if (!av_strcasecmp(cmd, \"AVOptionVideo\") ||\n                   !av_strcasecmp(cmd, \"AVOptionAudio\")) {\n            char arg2[1024];\n            AVCodecContext *avctx;\n            int type;\n            get_arg(arg, sizeof(arg), &p);\n            get_arg(arg2, sizeof(arg2), &p);\n            if (!av_strcasecmp(cmd, \"AVOptionVideo\")) {\n                avctx = &video_enc;\n                type = AV_OPT_FLAG_VIDEO_PARAM;\n            } else {\n                avctx = &audio_enc;\n                type = AV_OPT_FLAG_AUDIO_PARAM;\n            }\n            if (ffserver_opt_default(arg, arg2, avctx, type|AV_OPT_FLAG_ENCODING_PARAM)) {\n                ERROR(\"AVOption error: %s %s\\n\", arg, arg2);\n            }\n        } else if (!av_strcasecmp(cmd, \"AVPresetVideo\") ||\n                   !av_strcasecmp(cmd, \"AVPresetAudio\")) {\n            AVCodecContext *avctx;\n            int type;\n            get_arg(arg, sizeof(arg), &p);\n            if (!av_strcasecmp(cmd, \"AVPresetVideo\")) {\n                avctx = &video_enc;\n                video_enc.codec_id = video_id;\n                type = AV_OPT_FLAG_VIDEO_PARAM;\n            } else {\n                avctx = &audio_enc;\n                audio_enc.codec_id = audio_id;\n                type = AV_OPT_FLAG_AUDIO_PARAM;\n            }\n            if (ffserver_opt_preset(arg, avctx, type|AV_OPT_FLAG_ENCODING_PARAM, &audio_id, &video_id)) {\n                ERROR(\"AVPreset error: %s\\n\", arg);\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoTag\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if ((strlen(arg) == 4) && stream)\n                video_enc.codec_tag = MKTAG(arg[0], arg[1], arg[2], arg[3]);\n        } else if (!av_strcasecmp(cmd, \"BitExact\")) {\n            if (stream)\n                video_enc.flags |= CODEC_FLAG_BITEXACT;\n        } else if (!av_strcasecmp(cmd, \"DctFastint\")) {\n            if (stream)\n                video_enc.dct_algo  = FF_DCT_FASTINT;\n        } else if (!av_strcasecmp(cmd, \"IdctSimple\")) {\n            if (stream)\n                video_enc.idct_algo = FF_IDCT_SIMPLE;\n        } else if (!av_strcasecmp(cmd, \"Qscale\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                video_enc.flags |= CODEC_FLAG_QSCALE;\n                video_enc.global_quality = FF_QP2LAMBDA * atoi(arg);\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoQDiff\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                video_enc.max_qdiff = atoi(arg);\n                if (video_enc.max_qdiff < 1 || video_enc.max_qdiff > 31) {\n                    ERROR(\"VideoQDiff out of range\\n\");\n                }\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoQMax\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                video_enc.qmax = atoi(arg);\n                if (video_enc.qmax < 1 || video_enc.qmax > 31) {\n                    ERROR(\"VideoQMax out of range\\n\");\n                }\n            }\n        } else if (!av_strcasecmp(cmd, \"VideoQMin\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                video_enc.qmin = atoi(arg);\n                if (video_enc.qmin < 1 || video_enc.qmin > 31) {\n                    ERROR(\"VideoQMin out of range\\n\");\n                }\n            }\n        } else if (!av_strcasecmp(cmd, \"LumaElim\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                video_enc.luma_elim_threshold = atoi(arg);\n        } else if (!av_strcasecmp(cmd, \"ChromaElim\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                video_enc.chroma_elim_threshold = atoi(arg);\n        } else if (!av_strcasecmp(cmd, \"LumiMask\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                video_enc.lumi_masking = atof(arg);\n        } else if (!av_strcasecmp(cmd, \"DarkMask\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                video_enc.dark_masking = atof(arg);\n        } else if (!av_strcasecmp(cmd, \"NoVideo\")) {\n            video_id = AV_CODEC_ID_NONE;\n        } else if (!av_strcasecmp(cmd, \"NoAudio\")) {\n            audio_id = AV_CODEC_ID_NONE;\n        } else if (!av_strcasecmp(cmd, \"ACL\")) {\n            parse_acl_row(stream, feed, NULL, p, filename, line_num);\n        } else if (!av_strcasecmp(cmd, \"DynamicACL\")) {\n            if (stream) {\n                get_arg(stream->dynamic_acl, sizeof(stream->dynamic_acl), &p);\n            }\n        } else if (!av_strcasecmp(cmd, \"RTSPOption\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                av_freep(&stream->rtsp_option);\n                stream->rtsp_option = av_strdup(arg);\n            }\n        } else if (!av_strcasecmp(cmd, \"MulticastAddress\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream) {\n                if (resolve_host(&stream->multicast_ip, arg) != 0) {\n                    ERROR(\"Invalid host/IP address: %s\\n\", arg);\n                }\n                stream->is_multicast = 1;\n                stream->loop = 1; /* default is looping */\n            }\n        } else if (!av_strcasecmp(cmd, \"MulticastPort\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                stream->multicast_port = atoi(arg);\n        } else if (!av_strcasecmp(cmd, \"MulticastTTL\")) {\n            get_arg(arg, sizeof(arg), &p);\n            if (stream)\n                stream->multicast_ttl = atoi(arg);\n        } else if (!av_strcasecmp(cmd, \"NoLoop\")) {\n            if (stream)\n                stream->loop = 0;\n        } else if (!av_strcasecmp(cmd, \"</Stream>\")) {\n            if (!stream) {\n                ERROR(\"No corresponding <Stream> for </Stream>\\n\");\n            } else {\n                if (stream->feed && stream->fmt && strcmp(stream->fmt->name, \"ffm\") != 0) {\n                    if (audio_id != AV_CODEC_ID_NONE) {\n                        audio_enc.codec_type = AVMEDIA_TYPE_AUDIO;\n                        audio_enc.codec_id = audio_id;\n                        add_codec(stream, &audio_enc);\n                    }\n                    if (video_id != AV_CODEC_ID_NONE) {\n                        video_enc.codec_type = AVMEDIA_TYPE_VIDEO;\n                        video_enc.codec_id = video_id;\n                        add_codec(stream, &video_enc);\n                    }\n                }\n                stream = NULL;\n            }\n        } else if (!av_strcasecmp(cmd, \"<Redirect\")) {\n            /*********************************************/\n            char *q;\n            if (stream || feed || redirect) {\n                ERROR(\"Already in a tag\\n\");\n            } else {\n                redirect = av_mallocz(sizeof(FFStream));\n                *last_stream = redirect;\n                last_stream = &redirect->next;\n\n                get_arg(redirect->filename, sizeof(redirect->filename), &p);\n                q = strrchr(redirect->filename, '>');\n                if (*q)\n                    *q = '\\0';\n                redirect->stream_type = STREAM_TYPE_REDIRECT;\n            }\n        } else if (!av_strcasecmp(cmd, \"URL\")) {\n            if (redirect)\n                get_arg(redirect->feed_filename, sizeof(redirect->feed_filename), &p);\n        } else if (!av_strcasecmp(cmd, \"</Redirect>\")) {\n            if (!redirect) {\n                ERROR(\"No corresponding <Redirect> for </Redirect>\\n\");\n            } else {\n                if (!redirect->feed_filename[0]) {\n                    ERROR(\"No URL found for <Redirect>\\n\");\n                }\n                redirect = NULL;\n            }\n        } else if (!av_strcasecmp(cmd, \"LoadModule\")) {\n            get_arg(arg, sizeof(arg), &p);\n#if HAVE_DLOPEN\n            load_module(arg);\n#else\n            ERROR(\"Module support not compiled into this version: '%s'\\n\", arg);\n#endif\n        } else {\n            ERROR(\"Incorrect keyword: '%s'\\n\", cmd);\n        }\n    }\n#undef ERROR\n\n    fclose(f);\n    if (errors)\n        return -1;\n    else\n        return 0;\n}\n\nstatic void handle_child_exit(int sig)\n{\n    pid_t pid;\n    int status;\n\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        FFStream *feed;\n\n        for (feed = first_feed; feed; feed = feed->next) {\n            if (feed->pid == pid) {\n                int uptime = time(0) - feed->pid_start;\n\n                feed->pid = 0;\n                fprintf(stderr, \"%s: Pid %d exited with status %d after %d seconds\\n\", feed->filename, pid, status, uptime);\n\n                if (uptime < 30)\n                    /* Turn off any more restarts */\n                    feed->child_argv = 0;\n            }\n        }\n    }\n\n    need_to_start_children = 1;\n}\n\nstatic void opt_debug(void)\n{\n    ffserver_debug = 1;\n    ffserver_daemon = 0;\n    logfilename[0] = '-';\n}\n\nvoid show_help_default(const char *opt, const char *arg)\n{\n    printf(\"usage: ffserver [options]\\n\"\n           \"Hyper fast multi format Audio/Video streaming server\\n\");\n    printf(\"\\n\");\n    show_help_options(options, \"Main options:\", 0, 0, 0);\n}\n\nstatic const OptionDef options[] = {\n#include \"cmdutils_common_opts.h\"\n    { \"n\", OPT_BOOL, {(void *)&no_launch }, \"enable no-launch mode\" },\n    { \"d\", 0, {(void*)opt_debug}, \"enable debug mode\" },\n    { \"f\", HAS_ARG | OPT_STRING, {(void*)&config_filename }, \"use configfile instead of /etc/ffserver.conf\", \"configfile\" },\n    { NULL },\n};\n\nint main(int argc, char **argv)\n{\n    struct sigaction sigact = { { 0 } };\n\n    parse_loglevel(argc, argv, options);\n    av_register_all();\n    avformat_network_init();\n\n    show_banner(argc, argv, options);\n\n    my_program_name = argv[0];\n    my_program_dir = getcwd(0, 0);\n    ffserver_daemon = 1;\n\n    parse_options(NULL, argc, argv, options, NULL);\n\n    unsetenv(\"http_proxy\");             /* Kill the http_proxy */\n\n    av_lfg_init(&random_state, av_get_random_seed());\n\n    sigact.sa_handler = handle_child_exit;\n    sigact.sa_flags = SA_NOCLDSTOP | SA_RESTART;\n    sigaction(SIGCHLD, &sigact, 0);\n\n    if (parse_ffconfig(config_filename) < 0) {\n        fprintf(stderr, \"Incorrect config file - exiting.\\n\");\n        exit(1);\n    }\n\n    /* open log file if needed */\n    if (logfilename[0] != '\\0') {\n        if (!strcmp(logfilename, \"-\"))\n            logfile = stdout;\n        else\n            logfile = fopen(logfilename, \"a\");\n        av_log_set_callback(http_av_log);\n    }\n\n    build_file_streams();\n\n    build_feed_streams();\n\n    compute_bandwidth();\n\n    /* put the process in background and detach it from its TTY */\n    if (ffserver_daemon) {\n        int pid;\n\n        pid = fork();\n        if (pid < 0) {\n            perror(\"fork\");\n            exit(1);\n        } else if (pid > 0) {\n            /* parent : exit */\n            exit(0);\n        } else {\n            /* child */\n            setsid();\n            close(0);\n            open(\"/dev/null\", O_RDWR);\n            if (strcmp(logfilename, \"-\") != 0) {\n                close(1);\n                dup(0);\n            }\n            close(2);\n            dup(0);\n        }\n    }\n\n    /* signal init */\n    signal(SIGPIPE, SIG_IGN);\n\n    if (ffserver_daemon)\n        chdir(\"/\");\n\n    if (http_server() < 0) {\n        http_log(\"Could not start server\\n\");\n        exit(1);\n    }\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ffmpeg-1.0.10-ggwvgpzorieko7332epwc5znp55xiwtk/spack-src/libavfilter/vf_frei0r.c": "/*\n * Copyright (c) 2010 Stefano Sabatini\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * frei0r wrapper\n */\n\n/* #define DEBUG */\n\n#include <dlfcn.h>\n#include <frei0r.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"config.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/mem.h\"\n#include \"libavutil/parseutils.h\"\n#include \"avfilter.h\"\n#include \"formats.h\"\n#include \"internal.h\"\n#include \"video.h\"\n\ntypedef f0r_instance_t (*f0r_construct_f)(unsigned int width, unsigned int height);\ntypedef void (*f0r_destruct_f)(f0r_instance_t instance);\ntypedef void (*f0r_deinit_f)(void);\ntypedef int (*f0r_init_f)(void);\ntypedef void (*f0r_get_plugin_info_f)(f0r_plugin_info_t *info);\ntypedef void (*f0r_get_param_info_f)(f0r_param_info_t *info, int param_index);\ntypedef void (*f0r_update_f)(f0r_instance_t instance, double time, const uint32_t *inframe, uint32_t *outframe);\ntypedef void (*f0r_update2_f)(f0r_instance_t instance, double time, const uint32_t *inframe1, const uint32_t *inframe2, const uint32_t *inframe3, uint32_t *outframe);\ntypedef void (*f0r_set_param_value_f)(f0r_instance_t instance, f0r_param_t param, int param_index);\ntypedef void (*f0r_get_param_value_f)(f0r_instance_t instance, f0r_param_t param, int param_index);\n\ntypedef struct Frei0rContext {\n    f0r_update_f update;\n    void *dl_handle;            /* dynamic library handle   */\n    f0r_instance_t instance;\n    f0r_plugin_info_t plugin_info;\n\n    f0r_get_param_info_f  get_param_info;\n    f0r_get_param_value_f get_param_value;\n    f0r_set_param_value_f set_param_value;\n    f0r_construct_f       construct;\n    f0r_destruct_f        destruct;\n    f0r_deinit_f          deinit;\n    char params[256];\n\n    /* only used by the source */\n    int w, h;\n    AVRational time_base;\n    uint64_t pts;\n} Frei0rContext;\n\nstatic void *load_sym(AVFilterContext *ctx, const char *sym_name)\n{\n    Frei0rContext *frei0r = ctx->priv;\n    void *sym = dlsym(frei0r->dl_handle, sym_name);\n    if (!sym)\n        av_log(ctx, AV_LOG_ERROR, \"Could not find symbol '%s' in loaded module\\n\", sym_name);\n    return sym;\n}\n\nstatic int set_param(AVFilterContext *ctx, f0r_param_info_t info, int index, char *param)\n{\n    Frei0rContext *frei0r = ctx->priv;\n    union {\n        double d;\n        f0r_param_color_t col;\n        f0r_param_position_t pos;\n    } val;\n    char *tail;\n    uint8_t rgba[4];\n\n    switch (info.type) {\n    case F0R_PARAM_BOOL:\n        if      (!strcmp(param, \"y\")) val.d = 1.0;\n        else if (!strcmp(param, \"n\")) val.d = 0.0;\n        else goto fail;\n        break;\n\n    case F0R_PARAM_DOUBLE:\n        val.d = strtod(param, &tail);\n        if (*tail || val.d == HUGE_VAL)\n            goto fail;\n        break;\n\n    case F0R_PARAM_COLOR:\n        if (sscanf(param, \"%f/%f/%f\", &val.col.r, &val.col.g, &val.col.b) != 3) {\n            if (av_parse_color(rgba, param, -1, ctx) < 0)\n                goto fail;\n            val.col.r = rgba[0] / 255.0;\n            val.col.g = rgba[1] / 255.0;\n            val.col.b = rgba[2] / 255.0;\n        }\n        break;\n\n    case F0R_PARAM_POSITION:\n        if (sscanf(param, \"%lf/%lf\", &val.pos.x, &val.pos.y) != 2)\n            goto fail;\n        break;\n    }\n\n    frei0r->set_param_value(frei0r->instance, &val, index);\n    return 0;\n\nfail:\n    av_log(ctx, AV_LOG_ERROR, \"Invalid value '%s' for parameter '%s'\\n\",\n           param, info.name);\n    return AVERROR(EINVAL);\n}\n\nstatic int set_params(AVFilterContext *ctx, const char *params)\n{\n    Frei0rContext *frei0r = ctx->priv;\n    int i;\n\n    for (i = 0; i < frei0r->plugin_info.num_params; i++) {\n        f0r_param_info_t info;\n        char *param;\n        int ret;\n\n        frei0r->get_param_info(&info, i);\n\n        if (*params) {\n            if (!(param = av_get_token(&params, \":\")))\n                return AVERROR(ENOMEM);\n            params++;               /* skip ':' */\n            ret = set_param(ctx, info, i, param);\n            av_free(param);\n            if (ret < 0)\n                return ret;\n        }\n\n        av_log(ctx, AV_LOG_VERBOSE,\n               \"idx:%d name:'%s' type:%s explanation:'%s' \",\n               i, info.name,\n               info.type == F0R_PARAM_BOOL     ? \"bool\"     :\n               info.type == F0R_PARAM_DOUBLE   ? \"double\"   :\n               info.type == F0R_PARAM_COLOR    ? \"color\"    :\n               info.type == F0R_PARAM_POSITION ? \"position\" :\n               info.type == F0R_PARAM_STRING   ? \"string\"   : \"unknown\",\n               info.explanation);\n\n#ifdef DEBUG\n        av_log(ctx, AV_LOG_DEBUG, \"value:\");\n        switch (info.type) {\n            void *v;\n            double d;\n            char s[128];\n            f0r_param_color_t col;\n            f0r_param_position_t pos;\n\n        case F0R_PARAM_BOOL:\n            v = &d;\n            frei0r->get_param_value(frei0r->instance, v, i);\n            av_log(ctx, AV_LOG_DEBUG, \"%s\", d >= 0.5 && d <= 1.0 ? \"y\" : \"n\");\n            break;\n        case F0R_PARAM_DOUBLE:\n            v = &d;\n            frei0r->get_param_value(frei0r->instance, v, i);\n            av_log(ctx, AV_LOG_DEBUG, \"%f\", d);\n            break;\n        case F0R_PARAM_COLOR:\n            v = &col;\n            frei0r->get_param_value(frei0r->instance, v, i);\n            av_log(ctx, AV_LOG_DEBUG, \"%f/%f/%f\", col.r, col.g, col.b);\n            break;\n        case F0R_PARAM_POSITION:\n            v = &pos;\n            frei0r->get_param_value(frei0r->instance, v, i);\n            av_log(ctx, AV_LOG_DEBUG, \"%lf/%lf\", pos.x, pos.y);\n            break;\n        default: /* F0R_PARAM_STRING */\n            v = s;\n            frei0r->get_param_value(frei0r->instance, v, i);\n            av_log(ctx, AV_LOG_DEBUG, \"'%s'\\n\", s);\n            break;\n        }\n#endif\n        av_log(ctx, AV_LOG_VERBOSE, \"\\n\");\n    }\n\n    return 0;\n}\n\nstatic void *load_path(AVFilterContext *ctx, const char *prefix, const char *name)\n{\n    char path[1024];\n\n    snprintf(path, sizeof(path), \"%s%s%s\", prefix, name, SLIBSUF);\n    av_log(ctx, AV_LOG_DEBUG, \"Looking for frei0r effect in '%s'\\n\", path);\n    return dlopen(path, RTLD_NOW|RTLD_LOCAL);\n}\n\nstatic av_cold int frei0r_init(AVFilterContext *ctx,\n                               const char *dl_name, int type)\n{\n    Frei0rContext *frei0r = ctx->priv;\n    f0r_init_f            f0r_init;\n    f0r_get_plugin_info_f f0r_get_plugin_info;\n    f0r_plugin_info_t *pi;\n    char *path;\n\n    /* see: http://piksel.org/frei0r/1.2/spec/1.2/spec/group__pluglocations.html */\n    if ((path = av_strdup(getenv(\"FREI0R_PATH\")))) {\n        char *p, *ptr = NULL;\n        for (p = path; p = av_strtok(p, \":\", &ptr); p = NULL)\n            if (frei0r->dl_handle = load_path(ctx, p, dl_name))\n                break;\n        av_free(path);\n    }\n    if (!frei0r->dl_handle && (path = getenv(\"HOME\"))) {\n        char prefix[1024];\n        snprintf(prefix, sizeof(prefix), \"%s/.frei0r-1/lib/\", path);\n        frei0r->dl_handle = load_path(ctx, prefix, dl_name);\n    }\n    if (!frei0r->dl_handle)\n        frei0r->dl_handle = load_path(ctx, \"/usr/local/lib/frei0r-1/\", dl_name);\n    if (!frei0r->dl_handle)\n        frei0r->dl_handle = load_path(ctx, \"/usr/lib/frei0r-1/\", dl_name);\n    if (!frei0r->dl_handle) {\n        av_log(ctx, AV_LOG_ERROR, \"Could not find module '%s'\\n\", dl_name);\n        return AVERROR(EINVAL);\n    }\n\n    if (!(f0r_init                = load_sym(ctx, \"f0r_init\"           )) ||\n        !(f0r_get_plugin_info     = load_sym(ctx, \"f0r_get_plugin_info\")) ||\n        !(frei0r->get_param_info  = load_sym(ctx, \"f0r_get_param_info\" )) ||\n        !(frei0r->get_param_value = load_sym(ctx, \"f0r_get_param_value\")) ||\n        !(frei0r->set_param_value = load_sym(ctx, \"f0r_set_param_value\")) ||\n        !(frei0r->update          = load_sym(ctx, \"f0r_update\"         )) ||\n        !(frei0r->construct       = load_sym(ctx, \"f0r_construct\"      )) ||\n        !(frei0r->destruct        = load_sym(ctx, \"f0r_destruct\"       )) ||\n        !(frei0r->deinit          = load_sym(ctx, \"f0r_deinit\"         )))\n        return AVERROR(EINVAL);\n\n    if (f0r_init() < 0) {\n        av_log(ctx, AV_LOG_ERROR, \"Could not init the frei0r module\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    f0r_get_plugin_info(&frei0r->plugin_info);\n    pi = &frei0r->plugin_info;\n    if (pi->plugin_type != type) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"Invalid type '%s' for the plugin\\n\",\n               pi->plugin_type == F0R_PLUGIN_TYPE_FILTER ? \"filter\" :\n               pi->plugin_type == F0R_PLUGIN_TYPE_SOURCE ? \"source\" :\n               pi->plugin_type == F0R_PLUGIN_TYPE_MIXER2 ? \"mixer2\" :\n               pi->plugin_type == F0R_PLUGIN_TYPE_MIXER3 ? \"mixer3\" : \"unknown\");\n        return AVERROR(EINVAL);\n    }\n\n    av_log(ctx, AV_LOG_VERBOSE,\n           \"name:%s author:'%s' explanation:'%s' color_model:%s \"\n           \"frei0r_version:%d version:%d.%d num_params:%d\\n\",\n           pi->name, pi->author, pi->explanation,\n           pi->color_model == F0R_COLOR_MODEL_BGRA8888 ? \"bgra8888\" :\n           pi->color_model == F0R_COLOR_MODEL_RGBA8888 ? \"rgba8888\" :\n           pi->color_model == F0R_COLOR_MODEL_PACKED32 ? \"packed32\" : \"unknown\",\n           pi->frei0r_version, pi->major_version, pi->minor_version, pi->num_params);\n\n    return 0;\n}\n\nstatic av_cold int filter_init(AVFilterContext *ctx, const char *args)\n{\n    Frei0rContext *frei0r = ctx->priv;\n    char dl_name[1024], c;\n    *frei0r->params = 0;\n\n    if (args)\n        sscanf(args, \"%1023[^:=]%c%255c\", dl_name, &c, frei0r->params);\n\n    return frei0r_init(ctx, dl_name, F0R_PLUGIN_TYPE_FILTER);\n}\n\nstatic av_cold void uninit(AVFilterContext *ctx)\n{\n    Frei0rContext *frei0r = ctx->priv;\n\n    if (frei0r->destruct && frei0r->instance)\n        frei0r->destruct(frei0r->instance);\n    if (frei0r->deinit)\n        frei0r->deinit();\n    if (frei0r->dl_handle)\n        dlclose(frei0r->dl_handle);\n\n    memset(frei0r, 0, sizeof(*frei0r));\n}\n\nstatic int config_input_props(AVFilterLink *inlink)\n{\n    AVFilterContext *ctx = inlink->dst;\n    Frei0rContext *frei0r = ctx->priv;\n\n    if (!(frei0r->instance = frei0r->construct(inlink->w, inlink->h))) {\n        av_log(ctx, AV_LOG_ERROR, \"Impossible to load frei0r instance\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    return set_params(ctx, frei0r->params);\n}\n\nstatic int query_formats(AVFilterContext *ctx)\n{\n    Frei0rContext *frei0r = ctx->priv;\n    AVFilterFormats *formats = NULL;\n\n    if        (frei0r->plugin_info.color_model == F0R_COLOR_MODEL_BGRA8888) {\n        ff_add_format(&formats, PIX_FMT_BGRA);\n    } else if (frei0r->plugin_info.color_model == F0R_COLOR_MODEL_RGBA8888) {\n        ff_add_format(&formats, PIX_FMT_RGBA);\n    } else {                                   /* F0R_COLOR_MODEL_PACKED32 */\n        static const enum PixelFormat pix_fmts[] = {\n            PIX_FMT_BGRA, PIX_FMT_ARGB, PIX_FMT_ABGR, PIX_FMT_ARGB, PIX_FMT_NONE\n        };\n        formats = ff_make_format_list(pix_fmts);\n    }\n\n    if (!formats)\n        return AVERROR(ENOMEM);\n\n    ff_set_common_formats(ctx, formats);\n    return 0;\n}\n\nstatic int null_draw_slice(AVFilterLink *inlink, int y, int h, int slice_dir)\n{\n    return 0;\n}\n\nstatic int end_frame(AVFilterLink *inlink)\n{\n    Frei0rContext *frei0r = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFilterBufferRef  *inpicref =  inlink->cur_buf;\n    AVFilterBufferRef *outpicref = outlink->out_buf;\n    int ret;\n\n    frei0r->update(frei0r->instance, inpicref->pts * av_q2d(inlink->time_base) * 1000,\n                   (const uint32_t *)inpicref->data[0],\n                   (uint32_t *)outpicref->data[0]);\n    if ((ret = ff_draw_slice(outlink, 0, outlink->h, 1)) ||\n        (ret = ff_end_frame(outlink)) < 0)\n        return ret;\n    return 0;\n}\n\nAVFilter avfilter_vf_frei0r = {\n    .name      = \"frei0r\",\n    .description = NULL_IF_CONFIG_SMALL(\"Apply a frei0r effect.\"),\n\n    .query_formats = query_formats,\n    .init = filter_init,\n    .uninit = uninit,\n\n    .priv_size = sizeof(Frei0rContext),\n\n    .inputs    = (const AVFilterPad[]) {{ .name             = \"default\",\n                                          .type             = AVMEDIA_TYPE_VIDEO,\n                                          .draw_slice       = null_draw_slice,\n                                          .config_props     = config_input_props,\n                                          .end_frame        = end_frame,\n                                          .min_perms        = AV_PERM_READ },\n                                        { .name = NULL}},\n\n    .outputs   = (const AVFilterPad[]) {{ .name             = \"default\",\n                                          .type             = AVMEDIA_TYPE_VIDEO, },\n                                        { .name = NULL}},\n};\n\nstatic av_cold int source_init(AVFilterContext *ctx, const char *args)\n{\n    Frei0rContext *frei0r = ctx->priv;\n    char dl_name[1024], c;\n    char frame_size[128] = \"\";\n    char frame_rate[128] = \"\";\n    AVRational frame_rate_q;\n\n    memset(frei0r->params, 0, sizeof(frei0r->params));\n\n    if (args)\n        sscanf(args, \"%127[^:]:%127[^:]:%1023[^:=]%c%255c\",\n               frame_size, frame_rate, dl_name, &c, frei0r->params);\n\n    if (av_parse_video_size(&frei0r->w, &frei0r->h, frame_size) < 0) {\n        av_log(ctx, AV_LOG_ERROR, \"Invalid frame size: '%s'\\n\", frame_size);\n        return AVERROR(EINVAL);\n    }\n\n    if (av_parse_video_rate(&frame_rate_q, frame_rate) < 0) {\n        av_log(ctx, AV_LOG_ERROR, \"Invalid frame rate: '%s'\\n\", frame_rate);\n        return AVERROR(EINVAL);\n    }\n    frei0r->time_base.num = frame_rate_q.den;\n    frei0r->time_base.den = frame_rate_q.num;\n\n    return frei0r_init(ctx, dl_name, F0R_PLUGIN_TYPE_SOURCE);\n}\n\nstatic int source_config_props(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    Frei0rContext *frei0r = ctx->priv;\n\n    if (av_image_check_size(frei0r->w, frei0r->h, 0, ctx) < 0)\n        return AVERROR(EINVAL);\n    outlink->w = frei0r->w;\n    outlink->h = frei0r->h;\n    outlink->time_base = frei0r->time_base;\n    outlink->sample_aspect_ratio = (AVRational){1,1};\n\n    if (!(frei0r->instance = frei0r->construct(outlink->w, outlink->h))) {\n        av_log(ctx, AV_LOG_ERROR, \"Impossible to load frei0r instance\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    return set_params(ctx, frei0r->params);\n}\n\nstatic int source_request_frame(AVFilterLink *outlink)\n{\n    Frei0rContext *frei0r = outlink->src->priv;\n    AVFilterBufferRef *picref = ff_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h);\n    AVFilterBufferRef *buf_out;\n    int ret;\n\n    if (!picref)\n        return AVERROR(ENOMEM);\n\n    picref->video->sample_aspect_ratio = (AVRational) {1, 1};\n    picref->pts = frei0r->pts++;\n    picref->pos = -1;\n\n    buf_out = avfilter_ref_buffer(picref, ~0);\n    if (!buf_out) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    ret = ff_start_frame(outlink, buf_out);\n    if (ret < 0)\n        goto fail;\n\n    frei0r->update(frei0r->instance, av_rescale_q(picref->pts, frei0r->time_base, (AVRational){1,1000}),\n                   NULL, (uint32_t *)picref->data[0]);\n    ret = ff_draw_slice(outlink, 0, outlink->h, 1);\n    if (ret < 0)\n        goto fail;\n\n    ret = ff_end_frame(outlink);\n\nfail:\n    avfilter_unref_buffer(picref);\n\n    return ret;\n}\n\nAVFilter avfilter_vsrc_frei0r_src = {\n    .name        = \"frei0r_src\",\n    .description = NULL_IF_CONFIG_SMALL(\"Generate a frei0r source.\"),\n\n    .priv_size = sizeof(Frei0rContext),\n    .init      = source_init,\n    .uninit    = uninit,\n\n    .query_formats = query_formats,\n\n    .inputs    = NULL,\n\n    .outputs   = (const AVFilterPad[]) {{ .name            = \"default\",\n                                          .type            = AVMEDIA_TYPE_VIDEO,\n                                          .request_frame   = source_request_frame,\n                                          .config_props    = source_config_props },\n                                        { .name = NULL}},\n};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ffmpeg-1.0.10-ggwvgpzorieko7332epwc5znp55xiwtk/spack-src/libavformat/mmst.c",
        "/tmp/vanessa/spack-stage/spack-stage-ffmpeg-1.0.10-ggwvgpzorieko7332epwc5znp55xiwtk/spack-src/libavformat/mms.c",
        "/tmp/vanessa/spack-stage/spack-stage-ffmpeg-1.0.10-ggwvgpzorieko7332epwc5znp55xiwtk/spack-src/tests/lena.pnm",
        "/tmp/vanessa/spack-stage/spack-stage-ffmpeg-1.0.10-ggwvgpzorieko7332epwc5znp55xiwtk/spack-src/tests/asynth1.sw"
    ],
    "total_files": 2126
}