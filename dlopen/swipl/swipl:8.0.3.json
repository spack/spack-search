{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/pl-incl.h": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1985-2018, University of Amsterdam,\n                              VU University Amsterdam\n\t\t\t      CWI, Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef _PL_INCLUDE_H\n#define _PL_INCLUDE_H\n\n#define PLNAME \"swi\"\n\n#ifdef __WINDOWS__\n#ifdef WIN64\n#include \"config/win64.h\"\n#define PLHOME       \"c:/Program Files/swipl\"\n#else\n#include \"config/win32.h\"\n#define PLHOME       \"c:/Program Files (x86)/swipl\"\n#endif\n#define DEFSTARTUP   \"swipl.ini\"\n#else /*__WINDOWS__*/\n#include <config.h>\n#endif\n\n#ifdef _MSC_VER\n#define C_LIBS\t     \"\"\n#define C_STATICLIBS \"\"\n#define C_CC\t     \"cl\"\n#if (_MSC_VER < 1400)\n#define C_CFLAGS     \"/MD /GX\"\n#else\n#define C_CFLAGS     \"/MD /EHsc\"\n#endif\n#define C_LDFLAGS    \"\"\n#if defined(_DEBUG)\n#define C_PLLIB\t    \"swiplD.lib\"\n#else\n#define C_PLLIB\t    \"swipl.lib\"\n#endif\n#else\t\t\t\t\t/* !_MSC_VER  */\n#ifdef __WINDOWS__\t\t\t/* I.e., MinGW */\n#define C_LIBS\t     \"\"\n#define C_STATICLIBS \"\"\n#define C_CC\t     \"gcc\"\n#define C_CFLAGS     \"\"\n#define C_PLLIB\t     \"-lswipl\"\t\t/* Or \"libswipl.lib\"? */\n#define C_LIBPLSO    \"-lswipl\"\n#define C_LDFLAGS    \"\"\n#else\n#include <parms.h>\t\t\t/* pick from the working dir */\n#endif\n#endif\n\n#define PL_KERNEL\t\t1\n#include <inttypes.h>\n#include \"pl-builtin.h\"\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\t\t      PROLOG SYSTEM OPTIONS\n\nThese are not really options normally.  They are there because I use  to\nadd  new  features  conditional  using  #if ... #endif.  In many cases I\nleave them in for ducumentation purposes.   Notably  O_STRING  might  be\nhandy for it someone wants to add a data type to the system.\n\n  O_STRING\n      Include data type string.  This  feature  does  not  rely  on  any\n      system  feature.   It  hardly has any consequences for the system.\n      Because of its experimental nature it is optional.  The definition\n      of the predicates operating on strings might change.\n      (NOTE: Currently some of the boot files rely on strings. It is NOT\n      suggested to leave them out).\n  O_QUASIQUOTATIONS\n      Support quasi quoted content in read_term/3 and friends.\n  O_COMPILE_OR\n      Compile ->/2, ;/2 and |/2 into WAM.  This  no  longer  is  a  real\n      option.   the mechanism to handle cuts without compiling ;/2, etc.\n      has been taken out.\n  O_COMPILE_ARITH\n      Include arithmetic compiler (compiles is/2, >/2, etc. into WAM).\n  O_COMPILE_IS\n      Compile Var = Value in the body.\n  O_CALL_AT_MODULE\n      Support the Goal@Module control-structure\n  O_LABEL_ADDRESSES\n      Means we can pick up the address of a label in  a function using\n      the var  = `&&label' construct  and jump to  it using goto *var;\n      This construct is known by the GNU-C compiler gcc version 2.  It\n      is buggy in gcc-2.0, but seems to works properly in gcc-2.1.\n  VMCODE_IS_ADDRESS\n      Can only  be set when  O_LABEL_ADDRESSES is  set.  It causes the\n      prolog  compiler  to put the  code  (=  label-) addresses in the\n      compiled Prolog  code  rather than the  virtual-machine numbers.\n      This speeds-up  the vm  instruction dispatching in  interpret().\n      See also pl-comp.c\n  O_LOGICAL_UPDATE\n      Use `logical' update-view for dynamic predicates rather then the\n      `immediate' update-view of older Prolog systems.\n  O_PLMT\n      Include support for multi-threading. Too much of the system relies\n      on this now, so it cannot be disabled without significant work.\n  O_LARGEFILES\n      Supports files >2GB on 32-bit systems (if the OS provides it).\n  O_ATTVAR\n      Include support for attributes variables.\n      This option requires O_DESTRUCTIVE_ASSIGNMENT.\n  O_GVAR\n      Include support for backtrackable global variables.  This option\n      requires O_DESTRUCTIVE_ASSIGNMENT.\n  O_CYCLIC\n      Provide support for cyclic terms.\n  O_LOCALE\n      Provide locale support on streams.\n  O_GMP\n      Use GNU gmp library for infinite precision arthmetic\n  O_MITIGATE_SPECTRE\n      Reduce spectre security risc.  Currently reduces timer resolution.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define O_COMPILE_OR\t\t1\n#define O_SOFTCUT\t\t1\n#define O_COMPILE_ARITH\t\t1\n#define O_COMPILE_IS\t\t1\n#define O_CALL_AT_MODULE\t1\n#define O_STRING\t\t1\n#define O_RESERVED_SYMBOLS\t1\n#define O_QUASIQUOTATIONS\t1\n#define O_CATCHTHROW\t\t1\n#define O_DEBUGGER\t\t1\n#define O_INTERRUPT\t\t1\n#define O_DESTRUCTIVE_ASSIGNMENT 1\n#define O_TERMHASH\t\t1\n#define O_LIMIT_DEPTH\t\t1\n#define O_INFERENCE_LIMIT\t1\n#define O_SAFE_SIGNALS\t\t1\n#define O_LOGICAL_UPDATE\t1\n#define O_LOCALE\t\t1\n#define O_ATOMGC\t\t1\n#define O_CLAUSEGC\t\t1\n#define O_ATTVAR\t\t1\n#define O_CALL_RESIDUE\t\t1\n#define O_GVAR\t\t\t1\n#define O_CYCLIC\t\t1\n#define O_MITIGATE_SPECTRE\t1\n\n#if defined(O_PLMT)\n#if defined(O_SIGPROF_PROFILE) || defined(__WINDOWS__)\n#define O_PROFILE\t\t1\n#endif\n#endif\n\n#ifdef HAVE_GMP_H\n#define O_GMP\t\t\t1\n#endif\n#ifdef __WINDOWS__\n#define NOTTYCONTROL           TRUE\n#define O_DDE 1\n#define O_DLL 1\n#define O_HASDRIVES 1\n#define O_HASSHARES 1\n#define O_XOS 1\n#define O_RLC 1\n#endif\n\n#ifndef DOUBLE_TO_LONG_CAST_RAISES_SIGFPE\n#ifdef __i386__\n#define DOUBLE_TO_LONG_CAST_RAISES_SIGFPE 1\n#endif\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThe ia64 says setjmp()/longjmp() buffer must be aligned at 128 bits\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifndef JMPBUF_ALIGNMENT\n#ifdef __ia64__\n#define JMPBUF_ALIGNMENT 128\n#else\n#if ALIGNOF_DOUBLE != ALIGNOF_VOIDP\n#define JMPBUF_ALIGNMENT ALIGNOF_DOUBLE\n#endif\n#endif\n#endif\n\n#ifndef O_LABEL_ADDRESSES\n#if __GNUC__ == 2\n#define O_LABEL_ADDRESSES\t1\n#endif\n#endif\n\n#if O_LABEL_ADDRESSES && !defined(VMCODE_IS_ADDRESS)\n#define VMCODE_IS_ADDRESS\t1\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nRuntime version.  Uses somewhat less memory and has no tracer.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef O_RUNTIME\n#undef O_PROFILE\t\t\t/* no profiling */\n#undef O_DEBUGGER\t\t\t/* no debugging */\n#undef O_INTERRUPT\t\t\t/* no interrupts too */\n#endif\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThe macros below try to establish a common basis for various  compilers,\nso  we  can  write  most  of the real code without having to worry about\ncompiler limits and differences.\n\nThe current version has prototypes  defined   for  all functions. If you\nhave a very old compiler, try  the   unprotoize  program that comes with\ngcc.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifndef __unix__\n#if defined(_AIX) || defined(__APPLE__) || defined(__unix) || defined(__BEOS__) || defined(__NetBSD__) || defined(__HAIKU__)\n#define __unix__ 1\n#endif\n#endif\n\n/* AIX requires this to be the first thing in the file.  */\n#ifdef __GNUC__\n# ifndef alloca\n#  define alloca __builtin_alloca\n# endif\n#else\n# if HAVE_ALLOCA_H\n#  include <alloca.h>\n# else\n#  ifdef _AIX\n #pragma alloca\n#  else\n#   ifndef alloca /* predefined by HP cc +Olibcalls */\nvoid *alloca ();\n#   endif\n#  endif\n# endif\n#endif\n\n#if _FILE_OFFSET_BITS == 64 || defined(_LARGE_FILES)\n#define O_LARGEFILES 1\t\t/* use for conditional code in Prolog */\n#else\n#undef O_LARGEFILES\n#endif\n\n#include <sys/types.h>\n#if __MINGW32__\ntypedef _sigset_t sigset_t;\n#endif\n#include <setjmp.h>\n#ifdef ASSERT_H_REQUIRES_STDIO_H\n#include <stdio.h>\n#endif /*ASSERT_H_REQUIRES_STDIO_H*/\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <limits.h>\n\n#ifdef HAVE_SIGNAL\n#include <signal.h>\n#endif\n#ifdef HAVE_MALLOC_H\n#include <malloc.h>\n#else\n#ifdef HAVE_SYS_MALLOC_H\n#include <sys/malloc.h>\n#endif\n#endif\n\n#ifdef O_GMP\n#ifdef _MSC_VER\t\t\t/* ignore warning in gmp 5.0.2 header */\n#pragma warning( disable : 4146 )\n#endif\n#include <gmp.h>\n#ifdef _MSC_VER\n#pragma warning( default : 4146 )\n#endif\n#endif\n\n#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)\n#include <string.h>\n/* An ANSI string.h and pre-ANSI memory.h might conflict.  */\n#if !defined(STDC_HEADERS) && defined(HAVE_MEMORY_H)\n#include <memory.h>\n#endif /* not STDC_HEADERS and HAVE_MEMORY_H */\n#else /* not STDC_HEADERS and not HAVE_STRING_H */\n#include <strings.h>\n/* memory.h and strings.h conflict on some systems.  */\n#endif /* not STDC_HEADERS and not HAVE_STRING_H */\n\n#if OS2 && EMX\n#include <process.h>\n#include <io.h>\n#endif /* OS2 */\n\n/* prepare including BeOS types */\n#ifdef __BEOS__\n#define bool BOOL\n\n#include <BeBuild.h>\n#if (B_BEOS_VERSION <= B_BEOS_VERSION_5)\n# include <socket.h>      /* include socket.h to get the fd_set structure */\n#else\n# include <SupportDefs.h> /* not needed for a BONE-based networking stack */\n#endif\n#include <OS.h>\n\n#undef true\n#undef false\n#undef bool\n#define EMULATE_DLOPEN 1\t\t/* Emulated dlopen() in pl-beos.c */\n#endif\n\n/* MAXPATHLEN is an optional POSIX feature (Bug#63).  As SWI-Prolog has\n   no length limits on text except for representing paths, we should\n   rewrite all file handling code to avoid MAXPATHLEN.  For now we just\n   define it.\n*/\n\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nA common basis for C keywords.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#if __GNUC__ && !__STRICT_ANSI__\n#define HAVE_INLINE 1\n#define HAVE_VOLATILE 1\n#define HAVE___BUILTIN_EXPECT 1\n#endif\n\n#if !defined(HAVE_INLINE) && !defined(inline)\n#define inline\n#endif\n\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n#define _DEBUG 1\n#endif\n\n#ifndef HAVE_VOLATILE\n#define volatile\n#endif\n\n#if defined(__GNUC__) && !defined(NORETURN)\n#define NORETURN __attribute__ ((noreturn))\n#else\n#define NORETURN\n#endif\n\n#if defined(__GNUC__) && !defined(MAY_ALIAS)\n#define MAY_ALIAS __attribute__ ((__may_alias__))\n#else\n#define MAY_ALIAS\n#endif\n\n#ifdef HAVE___BUILTIN_EXPECT\n#define likely(x)       __builtin_expect((x), 1)\n#define unlikely(x)     __builtin_expect((x), 0)\n#else\n#define likely(x)\t(x)\n#define unlikely(x)\t(x)\n#endif\n\n#if defined(__STRICT_ANSI__) || defined(NO_ASM_NOP)\n#define ASM_NOP { static int nop; nop++; }\n#endif\n\n#ifdef DMALLOC\n#include <dmalloc.h>\t\t\t/* Use www.dmalloc.com debugger */\n\n#define PL_ALLOC_DONE 1\n#define DMALLOC_FUNC_CHECK 1\n#define allocHeap(n)\t\tmalloc(n)\n#define allocHeapOrHalt(n)\txmalloc(n)\n#define freeHeap(ptr, n)\tdo { (void)(n); xfree(ptr); } while(0)\n#endif /*DMALLOC*/\n\n#define forwards static\t\t/* forwards function declarations */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nBooleans,  addresses,  strings  and other   goodies.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\ntypedef int\t\t\tbool;\n\n#if __GNUC__ && !__STRICT_ANSI__\n#define LocalArray(t, n, s)\tt n[s]\n#else\n#define LocalArray(t, n, s)\tt *n = (t *) alloca((s)*sizeof(t))\n#endif\n\n#define TermVector(name, s)\tLocalArray(Word, name, s)\n\n#ifndef TRUE\n#define TRUE\t\t\t1\n#define FALSE\t\t\t0\n#endif\n#define succeed\t\t\treturn TRUE\n#define fail\t\t\treturn FALSE\n#define TRY(goal)\t\tdo { if (!(goal)) return FALSE; } while(0)\n\n#define CL_START\t\t((ClauseRef)1)\t/* asserta */\n#define CL_END\t\t\t((ClauseRef)2)\t/* assertz */\n\ntypedef void *\t\t\tcaddress;\n\n#define EOS\t\t\t('\\0')\n#define ESC\t\t\t((char) 27)\n#define streq(s, q)\t\t((strcmp((s), (q)) == 0))\n\n\t\t\t\t/* n is 2^m !!! */\n#define ROUND(p, n)\t\t((((p) + (n) - 1) & ~((n) - 1)))\n#define addPointer(p, n)\t((void *) ((intptr_t)(p) + (intptr_t)(n)))\n#define diffPointers(p1, p2)\t((intptr_t)(p1) - (intptr_t)(p2))\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\t\t\t     LIMITS\n\nBelow are some arbitrary limits on object sizes.  Feel free  to  enlarge\nthem.  Descriptions:\n\n\t* LINESIZ\n\tBuffer used to store textual info.  It is not concerned with\n\tcritical things, just things like building an error message,\n\treading a command for the tracer, etc.\n\n\t* MAXARITY\n\tMaximum arity of a predicate.  May be enarged further, but\n\twastes stack (4 bytes for each argument) on machines that\n\tuse malloc() for allocating the stack as the local and global\n\tstack need to be apart by this amount.  Also, an interrupt\n\tskips this amount of stack.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define BUFFER_RING_SIZE\t16\t/* foreign buffer ring (pl-fli.c) */\n#define LINESIZ\t\t\t1024\t/* size of a data line */\n#define MAXARITY\t\t1024\t/* arity of predicate */\n#define MINFOREIGNSIZE\t\t32\t/* Minimum term_t in foreign frame */\n#define MAXSYMBOLLEN\t\t256\t/* max size of foreign symbols */\n#define OP_MAXPRIORITY\t\t1200\t/* maximum operator priority */\n#define SMALLSTACK\t\t32 * 1024 /* GC policy */\n#define MAX_PORTRAY_NESTING\t100\t/* Max recursion in portray */\n\n#define LOCAL_MARGIN ((size_t)argFrameP((LocalFrame)NULL, MAXARITY) + \\\n\t\t      sizeof(struct choice))\n\n#define WORDBITSIZE\t\t(8 * sizeof(word))\n#define LONGBITSIZE\t\t(8 * sizeof(long))\n#define INTBITSIZE\t\t(8 * sizeof(int))\n#define INT64BITSIZE\t\t(8 * sizeof(int64_t))\n#define WORDS_PER_DOUBLE        ((sizeof(double)+sizeof(word)-1)/sizeof(word))\n#define WORDS_PER_INT64\t\t(sizeof(int64_t)/sizeof(word))\n\n\t\t\t\t/* Prolog's integer range */\n#define PLMINTAGGEDINT\t\t(-(intptr_t)((word)1<<(WORDBITSIZE-LMASK_BITS-1)))\n#define PLMAXTAGGEDINT\t\t(-PLMINTAGGEDINT - 1)\n#define PLMINTAGGEDINT32\t(-(intptr_t)((word)1<<(32-LMASK_BITS-1)))\n#define PLMAXTAGGEDINT32\t(-PLMINTAGGEDINT32 - 1)\n#define inTaggedNumRange(n)\t(valInt(consInt(n)) == (n))\n#define PLMININT\t\t(-PLMAXINT - 1)\n#define PLMAXINT\t\t((int64_t)(((uint64_t)1<<(INT64BITSIZE-1)) - 1))\n#if SIZEOF_WCHAR_T == 2\n#define PLMAXWCHAR\t\t(0xffff)\n#else\n#define PLMAXWCHAR\t\t(0x10ffff)\n#endif\n\n#if vax\n#define MAXREAL\t\t\t(1.701411834604692293e+38)\n#else\t\t\t\t\t/* IEEE double */\n#define MAXREAL\t\t\t(1.79769313486231470e+308)\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMacros to handle hash tables.  See pl-table.c for  details.   First  the\nsizes  of  the  hash  tables are defined.  Note that these should all be\n2^N.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define ATOMHASHSIZE\t\t1024\t/* global atom table */\n#define FUNCTORHASHSIZE\t\t512\t/* global functor table */\n#define PROCEDUREHASHSIZE\t256\t/* predicates in module user */\n#define MODULEPROCEDUREHASHSIZE 16\t/* predicates in other modules */\n#define MODULEHASHSIZE\t\t16\t/* global module table */\n#define PUBLICHASHSIZE\t\t8\t/* Module export table */\n#define FLAGHASHSIZE\t\t16\t/* global flag/3 table */\n\n#include \"os/pl-table.h\"\n#include \"pl-vmi.h\"\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nArithmetic comparison\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define LT 1\n#define GT 2\n#define LE 3\n#define GE 4\n#define NE 5\n#define EQ 6\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nOperator types.  NOTE: if you change OP_*, check operatorTypeToAtom()!\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define OP_PREFIX  0\n#define OP_INFIX   1\n#define OP_POSTFIX 2\n#define OP_MASK    0xf\n\n#define\tOP_FX\t(0x10|OP_PREFIX)\n#define OP_FY\t(0x20|OP_PREFIX)\n#define OP_XF\t(0x30|OP_POSTFIX)\n#define OP_YF\t(0x40|OP_POSTFIX)\n#define OP_XFX\t(0x50|OP_INFIX)\n#define OP_XFY\t(0x60|OP_INFIX)\n#define OP_YFX\t(0x70|OP_INFIX)\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMagic for assertions.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define StackMagic(n)\t((n) | 0x98765000)\n#define QID_MAGIC\tStackMagic(1)\t/* Query frame */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\t\t\t  PROLOG DATA REPRESENTATION\n\nProlog data objects live on various places:\n\n\t- In the variable and argument slots of environment frames.\n\t- As arguments to complex terms on the global stack.\n\t- In records (recorda/recorded database) in the heap.\n\t- In variables in foreign language functions.\n\nAll Prolog data is packed into a `word'.  A word is  a  32  bit  entity.\nThe top 3 bits are used to indicate the type; the bottom 2 bits are used\nfor  the  garbage  collector.   The  bits  for the garbage collector are\nalways 0 during normal execution.  This implies we do not have  to  care\nabout  them  for  pointers  and  as  pointers  always  point  to 4 bytes\nentities, the range is not harmed by the garbage collection bits.\n\nThe remaining 27 bits can hold a  unique  representation  of  the  value\nitself  or  can be a pointer to the global stack where the real value is\nstored.  We call the latter type of data `indirect'.\n\nBelow is a description of the  representation  used  for  each  type  of\nProlog data:\n\n***TBD*** This is totally out of date.  The datatypes are accessed using\nmacros defined in pl-data.h.\n\nINTEGER\n    Integers are stored in the  27  remaining  bits  of  a  word.   This\n    implies they are limited to +- 2^26.\nFLOAT\n    For a real, the 27 bits are a pointer to a 8 byte unit on the global\n    stack.  For both words of the 8 byte unit, the top 3  and  bottom  2\n    bits  are  reserved  for identification and garbage collection.  The\n    remaining bits hold the exponent and mantisse.  See pack_real()  and\n    unpack_real() in pl-alloc.c for details.\nATOM\n    For atoms, the 27 bits represent a pointer  to  an  atom  structure.\n    Atom  structures are cells of a hash table.  Equality of the pointer\n    implies equality of the atoms and visa versa.  Atom  structures  are\n    not  collected by the garbage collector and thus live for the entire\n    Prolog session.\nSTRING\n    For a string, the 27 bits are a pointer to the  global  stack.   The\n    first  word  of  the  string  again reserves  the top 3 and bottom 2\n    bits.  The remaining bits indicate the lenght of the  string.   Next\n    follows a 0 terminated character string.  Finally a word exactly the\n    same  as the header word, to allow the garbage collector to traverse\n    the stack downwards and identify the string.\nTERM\n    For a compound term, the 27 bits are a pointer to the global  stack.\n    the  first  word there is a pointer to a functordef structure, which\n    determines the name and arity of the  term.   functordef  structures\n    are  cells  of  a hash table like atom structures.  They to live for\n    the entire Prolog session.  Next, there are just as  many  words  as\n    the  arity  of the term, each word representing a normal Prolog data\n    object.\nVARIABLES\n    An unbound variable is represented by NULL.\nREFERENCES\n    References are the result of sharing variables.   If  two  variables\n    must  share,  the one with the shortest livetime is made a reference\n    pointer to the other.  This way a tree of reference pointers can  be\n    constructed.   The root of the tree is the variable with the longest\n    livetime.  To bind the entire tree of variables this root is  bound.\n    The  others remain reference pointers.  This implies that ANY prolog\n    data object might be a reference  pointer  to  another  Prolog  data\n    object,  holding  the  real  value.  To find the real value, a macro\n    called deRef() is available.\n\n    The direction of reference pointers is critical.  It MUST  point  in\n    the direction of the longest living variable.  If not, the reference\n    pointer  will  point  into  the  dark  if  the other end dies.  This\n    implies that if both cells are part of an environment frame, the one\n    in the child function (closest to the top of the stack)  must  point\n    to  the  one in the parent function.  If one is on the local and one\n    on the global stack, the  pointer  must  point  towards  the  global\n    stack.   Inside  the global stack it is irrelevant.  If backtracking\n    destroys a variable, it also will reset the reference towards it  if\n    there is one.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nCommon Prolog objects typedefs. Note that   code is word-aligned for two\nreasons. First of all, we want to get   the maximum speed and second, we\nmust ensure that sizeof(struct clause) is  a multiple of sizeof(word) to\nplace them on the stack (see I_USERCALL).\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef __GNUC__\n#define WORD_ALIGNED __attribute__ ((aligned (sizeof(word))))\n#else\n#define WORD_ALIGNED\n#endif\n\n#ifndef PL_HAVE_TERM_T\n#define PL_HAVE_TERM_T\ntypedef uintptr_t\t\tterm_t;\t\t/* external term-reference */\n#endif\n\ntypedef uintptr_t\t\tword;\t\t/* Anonymous 4 byte object */\ntypedef word *\t\t\tWord;\t\t/* a pointer to anything */\ntypedef word\t\t\tatom_t;\t\t/* encoded atom */\ntypedef word\t\t\tfunctor_t;\t/* encoded functor */\ntypedef uintptr_t\t\tcode WORD_ALIGNED; /* bytes codes */\ntypedef code *\t\t\tCode;\t\t/* pointer to byte codes */\ntypedef int\t\t\tChar;\t\t/* char that can pass EOF */\ntypedef word\t\t\t(*Func)();\t/* foreign functions */\ntypedef int\t\t\t(*ArithF)();\t/* arithmetic function */\n\ntypedef struct atom *\t\tAtom;\t\t/* atom */\ntypedef struct functor *\tFunctor;\t/* complex term */\ntypedef struct functorDef *\tFunctorDef;\t/* name/arity pair */\ntypedef struct procedure *\tProcedure;\t/* predicate */\ntypedef struct definition *\tDefinition;\t/* predicate definition */\ntypedef struct definition_chain *DefinitionChain; /* linked list of defs */\ntypedef struct clause *\t\tClause;\t\t/* compiled clause */\ntypedef struct clause_ref *\tClauseRef;      /* reference to a clause */\ntypedef struct clause_index *\tClauseIndex;    /* Clause indexing table */\ntypedef struct clause_bucket *\tClauseBucket;   /* Bucked in clause-index table */\ntypedef struct operator *\tOperator;\t/* see pl-op.c, pl-read.c */\ntypedef struct record *\t\tRecord;\t\t/* recorda/3, etc. */\ntypedef struct recordRef *\tRecordRef;      /* reference to a record */\ntypedef struct recordList *\tRecordList;\t/* list of these */\ntypedef struct module *\t\tModule;\t\t/* predicate modules */\ntypedef struct sourceFile *\tSourceFile;\t/* file adminitration */\ntypedef struct list_cell *\tListCell;\t/* Anonymous list */\ntypedef struct localFrame *\tLocalFrame;\t/* environment frame */\ntypedef struct local_definitions *LocalDefinitions; /* thread-local preds */\ntypedef struct choice *\t\tChoice;\t\t/* Choice-point */\ntypedef struct clause_choice *  ClauseChoice;   /* firstClause()/nextClause() */\ntypedef struct queryFrame *\tQueryFrame;     /* toplevel query frame */\ntypedef struct fliFrame *\tFliFrame;\t/* FLI interface frame */\ntypedef struct trail_entry *\tTrailEntry;\t/* Entry of trail stack */\ntypedef struct gc_trail_entry *\tGCTrailEntry;\t/* Entry of trail stack (GC) */\ntypedef struct mark\t\tmark;\t\t/* backtrack mark */\ntypedef struct stack *\t\tStack;\t\t/* machine stack */\ntypedef struct _varDef *\tVarDef;\t\t/* pl-comp.c */\ntypedef struct extension_cell *\tExtensionCell;  /* pl-ext.c */\ntypedef struct abort_handle *\tAbortHandle;\t/* PL_abort_hook() */\ntypedef struct initialise_handle * InitialiseHandle;\ntypedef struct canonical_dir *\tCanonicalDir;\t/* pl-os.c */\ntypedef struct on_halt *\tOnHalt;\t\t/* pl-os.c */\ntypedef struct find_data_tag *\tFindData;\t/* pl-trace.c */\ntypedef struct feature *\tFeature;\t/* pl-prims.c */\ntypedef struct dirty_def_info * DirtyDefInfo;\n\ntypedef uintptr_t qid_t;\t\t/* external query-id */\ntypedef uintptr_t PL_fid_t;\t\t/* external foreign context-id */\n\n#define fid_t PL_fid_t\t\t\t/* avoid AIX name-clash */\n\n\t\t /*******************************\n\t\t *\t    ARITHMETIC\t\t*\n\t\t *******************************/\n\n/* the numtype enum requires total ordering.\n*/\n\ntypedef enum\n{ V_INTEGER,\t\t\t\t/* integer (64-bit) value */\n#ifdef O_GMP\n  V_MPZ,\t\t\t\t/* mpz_t */\n  V_MPQ,\t\t\t\t/* mpq_t */\n#endif\n  V_FLOAT\t\t\t\t/* Floating point number (double) */\n} numtype;\n\ntypedef struct\n{ numtype type;\t\t\t\t/* type of number */\n  union { double f;\t\t\t/* value as a floating point number */\n\t  int64_t i;\t\t\t/* value as integer */\n\t  word  w[WORDS_PER_DOUBLE];\t/* for packing/unpacking the double */\n#ifdef O_GMP\n\t  mpz_t mpz;\t\t\t/* GMP integer */\n\t  mpq_t mpq;\t\t\t/* GMP rational */\n#endif\n\t} value;\n} number, *Number;\n\n#define TOINT_CONVERT_FLOAT\t0x1\t/* toIntegerNumber() */\n#define TOINT_TRUNCATE\t\t0x2\n\n#ifdef O_GMP\n#define intNumber(n)\t((n)->type <=  V_MPZ)\n#else\n#define intNumber(n)\t((n)->type <  V_FLOAT)\n#endif\n#define floatNumber(n)\t((n)->type >= V_FLOAT)\n\ntypedef enum\n{ NUM_ERROR = FALSE,\t\t\t/* Syntax error */\n  NUM_OK    = TRUE,\t\t\t/* Ok */\n  NUM_FUNDERFLOW = -1,\t\t\t/* Float underflow */\n  NUM_FOVERFLOW = -2,\t\t\t/* Float overflow */\n  NUM_IOVERFLOW = -3,\t\t\t/* Integer overflow */\n  NUM_CONSTRANGE = -4\t\t\t/* numeric constant out of range */\n} strnumstat;\n\n\n\n\t\t /*******************************\n\t\t *\t   GET-PROCEDURE\t*\n\t\t *******************************/\n\n#define GP_FIND\t\t0\t\t/* find anywhere */\n#define GP_FINDHERE\t1\t\t/* find in this module */\n#define GP_CREATE\t2\t\t/* create (in this module) */\n#define GP_DEFINE\t4\t\t/* define a procedure */\n#define GP_RESOLVE\t5\t\t/* find defenition */\n\n#define GP_HOW_MASK\t0x0ff\n#define GP_NAMEARITY\t0x100\t\t/* or'ed mask */\n#define GP_HIDESYSTEM\t0x200\t\t/* hide system module */\n#define GP_TYPE_QUIET\t0x400\t\t/* don't throw errors on wrong types */\n#define GP_EXISTENCE_ERROR 0x800\t/* throw error if proc is not found */\n#define GP_QUALIFY\t0x1000\t\t/* Always module-qualify */\n#define GP_NOT_QUALIFIED 0x2000\t\t/* Demand unqualified name/arity */\n\n\t\t\t\t\t/* get_functor() */\n#define GF_EXISTING\t0x1\n#define GF_PROCEDURE\t0x2\t\t/* check for max arity */\n#define GF_NAMEARITY\t0x4\t\t/* only accept name/arity */\n\n#define SM_NOCREATE\t0x1\t\t/* stripModule(): do not create modules */\n\n\t\t /*******************************\n\t\t *\t       ALERT\t\t*\n\t\t *******************************/\n\n/* See updateAlerted()\n*/\n\n#define\tALERT_SIGNAL\t     0x01\n#define\tALERT_GCREQ\t     0x02\n#define\tALERT_PROFILE\t     0x04\n#define\tALERT_EXITREQ\t     0x08\n#define\tALERT_DEPTHLIMIT     0x10\n#define\tALERT_INFERENCELIMIT 0x20\n#define\tALERT_WAKEUP\t     0x40\n#define\tALERT_DEBUG\t     0x80\n\n\n\t\t /*******************************\n\t\t *\t     CLEANUP\t\t*\n\t\t *******************************/\n\ntypedef enum\n{ CLN_NORMAL = 0,\t\t\t/* Normal mode */\n  CLN_PROLOG,\t\t\t\t/* Prolog hooks */\n  CLN_FOREIGN,\t\t\t\t/* Foreign hooks */\n  CLN_IO,\t\t\t\t/* Cleaning I/O */\n  CLN_SHARED,\t\t\t\t/* Unload shared objects */\n  CLN_DATA\t\t\t\t/* Remaining data */\n} cleanup_status;\n\n\n\t\t /*******************************\n\t\t *\t      FLAGS\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMany of the structures have a large number of booleans  associated  with\nthem.   Early  versions defined these using `unsigned <name> : 1' in the\nstructure definition.  When I ported SWI-Prolog to a  machine  that  did\nnot  understand  this  construct  I  decided  to pack all the flags in a\nshort.  As this allows us to set, clear and test combinations  of  flags\nwith one operation, it turns out to be faster as well.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define true(s, a)\t\t((s)->flags & (a))\n#define false(s, a)\t\t(!true((s), (a)))\n#define set(s, a)\t\tATOMIC_OR(&(s)->flags, (a))\n#define clear(s, a)\t\tATOMIC_AND(&(s)->flags, ~(a))\n#define clearFlags(s)\t\t((s)->flags = 0)\n\n/* Flags on predicates (packed in unsigned int */\n\n#define P_CLAUSABLE\t\t(0x00000002) /* Clause/2 always works */\n#define P_QUASI_QUOTATION_SYNTAX (0x00000004) /* {|Type||Quasi Quote|} */\n#define P_NON_TERMINAL\t\t(0x00000008) /* Grammar rule (Name//Arity) */\n#define P_SHRUNKPOW2\t\t(0x00000010) /* See reconsider_index() */\n#define P_FOREIGN\t\t(0x00000020) /* Implemented in C */\n#define P_NONDET\t\t(0x00000040) /* Foreign: nondet */\n#define P_VARARG\t\t(0x00000080) /* Foreign: use alt calling API */\n#define P_FOREIGN_CREF\t\t(0x00000100) /* Foreign: ndet ctx is clause */\n#define P_DYNAMIC\t\t(0x00000200) /* Dynamic predicate */\n#define P_THREAD_LOCAL\t\t(0x00000400) /* Thread local dynamic predicate */\n#define P_VOLATILE\t\t(0x00000800) /* Clauses are not saved */\n#define P_DISCONTIGUOUS\t\t(0x00001000) /* Clauses are not together */\n#define P_MULTIFILE\t\t(0x00002000) /* Clauses are in multiple files */\n#define P_PUBLIC\t\t(0x00004000) /* Called from somewhere */\n#define P_ISO\t\t\t(0x00008000) /* Part of the ISO standard */\n#define P_LOCKED\t\t(0x00010000) /* Locked as system predicate */\n#define P_NOPROFILE\t\t(0x00020000) /* Profile children, not me */\n#define P_TRANSPARENT\t\t(0x00040000) /* Inherit calling module */\n#define P_META\t\t\t(0x00080000) /* Has meta_predicate declaration */\n#define P_MFCONTEXT\t\t(0x00100000) /* Used for Goal@Module */\n#define P_DIRTYREG\t\t(0x00200000) /* Part of GD->procedures.dirty */\n#define P_ERASED\t\t(0x00400000) /* Predicate has been destroyed */\n#define HIDE_CHILDS\t\t(0x00800000) /* Hide children from tracer */\n#define SPY_ME\t\t\t(0x01000000) /* Spy point placed */\n#define TRACE_ME\t\t(0x02000000) /* Can be debugged */\n#define TRACE_CALL\t\t(0x04000000) /* Trace calls */\n#define TRACE_REDO\t\t(0x08000000) /* Trace redo */\n#define TRACE_EXIT\t\t(0x10000000) /* Trace edit */\n#define TRACE_FAIL\t\t(0x20000000) /* Trace fail */\n#define FILE_ASSIGNED\t\t(0x40000000) /* Is assigned to a file */\n#define P_REDEFINED\t\t(0x80000000) /* Overrules a definition */\n#define PROC_DEFINED\t\t(P_DYNAMIC|P_FOREIGN|P_MULTIFILE|P_DISCONTIGUOUS)\n/* flags for p_reload data (reconsult) */\n#define P_MODIFIED\t\tP_DIRTYREG\n#define P_NEW\t\t\tSPY_ME\n#define P_NO_CLAUSES\t\tTRACE_ME\n\n/* Flags on clauses (packed in unsigned flags : 8) */\n\n#define CL_ERASED\t\t(0x0001) /* clause was erased */\n#define UNIT_CLAUSE\t\t(0x0002) /* Clause has no body */\n#define HAS_BREAKPOINTS\t\t(0x0004) /* Clause has breakpoints */\n#define GOAL_CLAUSE\t\t(0x0008) /* Dummy for meta-calling */\n#define COMMIT_CLAUSE\t\t(0x0010) /* This clause will commit */\n#define DBREF_CLAUSE\t\t(0x0020) /* Clause has db-reference */\n#define DBREF_ERASED_CLAUSE\t(0x0040) /* Deleted while referenced */\n#define CL_BODY_CONTEXT\t\t(0x0080) /* Module context of body is different */\n\t\t\t\t\t /* from predicate */\n\n/* Flags on module.  Most of these flags are copied to the read context\n   in pl-read.c.\n*/\n\n#define M_SYSTEM\t\t(0x0001) /* system module */\n#define M_CHARESCAPE\t\t(0x0002) /* module */\n#define DBLQ_CHARS\t\t(0x0004) /* \"ab\" --> ['a', 'b'] */\n#define DBLQ_ATOM\t\t(0x0008) /* \"ab\" --> 'ab' */\n#define DBLQ_STRING\t\t(0x0010) /* \"ab\" --> \"ab\" */\n#define DBLQ_MASK\t\t(DBLQ_CHARS|DBLQ_ATOM|DBLQ_STRING)\n#define BQ_STRING\t\t(0x0020) /* `ab` --> \"ab\" */\n#define BQ_CODES\t\t(0x0040) /* `ab` --> [97,98] */\n#define BQ_CHARS\t\t(0x0080) /* `ab` --> [a,b] */\n#define BQ_MASK\t\t\t(BQ_STRING|BQ_CODES|BQ_CHARS)\n#define UNKNOWN_FAIL\t\t(0x0100) /* module */\n#define UNKNOWN_WARNING\t\t(0x0200) /* module */\n#define UNKNOWN_ERROR\t\t(0x0400) /* module */\n#define UNKNOWN_MASK\t\t(UNKNOWN_ERROR|UNKNOWN_WARNING|UNKNOWN_FAIL)\n#define M_VARPREFIX\t\t(0x0800)\n#define M_DESTROYED\t\t(0x1000)\n\n/* Flags on functors */\n\n#define CONTROL_F\t\t(0x0002) /* functor (compiled controlstruct) */\n#define ARITH_F\t\t\t(0x0004) /* functor (arithmetic operator) */\n#define VALID_F\t\t\t(0x0008) /* functor (fully defined) */\n\n/* Flags on record lists (recorded database keys) */\n\n#define RL_DIRTY\t\t(0x0001) /* recordlist */\n\n/* Flags on recorded database records (also PL_record()) */\n\n#define R_ERASED\t\t(0x0001) /* record: record is erased */\n#define R_EXTERNAL\t\t(0x0002) /* record: inline atoms */\n#define R_DUPLICATE\t\t(0x0004) /* record: include references */\n#define R_NOLOCK\t\t(0x0008) /* record: do not lock atoms */\n#define R_DBREF\t\t\t(0x0010) /* record: has DB-reference */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMacros for environment frames (local stack frames)\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define FR_HIDE_CHILDS\t\t(0x0001) /* flag of pred after I_DEPART */\n#define FR_SKIPPED\t\t(0x0002) /* We have skipped on this frame */\n#define FR_MARKED\t\t(0x0004) /* GC */\n#define FR_MARKED_PRED\t\t(0x0008) /* GC predicates/clauses */\n#define FR_DEBUG\t\t(0x0010) /* GUI debugger */\n#define FR_CATCHED\t\t(0x0020) /* Frame caught an exception */\n#define FR_INBOX\t\t(0x0040) /* Inside box (for REDO in built-in) */\n#define FR_CONTEXT\t\t(0x0080) /* fr->context is set */\n#define FR_CLEANUP\t\t(0x0100) /* setup_call_cleanup/4 */\n#define FR_INRESET\t\t(0x0200) /* Continuations: inside reset/3 */\n#define FR_WATCHED (FR_CLEANUP|FR_DEBUG)\n\n#define FR_MAGIC_MASK\t\t(0xfffff000)\n#define FR_MAGIC_MASK2\t\t(0xffff0000)\n#define FR_MAGIC\t\t(0x549d5000)\n\n#define isFrame(fr)\t\t(((fr)->flags&FR_MAGIC_MASK) == FR_MAGIC)\n#define wasFrame(fr)\t\t(((fr)->flags&FR_MAGIC_MASK2) == \\\n\t\t\t\t (FR_MAGIC&FR_MAGIC_MASK2))\n#define killFrame(fr)\t\tclear(fr, (FR_MAGIC_MASK&~FR_MAGIC_MASK2))\n\n#define ARGOFFSET\t\t((int)sizeof(struct localFrame))\n#define VAROFFSET(var)\t\t((var)+(ARGOFFSET/(int)sizeof(word)))\n\n#define setLevelFrame(fr, l)\tdo { (fr)->level = (l); } while(0)\n#define levelFrame(fr)\t\t((fr)->level)\n#define argFrameP(f, n)\t\t((Word)((f)+1) + (n))\n#define argFrame(f, n)\t\t(*argFrameP((f), (n)) )\n#define varFrameP(f, n)\t\t((Word)(f) + (n))\n#define varFrame(f, n)\t\t(*varFrameP((f), (n)) )\n#define refFliP(f, n)\t\t((Word)((f)+1) + (n))\n#define parentFrame(f)\t\t((f)->parent ? (f)->parent\\\n\t\t\t\t\t     : (LocalFrame)varFrame((f), -1))\n#define slotsFrame(f)\t\t(true((f)->predicate, P_FOREIGN) ? \\\n\t\t\t\t      (f)->predicate->functor->arity : \\\n\t\t\t\t      (f)->clause->clause->prolog_vars)\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nGenerations must be 64-bit to  avoid   overflow  in realistic scenarios.\nThis makes them the only 64-bit value in struct localFrame. Stack frames\nmix with variables on the stacks and  are thus word-aligned. We have two\noptions here. One is to represent a  generation as a struct (used below)\nor we must align frame at 8-byte  boundaries. The latter is probably the\nbest solution, but merely aligning lTop in   I_ENTER  doesn't seem to be\ndoing the trick: it causes failure of the  test suite for which I failed\nto find the reason. Enabling the structure   on x86 causes a slowdown of\nabout 5%. I'd assume the difference is smaller on real 32-bit hardware.\n\nWe enable this  if the alignment  of an int64_t type  is not the same as\nthe alignment of pointers.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef O_LOGICAL_UPDATE\ntypedef uint64_t gen_t;\n\n#define GEN_MAX (~(gen_t)0)\n#define GEN_NEW_DIRTY (gen_t)0\n\n#if ALIGNOF_INT64_T != ALIGNOF_VOIDP\ntypedef struct lgen_t\n{ uint32_t\tgen_l;\n  uint32_t\tgen_u;\n} lgen_t;\n\n#define generationFrame(f) \\\n\t((gen_t)(f)->generation.gen_u<<32 | (gen_t)(f)->generation.gen_l)\n#define setGenerationFrameVal(f, g) \\\n\tdo { gen_t __gen = (g); \\\n\t     (f)->generation.gen_u = (uint32_t)(__gen>>32); \\\n\t     (f)->generation.gen_l = (uint32_t)(__gen); \\\n\t   } while(0)\n#else\ntypedef uint64_t lgen_t;\n#define generationFrame(f)\t((f)->generation)\n#define setGenerationFrameVal(f, gen) \\\n\tdo { (f)->generation = (gen); } while(0)\n#endif\n#ifdef HAVE___SYNC_ADD_AND_FETCH_8\ntypedef uint64_t ggen_t;\n#else\n#define ATOMIC_GENERATION_HACK 1\ntypedef struct ggen_t\n{ uint32_t\tgen_l;\n  uint32_t\tgen_u;\n} ggen_t;\n#endif /*HAVE___SYNC_ADD_AND_FETCH_8*/\n#else /*O_LOGICAL_UPDATE*/\n#define global_generation()\t (0)\n#define next_global_generation() (0)\n#endif /*O_LOGICAL_UPDATE*/\n\n#define setGenerationFrame(fr) setGenerationFrame__LD((fr) PASS_LD)\n\n#define FR_CLEAR_NEXT\tFR_SKIPPED|FR_WATCHED|FR_CATCHED|FR_HIDE_CHILDS|FR_CLEANUP\n#define FR_CLEAR_FLAGS\t(FR_CLEAR_NEXT|FR_CONTEXT)\n\n#define setNextFrameFlags(next, fr) \\\n\tdo \\\n\t{ (next)->level = (fr)->level+1; \\\n\t  (next)->flags = ((fr)->flags) & ~FR_CLEAR_FLAGS; \\\n\t} while(0)\n\n#define setFramePredicate(fr, def) \\\n\tdo \\\n\t{ (fr)->predicate = (def); \\\n\t} while(0)\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nPredicate reference counting. The aim  of   this  mechanism  is to avoid\nmodifying the predicate structure while  it   has  choicepoints  or (MT)\nother threads running the predicate. For dynamic  code we allow to clean\nthe predicate as the reference-count drops to   zero. For static code we\nintroduce a garbage collector (TBD).\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define enterDefinition(def) (void)0\n#define leaveDefinition(def) (void)0\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nAt times an abort is not allowed because the heap  is  inconsistent  the\nprogrammer  should  call  startCritical  to start such a code region and\nendCritical to end it.\n\nMT/TBD: how to handle this gracefully in the multi-threading case.  Does\nit mean anything?\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define startCritical (void)(LD->critical++)\n#define endCritical   ((--(LD->critical) == 0 && LD->alerted) \\\n\t\t\t\t? endCritical__LD(PASS_LD1) : TRUE)\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nLIST processing macros.\n\n    isNil(w)\t\tword is the nil list ([]).\n    isList(w)\t\tword is a './2' term.\n    HeadList(p)\t\tPointer to the head of list *p (NOT dereferenced).\n    TailList(p)\t\tPointer to the tail of list *p (NOT dereferenced).\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define HeadList(p)\t(argTermP(*(p), 0) )\n#define TailList(p)\t(argTermP(*(p), 1) )\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nDoubles. To and from are Word pointers pointing to the data of a double,\nbut generally not  satisfying  the   double  alignment  requirements. We\nassume\n\n  sizeof(*to) == sizeof(*from) &&\n  sizeof(*to) * n == sizeof(*double)\n\twith n == 1 or n == 2.\n\nWe assume the compiler will optimise this properly.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define cpDoubleData(to, from) \\\n\t{ Word _f = (Word)(from); \\\n\t  switch(WORDS_PER_DOUBLE) \\\n\t  { case 2: \\\n\t      *(to)++ = *_f++; \\\n\t    case 1: \\\n\t      *(to)++ = *_f++; \\\n\t      from = (void *)_f; \\\n\t      break; \\\n\t    default: \\\n\t      assert(0); \\\n\t  } \\\n\t}\n\n#define cpInt64Data(to, from) \\\n\t{ Word _f = (Word)(from); \\\n\t  switch(WORDS_PER_INT64) \\\n\t  { case 2: \\\n\t      *(to)++ = *_f++; \\\n\t    case 1: \\\n\t      *(to)++ = *_f++; \\\n\t      from = (void *)_f; \\\n\t      break; \\\n\t    default: \\\n\t      assert(0); \\\n\t  } \\\n\t}\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nStructure declarations that must be shared across multiple files.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstruct atom\n{ Atom\t\tnext;\t\t/* next in chain */\n  word\t\tatom;\t\t/* as appearing on the global stack */\n#ifdef O_TERMHASH\n  unsigned int  hash_value;\t/* hash-key value */\n#endif\n#ifdef O_ATOMGC\n  unsigned int\treferences;\t/* reference-count */\n#endif\n  union\n  { struct PL_blob_t * type;\t/* blob-extension */\n    uintptr_t\tnext_invalid;\t/* next invalidated atom */\n  };\n  size_t\tlength;\t\t/* length of the atom */\n  char *\tname;\t\t/* name associated with atom */\n};\n\n\ntypedef struct atom_array\n{ Atom blocks[8*sizeof(void*)];\n} atom_array;\n\ntypedef struct atom_table * AtomTable;\n\ntypedef struct atom_table\n{ AtomTable\tprev;\n  int\t\tbuckets;\n  Atom *\ttable;\n} atom_table;\n\n\n#ifdef O_ATOMGC\n\n#define ATOM_STATE_MASK\t\t((unsigned int)0xF << (INTBITSIZE-4))\n#define ATOM_RESERVED_REFERENCE\t((unsigned int)0x1 << (INTBITSIZE-1))\n#define ATOM_VALID_REFERENCE\t((unsigned int)0x1 << (INTBITSIZE-2))\n#define ATOM_MARKED_REFERENCE\t((unsigned int)0x1 << (INTBITSIZE-3))\n#define ATOM_DESTROY_REFERENCE\t((unsigned int)0x1 << (INTBITSIZE-4))\n\n#define ATOM_IS_FREE(ref)\t(((ref) & ATOM_STATE_MASK) == 0)\n#define ATOM_IS_RESERVED(ref)\t((ref) & ATOM_RESERVED_REFERENCE)\n#define ATOM_IS_VALID(ref)\t((ref) & ATOM_VALID_REFERENCE)\n#define ATOM_IS_MARKED(ref)\t((ref) & ATOM_MARKED_REFERENCE)\n#define ATOM_IS_DESTROYED(ref)\t((ref) & ATOM_DESTROY_REFERENCE)\n\n#define ATOM_REF_COUNT_MASK\t(~ATOM_STATE_MASK)\n#define ATOM_REF_COUNT(ref)\t((ref) & ATOM_REF_COUNT_MASK)\n\n#define ATOM_TYPE_INVALID\t((PL_blob_t*)0x007)\n\n#ifdef O_DEBUG_ATOMGC\nextern IOSTREAM *atomLogFd;\n#define PL_register_atom(a) \\\n\t_PL_debug_register_atom(a, __FILE__, __LINE__, __PRETTY_FUNCTION__)\n#define PL_unregister_atom(a) \\\n\t_PL_debug_unregister_atom(a, __FILE__, __LINE__, __PRETTY_FUNCTION__)\n#endif\n#else /*!O_ATOMGC*/\n#define PL_register_atom(a)\n#define PL_unregister_atom(a)\n#endif\n\nstruct functorDef\n{ FunctorDef\tnext;\t\t/* next in chain */\n  word\t\tfunctor;\t/* as appearing on the global stack */\n  word\t\tname;\t\t/* Name of functor */\n  size_t\tarity;\t\t/* arity of functor */\n  unsigned      flags;\t\t/* Flag field holding: */\n\t\t  /* CONTROL_F\t   Compiled control-structure */\n\t\t  /* ARITH_F\t   Arithmetic function */\n\t\t  /* VALID_F\t   Fully defined functor */\n};\n\n\ntypedef struct functor_array\n{ FunctorDef *blocks[8*sizeof(void*)];\n} functor_array;\n\ntypedef struct functor_table * FunctorTable;\n\ntypedef struct functor_table\n{ FunctorTable\tprev;\n  int\t\tbuckets;\n  FunctorDef *\ttable;\n} functor_table;\n\n#define FUNCTOR_IS_VALID(flags)\t\t((flags) & VALID_F)\n\n\n#ifdef O_LOGICAL_UPDATE\n#define VISIBLE_CLAUSE(cl, gen) \\\n\t( ( (cl)->generation.created <= (gen) && \\\n\t    (cl)->generation.erased   > (gen) && \\\n\t    (cl)->generation.erased  != LD->gen_reload \\\n\t  ) || \\\n\t  ( (cl)->generation.created == LD->gen_reload \\\n\t  ) \\\n\t)\n#define GLOBALLY_VISIBLE_CLAUSE(cl, gen) \\\n\t( (cl)->generation.created <= (gen) && \\\n\t  (cl)->generation.erased   > (gen) \\\n\t)\n#else\n#define VISIBLE_CLAUSE(cl, gen) false(cl, CL_ERASED)\n#define GLOBALLY_VISIBLE_CLAUSE(cl, gen) false(cl, CL_ERASED)\n#endif\n\n#define visibleClause(cl, gen) visibleClause__LD(cl, gen PASS_LD)\n#define visibleClauseCNT(cl, gen) visibleClauseCNT__LD(cl, gen PASS_LD)\n\n#define GEN_INVALID 0\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nStruct clause must be a  multiple   of  sizeof(word)  for compilation on\nbehalf  of  I_USERCALL.  This   is   verified    in   an   assertion  in\ncheckCodeTable().\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define sizeofClause(n) ((char *)&((Clause)NULL)->codes[n] - (char *)NULL)\n\nstruct clause\n{ Definition\t\tpredicate;\t/* Predicate I belong to */\n#ifdef O_LOGICAL_UPDATE\n  struct\n  { gen_t created;\t\t\t/* Generation that created me */\n    gen_t erased;\t\t\t/* Generation I was erased */\n  } generation;\n#endif /*O_LOGICAL_UPDATE*/\n  unsigned int\t\tvariables;\t/* # of variables for frame */\n  unsigned int\t\tprolog_vars;\t/* # real Prolog variables */\n  unsigned int\t\tflags;\t\t/* Flag field holding: */\n  unsigned int\t\tline_no;\t/* Source line-number */\n  unsigned int\t\tsource_no;\t/* Index of source-file */\n  unsigned int\t\towner_no;\t/* Index of owning source-file */\n  unsigned int\t\treferences;\t/* # ClauseRef pointing at me */\n  code\t\t\tcode_size;\t/* size of ->codes */\n  code\t\t\tcodes[1];\t/* VM codes of clause */\n};\n\ntypedef struct arg_info\n{ float\t\tspeedup;\t\t/* Computed speedup */\n  unsigned\tlist\t   : 1;\t\t/* Index using lists */\n  unsigned\tln_buckets : 5;\t\t/* lg2(bucket count) */\n  unsigned\tassessed   : 1;\t\t/* Value was assessed */\n  unsigned\tmeta\t   : 4;\t\t/* Meta-argument info */\n} arg_info;\n\ntypedef struct impl_any\n{ arg_info     *args;\t\t\t/* Meta and indexing info */\n  void         *defined;\t\t/* One of function or first_clause */\n} impl_any, *ImplAny;\n\ntypedef struct impl_foreign\n{ arg_info     *args;\t\t\t/* Meta and indexing info */\n  Func\t\tfunction;\t\t/* Function pointer */\n} impl_foreign, *ImplForeign;\n\ntypedef struct clause_list\n{ arg_info     *args;\t\t\t/* Meta and indexing info */\n  ClauseRef\tfirst_clause;\t\t/* clause list of procedure */\n  ClauseRef\tlast_clause;\t\t/* last clause of list */\n  ClauseIndex  *clause_indexes;\t\t/* Hash index(es) */\n  unsigned int\tnumber_of_clauses;\t/* number of associated clauses */\n  unsigned int\terased_clauses;\t\t/* number of erased clauses in set */\n  unsigned int\tnumber_of_rules;\t/* number of real rules */\n  unsigned int\tjiti_tried;\t\t/* number of times we tried to find */\n} clause_list, *ClauseList;\n\ntypedef struct clause_ref\n{ ClauseRef\tnext;\t\t\t/* Next in list */\n  union\n  { word\tkey;\t\t\t/* Index key */\n    ClauseRef\tgnext;\t\t\t/* Next garbage clause reference */\n  } d;\n  union\n  { Clause\tclause;\t\t\t/* Single clause value */\n    clause_list\tclauses;\t\t/* Clause list (in hash-tables) */\n  } value;\n} clause_ref;\n\n#define SIZEOF_CREF_CLAUSE\t(offsetof(clause_ref, value.clause) + \\\n\t\t\t\t sizeof(Clause))\n#define SIZEOF_CREF_LIST\tsizeof(clause_ref)\n\ntypedef struct cgc_stats\n{ int\t\tthreads;\t\t/* # threads to scan */\n  size_t\tlocal_size;\t\t/* Summed size of local stacks */\n  size_t\tdirty_pred_clauses;\t/* # clauses in dirty predicates */\n  int64_t\terased_skipped;\t\t/* # skipped clauses that are erased  */\n} cgc_stats;\n\n\n#define VM_DYNARGC    255\t/* compute argcount dynamically */\n\n#define CA1_PROC\t1\t/* code arg 1 is procedure */\n#define CA1_FUNC\t2\t/* code arg 1 is functor */\n#define CA1_DATA\t3\t/* code arg 2 is prolog data (H_ATOM, H_SMALLINT) */\n#define CA1_INTEGER\t4\t/* intptr_t value */\n#define CA1_INT64\t5\t/* int64 value */\n#define CA1_FLOAT\t6\t/* next WORDS_PER_DOUBLE are double */\n#define CA1_STRING\t7\t/* inlined string */\n#define CA1_MODULE\t8\t/* a module */\n#define CA1_VAR\t\t9\t/* a variable(-offset) */\n#define CA1_FVAR       10\t/* a variable(-offset), used as `firstvar' */\n#define CA1_CHP\t       11\t/* ChoicePoint (also variable(-offset)) */\n#define CA1_MPZ\t       12\t/* GNU mpz number */\n#define CA1_FOREIGN    13\t/* Foreign function pointer */\n#define CA1_CLAUSEREF  14\t/* Clause reference */\n#define CA1_JUMP       15\t/* Instructions to skip */\n#define CA1_AFUNC      16\t/* Number of arithmetic function */\n\n#define VIF_BREAK      0x01\t/* Can be a breakpoint */\n\ntypedef enum\n{ VMI_REPLACE,\n  VMI_STEP_ARGUMENT\n} vmi_merge_type;\n\ntypedef struct\n{ vmi\t\tcode;\t\t/* Code to merge with */\n  vmi_merge_type how;\t\t/* How to merge? */\n  vmi\t\tmerge_op;\t/* Opcode of merge */\n  int\t\tmerge_ac;\t/* #arguments of merged code */\n  code\t\tmerge_av[1];\t/* Argument vector */\n} vmi_merge;\n\ntypedef struct\n{ char\t       *name;\t\t/* name of the code */\n  vmi\t\tcode;\t\t/* number of the code */\n  unsigned char flags;\t\t/* Addional flags (VIF_*) */\n  unsigned char\targuments;\t/* #args code takes (or VM_DYNARGC) */\n  char\t\targtype[4];\t/* Argument type(s) code takes */\n} code_info;\n\nstruct mark\n{ TrailEntry\ttrailtop;\t/* top of the trail stack */\n  Word\t\tglobaltop;\t/* top of the global stack */\n  Word\t\tsaved_bar;\t/* saved LD->mark_bar */\n};\n\nstruct functor\n{ word\t\tdefinition;\t/* Tagged definition pointer */\n  word\t\targuments[1];\t/* arguments vector */\n};\n\nstruct clause_bucket\n{ ClauseRef\thead;\n  ClauseRef\ttail;\n  unsigned int\tdirty;\t\t\t/* # of garbage clauses */\n};\n\n#define MAX_MULTI_INDEX  4\n#define MAXINDEXARG    254\n#define MAXINDEXDEPTH    7\n#define END_INDEX_POS  255\n\ntypedef unsigned char iarg_t;\t\t/* index argument */\n\nstruct clause_index\n{ unsigned int\t buckets;\t\t/* # entries */\n  unsigned int\t size;\t\t\t/* # clauses */\n  unsigned int\t resize_above;\t\t/* consider resize > #clauses */\n  unsigned int\t resize_below;\t\t/* consider resize < #clauses */\n  unsigned int\t dirty;\t\t\t/* # chains that are dirty */\n  unsigned\t is_list : 1;\t\t/* Index with lists */\n  unsigned\t incomplete : 1;\t/* Index is incomplete */\n  iarg_t\t args[MAX_MULTI_INDEX];\t/* Indexed arguments */\n  iarg_t\t position[MAXINDEXDEPTH+1]; /* Deep index position */\n  float\t\t speedup;\t\t/* Estimated speedup */\n  ClauseBucket\t entries;\t\t/* chains holding the clauses */\n};\n\n#define MAX_BLOCKS 20\t\t\t/* allows for 2M threads */\n\ntypedef struct local_definitions\n{ Definition *blocks[MAX_BLOCKS];\n  Definition preallocated[7];\n} local_definitions;\n\nstruct definition\n{ FunctorDef\tfunctor;\t\t/* Name/Arity of procedure */\n  Module\tmodule;\t\t\t/* module of the predicate */\n  Code\t\tcodes;\t\t\t/* Executable code */\n  union\n  { impl_any\tany;\t\t\t/* has some value */\n    clause_list\tclauses;\t\t/* (Indexed) list of clauses */\n    impl_foreign foreign;\t\t/* Foreign implementation */\n    LocalDefinitions local;\t\t/* P_THREAD_LOCAL predicates */\n  } impl;\n  unsigned int  flags;\t\t\t/* booleans (P_*) */\n  unsigned int  shared;\t\t\t/* #procedures sharing this def */\n  struct linger_list  *lingering;\t/* Assocated lingering objects */\n  gen_t\t\tlast_modified;\t\t/* Generation I was last modified */\n#ifdef O_PROF_PENTIUM\n  int\t\tprof_index;\t\t/* index in profiling */\n  char\t       *prof_name;\t\t/* name in profiling */\n#endif\n};\n\nstruct definition_chain\n{ Definition\t\tdefinition;\t/* chain on definition */\n  DefinitionChain\tnext;\t\t/* next in chain */\n};\n\nstruct dirty_def_info\n{ gen_t\t\toldest_generation;\t/* Oldest generation seen */\n};\n\ntypedef struct definition_ref\n{ Definition predicate;\t\t\t/* Referenced definition */\n  gen_t\t     generation;\t\t/* at generation */\n} definition_ref;\n\ntypedef struct definition_refs\n{ definition_ref *blocks[MAX_BLOCKS];\n  definition_ref preallocated[7];\n  size_t     top;\n} definition_refs;\n\n#define\tPROC_WEAK\t (0x0001)\t/* implicit import */\n#define\tPROC_MULTISOURCE (0x0002)\t/* Assigned to multiple sources */\n\nstruct procedure\n{ Definition\t definition;\t\t/* definition of procedure */\n  unsigned short flags;\t\t\t/* PROC_WEAK */\n  unsigned short source_no;\t\t/* Source I'm assigned to */\n};\n\nstruct localFrame\n{ Code\t\tprogramPointer;\t\t/* pointer into program */\n  LocalFrame\tparent;\t\t\t/* parent local frame */\n  ClauseRef\tclause;\t\t\t/* Current clause of frame */\n  Definition\tpredicate;\t\t/* Predicate we are running */\n  Module\tcontext;\t\t/* context module of frame */\n#ifdef O_PROFILE\n  struct call_node *prof_node;\t\t/* Profiling node */\n#endif\n#ifdef O_LOGICAL_UPDATE\n  lgen_t\tgeneration;\t\t/* generation of the database */\n#endif\n  unsigned int\tlevel;\t\t\t/* recursion level */\n  unsigned int\tflags;\t\t\t/* packed long holding: */\n};\n\n\ntypedef enum\n{ CHP_JUMP = 0,\t\t\t\t/* A jump due to ; */\n  CHP_CLAUSE,\t\t\t\t/* Next clause of predicate */\n  CHP_TOP,\t\t\t\t/* First (toplevel) choice */\n  CHP_CATCH,\t\t\t\t/* $catch initiated choice */\n  CHP_DEBUG\t\t\t\t/* Enable redo */\n} choice_type;\n\ntypedef enum\n{ DBG_OFF = 0,\t\t\t\t/* no debugging */\n  DBG_ON,\t\t\t\t/* switch on in current environment */\n  DBG_ALL\t\t\t\t/* switch on globally */\n} debug_type;\n\n#define SKIP_VERY_DEEP\t  ((size_t)-1)\t/* deep skiplevel */\n#define SKIP_REDO_IN_SKIP (SKIP_VERY_DEEP-1)\n\nstruct clause_choice\n{ ClauseRef\tcref;\t\t\t/* Next clause reference */\n  word\t\tkey;\t\t\t/* Search key */\n};\n\n#ifdef O_PLMT\n#define acquire_def(def) \\\n\tdo { DEBUG(CHK_SECURE, assert(!LD->thread.info->access.predicate)); \\\n\t     LD->thread.info->access.predicate = def; } while(0)\n#define release_def(def) \\\n\tdo { LD->thread.info->access.predicate = NULL; } while(0)\n#define acquire_def2(def, store) \\\n\tdo { store = LD->thread.info->access.predicate; \\\n\t     DEBUG(CHK_SECURE, assert(!store || store == def)); \\\n\t     LD->thread.info->access.predicate = def; } while(0)\n#define release_def2(def, store) \\\n\tdo { LD->thread.info->access.predicate = store; } while(0)\n\n#else\n#define acquire_def(def) (void)0\n#define release_def(def) (void)0\n#define acquire_def2(def,store) (void)store\n#define release_def2(def,store) (void)store\n#endif\n\nstruct choice\n{ choice_type\ttype;\t\t\t/* CHP_* */\n  Choice\tparent;\t\t\t/* Alternative if I fail */\n  mark\t\tmark;\t\t\t/* data mark for undo */\n  LocalFrame\tframe;\t\t\t/* Frame I am related to */\n#ifdef O_PROFILE\n  struct call_node *prof_node;\t\t/* Profiling node */\n#endif\n  union\n  { struct clause_choice clause;\t/* Next candidate clause */\n    Code\tPC;\t\t\t/* Next candidate program counter */\n    word        foreign;\t\t/* foreign redo handle */\n  } value;\n};\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nEXCEPTION_GUARDED(code, cleanup) must be used  in environments that need\ncleanup  should  a  PL_throw()  happen.  The   most  commpn  reason  for\nPL_throw() instead of the nicely   synchronous PL_raise_exception() is a\nstack overflow.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define EXCEPTION_GUARDED(code, cleanup) \\\n\t{ exception_frame __throw_env; \\\n\t  __throw_env.parent = LD->exception.throw_environment; \\\n\t  if ( setjmp(__throw_env.exception_jmp_env) != 0 ) \\\n\t  { LD->exception.throw_environment = __throw_env.parent; \\\n\t    cleanup; \\\n\t  } else \\\n\t  { __throw_env.magic = THROW_MAGIC; \\\n\t    LD->exception.throw_environment = &__throw_env; \\\n\t    code; \\\n\t    assert(LD->exception.throw_environment == &__throw_env); \\\n\t    __throw_env.magic = 41414141; \\\n\t    LD->exception.throw_environment = __throw_env.parent; \\\n\t  } \\\n\t}\n\n#define THROW_MAGIC 42424242\n\ntypedef struct exception_frame\t\t/* PL_throw exception environments */\n{ struct exception_frame *parent;\t/* parent frame */\n  int\t\tmagic;\t\t\t/* THROW_MAGIC */\n  jmp_buf\texception_jmp_env;\t/* longjmp environment */\n} exception_frame;\n\n\n#define QF_NODEBUG\t\t0x0001\t/* debug-able query */\n#define QF_DETERMINISTIC\t0x0002\t/* deterministic success */\n#define\tQF_INTERACTIVE\t\t0x0004\t/* interactive goal (prolog()) */\n\nstruct queryFrame\n{ uintptr_t magic;\t\t\t/* Magic code for security */\n  struct\t\t\t\t/* Interpreter registers */\n  { LocalFrame  fr;\n    Word\targp;\n    Code\tpc;\n  } registers;\n  LocalFrame\tnext_environment;\t/* See D_BREAK and get_vmi_state() */\n#ifdef O_LIMIT_DEPTH\n  uintptr_t saved_depth_limit;\t\t/* saved values of these */\n  uintptr_t saved_depth_reached;\n#endif\n#if O_CATCHTHROW\n  term_t\texception;\t\t/* Exception term */\n#endif\n  struct\n  { term_t\tterm;\t\t\t/* Handle to exchange data */\n  } yield;\n  fid_t\t\tforeign_frame;\t\t/* Frame after PL_next_solution() */\n  unsigned int\tflags;\n  debug_type\tdebugSave;\t\t/* saved debugstatus.debugging */\n  unsigned int\tflags_saved;\t\t/* Saved boolean Prolog flags */\n  int\t\tsolutions;\t\t/* # of solutions produced */\n  Word\t       *aSave;\t\t\t/* saved argument-stack */\n  Choice\tsaved_bfr;\t\t/* Saved choice-point */\n  LocalFrame\tsaved_ltop;\t\t/* Saved lTop */\n  QueryFrame\tparent;\t\t\t/* Parent queryFrame */\n  struct choice\tchoice;\t\t\t/* First (dummy) choice-point */\n  LocalFrame\tsaved_environment;\t/* Parent local-frame */\n\t\t\t\t\t/* Do not put anything between */\n\t\t\t\t\t/* or check parentFrame() */\n  struct localFrame top_frame;\t\t/* The (dummy) top local frame */\n  struct localFrame frame;\t\t/* The initial frame */\n};\n\n\n#define FLI_MAGIC\t\t82649821\n#define FLI_MAGIC_CLOSED\t42424242\n\nstruct fliFrame\n{ int\t\tmagic;\t\t\t/* Magic code */\n  int\t\tsize;\t\t\t/* # slots on it */\n  FliFrame\tparent;\t\t\t/* parent FLI frame */\n  mark\t\tmark;\t\t\t/* data-stack mark */\n};\n\n#ifdef O_MAINTENANCE\n#define REC_MAGIC 27473244\n#endif\n\nstruct record\n{ int\t\tsize;\t\t\t/* # bytes of the record */\n  unsigned      gsize;\t\t\t/* Size on global stack */\n  unsigned\tnvars;\t\t\t/* # variables in the term */\n  unsigned\tflags;\t\t\t/* Flags, holding */\n\t\t\t\t\t/* R_ERASED */\n\t\t\t\t\t/* R_EXTERNAL */\n\t\t\t\t\t/* R_DUPLICATE */\n\t\t\t\t\t/* R_NOLOCK */\n\t\t\t\t\t/* R_DBREF */\n#ifdef REC_MAGIC\n  int\t\tmagic;\t\t\t/* REC_MAGIC */\n#endif\n  int\t\treferences;\t\t/* PL_duplicate_record() support */\n  char\t\tbuffer[1];\t\t/* array holding codes */\n};\n\nstruct recordList\n{ RecordRef\tfirstRecord;\t\t/* first record associated with key */\n  RecordRef\tlastRecord;\t\t/* last record associated with key */\n  struct recordList *next;\t\t/* Next recordList */\n  word\t\tkey;\t\t\t/* key of record */\n  unsigned int\tflags;\t\t\t/* RL_DIRTY */\n  int\t\treferences;\t\t/* choicepoints reference count */\n};\n\nstruct recordRef\n{ RecordList\tlist;\t\t\t/* list I belong to */\n  RecordRef\tnext;\t\t\t/* next in list */\n  RecordRef\tprev;\t\t\t/* previous in list */\n  Record\trecord;\t\t\t/* the record itself */\n};\n\n\n\t\t /*******************************\n\t\t *\tEXCEPTION CLASSES\t*\n\t\t *******************************/\n\ntypedef enum except_class\n{ EXCEPT_NONE = 0,\t\t\t/* no exception */\n  EXCEPT_OTHER,\t\t\t\t/* any other exception */\n  EXCEPT_ERROR,\t\t\t\t/* ISO error(Formal,Context) */\n  EXCEPT_RESOURCE,\t\t\t/* ISO error(resource_error(_), _) */\n  EXCEPT_TIMEOUT,\t\t\t/* time_limit_exceeded */\n  EXCEPT_ABORT\t\t\t\t/* '$aborted' */\n} except_class;\n\n\n\t\t /*******************************\n\t\t *\tSOURCE FILE ADMIN\t*\n\t\t *******************************/\n\n#define SF_MAGIC 0x14a3c90f\n#define SF_MAGIC_DESTROYING 0x14a3c910\n\ntypedef struct p_reload\n{ Definition\tpredicate;\t\t/* definition we are working on */\n  gen_t\t\tgeneration;\t\t/* generation we update */\n  ClauseRef\tcurrent_clause;\t\t/* currently reloading clause */\n  arg_info     *args;\t\t\t/* Meta info on arguments */\n  unsigned\tflags;\t\t\t/* new flags (P_DYNAMIC, etc.) */\n  unsigned\tnumber_of_clauses;\t/* Number of clauses we've seen */\n} p_reload;\n\ntypedef struct m_reload\n{ Module\tmodule;\n  Table\t\tpublic;\t\t\t/* new export list */\n} m_reload;\n\ntypedef struct sf_reload\n{ Table\t\tprocedures;\t\t/* Procedures being reloaded */\n  gen_t\t\treload_gen;\t\t/* Magic gen for reloading */\n  size_t\tpred_access_count;\t/* Top of predicate access stack */\n  Table\t\tmodules;\t\t/* Modules seen during reload */\n  unsigned\tnumber_of_clauses;\t/* reload clause count */\n} sf_reload;\n\n\nstruct sourceFile\n{ atom_t\tname;\t\t\t/* name of source file */\n  double\tmtime;\t\t\t/* modification time when loaded */\n  ListCell\tprocedures;\t\t/* List of associated procedures */\n  Procedure\tcurrent_procedure;\t/* currently loading one */\n  ListCell\tmodules;\t\t/* Modules associated to this file */\n  sf_reload     *reload;\t\t/* Reloading context */\n#ifdef O_PLMT\n  counting_mutex *mutex;\t\t/* Mutex to guard procedures */\n#endif\n  int\t\tmagic;\t\t\t/* Magic number */\n  int\t\tcount;\t\t\t/* number of times loaded */\n  unsigned\tnumber_of_clauses;\t/* number of clauses */\n  unsigned\tindex     : 24;\t\t/* index number (1,2,...) */\n  unsigned\tsystem     : 1;\t\t/* system sourcefile: do not reload */\n  unsigned\tfrom_state : 1;\t\t/* Loaded from resource DB state */\n  unsigned\tresource   : 1;\t\t/* Loaded from resource DB file */\n};\n\ntypedef struct srcfile_array\n{ SourceFile *blocks[8*sizeof(void*)];\n} srcfile_array;\n\nstruct list_cell\n{ void *\tvalue;\t\t/* object in the cell */\n  ListCell\tnext;\t\t/* next in chain */\n};\n\n\n\t\t /*******************************\n\t\t *\t      MODULES\t\t*\n\t\t *******************************/\n\nstruct module\n{ atom_t\tname;\t\t/* name of module */\n  atom_t\tclass;\t\t/* class of the module */\n  SourceFile\tfile;\t\t/* file from which module is loaded */\n  Table\t\tprocedures;\t/* predicates associated with module */\n  Table\t\tpublic;\t\t/* public predicates associated */\n  Table\t\toperators;\t/* local operator declarations */\n  ListCell\tsupers;\t\t/* Import predicates from here */\n  ListCell\tlingering;\t/* Lingering definitions */\n  size_t\tcode_size;\t/* #Bytes used for its procedures */\n  size_t\tcode_limit;\t/* Limit for code_size */\n#ifdef O_PLMT\n  counting_mutex *mutex;\t/* Mutex to guard module modifications */\n#endif\n#ifdef O_PROLOG_HOOK\n  Procedure\thook;\t\t/* Hooked module */\n#endif\n  int\t\tlevel;\t\t/* Distance to root (root=0) */\n  unsigned int\tline_no;\t/* Source line-number */\n  unsigned int  flags;\t\t/* booleans: */\n  int\t\treferences;\t/* see acquireModule() */\n  gen_t\t\tlast_modified;\t/* Generation I was last modified */\n};\n\nstruct trail_entry\n{ Word\t\taddress;\t/* address of the variable */\n};\n\nstruct gc_trail_entry\n{ word\t\taddress;\t/* address of the variable */\n};\n\n\t\t /*******************************\n\t\t *\t   META PREDICATE\t*\n\t\t *******************************/\n\n/*0..9*/\t\t\t\t/* 0..9: `Extra meta arguments' */\n#define MA_META\t\t10\t\t/* : */\n#define MA_VAR\t\t11\t\t/* - */\n#define MA_ANY\t\t12\t\t/* ? */\n#define MA_NONVAR\t13\t\t/* + */\n#define MA_HAT\t\t14\t\t/* ^ */\n#define MA_DCG\t\t15\t\t/* // */\n\n#define MA_NEEDS_TRANSPARENT(m) \\\n\t((m) < 10 || (m) == MA_META || (m) == MA_HAT || (m) == MA_DCG)\n\n\t\t /*******************************\n\t\t *\t     MARK/UNDO\t\t*\n\t\t *******************************/\n\n#define setVar(w)\t((w) = (word) 0)\n\n#ifdef O_DESTRUCTIVE_ASSIGNMENT\n\n#define Undo(b)\t\tdo_undo(&b)\n\n#else /*O_DESTRUCTIVE_ASSIGNMENT*/\n\n#define Undo(b)\t\tdo { TrailEntry tt = tTop; \\\n\t\t\t     TrailEntry mt = (b).trailtop; \\\n\t\t\t     while(tt > mt) \\\n\t\t\t     { tt--; \\\n\t\t\t       setVar(*tt->address); \\\n\t\t\t     } \\\n\t\t\t     tTop = tt; \\\n\t\t\t     gTop = (LD->frozen_bar > (b).globaltop ? \\\n\t\t\t             LD->frozen_bar : (b).globaltop); \\\n\t\t\t    } while(0)\n#endif /*O_DESTRUCTIVE_ASSIGNMENT*/\n\n#define NO_MARK_BAR\t(Word)(~(uintptr_t)0)\n\n#define Mark(b)\t\tdo { (b).trailtop  = tTop; \\\n\t\t\t     (b).saved_bar = LD->mark_bar; \\\n\t\t\t     DEBUG(CHK_SECURE, \\\n\t\t\t\t   assert((b).saved_bar == NO_MARK_BAR || \\\n\t\t\t\t\t  ((b).saved_bar >= gBase && \\\n\t\t\t\t\t   (b).saved_bar <= gTop))); \\\n\t\t\t     (b).globaltop = gTop; \\\n\t\t\t     if ( LD->mark_bar != NO_MARK_BAR ) \\\n\t\t\t       LD->mark_bar = (b).globaltop; \\\n\t\t\t   } while(0)\n#define DiscardMark(b)\tdo { LD->mark_bar = (LD->frozen_bar > (b).saved_bar ? \\\n\t\t\t\t\t     LD->frozen_bar : (b).saved_bar); \\\n\t\t\t     DEBUG(CHK_SECURE, \\\n\t\t\t\t   assert(LD->mark_bar == NO_MARK_BAR || \\\n\t\t\t\t\t  (LD->mark_bar >= gBase && \\\n\t\t\t\t\t   LD->mark_bar <= gTop))); \\\n\t\t\t   } while(0)\n#define NOT_A_MARK\t(TrailEntry)(~(word)0)\n#define NoMark(b)\tdo { (b).trailtop = NOT_A_MARK; \\\n\t\t\t   } while(0)\n#define isRealMark(b)\t((b).trailtop != NOT_A_MARK)\n\n\n\t\t /*******************************\n\t\t *\t     TRAILING\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nNote that all trail operations demand that   the caller ensures there is\nat least one free cell on the trail-stack.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define Trail(p, w) Trail__LD(p, w PASS_LD)\n\t\t\t\t\t/* trail local stack pointer */\n#define LTrail(p) \\\n  (void)((tTop++)->address = p)\n\t\t\t\t\t/* trail global stack pointer */\n#define GTrail(p) \\\n  do { if ( p < LD->mark_bar ) \\\n         (tTop++)->address = p; \\\n     } while(0)\n\n\n\t\t /*******************************\n\t\t *\t    SUPERVISORS\t\t*\n\t\t *******************************/\n\n#define SUPERVISOR(name)\t(&PL_code_data.supervisors.name[1])\n\n\n\n\t\t /*******************************\n\t\t *\t   FLI INTERNALS\t*\n\t\t *******************************/\n\n#define consTermRef(p)\t ((Word)(p) - (Word)(lBase))\n#define valTermRef(r)\t (&((Word)(lBase))[r])\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTemporary store/restore pointers to make them safe over GC/shift\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define TMP_PTR_SIZE\t(4)\n#define PushPtr(p)\tdo { int i = LD->tmp.top++; \\\n\t\t\t     assert(i<TMP_PTR_SIZE); \\\n\t\t\t     *valTermRef(LD->tmp.h[i]) = makeRef(p); \\\n\t\t\t   } while(0)\n#define PopPtr(p)\tdo { int i = --LD->tmp.top; \\\n\t\t\t     p = unRef(*valTermRef(LD->tmp.h[i])); \\\n\t\t\t     setVar(*valTermRef(LD->tmp.h[i])); \\\n\t\t\t   } while(0)\n#define PushVal(w)\tdo { int i = LD->tmp.top++; \\\n\t\t\t     assert(i<TMP_PTR_SIZE); \\\n\t\t\t     *valTermRef(LD->tmp.h[i]) = w; \\\n\t\t\t   } while(0)\n#define PopVal(w)\tdo { int i = --LD->tmp.top; \\\n\t\t\t     w = *valTermRef(LD->tmp.h[i]); \\\n\t\t\t     setVar(*valTermRef(LD->tmp.h[i])); \\\n\t\t\t   } while(0)\n\n\n#define QueryFromQid(qid)\t((QueryFrame) valTermRef(qid))\n#define QidFromQuery(f)\t\t(consTermRef(f))\n#define QID_EXPORT_WAM_TABLE\t(qid_t)(-1)\n\n#define PL_ARITY_AS_SIZE\n#include \"SWI-Prolog.h\"\n\n\n\t\t /*******************************\n\t\t *\t       SIGNALS\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSWI-Prolog may be compiled without signal handling. Even in that case we\nstill have signals that trigger Prolog   housekeeping  events. These are\nnot bound to operating system signal handling though.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#if HAVE_SIGNAL\n#define MAXSIGNAL\t\t64\t/* highest system signal number */\n#define SIG_PROLOG_OFFSET\t32\t/* Start of Prolog signals */\n\n#else /* HAVE_SIGNAL */\n\n#define MAXSIGNAL\t\t32\t/* highest system signal number */\n#define SIG_PROLOG_OFFSET\t1\t/* Start of Prolog signals */\n\n#endif /* HAVE_SIGNAL */\n\n#ifndef RETSIGTYPE\n#define RETSIGTYPE void\n#endif\ntypedef RETSIGTYPE (*handler_t)(int);\n\ntypedef struct\n{ handler_t   saved_handler;\t\t/* Original handler */\n  handler_t   handler;\t\t\t/* User signal handler */\n  predicate_t predicate;\t\t/* Prolog handler */\n  int\t      flags;\t\t\t/* PLSIG_*, defined in pl-setup.c */\n} sig_handler, *SigHandler;\n\n\n#ifdef O_ATOMGC\n#define SIG_ATOM_GC\t  (SIG_PROLOG_OFFSET+0)\n#endif\n#define SIG_GC\t\t  (SIG_PROLOG_OFFSET+1)\n#ifdef O_PLMT\n#define SIG_THREAD_SIGNAL (SIG_PROLOG_OFFSET+2)\n#endif\n#define SIG_CLAUSE_GC\t  (SIG_PROLOG_OFFSET+3)\n#define SIG_PLABORT\t  (SIG_PROLOG_OFFSET+4)\n\n\n\t\t /*******************************\n\t\t *\t      EVENTS\t\t*\n\t\t *******************************/\n\ntypedef enum pl_event_type\n{ PLEV_ABORT,\t\t\t\t/* Execution aborted */\n  PLEV_ERASED_CLAUSE,\t\t\t/* clause was erased */\n  PLEV_ERASED_RECORD,\t\t\t/* record was erased */\n  PLEV_DEBUGGING,\t\t\t/* changed debugging mode */\n  PLEV_TRACING,\t\t\t\t/* changed tracing mode */\n  PLEV_SPY,\t\t\t\t/* changed spypoint */\n  PLEV_BREAK,\t\t\t\t/* a break-point was set */\n  PLEV_BREAK_EXISTS,\t\t\t/* existing breakpoint */\n  PLEV_NOBREAK,\t\t\t\t/* a break-point was cleared */\n  PLEV_GCNOBREAK,\t\t\t/* cleared due to clause GC */\n  PLEV_FRAMEFINISHED,\t\t\t/* A watched frame was discarded */\n  PL_EV_THREADFINISHED\t\t\t/* A thread has finished */\n} pl_event_type;\n\n\n\t\t /*******************************\n\t\t *\t       COMPARE\t\t*\n\t\t *******************************/\n\n/* Results from comparison operations.  Mostly used by compareStandard() */\n\n#define CMP_COMPOUND -3\t\t\t/* compare_primitive */\n#define CMP_ERROR    -2\t\t\t/* Error (out of memory) */\n#define CMP_LESS     -1\t\t\t/* < */\n#define CMP_EQUAL     0\t\t\t/* == */\n#define CMP_GREATER   1\t\t\t/* > */\n#define CMP_NOTEQ     2\t\t\t/* \\== */\n\n\t\t/********************************\n\t\t*             STACKS            *\n\t\t*********************************/\n\n#ifdef small\t\t\t\t/* defined by MSVC++ 2.0 windows.h */\n#undef small\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nIf we have access to the virtual   memory management of the machine, use\nthis to enlarge the runtime stacks.  Otherwise use the stack-shifter.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define GC_FAST_POLICY 0x1\t\t/* not really used yet */\n\n#define STACK(type) \\\n\t{ type\t\tbase;\t\t/* base address of the stack */     \\\n\t  type\t\ttop;\t\t/* current top of the stack */      \\\n\t  type\t\tmax;\t\t/* allocated maximum */\t\t    \\\n\t  size_t\tgced_size;\t/* size after last GC */\t    \\\n\t  size_t\tsmall;\t\t/* Do not GC below this size */\t    \\\n\t  size_t\tspare;\t\t/* Current reserved area */\t    \\\n\t  size_t\tdef_spare;\t/* Desired reserved area */\t    \\\n\t  size_t\tmin_free;\t/* Free left when trimming */\t    \\\n\t  bool\t\tgc;\t\t/* Can be GC'ed? */\t\t    \\\n\t  int\t\tfactor;\t\t/* How eager we are */\t\t    \\\n\t  int\t\tpolicy;\t\t/* Time, memory optimization */\t    \\\n\t  int\t        overflow_id;\t/* OVERFLOW_* */\t\t    \\\n\t  const char   *name;\t\t/* Symbolic name of the stack */    \\\n\t}\n\nstruct stack STACK(caddress);\t\t/* Anonymous stack */\n\ntypedef struct\n{ size_t limit;\t\t\t\t/* Total stack limit */\n  struct STACK(LocalFrame) local;\t/* local (environment) stack */\n  struct STACK(Word)\t   global;\t/* local (environment) stack */\n  struct STACK(TrailEntry) trail;\t/* trail stack */\n  struct STACK(Word *)\t   argument;\t/* argument stack */\n} pl_stacks_t;\n\n#define tBase\t(LD->stacks.trail.base)\n#define tTop\t(LD->stacks.trail.top)\n#define tMax\t(LD->stacks.trail.max)\n\n#define lBase\t(LD->stacks.local.base)\n#define lTop\t(LD->stacks.local.top)\n#define lMax\t(LD->stacks.local.max)\n\n#define gBase\t(LD->stacks.global.base)\n#define gTop\t(LD->stacks.global.top)\n#define gMax\t(LD->stacks.global.max)\n\n#define aBase\t(LD->stacks.argument.base)\n#define aTop\t(LD->stacks.argument.top)\n#define aMax\t(LD->stacks.argument.max)\n\n#define tSpare\t(LD->stacks.trail.spare)\n\n#define onStack(name, addr) \\\n\t((char *)(addr) >= (char *)LD->stacks.name.base && \\\n\t (char *)(addr) <  (char *)LD->stacks.name.top)\n#define onStackArea(name, addr) \\\n\t((char *)(addr) >= (char *)LD->stacks.name.base && \\\n\t (char *)(addr) <  (char *)LD->stacks.name.max)\n#define onTrailArea(addr) \\\n\t((char *)(addr) >= (char *)tBase && \\\n\t (char *)(addr) <  (char *)tMax + tSpare)\n#define onGlobalArea(addr) \\\n\t((char *)(addr) >= (char *)gBase && \\\n\t (char *)(addr) <  (char *)lBase)\n#define usedStackP(s) ((intptr_t)((char *)(s)->top - (char *)(s)->base))\n#define sizeStackP(s) ((intptr_t)((char *)(s)->max - (char *)(s)->base))\n#define roomStackP(s) ((intptr_t)((char *)(s)->max - (char *)(s)->top))\n#define spaceStackP(s) (limitStackP(s)-usedStackP(s))\n#define narrowStackP(s) (roomStackP(s) < (intptr_t)(s)->minfree)\n\n#define usedStack(name) usedStackP(&LD->stacks.name)\n#define sizeStack(name) sizeStackP(&LD->stacks.name)\n#define roomStack(name) roomStackP(&LD->stacks.name)\n#define spaceStack(name) spaceStackP(&LD->stacks.name)\n#define narrowStack(name) narrowStackP(&LD->stacks.name)\n\n#define globalStackLimit() (LD->stacks.limit > (MAXTAGGEDPTR+1) ? \\\n\t\t\t\t\t       (MAXTAGGEDPTR+1) : \\\n\t\t\t\t\t       LD->stacks.limit)\n\n#define GROW_TRIM  ((size_t)-1)\n#define GROW_TIGHT ((size_t)1)\n\n#define\tLOCAL_OVERFLOW\t  (-1)\n#define\tGLOBAL_OVERFLOW\t  (-2)\n#define\tTRAIL_OVERFLOW\t  (-3)\n#define\tARGUMENT_OVERFLOW (-4)\n#define STACK_OVERFLOW    (-5)\t\t/* total stack limit overflow */\n#define\tMEMORY_OVERFLOW   (-6)\t\t/* out of malloc()-heap */\n\n#define ALLOW_NOTHING\t0x0\n#define ALLOW_GC\t0x1\t\t/* allow GC on stack overflow */\n#define ALLOW_SHIFT\t0x2\t\t/* allow shift on stack overflow */\n#define ALLOW_CHECKED\t0x4\t\t/* we already verified space */\n#define ALLOW_RETCODE\t0x8\t\t/* do not allow anything; return status */\n\ntypedef enum\n{ STACK_OVERFLOW_RAISE,\n  STACK_OVERFLOW_THROW\n} stack_overflow_action;\n\n#define pushArgumentStack(p) \\\n\tdo { if ( likely(aTop+1 < aMax) ) \\\n\t       *aTop++ = (p); \\\n\t     else \\\n\t       pushArgumentStack__LD((p) PASS_LD); \\\n\t   } while(0)\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nhasGlobalSpace(n) is true if we have enough space to create an object of\nsize N on the global stack AND  can   use  bindConst()  to bind it to an\n(attributed) variable.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define BIND_GLOBAL_SPACE (7)\n#define BIND_TRAIL_SPACE (6)\n#define hasGlobalSpace(n) \\\n\t(likely(gTop+(n)+BIND_GLOBAL_SPACE <= gMax) && \\\n\t likely(tTop+BIND_TRAIL_SPACE <= tMax))\n#define overflowCode(n) \\\n\t( (gTop+(n)+BIND_GLOBAL_SPACE > gMax) ? GLOBAL_OVERFLOW \\\n\t\t\t\t\t      : TRAIL_OVERFLOW )\n#define GLOBAL_TRAIL_RATIO (6)\n\n\n\t\t /*******************************\n\t\t *\t     NUMBERVARS\t\t*\n\t\t *******************************/\n\ntypedef enum\n{ AV_BIND,\n  AV_SKIP,\n  AV_ERROR\n} av_action;\n\n#define NV_ERROR (PLMINTAGGEDINT-1)\n\ntypedef struct\n{ functor_t functor;\t\t\t/* Functor to use ($VAR/1) */\n  intptr_t  offset;\t\t\t/* offset */\n  av_action on_attvar;\t\t\t/* How to handle attvars */\n  int\t    singletons;\t\t\t/* Write singletons as $VAR('_') */\n  int\t    numbered_check;\t\t/* Check for already numbered */\n} nv_options;\n\n#define BEGIN_NUMBERVARS(save) \\\n\t{ fid_t _savedf; \\\n\t  if ( save ) \\\n\t  { _savedf = LD->var_names.numbervars_frame; \\\n\t    LD->var_names.numbervars_frame = PL_open_foreign_frame(); \\\n\t  }\n#define END_NUMBERVARS(save) \\\n          if ( save ) \\\n\t  { PL_discard_foreign_frame(LD->var_names.numbervars_frame); \\\n\t    LD->var_names.numbervars_frame = _savedf; \\\n\t  } \\\n\t}\n\n\n\t\t /*******************************\n\t\t *\t      WAKEUP\t\t*\n\t\t *******************************/\n\n#define WAKEUP_STATE_WAKEUP          0x1 /* State contains a wakeup */\n#define WAKEUP_STATE_EXCEPTION\t     0x2 /* State contains an exception */\n#define WAKEUP_STATE_SKIP_EXCEPTION  0x4 /* Do not restore exception from state */\n#define WAKEUP_KEEP_URGENT_EXCEPTION 0x8 /* Keep the most urgent exception */\n\ntypedef struct wakeup_state\n{ fid_t\t\tfid;\t\t\t/* foreign frame reference */\n  Stack\t\toutofstack;\t\t/* Stack we are out of */\n  int\t\tflags;\t\t\t/* WAKEUP_STATE_* */\n} wakeup_state;\n\n\n\n\n\t\t /*******************************\n\t\t *\t    STREAM I/O\t\t*\n\t\t *******************************/\n\n#define REDIR_MAGIC 0x23a9bef3\n\ntypedef struct redir_context\n{ int\t\tmagic;\t\t\t/* REDIR_MAGIC */\n  IOSTREAM     *stream;\t\t\t/* temporary output */\n  int\t\tis_stream;\t\t/* redirect to stream */\n  int\t\tredirected;\t\t/* output is redirected */\n  term_t\tterm;\t\t\t/* redirect target */\n  int\t\tout_format;\t\t/* output type */\n  int\t\tout_arity;\t\t/* 2 for difference-list versions */\n  size_t\tsize;\t\t\t/* size of I/O buffer */\n  char\t       *data;\t\t\t/* data written */\n  char\t\tbuffer[1024];\t\t/* fast temporary buffer */\n} redir_context;\n\n\n\t\t/********************************\n\t\t*       READ WARNINGS           *\n\t\t*********************************/\n\n#define ReadingSource (source_line_no > 0 && \\\n\t\t       source_file_name != NULL_ATOM)\n\n\n\t\t/********************************\n\t\t*        FAST DISPATCHING\t*\n\t\t********************************/\n\n#if VMCODE_IS_ADDRESS\n#define encode(wam) (wam_table[wam])\t\t/* WAM --> internal */\n\t\t\t\t\t\t/* internal --> WAM */\n#define decode(c)   ((code) (dewam_table[(uintptr_t)(c) - \\\n\t\t\t\t\t dewam_table_offset]))\n#else /* VMCODE_IS_ADDRESS */\n#define encode(wam) (wam)\n#define decode(wam) (wam)\n#endif /* VMCODE_IS_ADDRESS */\n\n\t\t/********************************\n\t\t*            STATUS             *\n\t\t*********************************/\n\ntypedef struct\n{ int\t\tblocked;\t\t/* GC is blocked now */\n  bool\t\tactive;\t\t\t/* Currently running? */\n  long\t\tcollections;\t\t/* # garbage collections */\n  int64_t\tglobal_gained;\t\t/* global stack bytes collected */\n  int64_t\ttrail_gained;\t\t/* trail stack bytes collected */\n  int64_t\tglobal_left;\t\t/* global stack bytes left after GC */\n  int64_t\ttrail_left;\t\t/* trail stack bytes left after GC */\n  double\ttime;\t\t\t/* time spent in collections */\n} pl_gc_status_t;\n\n\ntypedef struct\n{ int\t\tblocked;\t\t/* No shifts allowed */\n  double\ttime;\t\t\t/* time spent in stack shifts */\n  int\t\tlocal_shifts;\t\t/* Shifts of the local stack */\n  int\t\tglobal_shifts;\t\t/* Shifts of the global stack */\n  int\t\ttrail_shifts;\t\t/* Shifts of the trail stack */\n} pl_shift_status_t;\n\n\n\t\t/********************************\n\t\t*            MODULES            *\n\t\t*********************************/\n\n#define MODULE_user\t(GD->modules.user)\n#define MODULE_system\t(GD->modules.system)\n#define MODULE_parse\t(ReadingSource ? LD->modules.source \\\n\t\t\t\t       : LD->modules.typein)\n\n\n\t\t/********************************\n\t\t*         PREDICATES            *\n\t\t*********************************/\n\n#define PROCEDURE_catch3\t\t(GD->procedures.catch3)\n#define PROCEDURE_reset3\t\t(GD->procedures.reset3)\n#define PROCEDURE_true0\t\t\t(GD->procedures.true0)\n#define PROCEDURE_fail0\t\t\t(GD->procedures.fail0)\n#define PROCEDURE_event_hook1\t\t(GD->procedures.event_hook1)\n#define PROCEDURE_print_message2\t(GD->procedures.print_message2)\n#define PROCEDURE_dcall1\t\t(GD->procedures.dcall1)\n#define PROCEDURE_setup_call_catcher_cleanup4 \\\n\t\t\t\t(GD->procedures.setup_call_catcher_cleanup4)\n#define PROCEDURE_dwakeup1\t\t(GD->procedures.dwakeup1)\n#define PROCEDURE_dthread_init0\t\t(GD->procedures.dthread_init0)\n#define PROCEDURE_exception_hook4\t(GD->procedures.exception_hook4)\n#define PROCEDURE_dc_call_prolog\t(GD->procedures.dc_call_prolog0)\n#define PROCEDURE_dinit_goal\t\t(GD->procedures.dinit_goal3)\n\nextern const code_info codeTable[]; /* Instruction info (read-only) */\n\n\t\t /*******************************\n\t\t *\t  TEXT PROCESSING\t*\n\t\t *******************************/\n\ntypedef enum\n{ CVT_ok = 0,\t\t\t\t/* Conversion ok */\n  CVT_wide,\t\t\t\t/* Conversion needs wide characters */\n  CVT_partial,\t\t\t\t/* Input list is partial */\n  CVT_nolist,\t\t\t\t/* Input list is not a list */\n  CVT_nocode,\t\t\t\t/* List contains a non-code */\n  CVT_nochar,\t\t\t\t/* List contains a non-char */\n  CVT_representation\t\t\t/* List contains non-reprentable code */\n} CVT_status;\n\ntypedef struct\n{ CVT_status status;\n  word culprit;\t\t\t\t/* for CVT_nocode/CVT_nochar */\n} CVT_result;\n\n\n\t\t/********************************\n\t\t*            DEBUGGER           *\n\t\t*********************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTracer communication declarations.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define ACTION_CONTINUE\t0\n#define ACTION_RETRY\t1\n#define ACTION_FAIL\t2\n#define ACTION_IGNORE\t3\n#define ACTION_AGAIN\t4\n#define ACTION_ABORT\t5\t\t/* only for Prolog interception */\n\n#define CALL_PORT\t0x001\t\t/* port masks */\n#define EXIT_PORT\t0x002\n#define FAIL_PORT\t0x004\n#define REDO_PORT\t0x008\n#define UNIFY_PORT\t0x010\n#define CUT_CALL_PORT   0x040\n#define CUT_EXIT_PORT   0x080\n#define EXCEPTION_PORT\t0x100\n#define CUT_PORT\t(CUT_CALL_PORT|CUT_EXIT_PORT)\n#define PORT_MASK\t0x1ff\n\n/* keep in sync with style_name/1 in boot/prims.pl */\n\n#define SINGLETON_CHECK\t    0x0002\t/* read/1: check singleton vars */\n#define MULTITON_CHECK\t    0x0004\t/* read/1: check multiton vars */\n#define DISCONTIGUOUS_STYLE 0x0008\t/* warn on discontiguous predicates */\n/* reserved\t\t    0x0010 */\n#define CHARSET_CHECK\t    0x0020\t/* warn on unquoted characters */\n#define SEMSINGLETON_CHECK  0x0040\t/* Semantic singleton checking */\n#define NOEFFECT_CHECK\t    0x0080\t/* Check for meaningless statements */\n#define VARBRANCH_CHECK\t    0x0100\t/* warn on unbalanced variables */\n\n/* checkDataEx() flags */\n\n#define CHK_DATA_NOATTVAR_CHAIN 0x001\t/* attvars might not be on chain */\n\ntypedef struct debuginfo\n{ size_t\tskiplevel;\t\t/* current skip level */\n  bool\t\ttracing;\t\t/* are we tracing? */\n  debug_type\tdebugging;\t\t/* are we debugging? */\n  int\t\tleashing;\t\t/* ports we are leashing */\n  int\t        visible;\t\t/* ports that are visible */\n  bool\t\tshowContext;\t\t/* tracer shows context module */\n  int\t\tstyleCheck;\t\t/* source style checking */\n  int\t\tsuspendTrace;\t\t/* tracing is suspended now */\n  intptr_t\tretryFrame;\t\t/* Frame to retry (local stack offset) */\n} pl_debugstatus_t;\n\n#define FT_ATOM\t\t0\t\t/* atom feature */\n#define FT_BOOL\t\t1\t\t/* boolean feature (true, false) */\n#define FT_INTEGER\t2\t\t/* integer feature */\n#define FT_FLOAT\t3\t\t/* float feature */\n#define FT_TERM\t\t4\t\t/* term feature */\n#define FT_INT64\t5\t\t/* passed as int64_t */\n#define FT_FROM_VALUE\t0x0f\t\t/* Determine type from value */\n#define FT_MASK\t\t0x0f\t\t/* mask to get type */\n\n#define PLFLAG_CHARESCAPE\t    0x00000001 /* handle \\ in atoms */\n#define PLFLAG_GC\t\t    0x00000002 /* do GC */\n#define PLFLAG_TRACE_GC\t\t    0x00000004 /* verbose gc */\n#define PLFLAG_TTY_CONTROL\t    0x00000008 /* allow for tty control */\n//\t\t\t\t    0x00000010 /* not used */\n#define PLFLAG_DEBUG_ON_ERROR\t    0x00000020 /* start tracer on error */\n#define PLFLAG_REPORT_ERROR\t    0x00000040 /* print error message */\n#define PLFLAG_FILE_CASE\t    0x00000080 /* file names are case sensitive */\n#define PLFLAG_FILE_CASE_PRESERVING 0x00000100 /* case preserving file names */\n#define PLFLAG_DOS_FILE_NAMES       0x00000200 /* dos (8+3) file names */\n#define ALLOW_VARNAME_FUNCTOR\t    0x00000400 /* Read Foo(x) as 'Foo'(x) */\n#define PLFLAG_ISO\t\t    0x00000800 /* Strict ISO compliance */\n#define PLFLAG_OPTIMISE\t\t    0x00001000 /* -O: optimised compilation */\n#define PLFLAG_FILEVARS\t\t    0x00002000 /* Expand $var and ~ in filename */\n#define PLFLAG_AUTOLOAD\t\t    0x00004000 /* do autoloading */\n#define PLFLAG_CHARCONVERSION\t    0x00008000 /* do character-conversion */\n#define PLFLAG_LASTCALL\t\t    0x00010000 /* Last call optimization enabled? */\n//\t\t\t\t    0x00020000 /* not used */\n#define PLFLAG_SIGNALS\t\t    0x00040000 /* Handle signals */\n#define PLFLAG_DEBUGINFO\t    0x00080000 /* generate debug info */\n#define PLFLAG_FILEERRORS\t    0x00100000 /* Edinburgh file errors */\n#define PLFLAG_WARN_OVERRIDE_IMPLICIT_IMPORT 0x00200000 /* Warn overriding weak symbols */\n#define PLFLAG_QUASI_QUOTES\t    0x00400000 /* Support quasi quotes */\n#define PLFLAG_DOT_IN_ATOM\t    0x00800000 /* Allow atoms a.b.c */\n#define PLFLAG_VARPREFIX\t    0x01000000 /* Variable must start with _ */\n#define PLFLAG_PROTECT_STATIC_CODE  0x02000000 /* Deny clause/2 on static code */\n#define PLFLAG_ERROR_AMBIGUOUS_STREAM_PAIR 0x04000000\n#define PLFLAG_GCTHREAD\t\t    0x08000000 /* Do atom/clause GC in a thread */\n#define PLFLAG_MITIGATE_SPECTRE\t    0x10000000 /* Mitigate spectre attacks */\n\ntypedef struct\n{ unsigned int flags;\t\t/* Fast access to some boolean Prolog flags */\n} pl_features_t;\n\n#define truePrologFlag(flag)\t  true(&LD->prolog_flag.mask, flag)\n#define setPrologFlagMask(flag)\t  set(&LD->prolog_flag.mask, flag)\n#define clearPrologFlagMask(flag) clear(&LD->prolog_flag.mask, flag)\n\ntypedef enum\n{ OCCURS_CHECK_FALSE = 0,\t/* allow rational trees */\n  OCCURS_CHECK_TRUE,\t\t/* fail if rational tree would result */\n  OCCURS_CHECK_ERROR\t\t/* exception if rational tree would result */\n} occurs_check_t;\n\ntypedef enum\n{ ACCESS_LEVEL_USER = 0,\t/* Default user view */\n  ACCESS_LEVEL_SYSTEM\t\t/* Allow low-level access */\n} access_level_t;\n\n#define SYSTEM_MODE\t    (LD->prolog_flag.access_level == ACCESS_LEVEL_SYSTEM)\n\n#ifdef O_LIMIT_DEPTH\n#define DEPTH_NO_LIMIT\t(~(uintptr_t)0x0) /* Highest value */\n#endif\n\n#ifdef O_INFERENCE_LIMIT\n#define INFERENCE_NO_LIMIT 0x7fffffffffffffffLL /* Highest value */\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nAdministration of loaded intermediate code files  (see  pl-wic.c).  Used\nwith the -c option to include all these if necessary.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\ntypedef struct state * State;\n\nstruct state\n{ char *\tname;\t\t\t/* name of state */\n  State\t\tnext;\t\t\t/* next state loaded */\n};\n\n#define QLF_TOPLEVEL 0x1\t\t/* toplevel wic file */\n#define QLF_OPTIONS  0x2\t\t/* only load options */\n#define QLF_EXESTATE 0x4\t\t/* probe qlf exe state */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSourcelocation information (should be used at more places).\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\ntypedef struct\n{ atom_t\tfile;\t\t\t/* name of the file */\n  int\t\tline;\t\t\t/* line number */\n} sourceloc, *SourceLoc;\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nInclude debugging info to make it (very) verbose.  SECURE adds  code  to\ncheck  consistency mainly in the WAM interpreter.  Prolog gets VERY slow\nif SECURE is  used.   DEBUG  is  not  too  bad  (about  20%  performance\ndecrease).\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define REL(a)\t\t((Word)(a) - (Word)(lBase))\n\n#if defined(_DEBUG) && !defined(O_MAINTENANCE)\n#define O_MAINTENANCE\n#endif\n\n#include \"os/pl-os.h\"\t\t\t/* OS dependencies */\n\n#ifdef SYSLIB_H\n#include SYSLIB_H\n#endif\n\n#define NULL_ATOM ((atom_t)0)\n#define MK_ATOM(n)\t\t((atom_t)((n)<<7|TAG_ATOM|STG_STATIC))\n#include \"pl-atom.ih\"\n#include \"pl-funct.ih\"\n\n#include \"pl-alloc.h\"\t\t\t/* Allocation primitives */\n#include \"pl-init.h\"\t\t\t/* Declarations needed by pl-init.c */\n#include \"pl-error.h\"\t\t\t/* Exception generation */\n#include \"pl-thread.h\"\t\t\t/* thread manipulation */\n#include \"pl-data.h\"\t\t\t/* Access Prolog data */\n#include \"pl-segstack.h\"\t\t/* Segmented stacks */\n#include \"pl-gmp.h\"\t\t\t/* GNU-GMP support */\n#include \"os/pl-locale.h\"\t\t/* Locale objects */\n#include \"os/pl-file.h\"\t\t\t/* Stream management */\n#include \"pl-global.h\"\t\t\t/* global data */\n#include \"pl-funcs.h\"\t\t\t/* global functions */\n#include \"pl-ldpass.h\"\t\t\t/* Wrap __LD functions */\n#include \"pl-inline.h\"\t\t\t/* Inline facilities */\n#include \"pl-privitf.h\"\t\t\t/* private foreign interface */\n#include \"os/pl-text.h\"\t\t\t/* text manipulation */\n#include \"pl-hash.h\"\t\t\t/* Murmurhash function */\n#include \"os/pl-option.h\"\t\t/* Option processing */\n#include \"os/pl-files.h\"\t\t/* File management */\n#include \"os/pl-string.h\"\t\t/* Basic string functions */\n#include \"pl-ressymbol.h\"\t\t/* Meta atom handling */\n\n#ifdef __DECC\t\t\t\t/* Dec C-compiler: avoid conflicts */\n#undef leave\n#undef except\n#undef try\n#endif\n\n#endif /*_PL_INCLUDE_H*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/SWI-Prolog.h": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  2008-2017, University of Amsterdam\n                              VU University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef _FLI_H_INCLUDED\n#define _FLI_H_INCLUDED\n\n#ifndef __SWI_PROLOG__\t/* use this to switch on Prolog dialect */\n#define __SWI_PROLOG__\t/* normally defined by the swipl-ld compiler driver */\n#endif\n\n#ifndef __WINDOWS__\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#define __WINDOWS__ 1\n#endif\n#endif\n\n#include <stdarg.h>\n#include <stdlib.h>\t\t\t/* get size_t */\n#include <stddef.h>\n#ifdef _MSC_VER\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#if (_MSC_VER < 1300)\ntypedef long intptr_t;\ntypedef unsigned long uintptr_t;\n#endif\n#else\n#include <inttypes.h>\t\t\t/* more portable than stdint.h */\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* PLVERSION: 10000 * <Major> + 100 * <Minor> + <Patch> */\n/* PLVERSION_TAG: a string, normally \"\", but for example \"rc1\" */\n\n#ifndef PLVERSION\n#define PLVERSION 80003\n#endif\n#ifndef PLVERSION_TAG\n#define PLVERSION_TAG \"\"\n#endif\n\n\n\t\t /*******************************\n\t\t *\t       EXPORT\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTraditional and ELF-based Unix systems  don't   need  all this, but COFF\nbased systems need  to  import  and   export  symbols  explicitely  from\nexecutables and shared objects (DLL). On some systems (e.g. AIX) this is\nachieved using import/export files, on Windows   this  is achieved using\nspecial  declarations  on  exported  symbols.  So,  a  symbol  is  local\n(static), shared between the objects building   an executable or DLL (no\nspecial declaration) or exported from the executable or DLL.\n\nBoth using native Microsoft MSVC as well   as recent Cygwin (tested 1.1)\ncompilers support __declspec(...) for exporting symbols.\n\nAs SWI-Prolog.h can be included seperately or together with this file we\nduplicated this stuff.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifndef _PL_EXPORT_DONE\n#define _PL_EXPORT_DONE\n\n#if (defined(__WINDOWS__) || defined(__CYGWIN__)) && !defined(__LCC__)\n#define HAVE_DECLSPEC\n#endif\n\n#ifdef HAVE_DECLSPEC\n# ifdef PL_KERNEL\n#define PL_EXPORT(type)\t\t__declspec(dllexport) type\n#define PL_EXPORT_DATA(type)\t__declspec(dllexport) type\n#define install_t\t\tvoid\n# else\n#  ifdef __BORLANDC__\n#define PL_EXPORT(type)\t\ttype _stdcall\n#define PL_EXPORT_DATA(type)\textern type\n#  else\n#   ifdef __MINGW32__\n#define PL_EXPORT(type)\t\textern type\n#define PL_EXPORT_DATA(type)\textern type\n#   else\n#define PL_EXPORT(type)\t\textern type\n#define PL_EXPORT_DATA(type)\t__declspec(dllimport) type\n#   endif\n#  endif\n#define install_t\t\t__declspec(dllexport) void\n# endif\n#else /*HAVE_DECLSPEC*/\n#define PL_EXPORT(type)\t\textern type\n#define PL_EXPORT_DATA(type)\textern type\n#define install_t\t\tvoid\n#endif /*HAVE_DECLSPEC*/\n#endif /*_PL_EXPORT_DONE*/\n\n\n\t\t /*******************************\n\t\t *\t  GCC ATTRIBUTES\t*\n\t\t *******************************/\n\n#if __GNUC__ >= 4\n#define WUNUSED __attribute__((warn_unused_result))\n#else\n#define WUNUSED\n#endif\n\n\n\t\t /*******************************\n\t\t *\t       TYPES\t\t*\n\t\t *******************************/\n\n#ifdef _PL_INCLUDE_H\ntypedef Module\t\tmodule_t;\t/* a module */\ntypedef Procedure\tpredicate_t;\t/* a predicate handle */\ntypedef Record\t\trecord_t;\t/* handle to a recorded term */\ntypedef struct PL_local_data *PL_engine_t; /* handle to a engine */\n#else\ntypedef\tuintptr_t\tatom_t;\t\t/* Prolog atom */\ntypedef uintptr_t\tfunctor_t;\t/* Name/arity pair */\ntypedef void *\t\tmodule_t;\t/* Prolog module */\ntypedef void *\t\tpredicate_t;\t/* Prolog procedure */\ntypedef void *\t\trecord_t;\t/* Prolog recorded term */\n#ifndef PL_HAVE_TERM_T\n#define PL_HAVE_TERM_T\ntypedef uintptr_t\tterm_t;\t\t/* opaque term handle */\n#endif\ntypedef uintptr_t\tqid_t;\t\t/* opaque query handle */\ntypedef uintptr_t\tPL_fid_t;\t/* opaque foreign context handle */\ntypedef void *\t\tcontrol_t;\t/* non-deterministic control arg */\ntypedef void *\t\tPL_engine_t;\t/* opaque engine handle */\n#endif\ntypedef uintptr_t\tPL_atomic_t;\t/* same a word */\ntypedef uintptr_t\tforeign_t;\t/* return type of foreign functions */\ntypedef wchar_t\t        pl_wchar_t;\t/* Prolog wide character */\n#ifdef __cplusplus\ntypedef void *\t\tpl_function_t;      /* pass function as void* */\n#else\ntypedef foreign_t\t(*pl_function_t)(); /* foreign language functions */\n#endif\n\n#ifndef NORETURN\n#define NORETURN\n#endif\n\n#define fid_t PL_fid_t\t\t\t/* avoid AIX name-clash */\n\n\t\t\t\t\t/* values for PL_get_term_value() */\ntypedef union\n{ int64_t i;\t\t\t\t/* PL_INTEGER */\n  double f;\t\t\t\t/* PL_FLOAT */\n  char * s;\t\t\t\t/* PL_STRING */\n  atom_t a;\t\t\t\t/* PL_ATOM */\n  struct\t\t\t\t/* PL_TERM */\n  { atom_t name;\n    size_t arity;\n  } t;\n} term_value_t;\n\n#ifndef TRUE\n#define TRUE\t(1)\n#define FALSE\t(0)\n#endif\n\n\t\t /*******************************\n\t\t *      TERM-TYPE CONSTANTS\t*\n\t\t *******************************/\n\t\t\t\t\t/* PL_unify_term() arguments */\n#define\tPL_VARIABLE\t (1)\t\t/* nothing */\n#define PL_ATOM\t\t (2)\t\t/* const char * */\n#define PL_INTEGER\t (3)\t\t/* int */\n#define PL_FLOAT\t (4)\t\t/* double */\n#define PL_STRING\t (5)\t\t/* const char * */\n#define PL_TERM\t\t (6)\n\n#define PL_NIL\t\t (7)\t\t/* The constant [] */\n#define PL_BLOB\t\t (8)\t\t/* non-atom blob */\n#define PL_LIST_PAIR\t (9)\t\t/* [_|_] term */\n\n\t\t\t\t\t/* PL_unify_term() */\n#define PL_FUNCTOR\t (10)\t\t/* functor_t, arg ... */\n#define PL_LIST\t\t (11)\t\t/* length, arg ... */\n#define PL_CHARS\t (12)\t\t/* const char * */\n#define PL_POINTER\t (13)\t\t/* void * */\n\t\t\t\t\t/* PlArg::PlArg(text, type) */\n#define PL_CODE_LIST\t (14)\t\t/* [ascii...] */\n#define PL_CHAR_LIST\t (15)\t\t/* [h,e,l,l,o] */\n#define PL_BOOL\t\t (16)\t\t/* PL_set_prolog_flag() */\n#define PL_FUNCTOR_CHARS (17)\t\t/* PL_unify_term() */\n#define _PL_PREDICATE_INDICATOR (18)\t/* predicate_t (Procedure) */\n#define PL_SHORT\t (19)\t\t/* short */\n#define PL_INT\t\t (20)\t\t/* int */\n#define PL_LONG\t\t (21)\t\t/* long */\n#define PL_DOUBLE\t (22)\t\t/* double */\n#define PL_NCHARS\t (23)\t\t/* size_t, const char * */\n#define PL_UTF8_CHARS\t (24)\t\t/* const char * */\n#define PL_UTF8_STRING\t (25)\t\t/* const char * */\n#define PL_INT64\t (26)\t\t/* int64_t */\n#define PL_NUTF8_CHARS\t (27)\t\t/* size_t, const char * */\n#define PL_NUTF8_CODES\t (29)\t\t/* size_t, const char * */\n#define PL_NUTF8_STRING\t (30)\t\t/* size_t, const char * */\n#define PL_NWCHARS\t (31)\t\t/* size_t, const wchar_t * */\n#define PL_NWCODES\t (32)\t\t/* size_t, const wchar_t * */\n#define PL_NWSTRING\t (33)\t\t/* size_t, const wchar_t * */\n#define PL_MBCHARS\t (34)\t\t/* const char * */\n#define PL_MBCODES\t (35)\t\t/* const char * */\n#define PL_MBSTRING\t (36)\t\t/* const char * */\n#define PL_INTPTR\t (37)\t\t/* intptr_t */\n#define PL_CHAR\t\t (38)\t\t/* int */\n#define PL_CODE\t\t (39)\t\t/* int */\n#define PL_BYTE\t\t (40)\t\t/* int */\n\t\t\t\t\t/* PL_skip_list() */\n#define PL_PARTIAL_LIST\t (41)\t\t/* a partial list */\n#define PL_CYCLIC_TERM\t (42)\t\t/* a cyclic list/term */\n#define PL_NOT_A_LIST\t (43)\t\t/* Object is not a list */\n\t\t\t\t\t/* dicts */\n#define PL_DICT\t\t (44)\n\n/* Or'ed flags for PL_set_prolog_flag() */\n/* MUST fit in a short int! */\n#define FF_READONLY\t 0x1000\t\t/* Read-only prolog flag */\n#define FF_KEEP\t\t 0x2000\t\t/* keep prolog flag if already set */\n#define FF_NOCREATE\t 0x4000\t\t/* Fail if flag is non-existent */\n#define FF_FORCE\t 0x8000\t\t/* Force setting, overwrite READONLY */\n#define FF_MASK\t\t 0xf000\n\n\n\t\t/********************************\n\t\t*    DETERMINISTIC CALL/RETURN  *\n\t\t*********************************/\n\n#define\tPL_succeed\treturn TRUE\t/* succeed deterministically */\n#define PL_fail\t\treturn FALSE\t/* fail */\n\n\n\t\t/********************************\n\t\t* NON-DETERMINISTIC CALL/RETURN *\n\t\t*********************************/\n\n/*  Note 1: Non-deterministic foreign functions may also use the deterministic\n    return methods PL_succeed and PL_fail.\n\n    Note 2: The argument to PL_retry is a sizeof(ptr)-2 bits signed\n    integer (use type intptr_t).\n*/\n\n#define PL_FIRST_CALL\t\t(0)\n#define PL_CUTTED\t\t(1)\t/* deprecated */\n#define PL_PRUNED\t\t(1)\n#define PL_REDO\t\t\t(2)\n\n#define PL_retry(n)\t\treturn _PL_retry(n)\n#define PL_retry_address(a)\treturn _PL_retry_address(a)\n\nPL_EXPORT(foreign_t)\t_PL_retry(intptr_t);\nPL_EXPORT(foreign_t)\t_PL_retry_address(void *);\nPL_EXPORT(int)\t\tPL_foreign_control(control_t);\nPL_EXPORT(intptr_t)\tPL_foreign_context(control_t);\nPL_EXPORT(void *)\tPL_foreign_context_address(control_t);\nPL_EXPORT(predicate_t)\tPL_foreign_context_predicate(control_t);\n\n\n\t\t/********************************\n\t\t*      REGISTERING FOREIGNS     *\n\t\t*********************************/\n\ntypedef struct PL_extension\n{ const char   *predicate_name;\t\t/* Name of the predicate */\n  short\t\tarity;\t\t\t/* Arity of the predicate */\n  pl_function_t\tfunction;\t\t/* Implementing functions */\n  short\t\tflags;\t\t\t/* Or of PL_FA_... */\n} PL_extension;\n\n#define PL_FA_NOTRACE\t\t(0x01)\t/* foreign cannot be traced */\n#define PL_FA_TRANSPARENT\t(0x02)\t/* foreign is module transparent */\n#define PL_FA_NONDETERMINISTIC\t(0x04)\t/* foreign is non-deterministic */\n#define PL_FA_VARARGS\t\t(0x08)\t/* call using t0, ac, ctx */\n#define PL_FA_CREF\t\t(0x10)\t/* Internal: has clause-reference */\n#define PL_FA_ISO\t\t(0x20)\t/* Internal: ISO core predicate */\n#define PL_FA_META\t\t(0x40)\t/* Additional meta-argument spec */\n\nextern\t\t\tPL_extension PL_extensions[]; /* not Win32! */\nPL_EXPORT(void)\t\tPL_register_extensions(const PL_extension *e);\nPL_EXPORT(void)\t\tPL_register_extensions_in_module(const char *module, const PL_extension *e);\nPL_EXPORT(int)\t\tPL_register_foreign(const char *name, int arity,\n\t\t\t\t\t    pl_function_t func,\n\t\t\t\t\t    int flags, ...);\nPL_EXPORT(int)\t\tPL_register_foreign_in_module(const char *module,\n\t\t\t\t\t\t      const char *name, int arity,\n\t\t\t\t\t\t      pl_function_t func,\n\t\t\t\t\t\t      int flags, ...);\nPL_EXPORT(void)\t\tPL_load_extensions(const PL_extension *e);\n\n\t\t /*******************************\n\t\t *\t      LICENSE\t\t*\n\t\t *******************************/\n\nPL_EXPORT(void)\t\tPL_license(const char *license, const char *module);\n\n\t\t/********************************\n\t\t*            MODULES            *\n\t\t*********************************/\n\nPL_EXPORT(module_t)\tPL_context(void);\nPL_EXPORT(atom_t)\tPL_module_name(module_t module);\nPL_EXPORT(module_t)\tPL_new_module(atom_t name);\nPL_EXPORT(int)\t\tPL_strip_module(term_t in, module_t *m, term_t out) WUNUSED;\n\n\t\t /*******************************\n\t\t *\t     CONSTANTS\t\t*\n\t\t *******************************/\n\nPL_EXPORT(const atom_t) *_PL_atoms(void); /* base of reserved (meta-)atoms */\n#ifndef PL_KERNEL\n#define ATOM_nil\t(_PL_atoms()[0]) /* `[]` */\n#define ATOM_dot\t(_PL_atoms()[1]) /* `.` */\n#endif /*PL_KERNEL*/\n\n\n\t\t /*******************************\n\t\t *\t     CALL-BACK\t\t*\n\t\t *******************************/\n\n#ifdef PL_KERNEL\n#define PL_Q_DEBUG\t\t0x0001\t/* = TRUE for backward compatibility */\n#endif\n#define PL_Q_NORMAL\t\t0x0002\t/* normal usage */\n#define PL_Q_NODEBUG\t\t0x0004\t/* use this one */\n#define PL_Q_CATCH_EXCEPTION\t0x0008\t/* handle exceptions in C */\n#define PL_Q_PASS_EXCEPTION\t0x0010\t/* pass to parent environment */\n#define PL_Q_ALLOW_YIELD\t0x0020\t/* Support I_YIELD */\n#define PL_Q_EXT_STATUS\t\t0x0040\t/* Return extended status */\n#ifdef PL_KERNEL\n#define PL_Q_DETERMINISTIC\t0x0100\t/* call was deterministic */\n#endif\n\n\t\t\t\t\t/* PL_Q_EXT_STATUS return codes */\n#define PL_S_EXCEPTION\t       -1\t/* Query raised exception */\n#define PL_S_FALSE\t\t0\t/* Query failed */\n#define PL_S_TRUE\t\t1\t/* Query succeeded with choicepoint */\n#define PL_S_LAST\t\t2\t/* Query succeeded without CP */\n\n\n\t\t\t/* Foreign context frames */\nPL_EXPORT(fid_t)\tPL_open_foreign_frame(void);\nPL_EXPORT(void)\t\tPL_rewind_foreign_frame(fid_t cid);\nPL_EXPORT(void)\t\tPL_close_foreign_frame(fid_t cid);\nPL_EXPORT(void)\t\tPL_discard_foreign_frame(fid_t cid);\n\n\t\t\t/* Finding predicates */\nPL_EXPORT(predicate_t)\tPL_pred(functor_t f, module_t m);\nPL_EXPORT(predicate_t)\tPL_predicate(const char *name, int arity,\n\t\t\t\t     const char* module);\nPL_EXPORT(int)\t\tPL_predicate_info(predicate_t pred,\n\t\t\t\t\t  atom_t *name, size_t *arity,\n\t\t\t\t\t  module_t *module);\n\n\t\t\t/* Call-back */\nPL_EXPORT(qid_t)\tPL_open_query(module_t m, int flags,\n\t\t\t\t      predicate_t pred, term_t t0);\nPL_EXPORT(int)\t\tPL_next_solution(qid_t qid) WUNUSED;\nPL_EXPORT(int)\t\tPL_close_query(qid_t qid);\nPL_EXPORT(int)\t\tPL_cut_query(qid_t qid);\nPL_EXPORT(qid_t)\tPL_current_query(void);\n\n\t\t\t/* Simplified (but less flexible) call-back */\nPL_EXPORT(int)\t\tPL_call(term_t t, module_t m);\nPL_EXPORT(int)\t\tPL_call_predicate(module_t m, int debug,\n\t\t\t\t\t  predicate_t pred, term_t t0);\n\t\t\t/* Handling exceptions */\nPL_EXPORT(term_t)\tPL_exception(qid_t qid);\nPL_EXPORT(int)\t\tPL_raise_exception(term_t exception);\nPL_EXPORT(int)\t\tPL_throw(term_t exception);\nPL_EXPORT(void)\t\tPL_clear_exception(void);\n\t\t\t/* Engine-based coroutining */\nPL_EXPORT(term_t)\tPL_yielded(qid_t qid);\n\n\n\t\t /*******************************\n\t\t *        TERM-REFERENCES\t*\n\t\t *******************************/\n\n\t\t\t/* Creating and destroying term-refs */\nPL_EXPORT(term_t)\tPL_new_term_refs(int n);\nPL_EXPORT(term_t)\tPL_new_term_ref(void);\nPL_EXPORT(term_t)\tPL_copy_term_ref(term_t from);\nPL_EXPORT(void)\t\tPL_reset_term_refs(term_t r);\n\n\t\t\t/* Constants */\nPL_EXPORT(atom_t)\tPL_new_atom(const char *s);\nPL_EXPORT(atom_t)\tPL_new_atom_nchars(size_t len, const char *s);\nPL_EXPORT(atom_t)\tPL_new_atom_wchars(size_t len, const pl_wchar_t *s);\nPL_EXPORT(atom_t)\tPL_new_atom_mbchars(int rep, size_t len, const char *s);\nPL_EXPORT(const char *)\tPL_atom_chars(atom_t a);\nPL_EXPORT(const char *)\tPL_atom_nchars(atom_t a, size_t *len);\nPL_EXPORT(const wchar_t *)\tPL_atom_wchars(atom_t a, size_t *len);\n#ifndef O_DEBUG_ATOMGC\nPL_EXPORT(void)\t\tPL_register_atom(atom_t a);\nPL_EXPORT(void)\t\tPL_unregister_atom(atom_t a);\n#endif\nPL_EXPORT(functor_t)\tPL_new_functor_sz(atom_t f, size_t a);\nPL_EXPORT(functor_t)\tPL_new_functor(atom_t f, int a);\nPL_EXPORT(atom_t)\tPL_functor_name(functor_t f);\nPL_EXPORT(int)\t\tPL_functor_arity(functor_t f);\nPL_EXPORT(size_t)\tPL_functor_arity_sz(functor_t f);\n\n\t\t\t/* Get C-values from Prolog terms */\nPL_EXPORT(int)\t\tPL_get_atom(term_t t, atom_t *a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_bool(term_t t, int *value) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_atom_chars(term_t t, char **a) WUNUSED;\n#define PL_get_string_chars(t, s, l) PL_get_string(t,s,l)\n\t\t\t\t\t/* PL_get_string() is deprecated */\nPL_EXPORT(int)\t\tPL_get_string(term_t t, char **s, size_t *len) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_chars(term_t t, char **s, unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_list_chars(term_t l, char **s,\n\t\t\t\t\t  unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_atom_nchars(term_t t, size_t *len, char **a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_list_nchars(term_t l,\n\t\t\t\t\t   size_t *len, char **s,\n\t\t\t\t\t   unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_nchars(term_t t,\n\t\t\t\t      size_t *len, char **s,\n\t\t\t\t      unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_integer(term_t t, int *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_long(term_t t, long *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_intptr(term_t t, intptr_t *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_pointer(term_t t, void **ptr) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_float(term_t t, double *f) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_functor(term_t t, functor_t *f) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_name_arity_sz(term_t t, atom_t *name,\n\t\t\t\t\t     size_t *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_compound_name_arity_sz(term_t t, atom_t *name,\n\t\t\t\t\t\t      size_t *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_name_arity(term_t t, atom_t *name,\n\t\t\t\t\t  int *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_compound_name_arity(term_t t, atom_t *name,\n\t\t\t\t\t\t   int *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_module(term_t t, module_t *module) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_arg_sz(size_t index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_arg(int index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_list(term_t l, term_t h, term_t t) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_head(term_t l, term_t h) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_tail(term_t l, term_t t) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_nil(term_t l) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_term_value(term_t t, term_value_t *v) WUNUSED;\nPL_EXPORT(char *)\tPL_quote(int chr, const char *data);\n\n\t\t\t/* Verify types */\nPL_EXPORT(int)\t\tPL_term_type(term_t t);\nPL_EXPORT(int)\t\tPL_is_variable(term_t t);\nPL_EXPORT(int)\t\tPL_is_ground(term_t t);\nPL_EXPORT(int)\t\tPL_is_atom(term_t t);\nPL_EXPORT(int)\t\tPL_is_integer(term_t t);\nPL_EXPORT(int)\t\tPL_is_string(term_t t);\nPL_EXPORT(int)\t\tPL_is_float(term_t t);\nPL_EXPORT(int)\t\tPL_is_rational(term_t t);\nPL_EXPORT(int)\t\tPL_is_compound(term_t t);\nPL_EXPORT(int)\t\tPL_is_callable(term_t t);\nPL_EXPORT(int)\t\tPL_is_functor(term_t t, functor_t f);\nPL_EXPORT(int)\t\tPL_is_list(term_t t);\nPL_EXPORT(int)\t\tPL_is_pair(term_t t);\nPL_EXPORT(int)\t\tPL_is_atomic(term_t t);\nPL_EXPORT(int)\t\tPL_is_number(term_t t);\nPL_EXPORT(int)\t\tPL_is_acyclic(term_t t);\n\n\t\t\t/* Assign to term-references */\nPL_EXPORT(int)\t\tPL_put_variable(term_t t);\nPL_EXPORT(int)\t\tPL_put_atom(term_t t, atom_t a);\nPL_EXPORT(int)\t\tPL_put_bool(term_t t, int val);\nPL_EXPORT(int)\t\tPL_put_atom_chars(term_t t, const char *chars);\nPL_EXPORT(int)\t\tPL_put_string_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_chars(term_t t, int flags,\n\t\t\t\t     size_t len, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_codes(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_atom_nchars(term_t t, size_t l, const char *chars);\nPL_EXPORT(int)\t\tPL_put_string_nchars(term_t t, size_t len, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_nchars(term_t t, size_t l, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_ncodes(term_t t, size_t l, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_integer(term_t t, long i) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_pointer(term_t t, void *ptr) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_float(term_t t, double f) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_functor(term_t t, functor_t functor) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list(term_t l) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_nil(term_t l);\nPL_EXPORT(int)\t\tPL_put_term(term_t t1, term_t t2);\n\n\t\t\t/* construct a functor or list-cell */\nPL_EXPORT(int)\t\tPL_cons_functor(term_t h, functor_t f, ...) WUNUSED;\nPL_EXPORT(int)\t\tPL_cons_functor_v(term_t h, functor_t fd, term_t a0) WUNUSED;\nPL_EXPORT(int)\t\tPL_cons_list(term_t l, term_t h, term_t t) WUNUSED;\n\n\t\t\t/* Unify term-references */\nPL_EXPORT(int)\t\tPL_unify(term_t t1, term_t t2) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_atom(term_t t, atom_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_atom_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_codes(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_string_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_atom_nchars(term_t t, size_t l, const char *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_ncodes(term_t t, size_t l, const char *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_nchars(term_t t, size_t l, const char *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_string_nchars(term_t t,\n\t\t\t\t\t       size_t len,\n\t\t\t\t\t       const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_bool(term_t t, int n) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_integer(term_t t, intptr_t n) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_float(term_t t, double f) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_pointer(term_t t, void *ptr) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_functor(term_t t, functor_t f) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_compound(term_t t, functor_t f) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list(term_t l, term_t h, term_t t) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_nil(term_t l) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_arg_sz(size_t index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_arg(int index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_term(term_t t, ...) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_chars(term_t t, int flags,\n\t\t\t\t       size_t len, const char *s) WUNUSED;\n\n\t\t /*******************************\n\t\t *\t       LISTS\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_skip_list(term_t list, term_t tail, size_t *len);\n\n\n\t\t /*******************************\n\t\t *    WIDE CHARACTER VERSIONS\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_unify_wchars(term_t t, int type,\n\t\t\t\t\tsize_t len, const pl_wchar_t *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_wchars_diff(term_t t, term_t tail, int type,\n\t\t\t\t\tsize_t len, const pl_wchar_t *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_wchars(term_t l,\n\t\t\t\t      size_t *length, pl_wchar_t **s,\n\t\t\t\t      unsigned flags) WUNUSED;\nPL_EXPORT(size_t)\tPL_utf8_strlen(const char *s, size_t len) WUNUSED;\n\n\n\t\t /*******************************\n\t\t *\t   WIDE INTEGERS\t*\n\t\t *******************************/\n\n\nPL_EXPORT(int)\t\tPL_get_int64(term_t t, int64_t *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_int64(term_t t, int64_t value) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_uint64(term_t t, uint64_t value) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_int64(term_t t, int64_t i) WUNUSED;\n\n\n\t\t /*******************************\n\t\t *     ATTRIBUTED VARIABLES\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_is_attvar(term_t t);\nPL_EXPORT(int)\t\tPL_get_attr(term_t v, term_t a);\n\n\n\t\t /*******************************\n\t\t *\t      ERRORS\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_get_atom_ex(term_t t, atom_t *a);\nPL_EXPORT(int)\t\tPL_get_integer_ex(term_t t, int *i);\nPL_EXPORT(int)\t\tPL_get_long_ex(term_t t, long *i);\nPL_EXPORT(int)\t\tPL_get_int64_ex(term_t t, int64_t *i);\nPL_EXPORT(int)\t\tPL_get_intptr_ex(term_t t, intptr_t *i);\nPL_EXPORT(int)\t\tPL_get_size_ex(term_t t, size_t *i);\nPL_EXPORT(int)\t\tPL_get_bool_ex(term_t t, int *i);\nPL_EXPORT(int)\t\tPL_get_float_ex(term_t t, double *f);\nPL_EXPORT(int)\t\tPL_get_char_ex(term_t t, int *p, int eof);\nPL_EXPORT(int)\t\tPL_unify_bool_ex(term_t t, int val);\nPL_EXPORT(int)\t\tPL_get_pointer_ex(term_t t, void **addrp);\nPL_EXPORT(int)\t\tPL_unify_list_ex(term_t l, term_t h, term_t t);\nPL_EXPORT(int)\t\tPL_unify_nil_ex(term_t l);\nPL_EXPORT(int)\t\tPL_get_list_ex(term_t l, term_t h, term_t t);\nPL_EXPORT(int)\t\tPL_get_nil_ex(term_t l);\n\nPL_EXPORT(int)\t\tPL_instantiation_error(term_t culprit);\nPL_EXPORT(int)\t\tPL_uninstantiation_error(term_t culprit);\nPL_EXPORT(int)\t\tPL_representation_error(const char *resource);\nPL_EXPORT(int)\t\tPL_type_error(const char *expected, term_t culprit);\nPL_EXPORT(int)\t\tPL_domain_error(const char *expected, term_t culprit);\nPL_EXPORT(int)\t\tPL_existence_error(const char *type, term_t culprit);\nPL_EXPORT(int)\t\tPL_permission_error(const char *operation,\n\t\t\t\t\t    const char *type, term_t culprit);\nPL_EXPORT(int)\t\tPL_resource_error(const char *resource);\n#ifdef SIO_MAGIC\nPL_EXPORT(int)\t\tPL_syntax_error(const char *msg, IOSTREAM *in);\n#else\nPL_EXPORT(int)\t\tPL_syntax_error(const char *msg, void *in);\n#endif\n\n\t\t /*******************************\n\t\t *\t       BLOBS\t\t*\n\t\t *******************************/\n\n#define PL_BLOB_MAGIC_B\t0x75293a00\t/* Magic to validate a blob-type */\n#define PL_BLOB_VERSION 1\t\t/* Current version */\n#define PL_BLOB_MAGIC\t(PL_BLOB_MAGIC_B|PL_BLOB_VERSION)\n\n#define PL_BLOB_UNIQUE\t0x01\t\t/* Blob content is unique */\n#define PL_BLOB_TEXT\t0x02\t\t/* blob contains text */\n#define PL_BLOB_NOCOPY\t0x04\t\t/* do not copy the data */\n#define PL_BLOB_WCHAR\t0x08\t\t/* wide character string */\n\ntypedef struct PL_blob_t\n{ uintptr_t\t\tmagic;\t\t/* PL_BLOB_MAGIC */\n  uintptr_t\t\tflags;\t\t/* PL_BLOB_* */\n  char *\t\tname;\t\t/* name of the type */\n  int\t\t\t(*release)(atom_t a);\n  int\t\t\t(*compare)(atom_t a, atom_t b);\n#ifdef SIO_MAGIC\n  int\t\t\t(*write)(IOSTREAM *s, atom_t a, int flags);\n#else\n  int\t\t\t(*write)(void *s, atom_t a, int flags);\n#endif\n  void\t\t\t(*acquire)(atom_t a);\n#ifdef SIO_MAGIC\n  int\t\t\t(*save)(atom_t a, IOSTREAM *s);\n  atom_t\t\t(*load)(IOSTREAM *s);\n#else\n  int\t\t\t(*save)(atom_t a, void*);\n  atom_t\t\t(*load)(void *s);\n#endif\n  size_t\t\tpadding;\t/* Required 0-padding */\n\t\t\t\t\t/* private */\n  void *\t\treserved[9];\t/* for future extension */\n  int\t\t\tregistered;\t/* Already registered? */\n  int\t\t\trank;\t\t/* Rank for ordering atoms */\n  struct PL_blob_t *    next;\t\t/* next in registered type-chain */\n  atom_t\t\tatom_name;\t/* Name as atom */\n} PL_blob_t;\n\nPL_EXPORT(int)\t\tPL_is_blob(term_t t, PL_blob_t **type);\nPL_EXPORT(int)\t\tPL_unify_blob(term_t t, void *blob, size_t len,\n\t\t\t\t      PL_blob_t *type);\nPL_EXPORT(int)\t\tPL_put_blob(term_t t, void *blob, size_t len,\n\t\t\t\t    PL_blob_t *type);\nPL_EXPORT(int)\t\tPL_get_blob(term_t t, void **blob, size_t *len,\n\t\t\t\t    PL_blob_t **type);\n\nPL_EXPORT(void*)\tPL_blob_data(atom_t a,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct PL_blob_t **type);\n\nPL_EXPORT(void)\t\tPL_register_blob_type(PL_blob_t *type);\nPL_EXPORT(PL_blob_t*)\tPL_find_blob_type(const char* name);\nPL_EXPORT(int)\t\tPL_unregister_blob_type(PL_blob_t *type);\n\n\n#ifdef __GNU_MP__\n\n\t\t /*******************************\n\t\t *\t       GMP\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\tPL_get_mpz(term_t t, mpz_t mpz) WUNUSED;\nPL_EXPORT(int)\tPL_get_mpq(term_t t,  mpq_t mpq) WUNUSED;\nPL_EXPORT(int)\tPL_unify_mpz(term_t t, mpz_t mpz) WUNUSED;\nPL_EXPORT(int)\tPL_unify_mpq(term_t t, mpq_t mpq) WUNUSED;\n\n#endif /*__GNU_MP__*/\n\n\t\t /*******************************\n\t\t *\t  FILENAME SUPPORT\t*\n\t\t *******************************/\n\n#define PL_FILE_ABSOLUTE\t0x01\t/* return absolute path */\n#define PL_FILE_OSPATH\t\t0x02\t/* return path in OS notation */\n#define PL_FILE_SEARCH\t\t0x04\t/* use file_search_path */\n#define PL_FILE_EXIST\t\t0x08\t/* demand file to exist */\n#define PL_FILE_READ\t\t0x10\t/* demand read-access */\n#define PL_FILE_WRITE\t\t0x20\t/* demand write-access */\n#define PL_FILE_EXECUTE\t\t0x40\t/* demand execute-access */\n#define PL_FILE_NOERRORS\t0x80\t/* do not raise exceptions */\n\nPL_EXPORT(int)\t\tPL_get_file_name(term_t n, char **name, int flags);\nPL_EXPORT(int)\t\tPL_get_file_nameW(term_t n, wchar_t **name, int flags);\nPL_EXPORT(void)\t\tPL_changed_cwd(void); /* foreign code changed CWD */\nPL_EXPORT(char *)\tPL_cwd(char *buf, size_t buflen);\n\n\n\t\t /*******************************\n\t\t *    QUINTUS/SICSTUS WRAPPER\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_cvt_i_char(term_t p, char *c);\nPL_EXPORT(int)\t\tPL_cvt_i_uchar(term_t p, unsigned char *c);\nPL_EXPORT(int)\t\tPL_cvt_i_short(term_t p, short *s);\nPL_EXPORT(int)\t\tPL_cvt_i_ushort(term_t p, unsigned short *s);\nPL_EXPORT(int)\t\tPL_cvt_i_int(term_t p, int *c);\nPL_EXPORT(int)\t\tPL_cvt_i_uint(term_t p, unsigned int *c);\nPL_EXPORT(int)\t\tPL_cvt_i_long(term_t p, long *c);\nPL_EXPORT(int)\t\tPL_cvt_i_ulong(term_t p, unsigned long *c);\nPL_EXPORT(int)\t\tPL_cvt_i_int64(term_t p, int64_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_uint64(term_t p, uint64_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_size_t(term_t p, size_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_float(term_t p, double *c);\nPL_EXPORT(int)\t\tPL_cvt_i_single(term_t p, float *c);\nPL_EXPORT(int)\t\tPL_cvt_i_string(term_t p, char **c);\nPL_EXPORT(int)\t\tPL_cvt_i_codes(term_t p, char **c);\nPL_EXPORT(int)\t\tPL_cvt_i_atom(term_t p, atom_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_address(term_t p, void *c);\nPL_EXPORT(int)\t\tPL_cvt_o_int64(int64_t c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_float(double c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_single(float c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_string(const char *c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_codes(const char *c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_atom(atom_t c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_address(void *address, term_t p);\nPL_EXPORT(term_t)\tPL_new_nil_ref(void);\n\n/* set/get encoding for PL_cvt_*_string() functions.  The default\n   is UTF-8 (REP_UTF8)\n*/\n\nPL_EXPORT(int)\t\tPL_cvt_encoding(void);\nPL_EXPORT(int)\t\tPL_cvt_set_encoding(int enc);\nPL_EXPORT(void)\t\tSP_set_state(int state);\nPL_EXPORT(int)\t\tSP_get_state(void);\n\n\n\t\t /*******************************\n\t\t *\t     COMPARE\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_compare(term_t t1, term_t t2);\nPL_EXPORT(int)\t\tPL_same_compound(term_t t1, term_t t2);\n\n\t\t /*******************************\n\t\t *\t     MESSAGES\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_warning(const char *fmt, ...);\nPL_EXPORT(void)\t\tPL_fatal_error(const char *fmt, ...);\n\n\t\t /*******************************\n\t\t *      RECORDED DATABASE\t*\n\t\t *******************************/\n\nPL_EXPORT(record_t)\tPL_record(term_t term);\nPL_EXPORT(int)\t\tPL_recorded(record_t record, term_t term);\nPL_EXPORT(void)\t\tPL_erase(record_t record);\nPL_EXPORT(record_t)\tPL_duplicate_record(record_t r);\n\nPL_EXPORT(char *)\tPL_record_external(term_t t, size_t *size);\nPL_EXPORT(int)\t\tPL_recorded_external(const char *rec, term_t term);\nPL_EXPORT(int)\t\tPL_erase_external(char *rec);\n\n\t\t /*******************************\n\t\t *\t   PROLOG FLAGS\t\t*\n\t\t *******************************/\n\n#define PL_set_feature  PL_set_prolog_flag /* compatibility */\nPL_EXPORT(int)\t\tPL_set_prolog_flag(const char *name, int type, ...);\n\n\n\t\t /*******************************\n\t\t *\tINTERNAL FUNCTIONS\t*\n\t\t *******************************/\n\nPL_EXPORT(PL_atomic_t)\t_PL_get_atomic(term_t t);\nPL_EXPORT(void)\t\t_PL_put_atomic(term_t t, PL_atomic_t a);\nPL_EXPORT(int)\t\t_PL_unify_atomic(term_t t, PL_atomic_t a);\nPL_EXPORT(void)\t\t_PL_get_arg_sz(size_t index, term_t t, term_t a);\nPL_EXPORT(void)\t\t_PL_get_arg(int index, term_t t, term_t a);\n\n\n\t\t /*******************************\n\t\t *\t    CHAR BUFFERS\t*\n\t\t *******************************/\n\n#define CVT_ATOM\t0x0001\n#define CVT_STRING\t0x0002\n#define CVT_LIST\t0x0004\n#define CVT_INTEGER\t0x0008\n#define CVT_FLOAT\t0x0010\n#define CVT_VARIABLE\t0x0020\n#define CVT_NUMBER\t(CVT_INTEGER|CVT_FLOAT)\n#define CVT_ATOMIC\t(CVT_NUMBER|CVT_ATOM|CVT_STRING)\n#define CVT_WRITE\t0x0040\n#define CVT_WRITE_CANONICAL 0x0080\n#define CVT_WRITEQ\t0x00C0\n#define CVT_ALL\t\t(CVT_ATOMIC|CVT_LIST)\n#define CVT_MASK\t0x00ff\n\n#define BUF_DISCARDABLE\t0x0000\n#define BUF_RING\t0x0100\n#define BUF_MALLOC\t0x0200\n#define BUF_ALLOW_STACK\t0x0400\t\t/* allow pointer into (global) stack */\n\n#define CVT_EXCEPTION\t0x10000\t\t/* throw exception on error */\n#define CVT_VARNOFAIL\t0x20000\t\t/* return 2 if argument is unbound */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nOutput   representation   for   PL_get_chars()     and    friends.   The\nprepresentation type REP_FN is for   PL_get_file_name()  and friends. On\nWindows we use UTF-8 which is translated   by the `XOS' layer to Windows\nUNICODE file functions.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define REP_ISO_LATIN_1 0x0000\t\t/* output representation */\n#define REP_UTF8\t0x1000\n#define REP_MB\t\t0x2000\n#ifdef __WINDOWS__\n#define REP_FN\t\tREP_UTF8\n#else\n#define REP_FN\t\tREP_MB\n#endif\n\n#define PL_DIFF_LIST\t0x20000\t\t/* PL_unify_chars() */\n\n\n#ifdef SIO_MAGIC\t\t\t/* defined from <SWI-Stream.h> */\n\t\t /*******************************\n\t\t *\t  STREAM SUPPORT\t*\n\t\t *******************************/\n\n\t\t\t\t\t/* Make IOSTREAM known to Prolog */\n#define PL_open_stream  PL_unify_stream\t/* compatibility */\nPL_EXPORT(int)\t\tPL_unify_stream(term_t t, IOSTREAM *s);\nPL_EXPORT(int)\t\tPL_get_stream_handle(term_t t, IOSTREAM **s);\nPL_EXPORT(int)\t\tPL_get_stream(term_t t, IOSTREAM **s, int flags);\nPL_EXPORT(IOSTREAM*)\tPL_acquire_stream(IOSTREAM *s);\nPL_EXPORT(int)\t\tPL_release_stream(IOSTREAM *s);\nPL_EXPORT(int)\t\tPL_release_stream_noerror(IOSTREAM *s);\nPL_EXPORT(IOSTREAM *)\tPL_open_resource(module_t m,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t const char *rc_class,\n\t\t\t\t\t const char *mode);\n\nPL_EXPORT(IOSTREAM *)*_PL_streams(void);\t/* base of streams */\n#ifndef PL_KERNEL\n#define Suser_input     (_PL_streams()[0])\n#define Suser_output    (_PL_streams()[1])\n#define Suser_error     (_PL_streams()[2])\n#define Scurrent_input  (_PL_streams()[3])\n#define Scurrent_output (_PL_streams()[4])\n#endif\n\n#define PL_WRT_QUOTED\t\t0x01\t/* quote atoms */\n#define PL_WRT_IGNOREOPS\t0x02\t/* ignore list/operators */\n#define PL_WRT_NUMBERVARS\t0x04\t/* print $VAR(N) as a variable */\n#define PL_WRT_PORTRAY\t\t0x08\t/* call portray */\n#define PL_WRT_CHARESCAPES\t0x10\t/* Output ISO escape sequences */\n#define PL_WRT_BACKQUOTED_STRING 0x20\t/* Write strings as `...` */\n\t\t\t\t\t/* Write attributed variables */\n#define PL_WRT_ATTVAR_IGNORE\t0x040\t/* Default: just write the var */\n#define PL_WRT_ATTVAR_DOTS\t0x080\t/* Write as Var{...} */\n#define PL_WRT_ATTVAR_WRITE\t0x100\t/* Write as Var{Attributes} */\n#define PL_WRT_ATTVAR_PORTRAY\t0x200\t/* Use Module:portray_attrs/2 */\n#define PL_WRT_ATTVAR_MASK \\\n\t(PL_WRT_ATTVAR_IGNORE | \\\n\t PL_WRT_ATTVAR_DOTS | \\\n\t PL_WRT_ATTVAR_WRITE | \\\n\t PL_WRT_ATTVAR_PORTRAY)\n#define PL_WRT_BLOB_PORTRAY\t0x400\t/* Use portray to emit non-text blobs */\n#define PL_WRT_NO_CYCLES\t0x800\t/* Never emit @(Template,Subst) */\n#define PL_WRT_NEWLINE\t       0x2000\t/* Add a newline */\n#define PL_WRT_VARNAMES\t       0x4000\t/* Internal: variable_names(List)  */\n#define PL_WRT_BACKQUOTE_IS_SYMBOL 0x8000 /* ` is a symbol char */\n#define PL_WRT_DOTLISTS\t       0x10000\t/* Write lists as .(A,B) */\n#define PL_WRT_BRACETERMS      0x20000\t/* Write {A} as {}(A) */\n#define PL_WRT_NODICT\t       0x40000\t/* Do not write dicts in pretty syntax */\n#define PL_WRT_NODOTINATOM     0x80000\t/* never write a.b unquoted */\n\nPL_EXPORT(int)\tPL_write_term(IOSTREAM *s,\n\t\t\t     term_t term,\n\t\t\t     int precedence,\n\t\t\t     int flags);\n\n\t\t\t\t\t/* PL_ttymode() results */\n#define PL_NOTTY\t0\t\t/* -tty in effect */\n#define PL_RAWTTY\t1\t\t/* get_single_char/1 */\n#define PL_COOKEDTTY\t2\t\t/* normal input */\n\nPL_EXPORT(int)\t\tPL_ttymode(IOSTREAM *s);\n\n#endif /*SIO_MAGIC*/\n\nPL_EXPORT(int)  PL_put_term_from_chars(term_t t, int flags,\n\t\t\t\t       size_t len, const char *s);\nPL_EXPORT(int)\tPL_chars_to_term(const char *chars,\n\t\t\t\tterm_t term);\nPL_EXPORT(int)\tPL_wchars_to_term(const pl_wchar_t *chars,\n\t\t\t\t term_t term);\n\n\n\t\t /*******************************\n\t\t *\t    EMBEDDING\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_initialise(int argc, char **argv);\nPL_EXPORT(int)\t\tPL_is_initialised(int *argc, char ***argv);\nPL_EXPORT(int)\t\tPL_set_resource_db_mem(const unsigned char *data,\n\t\t\t\t\t       size_t size);\nPL_EXPORT(int)\t\tPL_toplevel(void);\nPL_EXPORT(int)\t\tPL_cleanup(int status);\nPL_EXPORT(void)\t\tPL_cleanup_fork();\nPL_EXPORT(int)\t\tPL_halt(int status);\n\n\t\t /*******************************\n\t\t *\t  DYNAMIC LINKING\t*\n\t\t *******************************/\n\nPL_EXPORT(void *)\tPL_dlopen(const char *file, int flags);\nPL_EXPORT(const char *) PL_dlerror(void);\nPL_EXPORT(void *)\tPL_dlsym(void *handle, char *symbol);\nPL_EXPORT(int)\t\tPL_dlclose(void *handle);\n\n\n\t\t /*******************************\n\t\t *      INPUT/PROMPT/ETC\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nNOTE: the functions in this section are   not  documented, as as yet not\nadviced for public usage.  They  are   intended  to  provide an abstract\ninterface for the GNU readline  interface   as  defined  in the readline\npackage.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\t\t\t\t\t/* PL_dispatch() modes */\n#define PL_DISPATCH_NOWAIT    0\t\t/* Dispatch only once */\n#define PL_DISPATCH_WAIT      1\t\t/* Dispatch till input available */\n#define PL_DISPATCH_INSTALLED 2\t\t/* dispatch function installed? */\n\nPL_EXPORT(int)\t\tPL_dispatch(int fd, int wait);\nPL_EXPORT(void)\t\tPL_add_to_protocol(const char *buf, size_t count);\nPL_EXPORT(char *)\tPL_prompt_string(int fd);\nPL_EXPORT(void)\t\tPL_write_prompt(int dowrite);\nPL_EXPORT(void)\t\tPL_prompt_next(int fd);\nPL_EXPORT(char *)\tPL_atom_generator(const char *prefix, int state);\nPL_EXPORT(pl_wchar_t*)\tPL_atom_generator_w(const pl_wchar_t *pref,\n\t\t\t\t\t    pl_wchar_t *buffer,\n\t\t\t\t\t    size_t buflen,\n\t\t\t\t\t    int state);\n\n\n\t\t /*******************************\n\t\t *\tMEMORY ALLOCATION\t*\n\t\t *******************************/\n\nPL_EXPORT(void *)\tPL_malloc(size_t size);\nPL_EXPORT(void *)\tPL_malloc_atomic(size_t size);\nPL_EXPORT(void *)\tPL_malloc_uncollectable(size_t size);\nPL_EXPORT(void *)\tPL_malloc_atomic_uncollectable(size_t size);\nPL_EXPORT(void *)\tPL_realloc(void *mem, size_t size);\nPL_EXPORT(void *)\tPL_malloc_unmanaged(size_t size);\nPL_EXPORT(void *)\tPL_malloc_atomic_unmanaged(size_t size);\nPL_EXPORT(void)\t\tPL_free(void *mem);\nPL_EXPORT(int)\t\tPL_linger(void *mem);\n\n\n\t\t/********************************\n\t\t*             HOOKS\t\t*\n\t\t********************************/\n\n#define PL_DISPATCH_INPUT   0\t\t/* There is input available */\n#define PL_DISPATCH_TIMEOUT 1\t\t/* Dispatch timeout */\n\ntypedef int  (*PL_dispatch_hook_t)(int fd);\ntypedef void (*PL_abort_hook_t)(void);\ntypedef void (*PL_initialise_hook_t)(int argc, char **argv);\ntypedef int  (*PL_agc_hook_t)(atom_t a);\n\nPL_EXPORT(PL_dispatch_hook_t)\tPL_dispatch_hook(PL_dispatch_hook_t);\nPL_EXPORT(void)\t\t\tPL_abort_hook(PL_abort_hook_t);\nPL_EXPORT(void)\t\t\tPL_initialise_hook(PL_initialise_hook_t);\nPL_EXPORT(int)\t\t\tPL_abort_unhook(PL_abort_hook_t);\nPL_EXPORT(PL_agc_hook_t)\tPL_agc_hook(PL_agc_hook_t);\n\n\n\t\t/********************************\n\t\t*            SIGNALS            *\n\t\t*********************************/\n\n/* PL_signal() masks (deprecated) */\n#define PL_SIGSYNC\t0x00010000\t/* call handler synchronously */\n#define PL_SIGNOFRAME\t0x00020000\t/* Do not create a Prolog frame */\n\n#define PLSIG_THROW     0x0002\t\t/* throw signal(num, name) */\n#define PLSIG_SYNC      0x0004\t\t/* call synchronously */\n#define PLSIG_NOFRAME   0x0008\t\t/* Do not create a Prolog frame */\n\n\n\n\ntypedef struct pl_sigaction\n{ void        (*sa_cfunction)(int);\t/* traditional C function */\n  predicate_t sa_predicate;\t\t/* call a predicate */\n  int\t      sa_flags;\t\t\t/* additional flags */\n  void       *reserved[2];\t\t/* future extentions */\n} pl_sigaction_t;\n\n\nPL_EXPORT(void) (*PL_signal(int sig, void (*func)(int)))(int);\nPL_EXPORT(int)  PL_sigaction(int sig, pl_sigaction_t *act, pl_sigaction_t *old);\nPL_EXPORT(void)\tPL_interrupt(int sig);\nPL_EXPORT(int)\tPL_raise(int sig);\nPL_EXPORT(int)\tPL_handle_signals(void);\nPL_EXPORT(int)\tPL_get_signum_ex(term_t sig, int *n);\n\n\n\t\t/********************************\n\t\t*      PROLOG ACTION/QUERY      *\n\t\t*********************************/\n\n#define\tPL_ACTION_TRACE\t\t1\t/* switch to trace mode */\n#define PL_ACTION_DEBUG\t\t2\t/* switch to debug mode */\n#define PL_ACTION_BACKTRACE\t3\t/* show a backtrace (stack dump) */\n#define PL_ACTION_BREAK\t\t4\t/* create a break environment */\n#define PL_ACTION_HALT\t\t5\t/* halt Prolog execution */\n#define PL_ACTION_ABORT\t\t6\t/* generate a Prolog abort */\n\t\t\t\t\t/* 7: Obsolete PL_ACTION_SYMBOLFILE */\n#define PL_ACTION_WRITE\t\t8\t/* write via Prolog i/o buffer */\n#define PL_ACTION_FLUSH\t\t9\t/* Flush Prolog i/o buffer */\n#define PL_ACTION_GUIAPP\t10\t/* Win32: set when this is a gui */\n#define PL_ACTION_ATTACH_CONSOLE 11\t/* MT: Attach a console */\n#define PL_GMP_SET_ALLOC_FUNCTIONS 12\t/* GMP: do not change allocation functions */\n#define PL_ACTION_TRADITIONAL\t13\t/* Set --traditional */\n\n#define PL_BT_SAFE\t\t0x1\t/* Do not try to print goals */\n#define PL_BT_USER\t\t0x2\t/* Only show user-goals */\n\nPL_EXPORT(int)\tPL_action(int, ...);\t/* perform some action */\nPL_EXPORT(void)\tPL_on_halt(int (*)(int, void *), void *);\nPL_EXPORT(void)\tPL_exit_hook(int (*)(int, void *), void *);\nPL_EXPORT(void)\tPL_backtrace(int depth, int flags);\nPL_EXPORT(char *) PL_backtrace_string(int depth, int flags);\nPL_EXPORT(int)\tPL_check_data(term_t data);\nPL_EXPORT(int)\tPL_check_stacks(void);\nPL_EXPORT(int)\tPL_current_prolog_flag(atom_t name, int type, void *ptr);\n\n\n\t\t/********************************\n\t\t*         QUERY PROLOG          *\n\t\t*********************************/\n\n#define PL_QUERY_ARGC\t\t1\t/* return main() argc */\n#define PL_QUERY_ARGV\t\t2\t/* return main() argv */\n\t\t\t\t\t/* 3: Obsolete PL_QUERY_SYMBOLFILE */\n\t\t\t\t\t/* 4: Obsolete PL_QUERY_ORGSYMBOLFILE*/\n#define PL_QUERY_GETC\t\t5\t/* Read character from terminal */\n#define PL_QUERY_MAX_INTEGER\t6\t/* largest integer */\n#define PL_QUERY_MIN_INTEGER\t7\t/* smallest integer */\n#define PL_QUERY_MAX_TAGGED_INT\t8\t/* largest tagged integer */\n#define PL_QUERY_MIN_TAGGED_INT\t9\t/* smallest tagged integer */\n#define PL_QUERY_VERSION        10\t/* 207006 = 2.7.6 */\n#define PL_QUERY_MAX_THREADS\t11\t/* maximum thread count */\n#define PL_QUERY_ENCODING\t12\t/* I/O encoding */\n#define PL_QUERY_USER_CPU\t13\t/* User CPU in milliseconds */\n#define PL_QUERY_HALTING\t14\t/* If TRUE, we are in PL_cleanup() */\n\nPL_EXPORT(intptr_t)\tPL_query(int);\t/* get information from Prolog */\n\n\n\t\t /*******************************\n\t\t *\t  PROLOG THREADS\t*\n\t\t *******************************/\n\n#define PL_THREAD_NO_DEBUG\t0x01\t/* Start thread in nodebug mode */\n#define PL_THREAD_NOT_DETACHED\t0x02\t/* Allow Prolog to join */\n\ntypedef enum\n{ PL_THREAD_CANCEL_FAILED = FALSE,\t/* failed to cancel; try abort */\n  PL_THREAD_CANCEL_JOINED = TRUE,\t/* cancelled and joined */\n  PL_THREAD_CANCEL_MUST_JOIN\t\t/* cancelled, must join */\n} rc_cancel;\n\ntypedef struct\n{ size_t    stack_limit;\t\t/* Total stack limit (bytes) */\n  size_t    table_space;\t\t/* Total tabling space limit (bytes) */\n  char *    alias;\t\t\t/* alias name */\n  rc_cancel (*cancel)(int id);\t\t/* cancel function */\n  intptr_t  flags;\t\t\t/* PL_THREAD_* flags */\n  size_t    max_queue_size;\t\t/* Max size of associated queue */\n  void *    reserved[3];\t\t/* reserved for extensions */\n} PL_thread_attr_t;\n\n\nPL_EXPORT(int)\tPL_thread_self(void);\t/* Prolog thread id (-1 if none) */\nPL_EXPORT(int)\tPL_unify_thread_id(term_t t, int i);\nPL_EXPORT(int)\tPL_get_thread_id_ex(term_t t, int *idp);\nPL_EXPORT(int)\tPL_get_thread_alias(int tid, atom_t *alias);\t/* Locks alias */\nPL_EXPORT(int)\tPL_thread_attach_engine(PL_thread_attr_t *attr);\nPL_EXPORT(int)\tPL_thread_destroy_engine(void);\nPL_EXPORT(int)\tPL_thread_at_exit(void (*function)(void *),\n\t\t\t\t  void *closure,\n\t\t\t\t  int global);\nPL_EXPORT(int)\tPL_thread_raise(int tid, int sig);\n#if defined(_WINDOWS_) || defined(_WINDOWS_H)\t/* <windows.h> is included */\nPL_EXPORT(int)\tPL_w32thread_raise(DWORD dwTid, int sig);\nPL_EXPORT(int)\tPL_wait_for_console_input(void *handle);\nPL_EXPORT(int)\tPL_w32_wrap_ansi_console(void);\nPL_EXPORT(const char*) PL_w32_running_under_wine(void);\n#endif\n\n\t\t /*******************************\n\t\t *\t ENGINES (MT-ONLY)\t*\n\t\t *******************************/\n\n#define PL_ENGINE_MAIN\t  ((PL_engine_t)0x1)\n#define PL_ENGINE_CURRENT ((PL_engine_t)0x2)\n\n#define PL_ENGINE_SET   0\t\t/* engine set successfully */\n#define PL_ENGINE_INVAL\t2\t\t/* engine doesn't exist */\n#define PL_ENGINE_INUSE\t3\t\t/* engine is in use */\n\nPL_EXPORT(PL_engine_t)\tPL_create_engine(PL_thread_attr_t *attributes);\nPL_EXPORT(int)\t\tPL_set_engine(PL_engine_t engine, PL_engine_t *old);\nPL_EXPORT(int)\t\tPL_destroy_engine(PL_engine_t engine);\n\n\n\t\t /*******************************\n\t\t *\t     PROFILER\t\t*\n\t\t *******************************/\n\ntypedef struct\n{ int\t(*unify)(term_t t, void *handle);\t/* implementation --> Prolog */\n  int   (*get)(term_t t, void **handle);\t/* Prolog --> implementation */\n  void\t(*activate)(int active);\t\t/* (de)activate */\n  intptr_t\tmagic;\t\t\t\t\t/* PROFTYPE_MAGIC */\n} PL_prof_type_t;\n\nPL_EXPORT(int)\t\tPL_register_profile_type(PL_prof_type_t *type);\nPL_EXPORT(void*)\tPL_prof_call(void *handle, PL_prof_type_t *type);\nPL_EXPORT(void)\t\tPL_prof_exit(void *node);\n\n\n\t\t /*******************************\n\t\t *\t WINDOWS MESSAGES\t*\n\t\t *******************************/\n\n#if defined(_WINDOWS_) || defined(_WINDOWS_H)\t/* <windows.h> is included */\n#define PL_MSG_EXCEPTION_RAISED -1\n#define PL_MSG_IGNORED 0\n#define PL_MSG_HANDLED 1\n\nPL_EXPORT(LRESULT)\tPL_win_message_proc(HWND hwnd,\n\t\t\t\t\t    UINT message,\n\t\t\t\t\t    WPARAM wParam,\n\t\t\t\t\t    LPARAM lParam);\n#endif /* _WINDOWS_/_WINDOWS_H */\n\n\n\t\t /*******************************\n\t\t *       FAST XPCE SUPPORT\t*\n\t\t *******************************/\n\ntypedef struct\n{ int type;\t\t\t\t/* PL_INTEGER or PL_ATOM */\n  union\n  { uintptr_t i;\t\t\t/* integer reference value */\n    atom_t\t  a;\t\t\t/* atom reference value */\n  } value;\n} xpceref_t;\n\nPL_EXPORT(int)\t_PL_get_xpce_reference(term_t t, xpceref_t *ref);\nPL_EXPORT(int)\t_PL_unify_xpce_reference(term_t t, xpceref_t *ref);\nPL_EXPORT(int)\t_PL_put_xpce_reference_i(term_t t, uintptr_t r);\nPL_EXPORT(int)\t_PL_put_xpce_reference_a(term_t t, atom_t name);\n\n\n\n\t\t /*******************************\n\t\t *         TRACE SUPPORT\t*\n\t\t *******************************/\n\n#ifndef _PL_INCLUDE_H\ntypedef void *QueryFrame;\ntypedef void *LocalFrame;\ntypedef void *Code;\n#endif\n\ntypedef struct pl_context_t\n{ PL_engine_t   ld;\t\t\t/* Engine */\n  QueryFrame\tqf;\t\t\t/* Current query */\n  LocalFrame\tfr;\t\t\t/* Current localframe */\n  Code\t\tpc;\t\t\t/* Code pointer */\n  void *\treserved[10];\t\t/* Reserved for extensions */\n} pl_context_t;\n\nPL_EXPORT(int)\tPL_get_context(struct pl_context_t *c, int thead_id);\nPL_EXPORT(int)\tPL_step_context(struct pl_context_t *c);\nPL_EXPORT(int)\tPL_describe_context(struct pl_context_t *c,\n\t\t\t\t    char *buf, size_t len);\n\n#ifdef PL_ARITY_AS_SIZE\n#define PL_new_functor(f,a) PL_new_functor_sz(f,a)\n#define PL_functor_arity(f) PL_functor_arity_sz(f)\n#define PL_get_name_arity(t,n,a) PL_get_name_arity_sz(t,n,a)\n#define PL_get_compound_name_arity(t,n,a) PL_get_compound_name_arity_sz(t,n,a)\n#define PL_get_arg(i,t,a) PL_get_arg_sz(i,t,a)\n#define PL_unify_arg(i,t,a) PL_unify_arg_sz(i,t,a)\n#ifndef _PL_INCLUDE_H\n#define _PL_get_arg(i,t,a) _PL_get_arg_sz(i,t,a)\n#endif\n#else\n//Considered too alarming\n//#warning \"Term arity has changed from int to size_t.\"\n//#warning \"Please update your code and use #define PL_ARITY_AS_SIZE 1.\"\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*_FLI_H_INCLUDED*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/pl-nt.c": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1995-2016, University of Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifdef __WINDOWS__\n#define WINVER 0x0501\n#if (_MSC_VER >= 1300) || __MINGW32__\n#include <winsock2.h>\t\t\t/* Needed on VC8 */\n#include <windows.h>\n#else\n#include <windows.h>\t\t\t/* Needed for MSVC 5&6 */\n#include <winsock2.h>\n#endif\n\n#ifdef __MINGW32__\n#ifndef _WIN32_IE\n#define _WIN32_IE 0x0400\n#endif\n/* FIXME: these are copied from SWI-Prolog.h. */\n#define PL_MSG_EXCEPTION_RAISED -1\n#define PL_MSG_IGNORED 0\n#define PL_MSG_HANDLED 1\n#endif\n\n#include \"pl-incl.h\"\n#include \"os/pl-utf8.h\"\n#include <process.h>\n#include \"os/pl-ctype.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include \"os/SWI-Stream.h\"\n#include <process.h>\n#include <winbase.h>\n#ifdef HAVE_CRTDBG_H\n#include <crtdbg.h>\n#endif\n\n\n\t\t /*******************************\n\t\t *\t       CONSOLE\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThere is no way to tell which subsystem   an app belongs too, except for\npeeking in its executable-header. This is a bit too much ...\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nint\nhasConsole(void)\n{ HANDLE h;\n\n  if ( GD->os.gui_app == FALSE )\t/* has been set explicitly */\n    succeed;\n\n\t\t\t\t\t/* I found a console */\n  if ( (h = GetStdHandle(STD_OUTPUT_HANDLE)) != INVALID_HANDLE_VALUE )\n  { DWORD mode;\n\n    if ( GetConsoleMode(h, &mode) )\n      succeed;\n  }\n\n\t\t\t\t\t/* assume we are GUI */\n  fail;\n}\n\n\nint\nPL_wait_for_console_input(void *handle)\n{ BOOL rc;\n  HANDLE hConsole = handle;\n\n  for(;;)\n  { rc = MsgWaitForMultipleObjects(1,\n\t\t\t\t   &hConsole,\n\t\t\t\t   FALSE,\t/* wait for either event */\n\t\t\t\t   INFINITE,\n\t\t\t\t   QS_ALLINPUT);\n\n    if ( rc == WAIT_OBJECT_0+1 )\n    { MSG msg;\n\n      while( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )\n      { TranslateMessage(&msg);\n\tDispatchMessage(&msg);\n      }\n    } else if ( rc == WAIT_OBJECT_0 )\n    { return TRUE;\n    } else\n    { Sdprintf(\"MsgWaitForMultipleObjects(): 0x%x\\n\", rc);\n    }\n  }\n}\n\n\n\t\t /*******************************\n\t\t *\t    MESSAGE BOX\t\t*\n\t\t *******************************/\n\nvoid\nPlMessage(const char *fm, ...)\n{ va_list(args);\n\n  va_start(args, fm);\n\n  if ( hasConsole() )\n  { Sfprintf(Serror, \"SWI-Prolog: \");\n    Svfprintf(Serror, fm, args);\n    Sfprintf(Serror, \"\\n\");\n  } else\n  { char buf[1024];\n    int64_t hwndi;\n    HWND hwnd = NULL;\n    static atom_t ATOM_hwnd = 0;\n\n    if ( !ATOM_hwnd )\n      ATOM_hwnd = PL_new_atom(\"hwnd\");\n\n    if ( PL_current_prolog_flag(ATOM_hwnd, PL_INTEGER, &hwndi) )\n      hwnd = (HWND)(uintptr_t)hwndi;\n\n    vsprintf(buf, fm, args);\n    MessageBox(hwnd, buf, \"SWI-Prolog\", MB_OK|MB_TASKMODAL);\n  }\n\n  va_end(args);\n}\n\n\n\n\t\t /*******************************\n\t\t *\tWinAPI ERROR CODES\t*\n\t\t *******************************/\n\nconst char *\nWinError(void)\n{ int id = GetLastError();\n  char *msg;\n  static WORD lang;\n  static int lang_initialised = 0;\n\n  if ( !lang_initialised )\n    lang = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK);\n\nagain:\n  if ( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|\n\t\t     FORMAT_MESSAGE_IGNORE_INSERTS|\n\t\t     FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t     NULL,\t\t\t/* source */\n\t\t     id,\t\t\t/* identifier */\n\t\t     lang,\n\t\t     (LPTSTR) &msg,\n\t\t     0,\t\t\t\t/* size */\n\t\t     NULL) )\t\t\t/* arguments */\n  { atom_t a = PL_new_atom(msg);\n\n    LocalFree(msg);\n    lang_initialised = 1;\n\n    return stringAtom(a);\n  } else\n  { if ( lang_initialised == 0 )\n    { lang = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);\n      lang_initialised = 1;\n      goto again;\n    }\n\n    return \"Unknown Windows error\";\n  }\n}\n\n\n\t\t /*******************************\n\t\t *\t  SLEEP/1 SUPPORT\t*\n\t\t *******************************/\n\nint\nPause(double t)\n{ HANDLE h;\n\n  if ( (h = CreateWaitableTimer(NULL, TRUE, NULL)) )\n  { LARGE_INTEGER ft;\n\n    ft.QuadPart = -(LONGLONG)(t * 10000000.0); /* 100 nanosecs per tick */\n\n    SetWaitableTimer(h, &ft, 0, NULL, NULL, FALSE);\n    for(;;)\n    { int rc = MsgWaitForMultipleObjects(1,\n\t\t\t\t\t &h,\n\t\t\t\t\t FALSE,\n\t\t\t\t\t INFINITE,\n\t\t\t\t\t QS_ALLINPUT);\n      if ( rc == WAIT_OBJECT_0+1 )\n      { MSG msg;\n\n\twhile( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )\n\t{ TranslateMessage(&msg);\n\t  DispatchMessage(&msg);\n\t}\n\n\tif ( PL_handle_signals() < 0 )\n\t{ CloseHandle(h);\n\t  return FALSE;\n\t}\n      } else\n\tbreak;\n    }\n    CloseHandle(h);\n\n    return TRUE;\n  } else\t\t\t\t/* Pre NT implementation */\n  { DWORD msecs = (DWORD)(t * 1000.0);\n\n    while( msecs >= 100 )\n    { Sleep(100);\n      if ( PL_handle_signals() < 0 )\n\treturn FALSE;\n      msecs -= 100;\n    }\n    if ( msecs > 0 )\n      Sleep(msecs);\n\n    return TRUE;\n  }\n}\n\n\n\t\t /*******************************\n\t\t *\t  SET FILE SIZE\t\t*\n\t\t *******************************/\n\n#ifndef HAVE_FTRUNCATE\n\nint\nftruncate(int fileno, int64_t length)\n{ errno_t e;\n\n  if ( (e=_chsize_s(fileno, length)) == 0 )\n    return 0;\n\n  errno = e;\n  return -1;\n}\n\n#endif\n\n\n\t\t /*******************************\n\t\t *\t QUERY CPU TIME\t\t*\n\t\t *******************************/\n\n#define nano * 0.0000001\n#define ntick 1.0\t\t\t/* manual says 100.0 ??? */\n\ndouble\nCpuTime(cputime_kind which)\n{ double t;\n  HANDLE proc = GetCurrentProcess();\n  FILETIME created, exited, kerneltime, usertime;\n\n  if ( GetProcessTimes(proc, &created, &exited, &kerneltime, &usertime) )\n  { FILETIME *p;\n\n    switch ( which )\n    { case CPU_USER:\n\tp = &usertime;\n\tbreak;\n      case CPU_SYSTEM:\n\tp = &kerneltime;\n        break;\n      default:\n\tassert(0);\n        return 0.0;\n    }\n    t = (double)p->dwHighDateTime * (4294967296.0 * ntick nano);\n    t += (double)p->dwLowDateTime  * (ntick nano);\n  } else\t\t\t\t/* '95, Windows 3.1/win32s */\n  { t = 0.0;\n  }\n\n  return t;\n}\n\n\nint\nCpuCount(void)\n{ SYSTEM_INFO si;\n\n  GetSystemInfo(&si);\n\n  return si.dwNumberOfProcessors;\n}\n\n\nvoid\nsetOSPrologFlags(void)\n{ PL_set_prolog_flag(\"cpu_count\", PL_INTEGER, CpuCount());\n}\n\n\nchar *\nfindExecutable(const char *module, char *exe, size_t exelen)\n{ int n;\n  wchar_t wbuf[MAXPATHLEN];\n  HMODULE hmod;\n\n  if ( module )\n  { if ( !(hmod = GetModuleHandle(module)) )\n    { hmod = GetModuleHandle(\"libswipl.dll\");\n      DEBUG(0,\n\t    Sdprintf(\"Warning: could not find module from \\\"%s\\\"\\n\"\n\t\t     \"Warning: Trying %s to find home\\n\",\n\t\t     module,\n\t\t     hmod ? \"\\\"LIBPL.DLL\\\"\" : \"executable\"));\n    }\n  } else\n    hmod = NULL;\n\n  if ( (n = GetModuleFileNameW(hmod, wbuf, MAXPATHLEN)) > 0 )\n  { wbuf[n] = EOS;\n    return _xos_long_file_name_toA(wbuf, exe, exelen);\n  } else if ( module )\n  { return PrologPath(module, exe, exelen);\n  } else\n    *exe = EOS;\n\n  return exe;\n}\n\n\t\t /*******************************\n\t\t *     SUPPORT FOR SHELL/2\t*\n\t\t *******************************/\n\ntypedef struct\n{ const char *name;\n  UINT        id;\n} showtype;\n\nstatic int\nget_showCmd(term_t show, UINT *cmd)\n{ char *s;\n  showtype *st;\n  static showtype types[] =\n  { { \"hide\",\t\t SW_HIDE },\n    { \"maximize\",\t SW_MAXIMIZE },\n    { \"minimize\",\t SW_MINIMIZE },\n    { \"restore\",\t SW_RESTORE },\n    { \"show\",\t\t SW_SHOW },\n    { \"showdefault\",\t SW_SHOWDEFAULT },\n    { \"showmaximized\",   SW_SHOWMAXIMIZED },\n    { \"showminimized\",   SW_SHOWMINIMIZED },\n    { \"showminnoactive\", SW_SHOWMINNOACTIVE },\n    { \"showna\",          SW_SHOWNA },\n    { \"shownoactive\",    SW_SHOWNOACTIVATE },\n    { \"shownormal\",      SW_SHOWNORMAL },\n\t\t\t\t\t/* compatibility */\n    { \"normal\",\t\t SW_SHOWNORMAL },\n    { \"iconic\",\t\t SW_MINIMIZE },\n    { NULL, 0 },\n  };\n\n  if ( show == 0 )\n  { *cmd = SW_SHOWNORMAL;\n    succeed;\n  }\n\n  if ( !PL_get_chars(show, &s, CVT_ATOM|CVT_EXCEPTION) )\n    fail;\n  for(st=types; st->name; st++)\n  { if ( streq(st->name, s) )\n    { *cmd = st->id;\n      succeed;\n    }\n  }\n\n  return PL_error(NULL, 0, NULL, ERR_DOMAIN,\n\t\t  PL_new_atom(\"win_show\"), show);\n}\n\n\n\nstatic int\nwin_exec(size_t len, const wchar_t *cmd, UINT show)\n{ GET_LD\n  STARTUPINFOW startup;\n  PROCESS_INFORMATION info;\n  int rval;\n  wchar_t *wcmd;\n\n  memset(&startup, 0, sizeof(startup));\n  startup.cb = sizeof(startup);\n  startup.wShowWindow = show;\n\n\t\t\t\t\t/* ensure 0-terminated */\n  wcmd = PL_malloc((len+1)*sizeof(wchar_t));\n  memcpy(wcmd, cmd, len*sizeof(wchar_t));\n  wcmd[len] = 0;\n\n  rval = CreateProcessW(NULL,\t\t/* app */\n\t\t\twcmd,\n\t\t\tNULL, NULL,\t/* security */\n\t\t\tFALSE,\t\t/* inherit handles */\n\t\t\t0,\t\t/* flags */\n\t\t\tNULL,\t\t/* environment */\n\t\t\tNULL,\t\t/* Directory */\n\t\t\t&startup,\n\t\t\t&info);\t\t/* process info */\n  PL_free(wcmd);\n\n  if ( rval )\n  { CloseHandle(info.hProcess);\n    CloseHandle(info.hThread);\n\n    succeed;\n  } else\n  { term_t tmp = PL_new_term_ref();\n\n    return ( PL_unify_wchars(tmp, PL_ATOM, len, cmd) &&\n\t     PL_error(NULL, 0, WinError(), ERR_SHELL_FAILED, tmp)\n\t   );\n  }\n}\n\n\nstatic void\nutf8towcs(wchar_t *o, const char *src)\n{ for( ; *src; )\n  { int wc;\n\n    src = utf8_get_char(src, &wc);\n    *o++ = wc;\n  }\n  *o = 0;\n}\n\n\nint\nSystem(char *command)\t\t\t/* command is a UTF-8 string */\n{ STARTUPINFOW sinfo;\n  PROCESS_INFORMATION pinfo;\n  int shell_rval;\n  size_t len;\n  wchar_t *wcmd;\n\n  memset(&sinfo, 0, sizeof(sinfo));\n  sinfo.cb = sizeof(sinfo);\n\n  len = utf8_strlen(command, strlen(command));\n  wcmd = PL_malloc((len+1)*sizeof(wchar_t));\n  utf8towcs(wcmd, command);\n\n  if ( CreateProcessW(NULL,\t\t\t/* module */\n\t\t      wcmd,\t\t\t/* command line */\n\t\t      NULL,\t\t\t/* Security stuff */\n\t\t      NULL,\t\t\t/* Thread security stuff */\n\t\t      FALSE,\t\t\t/* Inherit handles */\n\t\t      CREATE_NO_WINDOW,\t\t/* flags */\n\t\t      NULL,\t\t\t/* environment */\n\t\t      NULL,\t\t\t/* CWD */\n\t\t      &sinfo,\t\t\t/* startup info */\n\t\t      &pinfo) )\t\t\t/* process into */\n  { BOOL rval;\n    DWORD code;\n\n    CloseHandle(pinfo.hThread);\t\t\t/* don't need this */\n    PL_free(wcmd);\n\n    do\n    { MSG msg;\n\n      if ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )\n      { TranslateMessage(&msg);\n\tDispatchMessage(&msg);\n      } else\n\tSleep(50);\n\n      rval = GetExitCodeProcess(pinfo.hProcess, &code);\n    } while(rval == TRUE && code == STILL_ACTIVE);\n\n    shell_rval = (rval == TRUE ? code : -1);\n    CloseHandle(pinfo.hProcess);\n  } else\n  { PL_free(wcmd);\n    return shell_rval = -1;\n  }\n\n  return shell_rval;\n}\n\n\nword\npl_win_exec(term_t cmd, term_t how)\n{ wchar_t *s;\n  size_t len;\n  UINT h;\n\n  if ( PL_get_wchars(cmd, &len, &s, CVT_ALL|CVT_EXCEPTION) &&\n       get_showCmd(how, &h) )\n  { return win_exec(len, s, h);\n  } else\n    fail;\n}\n\ntypedef struct\n{ int   eno;\n  const char *message;\n} shell_error;\n\nstatic const shell_error se_errors[] =\n{ { 0 ,                     \"Out of memory or resources\" },\n  { ERROR_FILE_NOT_FOUND,   \"File not found\" },\n  { ERROR_PATH_NOT_FOUND,   \"path not found\" },\n  { ERROR_BAD_FORMAT,\t    \"Invalid .EXE\" },\n  { SE_ERR_ACCESSDENIED,    \"Access denied\" },\n  { SE_ERR_ASSOCINCOMPLETE, \"Incomplete association\" },\n  { SE_ERR_DDEBUSY,\t    \"DDE server busy\" },\n  { SE_ERR_DDEFAIL,         \"DDE transaction failed\" },\n  { SE_ERR_DDETIMEOUT,\t    \"DDE request timed out\" },\n  { SE_ERR_DLLNOTFOUND,\t    \"DLL not found\" },\n  { SE_ERR_FNF,\t\t    \"File not found (FNF)\" },\n  { SE_ERR_NOASSOC,\t    \"No association\" },\n  { SE_ERR_OOM,\t\t    \"Not enough memory\" },\n  { SE_ERR_PNF,\t\t    \"Path not found (PNF)\" },\n  { SE_ERR_SHARE,\t    \"Sharing violation\" },\n  { 0,\t\t\t    NULL }\n};\n\n\nstatic int\nwin_shell(term_t op, term_t file, term_t how)\n{ size_t lo, lf;\n  wchar_t *o, *f;\n  UINT h;\n  HINSTANCE instance;\n\n  if ( !PL_get_wchars(op,   &lo, &o, CVT_ALL|CVT_EXCEPTION|BUF_RING) ||\n       !PL_get_wchars(file, &lf, &f, CVT_ALL|CVT_EXCEPTION|BUF_RING) ||\n       !get_showCmd(how, &h) )\n    fail;\n\n  instance = ShellExecuteW(NULL, o, f, NULL, NULL, h);\n\n  if ( (intptr_t)instance <= 32 )\n  { const shell_error *se;\n\n    for(se = se_errors; se->message; se++)\n      { if ( se->eno == (int)(intptr_t)instance )\n\treturn PL_error(NULL, 0, se->message, ERR_SHELL_FAILED, file);\n    }\n    PL_error(NULL, 0, NULL, ERR_SHELL_FAILED, file);\n  }\n\n  succeed;\n}\n\n\nstatic\nPRED_IMPL(\"win_shell\", 2, win_shell2, 0)\n{ return win_shell(A1, A2, 0);\n}\n\n\nstatic\nPRED_IMPL(\"win_shell\", 3, win_shell3, 0)\n{ return win_shell(A1, A2, A3);\n}\n\n\nforeign_t\npl_win_module_file(term_t module, term_t file)\n{ char buf[MAXPATHLEN];\n  char *m;\n  char *f;\n\n  if ( !PL_get_chars(module, &m, CVT_ALL|CVT_EXCEPTION) )\n    fail;\n  if ( (f = findExecutable(m, buf, sizeof(buf))) )\n    return PL_unify_atom_chars(file, f);\n\n  fail;\n}\n\n\t\t /*******************************\n\t\t *\t  WINDOWS MESSAGES\t*\n\t\t *******************************/\n\nLRESULT\nPL_win_message_proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n#ifdef O_PLMT\n  if ( hwnd == NULL &&\n       message == WM_SIGNALLED &&\n       wParam == 0 &&\t\t\t/* or another constant? */\n       lParam == 0 )\n  { if ( PL_handle_signals() < 0 )\n      return PL_MSG_EXCEPTION_RAISED;\n\n    return PL_MSG_HANDLED;\n  }\n#endif\n\n  return PL_MSG_IGNORED;\n}\n\n\n\t\t /*******************************\n\t\t *\tDLOPEN AND FRIENDS\t*\n\t\t *******************************/\n\n#ifdef EMULATE_DLOPEN\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThese functions emulate the bits from the ELF shared object interface we\nneed. They are used  by  pl-load.c,   which  defines  the  actual Prolog\ninterface.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef HAVE_LIBLOADERAPI_H\n#include <LibLoaderAPI.h>\n#else\n#ifndef LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR\n#define LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR 0x00000100\n#endif\n#ifndef LOAD_LIBRARY_SEARCH_DEFAULT_DIRS\n#define LOAD_LIBRARY_SEARCH_DEFAULT_DIRS 0x00001000\n#endif\ntypedef void * DLL_DIRECTORY_COOKIE;\n#endif\n\nstatic const char *dlmsg;\nstatic DLL_DIRECTORY_COOKIE WINAPI (*f_AddDllDirectoryW)(wchar_t* dir);\nstatic BOOL WINAPI (*f_RemoveDllDirectory)(DLL_DIRECTORY_COOKIE);\n\nstatic DWORD\nload_library_search_flags(void)\n{ static int done = FALSE;\n  static DWORD flags = 0;\n\n  if ( !done )\n  { HMODULE kernel = GetModuleHandle(TEXT(\"kernel32.dll\"));\n\n    if ( (f_AddDllDirectoryW   = (void*)GetProcAddress(kernel, \"AddDllDirectory\")) &&\n\t (f_RemoveDllDirectory = (void*)GetProcAddress(kernel, \"RemoveDllDirectory\")) )\n    { flags = ( LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR|\n\t\tLOAD_LIBRARY_SEARCH_DEFAULT_DIRS );\n    }\n    done = TRUE;\n  }\n\n  return flags;\n}\n\n\nstatic\nPRED_IMPL(\"win_add_dll_directory\", 2, win_add_dll_directory, 0)\n{ PRED_LD\n  char *dirs;\n\n  if ( PL_get_file_name(A1, &dirs, REP_UTF8) )\n  { size_t len = utf8_strlen(dirs, strlen(dirs));\n    wchar_t *dirw = alloca((len+10)*sizeof(wchar_t));\n    DLL_DIRECTORY_COOKIE cookie;\n\n    if ( _xos_os_filenameW(dirs, dirw, len+10) == NULL )\n      return PL_representation_error(\"file_name\");\n    if ( load_library_search_flags() )\n    { if ( (cookie = (*f_AddDllDirectoryW)(dirw)) )\n\treturn PL_unify_int64(A2, (int64_t)(uintptr_t)cookie);\n      return PL_error(NULL, 0, WinError(), ERR_SYSCALL, \"AddDllDirectory()\");\n    } else\n      return FALSE;\n  } else\n    return FALSE;\n}\n\n\nstatic\nPRED_IMPL(\"win_remove_dll_directory\", 1, win_remove_dll_directory, 0)\n{ int64_t icookie;\n\n  if ( PL_get_int64_ex(A1, &icookie) )\n  { if ( f_RemoveDllDirectory )\n    { if ( (*f_RemoveDllDirectory)((DLL_DIRECTORY_COOKIE)(uintptr_t)icookie) )\n\treturn TRUE;\n\n      return PL_error(NULL, 0, WinError(), ERR_SYSCALL, \"RemoveDllDirectory()\");\n    } else\n      return FALSE;\n  } else\n    return FALSE;\n}\n\n\nstatic int\nis_windows_abs_path(const wchar_t *path)\n{ if ( path[1] == ':' && path[0] < 0x80 && iswalpha(path[0]) )\n    return TRUE;\t\t\t/* drive */\n  if ( path[0] == '\\\\' && path[1] == '\\\\' )\n    return TRUE;\t\t\t/* UNC */\n\n  return FALSE;\n}\n\nvoid *\nPL_dlopen(const char *file, int flags)\t/* file is in UTF-8, POSIX path */\n{ HINSTANCE h;\n  DWORD llflags = 0;\n  size_t len = utf8_strlen(file, strlen(file));\n  wchar_t *wfile = alloca((len+10)*sizeof(wchar_t));\n\n  if ( !wfile )\n  { dlmsg = \"No memory\";\n    return NULL;\n  }\n\n  if ( _xos_os_filenameW(file, wfile, len+10) == NULL )\n  { dlmsg = \"Name too long\";\n    return NULL;\n  }\n\n  if ( is_windows_abs_path(wfile) )\n    llflags |= load_library_search_flags();\n\n  if ( (h = LoadLibraryExW(wfile, NULL, llflags)) )\n  { dlmsg = \"No Error\";\n    return (void *)h;\n  }\n\n  dlmsg = WinError();\n  return NULL;\n}\n\n\nconst char *\nPL_dlerror(void)\n{ return dlmsg;\n}\n\n\nvoid *\nPL_dlsym(void *handle, char *symbol)\n{ void *addr = GetProcAddress(handle, symbol);\n\n  if ( addr )\n  { dlmsg = \"No Error\";\n    return addr;\n  }\n\n  dlmsg = WinError();\n  return NULL;\n}\n\n\nint\nPL_dlclose(void *handle)\n{ FreeLibrary(handle);\n\n  return 0;\n}\n\n#endif /*EMULATE_DLOPEN*/\n\n\n\t\t /*******************************\n\t\t *\t SNPRINTF MADNESS\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMS-Windows _snprintf() may look like C99 snprintf(), but is is not quite\nthe same: on overflow, the buffer is   *not* 0-terminated and the return\nis negative (unspecified how negative).  The   code  below  works around\nthis, returning count on overflow. This is still not the same as the C99\nversion that returns the  number  of   characters  that  would have been\nwritten, but it seems to be enough for our purposes.\n\nSee http://www.di-mgt.com.au/cprog.html#snprintf\n\nThe above came from the provided link, but it is even worse (copied from\nVS2005 docs):\n\n  - If len < count, then len characters are stored in buffer, a\n  null-terminator is appended, and len is returned.\n\n  - If len = count, then len characters are stored in buffer, no\n  null-terminator is appended, and len is returned.\n\n  - If len > count, then count characters are stored in buffer, no\n  null-terminator is appended, and a negative value is returned.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nint\nms_snprintf(char *buffer, size_t count, const char *fmt, ...)\n{ va_list ap;\n  int ret;\n\n  va_start(ap, fmt);\n  ret = _vsnprintf(buffer, count-1, fmt, ap);\n  va_end(ap);\n\n  if ( ret < 0 || ret == count )\n  { ret = (int)count;\n    buffer[count-1] = '\\0';\n  }\n\n  return ret;\n}\n\n\n\n\t\t /*******************************\n\t\t *\t      FOLDERS\t\t*\n\t\t *******************************/\n\n#ifdef HAVE_SHLOBJ_H\n#include <shlobj.h>\n#endif\n\ntypedef struct folderid\n{ int csidl;\n  const char *name;\n} folderid;\n\nstatic const folderid folderids[] =\n{ { CSIDL_COMMON_ALTSTARTUP, \"common_altstartup\" },\n  { CSIDL_ALTSTARTUP, \"altstartup\" },\n  { CSIDL_APPDATA, \"appdata\" },\n  { CSIDL_CONTROLS, \"controls\" },\n  { CSIDL_COOKIES, \"cookies\" },\n  { CSIDL_DESKTOP, \"desktop\" },\n  { CSIDL_COMMON_DESKTOPDIRECTORY, \"common_desktopdirectory\" },\n  { CSIDL_DESKTOPDIRECTORY, \"desktopdirectory\" },\n  { CSIDL_COMMON_FAVORITES, \"common_favorites\" },\n  { CSIDL_FAVORITES, \"favorites\" },\n  { CSIDL_FONTS, \"fonts\" },\n  { CSIDL_HISTORY, \"history\" },\n  { CSIDL_INTERNET_CACHE, \"internet_cache\" },\n  { CSIDL_INTERNET, \"internet\" },\n  { CSIDL_DRIVES, \"drives\" },\n  { CSIDL_PERSONAL, \"personal\" },\n  { CSIDL_NETWORK, \"network\" },\n  { CSIDL_NETHOOD, \"nethood\" },\n  { CSIDL_PERSONAL, \"personal\" },\n  { CSIDL_PRINTERS, \"printers\" },\n  { CSIDL_PRINTHOOD, \"printhood\" },\n  { CSIDL_COMMON_PROGRAMS, \"common_programs\" },\n  { CSIDL_PROGRAMS, \"programs\" },\n  { CSIDL_RECENT, \"recent\" },\n  { CSIDL_BITBUCKET, \"bitbucket\" },\n  { CSIDL_SENDTO, \"sendto\" },\n  { CSIDL_COMMON_STARTMENU, \"common_startmenu\" },\n  { CSIDL_STARTMENU, \"startmenu\" },\n  { CSIDL_COMMON_STARTUP, \"common_startup\" },\n  { CSIDL_STARTUP, \"startup\" },\n  { CSIDL_TEMPLATES, \"templates\" },\n  { 0, NULL }\n};\n\n\nstatic int\nunify_csidl_path(term_t t, int csidl)\n{ wchar_t buf[MAX_PATH];\n\n  if ( SHGetSpecialFolderPathW(0, buf, csidl, FALSE) )\n  { wchar_t *p;\n\n    for(p=buf; *p; p++)\n    { if ( *p == '\\\\' )\n\t*p = '/';\n    }\n\n    return PL_unify_wchars(t, PL_ATOM, -1, buf);\n  } else\n    return PL_error(NULL, 0, WinError(), ERR_SYSCALL, \"SHGetSpecialFolderPath\");\n}\n\n\nstatic\nPRED_IMPL(\"win_folder\", 2, win_folder, PL_FA_NONDETERMINISTIC)\n{ GET_LD\n  int n;\n\n  switch( CTX_CNTRL )\n  { case FRG_FIRST_CALL:\n      if ( PL_is_variable(A1) )\n      { n = 0;\n\tgoto generate;\n      } else\n      { char *s;\n\n\tif ( PL_get_chars(A1, &s, CVT_ATOM|CVT_EXCEPTION) )\n\t{ const folderid *fid;\n\n\t  for(fid = folderids; fid->name; fid++)\n\t  { if ( streq(s, fid->name) )\n\t      return unify_csidl_path(A2, fid->csidl);\n\t  }\n\n\t  { atom_t dom = PL_new_atom(\"win_folder\");\n\n\t    PL_error(NULL, 0, NULL, ERR_DOMAIN, dom, A1);\n\t    PL_unregister_atom(dom);\n\t    return FALSE;\n\t  }\n\t} else\n\t  return FALSE;\n      }\n    case FRG_REDO:\n    { fid_t fid;\n\n      n = (int)CTX_INT+1;\n\n      generate:\n\tfid = PL_open_foreign_frame();\n\tfor(; folderids[n].name; n++)\n\t{ if ( unify_csidl_path(A2, folderids[n].csidl) &&\n\t       PL_unify_atom_chars(A1, folderids[n].name) )\n\t  { PL_close_foreign_frame(fid);\n\t    ForeignRedoInt(n);\n\t  }\n\t  PL_rewind_foreign_frame(fid);\n\t}\n\tPL_close_foreign_frame(fid);\n\treturn FALSE;\n    }\n    default:\n      succeed;\n  }\n}\n\n\n\n\t\t /*******************************\n\t\t *\t      REGISTRY\t\t*\n\t\t *******************************/\n\n#define wstreq(s,q) (wcscmp((s), (q)) == 0)\n\nstatic HKEY\nreg_open_key(const wchar_t *which, int create)\n{ HKEY key = HKEY_CURRENT_USER;\n  DWORD disp;\n  LONG rval;\n\n  while(*which)\n  { wchar_t buf[256];\n    wchar_t *s;\n    HKEY tmp;\n\n    for(s=buf; *which && !(*which == '/' || *which == '\\\\'); )\n      *s++ = *which++;\n    *s = '\\0';\n    if ( *which )\n      which++;\n\n    if ( wstreq(buf, L\"HKEY_CLASSES_ROOT\") )\n    { key = HKEY_CLASSES_ROOT;\n      continue;\n    } else if ( wstreq(buf, L\"HKEY_CURRENT_USER\") )\n    { key = HKEY_CURRENT_USER;\n      continue;\n    } else if ( wstreq(buf, L\"HKEY_LOCAL_MACHINE\") )\n    { key = HKEY_LOCAL_MACHINE;\n      continue;\n    } else if ( wstreq(buf, L\"HKEY_USERS\") )\n    { key = HKEY_USERS;\n      continue;\n    }\n\n    DEBUG(2, Sdprintf(\"Trying %s\\n\", buf));\n    if ( RegOpenKeyExW(key, buf, 0L, KEY_READ, &tmp) == ERROR_SUCCESS )\n    { RegCloseKey(key);\n      key = tmp;\n      continue;\n    }\n\n    if ( !create )\n      return NULL;\n\n    rval = RegCreateKeyExW(key, buf, 0, L\"\", 0,\n\t\t\t  KEY_ALL_ACCESS, NULL, &tmp, &disp);\n    RegCloseKey(key);\n    if ( rval == ERROR_SUCCESS )\n      key = tmp;\n    else\n      return NULL;\n  }\n\n  return key;\n}\n\n#define MAXREGSTRLEN 1024\n\nstatic\nPRED_IMPL(\"win_registry_get_value\", 3, win_registry_get_value, 0)\n{ GET_LD\n  DWORD type;\n  union\n  { BYTE bytes[MAXREGSTRLEN];\n    wchar_t wchars[MAXREGSTRLEN/sizeof(wchar_t)];\n    DWORD dword;\n  } data;\n  DWORD len = sizeof(data);\n  size_t klen, namlen;\n  wchar_t *k, *name;\n  HKEY key;\n\n  term_t Key = A1;\n  term_t Name = A2;\n  term_t Value = A3;\n\n  if ( !PL_get_wchars(Key, &klen, &k, CVT_ATOM|CVT_EXCEPTION) ||\n       !PL_get_wchars(Name, &namlen, &name, CVT_ATOM|CVT_ATOM) )\n    return FALSE;\n  if ( !(key=reg_open_key(k, FALSE)) )\n    return PL_error(NULL, 0, NULL, ERR_EXISTENCE, ATOM_key, Key);\n\n  DEBUG(9, Sdprintf(\"key = %p, name = %s\\n\", key, name));\n  if ( RegQueryValueExW(key, name, NULL, &type, data.bytes, &len)\n\t\t\t\t\t\t\t== ERROR_SUCCESS )\n  { RegCloseKey(key);\n\n    switch(type)\n    { case REG_SZ:\n\treturn PL_unify_wchars(Value, PL_ATOM,\n\t\t\t       len/sizeof(wchar_t)-1, data.wchars);\n      case REG_DWORD:\n\treturn PL_unify_integer(Value, data.dword);\n      default:\n\twarning(\"get_registry_value/2: Unknown registery-type: %d\", type);\n        fail;\n    }\n  }\n\n  return FALSE;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nGet the local, global,  trail  and   argument-stack  defaults  from  the\nregistry.  They  can  be  on  the   HKEY_CURRENT_USER  as  well  as  the\nHKEY_LOCAL_MACHINE  registries  to  allow   for    both   user-only  and\nsystem-wide settings.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic struct regdef\n{ const char *name;\n  size_t     *address;\n} const regdefs[] =\n{ { \"stackLimit\",   &GD->defaults.stack_limit },\n  { \"tableSpace\",   &GD->defaults.table_space },\n  { NULL,           NULL }\n};\n\n\nstatic void\nsetStacksFromKey(HKEY key)\n{ DWORD type;\n  union\n  { BYTE bytes[128];\n    DWORD dword;\n  } data;\n  DWORD len = sizeof(data);\n  const struct regdef *rd;\n\n  for(rd = regdefs; rd->name; rd++)\n  { if ( RegQueryValueEx(key, rd->name, NULL, &type, data.bytes, &len) ==\n\t\t\t\t\t\t\tERROR_SUCCESS &&\n\t type == REG_DWORD )\n    { DWORD v = data.dword;\n\n      *rd->address = (size_t)v;\n    }\n  }\n}\n\n\nvoid\ngetDefaultsFromRegistry(void)\n{ HKEY key;\n\n  if ( (key = reg_open_key(L\"HKEY_LOCAL_MACHINE/Software/SWI/Prolog\", FALSE)) )\n  { setStacksFromKey(key);\n    RegCloseKey(key);\n  }\n  if ( (key = reg_open_key(L\"HKEY_CURRENT_USER/Software/SWI/Prolog\", FALSE)) )\n  { setStacksFromKey(key);\n    RegCloseKey(key);\n  }\n}\n\n\nconst char *\nPL_w32_running_under_wine(void)\n{ static const char * (CDECL *pwine_get_version)(void);\n  HMODULE hntdll = GetModuleHandle(\"ntdll.dll\");\n\n  if ( !hntdll )\n  { return NULL;\n  }\n\n  if ( (pwine_get_version = (void *)GetProcAddress(hntdll, \"wine_get_version\")) )\n    return pwine_get_version();\n\n  return NULL;\n}\n\n\n\t\t /*******************************\n\t\t *      PUBLISH PREDICATES\t*\n\t\t *******************************/\n\nBeginPredDefs(win)\n  PRED_DEF(\"win_shell\", 2, win_shell2, 0)\n  PRED_DEF(\"win_shell\", 3, win_shell3, 0)\n  PRED_DEF(\"win_registry_get_value\", 3, win_registry_get_value, 0)\n  PRED_DEF(\"win_folder\", 2, win_folder, PL_FA_NONDETERMINISTIC)\n  PRED_DEF(\"win_add_dll_directory\", 2, win_add_dll_directory, 0)\n  PRED_DEF(\"win_remove_dll_directory\", 1, win_remove_dll_directory, 0)\nEndPredDefs\n\n#endif /*__WINDOWS__*/\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/pl-global.h": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1997-2017, University of Amsterdam\n                              VU University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef PL_GLOBAL_H_INCLUDED\n#define PL_GLOBAL_H_INCLUDED\n#include \"pl-trie.h\"\n\n#ifndef GLOBAL\t\t\t/* global variables */\n#define GLOBAL extern\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThis module packs SWI-Prolog global data-structures into two structures.\nThe structure PL_global_data contains all global data that is related to\nthe state of the system as a  whole, and PL_local_data contains all data\nthat is related to a Prolog thread.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\t\t /*******************************\n\t\t *\t     CODE DATA\t\t*\n\t\t *******************************/\n\ntypedef struct\n{\n#if VMCODE_IS_ADDRESS\n  unsigned char   *_dewam_table;\t/* decoding table */\n  intptr_t\t  _dewam_table_offset;\t/* offset of 1st */\n  void  **_interpreter_jmp_table;\t/* interpreters table */\n\t\t\t\t\t/* must be last! (why?) */\n  code    _wam_table[I_HIGHEST];\t/* code --> address */\n#else\n  int\t  struct_may_not_be_empty;\t/* empty structure is illegal */\n#endif\n  struct\t\t\t\t/* see initSupervisors() */\n  { code exit[3];\t\t\t/* I_EXIT */\n    code next_clause[3];\t\t/* S_NEXTCLAUSE */\n    code virgin[3];\t\t\t/* S_VIRGIN */\n    code undef[3];\t\t\t/* S_UNDEF */\n    code dynamic[3];\t\t\t/* S_DYNAMIC */\n    code thread_local[3];\t\t/* S_THREAD_LOCAL */\n    code multifile[3];\t\t\t/* S_MULTIFILE */\n    code staticp[3];\t\t\t/* S_STATIC */\n  } supervisors;\n} PL_code_data_t;\n\ntypedef struct\n{ atom_t\tfile;\t\t\t/* current source file */\n  IOPOS\t\tposition;\t\t/* Line, line pos, char and byte */\n} source_location;\n\n\t\t /*******************************\n\t\t *\t    GLOBAL DATA\t\t*\n\t\t *******************************/\n\nstruct PL_global_data\n{ uintptr_t\theap_base;\t\t/* heap-base rounded downwards */\n  pl_defaults_t\tdefaults;\t\t/* system default settings */\n  pl_options_t\toptions;\t\t/* command-line options */\n  State\t\tstateList;\t\t/* list of loaded states */\n  int\t\tinitialised;\t\t/* Heap is initialised */\n  int\t\tio_initialised;\t\t/* I/O system has been initialised */\n  cleanup_status cleaning;\t\t/* Inside PL_cleanup() */\n  int\t\thalt_cancelled;\t\t/* Times halt was cancelled */\n  int\t\tbootsession;\t\t/* -b boot compilation */\n  int\t\tdebug_level;\t\t/* Maintenance debugging: 0..9 */\n  struct bit_vector *debug_topics;\t/* debug topics enabled */\n\n  struct\n  { void *\tDB;\t\t\t/* program resource database */\n    atom_t\thandle;\t\t\t/* Symbol for DB */\n  } resources;\n\n  struct\n  { sig_handler handlers[MAXSIGNAL];\t/* How Prolog preceives signals */\n#ifdef HAVE_SIGNAL\n    int\t\tsig_alert;\t\t/* our alert signal */\n#endif\n  } signals;\n#ifdef O_LOGICAL_UPDATE\n  volatile ggen_t _generation;\t\t/* generation of the database */\n#ifdef ATOMIC_GENERATION_HACK\n  volatile gen_t _last_generation;\t/* see pl-inline.h, global_generation() */\n#endif\n#endif\n\n  struct\n  { int\t\tos_argc;\t\t/* main(int argc, char **argv) */\n    char **\tos_argv;\n    int\t\tappl_argc;\t\t/* Application options */\n    char **\tappl_argv;\n    int\t\tnotty;\t\t\t/* -tty: donot use ioctl() */\n    int\t\toptimise;\t\t/* -O: optimised compilation */\n  } cmdline;\n\n  struct\n  { char *\tCWDdir;\n    size_t\tCWDlen;\n    char *\texecutable;\t\t/* Running executable */\n#ifdef __WINDOWS__\n    char *\tmodule;\t\t\t/* argv[0] module passed */\n#endif\n  } paths;\n\n  struct\n  { size_t\tatoms;\t\t\t/* No. of atoms defined */\n    size_t\tatom_string_space;\t/* # bytes used to store atoms */\n    size_t\tatom_string_space_freed;/* # bytes in freed atoms */\n    size_t\tstack_space;\t\t/* # bytes on stacks */\n    int\t\tfunctors;\t\t/* No. of functors defined */\n    int\t\tpredicates;\t\t/* No. of predicates defined */\n    int\t\tmodules;\t\t/* No. of modules in the system */\n    size_t\tclauses;\t\t/* No. clauses */\n    size_t\tcodes;\t\t\t/* No. of VM codes generated */\n    double\tuser_cputime;\t\t/* User CPU time (whole process) */\n    double\tsystem_cputime;\t\t/* Kernel CPU time (whole process) */\n    struct\n    { int\tcreated;\t\t/* # created hash tables */\n      int\tdestroyed;\t\t/* # destroyed hash tables */\n    } indexes;\n#ifdef O_PLMT\n    int\t\tthreads_created;\t/* # threads created */\n    int\t\tthreads_finished;\t/* # finished threads */\n    int\t\tengines_created;\t/* # engines created */\n    int\t\tengines_finished;\t/* # engines threads */\n    double\tthread_cputime;\t\t/* Total CPU time of threads */\n#endif\n  } statistics;\n\n#ifdef O_PROFILE\n  struct\n  { struct PL_local_data *thread;\t/* Thread being profiled */\n  } profile;\n#endif\n\n  struct\n  { Module\tuser;\t\t\t/* user module */\n    Module\tsystem;\t\t\t/* system predicate module */\n  } modules;\n\n  struct\n  { Table\tmodules;\t\t/* atom --> module */\n  } tables;\n\n  struct\n  { Table\trecord_lists;\t\t/* Available record lists */\n  } recorded_db;\n\n  struct\n  { ArithF     *functions;\t\t/* index --> function */\n    size_t\tfunctions_allocated;\t/* Size of above array */\n  } arith;\n\n  struct\n  { size_t\thighest;\t\t/* Highest atom index */\n    atom_array\tarray;\n    AtomTable\ttable;\t\t\t/* hash-table */\n    Atom\tbuiltin_array;\t\t/* Builtin atoms */\n    int\t\tlookups;\t\t/* # atom lookups */\n    int\t\tcmps;\t\t\t/* # string compares for lookup */\n    int\t\tinitialised;\t\t/* atoms have been initialised */\n#ifdef O_ATOMGC\n    int\t\tgc;\t\t\t/* # atom garbage collections */\n    int\t\tgc_active;\t\t/* Atom-GC is in progress */\n    int\t\trehashing;\t\t/* Atom-rehash in progress */\n    size_t\tbuiltin;\t\t/* Locked atoms (atom-gc) */\n    size_t\tno_hole_before;\t\t/* You won't find a hole before here */\n    size_t\tmargin;\t\t\t/* # atoms to grow before collect */\n    size_t\tnon_garbage;\t\t/* # atoms for after last AGC */\n    int64_t\tcollected;\t\t/* # collected atoms */\n    size_t\tunregistered;\t\t/* # candidate GC atoms */\n    double\tgc_time;\t\t/* Time spent on atom-gc */\n    PL_agc_hook_t gc_hook;\t\t/* Current hook */\n#endif\n    atom_t     *for_code[256];\t\t/* code --> one-char-atom */\n    PL_blob_t  *types;\t\t\t/* registered atom types */\n  } atoms;\n\n  struct\n  { Table\tbreakpoints;\t\t/* Breakpoint table */\n  } comp;\n\n  struct\n  { ExtensionCell _ext_head;\t\t/* head of registered extensions */\n    ExtensionCell _ext_tail;\t\t/* tail of this chain */\n\n    InitialiseHandle initialise_head;\t/* PL_initialise_hook() */\n    InitialiseHandle initialise_tail;\n    PL_dispatch_hook_t dispatch_events; /* PL_dispatch_hook() */\n\n    int\t\t  _loaded;\t\t/* system extensions are loaded */\n  } foreign;\n\n#ifdef O_GMP\n  struct\n  { int initialised;\t\t\t/* is GMP initialised? */\n    int keep_alloc_functions;\t\t/* do not change allocation */\n  } gmp;\n#endif\n\n  struct\t\t\t\t/* pl-format.c */\n  { Table\tpredicates;\n  } format;\n\n  struct\n  { Table\ttable;\t\t\t/* flag key --> flag */\n  } flags;\n\n  struct\n  { Table\ttable;\t\t\t/* global (read-only) features */\n  } prolog_flag;\n\n  struct\n  { size_t\thighest;\t\t/* Next index to handout */\n    functor_array array;\t\t/* index --> functor */\n    FunctorTable table;\t\t\t/* hash-table */\n    int\t\t rehashing;\t\t/* Table is being rehashed */\n  } functors;\n\n  struct\n  { Code\tcatch_exit_address;\t/* See findCatchExit() */\n  } exceptions;\n\n  struct\n  { Table\t\ttmp_files;\t/* Known temporary files */\n    CanonicalDir\t_canonical_dirlist;\n    char *\t\tmyhome;\t\t/* expansion of ~ */\n    char *\t\tfred;\t\t/* last expanded ~user */\n    char *\t\tfredshome;\t/* home of fred */\n    OnHalt\t\ton_halt_list;\t/* list of onhalt hooks */\n    OnHalt\t\texit_hooks;\t/* how to exit from PL_halt() */\n    int\t\t\thalting;\t/* process is shutting down */\n    int\t\t\tgui_app;\t/* Win32: Application is a gui app */\n    IOFUNCTIONS\t\tiofunctions;\t/* initial IO functions */\n    IOFUNCTIONS\t\torg_terminal;\t/* IO+Prolog terminal functions */\n  } os;\n\n  struct\n  { Procedure\tdgarbage_collect1;\n    Procedure\tcatch3;\n    Procedure\treset3;\n    Procedure\tdmeta_call1;\t\t/* $meta_call/1 */\n    Procedure\ttrue0;\n    Procedure\tfail0;\n    Procedure\tequals2;\t\t/* =/2 */\n    Procedure\tis2;\t\t\t/* is/2 */\n    Procedure\tstrict_equal2;\t\t/* ==/2 */\n    Procedure\tnot_strict_equal2;\t/* \\==/2 */\n    Procedure\tevent_hook1;\n    Procedure\texception_hook4;\n    Procedure\tprint_message2;\n    Procedure\tforeign_registered2;\t/* $foreign_registered/2 */\n    Procedure\tprolog_trace_interception4;\n    Procedure\tprolog_break_hook6;\t/* prolog:break_hook/6 */\n    Procedure\tportray;\t\t/* portray/1 */\n    Procedure   dcall1;\t\t\t/* $call/1 */\n    Procedure   call3;\t\t\t/* call/3*/\n    Procedure\tsetup_call_catcher_cleanup4; /* setup_call_catcher_cleanup/4 */\n    Procedure\tundefinterc4;\t\t/* $undefined_procedure/4 */\n    Procedure   dthread_init0;\t\t/* $thread_init/0 */\n    Procedure   dc_call_prolog0;\t/* $c_call_prolog/0 */\n    Procedure   dinit_goal3;\t\t/* $init_goal/3 */\n#ifdef O_ATTVAR\n    Procedure\tdwakeup1;\t\t/* system:$wakeup/1 */\n    Procedure\tportray_attvar1;\t/* $attvar:portray_attvar/1 */\n#endif\n    Procedure   comment_hook3;\t\t/* prolog:comment_hook/3 */\n\n    int\t\tstatic_dirty;\t\t/* #static dirty procedures */\n#ifdef O_CLAUSEGC\n    Table\tdirty;\t\t\t/* Table of dirty procedures */\n#endif\n  } procedures;\n\n  struct\n  { ClauseRef\tlingering;\t\t/* Unlinked clause refs */\n    size_t\tlingering_count;\t/* # Unlinked clause refs */\n    int\t\tcgc_active;\t\t/* CGC is running */\n    int64_t\tcgc_count;\t\t/* # clause GC calls */\n    int64_t\tcgc_reclaimed;\t\t/* # clauses reclaimed */\n    double\tcgc_time;\t\t/* Total time spent in CGC */\n    size_t\tdirty;\t\t\t/* # dirty clauses */\n    size_t\terased;\t\t\t/* # erased pending clauses */\n    size_t\terased_size;\t\t/* memory used by them */\n    size_t\terased_size_last;\t/* memory used by them after last CGC */\n    int\t\tcgc_space_factor;\t/* Max total/margin garbage */\n    double\tcgc_stack_factor;\t/* Price to scan stack space */\n    double\tcgc_clause_factor;\t/* Pce to scan clauses */\n  } clauses;\n\n  struct\n  { size_t\thighest;\t\t/* highest source file index */\n    size_t\tno_hole_before;\t\t/* All filled before here */\n    srcfile_array array;\t\t/* index --> file */\n    Table\ttable;\t\t\t/* name  --> file */\n  } files;\n\n#ifdef HAVE_TGETENT\n  struct\n  { int    initialised;\t\t\t/* initialisation status */\n    char  *_string_area;\t\t/* static area for tgetent */\n    char  *_buf_area;\t\t\t/* another one */\n    Table  _capabilities;\t\t/* User-level capability table */\n  } terminal;\n#endif\n\n#ifdef O_PLMT\n  struct\n  { struct _at_exit_goal *exit_goals;\t/* Global thread_at_exit/1 goals */\n    int\t\t\tenabled;\t/* threads are enabled */\n    Table\t\tmutexTable;\t/* Name --> mutex table */\n    int\t\t\tmutex_next_id;\t/* next id for anonymous mutexes */\n#ifdef __WINDOWS__\n    HINSTANCE\t\tinstance;\t/* Win32 process instance */\n#endif\n    counting_mutex     *mutexes;\t/* Registered mutexes */\n    PL_thread_info_t   *free;\t\t/* Free threads */\n    int\t\t\thighest_allocated; /* Highest with info struct */\n    int\t\t\tthread_max;\t/* Size of threads array */\n    PL_thread_info_t  **threads;\t/* Pointers to thread-info */\n    struct\n    { pthread_mutex_t\tmutex;\n      pthread_cond_t\tcond;\n      unsigned int\trequests;\n      unsigned int\tinitialized;\t/* mutex and condvar are initialized */\n    } gc;\n    struct\n    { pthread_mutex_t\tmutex;\n      pthread_cond_t\tcond;\n    } index;\n  } thread;\n#endif /*O_PLMT*/\n\n#ifdef O_LOCALE\n  struct\n  { Table\t\tlocaleTable;\t/* Name --> locale table */\n    PL_locale\t       *default_locale;\t/* System wide default */\n  } locale;\n#endif\n\n  struct stack\t\tcombined_stack; /* ID for combined stack */\n};\n\n\n\t\t /*******************************\n\t\t *\t     LOCAL DATA\t\t*\n\t\t *******************************/\n\n#define LD_MAGIC\t0x3cfd82b4\t/* Valid local-data structure */\n\nstruct PL_local_data\n{ uintptr_t\tmagic;\t\t\t/* LD_MAGIC */\n  LocalFrame    environment;\t\t/* Current local frame */\n  Choice\tchoicepoints;\t\t/* Choice-point chain */\n  FliFrame      foreign_environment;\t/* Current foreign context */\n  QueryFrame    query;\t\t\t/* Currently open query */\n  Word\t\tmark_bar;\t\t/* Mark globals > this one */\n#ifdef O_GVAR\n  Word\t\tfrozen_bar;\t\t/* Frozen part of the global stack */\n#endif\n  Code\t\tfast_condition;\t\t/* Fast condition support */\n  pl_stacks_t   stacks;\t\t\t/* Prolog runtime stacks */\n  uintptr_t\tbases[STG_MASK+1];\t/* area base addresses */\n  int\t\talerted;\t\t/* Special mode. See updateAlerted() */\n  int\t\tslow_unify;\t\t/* do not use inline unification */\n  int\t\tcritical;\t\t/* heap is being modified */\n  int\t\tbreak_level;\t\t/* current break level */\n  Stack\t\toutofstack;\t\t/* thread is out of stack */\n  int\t\ttrim_stack_requested;\t/* perform a trim-stack */\n#ifdef O_PLMT\n  int\t\texit_requested;\t\t/* Thread is asked to exit */\n#endif\n  int\t\tin_arithmetic;\t\t/* doing arithmetic */\n  int\t\tin_print_message;\t/* Inside printMessage() */\n  int\t\tautoload_nesting;\t/* Nesting level in autoloader */\n  gen_t\t\tgen_reload;\t\t/* reload generation */\n  void *\tglob_info;\t\t/* pl-glob.c */\n  IOENC\t\tencoding;\t\t/* default I/O encoding */\n  struct PL_local_data *next_free;\t/* see maybe_free_local_data() */\n\n  struct\n  { int\t\tpending[2];\t\t/* PL_raise() pending signals */\n    int\t\tcurrent;\t\t/* currently processing signal */\n    int\t\tis_sync;\t\t/* current signal is synchronous */\n  } signal;\n\n  struct\n  { int\t\tactive;\t\t\t/* doing pipe I/O */\n    jmp_buf\tcontext;\t\t/* context of longjmp() */\n  } pipe;\n\n  struct\n  { char       *getstr_buffer;\t\t/* getString() buffer */\n    size_t\tgetstr_buffer_size;\t/* size of getstr_buffer */\n    struct wic_state *current_state;\t/* qlf-creation state */\n  } qlf;\n\n  struct\n  { atom_t\tcurrent;\t\t/* current global prompt */\n    atom_t\tfirst;\t\t\t/* how to prompt first line */\n    int\t\tfirst_used;\t\t/* did we do the first line? */\n    int\t\tnext;\t\t\t/* prompt on next read operation */\n  } prompt;\n\n  source_location read_source;\t\t/* file, line, char of last term */\n\n  struct\n  { term_t\tterm;\t\t\t/* exception term */\n    term_t\tbin;\t\t\t/* temporary handle for exception */\n    term_t\tprinted;\t\t/* already printed exception */\n    term_t\ttmp;\t\t\t/* tmp for errors */\n    term_t\tpending;\t\t/* used by the debugger */\n    term_t\tfr_rewritten;\t\t/* processed by exception_hook() */\n    int\t\tin_hook;\t\t/* inside exception_hook() */\n    int\t\tprocessing;\t\t/* processing an exception */\n    exception_frame *throw_environment;\t/* PL_throw() environments */\n  } exception;\n\n#ifdef O_ATTVAR\n  struct\n  { term_t\thead;\t\t\t/* Head of wakeup list */\n    term_t\ttail;\t\t\t/* Tail of this list */\n    term_t\tgc_attvars;\t\t/* place for attvars during GC */\n    Word\tattvars;\t\t/* linked list of all attvars */\n    int\t\tcall_residue_vars_count; /* # call_residue_vars/2 active */\n  } attvar;\n#endif\n\n  struct\n  { term_t\tdummy;\t\t\t/* see trimStacks() */\n  } trim;\n\n  struct\n  { term_t\th[TMP_PTR_SIZE];\t/* temporary handles. See unify_ptrs */\n    int\t\ttop;\t\t\t/* Top-of-stack index */\n  } tmp;\n\n#ifdef O_GVAR\n  struct\n  { Table\tnb_vars;\t\t/* atom --> value */\n    int\t\tgrefs;\t\t\t/* references to global stack */\n  } gvar;\n#endif\n\n  struct\n  { int64_t\tinferences;\t\t/* inferences in this thread */\n    uintptr_t\tlast_cputime;\t\t/* milliseconds last CPU time */\n    uintptr_t\tlast_systime;\t\t/* milliseconds last SYSTEM time */\n    uintptr_t\tlast_real_time;\t\t/* Last Real Time (seconds since Epoch) */\n    double\tstart_time;\t\t/* When Thread was started */\n    double\tlast_walltime;\t\t/* Last Wall time (m-secs since start) */\n    double\tuser_cputime;\t\t/* User saved CPU time */\n    double\tsystem_cputime;\t\t/* Kernel saved CPU time */\n  } statistics;\n\n#ifdef O_GMP\n  struct\n  { int\t\tpersistent;\t\t/* do persistent operations */\n    size_t\tallocated;\t\t/* memory allocated */\n    ar_context *context;\t\t/* current allocation context */\n    mp_mem_header *head;\t\t/* linked list of allocated chunks */\n    mp_mem_header *tail;\n  } gmp;\n#endif\n\n#ifdef O_PROFILE\n  struct\n  { int\t\tactive;\t\t\t/* profiler is on */\n    int\t\taccounting;\t\t/* we are accounting */\n    int\t\tsum_ok;\t\t\t/* siblings are counted */\n    struct call_node *current;\t\t/* `current' node */\n    struct call_node *roots;\t\t/* list of root-nodes */\n    uintptr_t\tsamples;\t\t/* profile samples */\n    uintptr_t\tticks;\t\t\t/* profile ticks total */\n    uintptr_t\taccounting_ticks;\t/* Ticks in profCall() and friends */\n    uintptr_t\tnodes;\t\t\t/* #Recorded nodes */\n    double\ttime_at_last_tick;\t/* Time at last statistics tick */\n    double\ttime_at_start;\t\t/* Time at last start */\n    double\ttime;\t\t\t/* recorded CPU time */\n  } profile;\n#endif /* O_PROFILE */\n\n  struct\n  { Module\ttypein;\t\t\t/* module for type in goals */\n    Module\tsource;\t\t\t/* module we are reading clauses in */\n  } modules;\n\n  struct\n  { intptr_t\tgenerator;\t\t/* See PL_atom_generator() */\n    atom_t\tunregistering;\t\t/* See PL_unregister_atom() */\n  } atoms;\n\n  struct\n  { VarDef *\tvardefs;\t\t/* compiler variable analysis */\n    int\t\tnvardefs;\n    int\t\tfilledVars;\n  } comp;\n\n  struct\n  { Buffer\tbuffered;\t\t/* Buffered events */\n    int\t\tdelay_nesting;\t\t/* How deeply is delay nested? */\n  } event;\n\n  struct\n  { struct\n    { Number\tbase;\n      Number\ttop;\n      Number\tmax;\n    } stack;\n#ifdef O_GMP\n    struct\n    { gmp_randstate_t state;\n      int initialised;\n    } random;\n#endif\n  } arith;\n\n#if O_CYCLIC\n  struct\n  { segstack lstack;\t\t\t/* Stack for cycle-links */\n    segstack vstack;\t\t\t/* Stack for visited marks */\n  } cycle;\n#endif\n\n  struct\n  { struct tbl_component *component;    /* active component */\n    struct trie *variant_table;\t\t/* Variant --> table */\n    trie_allocation_pool node_pool;\t/* Node allocation pool for tries */\n    int\thas_scheduling_component;\t/* A leader was created */\n  } tabling;\n\n  struct\n  {\n#ifdef __BEOS__\n    status_t\tdl_error;\t\t/* dlopen() emulation in pl-beos.c */\n#endif\n    int\t\trand_initialised;\t/* have we initialised random? */\n#ifdef O_DDE\n    unsigned\tdde_instance;\t\t/* Actually DWORD */\n#endif\n  } os;\n\n  struct\n  { Table\t  table;\t\t/* Feature table */\n    pl_features_t mask;\t\t\t/* Masked access to booleans */\n    int\t\t  write_attributes;\t/* how to write attvars? */\n    occurs_check_t occurs_check;\t/* Unify and occurs check */\n    access_level_t access_level;\t/* Current access level */\n  } prolog_flag;\n\n  struct\n  { FindData\tfind;\t\t\t/* /<ports> <goal> in tracer */\n  } trace;\n\n  struct\n  { struct findall_bag *bags;\t\t/* Known bags */\n    struct findall_bag *default_bag;\t/* Bag we keep around */\n#if defined(O_ATOMGC) && defined(O_PLMT)\n    simpleMutex mutex;\t\t\t/* Atom GC scanning synchronization */\n#endif\n  } bags;\n\n  struct\n  { AbortHandle\t_abort_head;\t\t/* PL_abort_hook() */\n    AbortHandle _abort_tail;\n\n    buffer\t_discardable_buffer;\t/* PL_*() character buffers */\n    buffer\t_buffer_ring[BUFFER_RING_SIZE];\n    int\t\t_current_buffer_id;\n\n    int\t\tSP_state;\t\t/* For SICStus interface */\n  } fli;\n\n  struct\t\t\t\t/* Local IO stuff */\n  { IOSTREAM *streams[6];\t\t/* handles for standard streams */\n    st_check stream_type_check;\t\t/* Check bin/text streams? */\n\t\t\t\t\t/* do not copy from parent */\n    struct input_context *input_stack;\t/* maintain input stream info */\n    struct output_context *output_stack; /* maintain output stream info */\n    int\tportray_nesting;\t\t/* depth of portray nesting */\n  } IO;\n\n  struct\n  { fid_t\tnumbervars_frame;\t/* Numbervars choice-point */\n  } var_names;\n\n#ifdef O_LIMIT_DEPTH\n  struct\n  { uintptr_t limit;\n    uintptr_t reached;\n  } depth_info;\n#endif\n\n#ifdef O_INFERENCE_LIMIT\n  struct\n  { int64_t limit;\t\t\t/* Raise at this count */\n  } inference_limit;\n#endif\n\n  definition_refs predicate_references;\t/* Referenced predicates */\n\n  pl_shift_status_t shift_status;\t/* Stack shifter status */\n  pl_debugstatus_t _debugstatus;\t/* status of the debugger */\n  struct btrace *btrace_store;\t\t/* C-backtraces */\n\n#ifdef O_PLMT\n  struct\n  { intptr_t   magic;\t\t\t/* PL_THREAD_MAGIC (checking) */\n    struct _PL_thread_info_t *info;\t/* info structure */\n\t\t\t\t\t/* Communication */\n    message_queue messages;\t\t/* Message queue */\n    struct _thread_sig   *sig_head;\t/* Head of signal queue */\n    struct _thread_sig   *sig_tail;\t/* Tail of signal queue */\n    struct _at_exit_goal *exit_goals;\t/* thread_at_exit/1 goals */\n    DefinitionChain local_definitions;\t/* P_THREAD_LOCAL predicates */\n    simpleMutex scan_lock;\t\t/* Hold for asynchronous scans */\n  } thread;\n#endif\n\n#ifdef O_LOCALE\n  struct\n  { PL_locale *current;\t\t\t/* Current locale */\n  } locale;\n#endif\n\n  struct\n  { size_t\terased_skipped;\t\t/* # erased clauses skipped */\n    int64_t\tcgc_inferences;\t\t/* Inferences at last cgc consider */\n  } clauses;\n\n  struct\n  { intptr_t _total_marked;\t\t/* # marked global cells */\n    intptr_t _trailcells_deleted;\t/* # garbage trailcells */\n    intptr_t _relocation_chains;\t/* # relocation chains (debugging) */\n    intptr_t _relocation_cells;\t\t/* # relocation cells */\n    intptr_t _relocated_cells;\t\t/* # relocated cells */\n    intptr_t _needs_relocation;\t\t/* # cells that need relocation */\n    intptr_t _local_marked;\t\t/* # marked local -> global ptrs */\n    intptr_t _marks_swept;\t\t/* # marks swept */\n    intptr_t _marks_unswept;\t\t/* # marks swept */\n    intptr_t _alien_relocations;\t/* # alien_into_relocation_chain() */\n    intptr_t _local_frames;\t\t/* frame count for debugging */\n    intptr_t _choice_count;\t\t/* choice-point count for debugging */\n    int  *_start_map;\t\t\t/* bitmap with legal global starts */\n    sigset_t saved_sigmask;\t\t/* Saved signal mask */\n    int64_t inferences;\t\t\t/* #inferences at last GC */\n    pl_gc_status_t\tstatus;\t\t/* Garbage collection status */\n#ifdef O_CALL_RESIDUE\n    int\t\t\tmarked_attvars;\t/* do not GC attvars */\n#endif\n    int active;\t\t\t\t/* GC is running in this thread */\n\t\t\t\t\t/* These must be at the end to be */\n\t\t\t\t\t/* able to define O_DEBUG in only */\n\t\t\t\t\t/* some modules */\n#if defined(O_DEBUG) || defined(SECURE_GC)\n    intptr_t _trailtops_marked;\t\t/* # marked trailtops */\n    Word *_mark_base;\t\t\t/* Array of marked cells addresses */\n    Word *_mark_top;\t\t\t/* Top of this array */\n    Table _check_table;\t\t\t/* relocation address table */\n    Table _local_table;\t\t\t/* marked local variables */\n    int  _relocated_check;\t\t/* Verify relocated addresses? */\n    unsigned int incr_seed;\t\t/* Seed for random stack increments */\n#endif\n  } gc;\n};\n\nGLOBAL PL_global_data_t PL_global_data;\nGLOBAL PL_code_data_t\tPL_code_data;\nGLOBAL PL_local_data_t  PL_local_data;\n#ifdef O_MULTIPLE_ENGINES\nGLOBAL PL_local_data_t *PL_current_engine_ptr;\n#endif\n\n#define GD (&PL_global_data)\n#define CD (&PL_code_data)\n\n#define functor_array\t\t(GD->functors.array)\n#define systemDefaults\t\t(GD->defaults)\n\n#define environment_frame\t(LD->environment)\n#define fli_context\t\t(LD->foreign_environment)\n#define source_file_name\t(LD->read_source.file)\n#define source_line_no\t\t(LD->read_source.position.lineno)\n#define source_line_pos\t\t(LD->read_source.position.linepos)\n#define source_char_no\t\t(LD->read_source.position.charno)\n#define source_byte_no\t\t(LD->read_source.position.byteno)\n#define exception_term\t\t(LD->exception.term)\n#define exception_bin\t\t(LD->exception.bin)\n#define exception_printed\t(LD->exception.printed)\n#define gc_status\t\t(LD->gc.status)\n#define debugstatus\t\t(LD->_debugstatus)\n#define depth_limit\t\t(LD->depth_info.limit)\n#define depth_reached\t\t(LD->depth_info.reached)\n#define base_addresses\t\t(LD->bases)\n#define Suser_input\t\t(LD->IO.streams[0])\n#define Suser_output\t\t(LD->IO.streams[1])\n#define Suser_error\t\t(LD->IO.streams[2])\n#define Scurin\t\t\t(LD->IO.streams[3])\n#define Scurout\t\t\t(LD->IO.streams[4])\n#define Sprotocol\t\t(LD->IO.streams[5])\n#define Sdin\t\t\tSuser_input\t\t/* not used for now */\n#define Sdout\t\t\tSuser_error\n\n#ifdef VMCODE_IS_ADDRESS\n#define dewam_table\t\t(CD->_dewam_table)\n#define dewam_table_offset\t(CD->_dewam_table_offset)\n#define wam_table\t\t(CD->_wam_table)\n#define interpreter_jmp_table\t(CD->_interpreter_jmp_table)\n#endif /*VMCODE_IS_ADDRESS*/\n\n#endif /*PL_GLOBAL_H_INCLUDED*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/pl-load.c": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1985-2018, University of Amsterdam\n                              VU University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"pl-incl.h\"\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSWI-Prolog interface for runtime loading of foreign code (plugins).\n\nCurrently, this interface is implemented only  for ELF systems (based on\ndlopen()) and HPUX (based on slh_load()).   Despite, this covers a large\nnumber of modern Unix platforms. To name a few: Solaris, Linux, freeBSD,\nIRIX, HPUX, MacOS X.\n\nFor some platforms we emulate the ELF   interface and set the cpp symbol\nEMULATE_DLOPEN. You find examples in pl-nt.c   (for Win32) and pl-beos.c\n(for BeOS).\n\nBasically, 3 operations are required:\n\n\topen_shared_object(+File, [+Options], -Handle)\n\t    Load a shared object into the current image.\n\n\tcall_shared_object_function(+Handle, +FunctionName)\n\t    Call a named function without arguments.  Return value\n\t    is ignored too.\n\n\tclose_shared_object(+Handle)\n\t    Unload a shared object.\n\nFeel free to add this functionality for your favorite OS and mail me the\ncontributions.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n\t\t /*******************************\n\t\t *     DLOPEN() AND FRIENDS\t*\n\t\t *******************************/\n\n#ifndef EMULATE_DLOPEN\n#ifdef HAVE_DLOPEN\t\t\t/* sysvr4, elf binaries */\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#else /*HAVE_DLOPEN*/\n\n#ifdef HAVE_SHL_LOAD\t\t\t/* HPUX */\n\n#include <dl.h>\n#define dlopen(path, flags) shl_load((path), (flags), 0L)\n#define dlclose(handle)\t    shl_unload((handle))\n#define dlerror()\t    OsError()\n\nvoid *\ndlsym(void *handle, const char *name)\n{ void *value;\n  shl_t h = handle;\n\n  if ( shl_findsym(&h, name, TYPE_PROCEDURE, &value) < 0 )\n    return NULL;\n\n  return value;\n}\n\n#define RTLD_LAZY\tBIND_DEFERRED\n#ifdef BIND_IMMEDIATE\n#define RTLD_NOW\tBIND_IMMEDIATE\n#endif\n\n#endif /*HAVE_SHL_LOAD*/\n#endif /*HAVE_DLOPEN*/\n#endif /*EMULATE_DLOPEN*/\n\n#if defined(HAVE_DLOPEN) || defined(HAVE_SHL_LOAD) || defined(EMULATE_DLOPEN)\n#define HAVE_SHARED_OBJECTS\n\n#ifndef RTLD_GLOBAL\t\t\t/* solaris defines this */\n#define RTLD_GLOBAL 0\n#endif\n#ifndef RTLD_NOW\t\t\t/* implicit on some versions */\n#define RTLD_NOW 0\n#endif\n#ifndef RTLD_LAZY\t\t\t/* freeBSD doesn't have this? */\n#define RTLD_LAZY 0\n#endif\n\ntypedef int (*dl_funcptr)();\n\ntypedef struct dl_entry *DlEntry;\nstruct dl_entry\n{ int\t  id;\t\t\t\t/* Prolog's identifier */\n  void   *dlhandle;\t\t\t/* DL libraries identifier */\n  atom_t  file;\t\t\t\t/* Loaded filed */\n  DlEntry next;\t\t\t\t/* Next in table */\n};\n\nint\tdl_plid;\t\t\t/* next id to give */\nDlEntry dl_head;\t\t\t/* loaded DL's */\nDlEntry dl_tail;\t\t\t/* end of this chain */\n\n#define DL_NOW\t  0x1\n#define DL_GLOBAL 0x2\n\n#ifndef EMULATE_DLOPEN\nvoid *\nPL_dlopen(const char *file, int flags)\n{ return dlopen(file, flags);\n}\n\nconst char *\nPL_dlerror(void)\n{ return dlerror();\n}\n\nvoid *\nPL_dlsym(void *handle, char *symbol)\n{ return dlsym(handle, symbol);\n}\n\nint\nPL_dlclose(void *handle)\n{ return dlclose(handle);\n}\n\n#endif /*EMULATE_DLOPEN*/\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nunder_valgrind()\n\nTrue if we are running under valgrind.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef HAVE_VALGRIND_VALGRIND_H\n#include <valgrind/valgrind.h>\n#else\n#define RUNNING_ON_VALGRIND (getenv(\"VALGRIND_OPTS\") != NULL)\n#endif\n\nstatic int\nunder_valgrind(void)\n{ static int vg = -1;\n\n  if ( vg == -1 )\n  {\n#ifdef RUNNING_ON_VALGRIND\n    if ( RUNNING_ON_VALGRIND )\n      vg = TRUE;\n    else\n#endif\n      vg = FALSE;\n  }\n\n  return vg;\n}\n\n\nstatic\nPRED_IMPL(\"$open_shared_object\", 3, open_shared_object, 0)\n{ PRED_LD\n  void *dlhandle;\n  char *fn;\n  atom_t afile;\n  DlEntry e;\n  int dlflags;\n  int n;\n\n  term_t file     = A1;\n  term_t plhandle = A2;\n  term_t flags    = A3;\n\n\n  if ( PL_get_integer(flags, &n) )\n  { dlflags = (n & DL_NOW) ? RTLD_NOW : RTLD_LAZY;\n    if ( n & DL_GLOBAL )\n      dlflags |= RTLD_GLOBAL;\n  } else\n    dlflags = RTLD_LAZY;\n\n  if ( !PL_get_atom_ex(file, &afile) ||\n       !PL_get_file_name(file, &fn, 0) )\n    fail;\n  if ( !(dlhandle = PL_dlopen(fn, dlflags)) )\n    return PL_error(NULL, 0, NULL, ERR_SHARED_OBJECT_OP,\n\t\t    ATOM_open, PL_dlerror());\n\n  e = allocHeapOrHalt(sizeof(struct dl_entry));\n\n  PL_LOCK(L_FOREIGN);\n  e->id       = ++dl_plid;\n  e->dlhandle = dlhandle;\n  e->file     = afile;\n  e->next     = NULL;\n\n  if ( !dl_tail )\n  { dl_tail = e;\n    dl_head = e;\n  } else\n  { dl_tail->next = e;\n    dl_tail = e;\n  }\n  PL_UNLOCK(L_FOREIGN);\n\n  return PL_unify_integer(plhandle, e->id);\n}\n\n\nstatic DlEntry\nfind_dl_entry(term_t h)\n{ GET_LD\n  DlEntry e;\n  int id;\n\n  if ( PL_get_integer(h, &id) )\n  { for(e = dl_head; e; e = e->next)\n    { if ( e->id == id )\n\treturn e;\n    }\n    PL_error(NULL, 0, NULL, ERR_EXISTENCE, ATOM_shared_object_handle, h);\n    return NULL;\n  }\n\n  PL_error(NULL, 0, NULL, ERR_TYPE, ATOM_shared_object_handle, h);\n\n  return NULL;\n}\n\n\nstatic\nPRED_IMPL(\"close_shared_object\", 1, close_shared_object, 0)\n{ DlEntry e = find_dl_entry(A1);\n\n  if ( e && e->dlhandle)\n  { if ( !under_valgrind() )\n      PL_dlclose(e->dlhandle);\n    e->dlhandle = NULL;\n\n    succeed;\n  }\n\n  fail;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSome systems (notably MacOS X) prefixes symbols with _. In some version\nof this OS, dlsym() adds an _, in others not.  We'll try to work around\nthis junk with a runtime test ...\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic\nPRED_IMPL(\"call_shared_object_function\", 2, call_shared_object_function,\n\t  PL_FA_TRANSPARENT)\n{ DlEntry e = find_dl_entry(A1);\n  char *fname;\n  dl_funcptr ef;\n\n  if ( !e || !e->dlhandle ||\n       !PL_get_chars(A2, &fname, CVT_ALL|CVT_EXCEPTION) )\n    fail;\n\n#ifdef LD_SYMBOL_PREFIX\t\t\t/* first try plain anyway */\n  if ( !(ef = (dl_funcptr) PL_dlsym(e->dlhandle, fname)) )\n  { char symname[MAXSYMBOLLEN+1];\n\n    if ( strlen(fname)+strlen(LD_SYMBOL_PREFIX) > MAXSYMBOLLEN )\n      return PL_error(NULL, 0,\n\t\t      \"Symbol too long\",\n\t\t      ERR_REPRESENTATION,\n\t\t      PL_new_atom(\"symbol\"));\n\n    strcpy(symname, LD_SYMBOL_PREFIX);\n    strcat(symname, fname);\n    ef = (dl_funcptr) dlsym(e->dlhandle, symname);\n  }\n#else\n  ef = (dl_funcptr) PL_dlsym(e->dlhandle, fname);\n#endif\n  if ( ef )\n  { (*ef)();\n    succeed;\n  } else\n    fail;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nUnload all foreign libraries.  As we are doing this at the very end of\nthe cleanup, it should be safe now.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nvoid\ncleanupForeign(void)\n{ DlEntry e, next;\n\n  for(e = dl_head; e; e = next)\n  { next = e->next;\n\n    if ( e->dlhandle )\n    { if ( !under_valgrind() )\n\tPL_dlclose(e->dlhandle);\n    }\n\n    freeHeap(e, sizeof(*e));\n  }\n\n  dl_plid = 0;\n  dl_head = dl_tail = NULL;\n}\n\n#else /*HAVE_DLOPEN*/\n\n/* No-op stub for pl-init.c to call. */\nvoid\ncleanupForeign(void)\n{}\n\nstatic\nPRED_IMPL(\"$open_shared_object\", 3, open_shared_object, 0)\n{ return notImplemented(\"open_shared_object\", 3);\n}\n\n#endif /*HAVE_DLOPEN*/\n\n\t\t /*******************************\n\t\t *      PUBLISH PREDICATES\t*\n\t\t *******************************/\n\nBeginPredDefs(dlopen)\n  PRED_DEF(\"$open_shared_object\", 3, open_shared_object, 0)\n#ifdef HAVE_SHARED_OBJECTS\n  PRED_DEF(\"close_shared_object\", 1, close_shared_object, 0)\n  PRED_DEF(\"call_shared_object_function\", 2, call_shared_object_function,\n\t   PL_FA_TRANSPARENT)\n#endif\nEndPredDefs\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/pl-ext.c": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1985-2017, University of Amsterdam\n                              VU University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*#define O_DEBUG 1*/\t\t\t/* include crash/0 */\n#include \"pl-incl.h\"\n#include \"os/pl-ctype.h\"\n\n#if O_DEBUG\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSee how the system reacts on segmentation faults.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic word\npl_crash()\n{ intptr_t *lp = NULL;\n\n  Sdprintf(\"You asked for it ... Writing to address 0\\n\");\n\n  *lp = 5;\n\n  Sdprintf(\"Oops, this doesn't appear to be a secure OS\\n\");\n\n  fail;\n}\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nLink all foreign language predicates.  The arguments to FRG are:\n\n\tFRG(name, arity, function, flags).\n\nFlags almost always is TRACE_ME.  Additional common flags:\n\n\tP_TRANSPARENT\tPredicate is module transparent\n\tP_NONDET\tPredicate can be resatisfied\n\nDeprecated: the modern interface uses PRED_IMPL()\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define NOTRACE PL_FA_NOTRACE\n#define META    PL_FA_TRANSPARENT\n#define NDET\tPL_FA_NONDETERMINISTIC\n#define VA\tPL_FA_VARARGS\n#define CREF\tPL_FA_CREF\n#define ISO\tPL_FA_ISO\n\n#define FRG(n, a, f, flags) { n, a, f, flags }\n\nstatic const PL_extension foreigns[] = {\n#if O_DEBUG\n  FRG(\"crash\",\t\t\t0, pl_crash,\t\t\t0),\n#endif\n#ifdef __WINDOWS__\n  FRG(\"win_exec\",\t\t2, pl_win_exec,\t\t\t0),\n  FRG(\"win_module_file\",\t2, pl_win_module_file,\t\t0),\n#endif\n\n  FRG(\"halt\",\t\t\t1, pl_halt,\t\t      ISO),\n  FRG(\"getenv\",\t\t\t2, pl_getenv,\t\t\t0),\n  FRG(\"setenv\",\t\t\t2, pl_setenv,\t\t\t0),\n  FRG(\"unsetenv\",\t\t1, pl_unsetenv,\t\t\t0),\n  FRG(\"sub_atom\",\t\t5, pl_sub_atom,\t\t NDET|ISO),\n  FRG(\"sleep\",\t\t\t1, pl_sleep,\t\t\t0),\n  FRG(\"break\",\t\t\t0, pl_break,\t\t\t0),\n\n  FRG(\"write_canonical\",\t1, pl_write_canonical,\t      ISO),\n  FRG(\"write_term\",\t\t2, pl_write_term,\t META|ISO),\n  FRG(\"write_term\",\t\t3, pl_write_term3,\t META|ISO),\n  FRG(\"write\",\t\t\t1, pl_write,\t\t      ISO),\n  FRG(\"writeq\",\t\t\t1, pl_writeq,\t\t      ISO),\n  FRG(\"writeln\",\t\t1, pl_writeln,\t\t        0),\n  FRG(\"print\",\t\t\t1, pl_print,\t\t\t0),\n\n  FRG(\"read\",\t\t\t1, pl_read,\t\t      ISO),\n  FRG(\"$raw_read\",\t\t1, pl_raw_read,\t\t\t0),\n  FRG(\"$raw_read\",\t\t2, pl_raw_read2,\t\t0),\n  FRG(\"current_functor\",\t2, pl_current_functor,\t     NDET),\n  FRG(\"char_conversion\",\t2, pl_char_conversion,\t      ISO),\n  FRG(\"current_char_conversion\",2, pl_current_char_conversion, NDET|ISO),\n\n  FRG(\"!\",\t\t\t0, pl_metacut,\t\t      ISO),\n\n  FRG(\"abolish\",\t\t1, pl_abolish1,\t\t     META|ISO),\n  FRG(\"abolish\",\t\t2, pl_abolish,\t\t     META),\n  FRG(\"nth_clause\",\t\t3, pl_nth_clause,       NDET|META|CREF),\n  FRG(\"retractall\",\t\t1, pl_retractall,\t META|ISO),\n#ifdef O_MAINTENANCE\n  FRG(\"$list_generations\",\t1, pl_list_generations,\t     META),\n  FRG(\"$check_procedure\",\t1, pl_check_procedure,\t     META),\n#endif\n\n  FRG(\"$c_current_predicate\",\t2, pl_current_predicate,  NDET|META),\n  FRG(\"current_predicate\",\t1, pl_current_predicate1, NDET|META|ISO),\n  FRG(\"$set_predicate_attribute\", 3, pl_set_predicate_attribute,META),\n  FRG(\"$get_predicate_attribute\", 3, pl_get_predicate_attribute,META),\n  FRG(\"$require\",\t\t1, pl_require,\t\t     META),\n  FRG(\"$default_predicate\",\t2, pl_default_predicate,     META),\n\n  FRG(\"repeat\",\t\t\t0, pl_repeat,\t\t NDET|ISO),\n  FRG(\"fail\",\t\t\t0, pl_fail,\t\t      ISO),\n  FRG(\"true\",\t\t\t0, pl_true,\t\t      ISO),\n  FRG(\"$fail\",\t\t\t0, pl_fail,\t\t  NOTRACE),\n\n  FRG(\"trace\",\t\t\t0, pl_trace,\t\t  NOTRACE),\n  FRG(\"notrace\",\t\t0, pl_notrace,\t\t  NOTRACE),\n  FRG(\"tracing\",\t\t0, pl_tracing,\t\t  NOTRACE),\n  FRG(\"$spy\",\t\t\t1, pl_spy,\t\t     META),\n  FRG(\"$nospy\",\t\t\t1, pl_nospy,\t\t     META),\n  FRG(\"$leash\",\t\t\t2, pl_leash,\t\t  NOTRACE),\n  FRG(\"$visible\",\t\t2, pl_visible,\t\t  NOTRACE),\n  FRG(\"$debuglevel\",\t\t2, pl_debuglevel,\t\t0),\n\n#if COUNTING\n  FRG(\"$count\",\t\t\t0, pl_count,\t\t\t0),\n#endif /* COUNTING */\n\n  FRG(\"prolog_current_frame\",\t1, pl_prolog_current_frame,\t0),\n\n  FRG(\"dwim_match\",\t\t3, pl_dwim_match,\t\t0),\n  FRG(\"$dwim_predicate\",\t2, pl_dwim_predicate,\t     NDET),\n\n#ifdef O_PROLOG_HOOK\n  FRG(\"set_prolog_hook\",\t3, pl_set_prolog_hook,\t        0),\n#endif\n  FRG(\"context_module\",\t\t1, pl_context_module,\t     META),\n\n#if O_STRING\n  FRG(\"sub_string\",\t\t5, pl_sub_string,\t     NDET),\n#endif /* O_STRING */\n\n  FRG(\"format\",\t\t\t2, pl_format,\t\t     META),\n#ifdef O_DEBUG\n  FRG(\"$check_definition\",\t1, pl_check_definition,      META),\n#endif\n\n  FRG(\"$atom_hashstat\",\t\t2, pl_atom_hashstat,\t\t0),\n  FRG(\"$current_prolog_flag\",\t5, pl_prolog_flag5,\t     NDET),\n  FRG(\"current_prolog_flag\",\t2, pl_prolog_flag,\t NDET|ISO),\n  FRG(\"$garbage_collect\",\t1, pl_garbage_collect,\t\t0),\n#ifdef O_ATOMGC\n  FRG(\"garbage_collect_atoms\",\t0, pl_garbage_collect_atoms,\t0),\n  FRG(\"garbage_collect_clauses\", 0, pl_garbage_collect_clauses,\t0),\n#ifdef O_DEBUG_ATOMGC\n  FRG(\"track_atom\",\t\t2, pl_track_atom,\t\t0),\n#endif\n#endif\n  FRG(\"current_flag\",\t\t1, pl_current_flag,\t     NDET),\n\n  FRG(\"read\",\t\t\t2, pl_read2,\t\t      ISO),\n  FRG(\"write\",\t\t\t2, pl_write2,\t\t      ISO),\n  FRG(\"writeln\",\t\t2, pl_writeln2,\t\t        0),\n  FRG(\"writeq\",\t\t\t2, pl_writeq2,\t\t      ISO),\n  FRG(\"print\",\t\t\t2, pl_print2,\t\t\t0),\n  FRG(\"write_canonical\",\t2, pl_write_canonical2,\t      ISO),\n  FRG(\"format\",\t\t\t3, pl_format3,\t\t     META),\n\n  FRG(\"format_predicate\",\t2, pl_format_predicate,\t     META),\n  FRG(\"current_format_predicate\", 2, pl_current_format_predicate,\n\t\t\t\t\t\t        META|NDET),\n  FRG(\"get_time\",\t\t1, pl_get_time,\t\t\t0),\n\n#ifdef O_PLMT\n  FRG(\"thread_create\",\t\t3, pl_thread_create,\t META|ISO),\n  FRG(\"thread_exit\",\t\t1, pl_thread_exit,\t\t0),\n  FRG(\"thread_signal\",\t\t2, pl_thread_signal,\t META|ISO),\n  FRG(\"thread_at_exit\",\t\t1, pl_thread_at_exit,\t     META),\n  FRG(\"open_xterm\",\t\t5, pl_open_xterm,\t\t0),\n#endif\n\n  FRG(\"thread_self\",\t\t1, pl_thread_self,\t      ISO),\n  FRG(\"with_mutex\",\t\t2, pl_with_mutex,\t META|ISO),\n  FRG(\"$get_pid\",\t\t1, pl_get_pid,\t\t\t0),\n\n  /* DO NOT ADD ENTRIES BELOW THIS ONE */\n  FRG((char *)NULL,\t\t0, (Func)NULL,\t\t\t0)\n};\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThe extensions chain is used   to allow calling PL_register_extensions()\n*before* PL_initialise() to get foreign   extensions in embedded systems\ndefined before the state is loaded, so executing directives in the state\ncan use foreign extensions.\n\nIf an extension is registered before the  system extension is loaded, it\nwill be added to the chain. Right  after the system registers the system\npredicates, the extensions will be registered.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstruct extension_cell\n{ PL_extension *extensions;\n  char *module;\n  ExtensionCell next;\n};\n\n#define ext_head\t\t(GD->foreign._ext_head)\n#define ext_tail\t\t(GD->foreign._ext_tail)\n#define extensions_loaded\t(GD->foreign._loaded)\n\nstatic char *\ndupStr(const char *str)\n{ if (str)\n  { size_t len = strlen(str)+1;\n    char *m = PL_malloc(len);\n    memcpy(m, str, len);\n    return m;\n  }\n  return NULL;\n}\n\n\nstatic PL_extension *\ndupExtensions(const PL_extension *e)\n{ int i;\n  PL_extension *dup, *o;\n  int len = 0;\n\n  while(e[len++].predicate_name)\n    ;\n  o = dup = PL_malloc(len*sizeof(*e));\n\n  for ( i=0; i<len; i++, o++, e++)\n  { o->predicate_name = dupStr(e->predicate_name);\n    o->arity = e->arity;\n    o->function = e->function;\n    o->flags = e->flags;\n  }\n\n  return dup;\n}\n\n\nvoid\nrememberExtensions(const char *module, const PL_extension *e)\n{ ExtensionCell cell = PL_malloc(sizeof *cell);\n\n  cell->extensions = dupExtensions(e);\n  cell->next = NULL;\n  cell->module = dupStr(module);\n\n  if ( ext_tail )\n  { ext_tail->next = cell;\n    ext_tail = cell;\n  } else\n  { ext_head = ext_tail = cell;\n  }\n}\n\n\nvoid\ncleanupExtensions(void)\n{ ExtensionCell c, next;\n\n  for(c=ext_head; c; c=next)\n  { next = c->next;\n    if (c->module)\n      PL_free(c->module);\n\n    if (c->extensions)\n    { PL_extension *e = c->extensions;\n\n      for(;e->predicate_name; e++)\n\tPL_free((void *)e->predicate_name);\n\n      PL_free(c->extensions);\n    }\n\n    PL_free(c);\n  }\n\n  ext_head = ext_tail = NULL;\n}\n\n\n\nstatic void\nregisterBuiltins(const PL_extension *f)\n{ Module m = MODULE_system;\n\n  for(; f->predicate_name; f++)\n  { Procedure proc;\n    atom_t name\t= PL_new_atom(f->predicate_name);\n    functor_t fdef = lookupFunctorDef(name, f->arity);\n\n    PL_unregister_atom(name);\n    if ( (proc = lookupProcedure(fdef, m)) )\n    { Definition def = proc->definition;\n      set(def, P_FOREIGN|HIDE_CHILDS|P_LOCKED);\n\n      if ( f->flags & PL_FA_NOTRACE )\t       clear(def, TRACE_ME);\n      if ( f->flags & PL_FA_TRANSPARENT )      set(def, P_TRANSPARENT);\n      if ( f->flags & PL_FA_NONDETERMINISTIC ) set(def, P_NONDET);\n      if ( f->flags & PL_FA_VARARGS )\t       set(def, P_VARARG);\n      if ( f->flags & PL_FA_CREF )\t       set(def, P_FOREIGN_CREF);\n      if ( f->flags & PL_FA_ISO )\t       set(def, P_ISO);\n\n      def->impl.foreign.function = f->function;\n      createForeignSupervisor(def, f->function);\n    } else\n    { assert(0);\n    }\n  }\n}\n\n\n#define DECL_PLIST(id) \\\n\textern const PL_extension PL_predicates_from_ ## id[]\n#define REG_PLIST(id) \\\n\tregisterBuiltins(PL_predicates_from_ ## id)\n\nDECL_PLIST(alloc);\nDECL_PLIST(atom);\nDECL_PLIST(arith);\nDECL_PLIST(bag);\nDECL_PLIST(comp);\nDECL_PLIST(flag);\nDECL_PLIST(index);\nDECL_PLIST(list);\nDECL_PLIST(module);\nDECL_PLIST(prims);\nDECL_PLIST(strings);\nDECL_PLIST(variant);\nDECL_PLIST(copyterm);\nDECL_PLIST(prologflag);\nDECL_PLIST(trace);\nDECL_PLIST(pro);\nDECL_PLIST(read);\nDECL_PLIST(thread);\nDECL_PLIST(profile);\nDECL_PLIST(wic);\nDECL_PLIST(attvar);\nDECL_PLIST(gvar);\nDECL_PLIST(win);\nDECL_PLIST(file);\nDECL_PLIST(files);\nDECL_PLIST(glob);\nDECL_PLIST(btree);\nDECL_PLIST(ctype);\nDECL_PLIST(tai);\nDECL_PLIST(setup);\nDECL_PLIST(gc);\nDECL_PLIST(proc);\nDECL_PLIST(srcfile);\nDECL_PLIST(write);\nDECL_PLIST(dlopen);\nDECL_PLIST(system);\nDECL_PLIST(op);\nDECL_PLIST(rec);\nDECL_PLIST(termhash);\nDECL_PLIST(dde);\nDECL_PLIST(term);\nDECL_PLIST(debug);\nDECL_PLIST(locale);\nDECL_PLIST(dict);\nDECL_PLIST(cont);\nDECL_PLIST(trie);\nDECL_PLIST(tabling);\nDECL_PLIST(mutex);\nDECL_PLIST(zip);\nDECL_PLIST(cbtrace);\n\nvoid\ninitBuildIns(void)\n{ ExtensionCell ecell;\n  Module m = MODULE_system;\n\n  GD->procedures.dirty = newHTable(32);\n\n  registerBuiltins(foreigns);\n  REG_PLIST(alloc);\n  REG_PLIST(atom);\n  REG_PLIST(arith);\n  REG_PLIST(bag);\n  REG_PLIST(comp);\n  REG_PLIST(flag);\n  REG_PLIST(index);\n  REG_PLIST(list);\n  REG_PLIST(module);\n  REG_PLIST(prims);\n  REG_PLIST(strings);\n  REG_PLIST(variant);\n  REG_PLIST(copyterm);\n  REG_PLIST(prologflag);\n  REG_PLIST(trace);\n  REG_PLIST(pro);\n  REG_PLIST(read);\n  REG_PLIST(thread);\n  REG_PLIST(profile);\n  REG_PLIST(wic);\n  REG_PLIST(file);\n  REG_PLIST(files);\n  REG_PLIST(glob);\n  REG_PLIST(btree);\n  REG_PLIST(ctype);\n  REG_PLIST(tai);\n  REG_PLIST(setup);\n  REG_PLIST(gc);\n  REG_PLIST(proc);\n  REG_PLIST(srcfile);\n  REG_PLIST(write);\n  REG_PLIST(dlopen);\n  REG_PLIST(system);\n  REG_PLIST(op);\n  REG_PLIST(rec);\n  REG_PLIST(term);\n  REG_PLIST(termhash);\n#ifdef O_ATTVAR\n  REG_PLIST(attvar);\n#endif\n#ifdef O_GVAR\n  REG_PLIST(gvar);\n#endif\n#ifdef __WINDOWS__\n  REG_PLIST(win);\n  REG_PLIST(dde);\n#endif\n#ifdef O_LOCALE\n  REG_PLIST(locale);\n#endif\n  REG_PLIST(debug);\n  REG_PLIST(dict);\n  REG_PLIST(cont);\n  REG_PLIST(trie);\n  REG_PLIST(tabling);\n  REG_PLIST(mutex);\n  REG_PLIST(zip);\n  REG_PLIST(cbtrace);\n\n#define LOOKUPPROC(name) \\\n\t{ GD->procedures.name = lookupProcedure(FUNCTOR_ ## name, m); \\\n\t  DEBUG(CHK_SECURE, assert(GD->procedures.name)); \\\n\t}\n\n  LOOKUPPROC(dgarbage_collect1);\n  LOOKUPPROC(catch3);\n  LOOKUPPROC(reset3);\n  LOOKUPPROC(dmeta_call1);\n  LOOKUPPROC(true0);\n  LOOKUPPROC(fail0);\n  LOOKUPPROC(equals2);\n  LOOKUPPROC(is2);\n  LOOKUPPROC(strict_equal2);\n  LOOKUPPROC(not_strict_equal2);\n  LOOKUPPROC(print_message2);\n  LOOKUPPROC(dcall1);\n  LOOKUPPROC(setup_call_catcher_cleanup4);\n  LOOKUPPROC(dthread_init0);\n  LOOKUPPROC(dc_call_prolog0);\n  LOOKUPPROC(dinit_goal3);\n#ifdef O_ATTVAR\n  LOOKUPPROC(dwakeup1);\n#endif\n#if O_DEBUGGER\n  PROCEDURE_event_hook1 =\n\tPL_predicate(\"prolog_event_hook\", 1, \"user\");\n#endif\n  PROCEDURE_exception_hook4  =\n\tPL_predicate(\"prolog_exception_hook\", 4, \"user\");\n\t\t\t\t\t/* allow debugging in call/1 */\n  clear(PROCEDURE_dcall1->definition, HIDE_CHILDS|TRACE_ME);\n  set(PROCEDURE_dcall1->definition, P_DYNAMIC|P_LOCKED);\n\n  PL_meta_predicate(PL_predicate(\"assert\",           1, \"system\"), \":\");\n  PL_meta_predicate(PL_predicate(\"asserta\",          1, \"system\"), \":\");\n  PL_meta_predicate(PL_predicate(\"assertz\",          1, \"system\"), \":\");\n  PL_meta_predicate(PL_predicate(\"assert\",           2, \"system\"), \":-\");\n  PL_meta_predicate(PL_predicate(\"asserta\",          2, \"system\"), \":-\");\n  PL_meta_predicate(PL_predicate(\"assertz\",          2, \"system\"), \":-\");\n  PL_meta_predicate(PL_predicate(\"retract\",          1, \"system\"), \":\");\n  PL_meta_predicate(PL_predicate(\"retractall\",       1, \"system\"), \":\");\n  PL_meta_predicate(PL_predicate(\"clause\",           2, \"system\"), \":?\");\n\n  PL_meta_predicate(PL_predicate(\"format\",           2, \"system\"), \"+:\");\n  PL_meta_predicate(PL_predicate(\"format\",           3, \"system\"), \"++:\");\n  PL_meta_predicate(PL_predicate(\"format_predicate\", 2, \"system\"), \"+0\");\n\n  PL_meta_predicate(PL_predicate(\"notrace\",          1, \"system\"), \"0\");\n  PL_meta_predicate(PL_predicate(\"with_mutex\",       2, \"system\"), \"+0\");\n  PL_meta_predicate(PL_predicate(\"with_output_to\",   2, \"system\"), \"+0\");\n#ifdef O_PLMT\n  PL_meta_predicate(PL_predicate(\"thread_create\",    3, \"system\"), \"0?+\");\n  PL_meta_predicate(PL_predicate(\"thread_at_exit\",   1, \"system\"), \"0\");\n  PL_meta_predicate(PL_predicate(\"thread_signal\",    2, \"system\"), \"+0\");\n#endif\n  PL_meta_predicate(PL_predicate(\"prolog_frame_attribute\", 3, \"system\"), \"++:\");\n  PL_meta_predicate(PL_predicate(\"compile_predicates\", 1, \"system\"), \":\");\n  PL_meta_predicate(PL_predicate(\"op\",\t\t     3, \"system\"), \"++:\");\n  PL_meta_predicate(PL_predicate(\"current_op\",\t     3, \"system\"), \"++:\");\n\n  for( ecell = ext_head; ecell; ecell = ecell->next )\n    bindExtensions(ecell->module, ecell->extensions);\n\n  extensions_loaded = TRUE;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/pl-beos.c": "/*  Part of SWI-Prolog\n\n    Author:        Alex D\u00f6rfler\n    E-mail:        axeld@pinc-software.de\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  2002-2018, University of Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThis module is  written  by   Alex  D\u00f6rfler,  axeld@pinc-software.de and\nintegrated into SWI-Prolog by Jan Wielemaker.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef __BEOS__\n#include \"pl-incl.h\"\n\n\n\t\t /*******************************\n\t\t *\tDLOPEN AND FRIENDS\t*\n\t\t *******************************/\n\n#ifdef EMULATE_DLOPEN\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThese functions emulate the bits from the ELF shared object interface we\nneed. They are used  by  pl-load.c,   which  defines  the  actual Prolog\ninterface.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nvoid *\nPL_dlopen(const char *file, int flags)\n{ image_id image = load_add_on(file);\n\n  if ( image < B_OK )\n  { LD->os.dl_error = image;\n    return NULL;\n  }\n\n  LD->os.dl_error = B_OK;\n  return (void *)image;\n}\n\n\nconst char *\nPL_dlerror()\n{ return strerror(LD->os.dl_error);\n}\n\n\nvoid *\nPL_dlsym(void *handle, char *symbol)\n{ void *address;\n\n  LD->os.dl_error = get_image_symbol((image_id)handle,\n\t\t\t\t     symbol,\n\t\t\t\t     B_SYMBOL_TYPE_TEXT,\n\t\t\t\t     &address);\n  if ( LD->os.dl_error == B_OK )\n    return address;\n\n  return NULL;\n}\n\n\nint\nPL_dlclose(void *handle)\n{ return unload_add_on((image_id)handle);\n}\n\n#endif\t/* EMULATE_DLOPEN */\n\n#endif\t/* __BEOS__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/config/wincfg.h": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  2015-2017, University of Amsterdam\n                              Vu University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#define __WIN32__ 1\n#if !defined(VC8) && (_MSC_VER >= 1400)\t/* Visual studio 8 */\n#define VC8 1\t\t\t\t/* (aka Microsoft 2005 VC++ */\n#endif\n\n#define NOTTYCONTROL\t\tTRUE\t/* default -tty */\n\n#if defined(O_PLMT) && !defined(_REENTRANT)\n#define _REENTRANT 1\n#endif\n\n#define OPEN_MAX 32\n\n#define HAVE_UXNT_H 1\n\n#define HAVE_CLOCK 1\t\t\t/* clock() timing function */\n\n/* Define for emulating dlopen(), etc. using LoadLibrary */\n#define EMULATE_DLOPEN 1\n\n/* Define for the _xos_... functions */\n#define O_XOS 1\n\n/* Define O_RLC for the ../readline library */\n#define O_RLC 1\n\n/* Define for Windows DDE support */\n#define O_DDE 1\n\n/* Define for Windows DLL support */\n#define O_DLL 1\n\n/* Define if you disk-drives are special to you (DOS, Windows, OS/2) */\n#define O_HASDRIVES 1\n\n/* Define if you have shares using the notation //host/share */\n#define O_HASSHARES 1\n\n/* Maximum length of a path-name.  Note XOS! */\n#define MAXPATHLEN 512\n\n/* Define if floats are IEEE754 */\n#define IEEE754 1\n\n/* setenv comes from uxnt.c */\n#define HAVE_SETENV 1\n\n\n#ifdef __MINGW32__\n#include \"config.h\"\n#endif\n\n/* FIXME: this is overriding what is in config.h. */\n/* Define to make use of standard (UNIX98) pthread recursive mutexes */\n#define RECURSIVE_MUTEXES 1\n\n/* FIXME: this is overriding what is in config.h. */\n/* Define if pthread has pthread_mutexattr_settype() */\n#define HAVE_PTHREAD_MUTEXATTR_SETTYPE 1\n\n#ifndef __MINGW32__\ntypedef unsigned long sigset_t;\t\t/* we don't have this */\ntypedef int mode_t;\n\n/* Define to 1 if you have the <shlobj.h> header file. */\n#define HAVE_SHLOBJ_H 1\n\n/* Define to 1 if you have the <dbghelp.h> header file. */\n#define HAVE_DBGHELP_H 1\n\n/* Define to 1 if you have the <malloc.h> header file. */\n#define HAVE_MALLOC_H 1\n\n#define inline __inline\n\n#define snprintf ms_snprintf\t\t/* defined in pl-nt.c */\n\n#ifdef O_GMP\n#define HAVE_GMP_H 1\n#endif\n\n#ifdef __LCC__\n#define NO_MS_EXTENSIONS 1\n#endif\n\n/* Define to extension used for shared objects if not \"so\" */\n#define SO_EXT \"dll\"\n\n/* Define as the return type of signal handlers (int or void).  */\n#define RETSIGTYPE void\n\n/* Define if SIGPROF and setitimer() are available */\n#define O_PROFILE 1\n\n/* \"Define if Prolog kernel is in shared object\" */\n#define O_SHARED_KERNEL 1\n\n/* The number of bytes in a int.  */\n#define SIZEOF_INT 4\n\n/* The number of bytes in a long.  */\n#define SIZEOF_LONG 4\n\n/* The number of bytes in a wchar_t.  */\n#define SIZEOF_WCHAR_T 2\n\n/* Define if you have the access function.  */\n#define HAVE_ACCESS 1\n\n/* Define if you have the chmod function.  */\n#define HAVE_CHMOD 1\n\n/* Define if you have the fstat function.  */\n#define HAVE_FSTAT 1\n\n/* Define if you have the getcwd function.  */\n#define HAVE_GETCWD 1\n\n/* Define if you have the getpid function.  */\n#define HAVE_GETPID 1\n\n/* Define if you have the ftime function.  */\n#define HAVE_FTIME 1\n\n/* Define if you have the memmove function.  */\n#define HAVE_MEMMOVE 1\n\n/* Define if you have the opendir function.  */\n#define HAVE_OPENDIR 1\n\n/* Define if you have the popen function.  */\n#define HAVE_POPEN 1\n\n/* Define if you have the putenv function.  */\n#define HAVE_PUTENV 1\n\n/* Define if you have the remove function.  */\n#define HAVE_REMOVE 1\n\n/* Define if you have the rename function.  */\n#define HAVE_RENAME 1\n\n/* Define if you have the stricmp() function. */\n#define HAVE_STRICMP 1\n\n/* Define if you have the mbscasecoll() function. */\n#define mbscasecoll mbsicoll\n#define HAVE_MBSCASECOLL 1\n\n/* Define if you have the strlwr() function */\n#define HAVE_STRLWR 1\n\n/* Define if you have the rl_insert_close function.  */\n#define HAVE_RL_INSERT_CLOSE 1\n\n/* Define if you have the select function.  */\n#define HAVE_SELECT 1\n\n/* Define if you have the signal function.  */\n#define HAVE_SIGNAL 1\n\n/* Define if you have the srand function.  */\n#define HAVE_SRAND 1\n\n/* Define if you have the stat function.  */\n#define HAVE_STAT 1\n\n/* Define if you have the strerror function.  */\n#define HAVE_STRERROR 1\n\n/* Define to 1 if you have the `ceil' function. */\n#define HAVE_CEIL  1\n\n/* Define to 1 if you have the `floor' function. */\n#define HAVE_FLOOR 1\n\n/* Define if you have the <dirent.h> header file.  */\n#define HAVE_DIRENT_H 1\n\n/* Define if you have the <memory.h> header file.  */\n#define HAVE_MEMORY_H 1\n\n/* Define if you have the <ndir.h> header file.  */\n/* #undef HAVE_NDIR_H */\n\n/* Define if you have the <string.h> header file.  */\n#define HAVE_STRING_H 1\n\n/* Define if you have the <sys/stat.h> header file.  */\n#define HAVE_SYS_STAT_H 1\n\n/* Define if you have the m library (-lm).  */\n#define HAVE_LIBM 1\n\n/* Define to 1 if you have the <locale.h> header file. */\n#define HAVE_LOCALE_H 1\n\n/* Define to 1 if you have the `setlocale' function. */\n#define HAVE_SETLOCALE 1\n\n/* Define to 1 if you have `isnan' function */\n#define HAVE_ISNAN 1\n\n/* Define to 1 if you have `_fpclass' function */\n#define HAVE__FPCLASS 1\n\n/* Define to 1 if you have `signbit' function */\n/* #undef HAVE_SIGNBIT 1 */\n\n/* Define to 1 if you have <float.h> header */\n#define HAVE_FLOAT_H 1\n\n/* Define to 1 if you have the 'wcsxfrm' function. */\n#define HAVE_WCSXFRM 1\n\n#endif /*__MINGW32__*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/library/shlib.pl": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1995-2018, University of Amsterdam\n                              VU University Amsterdam\n                              CWI, Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n:- module(shlib,\n          [ load_foreign_library/1,     % :LibFile\n            load_foreign_library/2,     % :LibFile, +InstallFunc\n            unload_foreign_library/1,   % +LibFile\n            unload_foreign_library/2,   % +LibFile, +UninstallFunc\n            current_foreign_library/2,  % ?LibFile, ?Public\n            reload_foreign_libraries/0,\n                                        % Directives\n            use_foreign_library/1,      % :LibFile\n            use_foreign_library/2       % :LibFile, +InstallFunc\n          ]).\n:- use_module(library(lists), [reverse/2]).\n:- set_prolog_flag(generate_debug_info, false).\n\n/** <module> Utility library for loading foreign objects (DLLs, shared objects)\n\nThis   section   discusses   the   functionality   of   the   (autoload)\nlibrary(shlib), providing an interface to   manage  shared libraries. We\ndescribe the procedure for using a foreign  resource (DLL in Windows and\nshared object in Unix) called =mylib=.\n\nFirst, one must  assemble  the  resource   and  make  it  compatible  to\nSWI-Prolog. The details for this vary between platforms. The swipl-ld(1)\nutility can be used to deal with this  in a portable manner. The typical\ncommandline is:\n\n        ==\n        swipl-ld -o mylib file.{c,o,cc,C} ...\n        ==\n\nMake  sure  that  one  of   the    files   provides  a  global  function\n=|install_mylib()|=  that  initialises  the  module    using   calls  to\nPL_register_foreign(). Here is a  simple   example  file  mylib.c, which\ncreates a Windows MessageBox:\n\n    ==\n    #include <windows.h>\n    #include <SWI-Prolog.h>\n\n    static foreign_t\n    pl_say_hello(term_t to)\n    { char *a;\n\n      if ( PL_get_atom_chars(to, &a) )\n      { MessageBox(NULL, a, \"DLL test\", MB_OK|MB_TASKMODAL);\n\n        PL_succeed;\n      }\n\n      PL_fail;\n    }\n\n    install_t\n    install_mylib()\n    { PL_register_foreign(\"say_hello\", 1, pl_say_hello, 0);\n    }\n    ==\n\nNow write a file mylib.pl:\n\n    ==\n    :- module(mylib, [ say_hello/1 ]).\n    :- use_foreign_library(foreign(mylib)).\n    ==\n\nThe file mylib.pl can be loaded as a normal Prolog file and provides the\npredicate defined in C.\n*/\n\n:- meta_predicate\n    load_foreign_library(:),\n    load_foreign_library(:, +),\n    use_foreign_library(:),\n    use_foreign_library(:, +).\n\n:- dynamic\n    loading/1,                      % Lib\n    error/2,                        % File, Error\n    foreign_predicate/2,            % Lib, Pred\n    current_library/5.              % Lib, Entry, Path, Module, Handle\n\n:- volatile                             % Do not store in state\n    loading/1,\n    error/2,\n    foreign_predicate/2,\n    current_library/5.\n\n:- (   current_prolog_flag(open_shared_object, true)\n   ->  true\n   ;   print_message(warning, shlib(not_supported)) % error?\n   ).\n\n% The flag `res_keep_foreign` prevents deleting  temporary files created\n% to load shared objects when set  to   `true`.  This  may be needed for\n% debugging purposes.\n\n:- create_prolog_flag(res_keep_foreign, false,\n                      [ keep(true) ]).\n\n\n                 /*******************************\n                 *           DISPATCHING        *\n                 *******************************/\n\n%!  find_library(+LibSpec, -Lib, -Delete) is det.\n%\n%   Find a foreign library from LibSpec.  If LibSpec is available as\n%   a resource, the content of the resource is copied to a temporary\n%   file and Delete is unified with =true=.\n\nfind_library(Spec, TmpFile, true) :-\n    '$rc_handle'(Zipper),\n    term_to_atom(Spec, Name),\n    setup_call_cleanup(\n        zip_lock(Zipper),\n        setup_call_cleanup(\n            open_foreign_in_resources(Zipper, Name, In),\n            setup_call_cleanup(\n                tmp_file_stream(binary, TmpFile, Out),\n                copy_stream_data(In, Out),\n                close(Out)),\n            close(In)),\n        zip_unlock(Zipper)),\n    !.\nfind_library(Spec, Lib, Copy) :-\n    absolute_file_name(Spec, Lib0,\n                       [ file_type(executable),\n                         access(read),\n                         file_errors(fail)\n                       ]),\n    !,\n    lib_to_file(Lib0, Lib, Copy).\nfind_library(Spec, Spec, false) :-\n    atom(Spec),\n    !.                  % use machines finding schema\nfind_library(foreign(Spec), Spec, false) :-\n    atom(Spec),\n    !.                  % use machines finding schema\nfind_library(Spec, _, _) :-\n    throw(error(existence_error(source_sink, Spec), _)).\n\n%!  lib_to_file(+Lib0, -Lib, -Copy) is det.\n%\n%   If Lib0 is not a regular file  we   need  to  copy it to a temporary\n%   regular file because dlopen()  and   Windows  LoadLibrary() expect a\n%   file name. On some systems this can   be  avoided. Roughly using two\n%   approaches (after discussion with Peter Ludemann):\n%\n%     - On FreeBSD there is shm_open() to create an anonymous file in\n%       memory and than fdlopen() to link this.\n%     - In general, we could redefine the system calls open(), etc. to\n%       make dlopen() work on non-files.  This is highly non-portably\n%       though.\n%     - We can mount the resource zip using e.g., `fuse-zip` on Linux.\n%       This however fails if we include the resources as a string in\n%       the executable.\n%\n%   @see https://github.com/fancycode/MemoryModule for Windows\n\nlib_to_file(Res, TmpFile, true) :-\n    sub_atom(Res, 0, _, _, 'res://'),\n    !,\n    setup_call_cleanup(\n        open(Res, read, In, [type(binary)]),\n        setup_call_cleanup(\n            tmp_file_stream(binary, TmpFile, Out),\n            copy_stream_data(In, Out),\n            close(Out)),\n        close(In)).\nlib_to_file(Lib, Lib, false).\n\nopen_foreign_in_resources(Zipper, Name, Stream) :-\n    zipper_goto(Zipper, file(Name)),\n    zipper_open_current(Zipper, Stream,\n                        [ type(binary),\n                          release(true)\n                        ]).\n\nbase(Path, Base) :-\n    atomic(Path),\n    !,\n    file_base_name(Path, File),\n    file_name_extension(Base, _Ext, File).\nbase(_/Path, Base) :-\n    !,\n    base(Path, Base).\nbase(Path, Base) :-\n    Path =.. [_,Arg],\n    base(Arg, Base).\n\nentry(_, Function, Function) :-\n    Function \\= default(_),\n    !.\nentry(Spec, default(FuncBase), Function) :-\n    base(Spec, Base),\n    atomic_list_concat([FuncBase, Base], '_', Function).\nentry(_, default(Function), Function).\n\n                 /*******************************\n                 *          (UN)LOADING         *\n                 *******************************/\n\n%!  load_foreign_library(:FileSpec) is det.\n%!  load_foreign_library(:FileSpec, +Entry:atom) is det.\n%\n%   Load a _|shared object|_  or  _DLL_.   After  loading  the Entry\n%   function is called without arguments. The default entry function\n%   is composed from =install_=,  followed   by  the file base-name.\n%   E.g.,    the    load-call    below      calls    the    function\n%   =|install_mylib()|=. If the platform   prefixes extern functions\n%   with =_=, this prefix is added before calling.\n%\n%     ==\n%           ...\n%           load_foreign_library(foreign(mylib)),\n%           ...\n%     ==\n%\n%   @param  FileSpec is a specification for absolute_file_name/3.  If searching\n%           the file fails, the plain name is passed to the OS to try the default\n%           method of the OS for locating foreign objects.  The default definition\n%           of file_search_path/2 searches <prolog home>/lib/<arch> on Unix and\n%           <prolog home>/bin on Windows.\n%\n%   @see    use_foreign_library/1,2 are intended for use in directives.\n\nload_foreign_library(Library) :-\n    load_foreign_library(Library, default(install)).\n\nload_foreign_library(Module:LibFile, Entry) :-\n    with_mutex('$foreign',\n               load_foreign_library(LibFile, Module, Entry)).\n\nload_foreign_library(LibFile, _Module, _) :-\n    current_library(LibFile, _, _, _, _),\n    !.\nload_foreign_library(LibFile, Module, DefEntry) :-\n    retractall(error(_, _)),\n    find_library(LibFile, Path, Delete),\n    asserta(loading(LibFile)),\n    retractall(foreign_predicate(LibFile, _)),\n    catch(Module:open_shared_object(Path, Handle), E, true),\n    (   nonvar(E)\n    ->  delete_foreign_lib(Delete, Path),\n        assert(error(Path, E)),\n        fail\n    ;   delete_foreign_lib(Delete, Path)\n    ),\n    !,\n    (   entry(LibFile, DefEntry, Entry),\n        Module:call_shared_object_function(Handle, Entry)\n    ->  retractall(loading(LibFile)),\n        assert_shlib(LibFile, Entry, Path, Module, Handle)\n    ;   foreign_predicate(LibFile, _)\n    ->  retractall(loading(LibFile)),    % C++ object installed predicates\n        assert_shlib(LibFile, 'C++', Path, Module, Handle)\n    ;   retractall(loading(LibFile)),\n        retractall(foreign_predicate(LibFile, _)),\n        close_shared_object(Handle),\n        findall(Entry, entry(LibFile, DefEntry, Entry), Entries),\n        throw(error(existence_error(foreign_install_function,\n                                    install(Path, Entries)),\n                    _))\n    ).\nload_foreign_library(LibFile, _, _) :-\n    retractall(loading(LibFile)),\n    (   error(_Path, E)\n    ->  retractall(error(_, _)),\n        throw(E)\n    ;   throw(error(existence_error(foreign_library, LibFile), _))\n    ).\n\ndelete_foreign_lib(true, Path) :-\n    \\+ current_prolog_flag(res_keep_foreign, true),\n    !,\n    catch(delete_file(Path), _, true).\ndelete_foreign_lib(_, _).\n\n\n%!  use_foreign_library(+FileSpec) is det.\n%!  use_foreign_library(+FileSpec, +Entry:atom) is det.\n%\n%   Load and install a foreign   library as load_foreign_library/1,2\n%   and register the installation using   initialization/2  with the\n%   option =now=. This is similar to using:\n%\n%     ==\n%     :- initialization(load_foreign_library(foreign(mylib))).\n%     ==\n%\n%   but using the initialization/1 wrapper causes  the library to be\n%   loaded _after_ loading of  the  file   in  which  it  appears is\n%   completed,  while  use_foreign_library/1  loads    the   library\n%   _immediately_. I.e. the  difference  is   only  relevant  if the\n%   remainder of the file uses functionality of the C-library.\n\nuse_foreign_library(FileSpec) :-\n    initialization(load_foreign_library(FileSpec), now).\n\nuse_foreign_library(FileSpec, Entry) :-\n    initialization(load_foreign_library(FileSpec, Entry), now).\n\n%!  unload_foreign_library(+FileSpec) is det.\n%!  unload_foreign_library(+FileSpec, +Exit:atom) is det.\n%\n%   Unload a _|shared object|_ or  _DLL_.   After  calling  the Exit\n%   function, the shared object is  removed   from  the process. The\n%   default exit function is composed from =uninstall_=, followed by\n%   the file base-name.\n\nunload_foreign_library(LibFile) :-\n    unload_foreign_library(LibFile, default(uninstall)).\n\nunload_foreign_library(LibFile, DefUninstall) :-\n    with_mutex('$foreign', do_unload(LibFile, DefUninstall)).\n\ndo_unload(LibFile, DefUninstall) :-\n    current_library(LibFile, _, _, Module, Handle),\n    retractall(current_library(LibFile, _, _, _, _)),\n    (   entry(LibFile, DefUninstall, Uninstall),\n        Module:call_shared_object_function(Handle, Uninstall)\n    ->  true\n    ;   true\n    ),\n    abolish_foreign(LibFile),\n    close_shared_object(Handle).\n\nabolish_foreign(LibFile) :-\n    (   retract(foreign_predicate(LibFile, Module:Head)),\n        functor(Head, Name, Arity),\n        abolish(Module:Name, Arity),\n        fail\n    ;   true\n    ).\n\nsystem:'$foreign_registered'(M, H) :-\n    (   loading(Lib)\n    ->  true\n    ;   Lib = '<spontaneous>'\n    ),\n    assert(foreign_predicate(Lib, M:H)).\n\nassert_shlib(File, Entry, Path, Module, Handle) :-\n    retractall(current_library(File, _, _, _, _)),\n    asserta(current_library(File, Entry, Path, Module, Handle)).\n\n\n                 /*******************************\n                 *       ADMINISTRATION         *\n                 *******************************/\n\n%!  current_foreign_library(?File, ?Public)\n%\n%   Query currently loaded shared libraries.\n\ncurrent_foreign_library(File, Public) :-\n    current_library(File, _Entry, _Path, _Module, _Handle),\n    findall(Pred, foreign_predicate(File, Pred), Public).\n\n\n                 /*******************************\n                 *            RELOAD            *\n                 *******************************/\n\n%!  reload_foreign_libraries\n%\n%   Reload all foreign libraries loaded (after restore of a state\n%   created using qsave_program/2.\n\nreload_foreign_libraries :-\n    findall(lib(File, Entry, Module),\n            (   retract(current_library(File, Entry, _, Module, _)),\n                File \\== -\n            ),\n            Libs),\n    reverse(Libs, Reversed),\n    reload_libraries(Reversed).\n\nreload_libraries([]).\nreload_libraries([lib(File, Entry, Module)|T]) :-\n    (   load_foreign_library(File, Module, Entry)\n    ->  true\n    ;   print_message(error, shlib(File, load_failed))\n    ),\n    reload_libraries(T).\n\n\n                 /*******************************\n                 *     CLEANUP (WINDOWS ...)    *\n                 *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nCalled from Halt() in pl-os.c (if it  is defined), *after* all at_halt/1\nhooks have been executed, and after   dieIO(),  closing and flushing all\nfiles has been called.\n\nOn Unix, this is not very useful, and can only lead to conflicts.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nunload_all_foreign_libraries :-\n    current_prolog_flag(unload_foreign_libraries, true),\n    !,\n    forall(current_library(File, _, _, _, _),\n           unload_foreign(File)).\nunload_all_foreign_libraries.\n\n%!  unload_foreign(+File)\n%\n%   Unload the given foreign file and all `spontaneous' foreign\n%   predicates created afterwards. Handling these spontaneous\n%   predicates is a bit hard, as we do not know who created them and\n%   on which library they depend.\n\nunload_foreign(File) :-\n    unload_foreign_library(File),\n    (   clause(foreign_predicate(Lib, M:H), true, Ref),\n        (   Lib == '<spontaneous>'\n        ->  functor(H, Name, Arity),\n            abolish(M:Name, Arity),\n            erase(Ref),\n            fail\n        ;   !\n        )\n    ->  true\n    ;   true\n    ).\n\n                 /*******************************\n                 *            MESSAGES          *\n                 *******************************/\n\n:- multifile\n    prolog:message//1,\n    prolog:error_message//1.\n\nprolog:message(shlib(LibFile, load_failed)) -->\n    [ '~w: Failed to load file'-[LibFile] ].\nprolog:message(shlib(not_supported)) -->\n    [ 'Emulator does not support foreign libraries' ].\n\nprolog:error_message(existence_error(foreign_install_function,\n                                     install(Lib, List))) -->\n    [ 'No install function in ~q'-[Lib], nl,\n      '\\tTried: ~q'-[List]\n    ].\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/foreign.doc": "\\chapter{Foreign Language Interface}\t\t\\label{sec:foreign}\n\n\\newlength{\\tableft}\n\\settowidth{\\tableft}{\\const{PL_QUERY_ORGSYMBOLFILE}}\n\nSWI-Prolog offers a powerful interface to C \\cite{Kernighan:78}. The\nmain design objectives of the foreign language interface are flexibility\nand performance. A foreign predicate is a C function that has the same\nnumber of arguments as the predicate represented. C functions are\nprovided to analyse the passed terms, convert them to basic C types as\nwell as to instantiate arguments using unification. Non-deterministic\nforeign predicates are supported, providing the foreign function with a\nhandle to control backtracking.\n\nC can call Prolog predicates, providing both a query interface and\nan interface to extract multiple solutions from a non-deterministic\nProlog predicate.  There is no limit to the nesting of Prolog calling\nC, calling Prolog, etc.  It is also possible to write the `main' in\nC and use Prolog as an embedded logical engine.\n\n\n\\section{Overview of the Interface}\t\t\\label{sec:foreignoverview}\n\nA special include file called \\file{SWI-Prolog.h} should be included\nwith each C source file that is to be loaded via the foreign interface.\nThe installation process installs this file in the directory\n\\file{include} in the SWI-Prolog home directory (\\exam{?-\ncurrent_prolog_flag(home, Home).}). This C header file defines various\ndata types, macros and functions that can be used to communicate with\nSWI-Prolog. Functions and macros can be divided into the following\ncategories:\n\n\\begin{shortlist}\n    \\item Analysing Prolog terms\n    \\item Constructing new terms\n    \\item Unifying terms\n    \\item Returning control information to Prolog\n    \\item Registering foreign predicates with Prolog\n    \\item Calling Prolog from C\n    \\item Recorded database interactions\n    \\item Global actions on Prolog (halt, break, abort, etc.)\n\\end{shortlist}\n\n\n\\section{Linking Foreign Modules}\t\t\\label{sec:foreignlink}\n\nForeign modules may be linked to Prolog in two ways. Using\n\\jargon{static linking}, the extensions, a (short) file defining main()\nwhich attaches the extension calls to Prolog, and the SWI-Prolog kernel\ndistributed as a C library, are linked together to form a new executable.\nUsing \\jargon{dynamic linking}, the extensions are linked to a shared\nlibrary (\\fileext{so} file on most Unix systems) or dynamic link library\n(\\fileext{DLL} file on Microsoft platforms) and loaded into the\nrunning Prolog process.%\n    \\footnote{The system also contains code to load \\fileext{o} files\n              directly for some operating systems, notably Unix systems\n              using the BSD \\file{a.out} executable format. As the number of\n              Unix platforms supporting this quickly gets smaller and\n              this interface is difficult to port and slow, it is no\n              longer described in this manual.  The best alternative\n              would be to use the \\idx{dld} package on machines that do\n\t      not have shared libraries.}\n\n\\subsection{What linking is provided?}\n\\label{sec:foreign-linking}\n\nThe \\jargon{static linking} schema can be used on all versions of\nSWI-Prolog. Whether or not dynamic linking is supported can be deduced\nfrom the Prolog flag \\prologflag{open_shared_object} (see\ncurrent_prolog_flag/2). If this Prolog flag yields \\const{true},\nopen_shared_object/2 and related predicates are defined. See\n\\secref{shlib} for a suitable high-level interface to these predicates.\n\n\\subsection{What kind of loading should I be using?}\n\\label{sec:foreign-linking-options}\n\nAll described approaches have their advantages and disadvantages. Static\nlinking is portable and allows for debugging on all platforms. It is\nrelatively cumbersome and the libraries you need to pass to the linker\nmay vary from system to system, though the utility program\n\\program{swipl-ld} described in \\secref{plld} often hides these problems\nfrom the user.\n\nLoading shared objects (DLL files on Windows) provides sharing and\nprotection and is generally the best choice. If a saved state is created\nusing qsave_program/[1,2], an initialization/1 directive may be used to\nload the appropriate library at startup.\n\nNote that the definition of the foreign predicates is the same, regardless\nof the linking type used.\n\n\\input{lib/shlib}\n\n\\subsection{Low-level operations on shared libraries}\n\\label{sec:sharedobj}\n\nThe interface defined in this section allows the user to load shared\nlibraries (\\fileext{so} files on most Unix systems, \\fileext{dll} files\non Windows). This interface is portable to Windows as well as to Unix\nmachines providing \\manref{dlopen}{2} (Solaris, Linux, FreeBSD, Irix and\nmany more) or \\manref{shl_open}{2} (HP/UX). It is advised to use the\npredicates from \\secref{shlib} in your application.\n\n\n\\begin{description}\n    \\predicate{open_shared_object}{2}{+File, -Handle}\n\\arg{File} is the name of a shared object file (DLL in MS-Windows). This file is attached to the current process, and\n\\arg{Handle} is unified with a handle to the library. Equivalent to\n\\exam{open_shared_object(File, Handle, [])}. See also\nopen_shared_object/3 and load_foreign_library/1.\n\nOn errors, an exception \\term{shared_object}{Action, Message} is\nraised. \\arg{Message} is the return value from dlerror().\n\n    \\predicate{open_shared_object}{3}{+File, -Handle, +Options}\nAs open_shared_object/2, but allows for additional flags to be passed.\n\\arg{Options} is a list of atoms. \\const{now} implies the symbols are\nresolved immediately rather than lazy (default). \\const{global} implies\nsymbols of the loaded object are visible while loading other shared\nobjects (by default they are local). Note that these flags may not be\nsupported by your operating system. Check the documentation of dlopen()\nor equivalent on your operating system.  Unsupported flags are silently\nignored.\n\n    \\predicate{close_shared_object}{1}{+Handle}\nDetach the shared object identified by \\arg{Handle}.\n\n    \\predicate{call_shared_object_function}{2}{+Handle, +Function}\nCall the named function in the loaded shared library.  The function\nis called without arguments and the return value is ignored.  Normally\nthis function installs foreign language predicates using calls to\nPL_register_foreign().\n\\end{description}\n\n\n\\subsection{Static Linking} \\label{sec:staticl}\n\nBelow is an outline of the file structure required for statically\nlinking SWI-Prolog with foreign extensions. \\file{.../swipl} refers to\nthe SWI-Prolog home directory (see the Prolog flag \\prologflag{home}).\n\\file{<arch>} refers to the architecture identifier that may be obtained\nusing the Prolog flag \\prologflag{arch}.\n\n\\begin{center}\n\\begin{tabular}{ll}\n\\file{.../swipl/runtime/<arch>/libswipl.a} & SWI-Library \\\\\n\\file{.../swipl/include/SWI-Prolog.h}      & Include file \\\\\n\\file{.../swipl/include/SWI-Stream.h}      & Stream I/O include file \\\\\n\\file{.../swipl/include/SWI-Exports}       & Export declarations (AIX only) \\\\\n\\file{.../swipl/include/stub.c}            & Extension stub\n\\end{tabular}\n\\end{center}\n\nThe definition of the foreign predicates is the same as for dynamic\nlinking.  Unlike with dynamic linking, however, there is no\ninitialisation function.  Instead, the file \\file{.../swipl/include/stub.c}\nmay be copied to your project and modified to define the foreign\nextensions.  Below is \\file{stub.c}, modified to link the lowercase example\ndescribed later in this chapter:\n\n\\begin{code}\n#include <stdio.h>\n#include <SWI-Prolog.h>\n\nextern foreign_t pl_lowercase(term, term);\n\nPL_extension predicates[] =\n{\n/*{ \"name\",      arity,  function,      PL_FA_<flags> },*/\n\n  { \"lowercase\", 2       pl_lowercase,  0 },\n  { NULL,        0,      NULL,          0 } /* terminating line */\n};\n\n\nint\nmain(int argc, char **argv)\n{ PL_register_extensions(predicates);\n\n  if ( !PL_initialise(argc, argv) )\n    PL_halt(1);\n\n  PL_halt(PL_toplevel() ? 0 : 1);\n}\n\\end{code}\n\nNow, a new executable may be created by compiling this file and linking\nit to \\file{libpl.a} from the runtime directory and the libraries\nrequired by both the extensions and the SWI-Prolog kernel. This may be\ndone by hand, or by using the \\program{swipl-ld} utility described in\n\\secref{plld}. If the linking is performed by hand, the command line\noption \\const{-dump-runtime-variables} (see \\secref{cmdline}) can be\nused to obtain the required paths, libraries and linking options to link\nthe new executable.\n\n\\section{Interface Data Types}\t\t\\label{sec:foreigntypes}\n\n\\subsection{Type \\ctype{term_t}: a reference to a Prolog term}\n\\label{sec:type-term-t}\n\nThe principal data type is \\ctype{term_t}. Type \\ctype{term_t} is what\nQuintus calls \\ctype{QP_term_ref}. This name indicates better what the\ntype represents: it is a \\jargon{handle} for a term rather than the term\nitself. Terms can only be represented and manipulated using this type,\nas this is the only safe way to ensure the Prolog kernel is aware of all\nterms referenced by foreign code and thus allows the kernel to perform\ngarbage collection and/or stack-shifts while foreign code is active,\nfor example during a callback from C.\n\nA term reference is a C unsigned long, representing the offset of a\nvariable on the Prolog environment stack.  A foreign function is passed\nterm references for the predicate arguments, one for each argument.  If\nreferences for intermediate results are needed, such references may be\ncreated using PL_new_term_ref() or PL_new_term_refs().  These references\nnormally live till the foreign function returns control back to Prolog.\nTheir scope can be explicitly limited using PL_open_foreign_frame()\nand PL_close_foreign_frame()/PL_discard_foreign_frame().\n\nA \\ctype{term_t} always refers to a valid Prolog term (variable, atom, integer,\nfloat or compound term). A term lives either until backtracking takes us\nback to a point before the term was created, the garbage collector has\ncollected the term, or the term was created after a\nPL_open_foreign_frame() and PL_discard_foreign_frame() has been called.\n\nThe foreign interface functions can either {\\em read}, {\\em unify} or\n{\\em write} to term references.  In this document we use the\nfollowing notation for arguments of type \\ctype{term_t}:\n\n\\begin{quote}\n\\begin{tabular}{lp{4in}}\n\\tt term_t +t   & Accessed in read-mode.  The `+' indicates the\n                  argument is `input'. \\\\\n\\tt term_t -t   & Accessed in write-mode. \\\\\n\\tt term_t ?t   & Accessed in unify-mode. \\\\\n\\end{tabular}\n\\end{quote}\n\n\\textbf{WARNING} Term references that are accessed in `write' (-) mode\nwill refer to an invalid term if the term is allocated on the global\nstack and backtracking takes us back to a point before the term was\nwritten.\\footnote{This could have been avoided by \\jargon{trailing} term\nreferences when data is written to them. This seriously hurds\nperformance in some scenarios though. If this is desired, use\nPL_put_variable() followed by one of the PL_unify_*() functions.}\nCompounds, large integers, floats and strings are all allocated on the\nglobal stack. Below is a typical scenario where this may happen. The\nfirst solution writes a term extracted from the solution into \\arg{a}.\nAfter the system backtracks due to PL_next_solution(), \\arg{a} becomes a\nreference to a term that no longer exists.\n\n\\begin{code}\nterm_t a = PL_new_term_ref();\n...\nquery = PL_open_query(...);\nwhile(PL_next_solution(query))\n{ PL_get_arg(i, ..., a);\n}\nPL_close_query(query);\n\\end{code}\n\nThere are two solutions to this problem. One is to scope the term\nreference using PL_open_foreign_frame() and PL_close_foreign_frame() and\nmakes sure it goes out of scope before backtracking happens. The other\nis to clear the term reference using PL_put_variable() before\nbacktracking.\n\nTerm references are obtained in any of the following ways:\n\n\\begin{itemlist}\n\\item [Passed as argument]\n    The C functions implementing foreign predicates are passed their\n    arguments as term references.  These references may be read or\n    unified.  Writing to these variables causes undefined behaviour.\n\\item [Created by PL_new_term_ref()]\n    A term created by PL_new_term_ref() is normally used to build\n    temporary terms or to be written by one of the interface functions.\n    For example, PL_get_arg() writes a reference to the term argument\n    in its last argument.\n\\item [Created by PL_new_term_refs(int n)]\n    This function returns a set of term references with the same characteristics\n    as PL_new_term_ref().  See PL_open_query().\n\\item [Created by PL_copy_term_ref(term_t t)]\n    Creates a new term reference to the same term as the argument.  The\n    term may be written to.  See \\figref{pl-display}.\n\\end{itemlist}\n\nTerm references can safely be copied to other C variables of type\n\\ctype{term_t}, but all copies will always refer to the same term.\n\n\\begin{description}\n\\cfunction{term_t}{PL_new_term_ref}{}\nReturn a fresh reference to a term.  The reference is allocated on the\n\\jargon{local} stack.  Allocating a term reference may trigger a stack-shift\non machines that cannot use sparse memory management for allocation of the\nProlog stacks.  The returned reference describes a variable.\n\\cfunction{term_t}{PL_new_term_refs}{int n}\nReturn \\arg{n} new term references.  The first term reference is returned.\nThe others are $\\arg{t}+1$, $\\arg{t}+2$, etc.  There are two reasons\nfor using this function.  PL_open_query() expects the arguments as a set\nof consecutive term references, and {\\em very} time-critical code requiring\na number of term references can be written as:\n\n\\begin{code}\npl_mypredicate(term_t a0, term_t a1)\n{ term_t t0 = PL_new_term_refs(2);\n  term_t t1 = t0+1;\n\n  ...\n}\n\\end{code}\n\\cfunction{term_t}{PL_copy_term_ref}{term_t from}\nCreate a new term reference and make it point initially to the same\nterm as \\arg{from}.  This function is commonly used to copy a predicate\nargument to a term reference that may be written.\n\\cfunction{void}{PL_reset_term_refs}{term_t after}\nDestroy all term references that have been created after \\arg{after},\nincluding \\arg{after} itself. Any reference to the invalidated  term\nreferences after this call results in undefined behaviour.\n\nNote that returning from the foreign context to Prolog will reclaim\nall references used in the foreign context.  This call is only necessary\nif references are created inside a loop that never exits back to Prolog.\nSee also PL_open_foreign_frame(), PL_close_foreign_frame() and\nPL_discard_foreign_frame().\n\\end{description}\n\n\n\\subsubsection{Interaction with the garbage collector and stack-shifter}\n\\label{sec:foreign-gc}\n\nProlog implements two mechanisms for avoiding stack overflow: garbage\ncollection and stack expansion. On machines that allow for it, Prolog\nwill use virtual memory management to detect stack overflow and expand\nthe runtime stacks. On other machines Prolog will reallocate the stacks\nand update all pointers to them. To do so, Prolog needs to know which\ndata is referenced by C code. As all Prolog data known by C is\nreferenced through term references (\\ctype{term_t}), Prolog has all the\ninformation necessary to perform its memory management without\nspecial precautions from the C programmer.\n\n\n\\subsection{Other foreign interface types}\n\\label{sec:foreign-types}\n\n\\begin{description}\n    \\item[atom_t]\nAn atom in Prolog's internal representation.  Atoms are pointers to an\nopaque structure.  They are a unique representation for represented\ntext, which implies that atom $A$ represents the same text as\natom $B$ if and only if $A$ and $B$ are the same pointer.\n\nAtoms are the central representation for textual constants in Prolog.\nThe transformation of a character string $C$ to an atom implies a\nhash-table lookup.  If the same atom is needed often, it is advised\nto store its reference in a global variable to avoid repeated lookup.\n    \\item[functor_t]\nA functor is the internal representation of a name/arity pair. They are\nused to find the name and arity of a compound term as well as to\nconstruct new compound terms. Like atoms they live for the whole Prolog\nsession and are unique.\n    \\item[predicate_t]\nHandle to a Prolog predicate. Predicate handles live forever (although\nthey can lose their definition).\n    \\item[qid_t]\nQuery identifier. Used by\nPL_open_query(), PL_next_solution() and PL_close_query() to handle\nbacktracking from C.\n    \\item[fid_t]\nFrame identifier. Used by\nPL_open_foreign_frame() and PL_close_foreign_frame().\n    \\item[module_t]\nA module is a unique handle to a Prolog module. Modules are used only\nto call predicates in a specific module.\n    \\item[foreign_t]\nReturn type for a C function implementing a Prolog predicate.\n    \\item[control_t]\nPassed as additional argument to non-deterministic foreign functions.\nSee PL_retry*() and PL_foreign_context*().\n    \\item[install_t]\nType for the install() and uninstall() functions of shared\nor dynamic link libraries.  See \\secref{shlib}.\n    \\item[int64_t]\nActually part of the C99 standard rather than Prolog. As of version\n5.5.6, Prolog integers are 64-bit on all hardware. The C99 type\n\\ctype{int64_t} is defined in the \\file{stdint.h} standard header and\nprovides platform-independent 64-bit integers. Portable code accessing\nProlog should use this type to exchange integer values. Please note that\nPL_get_long() can return \\const{FALSE} on Prolog integers that cannot be\nrepresented as a C long. Robust code should not assume any of the\ninteger fetching functions to succeed, \\emph{even} if the Prolog term is known\nto be an integer.\n\\end{description}\n\n\\subsubsection{PL_ARITY_AS_SIZE}\n\\label{sec:pl-arity-as-size}\n\nAs of SWI-Prolog 7.3.12, the arity of terms has changed from \\ctype{int}\nto \\ctype{size_t}. To deal with this transition, all affecting functions\nhave two versions, where the old name exchanges the arity as \\ctype{int}\nand a new function with name *_sz() exchanges the arity as\n\\ctype{size_t}. If the C macro PL_ARITY_AS_SIZE is defined before\nloading \\file{SWI-Prolog.h}, macros are put in place that map the old\nnames to the new functions.  Without precautions, the old code is\ncompatible, but the following warning is printed when compiling:\n\n\\begin{code}\n#warning \"Term arity has changed from int to size_t.\"\n#warning \"Please update your code and use #define PL_ARITY_AS_SIZE 1.\"\n\\end{code}\n\nTo make the code compile silently again, include \\file{SWI-Prolog.h} as\nbelow and change the types you use to represent arity from \\ctype{int}\nto \\ctype{size_t}. Please be aware that \\ctype{size_t} is\n\\emph{unsigned}.\n\n\\begin{code}\n#define PL_ARITY_AS_SIZE\n#include <SWI-Prolog.h>\n\\end{code}\n\n\\section{The Foreign Include File}\t\\label{sec:foreigninclude}\n\n\\subsection{Argument Passing and Control}\n\\label{sec:foreign-control}\n\nIf Prolog encounters a foreign predicate at run time it will call a\nfunction specified in the predicate definition of the foreign predicate.\nThe arguments $1, \\ldots, <arity>$ pass the Prolog arguments to the goal\nas Prolog terms. Foreign functions should be declared of type\n\\ctype{foreign_t}. Deterministic foreign functions have two alternatives\nto return control back to Prolog:\n\n\\begin{description}\n    \\cmacro{(return) foreign_t}{PL_succeed}{}\nSucceed deterministically. PL_succeed is defined as\n\\exam{return \\const{TRUE}}.\n    \\cmacro{(return) foreign_t}{PL_fail}{}\nFail and start Prolog backtracking.  PL_fail is defined as \\exam{return\n\\const{FALSE}}.\n\\end{description}\n\n\\subsubsection{Non-deterministic Foreign Predicates}\t\\label{sec:foreignnondet}\n\nBy default foreign predicates are deterministic. Using the\n\\const{PL_FA_NONDETERMINISTIC} attribute (see PL_register_foreign()) it\nis possible to register a predicate as a non-deterministic predicate.\nWriting non-deterministic foreign predicates is slightly more\ncomplicated as the foreign function needs context information for\ngenerating the next solution. Note that the same foreign function should\nbe prepared to be simultaneously active in more than one goal. Suppose\nthe {natural_number_below_n}/2 is a non-deterministic foreign predicate,\nbacktracking over all natural numbers lower than the first argument. Now\nconsider the following predicate:\n\n\\begin{code}\nquotient_below_n(Q, N) :-\n        natural_number_below_n(N, N1),\n        natural_number_below_n(N, N2),\n        Q =:= N1 / N2, !.\n\\end{code}\n\nIn this predicate the function {natural_number_below_n}/2 simultaneously\ngenerates solutions for both its invocations.\n\nNon-deterministic foreign functions should be prepared to handle three\ndifferent calls from Prolog:\n\n\\begin{itemlist}\n    \\item [Initial call (\\const{PL_FIRST_CALL})]\nProlog has just created a frame for the foreign function and asks it to\nproduce the first answer.\n    \\item [Redo call (\\const{PL_REDO})]\nThe previous invocation of the foreign function associated with the\ncurrent goal indicated it was possible to backtrack.  The foreign\nfunction should produce the next solution.\n    \\item [Terminate call (\\const{PL_PRUNED})]\nThe choice point left by the foreign function has been destroyed by\na cut.  The foreign function is given the opportunity to clean the\nenvironment.\n\\end{itemlist}\n\nBoth the context information and the type of call is provided by an\nargument of type \\ctype{control_t} appended to the argument list for\ndeterministic foreign functions.  The macro PL_foreign_control()\nextracts the type of call from the control argument.  The foreign\nfunction can pass a context handle using the {\\tt PL_retry*()} macros and\nextract the handle from the extra argument using the\n{\\tt PL_foreign_context*()} macro.\n\n\\begin{description}\n    \\cmacro{(return) foreign_t}{PL_retry}{intptr_t value}\nThe foreign function succeeds while leaving a choice point. On\nbacktracking over this goal the foreign function will be called again,\nbut the control argument now indicates it is a `Redo' call and the\nmacro PL_foreign_context() returns the handle passed via\nPL_retry(). This handle is a signed value two bits smaller than a pointer,\ni.e., 30 or 62 bits (two bits are used for status indication).\nDefined as \\exam{return _PL_retry(n)}. See also PL_succeed().\n\n    \\cmacro{(return) foreign_t}{PL_retry_address}{void *}\nAs PL_retry(), but ensures an address as returned by malloc() is\ncorrectly recovered by PL_foreign_context_address().\nDefined as \\exam{return _PL_retry_address(n)}. See also\nPL_succeed().\n\n    \\cmacro{int}{PL_foreign_control}{control_t}\nExtracts the type of call from the control argument.  The return values\nare described above.  Note that the function should be prepared to\nhandle the \\const{PL_PRUNED} case and should be aware that the other\narguments are not valid in this case.\n\n    \\cmacro{intptr_t}{PL_foreign_context}{control_t}\nExtracts the context from the context argument.  If the call type is\n\\const{PL_FIRST_CALL} the context value is 0L.  Otherwise it is the value\nreturned by the last PL_retry() associated with this goal (both if the\ncall type is \\const{PL_REDO} or \\const{PL_PRUNED}).\n\n    \\cmacro{void *}{PL_foreign_context_address}{control_t}\nExtracts an address as passed in by PL_retry_address().\n\n    \\cmacro{predicate_t}{PL_foreign_context_predicate}{control_t}\n\nFetch the Prolog predicate that is executing this function. Note that if\nthe predicate is imported, the returned predicate refers to the final\ndefinition rather than the imported predicate, i.e., the module reported\nby PL_predicate_info() is the module in which the predicate is defined\nrather than the module where it was called. See also\nPL_predicate_info().\n\\end{description}\n\nNote: If a non-deterministic foreign function returns using PL_succeed()\nor PL_fail(), Prolog assumes the foreign function has cleaned its\nenvironment. {\\bf No} call with control argument \\const{PL_PRUNED} will\nfollow.\n\nThe code of \\figref{nondetermf} shows a skeleton for a\nnon-deterministic foreign predicate definition.\n\n\\begin{figure}\n\\begin{code}\ntypedef struct                  /* define a context structure */\n{ ...\n} context;\n\nforeign_t\nmy_function(term_t a0, term_t a1, control_t handle)\n{ struct context * ctxt;\n\n  switch( PL_foreign_control(handle) )\n  { case PL_FIRST_CALL:\n        ctxt = malloc(sizeof(struct context));\n        ...\n        PL_retry_address(ctxt);\n    case PL_REDO:\n        ctxt = PL_foreign_context_address(handle);\n        ...\n        PL_retry_address(ctxt);\n    case PL_PRUNED:\n        ctxt = PL_foreign_context_address(handle);\n        ...\n        free(ctxt);\n        PL_succeed;\n  }\n}\n\\end{code}\n    \\caption{Skeleton for non-deterministic foreign functions}\n    \\label{fig:nondetermf}\n\\end{figure}\n\n\n\\subsection{Atoms and functors}\n\\label{sec:foreign-atoms}\n\nThe following functions provide for communication using atoms and\nfunctors.\n\n\\begin{description}\n    \\cfunction{atom_t}{PL_new_atom}{const char *}\nReturn an atom handle for the given C-string.  This function always\nsucceeds. The returned handle is valid as long as the atom is\nreferenced (see \\secref{atomgc}).  The following atoms are provided\nas macros, giving access to the empty list symbol and the name of the\nlist constructor.  Prior to version~7, \\const{ATOM_nil} is the same\nas \\exam{PL_new_atom(\"[]\")} and \\const{ATOM_dot} is the same as\n\\exam{PL_new_atom(\".\")}.  This is no long the case in SWI-Prolog\nversion~7.\n\n    \\begin{description}\n\t\\cmacro{atom_t}{ATOM_nil}\nAtomic constant that represents the empty list.  It is adviced to\nuse PL_get_nil(), PL_put_nil() or PL_unify_nil() where applicable.\n\n\t\\cmacro{atom_t}{ATOM_dot}\nAtomic constant that represents the name of the list constructor.\nThe list constructor itself is created using\n\\exam{PL_new_functor(ATOM_dot,2)}.   It is adviced to use\nPL_get_list(), PL_put_list() or PL_unify_list() where applicable.\n    \\end{description}\n\n    \\cfunction{atom_t}{PL_new_atom_mbchars}{int rep, size_t len,\n\t\t\t\t\t    const char *s}\nThis function generalizes PL_new_atom() and PL_new_atom_nchars() while\nallowing for multiple encodings. The \\arg{rep} argument is one of\n\\const{REP_ISO_LATIN_1}, \\const{REP_UTF8} or \\const{REP_MB}. If\n\\arg{len} is \\exam{(size_t)-1}, it is computed from \\arg{s} using\nstrlen().\n\n    \\cfunction{const char*}{PL_atom_chars}{atom_t atom}\nReturn a C-string for the text represented by the given atom. The\nreturned text will not be changed by Prolog. It is not allowed to modify\nthe contents, not even `temporary' as the string may reside in read-only\nmemory. The returned string becomes invalid if the atom is\ngarbage collected (see \\secref{atomgc}).  Foreign functions that require\nthe text from an atom passed in a \\ctype{term_t} normally use\nPL_get_atom_chars() or PL_get_atom_nchars().\n\n    \\cfunction{functor_t}{PL_new_functor}{atom_t name, int arity}\nReturns a {\\em functor identifier}, a handle for the name/arity\npair.  The returned handle is valid for the entire Prolog session.\n\\cfunction{atom_t}{PL_functor_name}{functor_t f}\nReturn an atom representing the name of the given functor.\n\\cfunction{size_t}{PL_functor_arity}{functor_t f}\nReturn the arity of the given functor.\n\\end{description}\n\n\n\\subsubsection{Atoms and atom garbage collection}\t\\label{sec:atomgc}\n\nWith the introduction of atom garbage collection in version 3.3.0, atoms\nno longer live as long as the process. Instead, their lifetime is\nguaranteed only as long as they are referenced. In the single-threaded\nversion, atom garbage collections are only invoked at the\n\\jargon{call-port}. In the multithreaded version (see \\chapref{threads}),\nthey appear asynchronously, except for the invoking thread.\n\nFor dealing with atom garbage collection, two additional functions are\nprovided:\n\n\\begin{description}\n    \\cfunction{void}{PL_register_atom}{atom_t atom}\nIncrement the reference count of the atom by one. PL_new_atom() performs\nthis automatically, returning an atom with a reference count of at least\none.%\n\t\\footnote{Otherwise asynchronous atom garbage collection might\n\t\t  destroy the atom before it is used.}\n\n    \\cfunction{void}{PL_unregister_atom}{atom_t atom}\nDecrement the reference count of the atom.  If the reference count\ndrops below zero, an assertion error is raised.\n\\end{description}\n\nPlease note that the following two calls are different with respect to\natom garbage collection:\n\n\\begin{code}\nPL_unify_atom_chars(t, \"text\");\nPL_unify_atom(t, PL_new_atom(\"text\"));\n\\end{code}\n\nThe latter increments the reference count of the atom \\const{text},\nwhich effectively ensures the atom will never be collected.  It is\nadvised to use the *_chars() or *_nchars() functions whenever\napplicable.\n\n\n\\subsection{Analysing Terms via the Foreign Interface}\n\\label{sec:foreign-term-analysis}\n\nEach argument of a foreign function (except for the control argument) is\nof type \\ctype{term_t}, an opaque handle to a Prolog term. Three groups of\nfunctions are available for the analysis of terms. The first just\nvalidates the type, like the Prolog predicates var/1, atom/1, etc., and\nare called {\\tt PL_is_*()}. The second group attempts to translate the\nargument into a C primitive type. These predicates take a \\ctype{term_t}\nand a pointer to the appropriate C type and return \\const{TRUE} or\n\\const{FALSE} depending on successful or unsuccessful translation. If the\ntranslation fails, the pointed-to data is never modified.\n\n\\subsubsection{Testing the type of a term}\n\\label{sec:foreign-term-type}\n\n\\begin{description}\n\\cfunction{int}{PL_term_type}{term_t}\nObtain the type of a term, which should be a term returned by\none of the other interface predicates or passed as an argument. The\nfunction returns the type of the Prolog term. The type identifiers are\nlisted below.  Note that the extraction functions {\\tt PL_get_*()} also\nvalidate the type and thus the two sections below are\nequivalent.\n\n\\begin{code}\n        if ( PL_is_atom(t) )\n        { char *s;\n\n          PL_get_atom_chars(t, &s);\n          ...;\n        }\n\nor\n\n        char *s;\n        if ( PL_get_atom_chars(t, &s) )\n        { ...;\n        }\n\\end{code}\n\n\\textbf{Version~7} added \\const{PL_NIL}, \\const{PL_BLOB},\n\\const{PL_LIST_PAIR} and \\const{PL_DICT}.  Older versions\nclassify \\const{PL_NIL} and \\const{PL_BLOB} as \\const{PL_ATOM},\n\\const{PL_LIST_PAIR} as \\const{PL_TERM}\tand do not have\ndicts.\n\n\\begin{tabular}{|p{\\tableft}|p{\\linewidth-\\tableft-2cm}|}\n\\hline\n\\const{PL_VARIABLE}  & A variable or attributed variable \\\\\n\\const{PL_ATOM}      & A Prolog atom \\\\\n\\const{PL_NIL}       & The constant \\verb$[]$ \\\\\n\\const{PL_BLOB}\t     & A blob (see \\secref{blobaccess}) \\\\\n\\const{PL_STRING}    & A string (see \\secref{strings}) \\\\\n\\const{PL_INTEGER}   & A integer \\\\\n\\const{PL_FLOAT}     & A floating point number \\\\\n\\const{PL_TERM}      & A compound term \\\\\n\\const{PL_LIST_PAIR} & A list cell (\\verb$[H|T]$) \\\\\n\\const{PL_DICT}\t     & A dict (see \\secref{bidicts})) \\\\\n\\hline\n\\end{tabular}\n\\end{description}\n\nThe functions PL_is_<type> are an alternative to PL_term_type(). The\ntest \\exam{PL_is_variable(term)} is equivalent to\n\\exam{PL_term_type(term) == PL_VARIABLE}, but the first is considerably\nfaster. On the other hand, using a switch over PL_term_type() is faster\nand more readable then using an if-then-else using the functions below.\nAll these functions return either \\const{TRUE} or \\const{FALSE}.\n\n\\begin{description}\n    \\cfunction{int}{PL_is_variable}{term_t}\nReturns non-zero if \\arg{term} is a variable.\n\n    \\cfunction{int}{PL_is_ground}{term_t}\nReturns non-zero if \\arg{term} is a ground term.  See also ground/1.\nThis function is cycle-safe.\n\n    \\cfunction{int}{PL_is_atom}{term_t}\nReturns non-zero if \\arg{term} is an atom.\n\n    \\cfunction{int}{PL_is_string}{term_t}\nReturns non-zero if \\arg{term} is a string.\n\n    \\cfunction{int}{PL_is_integer}{term_t}\nReturns non-zero if \\arg{term} is an integer.\n\n    \\cfunction{int}{PL_is_float}{term_t}\nReturns non-zero if \\arg{term} is a float.\n\n    \\cfunction{int}{PL_is_callable}{term_t}\nReturns non-zero if \\arg{term} is a callable term.  See callable/1\nfor details.\n\n    \\cfunction{int}{PL_is_compound}{term_t}\nReturns non-zero if \\arg{term} is a compound term.\n\n    \\cfunction{int}{PL_is_functor}{term_t, functor_t}\nReturns non-zero if \\arg{term} is compound and its functor is \\arg{functor}.\nThis test is equivalent to PL_get_functor(), followed by testing the\nfunctor, but easier to write and faster.\n\n    \\cfunction{int}{PL_is_list}{term_t}\nReturns non-zero if \\arg{term} is a compound term using the list\nconstructor or the list terminator. See also PL_is_pair() and\nPL_skip_list().\n\n    \\cfunction{int}{PL_is_pair}{term_t}\nReturns non-zero if \\arg{term} is a compound term using the list\nconstructor.  See also PL_is_list() and PL_skip_list().\n\n    \\cfunction{int}{PL_is_atomic}{term_t}\nReturns non-zero if \\arg{term} is atomic (not variable or compound).\n\n    \\cfunction{int}{PL_is_number}{term_t}\nReturns non-zero if \\arg{term} is an integer or float.\n\n    \\cfunction{int}{PL_is_acyclic}{term_t}\nReturns non-zero if \\arg{term} is acyclic (i.e.\\ a finite tree).\n\\end{description}\n\n\n\\subsubsection{Reading data from a term}\n\\label{sec:foreign-extract-from-term}\n\nThe functions {\\tt PL_get_*()} read information from a Prolog term. Most\nof them take two arguments.  The first is the input term and the second\nis a pointer to the output value or a term reference.\n\n\\begin{description}\n    \\cfunction{int}{PL_get_atom}{term_t +t, atom_t *a}\nIf \\arg{t} is an atom, store the unique atom identifier over \\arg{a}.\nSee also PL_atom_chars() and PL_new_atom(). If there is no need to\naccess the data (characters) of an atom, it is advised to manipulate\natoms using their handle.  As the atom is referenced by \\arg{t}, it\nwill live at least as long as \\arg{t} does.  If longer live-time is\nrequired, the atom should be locked using PL_register_atom().\n\n    \\cfunction{int}{PL_get_atom_chars}{term_t +t, char **s}\nIf \\arg{t} is an atom, store a pointer to a 0-terminated C-string in\n\\arg{s}.  It is explicitly \\strong{not} allowed to modify the contents\nof this string.  Some built-in atoms may have the string allocated in\nread-only memory, so `temporary manipulation' can cause an error.\n\n    \\cfunction{int}{PL_get_string_chars}{term_t +t, char **s, size_t *len}\nIf \\arg{t} is a string object, store a pointer to a 0-terminated\nC-string in \\arg{s} and the length of the string in \\arg{len}.  Note\nthat this pointer is invalidated by backtracking, garbage collection\nand stack-shifts, so generally the only save operations are to pass\nit immediately to a C function that doesn't involve Prolog.\n\n    \\cfunction{int}{PL_get_chars}{term_t +t, char **s, unsigned flags}\nConvert the argument term \\arg{t} to a 0-terminated C-string.  {\\em\nflags} is a bitwise disjunction from two groups of constants.  The\nfirst specifies which term types should be converted and the second\nhow the argument is stored.  Below is a specification of these\nconstants.  \\const{BUF_RING} implies, if the data is not static\n(as from an atom), that the data is copied to the next buffer from a\nring of 16 buffers.  This is a convenient way of converting\nmultiple arguments passed to a foreign predicate to C-strings.  If\nBUF_MALLOC is used, the data must be freed using PL_free() when no longer\nneeded.\n\nWith the introduction of wide characters (see \\secref{encoding}), not\nall atoms can be converted into a \\ctype{char*}.  This function fails\nif \\arg{t} is of the wrong type, but also if the text cannot be\nrepresented.  See the \\const{REP_*} flags below for details.\n\n\\begin{description}\n    \\termitem{CVT_ATOM}{}\nConvert if term is an atom.\n\n    \\termitem{CVT_STRING}{}\nConvert if term is a string.\n\n    \\termitem{CVT_LIST}{}\nConvert if term is a list of of character codes.\n\n    \\termitem{CVT_INTEGER}{}\nConvert if term is an integer.\n\n    \\termitem{CVT_FLOAT}{}\nConvert if term is a float.  The characters returned are the same as\nwrite/1 would write for the floating point number.\n\n    \\termitem{CVT_NUMBER}{}\nConvert if term is an integer or float.\n\n    \\termitem{CVT_ATOMIC}{}\nConvert if term is atomic.\n\n    \\termitem{CVT_VARIABLE}{}\nConvert variable to print-name\n\n    \\termitem{CVT_WRITE}{}\nConvert any term that is not converted by any of the other flags using\nwrite/1. If no \\const{BUF_*} is provided, \\const{BUF_RING} is implied.\n\n    \\termitem{CVT_WRITE_CANONICAL}{}\nAs \\const{CVT_WRITE}, but using write_canonical/2.\n\n    \\termitem{CVT_WRITEQ}{}\nAs \\const{CVT_WRITE}, but using writeq/2.\n\n    \\termitem{CVT_ALL}{}\nConvert if term is any of the above, except for \\const{CVT_VARIABLE} and\n\\const{CVT_WRITE*}.\n\n    \\termitem{CVT_EXCEPTION}{}\nIf conversion fails due to a type error, raise a Prolog type error\nexception in addition to failure\n\n    \\termitem{BUF_DISCARDABLE}{}\nData must copied immediately\n\n    \\termitem{BUF_RING}{}\nData is stored in a ring of buffers\n\n    \\termitem{BUF_MALLOC}{}\nData is copied to a new buffer returned by \\manref{PL_malloc}{3}. When\nno longer needed the user must call PL_free() on the data.\n\n    \\termitem{REP_ISO_LATIN_1}{}\nText is in ISO Latin-1 encoding and the call fails if text\ncannot be represented.  This flag has the value 0 and is thus the\ndefault.\n\n    \\termitem{REP_UTF8}{}\nConvert the text to a UTF-8 string. This works for all text.\n\n    \\termitem{REP_MB}{}\nConvert to default locale-defined 8-bit string. Success depends on the\nlocale. Conversion is done using the wcrtomb() C library function.\n\\end{description}\n\n\n\\cfunction{int}{PL_get_list_chars}{+term_t l, char **s, unsigned flags}\nSame as \\exam{PL_get_chars(\\arg{l}, \\arg{s}, CVT_LIST|\\arg{flags})},\nprovided \\arg{flags} contains none of the {\\tt CVT_*} flags.\n\\cfunction{int}{PL_get_integer}{+term_t t, int *i}\nIf \\arg{t} is a Prolog integer, assign its value over \\arg{i}.  On\n32-bit machines, this is the same as PL_get_long(), but avoids a\nwarning from the compiler.  See also PL_get_long().\n\n\\cfunction{int}{PL_get_long}{term_t +t, long *i}\nIf \\arg{t} is a Prolog integer that can be represented as a long, assign\nits value over \\arg{i}. If \\arg{t} is an integer that cannot be\nrepresented by a C long, this function returns \\const{FALSE}. If \\arg{t}\nis a floating point number that can be represented as a long, this\nfunction succeeds as well.  See also PL_get_int64().\n\n\\cfunction{int}{PL_get_int64}{term_t +t, int64_t *i}\nIf \\arg{t} is a Prolog integer or float that can be represented as a\n\\ctype{int64_t}, assign its value over \\arg{i}.\n\n\\cfunction{int}{PL_get_intptr}{term_t +t, intptr_t *i}\nGet an integer that is at least as wide as a pointer. On most\nplatforms this is the same as PL_get_long(), but on Win64 pointers are 8\nbytes and longs only 4. Unlike PL_get_pointer(), the value is not\nmodified.\n\n\\cfunction{int}{PL_get_bool}{term_t +t, int *val}\nIf \\arg{t} has the value \\const{true} or \\const{false}, set \\arg{val}\nto the C constant \\const{TRUE} or \\const{FALSE} and return success,\notherwise return failure.\n\\cfunction{int}{PL_get_pointer}{term_t +t, void **ptr}\nIn the current system, pointers are represented by Prolog integers,\nbut need some manipulation to make sure they do not get truncated due\nto the limited Prolog integer range.  PL_put_pointer() and PL_get_pointer()\nguarantee pointers in the range of malloc() are handled without\ntruncating.\n\\cfunction{int}{PL_get_float}{term_t +t, double *f}\nIf \\arg{t} is a float or integer, its value is assigned over \\arg{f}.\n\\cfunction{int}{PL_get_functor}{term_t +t, functor_t *f}\nIf \\arg{t} is compound or an atom, the Prolog representation of the\nname-arity pair will be assigned over \\arg{f}. See also\nPL_get_name_arity() and PL_is_functor().\n\n\\cfunction{int}{PL_get_name_arity}{term_t +t, atom_t *name, size_t *arity}\nIf \\arg{t} is compound or an atom, the functor name will be assigned\nover \\arg{name} and the arity over \\arg{arity}. See also\nPL_get_functor() and PL_is_functor().  See \\secref{pl-arity-as-size}.\n\n\\cfunction{int}{PL_get_compound_name_arity}{term_t +t, atom_t *name, size_t *arity}\nIf \\arg{t} is compound term, the functor name will be assigned over\n\\arg{name} and the arity over \\arg{arity}.  This is the same as\nPL_get_name_arity(), but this function fails if \\arg{t} is an atom.\n\n\\cfunction{int}{PL_get_module}{term_t +t, module_t *module}\nIf \\arg{t} is an atom, the system will look up or create the\ncorresponding module and assign an opaque pointer to it over {\\em\nmodule}.\n\\cfunction{int}{PL_get_arg}{size_t index, term_t +t, term_t -a}\nIf \\arg{t} is compound and index is between 1 and arity (inclusive),\nassign \\arg{a} with a term reference to the argument.\n\\cfunction{int}{_PL_get_arg}{size_t index, term_t +t, term_t -a}\nSame as PL_get_arg(), but no checking is performed, neither whether \\arg{t}\nis actually a term nor whether \\arg{index} is a valid argument index.\n\\end{description}\n\n\n\\subsubsection{Exchanging text using length and string}\n\\label{sec:foreign-text-with-length}\n\nAll internal text representation in SWI-Prolog is represented using\n\\type{char *} plus length and allow for \\jargon{0-bytes} in them.\nThe foreign library supports this by implementing a *_nchars() function\nfor each applicable *_chars() function.  Below we briefly present the\nsignatures of these functions.  For full documentation consult the\n*_chars() function.\n\n\\begin{description}\n    \\cfunction{int}{PL_get_atom_nchars}{term_t t, size_t *len, char **s}\nSee PL_get_atom_chars().\n    \\cfunction{int}{PL_get_list_nchars}{term_t t, size_t *len, char **s}\nSee PL_get_list_chars().\n    \\cfunction{int}{PL_get_nchars}{term_t t, size_t *len, char **s,\n\t\t\t\t   unsigned int flags}\nSee PL_get_chars().\n    \\cfunction{int}{PL_put_atom_nchars}{term_t t, size_t len, const char *s}\nSee PL_put_atom_chars().\n    \\cfunction{int}{PL_put_string_nchars}{term_t t, size_t len, const char *s}\nSee PL_put_string_chars().\n    \\cfunction{int}{PL_put_list_ncodes}{term_t t, size_t len, const char *s}\nSee PL_put_list_codes().\n    \\cfunction{int}{PL_put_list_nchars}{term_t t, size_t len, const char *s}\nSee PL_put_list_chars().\n    \\cfunction{int}{PL_unify_atom_nchars}{term_t t, size_t len, const char *s}\nSee PL_unify_atom_chars().\n    \\cfunction{int}{PL_unify_string_nchars}{term_t t, size_t len, const char *s}\nSee PL_unify_string_chars().\n    \\cfunction{int}{PL_unify_list_ncodes}{term_t t, size_t len, const char *s}\nSee PL_unify_codes().\n    \\cfunction{int}{PL_unify_list_nchars}{term_t t, size_t len, const char *s}\nSee PL_unify_list_chars().\n\\end{description}\n\nIn addition, the following functions are available for creating and\ninspecting atoms:\n\n\\begin{description}\n    \\cfunction{atom_t}{PL_new_atom_nchars}{size_t len, const char *s}\nCreate a new atom as PL_new_atom(), but using the given length and characters.\nIf \\arg{len} is \\exam{(size_t)-1}, it is computed from \\arg{s} using\nstrlen().\n\n    \\cfunction{const char *}{PL_atom_nchars}{atom_t a, size_t *len}\nExtract the text and length of an atom.\n\\end{description}\n\n\n\\subsubsection{Wide-character versions}\n\\label{sec:foreign-unicode}\n\nSupport for exchange of wide-character strings is still under\nconsideration. The functions dealing with 8-bit character strings\nreturn failure when operating on a wide-character atom or Prolog string\nobject. The functions below can extract and unify both 8-bit and wide\natoms and string objects. Wide character strings are represented as C\narrays of objects of the type \\ctype{pl_wchar_t}, which is guaranteed to\nbe the same as \\ctype{wchar_t} on platforms supporting this type. For\nexample, on MS-Windows, this represents 16-bit UCS2 characters, while\nusing the GNU C library (glibc) this represents 32-bit UCS4 characters.\n\n\\begin{description}\n    \\cfunction{atom_t}{PL_new_atom_wchars}{size_t len, const pl_wchar_t *s}\nCreate atom from wide-character string as PL_new_atom_nchars() does for\nISO-Latin-1 strings. If \\arg{s} only contains ISO-Latin-1 characters a\nnormal byte-array atom is created. If \\arg{len} is \\exam{(size_t)-1}, it\nis computed from \\arg{s} using wcslen().\n\n    \\cfunction{pl_wchar_t*}{PL_atom_wchars}{atom_t atom, int *len}\nExtract characters from a wide-character atom.  Succeeds on any atom\nmarked as `text'.  If the underlying atom is a wide-character atom,\nthe returned pointer is a pointer into the atom structure.  If it is\nan ISO-Latin-1 character, the returned pointer comes from Prolog's\n`buffer ring' (see PL_get_chars()).\n\n    \\cfunction{int}{PL_get_wchars}{term_t t, size_t *len,\n\t\t\t\t   pl_wchar_t **s, unsigned flags}\nWide-character version of PL_get_chars().  The \\arg{flags} argument\nis the same as for PL_get_chars().\n\n    \\cfunction{int}{PL_unify_wchars}{term_t t, int type,\n\t\t\t\t     size_t len,\n\t\t\t\t     const pl_wchar_t *s}\nUnify \\arg{t} with a textual representation of the C wide-character\narray \\arg{s}.  The \\arg{type} argument defines the Prolog\nrepresentation and is one of \\const{PL_ATOM}, \\const{PL_STRING},\n\\const{PL_CODE_LIST} or \\const{PL_CHAR_LIST}.\n    \\cfunction{int}{PL_unify_wchars_diff}{term_t +t, term_t -tail, int type,\n\t\t\t\t\t  size_t len,\n\t\t\t\t\t  const pl_wchar_t *s}\nDifference list version of PL_unify_wchars(), only supporting the\ntypes \\const{PL_CODE_LIST} and \\const{PL_CHAR_LIST}.  It serves two\npurposes.  It allows for returning very long lists from data read from\na stream without the need for a resizing buffer in C.  Also, the use of\ndifference lists is often practical for further processing in Prolog.\nExamples can be found in \\file{packages/clib/readutil.c} from the\nsource distribution.\n\\end{description}\n\n\n\\subsubsection{Reading a list}\n\\label{sec:foreign-read-list}\n\nThe functions from this section are intended to read a Prolog list from\nC.  Suppose we expect a list of atoms; the following code will print the\natoms, each on a line:\n\n\\begin{code}\nforeign_t\npl_write_atoms(term_t l)\n{ term_t head = PL_new_term_ref();   /* the elements */\n  term_t list = PL_copy_term_ref(l); /* copy (we modify list) */\n\n  while( PL_get_list(list, head, list) )\n  { char *s;\n\n    if ( PL_get_atom_chars(head, &s) )\n      Sprintf(\"%s\\n\", s);\n    else\n      PL_fail;\n  }\n\n  return PL_get_nil(list);            /* test end for [] */\n}\n\\end{code}\n\nNote that as of version~7, lists have a new representation unless the\noption \\cmdlineoption{--traditional} is used.  see \\secref{ext-lists}.\n\n\\begin{description}\n    \\cfunction{int}{PL_get_list}{term_t +l, term_t -h, term_t -t}\nIf \\arg{l} is a list and not the empty list, assign a term reference to\nthe head to \\arg{h} and to the tail to \\arg{t}.\n\n    \\cfunction{int}{PL_get_head}{term_t +l, term_t -h}\nIf \\arg{l} is a list and not the empty list, assign a term reference to\nthe head to \\arg{h}.\n\n    \\cfunction{int}{PL_get_tail}{term_t +l, term_t -t}\nIf \\arg{l} is a list and not the empty list, assign a term reference to\nthe tail to \\arg{t}.\n\n    \\cfunction{int}{PL_get_nil}{term_t +l}\nSucceeds if \\arg{l} represents the list termination constant.\n\n    \\cfunction{int}{PL_skip_list}{term_t +list, term_t -tail, size_t *len}\nThis is a multi-purpose function to deal with lists.  It allows for\nfinding the length of a list, checking whether something is a list,\netc. The reference \\arg{tail} is set to point to the end of the list,\n\\arg{len} is filled with the number of list-cells skipped, and the\nreturn value indicates the status of the list:\n\n    \\begin{description}\n\t\\constitem{PL_LIST}\n    The list is a `proper' list: one that ends in the list terminator\n    constant and \\arg{tail} is filled with the terminator constant.\n\n\t\\constitem{PL_PARTIAL_LIST}\n    The list is a `partial' list: one that ends in a variable and\n    \\arg{tail} is a reference to this variable.\n\n\t\\constitem{PL_CYCLIC_TERM}\n    The list is cyclic (e.g. X = [a|X]).  \\arg{tail} points to\n    an arbitrary cell of the list and \\arg{len} is at most twice\n    the cycle length of the list.\n\n\t\\constitem{PL_NOT_A_LIST}\n    The term \\arg{list} is not a list at all.  \\arg{tail} is\n    bound to the non-list term and \\arg{len} is set to the number\n    of list-cells skipped.\n    \\end{description}\n\nIt is allowed to pass 0 for \\arg{tail} and \\const{NULL} for \\arg{len}.\n\\end{description}\n\n\\subsubsection{An example: defining write/1 in C}\n\\label{sec:foreign-write}\n\n\\Figref{pl-display} shows a simplified definition of write/1 to\nillustrate the described functions.  This simplified version does not\ndeal with operators.  It is called display/1, because it mimics closely\nthe behaviour of this Edinburgh predicate.\n\n\\begin{figure}\n\\begin{code}\nforeign_t\npl_display(term_t t)\n{ functor_t functor;\n  int arity, len, n;\n  char *s;\n\n  switch( PL_term_type(t) )\n  { case PL_VARIABLE:\n    case PL_ATOM:\n    case PL_INTEGER:\n    case PL_FLOAT:\n      PL_get_chars(t, &s, CVT_ALL);\n      Sprintf(\"%s\", s);\n      break;\n    case PL_STRING:\n      PL_get_string_chars(t, &s, &len);\n      Sprintf(\"\\\"%s\\\"\", s);\n      break;\n    case PL_TERM:\n    { term_t a = PL_new_term_ref();\n\n      PL_get_name_arity(t, &name, &arity);\n      Sprintf(\"%s(\", PL_atom_chars(name));\n      for(n=1; n<=arity; n++)\n      { PL_get_arg(n, t, a);\n        if ( n > 1 )\n          Sprintf(\", \");\n        pl_display(a);\n      }\n      Sprintf(\")\");\n      break;\n    default:\n      PL_fail;                          /* should not happen */\n    }\n  }\n\n  PL_succeed;\n}\n\\end{code}\n\n    \\caption{A Foreign definition of display/1}\n    \\label{fig:pl-display}\n\\end{figure}\n\n\n\\subsection{Constructing Terms}\n\\label{sec:foreign-term-construct}\n\nTerms can be constructed using functions from the {\\tt PL_put_*()} and\n{\\tt PL_cons_*()} families. This approach builds the term `inside-out',\nstarting at the leaves and subsequently creating compound terms.\nAlternatively, terms may be created `top-down', first creating a\ncompound holding only variables and subsequently unifying the arguments.\nThis section discusses functions for the first approach. This approach\nis generally used for creating arguments for PL_call() and\nPL_open_query().\n\n\\begin{description}\n\\cfunction{void}{PL_put_variable}{term_t -t}\nPut a fresh variable in the term, resetting the term reference to its\ninitial state.\\footnote{Older versions created a variable on the global\nstack.}\n\\cfunction{void}{PL_put_atom}{term_t -t, atom_t a}\nPut an atom in the term reference from a handle.  See also\nPL_new_atom() and PL_atom_chars().\n\\cfunction{void}{PL_put_bool}{term_t -t, int val}\nPut one of the atoms \\const{true} or \\const{false} in the term reference\nSee also PL_put_atom(), PL_unify_bool() and PL_get_bool().\n\\cfunction{int}{PL_put_chars}{term_t -t, int flags,\n\t\t\t      size_t len,\n\t\t\t      const char *chars}\nNew function to deal with setting a term from a \\ctype{char*} with\nvarious encodings. The \\arg{flags} argument is a bitwise \\emph{or}\nspecifying the Prolog target type and the encoding of \\arg{chars}. A\nProlog type is one of \\const{PL_ATOM}, \\const{PL_STRING},\n\\const{PL_CODE_LIST} or \\const{PL_CHAR_LIST}. A representation is one of\n\\const{REP_ISO_LATIN_1}, \\const{REP_UTF8} or \\const{REP_MB}. See\nPL_get_chars() for a definition of the representation types. If\n\\arg{len} is \\const{-1} \\arg{chars} must be zero-terminated and the\nlength is computed from \\arg{chars} using strlen().\n\\cfunction{int}{PL_put_atom_chars}{term_t -t, const char *chars}\nPut an atom in the term reference constructed from the zero-terminated\nstring.  The string itself will never be referenced by Prolog after this\nfunction.\n\\cfunction{int}{PL_put_string_chars}{term_t -t, const char *chars}\nPut a zero-terminated string in the term reference. The data will be\ncopied.  See also PL_put_string_nchars().\n\\cfunction{int}{PL_put_string_nchars}{term_t -t,\n\t\t\t\t       size_t len,\n\t\t\t\t       const char *chars}\n\nPut a string, represented by a length/start pointer pair in the\nterm reference.  The data will be copied.  This interface can deal\nwith 0-bytes in the string.  See also \\secref{foreigndata}.\n\\cfunction{int}{PL_put_list_chars}{term_t -t, const char *chars}\nPut a list of ASCII values in the term reference.\n\\cfunction{int}{PL_put_integer}{term_t -t, long i}\nPut a Prolog integer in the term reference.\n\\cfunction{int}{PL_put_int64}{term_t -t, int64_t i}\nPut a Prolog integer in the term reference.\n\\cfunction{int}{PL_put_pointer}{term_t -t, void *ptr}\nPut a Prolog integer in the term reference.  Provided \\arg{ptr} is in the\n`malloc()-area', PL_get_pointer() will get the pointer back.\n\\cfunction{int}{PL_put_float}{term_t -t, double f}\nPut a floating-point value in the term reference.\n\n    \\cfunction{int}{PL_put_functor}{term_t -t, functor_t functor}\nCreate a new compound term from \\arg{functor} and bind \\arg{t} to\nthis term. All arguments of the term will be variables. To create\na term with instantiated arguments, either instantiate the arguments\nusing the {\\tt PL_unify_*()} functions or use PL_cons_functor().\n\n    \\cfunction{int}{PL_put_list}{term_t -l}\nAs PL_put_functor(), using the list-cell functor. Note that on classical\nProlog systems or in SWI-Prolog using the option\n\\cmdlineoption{--traditional}, this is \\functor{.}{2}, while on\nSWI-Prolog version~7 this is \\functor{[|]}{2}.\n\n    \\cfunction{int}{PL_put_nil}{term_t -l}\nPut the list terminator constant in \\arg{l}. Always returns\n\\const{TRUE}. Note that in classical Prolog systems or in SWI-Prolog\nusing the option \\cmdlineoption{--traditional}, this is the same as\n\\exam{PL_put_atom_chars(\"[]\")}. See \\secref{ext-lists}.\n\n    \\cfunction{void}{PL_put_term}{term_t -t1, term_t +t2}\nMake \\arg{t1} point to the same term as \\arg{t2}.\n\n    \\cfunction{int}{PL_cons_functor}{term_t -h, functor_t f, \\ldots}\nCreate a term whose arguments are filled from a variable argument list\nholding the same number of \\ctype{term_t} objects as the arity of the functor.\nTo create the term \\exam{animal(gnu, 50)}, use:\n\n\\begin{code}\n{ term_t a1 = PL_new_term_ref();\n  term_t a2 = PL_new_term_ref();\n  term_t t  = PL_new_term_ref();\n  functor_t animal2;\n\n  /* animal2 is a constant that may be bound to a global\n     variable and re-used\n  */\n  animal2 = PL_new_functor(PL_new_atom(\"animal\"), 2);\n\n  PL_put_atom_chars(a1, \"gnu\");\n  PL_put_integer(a2, 50);\n  PL_cons_functor(t, animal2, a1, a2);\n}\n\\end{code}\n\n\nAfter this sequence, the term references \\arg{a1} and \\arg{a2} may\nbe used for other purposes.\n\\cfunction{int}{PL_cons_functor_v}{term_t -h, functor_t f, term_t a0}\nCreate a compound term like PL_cons_functor(), but \\arg{a0} is an\narray of term references as returned by PL_new_term_refs().  The length\nof this array should match the number of arguments required by the\nfunctor.\n\\cfunction{int}{PL_cons_list}{term_t -l, term_t +h, term_t +t}\nCreate a list (cons-) cell in \\arg{l} from the head \\arg{h} and tail \\arg{t}.  The\ncode below creates a list of atoms from a \\ctype{char **}.  The list\nis built tail-to-head.  The {\\tt PL_unify_*()} functions can be used\nto build a list head-to-tail.\n\n\\begin{code}\nvoid\nput_list(term_t l, int n, char **words)\n{ term_t a = PL_new_term_ref();\n\n  PL_put_nil(l);\n  while( --n >= 0 )\n  { PL_put_atom_chars(a, words[n]);\n    PL_cons_list(l, a, l);\n  }\n}\n\\end{code}\nNote that \\arg{l} can be redefined within a {\\tt PL_cons_list} call as\nshown here because operationally its old value is consumed before its\nnew value is set.\n\\end{description}\n\n\n\\subsection{Unifying data}\n\\label{sec:foreign-unify}\n\nThe functions of this section \\jargon{unify} terms with other terms or\ntranslated C data structures. Except for PL_unify(), these functions\nare specific to SWI-Prolog. They have been introduced\nbecause they shorten the code for returning data to Prolog and at the\nsame time make this more efficient by avoiding the need to allocate\ntemporary term references and reduce the number of calls to the Prolog\nAPI. Consider the case where we want a foreign function to return the\nhost name of the machine Prolog is running on. Using the {\\tt\nPL_get_*()} and {\\tt PL_put_*()} functions, the code becomes:\n\n\\begin{code}\nforeign_t\npl_hostname(term_t name)\n{ char buf[100];\n\n  if ( gethostname(buf, sizeof(buf)) )\n  { term_t tmp = PL_new_term_ref();\n\n    PL_put_atom_chars(tmp, buf);\n    return PL_unify(name, tmp);\n  }\n\n  PL_fail;\n}\n\\end{code}\n\nUsing PL_unify_atom_chars(), this becomes:\n\n\\begin{code}\nforeign_t\npl_hostname(term_t name)\n{ char buf[100];\n\n  if ( gethostname(buf, sizeof(buf)) )\n    return PL_unify_atom_chars(name, buf);\n\n  PL_fail;\n}\n\\end{code}\n\nNote that unification functions that perform multiple bindings may leave\npart of the bindings in case of failure. See PL_unify() for details.\n\n\n\\begin{description}\n    \\cfunction{int}{PL_unify}{term_t ?t1, term_t ?t2}\nUnify two Prolog terms and return \\const{TRUE} on success.\n\nCare is needed if PL_unify() returns \\const{FAIL} and the foreign\nfunction does not \\emph{immediately} return to Prolog with \\const{FAIL}.\nUnification may perform multiple changes to either \\arg{t1} or \\arg{t2}.\nA failing unification may have created bindings before failure is\ndetected. \\emph{Already created bindings are not undone}. For\nexample, calling PL_unify() on \\term{a}{X, a} and \\term{a}{c,b} binds\n\\arg{X} to \\const{c} and fails when trying to unify \\const{a} to\n\\const{b}. If control remains in C or even if we want to return success\nto Prolog, we \\emph{must} undo such bindings. This is achieved using\nPL_open_foreign_frame() and PL_rewind_foreign_frame(), as shown in the\nsnippet below.\n\n\\begin{code}\n    { fid_t fid = PL_open_foreign_frame();\n\n      ...\n      if ( !PL_unify(t1, t2) )\n        PL_rewind_foreign_frame(fid);\n      ...\n\n      PL_close_foreign_frame(fid);\n    }\n\\end{code}\n\nIn addition, PL_unify() may have failed on an \\textbf{exception},\ntypically a resource (stack) overflow. This can be tested using\nPL_exception(), passing 0 (zero) for the query-id argument. Foreign\nfunctions that encounter an exception must return \\const{FAIL} to\nProlog as soon as possible or call PL_clear_exception() if they wish\nto ignore the exception.\n\n    \\cfunction{int}{PL_unify_atom}{term_t ?t, atom_t a}\nUnify \\arg{t} with the atom \\arg{a} and return non-zero on success.\n\n    \\cfunction{int}{PL_unify_bool}{term_t ?t, int a}\nUnify \\arg{t} with either \\const{true} or \\const{false}.\n\n    \\cfunction{int}{PL_unify_chars}{term_t ?t, int flags,\n\t\t\t\t    size_t len,\n\t\t\t\t    const char *chars}\nNew function to deal with unification of \\ctype{char*} with various\nencodings to a Prolog representation. The \\arg{flags} argument is a\nbitwise \\emph{or} specifying the Prolog target type and the encoding of\n\\arg{chars}. A Prolog type is one of \\const{PL_ATOM}, \\const{PL_STRING},\n\\const{PL_CODE_LIST} or \\const{PL_CHAR_LIST}. A representation is one of\n\\const{REP_ISO_LATIN_1}, \\const{REP_UTF8} or \\const{REP_MB}. See\nPL_get_chars() for a definition of the representation types. If\n\\arg{len} is \\const{-1} \\arg{chars} must be zero-terminated and the length\nis computed from \\arg{chars} using strlen().\n\nIf \\arg{flags} includes \\const{PL_DIFF_LIST} and type is one of\n\\const{PL_CODE_LIST} or \\const{PL_CHAR_LIST}, the text is converted\nto a \\jargon{difference list}.  The tail of the difference list is\n$t+1$.\n\n    \\cfunction{int}{PL_unify_atom_chars}{term_t ?t, const char *chars}\nUnify \\arg{t} with an atom created from \\arg{chars}  and return non-zero\non success.\n\n    \\cfunction{int}{PL_unify_list_chars}{term_t ?t, const char *chars}\nUnify \\arg{t} with a list of ASCII characters constructed from\n\\arg{chars}.\n\n    \\cfunction{void}{PL_unify_string_chars}{term_t ?t, const char *chars}\nUnify \\arg{t} with a Prolog string object created from the\nzero-terminated string \\arg{chars}. The data will be copied.\nSee also PL_unify_string_nchars().\n    \\cfunction{int}{PL_unify_integer}{term_t ?t, intptr_t n}\nUnify \\arg{t} with a Prolog integer from \\arg{n}.\n    \\cfunction{int}{PL_unify_int64}{term_t ?t, int64_t n}\nUnify \\arg{t} with a Prolog integer from \\arg{n}.\n    \\cfunction{int}{PL_unify_uint64}{term_t ?t, uint64_t n}\nUnify \\arg{t} with a Prolog integer from \\arg{n}.  Note that unbounded\ninteger support is required if \\arg{n} does not fit in a \\emph{signed}\n\\ctype{int64_t}.  If unbounded integers are not supported a\n\\const{representation_error} is raised.\n    \\cfunction{int}{PL_unify_float}{term_t ?t, double f}\nUnify \\arg{t} with a Prolog float from \\arg{f}.\n    \\cfunction{int}{PL_unify_pointer}{term_t ?t, void *ptr}\nUnify \\arg{t} with a Prolog integer describing the pointer. See also\nPL_put_pointer() and PL_get_pointer().\n\n    \\cfunction{int}{PL_unify_functor}{term_t ?t, functor_t f}\nIf \\arg{t} is a compound term with the given functor, just succeed.\nIf it is unbound, create a term and bind the variable, else fail.\nNote that this function does not create a term if the argument is\nalready instantiated.  If \\arg{f} is a functor with arity 0, \\arg{t}\nis unified with an atom.  See also PL_unify_compound().\n\n    \\cfunction{int}{PL_unify_compound}{term_t ?t, functor_t f}\nIf \\arg{t} is a compound term with the given functor, just succeed.\nIf it is unbound, create a term and bind the variable, else fail.\nNote that this function does not create a term if the argument is\nalready instantiated.  If \\arg{f} is a functor with arity 0, \\arg{t}\nis unified with compound without arguments. See also\nPL_unify_functor().\n\n    \\cfunction{int}{PL_unify_list}{term_t ?l, term_t -h, term_t -t}\nUnify \\arg{l} with a list-cell ({\\tt ./2}). If successful, write a\nreference to the head of the list into \\arg{h} and a reference\nto the tail of the list into \\arg{t}. This reference may be used for\nsubsequent calls to this function. Suppose we want to return a list of\natoms from a \\ctype{char **}. We could use the example described by\nPL_put_list(), followed by a call to PL_unify(), or we can use the code\nbelow. If the predicate argument is unbound, the difference is minimal\n(the code based on PL_put_list() is probably slightly faster). If the\nargument is bound, the code below may fail before reaching the end of\nthe word list, but even if the unification succeeds, this code avoids a\nduplicate (garbage) list and a deep unification.\n\n\\begin{code}\nforeign_t\npl_get_environ(term_t env)\n{ term_t l = PL_copy_term_ref(env);\n  term_t a = PL_new_term_ref();\n  extern char **environ;\n  char **e;\n\n  for(e = environ; *e; e++)\n  { if ( !PL_unify_list(l, a, l) ||\n         !PL_unify_atom_chars(a, *e) )\n      PL_fail;\n  }\n\n  return PL_unify_nil(l);\n}\n\\end{code}\n\\cfunction{int}{PL_unify_nil}{term_t ?l}\nUnify \\arg{l} with the atom \\const{[]}.\n\\cfunction{int}{PL_unify_arg}{int index, term_t ?t, term_t ?a}\nUnifies the {\\em index-th} argument (1-based) of \\arg{t} with\n\\arg{a}.\n\\cfunction{int}{PL_unify_term}{term_t ?t, \\ldots}\nUnify \\arg{t} with a (normally) compound term.  The remaining arguments\nare a sequence of a type identifier followed by the required\narguments. This predicate is an extension to the Quintus and SICStus\nforeign interface from which the SWI-Prolog foreign interface has been\nderived, but has proved to be a powerful and comfortable way to create\ncompound terms from C.  Due to the vararg packing/unpacking and the\nrequired type-switching this interface is slightly slower than using\nthe primitives.  Please note that some bad C compilers have fairly\nlow limits on the number of arguments that may be passed to a function.\n\nSpecial attention is required when passing numbers. C `promotes' any\nintegral smaller than \\type{int} to \\type{int}. That is, the types\n\\type{char}, \\type{short} and \\type{int} are all passed as \\type{int}.\nIn addition, on most 32-bit platforms \\type{int} and \\type{long} are the\nsame. Up to version 4.0.5, only \\const{PL_INTEGER} could be specified,\nwhich was taken from the stack as \\type{long}. Such code fails when\npassing small integral types on machines where \\type{int} is smaller\nthan \\type{long}. It is advised to use \\const{PL_SHORT}, \\const{PL_INT}\nor \\const{PL_LONG} as appropriate. Similarly, C compilers promote\n\\type{float} to \\type{double} and therefore \\const{PL_FLOAT} and\n\\const{PL_DOUBLE} are synonyms.\n\nThe type identifiers are:\n\n\\begin{description}\n   \\definition{\\const{PL_VARIABLE} \\arg{none}}\nNo op.  Used in arguments of \\const{PL_FUNCTOR}.\n   \\definition{\\const{PL_BOOL} \\arg{int}}\nUnify the argument with \\const{true} or \\const{false}.\n   \\definition{\\const{PL_ATOM} \\arg{atom_t}}\nUnify the argument with an atom, as in PL_unify_atom().\n   \\definition{\\const{PL_CHARS} \\arg{const char *}}\nUnify the argument with an atom constructed from the C \\ctype{char *},\nas in PL_unify_atom_chars().\n   \\definition{\\const{PL_NCHARS} \\arg{size_t, const char *}}\nUnify the argument with an atom constructed from length and\n\\ctype{char*} as in PL_unify_atom_nchars().\n   \\definition{\\const{PL_UTF8_CHARS} \\arg{const char *}}\nCreate an atom from a UTF-8 string.\n   \\definition{\\const{PL_UTF8_STRING} \\arg{const char *}}\nCreate a packed string object from a UTF-8 string.\n   \\definition{\\const{PL_MBCHARS} \\arg{const char *}}\nCreate an atom from a multi-byte string in the current locale.\n   \\definition{\\const{PL_MBCODES} \\arg{const char *}}\nCreate a list of character codes from a multi-byte string in the current\nlocale.\n   \\definition{\\const{PL_MBSTRING} \\arg{const char *}}\nCreate a packed string object from a multi-byte string in the\ncurrent locale.\n   \\definition{\\const{PL_NWCHARS} \\arg{size_t, const wchar_t *}}\nCreate an atom from a length and a wide character pointer.\n   \\definition{\\const{PL_NWCODES} \\arg{size_t, const wchar_t *}}\nCreate a list of character codes from a length and a wide character pointer.\n   \\definition{\\const{PL_NWSTRING} \\arg{size_t, const wchar_t *}}\nCreate a packed string object from a length and a wide character pointer.\n   \\definition{\\const{PL_SHORT} \\arg{short}}\nUnify the argument with an integer, as in PL_unify_integer(). As\n\\type{short} is promoted to \\type{int}, \\const{PL_SHORT} is a\nsynonym for \\type{PL_INT}.\n   \\definition{\\const{PL_INTEGER} \\arg{long}}\nUnify the argument with an integer, as in PL_unify_integer().\n   \\definition{\\const{PL_INT} \\arg{int}}\nUnify the argument with an integer, as in PL_unify_integer().\n   \\definition{\\const{PL_LONG} \\arg{long}}\nUnify the argument with an integer, as in PL_unify_integer().\n   \\definition{\\const{PL_INT64} \\arg{int64_t}}\nUnify the argument with a 64-bit integer, as in PL_unify_int64().\n   \\definition{\\const{PL_INTPTR} \\arg{intptr_t}}\nUnify the argument with an integer with the same width as a pointer.\nOn most machines this is the same as \\const{PL_LONG}. but on 64-bit\nMS-Windows pointers are 64 bits while longs are only 32 bits.\n   \\definition{\\const{PL_DOUBLE} \\arg{double}}\nUnify the argument with a float, as in PL_unify_float(). Note that,\nas the argument is passed using the C vararg conventions, a float must\nbe casted to a double explicitly.\n   \\definition{\\const{PL_FLOAT} \\arg{double}}\nUnify the argument with a float, as in PL_unify_float().\n   \\definition{\\const{PL_POINTER} \\arg{void *}}\nUnify the argument with a pointer, as in PL_unify_pointer().\n   \\definition{\\const{PL_STRING} \\arg{const char *}}\nUnify the argument with a string object, as in PL_unify_string_chars().\n   \\definition{\\const{PL_TERM} \\arg{term_t}}\nUnify a subterm.  Note this may be the return value of a PL_new_term_ref()\ncall to get access to a variable.\n   \\definition{\\const{PL_FUNCTOR} \\arg{functor_t, \\ldots}}\nUnify the argument with a compound term.  This specification should be\nfollowed by exactly as many specifications as the number of arguments of\nthe compound term.\n   \\definition{\\const{PL_FUNCTOR_CHARS}\n\t       \\arg{const char *name, int arity, \\ldots}}\nCreate a functor from the given name and arity and then behave as\n\\const{PL_FUNCTOR}.\n   \\definition{\\const{PL_LIST} \\arg{int length, \\ldots}}\nCreate a list of the indicated length.  The remaining arguments contain\nthe elements of the list.\n\\end{description}\n\nFor example, to unify an argument with the term \\exam{language(dutch)},\nthe following skeleton may be used:\n\n\n\\begin{code}\nstatic functor_t FUNCTOR_language1;\n\nstatic void\ninit_constants()\n{ FUNCTOR_language1 = PL_new_functor(PL_new_atom(\"language\"),1);\n}\n\nforeign_t\npl_get_lang(term_t r)\n{ return PL_unify_term(r,\n                       PL_FUNCTOR, FUNCTOR_language1,\n                           PL_CHARS, \"dutch\");\n}\n\ninstall_t\ninstall()\n{ PL_register_foreign(\"get_lang\", 1, pl_get_lang, 0);\n  init_constants();\n}\n\\end{code}\n\n\\cfunction{int}{PL_chars_to_term}{const char *chars, term_t -t}\nParse the string \\arg{chars} and put the resulting Prolog term into\n\\arg{t}. \\arg{chars} may or may not be closed using a Prolog full-stop\n(i.e., a dot followed by a blank). Returns \\const{FALSE} if a syntax\nerror was encountered and \\const{TRUE} after successful completion.\nIn addition to returning \\const{FALSE}, the exception-term is\nreturned in \\arg{t} on a syntax error.\nSee also term_to_atom/2.\n\nThe following example builds a goal term from a string and calls it.\n\n\\begin{code}\nint\ncall_chars(const char *goal)\n{ fid_t fid = PL_open_foreign_frame();\n  term_t g = PL_new_term_ref();\n  BOOL rval;\n\n  if ( PL_chars_to_term(goal, g) )\n    rval = PL_call(goal, NULL);\n  else\n    rval = FALSE;\n\n  PL_discard_foreign_frame(fid);\n  return rval;\n}\n  ...\n  call_chars(\"consult(load)\");\n  ...\n\\end{code}\n\n\\cfunction{int}{PL_wchars_to_term}{const pl_wchar_t *chars, term_t -t}\nWide character version of PL_chars_to_term().\n\n\\cfunction{char *}{PL_quote}{int chr, const char *string}\n    Return a quoted version of \\arg{string}.  If \\arg{chr} is\n    \\verb$'\\''$, the result is a quoted atom.  If \\arg{chr} is\n    \\verb$'\"'$, the result is a string.  The result string is stored\n    in the same ring of buffers as described with the \\const{BUF_RING}\n    argument of PL_get_chars();\n\n    In the current implementation, the string is surrounded by\n    \\arg{chr} and any occurrence of \\arg{chr} is doubled.  In the\n    future the behaviour will depend on the\n    \\prologflag{character_escapes} Prolog flag.\n\\end{description}\n\n\n\\subsection{Convenient functions to generate Prolog exceptions}\n\\label{sec:cerror}\n\nThe typical implementation of a foreign predicate first uses the\nPL_get_*() functions to extract C data types from the Prolog terms.\nFailure of any of these functions is normally because the Prolog\nterm is of the wrong type.  The *_ex() family of functions are\nwrappers around (mostly) the PL_get_*() functions, such that we\ncan write code in the style below and get proper exceptions if\nan argument is uninstantiated or of the wrong type.\n\n\\begin{code}\n/** set_size(+Name:atom, +Width:int, +Height:int) is det.\n\nstatic foreign_t\nset_size(term_t name, term_t width, term_t height)\n{ char *n;\n  int w, h;\n\n  if ( !PL_get_chars(name, &n, CVT_ATOM|CVT_EXCEPTION) ||\n       !PL_get_integer_ex(with, &w) ||\n       !PL_get_integer_ex(height, &h) )\n    return FALSE;\n\n  ...\n\n}\n\\end{code}\n\n\\begin{description}\n    \\cfunction{int}{PL_get_atom_ex}{term_t t, atom_t *a}\nAs PL_get_atom(), but raises a type or instantiation error if\n\\arg{t} is not an atom.\n\n    \\cfunction{int}{PL_get_integer_ex}{term_t t, int *i}\nAs PL_get_integer(), but raises a type or instantiation error if\n\\arg{t} is not an integer, or a representation error if the Prolog\ninteger does not fit in a C \\ctype{int}.\n\n    \\cfunction{int}{PL_get_long_ex}{term_t t, long *i}\nAs PL_get_long(), but raises a type or instantiation error if\n\\arg{t} is not an atom, or a representation error if the Prolog\ninteger does not fit in a C \\ctype{long}.\n\n    \\cfunction{int}{PL_get_int64_ex}{term_t t, int64_t *i}\nAs PL_get_int64(), but raises a type or instantiation error if\n\\arg{t} is not an atom, or a representation error if the Prolog\ninteger does not fit in a C \\ctype{int64_t}.\n\n    \\cfunction{int}{PL_get_intptr_ex}{term_t t, intptr_t *i}\nAs PL_get_intptr(), but raises a type or instantiation error if\n\\arg{t} is not an atom, or a representation error if the Prolog\ninteger does not fit in a C \\ctype{intptr_t}.\n\n    \\cfunction{int}{PL_get_size_ex}{term_t t, size_t *i}\nAs PL_get_size(), but raises a type or instantiation error if\n\\arg{t} is not an atom, or a representation error if the Prolog\ninteger does not fit in a C \\ctype{size_t}.\n\n    \\cfunction{int}{PL_get_bool_ex}{term_t t, int *i}\nAs PL_get_bool(), but raises a type or instantiation error if\n\\arg{t} is not an boolean.\n\n    \\cfunction{int}{PL_get_float_ex}{term_t t, double *f}\nAs PL_get_float(), but raises a type or instantiation error if\n\\arg{t} is not a float.\n\n    \\cfunction{int}{PL_get_char_ex}{term_t t, int *p, int eof}\nGet a character code from \\arg{t}, where \\arg{t} is either an\ninteger or an atom with length one.  If \\arg{eof} is \\const{TRUE}\nand \\arg{t} is -1, \\arg{p} is filled with -1.  Raises an appropriate\nerror if the conversion is not possible.\n\n    \\cfunction{int}{PL_get_pointer_ex}{term_t t, void **addrp}\nAs PL_get_pointer(), but raises a type or instantiation error if\n\\arg{t} is not a pointer.\n\n    \\cfunction{int}{PL_get_list_ex}{term_t l, term_t h, term_t t}\nAs PL_get_list(), but raises a type or instantiation error if\n\\arg{t} is not a list.\n\n    \\cfunction{int}{PL_get_nil_ex}{term_t l}\nAs PL_get_nil(), but raises a type or instantiation error if\n\\arg{t} is not the empty list.\n\n    \\cfunction{int}{PL_unify_list_ex}{term_t l, term_t h, term_t t}\nAs PL_unify_list(), but raises a type error if \\arg{t} is not a\nvariable, list-cell or the empty list.\n\n    \\cfunction{int}{PL_unify_nil_ex}{term_t l}\nAs PL_unify_nil(), but raises a type error if \\arg{t} is not a\nvariable, list-cell or the empty list.\n\n    \\cfunction{int}{PL_unify_bool_ex}{term_t t, int val}\nAs PL_unify_bool(), but raises a type error if \\arg{t} is not a\nvariable or a boolean.\n\\end{description}\n\nThe second family of functions in this section simplifies the generation\nof ISO compatible error terms. Any foreign function that calls this\nfunction must return to Prolog with the return code of the error\nfunction or the constant \\const{FALSE}. If available, these error\nfunctions add the name of the calling predicate to the error context.\nSee also PL_raise_exception().\n\n\\begin{description}\n    \\cfunction{int}{PL_instantiation_error}{term_t culprit}\nRaise \\const{instantiation_error}.  \\arg{Culprit} is ignored, but\nshould be bound to the term that is insufficiently instantiated.  See\ninstantiation_error/1.\n\n    \\cfunction{int}{PL_uninstantiation_error}{term_t culprit}\nRaise \\exam{uninstantiation_error(culprit)}. This should be called if an\nargument that must be unbound at entry is bound to \\arg{culprit}. This\nerror is typically raised for a pure output arguments such as a newly\ncreated stream handle (e.g., the third argument of open/3).\n\n    \\cfunction{int}{PL_representation_error}{const char *resource}\nRaise \\exam{representation_error(resource)}. See representation_error/1.\n\n    \\cfunction{int}{PL_type_error}{const char *expected, term_t culprit}\nRaise \\exam{type_error(expected, culprit)}.  See type_error/2.\n\n    \\cfunction{int}{PL_domain_error}{const char *expected, term_t culprit}\nRaise \\exam{domain_error(expected, culprit)}.  See domain_error/2.\n\n    \\cfunction{int}{PL_existence_error}{const char *type, term_t culprit}\nRaise \\exam{existence_error(type, culprit)}.  See type_error/2.\n\n    \\cfunction{int}{PL_permission_error}{const char *operation,\n\t\t\t\t\t const char *type, term_t culprit}\nRaise \\exam{permission_error(operation, type, culprit)}. See\npermission_error/3.\n    \\cfunction{int}{PL_resource_error}{const char *resource}\nRaise \\exam{resource_error(resource)}. See resource_error/1.\n    \\cfunction{int}{PL_syntax_error}{const char *message, IOSTREAM *in}\nRaise \\exam{syntax_error(message)}.  If \\arg{arg} is not \\const{NULL},\nadd information about the current position of the input stream.\n\\end{description}\n\n\n\\subsection{Serializing and deserializing Prolog terms}\n\\label{sec:foreign-serialize}\n\n\\begin{description}\n    \\cfunction{int}{PL_put_term_from_chars}{term_t t, int flags,\n\t\t\t\t\t    size_t len, const char *s}\nParse the text from the C-string \\arg{s} holding \\arg{len} bytes and\nput the resulting term in \\arg{t}.  \\arg{len} can be \\exam{(size_t)-1},\nassuming a 0-terminated string.  The \\arg{flags} argument controls the\nencoding and is currently one of \\const{REP_UTF8} (string is UTF8\nencoded), \\const{REP_MB} (string is encoded in the current locale)\nor 0 (string is encoded in ISO latin 1).  The string may, but is\nnot required, to be closed by a full stop (.).\n\\end{description}\n\n\n\\subsection{BLOBS: Using atoms to store arbitrary binary data}\n\\label{sec:blob}\n\n\\index{Java}\\index{COM}\nSWI-Prolog atoms as well as strings can represent arbitrary binary data\nof arbitrary length.  This facility is attractive for storing foreign\ndata such as images in an atom.  An atom is a unique handle to this\ndata and the atom garbage collector is able to destroy atoms that\nare no longer referenced by the Prolog engine.  This property of atoms\nmakes them attractive as a handle to foreign resources, such as\nJava atoms,  Microsoft's COM objects, etc., providing safe combined\ngarbage collection.\n\nTo exploit these features safely and in an organised manner, the\nSWI-Prolog foreign interface allows for creating `atoms' with additional\ntype information. The type is represented by a structure holding C\nfunction pointers that tell Prolog how to handle releasing the atom,\nwriting it, sorting it, etc. Two atoms created with different types can\nrepresent the same sequence of bytes. Atoms are first ordered on the\nrank number of the type and then on the result of the\n\\cfuncref{compare}{} function.  Rank numbers are assigned when the\ntype is registered.\n\n\n\\subsubsection{Defining a BLOB type}\n\\label{sec:blobtype}\n\nThe type \\ctype{PL_blob_t} represents a structure with the layout\ndisplayed below. The structure contains additional fields at the\n\\ldots for internal bookkeeping as well as future extensions.\n\n\\begin{code}\ntypedef struct PL_blob_t\n{ uintptr_t\tmagic;\t\t/* PL_BLOB_MAGIC */\n  uintptr_t\tflags;\t\t/* Bitwise or of PL_BLOB_* */\n  char *\tname;\t\t/* name of the type */\n  int\t\t(*release)(atom_t a);\n  int\t\t(*compare)(atom_t a, atom_t b);\n  int\t\t(*write)(IOSTREAM *s, atom_t a, int flags);\n  void\t\t(*acquire)(atom_t a);\n  ...\n} PL_blob_t;\n\\end{code}\n\nFor each type, exactly one such structure should be allocated.  Its\nfirst field must be initialised to \\const{PL_BLOB_MAGIC}.  The\n\\arg{flags} is a bitwise \\emph{or} of the following constants:\n\n\\begin{description}\n    \\constitem{PL_BLOB_TEXT}\nIf specified the blob is assumed to contain text and is considered\na normal Prolog atom.\n\n    \\constitem{PL_BLOB_UNIQUE}\nIf specified the system ensures that the blob-handle is a unique\nreference for a blob with the given type, length and content.\nIf this flag is not specified, each lookup creates a new blob.\n\n    \\constitem{PL_BLOB_NOCOPY}\nBy default the content of the blob is copied. Using this flag the blob\nreferences the external data directly. The user must ensure the provided\npointer is valid as long as the atom lives.  If \\const{PL_BLOB_UNIQUE}\nis also specified, uniqueness is determined by comparing the pointer\nrather than the data pointed at.\n\\end{description}\n\nThe \\arg{name} field represents the type name as available to Prolog.\nSee also current_blob/2. The other fields are function pointers that must\nbe initialised to proper functions or \\const{NULL} to get the default\nbehaviour of built-in atoms. Below are the defined member functions:\n\n\\begin{description}\n    \\cfunction{void}{acquire}{atom_t a}\nCalled if a new blob of this type is created through PL_put_blob()\nor PL_unify_blob().  This callback may be used together with the\nrelease hook to deal with reference-counted external objects.\n\n    \\cfunction{int}{release}{atom_t a}\nThe blob (atom) \\arg{a} is about to be released.  This function\ncan retrieve the data of the blob using PL_blob_data().  If it\nreturns \\const{FALSE} the atom garbage collector will \\emph{not}\nreclaim the atom.\n\n    \\cfunction{int}{compare}{atom_t a, atom_t b}\nCompare the blobs \\arg{a} and \\arg{b}, both of which are of the\ntype associated to this blob type.  Return values are, as memcmp(),\n$< 0$ if \\arg{a} is less than \\arg{b}, $= 0$ if both are equal, and\n$> 0$ otherwise.\n\n    \\cfunction{int}{write}{IOSTREAM *s, atom_t a, int flags}\nWrite the content of the blob \\arg{a} to the stream \\arg{s}\nrespecting the \\arg{flags}.  The \\arg{flags} are a bitwise\n\\emph{or} of zero or more of the \\const{PL_WRT_*} flags defined in\n\\file{SWI-Prolog.h}. This prototype is available if the\nundocumented \\file{SWI-Stream.h} is included \\emph{before}\n\\file{SWI-Prolog.h}.\n\nIf this function is not provided, write/1 emits the content\nof the blob for blobs of type \\const{PL_BLOB_TEXT} or a\nstring of the format \\verb$<#$\\textit{hex data}\\verb$>$\nfor binary blobs.\n\\end{description}\n\nIf a blob type is registered from a loadable object (shared object\nor DLL) the blob type must be deregistered before the object may be\nreleased.\n\n\\begin{description}\n    \\cfunction{int}{PL_unregister_blob_type}{PL_blob_t *type}\nUnlink the blob type from the registered type and transform the type of\npossible living blobs to \\const{unregistered}, avoiding further\nreference to the type structure, functions referred by it, as well as the\ndata. This function returns \\const{TRUE} if no blobs of this type\nexisted and \\const{FALSE} otherwise. PL_unregister_blob_type() is\nintended for the uninstall() hook of foreign modules, avoiding further\nreferences to the module.\n\\end{description}\n\n\n\\subsubsection{Accessing blobs}\n\\label{sec:blobaccess}\n\nThe blob access functions are similar to the atom accessing functions.\nBlobs being atoms, the atom functions operate on blobs and vice versa.\nFor clarity and possible future compatibility issues, however, it is not\nadvised to rely on this.\n\n\\begin{description}\n    \\cfunction{int}{PL_is_blob}{term_t t, PL_blob_t **type}\nSucceeds if \\arg{t} refers to a blob, in which case \\arg{type} is\nfilled with the type of the blob.\n\n    \\cfunction{int}{PL_unify_blob}{term_t t, void *blob, size_t len,\n\t\t\t\t   PL_blob_t *type}\nUnify \\arg{t} to a new blob constructed from the given data and\nassociated to the given type.  See also PL_unify_atom_nchars().\n\n    \\cfunction{int}{PL_put_blob}{term_t t, void *blob, size_t len,\n\t\t\t\t PL_blob_t *type}\nStore the described blob in \\arg{t}.  The return value indicates whether\na new blob was allocated (\\const{FALSE}) or the blob is a reference to\nan existing blob (\\const{TRUE}).  Reporting new/existing can be used to\ndeal with external objects having their own reference counts.  If the\nreturn is \\const{TRUE} this reference count must be incremented, and it\nmust be decremented on blob destruction callback.  See also\nPL_put_atom_nchars().\n\n    \\cfunction{int}{PL_get_blob}{term_t t, void **blob, size_t *len,\n\t\t\t\t PL_blob_t **type}\nIf \\arg{t} holds a blob or atom, get the data and type and return\n\\const{TRUE}.  Otherwise return \\const{FALSE}.  Each result pointer\nmay be \\const{NULL}, in which case the requested information is\nignored.\n\n    \\cfunction{void *}{PL_blob_data}{atom_t a,\n\t\t\t\t     size_t *len,\n\t\t\t\t     PL_blob_t **type}\nGet the data and type associated to a blob.  This function is mainly\nused from the callback functions described in \\secref{blobtype}.\n\\end{description}\n\n\n\\subsection{Exchanging GMP numbers}\n\\label{sec:gmpforeign}\n\nIf SWI-Prolog is linked with the GNU Multiple Precision Arithmetic\nLibrary (GMP, used by default), the foreign interface provides functions\nfor exchanging numeric values to GMP types.  To access these functions\nthe header \\verb$<gmp.h>$ must be included \\emph{before}\n\\verb$<SWI-Prolog.h>$. Foreign code using GMP linked to SWI-Prolog asks\nfor some considerations.\n\n\\begin{itemize}\n    \\item SWI-Prolog normally rebinds the GMP allocation functions using\n    mp_set_memory_functions(). This means SWI-Prolog must be initialised\n    before the foreign code touches any GMP function.  You can call\n    \\verb$PL_action(PL_GMP_SET_ALLOC_FUNCTIONS, TRUE)$ to force Prolog's\n    GMP initialization without doing the rest of the\n    Prolog initialization.  If you do not want Prolog rebinding the\n    GMP allocation, call \\verb$PL_action(PL_GMP_SET_ALLOC_FUNCTIONS, FALSE)$\n    \\emph{before} initializing Prolog.\n\n    \\item On Windows, each DLL has its own memory pool.  To make exchange\n    of GMP numbers between Prolog and foreign code possible you must\n    either let Prolog rebind the allocation functions (default) or you\n    must recompile SWI-Prolog to link to a DLL version of the GMP\n    library.\n\\end{itemize}\n\nHere is an example exploiting the function mpz_nextprime():\n\n\\begin{code}\n#include <gmp.h>\n#include <SWI-Prolog.h>\n\nstatic foreign_t\nnext_prime(term_t n, term_t prime)\n{ mpz_t mpz;\n  int rc;\n\n  mpz_init(mpz);\n  if ( PL_get_mpz(n, mpz) )\n  { mpz_nextprime(mpz, mpz);\n\n    rc = PL_unify_mpz(prime, mpz);\n  } else\n    rc = FALSE;\n\n  mpz_clear(mpz);\n  return rc;\n}\n\ninstall_t\ninstall()\n{ PL_register_foreign(\"next_prime\", 2, next_prime, 0);\n}\n\\end{code}\n\n\\begin{description}\n    \\cfunction{int}{PL_get_mpz}{term_t t, mpz_t mpz}\nIf \\arg{t} represents an integer, \\arg{mpz} is filled with the value and\nthe function returns \\const{TRUE}. Otherwise \\arg{mpz} is untouched and\nthe function returns \\const{FALSE}.  Note that \\arg{mpz} must have been\ninitialised before calling this function and must be cleared using\nmpz_clear() to reclaim any storage associated with it.\n\n    \\cfunction{int}{PL_get_mpq}{term_t t, mpq_t mpq}\nIf \\arg{t} is an integer or rational number (term \\functor{rdiv}{2}),\n\\arg{mpq} is filled with the \\emph{normalised} rational number and the\nfunction returns \\const{TRUE}.  Otherwise \\arg{mpq} is untouched and\nthe function returns \\const{FALSE}.  Note that \\arg{mpq} must have been\ninitialised before calling this function and must be cleared using\nmpq_clear() to reclaim any storage associated with it.\n\n    \\cfunction{int}{PL_unify_mpz}{term_t t, mpz_t mpz}\nUnify \\arg{t} with the integer value represented by \\arg{mpz} and return\n\\const{TRUE} on success.  The \\arg{mpz} argument is not changed.\n\n    \\cfunction{int}{PL_unify_mpq}{term_t t, mpq_t mpq}\nUnify \\arg{t} with a rational number represented by \\arg{mpq} and return\n\\const{TRUE} on success.  Note that \\arg{t} is unified with an integer if\nthe denominator is 1.  The \\arg{mpq} argument is not changed.\n\\end{description}\n\n\n\\subsection{Calling Prolog from C}\n\\label{sec:calling-prolog-from-c}\n\nThe Prolog engine can be called from C. There are two interfaces for\nthis. For the first, a term is created that could be used as an argument\nto call/1, and then PL_call() is used to call Prolog. This system is\nsimple, but does not allow to inspect the different answers to a\nnon-deterministic goal and is relatively slow as the runtime system\nneeds to find the predicate. The other interface is based on\nPL_open_query(), PL_next_solution() and PL_cut_query() or\nPL_close_query(). This mechanism is more powerful, but also more\ncomplicated to use.\n\n\n\\subsubsection{Predicate references}\n\\label{sec:foreign-predicate-handle}\n\nThis section discusses the functions used to communicate about\npredicates. Though a Prolog predicate may be defined or not, redefined,\netc., a Prolog predicate has a handle that is neither destroyed nor moved.\nThis handle is known by the type \\ctype{predicate_t}.\n\n\\begin{description}\n    \\cfunction{predicate_t}{PL_pred}{functor_t f, module_t m}\nReturn a handle to a predicate for the specified name/arity in the given\nmodule. This function always succeeds, creating a handle for an\nundefined predicate if no handle was available.  If the module argument\n\\arg{m} is \\const{NULL}, the current context module is used.\n\n    \\cfunction{predicate_t}{PL_predicate}{const char *name, int arity,\n\t\t\t\t\t  const char* module}\nSame as PL_pred(), but provides a more convenient interface to\nthe C programmer.\n\n    \\cfunction{void}{PL_predicate_info}{predicate_t p, atom_t *n,\n\t\t\t\t\tsize_t *a, module_t *m}\nReturn information on the predicate \\arg{p}. The name is stored over\n\\arg{n}, the arity over \\arg{a}, while \\arg{m} receives the definition\nmodule. Note that the latter need not be the same as specified with\nPL_predicate(). If the predicate is imported into the module given to\nPL_predicate(), this function will return the module where the predicate\nis defined. Any of the arguments \\arg{n}, \\arg{a} and \\arg{m} can be\n\\const{NULL}.\n\\end{description}\n\n\n\\subsubsection{Initiating a query from C}\n\\label{sec:foreign-create-query}\n\nThis section discusses the functions for creating and manipulating\nqueries from C.  Note that a foreign context can have at most one\nactive query.  This implies that it is allowed to make strictly nested\ncalls between C and Prolog (Prolog calls C, calls Prolog, calls C,\netc.), but it is \\strong{not} allowed to open multiple queries and start\ngenerating solutions for each of them by calling PL_next_solution().\nBe sure to call PL_cut_query() or PL_close_query() on any query you\nopened before opening the next or returning control back to Prolog.\n\n\n\\begin{description}\n\\cfunction{qid_t}{PL_open_query}{module_t ctx, int flags,\n\t\t\t\t predicate_t p, term_t +t0}\n\nOpens a query and returns an identifier for it. \\arg{ctx} is the {\\em\ncontext module} of the goal. When \\const{NULL}, the context module of\nthe calling context will be used, or \\const{user} if there is no calling\ncontext (as may happen in embedded systems). Note that the context\nmodule only matters for \\jargon{meta-predicates}. See meta_predicate/1,\ncontext_module/1 and module_transparent/1. The \\arg{p} argument\nspecifies the predicate, and should be the result of a call to PL_pred()\nor PL_predicate(). Note that it is allowed to store this handle as\nglobal data and reuse it for future queries. The term reference \\arg{t0}\nis the first of a vector of term references as returned by\nPL_new_term_refs(n).\n\nThe \\arg{flags} arguments provides some additional options concerning\ndebugging and exception handling.  It is a bitwise \\emph{or} of the following\nvalues:\n\n\\begin{description}\n    \\definition{\\const{PL_Q_NORMAL}}\nNormal operation.  The debugger inherits its settings from the environment.\nIf an exception occurs that is not handled in Prolog, a message is printed\nand the tracer is started to debug the error.%\n\t\\footnote{Do not pass the integer 0 for normal operation, as\n\t\t  this is interpreted as \\const{PL_Q_NODEBUG} for\n\t\t  backward compatibility reasons.}\n    \\definition{\\const{PL_Q_NODEBUG}}\nSwitch off the debugger while executing the goal.  This option is used\nby many calls to hook-predicates to avoid tracing the hooks.  An example\nis print/1 calling portray/1 from foreign code.\n    \\definition{\\const{PL_Q_CATCH_EXCEPTION}}\nIf an exception is raised while executing the goal, do not report it, but\nmake it available for PL_exception().\n    \\definition{\\const{PL_Q_PASS_EXCEPTION}}\nAs \\const{PL_Q_CATCH_EXCEPTION}, but do not invalidate the exception-term\nwhile calling PL_close_query().  This option is experimental.\n    \\definition{\\const{PL_Q_ALLOW_YIELD}}\nSupport the \\const{I_YIELD} instruction for engine-based coroutining.\nSee \\nopredref{\\$engine_yield}{2} in \\file{boot/init.pl} for details.\n    \\definition{\\const{PL_Q_EXT_STATUS}}\nMake PL_next_solution() return extended status.  Instead of only\n\\const{TRUE} or \\const{FALSE} extended status as illustrated in the\nfollowing table:\n\n\\begin{center}\n\\begin{tabular}{llp{4in}}\n\\bf Extended & \\bf Normal & \\\\\n\\hline\nPL_S_EXCEPTION\t& FALSE & Exception available through PL_exception() \\\\\nPL_S_FALSE\t& FALSE & Query failed \\\\\nPL_S_TRUE\t& TRUE & Query succeeded with choicepoint \\\\\nPL_S_LAST\t& TRUE & Query succeeded without choicepoint \\\\\n\\end{tabular}\n\\end{center}\n\\end{description}\n\n\nPL_open_query() can return the query identifier `0' if there is not enough\nspace on the environment stack. This function succeeds, even if the\nreferenced predicate is not defined. In this case, running the query\nusing PL_next_solution() will return an existence_error. See\nPL_exception().\n\nThe example below opens a query to the predicate \\verb$is_a/2$ to find the\nancestor of `me'. The reference to the predicate is valid for the\nduration of the process and may be cached by the client.\n\n\\begin{code}\nchar *\nancestor(const char *me)\n{ term_t a0 = PL_new_term_refs(2);\n  static predicate_t p;\n\n  if ( !p )\n    p = PL_predicate(\"is_a\", 2, \"database\");\n\n  PL_put_atom_chars(a0, me);\n  PL_open_query(NULL, PL_Q_NORMAL, p, a0);\n  ...\n}\n\\end{code}\n\n    \\cfunction{int}{PL_next_solution}{qid_t qid}\nGenerate the first (next) solution for the given query.  The return\nvalue is \\const{TRUE} if a solution was found, or \\const{FALSE} to indicate\nthe query could not be proven.  This function may be called repeatedly\nuntil it fails to generate all solutions to the query.\n\n    \\cfunction{int}{PL_cut_query}{qid_t qid}\nDiscards the query, but does not delete any of the data created by the\nquery.  It just invalidates \\arg{qid}, allowing for a new call to\nPL_open_query() in this context.  PL_cut_query() may invoke cleanup\nhandlers (see setup_call_cleanup/3) and therefore may experience\nexceptions.  If an exception occurs the return value is \\const{FALSE}\nand the exception is accessible through \\exam{PL_exception(0)}.\n\n    \\cfunction{int}{PL_close_query}{qid_t qid}\nAs PL_cut_query(), but all data and bindings created by the query are\ndestroyed.\n\n    \\cfunction{qid_t}{PL_current_query}{void}\nReturns the query id of of the current query or \\const{0} if the\ncurrent thread is not executing any queries.\n\n    \\cfunction{int}{PL_call_predicate}{module_t m, int flags,\n\t\t\t\t       predicate_t pred, term_t +t0}\nShorthand for PL_open_query(), PL_next_solution(), PL_cut_query(),\ngenerating a single solution.  The arguments are the same as for\nPL_open_query(), the return value is the same as PL_next_solution().\n    \\cfunction{int}{PL_call}{term_t t, module_t m}\nCall term \\arg{t} just like the Prolog predicate once/1. \\arg{t} is called\nin the module \\arg{m}, or in the context module if \\arg{m} == NULL.\nReturns \\const{TRUE} if the call succeeds, \\const{FALSE} otherwise.\n\\Figref{calling} shows an example to obtain the number of\ndefined atoms. All checks are omitted to improve readability.\n\\end{description}\n\n\\subsection{Discarding Data}\n\\label{sec:foreign-discard-term-t}\n\nThe Prolog data created and term references needed to set up the call\nand/or analyse the result can in most cases be discarded right after the\ncall. PL_close_query() allows for destroying the data, while leaving\nthe term references. The calls below may be used to destroy\nterm references and data. See \\figref{calling} for an example.\n\n\\begin{description}\n\\cfunction{fid_t}{PL_open_foreign_frame}{}\nCreate a foreign frame, holding a mark that allows the system to\nundo bindings and destroy data created after it, as well as providing\nthe environment for creating term references.  This function is called\nby the kernel before calling a foreign predicate.\n\\cfunction{void}{PL_close_foreign_frame}{fid_t id}\nDiscard all term references created after the frame was opened.  All\nother Prolog data is retained.  This function is called by the kernel\nwhenever a foreign function returns control back to Prolog.\n\\cfunction{void}{PL_discard_foreign_frame}{fid_t id}\nSame as PL_close_foreign_frame(), but also undo all bindings made since\nthe open and destroy all Prolog data.\n\\cfunction{void}{PL_rewind_foreign_frame}{fid_t id}\nUndo all bindings and discard all term references created since the\nframe was created, but do not pop the frame.  That is, the same frame\ncan be rewound multiple times, and must eventually be closed or\ndiscarded.\n\\end{description}\n\nIt is obligatory to call either of the two closing functions to discard\na foreign frame.  Foreign frames may be nested.\n\n\n\\begin{figure}\n\n\\begin{code}\nint\ncount_atoms()\n{ fid_t fid = PL_open_foreign_frame();\n  term_t goal  = PL_new_term_ref();\n  term_t a1    = PL_new_term_ref();\n  term_t a2    = PL_new_term_ref();\n  functor_t s2 = PL_new_functor(PL_new_atom(\"statistics\"), 2);\n  int atoms;\n\n  PL_put_atom_chars(a1, \"atoms\");\n  PL_cons_functor(goal, s2, a1, a2);\n  PL_call(goal, NULL);         /* call it in current module */\n\n  PL_get_integer(a2, &atoms);\n  PL_discard_foreign_frame(fid);\n\n  return atoms;\n}\n\\end{code}\n\n     \\caption{Calling Prolog}\n     \\label{fig:calling}\n\\end{figure}\n\n\n\\subsection{Foreign Code and Modules}\n\\label{sec:foreign-modules}\n\nModules are identified via a unique handle.  The following functions\nare available to query and manipulate modules.\n\n\\begin{description}\n    \\cfunction{module_t}{PL_context}{}\nReturn the module identifier of the context module of the currently\nactive foreign predicate.\n\n    \\cfunction{int}{PL_strip_module}{term_t +raw, module_t *m, term_t -plain}\nUtility function. If \\arg{raw} is a term, possibly holding the module\nconstruct \\mbox{<module>{\\tt :}<rest>}, this function will make\n\\arg{plain} a reference to <rest> and fill \\arg{module *} with <module>.\nFor further nested module constructs the innermost module is returned\nvia \\arg{module *}. If \\arg{raw} is not a module construct, \\arg{raw}\nwill simply be put in \\arg{plain}. The value pointed to by \\arg{m} must\nbe initialized before calling PL_strip_module(), either to the default\nmodule or to \\const{NULL}. A \\const{NULL} value is replaced by the\ncurrent context module if \\arg{raw} carries no module. The following\nexample shows how to obtain the plain term and module if the default\nmodule is the user module:\n\n\\begin{code}\n{ module m = PL_new_module(PL_new_atom(\"user\"));\n  term_t plain = PL_new_term_ref();\n\n  PL_strip_module(term, &m, plain);\n  ...\n}\n\\end{code}\n\n\n\\cfunction{atom_t}{PL_module_name}{module_t module}\nReturn the name of \\arg{module} as an atom.\n\\cfunction{module_t}{PL_new_module}{atom_t name}\nFind an existing module or create a new module with the name \\arg{name}.\n\\end{description}\n\n\n\\subsection{Prolog exceptions in foreign code}\n\\label{sec:foreign-exceptions}\n\nThis section discusses PL_exception(), PL_throw() and\nPL_raise_exception(), the interface functions to detect and generate\nProlog exceptions from C code. PL_throw() and PL_raise_exception() from\nthe C interface raise an exception from foreign code. PL_throw()\nexploits the C function longjmp() to return immediately to the innermost\nPL_next_solution(). PL_raise_exception() registers the exception term\nand returns \\const{FALSE}. If a foreign predicate returns \\const{FALSE}, while\nan exception term is registered, a Prolog exception will be raised by\nthe virtual machine.\n\nCalling these functions outside the context of a function implementing a\nforeign predicate results in undefined behaviour.\n\nPL_exception() may be used after a call to PL_next_solution() fails,\nand returns a term reference to an exception term if an exception\nwas raised, and 0 otherwise.\n\nIf a C function implementing a predicate calls Prolog and detects\nan exception using PL_exception(), it can handle this exception or\nreturn with the exception.  Some caution is required though.  It is\n\\strong{not} allowed to call PL_close_query() or\nPL_discard_foreign_frame() afterwards, as this will invalidate the\nexception term.  Below is the code that calls a Prolog-defined\narithmetic function (see arithmetic_function/1).\n\nIf PL_next_solution() succeeds, the result is analysed and translated to\na number, after which the query is closed and all Prolog data created\nafter PL_open_foreign_frame() is destroyed. On the other hand, if\nPL_next_solution() fails and if an exception was raised, just pass it.\nOtherwise generate an exception (PL_error() is an internal call for\nbuilding the standard error terms and calling PL_raise_exception()).\nAfter this, the Prolog environment should be discarded using\nPL_cut_query() and PL_close_foreign_frame() to avoid invalidating the\nexception term.\n\n\\begin{code}\nstatic int\nprologFunction(ArithFunction f, term_t av, Number r)\n{ int arity = f->proc->definition->functor->arity;\n  fid_t fid = PL_open_foreign_frame();\n  qid_t qid;\n  int rval;\n\n  qid = PL_open_query(NULL, PL_Q_NORMAL, f->proc, av);\n\n  if ( PL_next_solution(qid) )\n  { rval = valueExpression(av+arity-1, r);\n    PL_close_query(qid);\n    PL_discard_foreign_frame(fid);\n  } else\n  { term_t except;\n\n    if ( (except = PL_exception(qid)) )\n    { rval = PL_throw(except);\t\t/* pass exception */\n    } else\n    { char *name = stringAtom(f->proc->definition->functor->name);\n\n\t\t\t\t\t/* generate exception */\n      rval = PL_error(name, arity-1, NULL, ERR_FAILED, f->proc);\n    }\n\n    PL_cut_query(qid);\t\t\t/* donot destroy data */\n    PL_close_foreign_frame(fid);\t/* same */\n  }\n\n  return rval;\n}\n\\end{code}\n\n\n\\begin{description}\n    \\cfunction{int}{PL_raise_exception}{term_t exception}\nGenerate an exception (as throw/1) and return \\const{FALSE}.  Below is\nan example returning an exception from a foreign predicate:\n\n\\begin{code}\nforeign_t\npl_hello(term_t to)\n{ char *s;\n\n  if ( PL_get_atom_chars(to, &s) )\n  { Sprintf(\"Hello \\\"%s\\\"\\n\", s);\n\n    PL_succeed;\n  } else\n  { term_t except = PL_new_term_ref();\n\n    PL_unify_term(except,\n\t\t  PL_FUNCTOR_CHARS, \"type_error\", 2,\n\t\t    PL_CHARS, \"atom\",\n\t\t    PL_TERM, to);\n\n    return PL_raise_exception(except);\n  }\n}\n\\end{code}\n    \\cfunction{int}{PL_throw}{term_t exception}\nSimilar to PL_raise_exception(), but returns using the C longjmp()\nfunction to the innermost PL_next_solution().\n\n    \\cfunction{term_t}{PL_exception}{qid_t qid}\nIf PL_next_solution() fails, this can be due to normal failure of the\nProlog call, or because an exception was raised using throw/1.  This\nfunction returns a handle to the exception term if an exception was\nraised, or 0 if the Prolog goal simply failed. If there is an exception,\nPL_exception() allocates a term-handle using PL_new_term_ref() that is\nused to return the exception term.\n\nAdditionally, \\verb$PL_exception(0)$ returns the pending exception in\nthe current query or 0 if no exception is pending. This can be used to\ncheck the error status after a failing call to, e.g., one of the\nunification functions.\n\n    \\cfunction{void}{PL_clear_exception}{void}\nTells Prolog that the encountered exception must be ignored. This\nfunction must be called if control remains in C after a previous API\ncall fails with an exception.\\footnote{This feature is non-portable.\nOther Prolog systems (e.g., YAP) have no facilities to ignore raised\nexceptions, and the design of YAP's exception handling does not support\nsuch a facility.}\n\\end{description}\n\n\n\\subsection{Catching Signals (Software Interrupts)}\t\\label{sec:csignal}\n\nSWI-Prolog offers both a C and Prolog interface to deal with software\ninterrupts (signals). The Prolog mapping is defined in\n\\secref{signal}. This subsection deals with handling signals from C.\n\nIf a signal is not used by Prolog and the handler does not call Prolog\nin any way, the native signal interface routines may be used.\n\nAny handler that wishes to call one of the Prolog interface functions\nshould call PL_sigaction() to install the handler.  PL_signal() provides\na deprecated interface that is notably not capable of properly restoring\nthe old signal status if the signal was previously handled by Prolog.\n\n\\begin{description}\n    \\cfunction{int}{PL_sigaction}{int sig, pl_sigaction_t *act,\n\t\t\t\t  pl_sigaction_t *oldact}\nInstall or query the status for signal \\arg{sig}.  The signal is\nan integer between 1 and 64, where the where the signals up to 32\nare mapped to OS signals and signals above that are handled by\nProlog's synchronous signal handling.  The \\ctype{pl_sigaction_t}\nis a struct with the following definition:\n\n\\begin{code}\ntypedef struct pl_sigaction\n{ void        (*sa_cfunction)(int);\t/* traditional C function */\n  predicate_t sa_predicate;\t\t/* call a predicate */\n  int\t      sa_flags;\t\t\t/* additional flags */\n} pl_sigaction_t;\n\\end{code}\n\nThe \\const{sa_flags} is a bitwise or of \\const{PLSIG_THROW},\n\\const{PLSIG_SYNC} and \\const{PLSIG_NOFRAME}. Signal handling is enabled\nif \\const{PLSIG_THROW} is provided, \\const{sa_cfunction} or\n\\const{sa_predicate} is provided. \\const{sa_predicate} is a predicate\nhandle for a predicate with arity~1. If no action is provided the signal\nhandling for this signal is restored to the default before\nPL_initialise() was called.\n\nFinally, 0 (zero) may be passsed for \\arg{sig}.  In that case the system\nallocates a free signal in the \\textit{Prolog range} (32\\ldots{}64).\nSuch signal handler are activated using PL_thread_raise().\n\n    \\cfunction{void (*)()}{PL_signal}{sig, func}\nThis function is equivalent to the BSD-Unix signal() function,\nregardless of the platform used.  The signal handler is blocked\nwhile the signal routine is active, and automatically reactivated\nafter the handler returns.\n\nAfter a signal handler is registered using this function, the native\nsignal interface redirects the signal to a generic signal handler inside\nSWI-Prolog. This generic handler validates the environment, creates a\nsuitable environment for calling the interface functions described in\nthis chapter and finally calls the registered user-handler.\n\nBy default, signals are handled asynchronously (i.e., at the time they\narrive). It is inherently dangerous to call extensive code fragments,\nand especially exception related code from asynchronous handlers. The\ninterface allows for \\jargon{synchronous} handling of signals. In this\ncase the native OS handler just schedules the signal using PL_raise(),\nwhich is checked by PL_handle_signals() at the call- and redo-port. This\nbehaviour is realised by \\emph{or}-ing \\arg{sig} with the constant\n\\const{PL_SIGSYNC}.%\n    \\footnote{A better default would be to use synchronous handling,\n\t      but this interface preserves backward compatibility.}\n\nSignal handling routines may raise exceptions using\nPL_raise_exception().  The use of PL_throw() is not safe.  If a synchronous\nhandler raises an exception, the exception is delayed to the next call\nto PL_handle_signals();\n\n    \\cfunction{int}{PL_raise}{int sig}\nRegister \\arg{sig} for \\emph{synchronous} handling by Prolog.\nSynchronous signals are handled at the call-port or if foreign code\ncalls PL_handle_signals().  See also thread_signal/2.\n\n    \\cfunction{int}{PL_handle_signals}{void}\nHandle any signals pending from PL_raise(). PL_handle_signals() is\ncalled at each pass through the call- and redo-port at a safe point.\nExceptions raised by the handler using PL_raise_exception() are properly\npassed to the environment.\n\nThe user may call this function inside long-running foreign functions\nto handle scheduled interrupts.  This routine returns the number of\nsignals handled.  If a handler raises an exception, the return value\nis -1 and the calling routine should return with \\const{FALSE} as\nsoon as possible.\n\n    \\cfunction{int}{PL_get_signum_ex}{term_t t, int *sig}\nExtract a signal specification from a Prolog term and store as an integer\nsignal number in \\arg{sig}.  The specification is an integer, a lowercase\nsignal name without \\const{SIG} or the full signal name.  These refer\nto the same: \\verb$9$, \\verb$kill$ and \\verb$SIGKILL$. Leaves a typed,\ndomain or instantiation error if the conversion fails.\n\\end{description}\n\n\n\\subsection{Miscellaneous}\n\\label{sec:foreign-misc}\n\n\\subsubsection{Term Comparison}\n\\label{sec:foreign-compare}\n\n\\begin{description}\n\\cfunction{int}{PL_compare}{term_t t1, term_t t2}\n    Compares two terms using the standard order of terms and returns -1,\n    0 or 1. See also compare/3.\n\\cfunction{int}{PL_same_compound}{term_t t1, term_t t2}\n    Yields \\const{TRUE} if \\arg{t1} and \\arg{t2} refer to physically\n    the same compound term and \\const{FALSE} otherwise.\n\\end{description}\n\n\\subsubsection{Recorded database}\n\\label{sec:foreign-recorded}\n\nIn some applications it is useful to store and retrieve Prolog terms\nfrom C code.  For example, the XPCE graphical environment does this for\nstoring arbitrary Prolog data as slot-data of XPCE objects.\n\nPlease note that the returned handles have no meaning at the Prolog\nlevel and the recorded terms are not visible from Prolog. The functions\nPL_recorded() and PL_erase() are the only functions that can operate on\nthe stored term.\n\nTwo groups of functions are provided.  The first group (PL_record() and\nfriends) store Prolog terms on the Prolog heap for retrieval during the\nsame session. These functions are also used by recorda/3 and friends.\nThe recorded database may be used to communicate Prolog terms between\nthreads.\n\n\\begin{description}\n\\cfunction{record_t}{PL_record}{term_t +t}\n    Record the term \\arg{t} into the Prolog database as recorda/3 and\n    return an opaque handle to the term.  The returned handle remains\n    valid until PL_erase() is called on it.  PL_recorded() is used to\n    copy recorded terms back to the Prolog stack.\n\n\\cfunction{record_t}{PL_duplicate_record}{record_t record}\n    Return a duplicate of \\arg{record}.  As records are read-only\n    objects this function merely increments the records reference\n    count.\n\n\\cfunction{int}{PL_recorded}{record_t record, term_t -t}\n    Copy a recorded term back to the Prolog stack.  The same record\n    may be used to copy multiple instances at any time to the Prolog\n    stack. Returns \\const{TRUE} on success, and \\const{FALSE} if\n    there is not enough space on the stack to accommodate the term.\n    See also PL_record() and PL_erase().\n\n\\cfunction{void}{PL_erase}{record_t record}\n    Remove the recorded term from the Prolog database, reclaiming all\n    associated memory resources.\n\\end{description}\n\nThe second group (headed by PL_record_external()) provides the same\nfunctionality, but the returned data has properties that enable storing\nthe data on an external device. It has been designed to make it possible\nto store Prolog terms fast and compact in an external database.\tHere are\nthe main features:\n\n\\begin{itemlist}\n    \\item [Independent of session]\nRecords can be communicated to another Prolog session and made visible\nusing PL_recorded_external().\n    \\item [Binary]\nThe representation is binary for maximum performance.  The returned data\nmay contain zero bytes.\n    \\item [Byte-order independent]\nThe representation can be transferred between machines with different\nbyte order.\n    \\item [No alignment restrictions]\nThere are no memory alignment restrictions and copies of the record\ncan thus be moved freely.  For example, it is possible to use this\nrepresentation to exchange terms using shared memory between different\nProlog processes.\n    \\item [Compact]\nIt is assumed that a smaller memory footprint will eventually outperform\nslightly faster representations.\n    \\item [Stable]\nThe format is designed for future enhancements without breaking\ncompatibility with older records.\n\\end{itemlist}\n\n\\begin{description}\n\\cfunction{char *}{PL_record_external}{term_t +t, size_t *len}\n    Record the term \\arg{t} into the Prolog database as recorda/3 and\n    return an opaque handle to the term.  The returned handle remains\n    valid until PL_erase_external() is called on it.\n\n    It is allowed to copy the data and use PL_recorded_external() on\n    the copy.  The user is responsible for the memory management of\n    the copy.  After copying, the original may be discarded using\n    PL_erase_external().\n\n    PL_recorded_external() is used to copy such recorded terms back to\n    the Prolog stack.\n\\cfunction{int}{PL_recorded_external}{const char *record, term_t -t}\n    Copy a recorded term back to the Prolog stack.  The same record\n    may be used to copy multiple instances at any time to the Prolog\n    stack.  See also PL_record_external() and PL_erase_external().\n\\cfunction{int}{PL_erase_external}{char *record}\n    Remove the recorded term from the Prolog database, reclaiming all\n    associated memory resources.\n\\end{description}\n\n\n\\subsubsection{Getting file names}\t\t\\label{sec:cfilenames}\n\nThe function PL_get_file_name() provides access to Prolog filenames and\nits file-search mechanism described with absolute_file_name/3. Its\nexistence is motivated to realise a uniform interface to deal with\nfile properties, search, naming conventions, etc., from foreign code.\n\n\\begin{description}\n    \\cfunction{int}{PL_get_file_name}{term_t spec, char **name, int flags}\nTranslate a Prolog term into a file name. The name is stored in the\nstatic buffer ring described with th PL_get_chars() option\n\\const{BUF_RING}. Conversion from the internal UNICODE encoding is done\nusing standard C library functions. \\arg{flags} is a bit-mask\ncontrolling the conversion process. Options are:\n\n\\begin{description}\n    \\definition{\\const{PL_FILE_ABSOLUTE}}\nReturn an absolute path to the requested file.\n    \\definition{\\const{PL_FILE_OSPATH}}\nReturn the name using the hosting OS conventions.  On MS-Windows,\n\\chr{\\} is used to separate directories rather than the canonical\n\\chr{/}.\n    \\definition{\\const{PL_FILE_SEARCH}}\nInvoke absolute_file_name/3.  This implies rules from file_search_path/2\nare used.\n    \\definition{\\const{PL_FILE_EXIST}}\nDemand the path to refer to an existing entity.\n    \\definition{\\const{PL_FILE_READ}}\nDemand read-access on the result.\n    \\definition{\\const{PL_FILE_WRITE}}\nDemand write-access on the result.\n    \\definition{\\const{PL_FILE_EXECUTE}}\nDemand execute-access on the result.\n    \\definition{\\const{PL_FILE_NOERRORS}}\nDo not raise any exceptions.\n\\end{description}\n\n\\cfunction{int}{PL_get_file_nameW}{term_t spec, wchar_t **name, int flags}\nSame as PL_get_file_name(), but returns the filename as a wide-character\nstring. This is intended for Windows to access the Unicode version of\nthe Win32 API. Note that the flag \\const{PL_FILE_OSPATH} must be\nprovided to fetch a filename in OS native (e.g., \\verb$C:\\x\\y$)\nnotation.\n\\end{description}\n\n\n\\subsubsection{Dealing with Prolog flags from C}\n\\label{sec:cprologflags}\n\nForeign code can set or create Prolog flags using PL_set_prolog_flag().\nSee set_prolog_flag/2 and create_prolog_flag/3. To retrieve the value\nof a flag you can use PL_current_prolog_flag().\n\n\\begin{description}\n    \\cfunction{int}{PL_set_prolog_flag}{const char *name, int type, ...}\nSet/create a Prolog flag from C.  \\arg{name} is the name of the affected\nflag. \\arg{type} is one of the values below, which also\ndictates the type of the final argument. The function returns\n\\const{TRUE} on success and \\const{FALSE} on failure.  This function\ncan be called \\emph{before} PL_initialise(), making the flag available\nto the Prolog startup code.\n\n\\begin{description}\n    \\definition{\\const{PL_BOOL}}\nCreate a boolean (\\const{true} or \\const{false}) flag. The argument must\nbe an \\ctype{int}.\n    \\definition{\\const{PL_ATOM}}\nCreate a flag with an atom as value. The argument must be of type\n\\ctype{const char *}.\n    \\definition{\\const{PL_INTEGER}}\nCreate a flag with an integer as value. The argument must be of type\n\\ctype{intptr_t *}.\n\\end{description}\n\\end{description}\n\n\n\\begin{description}\n    \\cfunction{int}{PL_current_prolog_flag}{atom_t name, int type, void *value}\nRetrieve the value of a Prolog flag from C.  \\arg{name} is the name of the\nflag as an \\const{atom_t} (see current_prolog_flag/2).\n\\arg{type} specifies the kind of value to be retrieved, it is one\nof the values below.  \\arg{value} is a pointer to a location where\nto store the value. The user is responsible for making sure this memory\nlocation is of the appropiate size/type (see the returned types below\nto determine the size/type).\nThe function returns \\const{TRUE} on success\nand \\const{FALSE} on failure.\n\n\\begin{description}\n    \\definition{\\const{PL_ATOM}}\nRetrieve a flag whose value is an \\const{atom}. The returned value is an atom handle of type \\ctype{atom_t}.\n    \\definition{\\const{PL_INTEGER}}\nRetrieve a flag whose value is an \\const{integer}. The returned value is an  integer of type \\ctype{int64_t}.\n    \\definition{\\const{PL_FLOAT}}\nRetrieve a flag whose value is a \\const{float}. The returned value is a floating point number of type \\ctype{double}.\n    \\definition{\\const{PL_TERM}}\nRetrieve a flag whose value is a \\const{term}. The returned value is a term handle of type \\ctype{term_t}.\n\\end{description}\n\\end{description}\n\n\\subsection{Errors and warnings}\n\\label{sec:foreign-print-warning}\n\nPL_warning() prints a standard Prolog warning message to the standard\nerror (\\const{user_error}) stream. Please note that new code should\nconsider using PL_raise_exception() to raise a Prolog exception. See\nalso \\secref{exception}.\n\n\\begin{description}\n\\cfunction{int}{PL_warning}{format, a1, \\ldots}\nPrint an error message starting with `{\\tt [WARNING: }', followed\nby the output from \\arg{format}, followed by a `\\chr{]}' and a newline.\nThen start the tracer. \\arg{format} and the arguments are the same as\nfor \\manref{printf}{2}. Always returns \\const{FALSE}.\n\\end{description}\n\n\\subsection{Environment Control from Foreign Code}\n\\label{sec:foreign-control-prolog}\n\n\\begin{description}\n\\cfunction{int}{PL_action}{int, ...}\nPerform some action on the Prolog system. \\arg{int} describes the\naction. Remaining arguments depend on the requested action. The actions\nare listed below:\n\n\\begin{description}\n    \\termitem{PL_ACTION_TRACE}{}\nStart Prolog tracer (trace/0).  Requires no arguments.\n\n    \\termitem{PL_ACTION_DEBUG}{}\nSwitch on Prolog debug mode (debug/0).  Requires no arguments.\n\n    \\termitem{PL_ACTION_BACKTRACE}{}\nPrint backtrace on current output stream.  The argument (an \\ctype{int})\nis the number of frames printed.\n\n    \\termitem{PL_ACTION_HALT}{}\nHalt Prolog execution. This action should be called rather than Unix\nexit() to give Prolog the opportunity to clean up. This call does not\nreturn. The argument (an \\ctype{int}) is the exit code. See halt/1.\n\n    \\termitem{PL_ACTION_ABORT}{}\nGenerate a Prolog abort (abort/0). This call does not return. Requires\nno arguments.\n\n    \\termitem{PL_ACTION_BREAK}{}\nCreate a standard Prolog break environment (break/0). Returns after the\nuser types the end-of-file character. Requires no arguments.\n\n    \\termitem{PL_ACTION_GUIAPP}{}\nWindows: Used to indicate to the kernel that the application is a GUI\napplication if the argument is not 0, and a console application if the\nargument is 0. If a fatal error occurs, the system uses a windows\nmessagebox to report this on a GUI application, and otherwise simply\nprints the error and exits.\n\n    \\termitem{PL_ACTION_TRADITIONAL}{}\nSame effect as using \\cmdlineoption{--traditional}.  Must be called\n\\emph{before} PL_initialise().\n\n    \\termitem{PL_ACTION_WRITE}{}\nWrite the argument, a \\ctype{char *} to the current output stream.\n\n    \\termitem{PL_ACTION_FLUSH}{}\nFlush the current output stream.  Requires no arguments.\n\n    \\termitem{PL_ACTION_ATTACH_CONSOLE}{}\nAttach a console to a thread if it does not have one. See\nattach_console/0.\n\n    \\termitem{PL_GMP_SET_ALLOC_FUNCTIONS}{}\nTakes an integer argument. If \\const{TRUE}, the GMP allocations are\nimmediately bound to the Prolog functions. If \\const{FALSE}, SWI-Prolog\nwill never rebind the GMP allocation functions. See\nmp_set_memory_functions() in the GMP documentation. The action returns\n\\const{FALSE} if there is no GMP support or GMP is already initialised.\n\\end{description}\n\\end{description}\n\n\\subsection{Querying Prolog}\n\\label{sec:foreign-query}\n\n\\begin{description}\n\\cfunction{long}{PL_query}{int}\nObtain status information on the Prolog system. The actual argument\ntype depends on the information required. \\arg{int} describes what\ninformation is wanted.%\n\t\\footnote{Returning pointers and integers as a long is bad\n\t\t  style.  The signature of this function should be\n\t\t  changed.}\nThe  options are given in \\tabref{query}.\n\n\n\\begin{table}\n\\begin{quote}\\begin{tabular}{|p{\\tableft}|p{\\linewidth-\\tableft-2cm}|}\n\\hline\n\\const{PL_QUERY_ARGC}       & Return an integer holding the number of\n                              arguments given to Prolog from Unix. \\\\\n\\const{PL_QUERY_ARGV}       & Return a \\ctype{char **} holding the argument vector\n                              given to Prolog from Unix. \\\\\n\\const{PL_QUERY_SYMBOLFILE} & Return a \\ctype{char *} holding the current symbol\n                              file of the running process. \\\\\n\\const{PL_MAX_INTEGER}      & Return a long, representing the maximal integer\n                              value represented by a Prolog integer. \\\\\n\\const{PL_MIN_INTEGER}      & Return a long, representing the minimal integer\n                              value. \\\\\n\\const{PL_QUERY_VERSION}    & Return a long, representing the version as\n                              $10,000 \\times M + 100 \\times m + p$, where\n                              $M$ is the major, $m$ the minor version number\n                              and $p$ the patch level.  For example,\n                              \\exam{20717} means \\exam{2.7.17}. \\\\\n\\const{PL_QUERY_ENCODING}    & Return the default stream encoding of\n\t\t\t       Prolog (of type \\ctype{IOENC}). \\\\\n\\const{PL_QUERY_USER_CPU}    & Get amount of user CPU time of the\n\t\t\t       process in milliseconds. \\\\\n\\hline\n\\end{tabular}\\end{quote}\n\n    \\caption{PL_query() options}\n    \\label{tab:query}\n\\end{table}\n\\end{description}\n\n\n\\subsection{Registering Foreign Predicates}\n\\label{sec:foreign-register-predicate}\n\n\\begin{description}\n\\cfunction{int}{PL_register_foreign_in_module}{char *mod,\n\t\t\t\t\t       char *name, int arity,\n\t\t\t\t\t       foreign_t (*f)(),\n\t\t\t\t\t       int flags, ...}\nRegister the C function \\arg{f} to implement a Prolog predicate. After\nthis call returns successfully a predicate with name \\arg{name} (a\n\\ctype{char *}) and arity \\arg{arity} (a C \\ctype{int}) is created in\nmodule \\arg{mod}. If \\arg{mod} is \\const{NULL}, the predicate is created\nin the module of the calling context, or if no context is present in the\nmodule \\const{user}.\n\nWhen called in Prolog, Prolog will call \\arg{function}. \\arg{flags}\nform a bitwise \\emph{or}'ed list of options for the installation. These are:\n\n\\begin{tabular}{|p{\\tableft}|p{\\linewidth-\\tableft-2cm}|}\n\\hline\n\\const{PL_FA_META}\t       & Provide meta-predicate info (see below) \\\\\n\\const{PL_FA_TRANSPARENT}      & Predicate is module transparent (deprecated) \\\\\n\\const{PL_FA_NONDETERMINISTIC} & Predicate is non-deterministic.\n                                 See also PL_retry(). \\\\\n\\const{PL_FA_NOTRACE}          & Predicate cannot be seen in the tracer \\\\\n\\const{PL_FA_VARARGS}\t       & Use alternative calling convention. \\\\\n\\hline\n\\end{tabular}\n\nIf \\const{PL_FA_META} is provided, PL_register_foreign_in_module() takes\none extra argument. This argument is of type \\ctype{const char*}. This\nstring must be exactly as long as the number of arguments of the\npredicate and filled with characters from the set \\verb$0-9:^-+?$. See\nmeta_predicate/1 for details. \\const{PL_FA_TRANSPARENT} is implied if at\nleast one meta-argument is provided (\\verb$0-9:^$). Note that\nmeta-arguments are \\emph{not always} passed as <module>:<term>. Always\nuse PL_strip_module() to extract the module and plain term from a\nmeta-argument.\\footnote{It is encouraged to pass an additional \\const{NULL}\npointer for non-meta-predicates.}\n\nPredicates may be registered either before or after PL_initialise().\nWhen registered before initialisation the registration is recorded and\nexecuted after installing the system predicates and before loading the\nsaved state.\n\nDefault calling (i.e.\\ without \\const{PL_FA_VARARGS}) \\arg{function} is\npassed the same number of \\ctype{term_t} arguments as the arity of the predicate\nand, if the predicate is non-deterministic, an extra argument of type\n\\ctype{control_t} (see \\secref{foreignnondet}). If \\const{PL_FA_VARARGS}\nis provided, \\arg{function} is called with three arguments. The first\nargument is a \\ctype{term_t} handle to the first argument. Further\narguments can be reached by adding the offset (see also\nPL_new_term_refs()). The second argument is the arity, which defines the\nnumber of valid term references in the argument vector.  The last argument\nis used for non-deterministic calls.  It is currently undocumented and should\nbe defined of type \\ctype{void*}.  Here is an example:\n\n\\begin{code}\nstatic foreign_t\natom_checksum(term_t a0, int arity, void* context)\n{ char *s;\n\n  if ( PL_get_atom_chars(a0, &s) )\n  { int sum;\n\n    for(sum=0; *s; s++)\n      sum += *s&0xff;\n\n    return PL_unify_integer(a0+1, sum&0xff);\n  }\n\n  return FALSE;\n}\n\ninstall_t\ninstall()\n{ PL_register_foreign(\"atom_checksum\", 2,\n\t\t      atom_checksum, PL_FA_VARARGS);\n}\n\\end{code}\n\n\\cfunction{int}{PL_register_foreign}{const char *name, int arity,\n\t\t\t\t     foreign_t (*function)(),\n\t\t\t\t     int flags, ...}\nSame as PL_register_foreign_in_module(), passing \\const{NULL} for the\n\\arg{module}.\n\n    \\cfunction{void}{PL_register_extensions_in_module}{const char *module,\n\t\t\t\t\t\t       PL_extension *e}\nRegister a series of predicates from an array of definitions of the type\n\\ctype{PL_extension} in the given \\arg{module}. If \\arg{module} is\n\\const{NULL}, the predicate is created in the module of the calling\ncontext, or if no context is present in the module \\const{user}.\nThe \\ctype{PL_extension} type is defined as\n\n\\begin{code}\ntypedef struct PL_extension\n{ char\t\t*predicate_name; /* Name of the predicate */\n  short\t\tarity;\t\t /* Arity of the predicate */\n  pl_function_t\tfunction;\t /* Implementing functions */\n  short\t\tflags;\t\t /* Or of PL_FA_... */\n} PL_extension;\n\\end{code}\n\nFor details, see PL_register_foreign_in_module(). Here is an example of\nits usage:\n\n\\begin{code}\nstatic PL_extension predicates[] = {\n{ \"foo\",\t1,\tpl_foo, 0 },\n{ \"bar\",\t2,\tpl_bar, PL_FA_NONDETERMINISTIC },\n{ NULL,\t\t0,\tNULL,   0 }\n};\n\nmain(int argc, char **argv)\n{ PL_register_extensions_in_module(\"user\", predicates);\n\n  if ( !PL_initialise(argc, argv) )\n    PL_halt(1);\n\n  ...\n}\n\\end{code}\n\n    \\cfunction{void}{PL_register_extensions}{ PL_extension *e}\nSame as PL_register_extensions_in_module() using \\const{NULL} for\nthe \\arg{module} argument.\n\\end{description}\n\n\n\\subsection{Foreign Code Hooks}\n\\label{sec:foreign-hooks}\n\nFor various specific applications some hooks are provided.\n\n\\begin{description}\n\\cfunction{PL_dispatch_hook_t}{PL_dispatch_hook}{PL_dispatch_hook_t}\nIf this hook is not NULL, this function is called when reading from the\nterminal. It is supposed to dispatch events when SWI-Prolog is connected\nto a window environment. It can return two values:\n\\const{PL_DISPATCH_INPUT} indicates Prolog input is available on file\ndescriptor 0 or \\const{PL_DISPATCH_TIMEOUT} to indicate a timeout. The old\nhook is returned. The type \\ctype{PL_dispatch_hook_t} is defined as:\n\n\\begin{code}\ntypedef int  (*PL_dispatch_hook_t)(void);\n\\end{code}\n    \\cfunction{void}{PL_abort_hook}{PL_abort_hook_t}\nInstall a hook when abort/0 is executed. SWI-Prolog abort/0 is\nimplemented using C setjmp()/longjmp() construct.  The hooks are\nexecuted in the reverse order of their registration after the longjmp()\ntook place and before the Prolog top level is reinvoked. The type\n    \\ctype{PL_abort_hook_t} is defined as:\n\\begin{code}\ntypedef void (*PL_abort_hook_t)(void);\n\\end{code}\n\n    \\cfunction{int}{PL_abort_unhook}{PL_abort_hook_t}\nRemove a hook installed with PL_abort_hook(). Returns \\const{FALSE} if no\nsuch hook is found, \\const{TRUE} otherwise.\n\n    \\cfunction{void}{PL_on_halt}{int (*f)(int, void *), void *closure}\nRegister the function \\arg{f} to be called if SWI-Prolog is halted. The\nfunction is called with two arguments: the exit code of the process (0\nif this cannot be determined) and the \\arg{closure} argument passed to\nthe PL_on_halt() call.  Handlers \\emph{must} return 0.  Other return\nvalues are reserved for future use. See also at_halt/1.\\bug{Although\nboth PL_on_halt() and at_halt/1 are called in FIFO order, \\emph{all}\nat_halt/1 handlers are called before \\emph{all} PL_on_halt() handlers.}\nThese handlers are called \\emph{before} system cleanup and can therefore\naccess all normal Prolog resources.  See also PL_exit_hook().\n\n    \\cfunction{void}{PL_exit_hook}{int (*f)(int, void *), void *closure}\nSimilar to PL_on_halt(), but the hooks are executed by PL_halt() instead\nof PL_cleanup() just before calling exit().\n\n    \\cfunction{PL_agc_hook_t}{PL_agc_hook}{PL_agc_hook_t new}\nRegister a hook with the atom-garbage collector (see\ngarbage_collect_atoms/0) that is called on any atom that is reclaimed.\nThe old hook is returned.  If no hook is currently defined, \\const{NULL}\nis returned. The argument of the called hook is the atom that is to be\ngarbage collected.  The return value is an \\ctype{int}.  If the return\nvalue is zero, the atom is {\\bf not} reclaimed.\nThe hook may invoke any Prolog predicate.\n\nThe example below defines a foreign library for printing the garbage\ncollected atoms for debugging purposes.\n\n\\begin{code}\n#include <SWI-Stream.h>\n#include <SWI-Prolog.h>\n\nstatic int\natom_hook(atom_t a)\n{ Sdprintf(\"AGC: deleting %s\\n\", PL_atom_chars(a));\n\n  return TRUE;\n}\n\nstatic PL_agc_hook_t old;\n\ninstall_t\ninstall()\n{ old = PL_agc_hook(atom_hook);\n}\n\ninstall_t\nuninstall()\n{ PL_agc_hook(old);\n}\n\\end{code}\n\\end{description}\n\n\n\\subsection{Storing foreign data}\t\t\\label{sec:foreigndata}\n\nWhen combining foreign code with Prolog, it can be necessary to make\ndata represented in the foreign language available to Prolog. For\nexample, to pass it to another foreign function. At the end of this\nsection, there is a partial implementation of using foreign functions to\nmanage bit-vectors. Another example is the SGML/XML library that manages\na `parser' object, an object that represents the current state of the\nparser and that can be directed to perform actions such as parsing a\ndocument or make queries about the document content.\n\nThis section provides some hints for handling foreign data in Prolog.\nThere are four options for storing such data:\n\n\\begin{itemlist}\n    \\item[Natural Prolog data]\nUses the representation one would choose if no foreign interface was\nrequired. For example, a bitvector representing a list of small integers can be\nrepresented as a Prolog list of integers.\n\n    \\item[Opaque packed data on the stacks]\nIt is possible to represent the raw binary representation of the foreign\nobject as a Prolog string (see \\secref{strings}). Strings may be created\nfrom foreign data using PL_put_string_nchars() and retrieved using\nPL_get_string_chars(). It is good practice to wrap the string in a\ncompound term with arity 1, so Prolog can identify the type. The hook\nportray/1 rules may be used to streamline printing such terms during\ndevelopment.\n\n    \\item[Opaque packed data in a blob]\nSimilar to the above solution, binary data can be stored in an atom. The\nblob interface (\\secref{blob}) provides additional facilities to assign\na type and hook-functions that act on creation and destruction of the\nunderlying atom.\n\n    \\item[Natural foreign data, passed as a pointer]\nAn alternative is to pass a pointer to the foreign data. Again, the\npointer is often wrapped in a compound term.\n\\end{itemlist}\n\n\\noindent\nThe choice may be guided using the following distinctions\n\n\\begin{itemlist}\n    \\item[Is the data opaque to Prolog]\nWith `opaque' data, we refer to data handled in foreign functions,\npassed around in Prolog, but where Prolog never examines the contents of\nthe data itself. If the data is opaque to Prolog, the selection will be\ndriven solely by simplicity of the interface and performance.\n\n    \\item[What is the lifetime of the data]\nWith `lifetime' we refer to how it is decided that the object is (or can\nbe) destroyed. We can distinguish three cases:\n\n    \\begin{enumerate}\n\t\\item\nThe object must be destroyed on backtracking and normal Prolog garbage\ncollection (i.e., it acts as a normal Prolog term). In this case,\nrepresenting the object as a Prolog string (second option above) is the\nonly feasible solution.\n\n        \\item\nThe data must survive Prolog backtracking. This leaves two options. One\nis to represent the object using a pointer and use explicit creation and\ndestruction, making the programmer responsible. The alternative is to\nuse the blob-interface, leaving destruction to the (atom) garbage\ncollector.\n\n\t\\item\nThe data lives as during the lifetime of a foreign function that\nimplements a predicate. If the predicate is deterministic, foreign\nautomatic variables are suitable. If the predicate is non-deterministic,\nthe data may be allocated using malloc() and a pointer may be passed.\nSee \\secref{foreignnondet}.\n    \\end{enumerate}\n\\end{itemlist}\n\n\n\\subsubsection{Examples for storing foreign data}\n\\label{sec:foreign-store-data}\n\nIn this section, we outline some examples, covering typical cases. In\nthe first example, we will deal with extending Prolog's data\nrepresentation with integer sets, represented as bit-vectors. Then, we\ndiscuss the outline of the DDE interface.\n\n\\paragraph{Integer sets} with not-too-far-apart upper- and lower-bounds\ncan be represented using bit-vectors. Common set operations, such as\nunion, intersection, etc., are reduced to simple \\emph{and}'ing and\n\\emph{or}'ing the bit-vectors. This can be done using Prolog's unbounded\nintegers.\n\nFor really demanding applications, foreign representation will perform\nbetter, especially time-wise. Bit-vectors are naturally expressed using\nstring objects. If the string is wrapped in \\functor{bitvector}{1},\nthe lower-bound of the vector is 0 and the upper-bound is not defined; an\nimplementation for getting and putting the sets as well as the\nunion predicate for it is below.\n\n\\begin{code}\n#include <SWI-Prolog.h>\n\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nstatic functor_t FUNCTOR_bitvector1;\n\nstatic int\nget_bitvector(term_t in, int *len, unsigned char **data)\n{ if ( PL_is_functor(in, FUNCTOR_bitvector1) )\n  { term_t a = PL_new_term_ref();\n\n    PL_get_arg(1, in, a);\n    return PL_get_string(a, (char **)data, len);\n  }\n\n  PL_fail;\n}\n\nstatic int\nunify_bitvector(term_t out, int len, const unsigned char *data)\n{ if ( PL_unify_functor(out, FUNCTOR_bitvector1) )\n  { term_t a = PL_new_term_ref();\n\n    PL_get_arg(1, out, a);\n\n    return PL_unify_string_nchars(a, len, (const char *)data);\n  }\n\n  PL_fail;\n}\n\nstatic foreign_t\npl_bitvector_union(term_t t1, term_t t2, term_t u)\n{ unsigned char *s1, *s2;\n  int l1, l2;\n\n  if ( get_bitvector(t1, &l1, &s1) &&\n       get_bitvector(t2, &l2, &s2) )\n  { int l = max(l1, l2);\n    unsigned char *s3 = alloca(l);\n\n    if ( s3 )\n    { int n;\n      int ml = min(l1, l2);\n\n      for(n=0; n<ml; n++)\n        s3[n] = s1[n] | s2[n];\n      for( ; n < l1; n++)\n        s3[n] = s1[n];\n      for( ; n < l2; n++)\n        s3[n] = s2[n];\n\n      return unify_bitvector(u, l, s3);\n    }\n\n    return PL_warning(\"Not enough memory\");\n  }\n\n  PL_fail;\n}\n\n\ninstall_t\ninstall()\n{ PL_register_foreign(\"bitvector_union\", 3, pl_bitvector_union, 0);\n\n  FUNCTOR_bitvector1 = PL_new_functor(PL_new_atom(\"bitvector\"), 1);\n}\n\\end{code}\n\n\\paragraph{The DDE interface} (see \\secref{DDE}) represents another\ncommon usage of the foreign interface: providing communication to new\noperating system features. The DDE interface requires knowledge about\nactive DDE server and client channels. These channels contains various\nforeign data types.  Such an interface is normally achieved using an\nopen/close protocol that creates and destroys a \\jargon{handle}.  The\nhandle is a reference to a foreign data structure containing the\nrelevant information.\n\nThere are a couple of possibilities for representing the handle.  The\nchoice depends on responsibilities and debugging facilities.  The\nsimplest approach is to use PL_unify_pointer() and PL_get_pointer().\nThis approach is fast and easy, but has the drawbacks of (untyped)\npointers: there is no reliable way to detect the validity of the\npointer, nor to verify that it is pointing to a structure of the desired\ntype.  The pointer may be wrapped into a compound term with arity\n1 (i.e., \\exam{dde_channel(<Pointer>)}), making the type-problem\nless serious.\n\nAlternatively (used in the DDE interface), the interface code can\nmaintain a (preferably variable length) array of pointers and return the\nindex in this array. This provides better protection. Especially for\ndebugging purposes, wrapping the handle in a compound is a good\nsuggestion.\n\n\n\\subsection{Embedding SWI-Prolog in other applications}\t\\label{sec:embedded}\n\nWith embedded Prolog we refer to the situation where the `main' program\nis not the Prolog application.  Prolog is sometimes embedded in C, C++,\nJava or other languages to provide logic based services in a larger\napplication.  Embedding loads the Prolog engine as a library to the\nexternal language.  Prolog itself only provides for embedding in the\nC language (compatible with C++).  Embedding in Java is achieved using\nJPL using a C-glue between the Java and Prolog C interfaces.\n\nThe most simple embedded program is below. The interface function\nPL_initialise() {\\bf must} be called before any of the other SWI-Prolog\nforeign language functions described in this chapter, except for\nPL_initialise_hook(), PL_new_atom(), PL_new_functor() and\nPL_register_foreign(). PL_initialise() interprets all the command line\narguments, except for the \\argoption{-t}{toplevel} flag that is\ninterpreted by PL_toplevel().\n\n\\begin{code}\nint\nmain(int argc, char **argv)\n{ if ( !PL_initialise(argc, argv) )\n    PL_halt(1);\n\n  PL_halt(PL_toplevel() ? 0 : 1);\n}\n\\end{code}\n\n\\begin{description}\n\\cfunction{int}{PL_initialise}{int argc, char **argv}\nInitialises the SWI-Prolog heap and stacks, restores the Prolog\nstate, loads the system and personal initialisation files,\nruns the initialization/1 hooks and finally runs the\n\\argoption{-g}{goal} hook.\n\nSpecial consideration is required for \\verb$argv[0]$. On {\\bf Unix},\nthis argument passes the part of the command line that is used\nto locate the executable.  Prolog uses this to find the file holding\nthe running executable.  The {\\bf Windows} version uses this to find\na \\jargon{module} of the running executable.  If the specified module\ncannot be found, it tries the module \\const{libpl.dll}, containing\nthe Prolog runtime kernel. In all these cases, the resulting file is\nused for two purposes:\n\n\\begin{itemize}\n    \\item See whether a Prolog saved state is appended to the file.\n          If this is the case, this state will be loaded instead of\n\t  the default \\file{boot.prc} file from the SWI-Prolog home\n\t  directory.  See also qsave_program/[1,2] and \\secref{plld}.\n    \\item Find the Prolog home directory.  This process is described\n          in detail in \\secref{findhome}.\n\\end{itemize}\n\nPL_initialise() returns 1 if all initialisation succeeded and 0\notherwise.%\n    \\bug{Various fatal errors may cause PL_initialise() to call\n\t PL_halt(1), preventing it from returning at all.}\n\nIn most cases, \\arg{argc} and \\arg{argv} will be passed from the main\nprogram.  It is allowed to create your own argument vector, provided\n\\verb$argv[0]$ is constructed according to the rules above.   For\nexample:\n\n\\begin{code}\nint\nmain(int argc, char **argv)\n{ char *av[10];\n  int ac = 0;\n\n  av[ac++] = argv[0];\n  av[ac++] = \"-x\";\n  av[ac++] = \"mystate\";\n  av[ac]   = NULL;\n\n  if ( !PL_initialise(ac, av) )\n    PL_halt(1);\n  ...\n}\n\\end{code}\n\nPlease note that the passed argument vector may be referred from Prolog\nat any time and should therefore be valid as long as the Prolog engine\nis used.\n\nA good setup in Windows is to add SWI-Prolog's \\file{bin} directory\nto your \\env{PATH} and either pass a module holding a saved state, or\n\\verb$\"libpl.dll\"$ as \\verb$argv[0]$.  If the Prolog state is attached\nto a DLL (see the \\cmdlineoption{-dll} option of \\program{swipl-ld}), pass\nthe name of this DLL.\n\n    \\cfunction{int}{PL_is_initialised}{int *argc, char ***argv}\nTest whether the Prolog engine is already initialised. Returns\n\\const{FALSE} if Prolog is not initialised and \\const{TRUE} otherwise.\nIf the engine is initialised and \\arg{argc} is not \\const{NULL}, the\nargument count used with PL_initialise() is stored in \\arg{argc}.  Same\nfor the argument vector \\arg{argv}.\n\n    \\cfunction{int}{PL_set_resource_db_mem}{const unsigned char *data,\n\t\t\t\t\t    size_t size}\nThis function must be called at most once and \\emph{before} calling\nPL_initialise(). The memory area designated by \\arg{data} and \\arg{size}\nmust contain the resource data and be in the format as produced by\nqsave_program/2. The memory area is accessed by PL_initialise() as well\nas calls to open_resource/3.\\footnote{This implies that the data must\nremain accessible during the lifetime of the process if open_resource/3\nis used.  Future versions may provide a function to detach the resource\ndatabase and cause open_resource/3 to raise an exception.}\n\nFor example, we can include the bootstrap data into an embedded\nexecutable using the steps below. The advantage of this approach is that\nit is fully supported by any OS and you obtain a single file executable.\n\n\\begin{enumerate}\n    \\item Create a saved state using qsave_program/2 or\n\\begin{code}\n% swipl -o state -c file.pl ...\n\\end{code}\n    \\item Create a C source file from the state using e.g., the\n    Unix utility \\program{xxd}(1):\n\\begin{code}\n% xxd -i state > state.h\n\\end{code}\n    \\item Embed Prolog as in the example below.  Instead of calling\n    the toplevel you probably want to call your application code.\n\\begin{code}\n#include <SWI-Prolog.h>\n#include \"state.h\"\n\nint\nmain(int argc, char **argv)\n{ if ( !PL_set_resource_db_mem(state, state_len) ||\n       !PL_initialise(argc, argv) )\n    PL_halt(1);\n\n  return PL_toplevel();\n}\n\\end{code}\n\\end{enumerate}\n\nAlternative to \\program{xxd}, it is possible to use inline assembler,\ne.g. the \\program{gcc} \\const{incbin} instruction. Code for\n\\program{gcc} was provided by Roberto Bagnara on the SWI-Prolog\nmailinglist.  Given the state in a file \\file{state}, create the\nfollowing assembler program:\n\n\\begin{code}\n        .globl _state\n        .globl _state_end\n_state:\n        .incbin \"state\"\n_state_end:\n\\end{code}\n\nNow include this as follows:\n\n\\begin{code}\n#include <SWI-Prolog.h>\n\n#if __linux\n#define STATE _state\n#define STATE_END _state_end\n#else\n#define STATE state\n#define STATE_END state_end\n#endif\n\nextern unsigned char STATE[];\nextern unsigned char STATE_END[];\n\nint\nmain(int argc, char **argv)\n{ if ( !PL_set_resource_db_mem(STATE, STATE_END - STATE) ||\n       !PL_initialise(argc, argv) )\n    PL_halt(1);\n  return PL_toplevel();\n}\n\\end{code}\n\nAs Jose Morales pointed at\n\\url{https://github.com/graphitemaster/incbin}, which contains a\nportability layer on top of the above idea.\n\n    \\cfunction{int}{PL_toplevel}{}\nRuns the goal of the \\argoption{-t}{toplevel} switch (default prolog/0) and\nreturns 1 if successful, 0 otherwise.\n\n    \\cfunction{int}{PL_cleanup}{int status}\nThis function performs the reverse of PL_initialise(). It runs the\nPL_on_halt() and at_halt/1 handlers, closes all streams (except for the\n`standard I/O' streams which are flushed only), deallocates all memory\nif \\arg{status} equals `0' and restores all signal handlers. The\n\\arg{status} argument is passed to the various termination hooks and\nindicates the \\jargon{exit-status}.\n\nThe function returns \\const{TRUE} if successful and \\const{FALSE}\notherwise. Currently, \\const{FALSE} is returned when an attempt is made\nto call PL_cleanup() recursively or if one of the exit handlers\ncancels the termination using cancel_halt/1.  Exit handlers may only\ncancel termination if \\arg{status} is 0.\n\nIn theory, this function allows deleting and restarting the Prolog\nsystem in the same process. In practice, SWI-Prolog's cleanup process is\nfar from complete, and trying to revive the system using PL_initialise()\nwill leak memory in the best case. It can also crash the appliction.\n\nIn this state, there is little practical use for this function. If you\nwant to use Prolog temporarily, consider running it in a separate process.\nIf you want to be able to reset Prolog, your options are (again) a\nseparate process, modules or threads.\n\n    \\cfunction{void}{PL_cleanup_fork}{}\nStop intervaltimer that may be running on behalf of profile/1.  The call\nis intended to be used in combination with fork():\n\n\\begin{code}\n    if ( (pid=fork()) == 0 )\n    { PL_cleanup_fork();\n      <some exec variation>\n    }\n\\end{code}\n\nThe call behaves the same  on  Windows,   though  there  is  probably no\nmeaningful application.\n\n    \\cfunction{int}{PL_halt}{int status}\nClean up the Prolog environment using PL_cleanup() and if successful\ncall exit() with the status argument.  Returns \\const{FALSE} if exit\nwas cancelled by PL_cleanup().\n\\end{description}\n\n\n\\subsubsection{Threading, Signals and embedded Prolog}\n\\label{sec:sigembedded}\n\nThis section applies to Unix-based environments that have signals or\nmultithreading.  The Windows version is compiled for multithreading,\nand Windows lacks proper signals.\n\nWe can distinguish two classes of embedded executables. There are small\nC/C++ programs that act as an interfacing layer around Prolog. Most of\nthese programs can be replaced using the normal Prolog executable\nextended with a dynamically loaded foreign extension and in most cases\nthis is the preferred route. In other cases, Prolog is embedded in a\ncomplex application that---like Prolog---wants to control the process\nenvironment. A good example is Java. Embedding Prolog is generally the\nonly way to get these environments together in one process image. Java\nVMs, however, are by nature multithreaded and appear to do\nsignal handling (software interrupts).\n\nOn Unix systems, SWI-Prolog installs handlers for the following\nsignals:\n\n\\begin{description}\n    \\item[SIGUSR2] has an empty signal handler.   This signal is\n    sent to a thread after sending a thread-signal (see\n    thread_signal/2).  It causes blocking system calls to return\n    with \\const{EINTR}, which gives them the opportunity to react\n    to thread-signals.\n\n    In some cases the embedded system and SWI-Prolog may both use\n    \\const{SIGUSR2} without conflict. If the embedded system redefines\n    \\const{SIGUSR2} with a handler that runs quickly and no harm is\n    done in the embedded system due to spurious wakeup when initiated\n    from Prolog, there is no problem.  If SWI-Prolog is initialised\n    \\emph{after} the embedded system it will call the handler set by\n    the embedded system and the same conditions as above apply.\n    SWI-Prolog's handler is a simple function only chaining a possibly\n    previously registered handler.  SWI-Prolog can handle spurious\n    \\const{SIGUSR2} signals.\n\n    \\item[SIGINT] is used by the top level to activate the tracer\n    (typically bound to control-C).  The first control-C posts a\n    request for\tstarting the tracer in a safe, synchronous fashion.\n    If control-C is hit again before the safe route is executed,\n    it prompts the user whether or not a forced interrupt is\n    desired.\n\n    \\item[SIGTERM, SIGABRT and SIGQUIT] are caught to cleanup before\n    killing the process again using the same signal.\n\n    \\item[SIGSEGV, SIGILL, SIGBUS, SIGFPE and SIGSYS] are caught by\n    to print a backtrace before killing the process again using\n    the same signal.\n\n    \\item[SIGHUP] is caught and causes the process to exit with status 2\n    after cleanup.\n\\end{description}\n\nThe \\cmdlineoption{--nosignals} option can be used to inhibit all signal\nprocessing except for \\const{SIGUSR2}. The handling of \\const{SIGUSR2}\nis vital for dealing with blocking system call in threads. The used\nsignal may be changed using the \\cmdlineoption{--sigalert=NUM} option or\ndisabled using \\verb$--sigalert=0$.\n\n\n\n\\section{Linking embedded applications using swipl-ld}\t\\label{sec:plld}\n\nThe utility program \\program{swipl-ld} (Win32: swipl-ld.exe) may be used to link\na combination of C files and Prolog files into a stand-alone executable.\n\\program{swipl-ld} automates most of what is described in the previous\nsections.\n\nIn normal usage, a copy is made of the default embedding template\n\\file{.../swipl/include/stub.c}. The main() routine is modified to suit\nyour application. PL_initialise() \\strong{must} be passed the\nprogram name (\\arg{argv[0]}) (Win32: the executing program can be\nobtained using GetModuleFileName()). The other elements of the\ncommand line may be modified. Next, \\program{swipl-ld} is typically invoked\nas:\n\n\\begin{code}\nswipl-ld -o output stubfile.c [other-c-or-o-files] [plfiles]\n\\end{code}\n\n\\program{swipl-ld} will first split the options into various groups for both\nthe C compiler and the Prolog compiler. Next, it will add various\ndefault options to the C compiler and call it to create an executable\nholding the user's C code and the Prolog kernel. Then, it will call the\nSWI-Prolog compiler to create a saved state from the provided Prolog\nfiles and finally, it will attach this saved state to the created\nemulator to create the requested executable.\n\nBelow, it is described how the options are split and which additional\noptions are passed.\n\n\\begin{description}\n    \\cmdlineoptionitem{-help}{}\nPrint brief synopsis.\n    \\cmdlineoptionitem{-pl}{prolog}\nSelect the Prolog to use.  This Prolog is used for two purposes: get the\nhome directory as well as the compiler/linker options and create a saved\nstate of the Prolog code.\n    \\cmdlineoptionitem{-ld}{linker}\nLinker used to link the raw executable.  Default is to use the C compiler\n(Win32: \\program{link.exe}).\n    \\cmdlineoptionitem{-cc}{C compiler}\nCompiler for \\fileext{c} files found on the command line.  Default is the\ncompiler used to build SWI-Prolog accessible through the Prolog flag\n\\prologflag{c_cc} (Win32: \\program{cl.exe}).\n    \\cmdlineoptionitem{-c++}{C++-compiler}\nCompiler for C++ source file (extensions \\fileext{cpp}, \\fileext{cxx},\n\\fileext{cc} or \\fileext{C}) found on the command line.  Default is\n\\program{c++} or \\program{g++} if the C compiler is \\program{gcc}\n(Win32: cl.exe).\n\n    \\cmdlineoptionitem{-nostate}{}\nJust relink the kernel, do not add any Prolog code to the new kernel.\nThis is used to create a new kernel holding additional foreign predicates\non machines that do not support the shared-library (DLL) interface, or if\nbuilding the state cannot be handled by the default procedure used by\n\\program{swipl-ld}.  In the latter case the state is created separately and\nappended to the kernel using \\exam{cat <kernel> <state> > <out>}\n(Win32: \\exam{copy /b <kernel>+<state> <out>}).\n\n    \\cmdlineoptionitem{-shared}{}\nLink C, C++ or object files into a shared object (DLL) that can be\nloaded by the load_foreign_library/1 predicate. If used with\n\\cmdlineoption{-c}{} it sets the proper options to compile a C or C++\nfile ready for linking into a shared object.\n\n    \\cmdlineoptionitem{-dll}{}\n\\emph{Windows only}. Embed SWI-Prolog into a DLL rather than an\nexecutable.\n\n    \\cmdlineoptionitem{-c}{}\nCompile C or C++ source files into object files. This turns\n\\program{swipl-ld} into a replacement for the C or C++ compiler, where proper\noptions such as the location of the include directory are passed\nautomatically to the compiler.\n\n    \\cmdlineoptionitem{-E}{}\nInvoke the C preprocessor. Used to make \\program{swipl-ld} a replacement for\nthe C or C++ compiler.\n\n    \\cmdlineoptionitem{-pl-options}{,\\ldots}\nAdditional options passed to Prolog when creating the saved state.  The\nfirst character immediately following \\const{pl-options} is used as\nseparator and translated to spaces when the argument is built.\nExample: \\exam{-pl-options,-F,xpce} passes \\exam{-F xpce} as additional\nflags to Prolog.\n    \\cmdlineoptionitem{-ld-options}{,\\ldots}\nPasses options to the linker, similar to \\cmdlineoption{-pl-options}.\n    \\cmdlineoptionitem{-cc-options}{,\\ldots}\nPasses options to the C/C++ compiler, similar to \\cmdlineoption{-pl-options}.\n    \\cmdlineoptionitem{-v}{}\nSelect verbose operation, showing the various programs and their options.\n    \\cmdlineoptionitem{-o}{outfile}\nReserved to specify the final output file.\n    \\cmdlineoptionitem*{-l}{library}\nSpecifies a library for the C compiler.  By default, \\clib{-lswipl}\n(Win32: libpl.lib) and the libraries needed by the Prolog kernel are given.\n    \\cmdlineoptionitem*{-L}{library-directory}\nSpecifies a library directory for the C compiler.  By default the\ndirectory containing the Prolog C library for the current architecture\nis passed.\n    \\cmdlineoptionitem{\\cmdlineoption{-g} \\bnfor{}\n\t\t       \\cmdlineoption{-I\\arg{include-directory}} \\bnfor{}\n\t\t       \\cmdlineoption{-D\\arg{definition}}}{}\nThese options are passed to the C compiler.  By default, the include\ndirectory containing \\file{SWI-Prolog.h} is passed.  \\program{swipl-ld} adds\ntwo additional \\argoption*{-D}{def} flags:\n\\begin{description}\n\\cmdlineoptionitem*{-D}{\\const{__SWI_PROLOG__}}\nIndicates the code is to be connected to SWI-Prolog.\n\\cmdlineoptionitem*{-D}{\\const{__SWI_EMBEDDED__}}\nIndicates the creation of an embedded program.\n\\end{description}\n    \\cmdlineoptionitem{}{*.o \\bnfor{}\n\t\t\t *.c \\bnfor{}\n\t\t\t *.C \\bnfor{}\n\t\t\t *.cxx \\bnfor{}\n\t\t\t *.cpp}\nPassed as input files to the C compiler.\n    \\cmdlineoptionitem{}{*.pl \\bnfor *.qlf}\nPassed as input files to the Prolog compiler to create the saved state.\n    \\cmdlineoptionitem{}{*}\nAll other options. These are passed as linker options to the\nC compiler.\n\\end{description}\n\n\n\\subsection{A simple example}\n\\label{sec:foreign-example}\n\nThe following is a very simple example going through all the steps\noutlined above. It provides an arithmetic expression evaluator. We will\ncall the application \\program{calc} and define it in the files \\file{calc.c}\nand \\file{calc.pl}.  The Prolog file is simple:\n\n\\begin{code}\ncalc(Atom) :-\n        term_to_atom(Expr, Atom),\n        A is Expr,\n        write(A),\n        nl.\n\\end{code}\n\nThe C part of the application parses the command line options,\ninitialises the Prolog engine, locates the \\verb$calc/1$ predicate and calls\nit.  The coder is in \\figref{calc}.\n\n\\begin{figure}\n\\begin{code}\n#include <stdio.h>\n#include <SWI-Prolog.h>\n\n#define MAXLINE 1024\n\nint\nmain(int argc, char **argv)\n{ char expression[MAXLINE];\n  char *e = expression;\n  char *program = argv[0];\n  char *plav[2];\n  int n;\n\n  /* combine all the arguments in a single string */\n\n  for(n=1; n<argc; n++)\n  { if ( n != 1 )\n      *e++ = ' ';\n    strcpy(e, argv[n]);\n    e += strlen(e);\n  }\n\n  /* make the argument vector for Prolog */\n\n  plav[0] = program;\n  plav[1] = NULL;\n\n  /* initialise Prolog */\n\n  if ( !PL_initialise(1, plav) )\n    PL_halt(1);\n\n  /* Lookup calc/1 and make the arguments and call */\n\n  { predicate_t pred = PL_predicate(\"calc\", 1, \"user\");\n    term_t h0 = PL_new_term_refs(1);\n    int rval;\n\n    PL_put_atom_chars(h0, expression);\n    rval = PL_call_predicate(NULL, PL_Q_NORMAL, pred, h0);\n\n    PL_halt(rval ? 0 : 1);\n  }\n\n  return 0;\n}\n\\end{code}\n\\caption{C source for the calc application}\n\\label{fig:calc}\n\\end{figure}\n\n\\noindent\nThe application is now created using the following command line:\n\n\\begin{code}\n% swipl-ld -o calc calc.c calc.pl\n\\end{code}\n\n\\noindent\nThe following indicates the usage of the application:\n\n\\begin{code}\n% calc pi/2\n1.5708\n\\end{code}\n\n\n\\section{The Prolog `home' directory}\t\t\\label{sec:findhome}\n\nExecutables embedding SWI-Prolog should be able to find the `home'\ndirectory of the development environment unless a self-contained\nsaved state has been added to the executable (see qsave_program/[1,2]\nand \\secref{plld}).\n\nIf Prolog starts up, it will try to locate the development environment.\nTo do so, it will try the following steps until one succeeds:\n\n\\begin{enumerate}\n    \\item If the \\cmdlineoption{--home=DIR} is provided, use this.\n    \\item If the environment variable \\env{SWI_HOME_DIR} is defined and\n          points to an existing directory, use this.\n    \\item If the environment variable \\env{SWIPL} is defined and\n          points to an existing directory, use this.\n    \\item Locate the primary executable or (Windows only) a component\n          (\\jargon{module}) thereof and check whether the parent\n\t  directory of the directory holding this file contains the\n\t  file \\file{swipl}.  If so, this file contains the (relative)\n\t  path to the home directory. If this directory exists, use\n\t  this.  This is the normal mechanism used by the binary\n\t  distribution.\n    \\item If the precompiled path exists, use it.  This is only useful\n          for a source installation.\n\\end{enumerate}\n\nIf all fails and there is no state attached to the executable or\nprovided Windows module (see PL_initialise()), SWI-Prolog gives up.  If\na state is attached, the current working directory is used.\n\nThe file_search_path/2 alias \\const{swi} is set to point to the home\ndirectory located.\n\n\n\\section{Example of Using the Foreign Interface} \\label{sec:foreignxmp}\n\nBelow is an example showing all stages of the declaration of a foreign\npredicate that transforms atoms possibly holding uppercase letters into\nan atom only holding lowercase letters. \\Figref{lowercase-c} shows the\nC source file, \\figref{load-foreign} illustrates compiling and loading\nof foreign code.\n\n\\begin{figure}[htb]\n\n\\begin{code}\n/*  Include file depends on local installation */\n#include <SWI-Prolog.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nforeign_t\npl_lowercase(term_t u, term_t l)\n{ char *copy;\n  char *s, *q;\n  int rval;\n\n  if ( !PL_get_atom_chars(u, &s) )\n    return PL_warning(\"lowercase/2: instantiation fault\");\n  copy = malloc(strlen(s)+1);\n\n  for( q=copy; *s; q++, s++)\n    *q = (isupper(*s) ? tolower(*s) : *s);\n  *q = '\\0';\n\n  rval = PL_unify_atom_chars(l, copy);\n  free(copy);\n\n  return rval;\n}\n\ninstall_t\ninstall()\n{ PL_register_foreign(\"lowercase\", 2, pl_lowercase, 0);\n}\n\\end{code}\n\n    \\caption{Lowercase source file}\n    \\label{fig:lowercase-c}\n\\end{figure}\n\n\n\\begin{figure}[htb]\n\\begin{code}\n% gcc -I/usr/local/lib/swipl-\\plversion/include -fpic -c lowercase.c\n% gcc -shared -o lowercase.so lowercase.o\n% swipl\nWelcome to SWI-Prolog (...)\n...\n\n1 ?- load_foreign_library(lowercase).\ntrue.\n\n2 ?- lowercase('Hello World!', L).\nL = 'hello world!'.\n\\end{code}\n    \\caption{Compiling the C source and loading the object file}\n    \\label{fig:load-foreign}\n\\end{figure}\n\\clearpage\n\n\n\\section{Notes on Using Foreign Code}\t\\label{sec:foreignnotes}\n\n\\subsection{Foreign debugging functions}\n\\label{sec:foreign-debug}\n\nThe functions in this section are primarily intended for debugging\nforeign extensions or embedded Prolog. Violating the constraints of the\nforeign interface often leads to crashes in a subsequent garbage\ncollection. If this happens, the system needs to be recompiled with the\ncflags \\const{-DO_DEBUG}. This is normally achieved by editing\n\\file{src/Makefile} and changing the definition of \\const{COFLAGS} to\nthe value below. The \\exam{-gdwarf-2 -g3} provides detailed debugging\ninformation for \\program{gcc}. If you use another C compiler you may\nneed other flags.\n\n\\begin{code}\nCOFLAGS=-DO_DEBUG -gdwarf-2 -g3\n\\end{code}\n\nAfter recompiling the Prolog kernel all functions listed above are\navailable to use from the debugger (e.g. \\program{gdb}) or can be placed\nat critical location in your code or the system code.\n\n\\begin{description}\n    \\cfunction{void}{PL_backtrace}{int depth, int flags}\nDump a Prolog backtrace to the \\const{user_error} stream. \\arg{Depth} is\nthe number of frames to dump. \\arg{Flags} is a bitwise or of the\nfollowing constants:\n\n    \\begin{description}\n    \\termitem{PL_BT_SAFE}{}\n    (0x1) Do not try to print \\jargon{goals}.  Instead, just print the\n    predicate name and arity.  This reduces the likelyhood to crash if\n    PL_backtrace() is called in a damaged environment.\n    \\termitem{PL_BT_USER}{}\n    (0x2) Only show `user' frames.  Default is to also show frames\n    of hidden built-in predicates.\n    \\end{description}\n\n    \\cfunction{char *}{PL_backtrace_string}{int depth, int flags}\nAs PL_backtrace(), but returns the stack as a string. The string uses\nUTF-8 encoding. The returned string must be freed using PL_free(). This\nfunction is was added to get stack traces from running servers where I/O\nis redirected or discarded.  For example, using \\program{gdb}, a stack\ntrace is printed in the gdb console regardless of Prolog I/O redirection\nusing the following command:\n\n\\begin{code}\n(gdb) printf \"%s\", PL_backtrace_string(25,0)\n\\end{code}\n\nThe source distribution provides the script \\file{scripts/swipl-bt} that\nexploits \\program{gdb} and PL_backtrace_string() to print stack traces\nin various formats for a SWI-Prolog process, given its process id.\n\n    \\cfunction{int}{PL_check_data}{term_t data}\n    Check the consistency of the term \\arg{data}.  Returns \\const{TRUE}\n    this is actually implemented in the current version and\n    \\const{FALSE} otherwise.  The actual implementation only exists\n    if the system is compiled with the cflag \\const{-DO_DEBUG} or\n    \\const{-DO_MAINTENANCE}.  This is \\emph{not} the default.\n\n    \\cfunction{int}{PL_check_stacks}{}\n    Check the consistency of the runtime stacks of the calling thread.\n    Returns \\const{TRUE} this is actually implemented in the current\n    version and \\const{FALSE} otherwise. The actual implementation only exists\n    if the system is compiled with the cflag \\const{-DO_DEBUG} or\n    \\const{-DO_MAINTENANCE}.  This is \\emph{not} the default.\n\\end{description}\n\nThe Prolog kernel sources use the macro \\cfuncref{DEBUG}{Topic, Code}.\nThese macros are disabled in the production version and must be enabled\nby recompiling the system as described above. Specific topics can be\nenabled and disabled using the predicates prolog_debug/1 and\nprolog_nodebug/1. In addition, they can be activated from the\ncommandline using commandline option \\const{-d topics}, where\n\\arg{topics} is a comma-separated list of debug topics to enable. For\nexample, the code below adds many consistency checks and prints messages\nif the Prolog signal handler dispatches signals.\n\n\\begin{code}\n$ swipl -d chk_secure,msg_signal\n\\end{code}\n\n\\begin{description}\n    \\predicate{prolog_debug}{1}{+Topic}\n    \\nodescription\n    \\predicate{prolog_nodebug}{1}{+Topic}\nEnable/disable a debug topic.  \\arg{Topic} is an atom that identifies\nthe desired topic. The available topics are defined in\n\\file{src/pl-debug.h}.  Please search the sources to find out what\nis actually printed and when.  We highlight one topic here:\n\n    \\begin{description}\n    \\termitem{chk_secure}\n    Add many expensive consistency checks to the system.  This should\n    typically be used when the system crashes, notably in the garbage\n    collector.  Garbage collection crashes are in most cases caused\n    by invalid data on the Prolog stacks.  This debug topic may help\n    locating how the invalid data was created.\n    \\end{description}\n\\end{description}\n\n\n\\subsection{Memory Allocation}\n\\label{sec:foreign-malloc}\n\nSWI-Prolog's heap memory allocation is based on the \\manref{malloc}{3}\nlibrary routines. SWI-Prolog provides the functions below as a wrapper\naround malloc(). Allocation errors in these functions trap SWI-Prolog's\nfatal-error handler, in which case PL_malloc() or PL_realloc() do not\nreturn.\n\nPortable applications must use PL_free() to release strings returned\nby PL_get_chars() using the \\const{BUF_MALLOC} argument.  Portable\napplications may use both PL_malloc() and friends or malloc() and\nfriends but should not mix these two sets of functions on the same\nmemory.\n\n\\begin{description}\n    \\cfunction{void *}{PL_malloc}{size_t bytes}\nAllocate \\arg{bytes} of memory.  On failure SWI-Prolog's fatal-error\nhandler is called and PL_malloc() does not return.  Memory allocated\nusing these functions must use PL_realloc() and PL_free() rather than\nrealloc() and free().\n\n    \\cfunction{void *}{PL_realloc}{void *mem, size_t size}\nChange the size of the allocated chunk, possibly moving it.  The\n\\arg{mem} argument must be obtained from a previous PL_malloc() or\nPL_realloc() call.\n\n    \\cfunction{void}{PL_free}{void *mem}\nRelease memory.  The \\arg{mem} argument must be obtained from a\nprevious PL_malloc() or PL_realloc() call.\n\\end{description}\n\n\\subsubsection{Boehm-GC support}\n\\label{sec:boehm-gc}\n\n\\begin{quote}\nThis section is obsolete.  Although the Boehm-GC interfaces\nstill exist, it turns out that the scalability is not good enough for\nSWI-Prolog. It is unlikely that SWI-Prolog will ever switch to\nBoehm-GC.\n\\end{quote}\n\n\\index{Boehm GC}%\nTo accommodate future use of the Boehm garbage\ncollector\\footnote{\\url{http://www.hpl.hp.com/personal/Hans_Boehm/gc/}}\nfor heap memory allocation, the interface provides the functions\ndescribed below. Foreign extensions that wish to use the Boehm-GC\nfacilities can use these wrappers. Please note that if SWI-Prolog is\nnot compiled to use Boehm-GC (default), the user is responsible for\ncalling PL_free() to reclaim memory.\n\n\\begin{description}\n    \\cfunction{void*}{PL_malloc_atomic}{size_t bytes}\n    \\nodescription\n    \\cfunction{void*}{PL_malloc_uncollectable}{size_t bytes}\n    \\nodescription\n    \\cfunction{void*}{PL_malloc_atomic_uncollectable}{size_t bytes}\nIf Boehm-GC is not used, these are all the same as PL_malloc().  With\nBoehm-GC, these map to the corresponding Boehm-GC functions.\n\\jargon{Atomic} means that the content should not be scanned for\npointers, and \\jargon{uncollectable} means that the object should never\nbe garbage collected.\n    \\cfunction{void*}{PL_malloc_stubborn}{size_t bytes}\n    \\nodescription\n    \\cfunction{void}{PL_end_stubborn_change}{void *memory}\nThese functions allow creating objects, promising GC that the content\nwill not change after PL_end_stubborn_change().\n\\end{description}\n\n\n\\subsection{Compatibility between Prolog versions}\n\\label{sec:foreign-compat}\n\nGreat care is taken to ensure binary compatibility of foreign extensions\nbetween different Prolog versions. Only the much less frequently used stream\ninterface has been responsible for binary incompatibilities.\n\n\\index{PLVERSION}%\nSource code that relies on new features of the foreign interface can\nuse the macro \\const{PLVERSION} to find the version of\n\\file{SWI-Prolog.h} and PL_query() using the option\n\\const{PL_QUERY_VERSION} to find the version of the attached Prolog\nsystem. Both follow the same numbering schema explained with PL_query().\n\n\n\\subsection{Debugging and profiling foreign code (valgrind)}\n\\label{sec:foreign-debug-and-profile}\n\n\\index{valgrind}\\index{profiling,foreign code}%\nThis section is only relevant for Unix users on platforms supported by\n\\href{http://valgrind.org/}{valgrind}. Valgrind is an excellent binary\ninstrumentation platform.  Unlike many other instrumentation platforms,\nvalgrind can deal with code loaded through dlopen().\n\nThe \\program{callgrind} tool can be used to profile foreign code loaded\nunder SWI-Prolog. Compile the foreign library adding \\cmdlineoption{-g}\noption to \\program{gcc} or \\program{swipl-ld}. By setting the environment\nvariable \\env{VALGRIND} to \\const{yes}, SWI-Prolog will \\emph{not}\nrelease loaded shared objects using dlclose(). This trick is required to\nget source information on the loaded library. Without, valgrind claims\nthat the shared object has no debugging information.\\footnote{Tested\nusing valgrind version 3.2.3 on x64.} Here is the complete sequence\nusing \\program{bash} as login shell:\n\n\\begin{code}\n% VALGRIND=yes valgrind --tool=callgrind pl <args>\n<prolog interaction>\n% kcachegrind callgrind.out.<pid>\n\\end{code}\n\n\n\\subsection{Name Conflicts in C modules}\n\\label{sec:foreign-name-conflicts}\n\nIn the current version of the system all public C functions of\nSWI-Prolog are in the symbol table.  This can lead to name clashes with\nforeign code.  Someday I should write a program to strip all these\nsymbols from the symbol table (why does Unix not have that?).  For now\nI can only suggest you give your function another name.  You can do this\nusing the C preprocessor.  If---for example---your foreign package uses\na function warning(), which happens to exist in SWI-Prolog as well, the\nfollowing macro should fix the problem:\n\n\\begin{code}\n#define warning warning_\n\\end{code}\n\nNote that shared libraries do not have this problem as the shared\nlibrary loader will only look for symbols in the main executable for\nsymbols that are not defined in the library itself.\n\n\n\\subsection{Compatibility of the Foreign Interface}\n\\label{sec:foreign-quintus-sicstus}\n\nThe term reference mechanism was first used by Quintus Prolog version~3.\nSICStus Prolog version 3 is strongly based on the Quintus interface. The\ndescribed SWI-Prolog interface is similar to using the Quintus or\nSICStus interfaces, defining all foreign-predicate arguments of type\n\\const{+term}.  SWI-Prolog explicitly uses type \\ctype{functor_t}, while\nQuintus and SICStus use <name> and <arity>.  As the names of the functions\ndiffer from Prolog to Prolog, a simple macro layer dealing with the\nnames can also deal with this detail.  For example:\n\n\\begin{code}\n#define QP_put_functor(t, n, a) \\\n\tPL_put_functor(t, PL_new_functor(n, a))\n\\end{code}\n\nThe {\\tt PL_unify_*()} functions are lacking from the Quintus and\nSICStus interface.  They can easily be emulated, or the put/unify\napproach should be used to write compatible code.\n\nThe PL_open_foreign_frame()/PL_close_foreign_frame() combination is\nlacking from both other Prologs.  SICStus has PL_new_term_refs(0),\nfollowed by PL_reset_term_refs(), that allows for discarding\nterm references.\n\nThe Prolog interface for the graphical user interface package XPCE\nshares about 90\\% of the code using a simple macro layer to deal\nwith different naming and calling conventions of the interfaces.\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/boot/syspred.pl": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1985-2018, University of Amsterdam\n                              VU University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n:- module('$syspreds',\n          [ leash/1,\n            visible/1,\n            style_check/1,\n            (spy)/1,\n            (nospy)/1,\n            trace/1,\n            trace/2,\n            nospyall/0,\n            debugging/0,\n            rational/3,\n            flag/3,\n            atom_prefix/2,\n            dwim_match/2,\n            source_file_property/2,\n            source_file/1,\n            source_file/2,\n            unload_file/1,\n            prolog_load_context/2,\n            stream_position_data/3,\n            current_predicate/2,\n            '$defined_predicate'/1,\n            predicate_property/2,\n            '$predicate_property'/2,\n            clause_property/2,\n            current_module/1,                   % ?Module\n            module_property/2,                  % ?Module, ?Property\n            module/1,                           % +Module\n            current_trie/1,                     % ?Trie\n            trie_property/2,                    % ?Trie, ?Property\n            working_directory/2,                % -OldDir, +NewDir\n            shell/1,                            % +Command\n            on_signal/3,\n            current_signal/3,\n            open_shared_object/2,\n            open_shared_object/3,\n            format/1,\n            garbage_collect/0,\n            set_prolog_stack/2,\n            prolog_stack_property/2,\n            absolute_file_name/2,\n            tmp_file_stream/3,                  % +Enc, -File, -Stream\n            require/1,\n            call_with_depth_limit/3,            % :Goal, +Limit, -Result\n            call_with_inference_limit/3,        % :Goal, +Limit, -Result\n            numbervars/3,                       % +Term, +Start, -End\n            term_string/3,                      % ?Term, ?String, +Options\n            nb_setval/2,                        % +Var, +Value\n            thread_create/2,                    % :Goal, -Id\n            thread_join/1,                      % +Id\n            set_prolog_gc_thread/1\t\t% +Status\n          ]).\n\n                /********************************\n                *           DEBUGGER            *\n                *********************************/\n\n%!  map_bits(:Pred, +Modify, +OldBits, -NewBits)\n\n:- meta_predicate\n    map_bits(2, +, +, -).\n\nmap_bits(_, Var, _, _) :-\n    var(Var),\n    !,\n    '$instantiation_error'(Var).\nmap_bits(_, [], Bits, Bits) :- !.\nmap_bits(Pred, [H|T], Old, New) :-\n    map_bits(Pred, H, Old, New0),\n    map_bits(Pred, T, New0, New).\nmap_bits(Pred, +Name, Old, New) :-     % set a bit\n    !,\n    bit(Pred, Name, Bits),\n    !,\n    New is Old \\/ Bits.\nmap_bits(Pred, -Name, Old, New) :-     % clear a bit\n    !,\n    bit(Pred, Name, Bits),\n    !,\n    New is Old /\\ (\\Bits).\nmap_bits(Pred, ?(Name), Old, Old) :-   % ask a bit\n    !,\n    bit(Pred, Name, Bits),\n    Old /\\ Bits > 0.\nmap_bits(_, Term, _, _) :-\n    '$type_error'('+|-|?(Flag)', Term).\n\nbit(Pred, Name, Bits) :-\n    call(Pred, Name, Bits),\n    !.\nbit(_:Pred, Name, _) :-\n    '$domain_error'(Pred, Name).\n\n:- public port_name/2.                  % used by library(test_cover)\n\nport_name(      call, 2'000000001).\nport_name(      exit, 2'000000010).\nport_name(      fail, 2'000000100).\nport_name(      redo, 2'000001000).\nport_name(     unify, 2'000010000).\nport_name(     break, 2'000100000).\nport_name(  cut_call, 2'001000000).\nport_name(  cut_exit, 2'010000000).\nport_name( exception, 2'100000000).\nport_name(       cut, 2'011000000).\nport_name(       all, 2'000111111).\nport_name(      full, 2'000101111).\nport_name(      half, 2'000101101).     % '\n\nleash(Ports) :-\n    '$leash'(Old, Old),\n    map_bits(port_name, Ports, Old, New),\n    '$leash'(_, New).\n\nvisible(Ports) :-\n    '$visible'(Old, Old),\n    map_bits(port_name, Ports, Old, New),\n    '$visible'(_, New).\n\nstyle_name(atom,            0x0001) :-\n    print_message(warning, decl_no_effect(style_check(atom))).\nstyle_name(singleton,       0x0042).            % semantic and syntactic\nstyle_name(discontiguous,   0x0008).\nstyle_name(charset,         0x0020).\nstyle_name(no_effect,       0x0080).\nstyle_name(var_branches,    0x0100).\n\n%!  style_check(+Spec) is nondet.\n\nstyle_check(Var) :-\n    var(Var),\n    !,\n    '$instantiation_error'(Var).\nstyle_check(?(Style)) :-\n    !,\n    (   var(Style)\n    ->  enum_style_check(Style)\n    ;   enum_style_check(Style)\n    ->  true\n    ).\nstyle_check(Spec) :-\n    '$style_check'(Old, Old),\n    map_bits(style_name, Spec, Old, New),\n    '$style_check'(_, New).\n\nenum_style_check(Style) :-\n    '$style_check'(Bits, Bits),\n    style_name(Style, Bit),\n    Bit /\\ Bits =\\= 0.\n\n\n%!  prolog:debug_control_hook(+Action)\n%\n%   Allow user-hooks in the Prolog debugger interaction.  See the calls\n%   below for the provided hooks.  We use a single predicate with action\n%   argument to avoid an uncontrolled poliferation of hooks.\n%\n%   TBD: What hooks to provide for trace/[1,2]\n\n:- multifile\n    prolog:debug_control_hook/1.    % +Action\n\n%!  trace(:Preds) is det.\n%!  trace(:Preds, +PortSpec) is det.\n%\n%   Start printing messages if control passes specified ports of\n%   the given predicates.\n\n:- meta_predicate\n    trace(:),\n    trace(:, +).\n\ntrace(Preds) :-\n    trace(Preds, +all).\n\ntrace(_:X, _) :-\n    var(X),\n    !,\n    throw(error(instantiation_error, _)).\ntrace(_:[], _) :- !.\ntrace(M:[H|T], Ps) :-\n    !,\n    trace(M:H, Ps),\n    trace(M:T, Ps).\ntrace(Pred, Ports) :-\n    '$find_predicate'(Pred, Preds),\n    Preds \\== [],\n    set_prolog_flag(debug, true),\n    (   '$member'(PI, Preds),\n            pi_to_head(PI, Head),\n            (   Head = _:_\n            ->  QHead0 = Head\n            ;   QHead0 = user:Head\n            ),\n            '$define_predicate'(QHead0),\n            (   predicate_property(QHead0, imported_from(M))\n            ->  QHead0 = _:Plain,\n                QHead = M:Plain\n            ;   QHead = QHead0\n            ),\n            '$trace'(Ports, QHead),\n            trace_ports(QHead, Tracing),\n            print_message(informational, trace(QHead, Tracing)),\n        fail\n    ;   true\n    ).\n\ntrace_alias(all,  [trace_call, trace_redo, trace_exit, trace_fail]).\ntrace_alias(call, [trace_call]).\ntrace_alias(redo, [trace_redo]).\ntrace_alias(exit, [trace_exit]).\ntrace_alias(fail, [trace_fail]).\n\n'$trace'([], _) :- !.\n'$trace'([H|T], Head) :-\n    !,\n    '$trace'(H, Head),\n    '$trace'(T, Head).\n'$trace'(+H, Head) :-\n    trace_alias(H, A0),\n    !,\n    tag_list(A0, +, A1),\n    '$trace'(A1, Head).\n'$trace'(+H, Head) :-\n    !,\n    trace_alias(_, [H]),\n    '$set_predicate_attribute'(Head, H, true).\n'$trace'(-H, Head) :-\n    trace_alias(H, A0),\n    !,\n    tag_list(A0, -, A1),\n    '$trace'(A1, Head).\n'$trace'(-H, Head) :-\n    !,\n    trace_alias(_, [H]),\n    '$set_predicate_attribute'(Head, H, false).\n'$trace'(H, Head) :-\n    atom(H),\n    '$trace'(+H, Head).\n\ntag_list([], _, []).\ntag_list([H0|T0], F, [H1|T1]) :-\n    H1 =.. [F, H0],\n    tag_list(T0, F, T1).\n\n:- meta_predicate\n    spy(:),\n    nospy(:).\n\n%!  spy(:Spec) is det.\n%!  nospy(:Spec) is det.\n%!  nospyall is det.\n%\n%   Set/clear spy-points. A successfully set or cleared spy-point is\n%   reported using print_message/2, level  =informational=, with one\n%   of the following terms, where Spec is of the form M:Head.\n%\n%       - spy(Spec)\n%       - nospy(Spec)\n%\n%   @see    spy/1 and nospy/1 call the hook prolog:debug_control_hook/1\n%           to allow for alternative specifications of the thing to\n%           debug.\n\nspy(_:X) :-\n    var(X),\n    throw(error(instantiation_error, _)).\nspy(_:[]) :- !.\nspy(M:[H|T]) :-\n    !,\n    spy(M:H),\n    spy(M:T).\nspy(Spec) :-\n    notrace(prolog:debug_control_hook(spy(Spec))),\n    !.\nspy(Spec) :-\n    '$find_predicate'(Spec, Preds),\n    '$member'(PI, Preds),\n        pi_to_head(PI, Head),\n        '$define_predicate'(Head),\n        '$spy'(Head),\n    fail.\nspy(_).\n\nnospy(_:X) :-\n    var(X),\n    throw(error(instantiation_error, _)).\nnospy(_:[]) :- !.\nnospy(M:[H|T]) :-\n    !,\n    nospy(M:H),\n    nospy(M:T).\nnospy(Spec) :-\n    notrace(prolog:debug_control_hook(nospy(Spec))),\n    !.\nnospy(Spec) :-\n    '$find_predicate'(Spec, Preds),\n    '$member'(PI, Preds),\n         pi_to_head(PI, Head),\n        '$nospy'(Head),\n    fail.\nnospy(_).\n\nnospyall :-\n    notrace(prolog:debug_control_hook(nospyall)),\n    fail.\nnospyall :-\n    spy_point(Head),\n        '$nospy'(Head),\n    fail.\nnospyall.\n\npi_to_head(M:PI, M:Head) :-\n    !,\n    pi_to_head(PI, Head).\npi_to_head(Name/Arity, Head) :-\n    functor(Head, Name, Arity).\n\n%!  debugging is det.\n%\n%   Report current status of the debugger.\n\ndebugging :-\n    notrace(prolog:debug_control_hook(debugging)),\n    !.\ndebugging :-\n    current_prolog_flag(debug, true),\n    !,\n    print_message(informational, debugging(on)),\n    findall(H, spy_point(H), SpyPoints),\n    print_message(informational, spying(SpyPoints)),\n    findall(trace(H,P), trace_point(H,P), TracePoints),\n    print_message(informational, tracing(TracePoints)).\ndebugging :-\n    print_message(informational, debugging(off)).\n\nspy_point(Module:Head) :-\n    current_predicate(_, Module:Head),\n    '$get_predicate_attribute'(Module:Head, spy, 1),\n    \\+ predicate_property(Module:Head, imported_from(_)).\n\ntrace_point(Module:Head, Ports) :-\n    current_predicate(_, Module:Head),\n        '$get_predicate_attribute'(Module:Head, trace_any, 1),\n        \\+ predicate_property(Module:Head, imported_from(_)),\n        trace_ports(Module:Head, Ports).\n\ntrace_ports(Head, Ports) :-\n    findall(Port,\n            (trace_alias(Port, [AttName]),\n             '$get_predicate_attribute'(Head, AttName, 1)),\n            Ports).\n\n\n%!  flag(+Name, -Old, +New) is det.\n%\n%   True when Old is the current value associated with the flag Name\n%   and New has become the new value.\n\nflag(Name, Old, New) :-\n    Old == New,\n    !,\n    get_flag(Name, Old).\nflag(Name, Old, New) :-\n    with_mutex('$flag', update_flag(Name, Old, New)).\n\nupdate_flag(Name, Old, New) :-\n    get_flag(Name, Old),\n    (   atom(New)\n    ->  set_flag(Name, New)\n    ;   Value is New,\n        set_flag(Name, Value)\n    ).\n\n\n                 /*******************************\n                 *            RATIONAL          *\n                 *******************************/\n\n%!  rational(+Rat, -Numerator, -Denominator) is semidet.\n%\n%   True when Rat is a  rational   number  with  given Numerator and\n%   Denominator.\n\nrational(Rat, M, N) :-\n    rational(Rat),\n    (   Rat = rdiv(M, N)\n    ->  true\n    ;   integer(Rat)\n    ->  M = Rat,\n        N = 1\n    ).\n\n\n                /********************************\n                *             ATOMS             *\n                *********************************/\n\ndwim_match(A1, A2) :-\n    dwim_match(A1, A2, _).\n\natom_prefix(Atom, Prefix) :-\n    sub_atom(Atom, 0, _, _, Prefix).\n\n\n                /********************************\n                *             SOURCE            *\n                *********************************/\n\n%!  source_file(-File) is nondet.\n%!  source_file(+File) is semidet.\n%\n%   True if File is loaded into  Prolog.   If  File is unbound it is\n%   bound to the canonical name for it. If File is bound it succeeds\n%   if the canonical name  as   defined  by  absolute_file_name/2 is\n%   known as a loaded filename.\n%\n%   Note that Time = 0.0 is used by  PlDoc and other code that needs\n%   to create a file record without being interested in the time.\n\nsource_file(File) :-\n    (   current_prolog_flag(access_level, user)\n    ->  Level = user\n    ;   true\n    ),\n    (   ground(File)\n    ->  (   '$time_source_file'(File, Time, Level)\n        ;   absolute_file_name(File, Abs),\n            '$time_source_file'(Abs, Time, Level)\n        ), !\n    ;   '$time_source_file'(File, Time, Level)\n    ),\n    Time > 0.0.\n\n%!  source_file(+Head, -File) is semidet.\n%!  source_file(?Head, ?File) is nondet.\n%\n%   True when Head is a predicate owned by File.\n\n:- meta_predicate source_file(:, ?).\n\nsource_file(M:Head, File) :-\n    nonvar(M), nonvar(Head),\n    !,\n    (   '$c_current_predicate'(_, M:Head),\n        predicate_property(M:Head, multifile)\n    ->  multi_source_files(M:Head, Files),\n        '$member'(File, Files)\n    ;   '$source_file'(M:Head, File)\n    ).\nsource_file(M:Head, File) :-\n    (   nonvar(File)\n    ->  true\n    ;   source_file(File)\n    ),\n    '$source_file_predicates'(File, Predicates),\n    '$member'(M:Head, Predicates).\n\n:- thread_local found_src_file/1.\n\nmulti_source_files(Head, Files) :-\n    call_cleanup(\n        findall(File, multi_source_file(Head, File), Files),\n        retractall(found_src_file(_))).\n\nmulti_source_file(Head, File) :-\n    nth_clause(Head, _, Clause),\n    clause_property(Clause, source(File)),\n    \\+ found_src_file(File),\n    asserta(found_src_file(File)).\n\n\n%!  source_file_property(?File, ?Property) is nondet.\n%\n%   True if Property is a property of the loaded source-file File.\n\nsource_file_property(File, P) :-\n    nonvar(File),\n    !,\n    canonical_source_file(File, Path),\n    property_source_file(P, Path).\nsource_file_property(File, P) :-\n    property_source_file(P, File).\n\nproperty_source_file(modified(Time), File) :-\n    '$time_source_file'(File, Time, user).\nproperty_source_file(source(Source), File) :-\n    (   '$source_file_property'(File, from_state, true)\n    ->  Source = state\n    ;   '$source_file_property'(File, resource, true)\n    ->  Source = resource\n    ;   Source = file\n    ).\nproperty_source_file(module(M), File) :-\n    (   nonvar(M)\n    ->  '$current_module'(M, File)\n    ;   nonvar(File)\n    ->  '$current_module'(ML, File),\n        (   atom(ML)\n        ->  M = ML\n        ;   '$member'(M, ML)\n        )\n    ;   '$current_module'(M, File)\n    ).\nproperty_source_file(load_context(Module, Location, Options), File) :-\n    '$time_source_file'(File, _, user),\n    clause(system:'$load_context_module'(File, Module, Options), true, Ref),\n    (   clause_property(Ref, file(FromFile)),\n        clause_property(Ref, line_count(FromLine))\n    ->  Location = FromFile:FromLine\n    ;   Location = user\n    ).\nproperty_source_file(includes(Master, Stamp), File) :-\n    system:'$included'(File, _Line, Master, Stamp).\nproperty_source_file(included_in(Master, Line), File) :-\n    system:'$included'(Master, Line, File, _).\nproperty_source_file(derived_from(DerivedFrom, Stamp), File) :-\n    system:'$derived_source'(File, DerivedFrom, Stamp).\nproperty_source_file(reloading, File) :-\n    source_file(File),\n    '$source_file_property'(File, reloading, true).\nproperty_source_file(load_count(Count), File) :-\n    source_file(File),\n    '$source_file_property'(File, load_count, Count).\nproperty_source_file(number_of_clauses(Count), File) :-\n    source_file(File),\n    '$source_file_property'(File, number_of_clauses, Count).\n\n\n%!  canonical_source_file(+Spec, -File) is semidet.\n%\n%   File is the canonical representation of the source-file Spec.\n\ncanonical_source_file(Spec, File) :-\n    atom(Spec),\n    '$time_source_file'(Spec, _, _),\n    !,\n    File = Spec.\ncanonical_source_file(Spec, File) :-\n    system:'$included'(_Master, _Line, Spec, _),\n    !,\n    File = Spec.\ncanonical_source_file(Spec, File) :-\n    absolute_file_name(Spec,\n                           [ file_type(prolog),\n                             access(read),\n                             file_errors(fail)\n                           ],\n                           File),\n    source_file(File).\n\n\n%!  prolog_load_context(+Key, -Value)\n%\n%   Provides context information for  term_expansion and directives.\n%   Note  that  only  the  line-number  info    is   valid  for  the\n%   '$stream_position'. Largely Quintus compatible.\n\nprolog_load_context(module, Module) :-\n    '$current_source_module'(Module).\nprolog_load_context(file, F) :-\n    source_location(F, _).\nprolog_load_context(source, F) :-       % SICStus compatibility\n    source_location(F0, _),\n    '$input_context'(Context),\n    '$top_file'(Context, F0, F).\nprolog_load_context(stream, S) :-\n    (   system:'$load_input'(_, S0)\n    ->  S = S0\n    ).\nprolog_load_context(directory, D) :-\n    source_location(F, _),\n    file_directory_name(F, D).\nprolog_load_context(dialect, D) :-\n    current_prolog_flag(emulated_dialect, D).\nprolog_load_context(term_position, TermPos) :-\n    source_location(_, L),\n    (   nb_current('$term_position', Pos),\n        compound(Pos),              % actually set\n        stream_position_data(line_count, Pos, L)\n    ->  TermPos = Pos\n    ;   TermPos = '$stream_position'(0,L,0,0)\n    ).\nprolog_load_context(script, Bool) :-\n    (   '$toplevel':loaded_init_file(script, Path),\n        source_location(Path, _)\n    ->  Bool = true\n    ;   Bool = false\n    ).\nprolog_load_context(variable_names, Bindings) :-\n    nb_current('$variable_names', Bindings).\nprolog_load_context(term, Term) :-\n    nb_current('$term', Term).\nprolog_load_context(reloading, true) :-\n    prolog_load_context(source, F),\n    '$source_file_property'(F, reloading, true).\n\n%!  unload_file(+File) is det.\n%\n%   Remove all traces of loading file.\n\n:- dynamic system:'$resolved_source_path'/2.\n\nunload_file(File) :-\n    (   canonical_source_file(File, Path)\n    ->  '$unload_file'(Path),\n        retractall(system:'$resolved_source_path'(_, Path))\n    ;   true\n    ).\n\n\n                 /*******************************\n                 *            STREAMS           *\n                 *******************************/\n\n%!  stream_position_data(?Field, +Pos, ?Date)\n%\n%   Extract values from stream position objects. '$stream_position' is\n%   of the format '$stream_position'(Byte, Char, Line, LinePos)\n\nstream_position_data(Prop, Term, Value) :-\n    nonvar(Prop),\n    !,\n    (   stream_position_field(Prop, Pos)\n    ->  arg(Pos, Term, Value)\n    ;   throw(error(domain_error(stream_position_data, Prop)))\n    ).\nstream_position_data(Prop, Term, Value) :-\n    stream_position_field(Prop, Pos),\n    arg(Pos, Term, Value).\n\nstream_position_field(char_count,    1).\nstream_position_field(line_count,    2).\nstream_position_field(line_position, 3).\nstream_position_field(byte_count,    4).\n\n\n                 /*******************************\n                 *            CONTROL           *\n                 *******************************/\n\n%!  call_with_depth_limit(:Goal, +DepthLimit, -Result)\n%\n%   Try to proof Goal, but fail on any branch exceeding the indicated\n%   depth-limit.  Unify Result with the maximum-reached limit on success,\n%   depth_limit_exceeded if the limit was exceeded and fails otherwise.\n\n:- meta_predicate\n    call_with_depth_limit(0, +, -).\n\ncall_with_depth_limit(G, Limit, Result) :-\n    '$depth_limit'(Limit, OLimit, OReached),\n    (   catch(G, E, '$depth_limit_except'(OLimit, OReached, E)),\n        '$depth_limit_true'(Limit, OLimit, OReached, Result, Det),\n        ( Det == ! -> ! ; true )\n    ;   '$depth_limit_false'(OLimit, OReached, Result)\n    ).\n\n%!  call_with_inference_limit(:Goal, +InferenceLimit, -Result)\n%\n%   Equivalent to call(Goal), but poses  a   limit  on the number of\n%   inferences. If this limit is  reached,   Result  is unified with\n%   =inference_limit_exceeded=, otherwise Result  is   unified  with\n%   =|!|=  if  Goal  succeeded  without  a  choicepoint  and  =true=\n%   otherwise.\n%\n%   Note that we perform calls in   system  to avoid auto-importing,\n%   which makes raiseInferenceLimitException()  fail   to  recognise\n%   that the exception happens in the overhead.\n\n:- meta_predicate\n    call_with_inference_limit(0, +, -).\n\ncall_with_inference_limit(G, Limit, Result) :-\n    '$inference_limit'(Limit, OLimit),\n    (   catch(G, Except,\n              system:'$inference_limit_except'(OLimit, Except, Result0)),\n        system:'$inference_limit_true'(Limit, OLimit, Result0),\n        ( Result0 == ! -> ! ; true ),\n        Result = Result0\n    ;   system:'$inference_limit_false'(OLimit)\n    ).\n\n\n                /********************************\n                *           DATA BASE           *\n                *********************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThe predicate current_predicate/2 is   a  difficult subject since  the\nintroduction  of defaulting     modules   and   dynamic     libraries.\ncurrent_predicate/2 is normally  called with instantiated arguments to\nverify some  predicate can   be called without trapping   an undefined\npredicate.  In this case we must  perform the search algorithm used by\nthe prolog system itself.\n\nIf the pattern is not fully specified, we only generate the predicates\nactually available in this  module.   This seems the best for listing,\netc.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n:- meta_predicate\n    current_predicate(?, :),\n    '$defined_predicate'(:).\n\ncurrent_predicate(Name, Module:Head) :-\n    (var(Module) ; var(Head)),\n    !,\n    generate_current_predicate(Name, Module, Head).\ncurrent_predicate(Name, Term) :-\n    '$c_current_predicate'(Name, Term),\n    '$defined_predicate'(Term),\n    !.\ncurrent_predicate(Name, Module:Head) :-\n    default_module(Module, DefModule),\n    '$c_current_predicate'(Name, DefModule:Head),\n    '$defined_predicate'(DefModule:Head),\n    !.\ncurrent_predicate(Name, Module:Head) :-\n    current_prolog_flag(autoload, true),\n    \\+ current_prolog_flag(Module:unknown, fail),\n    (   compound(Head)\n    ->  compound_name_arity(Head, Name, Arity)\n    ;   Name = Head, Arity = 0\n    ),\n    '$find_library'(Module, Name, Arity, _LoadModule, _Library),\n    !.\n\ngenerate_current_predicate(Name, Module, Head) :-\n    current_module(Module),\n    QHead = Module:Head,\n    '$c_current_predicate'(Name, QHead),\n    '$get_predicate_attribute'(QHead, defined, 1).\n\n'$defined_predicate'(Head) :-\n    '$get_predicate_attribute'(Head, defined, 1),\n    !.\n\n%!  predicate_property(?Predicate, ?Property) is nondet.\n%\n%   True when Property is a property of Predicate.\n\n:- meta_predicate\n    predicate_property(:, ?).\n\n:- '$iso'(predicate_property/2).\n\npredicate_property(Pred, Property) :-           % Mode ?,+\n    nonvar(Property),\n    !,\n    property_predicate(Property, Pred).\npredicate_property(Pred, Property) :-           % Mode +,-\n    define_or_generate(Pred),\n    '$predicate_property'(Property, Pred).\n\n%!  property_predicate(+Property, ?Pred)\n%\n%   First handle the special  cases  that   are  not  about querying\n%   normally  defined  predicates:   =undefined=,    =visible=   and\n%   =autoload=, followed by the generic case.\n\nproperty_predicate(undefined, Pred) :-\n    !,\n    Pred = Module:Head,\n    current_module(Module),\n    '$c_current_predicate'(_, Pred),\n    \\+ '$defined_predicate'(Pred),          % Speed up a bit\n    \\+ current_predicate(_, Pred),\n    goal_name_arity(Head, Name, Arity),\n    \\+ system_undefined(Module:Name/Arity).\nproperty_predicate(visible, Pred) :-\n    !,\n    visible_predicate(Pred).\nproperty_predicate(autoload(File), _:Head) :-\n    !,\n    current_prolog_flag(autoload, true),\n    (   callable(Head)\n    ->  goal_name_arity(Head, Name, Arity),\n        (   '$find_library'(_, Name, Arity, _, File)\n        ->  true\n        )\n    ;   '$in_library'(Name, Arity, File),\n        functor(Head, Name, Arity)\n    ).\nproperty_predicate(implementation_module(IM), M:Head) :-\n    !,\n    atom(M),\n    (   default_module(M, DM),\n        '$get_predicate_attribute'(DM:Head, defined, 1)\n    ->  (   '$get_predicate_attribute'(DM:Head, imported, ImportM)\n        ->  IM = ImportM\n        ;   IM = M\n        )\n    ;   \\+ current_prolog_flag(M:unknown, fail),\n        goal_name_arity(Head, Name, Arity),\n        '$find_library'(_, Name, Arity, LoadModule, _File)\n    ->  IM = LoadModule\n    ;   M = IM\n    ).\nproperty_predicate(iso, _:Head) :-\n    callable(Head),\n    !,\n    goal_name_arity(Head, Name, Arity),\n    current_predicate(system:Name/Arity),\n    '$predicate_property'(iso, system:Head).\nproperty_predicate(Property, Pred) :-\n    define_or_generate(Pred),\n    '$predicate_property'(Property, Pred).\n\ngoal_name_arity(Head, Name, Arity) :-\n    compound(Head),\n    !,\n    compound_name_arity(Head, Name, Arity).\ngoal_name_arity(Head, Head, 0).\n\n\n%!  define_or_generate(+Head) is semidet.\n%!  define_or_generate(-Head) is nondet.\n%\n%   If the predicate is known, try to resolve it. Otherwise generate\n%   the known predicate, but do not try to (auto)load the predicate.\n\ndefine_or_generate(M:Head) :-\n    callable(Head),\n    atom(M),\n    '$get_predicate_attribute'(M:Head, defined, 1),\n    !.\ndefine_or_generate(M:Head) :-\n    callable(Head),\n    nonvar(M), M \\== system,\n    !,\n    '$define_predicate'(M:Head).\ndefine_or_generate(Pred) :-\n    current_predicate(_, Pred),\n    '$define_predicate'(Pred).\n\n\n'$predicate_property'(interpreted, Pred) :-\n    '$get_predicate_attribute'(Pred, foreign, 0).\n'$predicate_property'(visible, Pred) :-\n    '$get_predicate_attribute'(Pred, defined, 1).\n'$predicate_property'(built_in, Pred) :-\n    '$get_predicate_attribute'(Pred, system, 1).\n'$predicate_property'(exported, Pred) :-\n    '$get_predicate_attribute'(Pred, exported, 1).\n'$predicate_property'(public, Pred) :-\n    '$get_predicate_attribute'(Pred, public, 1).\n'$predicate_property'(non_terminal, Pred) :-\n    '$get_predicate_attribute'(Pred, non_terminal, 1).\n'$predicate_property'(foreign, Pred) :-\n    '$get_predicate_attribute'(Pred, foreign, 1).\n'$predicate_property'((dynamic), Pred) :-\n    '$get_predicate_attribute'(Pred, (dynamic), 1).\n'$predicate_property'((static), Pred) :-\n    '$get_predicate_attribute'(Pred, (dynamic), 0).\n'$predicate_property'((volatile), Pred) :-\n    '$get_predicate_attribute'(Pred, (volatile), 1).\n'$predicate_property'((thread_local), Pred) :-\n    '$get_predicate_attribute'(Pred, (thread_local), 1).\n'$predicate_property'((multifile), Pred) :-\n    '$get_predicate_attribute'(Pred, (multifile), 1).\n'$predicate_property'(imported_from(Module), Pred) :-\n    '$get_predicate_attribute'(Pred, imported, Module).\n'$predicate_property'(transparent, Pred) :-\n    '$get_predicate_attribute'(Pred, transparent, 1).\n'$predicate_property'(meta_predicate(Pattern), Pred) :-\n    '$get_predicate_attribute'(Pred, meta_predicate, Pattern).\n'$predicate_property'(file(File), Pred) :-\n    '$get_predicate_attribute'(Pred, file, File).\n'$predicate_property'(line_count(LineNumber), Pred) :-\n    '$get_predicate_attribute'(Pred, line_count, LineNumber).\n'$predicate_property'(notrace, Pred) :-\n    '$get_predicate_attribute'(Pred, trace, 0).\n'$predicate_property'(nodebug, Pred) :-\n    '$get_predicate_attribute'(Pred, hide_childs, 1).\n'$predicate_property'(spying, Pred) :-\n    '$get_predicate_attribute'(Pred, spy, 1).\n'$predicate_property'(number_of_clauses(N), Pred) :-\n    '$get_predicate_attribute'(Pred, number_of_clauses, N).\n'$predicate_property'(number_of_rules(N), Pred) :-\n    '$get_predicate_attribute'(Pred, number_of_rules, N).\n'$predicate_property'(last_modified_generation(Gen), Pred) :-\n    '$get_predicate_attribute'(Pred, last_modified_generation, Gen).\n'$predicate_property'(indexed(Indices), Pred) :-\n    '$get_predicate_attribute'(Pred, indexed, Indices).\n'$predicate_property'(noprofile, Pred) :-\n    '$get_predicate_attribute'(Pred, noprofile, 1).\n'$predicate_property'(iso, Pred) :-\n    '$get_predicate_attribute'(Pred, iso, 1).\n'$predicate_property'(quasi_quotation_syntax, Pred) :-\n    '$get_predicate_attribute'(Pred, quasi_quotation_syntax, 1).\n'$predicate_property'(defined, Pred) :-\n    '$get_predicate_attribute'(Pred, defined, 1).\n\nsystem_undefined(user:prolog_trace_interception/4).\nsystem_undefined(user:prolog_exception_hook/4).\nsystem_undefined(system:'$c_call_prolog'/0).\nsystem_undefined(system:window_title/2).\n\n%!  visible_predicate(:Head) is nondet.\n%\n%   True when Head can be called without raising an existence error.\n%   This implies it is defined,  can   be  inherited  from a default\n%   module or can be autoloaded.\n\nvisible_predicate(Pred) :-\n    Pred = M:Head,\n    current_module(M),\n    (   callable(Head)\n    ->  (   '$get_predicate_attribute'(Pred, defined, 1)\n        ->  true\n        ;   \\+ current_prolog_flag(M:unknown, fail),\n            functor(Head, Name, Arity),\n            '$find_library'(M, Name, Arity, _LoadModule, _Library)\n        )\n    ;   setof(PI, visible_in_module(M, PI), PIs),\n        '$member'(Name/Arity, PIs),\n        functor(Head, Name, Arity)\n    ).\n\nvisible_in_module(M, Name/Arity) :-\n    default_module(M, DefM),\n    DefHead = DefM:Head,\n    '$c_current_predicate'(_, DefHead),\n    '$get_predicate_attribute'(DefHead, defined, 1),\n    \\+ hidden_system_predicate(Head),\n    functor(Head, Name, Arity).\nvisible_in_module(_, Name/Arity) :-\n    '$in_library'(Name, Arity, _).\n\nhidden_system_predicate(Head) :-\n    functor(Head, Name, _),\n    atom(Name),                     % Avoid [].\n    sub_atom(Name, 0, _, _, $),\n    \\+ current_prolog_flag(access_level, system).\n\n\n%!  clause_property(+ClauseRef, ?Property) is nondet.\n%\n%   Provide information on individual clauses.  Defined properties\n%   are:\n%\n%       * line_count(-Line)\n%       Line from which the clause is loaded.\n%       * file(-File)\n%       File from which the clause is loaded.\n%       * source(-File)\n%       File that `owns' the clause: reloading this file wipes\n%       the clause.\n%       * fact\n%       Clause has body =true=.\n%       * erased\n%       Clause was erased.\n%       * predicate(:PI)\n%       Predicate indicator of the predicate this clause belongs\n%       to.  Can be used to find the predicate of erased clauses.\n%       * module(-M)\n%       Module context in which the clause was compiled.\n\nclause_property(Clause, Property) :-\n    '$clause_property'(Property, Clause).\n\n'$clause_property'(line_count(LineNumber), Clause) :-\n    '$get_clause_attribute'(Clause, line_count, LineNumber).\n'$clause_property'(file(File), Clause) :-\n    '$get_clause_attribute'(Clause, file, File).\n'$clause_property'(source(File), Clause) :-\n    '$get_clause_attribute'(Clause, owner, File).\n'$clause_property'(size(Bytes), Clause) :-\n    '$get_clause_attribute'(Clause, size, Bytes).\n'$clause_property'(fact, Clause) :-\n    '$get_clause_attribute'(Clause, fact, true).\n'$clause_property'(erased, Clause) :-\n    '$get_clause_attribute'(Clause, erased, true).\n'$clause_property'(predicate(PI), Clause) :-\n    '$get_clause_attribute'(Clause, predicate_indicator, PI).\n'$clause_property'(module(M), Clause) :-\n    '$get_clause_attribute'(Clause, module, M).\n\n\n                 /*******************************\n                 *             REQUIRE          *\n                 *******************************/\n\n:- meta_predicate\n    require(:).\n\n%!  require(:ListOfPredIndicators) is det.\n%\n%   Tag given predicates as undefined, so they will be included\n%   into a saved state through the autoloader.\n%\n%   @see autoload/0.\n\nrequire(M:List) :-\n    (   is_list(List)\n    ->  require(List, M)\n    ;   throw(error(type_error(list, List), _))\n    ).\n\nrequire([], _).\nrequire([N/A|T], M) :-\n    !,\n    functor(Head, N, A),\n    '$require'(M:Head),\n    require(T, M).\nrequire([H|_T], _) :-\n    throw(error(type_error(predicate_indicator, H), _)).\n\n\n                /********************************\n                *            MODULES            *\n                *********************************/\n\n%!  current_module(?Module) is nondet.\n%\n%   True if Module is a currently defined module.\n\ncurrent_module(Module) :-\n    '$current_module'(Module, _).\n\n%!  module_property(?Module, ?Property) is nondet.\n%\n%   True if Property is a property of Module.  Defined properties\n%   are:\n%\n%       * file(File)\n%       Module is loaded from File.\n%       * line_count(Count)\n%       The module declaration is on line Count of File.\n%       * exports(ListOfPredicateIndicators)\n%       The module exports ListOfPredicateIndicators\n%       * exported_operators(ListOfOp3)\n%       The module exports the operators ListOfOp3.\n\nmodule_property(Module, Property) :-\n    nonvar(Module), nonvar(Property),\n    !,\n    property_module(Property, Module).\nmodule_property(Module, Property) :-    % -, file(File)\n    nonvar(Property), Property = file(File),\n    !,\n    (   nonvar(File)\n    ->  '$current_module'(Modules, File),\n        (   atom(Modules)\n        ->  Module = Modules\n        ;   '$member'(Module, Modules)\n        )\n    ;   '$current_module'(Module, File),\n        File \\== []\n    ).\nmodule_property(Module, Property) :-\n    current_module(Module),\n    property_module(Property, Module).\n\nproperty_module(Property, Module) :-\n    module_property(Property),\n    (   Property = exported_operators(List)\n    ->  '$exported_ops'(Module, List, []),\n        List \\== []\n    ;   '$module_property'(Module, Property)\n    ).\n\nmodule_property(class(_)).\nmodule_property(file(_)).\nmodule_property(line_count(_)).\nmodule_property(exports(_)).\nmodule_property(exported_operators(_)).\nmodule_property(program_size(_)).\nmodule_property(program_space(_)).\nmodule_property(last_modified_generation(_)).\n\n%!  module(+Module) is det.\n%\n%   Set the module that is associated to the toplevel to Module.\n\nmodule(Module) :-\n    atom(Module),\n    current_module(Module),\n    !,\n    '$set_typein_module'(Module).\nmodule(Module) :-\n    '$set_typein_module'(Module),\n    print_message(warning, no_current_module(Module)).\n\n%!  working_directory(-Old, +New)\n%\n%   True when Old is the current working directory and the working\n%   directory has been updated to New.\n\nworking_directory(Old, New) :-\n    '$cwd'(Old),\n    (   Old == New\n    ->  true\n    ;   '$chdir'(New)\n    ).\n\n\n                 /*******************************\n                 *            TRIES             *\n                 *******************************/\n\n%!  current_trie(?Trie) is nondet.\n%\n%   True if Trie is the handle of an existing trie.\n\ncurrent_trie(Trie) :-\n    current_blob(Trie, trie),\n    is_trie(Trie).\n\n%!  trie_property(?Trie, ?Property)\n%\n%   True when Property is a property of Trie. Defined properties\n%   are:\n%\n%     - value_count(Count)\n%     Number of terms in the trie.\n%     - node_count(Count)\n%     Number of nodes in the trie.\n%     - size(Bytes)\n%     Number of bytes needed to store the trie.\n%     - hashed(Count)\n%     Number of hashed nodes.\n\ntrie_property(Trie, Property) :-\n    current_trie(Trie),\n    trie_property(Property),\n    '$trie_property'(Trie, Property).\n\ntrie_property(node_count(_)).\ntrie_property(value_count(_)).\ntrie_property(size(_)).\ntrie_property(hashed(_)).\n\n\n\n                /********************************\n                *      SYSTEM INTERACTION       *\n                *********************************/\n\nshell(Command) :-\n    shell(Command, 0).\n\n%!  win_add_dll_directory(+AbsDir) is det.\n%\n%   Add AbsDir to the directories where  dependent DLLs are searched\n%   on Windows systems.\n\n:- if(current_prolog_flag(windows, true)).\n:- export(win_add_dll_directory/1).\nwin_add_dll_directory(Dir) :-\n    win_add_dll_directory(Dir, _),\n    !.\nwin_add_dll_directory(Dir) :-\n    prolog_to_os_filename(Dir, OSDir),\n    getenv('PATH', Path0),\n    atomic_list_concat([Path0, OSDir], ';', Path),\n    setenv('PATH', Path).\n:- endif.\n\n                 /*******************************\n                 *            SIGNALS           *\n                 *******************************/\n\n:- meta_predicate\n    on_signal(+, :, :),\n    current_signal(?, ?, :).\n\n%!  on_signal(+Signal, -OldHandler, :NewHandler) is det.\n\non_signal(Signal, Old, New) :-\n    atom(Signal),\n    !,\n    '$on_signal'(_Num, Signal, Old, New).\non_signal(Signal, Old, New) :-\n    integer(Signal),\n    !,\n    '$on_signal'(Signal, _Name, Old, New).\non_signal(Signal, _Old, _New) :-\n    '$type_error'(signal_name, Signal).\n\n%!  current_signal(?Name, ?SignalNumber, :Handler) is nondet.\n\ncurrent_signal(Name, Id, Handler) :-\n    between(1, 32, Id),\n    '$on_signal'(Id, Name, Handler, Handler).\n\n:- multifile\n    prolog:called_by/2.\n\nprolog:called_by(on_signal(_,_,New), [New+1]) :-\n    (   new == throw\n    ;   new == default\n    ), !, fail.\n\n\n                 /*******************************\n                 *            DLOPEN            *\n                 *******************************/\n\n%!  open_shared_object(+File, -Handle) is det.\n%!  open_shared_object(+File, -Handle, +Flags) is det.\n%\n%   Open a shared object or DLL file. Flags  is a list of flags. The\n%   following flags are recognised. Note   however  that these flags\n%   may have no affect on the target platform.\n%\n%       * =now=\n%       Resolve all symbols in the file now instead of lazily.\n%       * =global=\n%       Make new symbols globally known.\n\nopen_shared_object(File, Handle) :-\n    open_shared_object(File, Handle, []). % use pl-load.c defaults\n\nopen_shared_object(File, Handle, Flags) :-\n    (   is_list(Flags)\n    ->  true\n    ;   throw(error(type_error(list, Flags), _))\n    ),\n    map_dlflags(Flags, Mask),\n    '$open_shared_object'(File, Handle, Mask).\n\ndlopen_flag(now,        2'01).          % see pl-load.c for these constants\ndlopen_flag(global,     2'10).          % Solaris only\n\nmap_dlflags([], 0).\nmap_dlflags([F|T], M) :-\n    map_dlflags(T, M0),\n    (   dlopen_flag(F, I)\n    ->  true\n    ;   throw(error(domain_error(dlopen_flag, F), _))\n    ),\n    M is M0 \\/ I.\n\n\n                 /*******************************\n                 *             I/O              *\n                 *******************************/\n\nformat(Fmt) :-\n    format(Fmt, []).\n\n                 /*******************************\n                 *            FILES             *\n                 *******************************/\n\n%!  absolute_file_name(+Term, -AbsoluteFile)\n\nabsolute_file_name(Name, Abs) :-\n    atomic(Name),\n    !,\n    '$absolute_file_name'(Name, Abs).\nabsolute_file_name(Term, Abs) :-\n    '$chk_file'(Term, [''], [access(read)], true, File),\n    !,\n    '$absolute_file_name'(File, Abs).\nabsolute_file_name(Term, Abs) :-\n    '$chk_file'(Term, [''], [], true, File),\n    !,\n    '$absolute_file_name'(File, Abs).\n\n%!  tmp_file_stream(-File, -Stream, +Encoding) is det.\n%!  tmp_file_stream(+Encoding, -File, -Stream) is det.\n\ntmp_file_stream(Enc, File, Stream) :-\n    atom(Enc), var(File), var(Stream),\n    !,\n    '$tmp_file_stream'('', Enc, File, Stream).\ntmp_file_stream(File, Stream, Options) :-\n    current_prolog_flag(encoding, DefEnc),\n    '$option'(encoding(Enc), Options, DefEnc),\n    '$option'(extension(Ext), Options, ''),\n    '$tmp_file_stream'(Ext, Enc, File, Stream).\n\n\n                /********************************\n                *        MEMORY MANAGEMENT      *\n                *********************************/\n\n%!  garbage_collect is det.\n%\n%   Invoke the garbage collector.  The   argument  of the underlying\n%   '$garbage_collect'/1  is  the  debugging  level  to  use  during\n%   garbage collection. This only works if   the  system is compiled\n%   with the -DODEBUG cpp flag. Only to simplify maintenance.\n\ngarbage_collect :-\n    '$garbage_collect'(0).\n\n%!  set_prolog_stack(+Name, +Option) is det.\n%\n%   Set a parameter for one of the Prolog stacks.\n\nset_prolog_stack(Stack, Option) :-\n    Option =.. [Name,Value0],\n    Value is Value0,\n    '$set_prolog_stack'(Stack, Name, _Old, Value).\n\n%!  prolog_stack_property(?Stack, ?Property) is nondet.\n%\n%   Examine stack properties.\n\nprolog_stack_property(Stack, Property) :-\n    stack_property(P),\n    stack_name(Stack),\n    Property =.. [P,Value],\n    '$set_prolog_stack'(Stack, P, Value, Value).\n\nstack_name(local).\nstack_name(global).\nstack_name(trail).\n\nstack_property(limit).\nstack_property(spare).\nstack_property(min_free).\nstack_property(low).\nstack_property(factor).\n\n\n                 /*******************************\n                 *             TERM             *\n                 *******************************/\n\n:- '$iso'((numbervars/3)).\n\n%!  numbervars(+Term, +StartIndex, -EndIndex) is det.\n%\n%   Number all unbound variables in Term   using  '$VAR'(N), where the\n%   first N is StartIndex and EndIndex is  unified to the index that\n%   will be given to the next variable.\n\nnumbervars(Term, From, To) :-\n    numbervars(Term, From, To, []).\n\n\n                 /*******************************\n                 *            STRING            *\n                 *******************************/\n\n%!  term_string(?Term, ?String, +Options)\n%\n%   Parse/write a term from/to a string using Options.\n\nterm_string(Term, String, Options) :-\n    nonvar(String),\n    !,\n    read_term_from_atom(String, Term, Options).\nterm_string(Term, String, Options) :-\n    (   '$option'(quoted(_), Options)\n    ->  Options1 = Options\n    ;   '$merge_options'(_{quoted:true}, Options, Options1)\n    ),\n    format(string(String), '~W', [Term, Options1]).\n\n\n                 /*******************************\n                 *             GVAR             *\n                 *******************************/\n\n%!  nb_setval(+Name, +Value) is det.\n%\n%   Bind the non-backtrackable variable Name with a copy of Value\n\nnb_setval(Name, Value) :-\n    duplicate_term(Value, Copy),\n    nb_linkval(Name, Copy).\n\n\n\t\t /*******************************\n\t\t *            THREADS\t\t*\n\t\t *******************************/\n\n:- meta_predicate\n    thread_create(0, -).\n\n%!  thread_create(:Goal, -Id)\n%\n%   Shorthand for thread_create(Goal, Id, []).\n\nthread_create(Goal, Id) :-\n    thread_create(Goal, Id, []).\n\n%!  thread_join(+Id)\n%\n%   Join a thread and raise an error of the thread did not succeed.\n%\n%   @error  thread_error(Status),  where  Status  is    the   result  of\n%   thread_join/2.\n\nthread_join(Id) :-\n    thread_join(Id, Status),\n    (   Status == true\n    ->  true\n    ;   throw(error(thread_error(Status), _))\n    ).\n\n%!  set_prolog_gc_thread(+Status)\n%\n%   Control the GC thread.  Status is one of\n%\n%     - false\n%     Disable the separate GC thread, running atom and clause\n%     garbage collection in the triggering thread.\n%     - true\n%     Enable the separate GC thread.  All implicit atom and clause\n%     garbage collection is executed by the thread `gc`.\n%     - stop\n%     Stop the `gc` thread if it is running.  The thread is recreated\n%     on the next implicit atom or clause garbage collection.  Used\n%     by fork/1 to avoid forking a multi-threaded application.\n\nset_prolog_gc_thread(Status) :-\n    var(Status),\n    !,\n    '$instantiation_error'(Status).\n:- if(current_prolog_flag(threads,true)).\nset_prolog_gc_thread(false) :-\n    !,\n    set_prolog_flag(gc_thread, false),\n    (   '$gc_stop'\n    ->  thread_join(gc)\n    ;   true\n    ).\nset_prolog_gc_thread(true) :-\n    !,\n    set_prolog_flag(gc_thread, true).\nset_prolog_gc_thread(stop) :-\n    !,\n    (   '$gc_stop'\n    ->  thread_join(gc)\n    ;   true\n    ).\n:- else.\nset_prolog_gc_thread(false) :- !.\nset_prolog_gc_thread(true) :- !.\nset_prolog_gc_thread(stop) :- !.\n:- endif.\nset_prolog_gc_thread(Status) :-\n    '$domain_error'(gc_thread, Status).\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/src/x11/x11-compat.c": "/*  Part of XPCE --- The SWI-Prolog GUI toolkit\n\n    Author:        Jan Wielemaker and Anjo Anjewierden\n    E-mail:        jan@swi.psy.uva.nl\n    WWW:           http://www.swi.psy.uva.nl/projects/xpce/\n    Copyright (c)  1985-2002, University of Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <h/kernel.h>\n#include <h/graphics.h>\n\n\t\t/********************************\n\t\t*            HACKS ...\t\t*\n\t\t********************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nWho  the   hell is using  these!?   It doesn't  seem  to be  the X11R5\nlibraries.  It certainly ain't PCE itself.  Nevertheless someone seems\nto refer  to them.  Unfortunately they only  in a dynamic library  and\nthus cannot be loaded through many foreign  language interfaces.  What\nto do????\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#if !defined(HAVE_LIBDL) && defined(__sun__) && XT_REVISION == 5\n\nvoid *\ndlopen(char *path, int mode)\n{ Cprintf(\"dlopen(%s, %d)\\n\", path, mode);\n\n  return NULL;\n}\n\n\nvoid *\ndlsym(void *handle, char *symbol)\n{ Cprintf(\"dlsym(%p, %s)\\n\", handle, symbol);\n\n  return NULL;\n}\n\n\nvoid *\ndlclose(void *handle)\n{ Cprintf(\"dlclose (%p)\\n\", handle);\n\n  return NULL;\n}\n\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMore of this nonsens.  RS6000 this time ...\n\n\tnm -pgo /usr/lib/libX11.a | grep _iconv_open\n\tshr4.o:         U __iconv_open\n\tshr4.o:0000fc18 T .__iconv_open\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#if _AIX\nvoid *\n__iconv_open()\n{ Cprintf(\"_iconv_open() called\\n\");\n\n  return NULL;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/cmake/Config.cmake": "check_include_file(inttypes.h HAVE_INTTYPES_H)\ncheck_include_file(stdlib.h HAVE_STDLIB_H)\ncheck_include_file(strings.h HAVE_STRINGS_H)\ncheck_include_file(wchar.h HAVE_WCHAR_H)\ncheck_include_file(alloca.h HAVE_ALLOCA_H)\ncheck_include_file(curses.h HAVE_CURSES_H)\ncheck_include_file(dirent.h HAVE_DIRENT_H)\ncheck_include_file(dl.h HAVE_DL_H)\ncheck_include_file(dlfcn.h HAVE_DLFCN_H)\ncheck_include_file(dmalloc.h HAVE_DMALLOC_H)\ncheck_include_file(execinfo.h HAVE_EXECINFO_H)\ncheck_include_file(float.h HAVE_FLOAT_H)\ncheck_include_file(floatingpoint.h HAVE_FLOATINGPOINT_H)\ncheck_include_file(ieeefp.h HAVE_IEEEFP_H)\ncheck_include_file(ieee754.h HAVE_IEEE754_H)\ncheck_include_file(libloaderapi.h HAVE_LIBLOADERAPI_H)\ncheck_include_file(limits.h HAVE_LIMITS_H)\ncheck_include_file(locale.h HAVE_LOCALE_H)\nif(NOT CMAKE_SYSTEM_NAME STREQUAL \"FreeBSD\")\ncheck_include_file(malloc.h HAVE_MALLOC_H)\nendif()\ncheck_include_file(memory.h HAVE_MEMORY_H)\ncheck_include_file(ncurses/curses.h HAVE_NCURSES_CURSES_H)\ncheck_include_file(ncurses/term.h HAVE_NCURSES_TERM_H)\ncheck_include_file(poll.h HAVE_POLL_H)\ncheck_include_file(pwd.h HAVE_PWD_H)\ncheck_include_file(shlobj.h HAVE_SHLOBJ_H)\ncheck_include_file(signal.h HAVE_SIGNAL_H)\ncheck_include_file(string.h HAVE_STRING_H)\ncheck_include_file(sys/dir.h HAVE_SYS_DIR_H)\ncheck_include_file(sys/file.h HAVE_SYS_FILE_H)\ncheck_include_file(sys/mman.h HAVE_SYS_MMAN_H)\ncheck_include_file(sys/ndir.h HAVE_SYS_NDIR_H)\ncheck_include_file(sys/param.h HAVE_SYS_PARAM_H)\ncheck_include_file(sys/resource.h HAVE_SYS_RESOURCE_H)\ncheck_include_file(sys/select.h HAVE_SYS_SELECT_H)\ncheck_include_file(sys/stat.h HAVE_SYS_STAT_H)\ncheck_include_file(sys/syscall.h HAVE_SYS_SYSCALL_H)\ncheck_include_file(sys/termio.h HAVE_SYS_TERMIO_H)\ncheck_include_file(sys/termios.h HAVE_SYS_TERMIOS_H)\ncheck_include_file(sys/time.h HAVE_SYS_TIME_H)\ncheck_include_file(sys/types.h HAVE_SYS_TYPES_H)\ncheck_include_file(sys/wait.h HAVE_SYS_WAIT_H)\ncheck_include_file(term.h HAVE_TERM_H)\ncheck_include_file(time.h HAVE_TIME_H)\ncheck_include_file(unistd.h HAVE_UNISTD_H)\ncheck_include_file(valgrind/valgrind.h HAVE_VALGRIND_VALGRIND_H)\ncheck_include_file(vfork.h HAVE_VFORK_H)\ncheck_include_file(mach/thread_act.h HAVE_MACH_THREAD_ACT_H)\ncheck_include_file(sys/stropts.h HAVE_SYS_STROPTS_H)\ncheck_include_file(zlib.h HAVE_ZLIB_H)\n\ncheck_library_exists(dl dlopen\t      \"\" HAVE_LIBDL)\ncheck_library_exists(m  sin           \"\" HAVE_LIBM)\ncheck_library_exists(rt clock_gettime \"\" HAVE_LIBRT)\n\nif(HAVE_LIBDL)\n  set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} dl)\nendif()\nif(HAVE_LIBM)\n  set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} m)\nendif()\nif(HAVE_LIBRT)\n  set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} rt)\nendif()\nif(CURSES_FOUND)\n  set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${CURSES_LIBRARIES})\nendif()\nif(GMP_FOUND)\n  set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${GMP_LIBRARIES})\n  set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES} ${GMP_INCLUDE_DIRS})\n  set(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} gmp.h)\nendif()\n\nset(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES}\n    ${CMAKE_THREAD_LIBS_INIT}\n)\n\nset(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} math.h)\n\n#if(CMAKE_C_COMPILER_ID STREQUAL \"GNU\")\n#  set(CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS} -Wno-builtin-declaration-mismatch)\n#endif()\n\n################\n# Types\n\ncheck_type_size(\"int\" SIZEOF_INT)\ncheck_type_size(\"long\" SIZEOF_LONG)\ncheck_type_size(\"void *\" SIZEOF_VOIDP)\ncheck_type_size(\"long long\" SIZEOF_LONG_LONG)\ncheck_type_size(\"wchar_t\" SIZEOF_WCHAR_T)\ncheck_type_size(\"mp_bitcnt_t\" SIZEOF_MP_BITCNT_T)\n\nif(NOT SIZEOF_MP_BITCNT_T STREQUAL \"\")\n  set(HAVE_MP_BITCNT_T 1)\nendif()\n\ninclude(AlignOf)\nalignof(ALIGNOF_INT64_T ALIGNOF_VOIDP ALIGNOF_DOUBLE)\n\n\n################\n# Functions\n\n# Misc\nif(NOT EMSCRIPTEN)\n  check_function_exists(mmap HAVE_MMAP)\nendif()\ncheck_function_exists(strerror HAVE_STRERROR)\ncheck_function_exists(poll HAVE_POLL)\ncheck_function_exists(popen HAVE_POPEN)\ncheck_function_exists(getpwnam HAVE_GETPWNAM)\ncheck_function_exists(fork HAVE_FORK)\ncheck_function_exists(vfork HAVE_VFORK)\ncheck_function_exists(qsort_r HAVE_QSORT_R)\ncheck_function_exists(qsort_s HAVE_QSORT_S)\ncheck_function_exists(getpagesize HAVE_GETPAGESIZE)\n# files\ncheck_function_exists(access HAVE_ACCESS)\ncheck_function_exists(chmod HAVE_CHMOD)\ncheck_function_exists(fchmod HAVE_FCHMOD)\ncheck_function_exists(fcntl HAVE_FCNTL)\ncheck_function_exists(fstat HAVE_FSTAT)\ncheck_function_exists(ftruncate HAVE_FTRUNCATE)\ncheck_function_exists(getcwd HAVE_GETCWD)\ncheck_function_exists(getwd HAVE_GETWD)\ncheck_function_exists(opendir HAVE_OPENDIR)\ncheck_function_exists(readlink HAVE_READLINK)\ncheck_function_exists(remove HAVE_REMOVE)\ncheck_function_exists(rename HAVE_RENAME)\ncheck_function_exists(stat HAVE_STAT)\n# Strings and locale\ncheck_function_exists(memmove HAVE_MEMMOVE)\ncheck_function_exists(strcasecmp HAVE_STRCASECMP)\ncheck_function_exists(stricmp HAVE_STRICMP)\ncheck_function_exists(strlwr HAVE_STRLWR)\ncheck_function_exists(setlocale HAVE_SETLOCALE)\ncheck_function_exists(mbsnrtowcs HAVE_MBSNRTOWCS)\ncheck_function_exists(mbcasescoll HAVE_MBCASESCOLL)\ncheck_function_exists(localeconv HAVE_LOCALECONV)\ncheck_function_exists(wcsdup HAVE_WCSDUP)\ncheck_function_exists(wcsxfrm HAVE_WCSXFRM)\n# processes\ncheck_function_exists(getpid HAVE_GETPID)\ncheck_function_exists(waitpid HAVE_WAITPID)\n# environment, config\ncheck_function_exists(setenv HAVE_SETENV)\ncheck_function_exists(putenv HAVE_PUTENV)\ncheck_function_exists(unsetenv HAVE_UNSETENV)\ncheck_function_exists(sysconf HAVE_SYSCONF)\ncheck_function_exists(confstr HAVE_CONFSTR)\ncheck_function_exists(getrlimit HAVE_GETRLIMIT)\ncheck_function_exists(getrusage HAVE_GETRUSAGE)\n# dynamic linking\ncheck_function_exists(shl_load HAVE_SHL_LOAD)\ncheck_function_exists(dlopen HAVE_DLOPEN)\ncheck_function_exists(dladdr HAVE_DLADDR)\n# signals\nif(USE_SIGNALS)\ncheck_function_exists(signal HAVE_SIGNAL)\ncheck_function_exists(sigprocmask HAVE_SIGPROCMASK)\ncheck_function_exists(sigsetmask HAVE_SIGSETMASK)\ncheck_function_exists(siggetmask HAVE_SIGGETMASK)\ncheck_function_exists(sigaction HAVE_SIGACTION)\ncheck_function_exists(sigset HAVE_SIGSET)\ncheck_function_exists(sigblock HAVE_SIGBLOCK)\nendif(USE_SIGNALS)\ncheck_function_exists(kill HAVE_KILL)\ncheck_function_exists(backtrace HAVE_BACKTRACE)\n# Allocation\ncheck_function_exists(mtrace HAVE_MTRACE)\n# terminal\ncheck_function_exists(tgetent HAVE_TGETENT)\ncheck_function_exists(tcsetattr HAVE_TCSETATTR)\ncheck_function_exists(grantpt HAVE_GRANTPT)\ncheck_function_exists(sgttyb HAVE_SGTTYB)\ncheck_function_exists(cfmakeraw HAVE_CFMAKERAW)\n# math\ncheck_function_exists(ceil HAVE_CEIL)\ncheck_function_exists(floor HAVE_FLOOR)\ncheck_function_exists(srand HAVE_SRAND)\ncheck_function_exists(srandom HAVE_SRANDOM)\ncheck_function_exists(random HAVE_RANDOM)\ncheck_function_exists(rint HAVE_RINT)\ncheck_function_exists(fpclass HAVE_FPCLASS)\ncheck_function_exists(_fpclass HAVE_FPCLASS)\n# check_function_exists(fpclassify HAVE_FPCLASSIFY)\ncheck_function_exists(fpresetsticky HAVE_FPRESETSTICKY)\ncheck_function_exists(fpsetmask HAVE_FPSETMASK)\ncheck_function_exists(isnan HAVE_ISNAN)\ncheck_function_exists(isinf HAVE_ISINF)\n# time and sleep\ncheck_function_exists(ftime HAVE_FTIME)\ncheck_function_exists(clock_gettime HAVE_CLOCK_GETTIME)\ncheck_function_exists(gettimeofday HAVE_GETTIMEOFDAY)\ncheck_function_exists(localtime_r HAVE_LOCALTIME_R)\ncheck_function_exists(localtime_s HAVE_LOCALTIME_S)\ncheck_function_exists(ctime_r HAVE_CTIME_R)\ncheck_function_exists(asctime_r HAVE_ASCTIME_R)\ncheck_function_exists(nanosleep HAVE_NANOSLEEP)\ncheck_function_exists(sleep HAVE_SLEEP)\ncheck_function_exists(usleep HAVE_USLEEP)\ncheck_function_exists(select HAVE_SELECT)\ncheck_function_exists(clock HAVE_CLOCK)\ncheck_function_exists(times HAVE_TIMES)\ncheck_function_exists(delay HAVE_DELAY)\ncheck_function_exists(dossleep HAVE_DOSSLEEP)\ncheck_function_exists(clock_gettime HAVE_CLOCK_GETTIME)\n# threads and scheduling\nif(CMAKE_USE_PTHREADS_INIT)\ncheck_c_source_compiles(\n    \"#include <sys/param.h>\n     #include <sys/cpuset.h>\n     int main() {}\"\n    SYS_CPUSET_H_FOUND)\nif(SYS_CPUSET_H_FOUND)\n  check_c_source_compiles(\n      \"#include <sys/param.h>\n       #include <sys/cpuset.h>\n       int main(int argc, char** argv)\n       {\n        (void)argv;\n       #ifndef CPU_ZERO\n        return ((int*)(&CPU_ZERO))[argc];\n       #else\n        (void)argc;\n        return 0;\n       #endif\n       }\"\n      HAVE_SYS_CPUSET_H)\n  check_c_source_compiles(\n      \"#include <sys/param.h>\n       #include <sys/cpuset.h>\n       typedef cpuset_t cpu_set_t;\n       int main() { cpu_set_t *set; CPU_ZERO(set);}\"\n      HAVE_CPUSET_T)\nendif(SYS_CPUSET_H_FOUND)\ncheck_include_file(pthread_np.h HAVE_PTHREAD_NP_H)\ncheck_function_exists(pthread_attr_setaffinity_np HAVE_PTHREAD_ATTR_SETAFFINITY_NP)\ncheck_function_exists(pthread_getname_np HAVE_PTHREAD_GETNAME_NP)\ncheck_function_exists(pthread_getw32threadhandle_np HAVE_PTHREAD_GETW32THREADHANDLE_NP)\ncheck_function_exists(pthread_kill HAVE_PTHREAD_KILL)\ncheck_function_exists(pthread_mutexattr_setkind_np HAVE_PTHREAD_MUTEXATTR_SETKIND_NP)\ncheck_function_exists(pthread_mutexattr_settype HAVE_PTHREAD_MUTEXATTR_SETTYPE)\ncheck_function_exists(pthread_mutex_timedlock HAVE_PTHREAD_MUTEX_TIMEDLOCK)\ncheck_function_exists(pthread_setconcurrency HAVE_PTHREAD_SETCONCURRENCY)\ncheck_function_exists(pthread_setname_np HAVE_PTHREAD_SETNAME_NP)\ncheck_function_exists(pthread_sigmask HAVE_PTHREAD_SIGMASK)\ncheck_function_exists(pthread_timedjoin_np HAVE_PTHREAD_TIMEDJOIN_NP)\ncheck_function_exists(pthread_getcpuclockid HAVE_PTHREAD_GETCPUCLOCKID)\ncheck_function_exists(pthread_attr_setstacksize HAVE_PTHREAD_ATTR_SETSTACKSIZE)\ncheck_function_exists(sched_setaffinity HAVE_SCHED_SETAFFINITY)\ncheck_function_exists(sema_init HAVE_SEMA_INIT)\ncheck_function_exists(sem_init HAVE_SEM_INIT)\n\ninclude(TestRecursiveMutex)\n\nif(HAVE_PTHREAD_SETNAME_NP)\nfunction(check_pthread_setname_np)\n  set(CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS} -Werror)\n  check_c_source_compiles(\n      \"#define _GNU_SOURCE\n       #include <pthread.h>\\nint main()\n       { pthread_setname_np(0, \\\"myname\\\"); return 0;\n       }\"\n      HAVE_PTHREAD_SETNAME_NP_WITH_TID)\n\n  check_c_source_compiles(\n      \"#define _GNU_SOURCE\n       #include <pthread.h>\n       int main()\n       { pthread_setname_np(0, \\\"%s\\\", (void *)\\\"myname\\\"); return 0;\n       }\"\n      HAVE_PTHREAD_SETNAME_NP_WITH_TID_AND_ARG)\n\n  if(HAVE_PTHREAD_SETNAME_NP_WITH_TID)\n    set(HAVE_PTHREAD_SETNAME_NP_WITH_TID 1 PARENT_SCOPE)\n  elseif(HAVE_PTHREAD_SETNAME_NP_WITH_TID_AND_ARG)\n    set(HAVE_PTHREAD_SETNAME_NP_WITH_TID_AND_ARG 1 PARENT_SCOPE)\n  endif()\nendfunction()\ncheck_pthread_setname_np()\nendif(HAVE_PTHREAD_SETNAME_NP)\n\ncheck_c_source_compiles(\n    \"#include <sys/types.h>\n     #include <linux/unistd.h>\n     int main()\n     { _syscall0(pid_t,gettid);\n       return 0;\n     }\"\n    HAVE_GETTID_MACRO)\nif(NOT HAVE_GETTID_MACRO)\n  check_c_source_compiles(\n      \"#include <unistd.h>\n       #include <sys/syscall.h>\n       int main()\n       { syscall(__NR_gettid);\n\t return 0;\n       }\"\n      HAVE_GETTID_SYSCALL)\nendif()\n\nendif(CMAKE_USE_PTHREADS_INIT)\n# Windows\ncheck_function_exists(WSAPoll HAVE_WSAPOLL)\ncheck_function_exists(WinExec HAVE_WINEXEC)\n\ncheck_symbol_exists(F_SETLKW fcntl.h HAVE_F_SETLKW)\n\ncheck_c_source_compiles(\n    \"#include <time.h>\n     extern long timezone;\n     int main() { return 0;}\"\n     HAVE_VAR_TIMEZONE)\n\ncheck_symbol_exists(SIGPROF signal.h HAVE_SIGPROF)\n\ncheck_struct_has_member(\"struct tm\" tm_gmtoff time.h HAVE_STRUCT_TIME_TM_GMTOFF)\ncheck_struct_has_member(\"struct stat\" st_mtim sys/stat.h HAVE_STRUCT_STAT_ST_MTIM)\ncheck_struct_has_member(\"struct rusage\" ru_idrss sys/resource.h HAVE_RU_IDRSS)\n\n# GMP\n# check_function_exists(gmp_randinit_mt HAVE_GMP_RANDINIT_MT)\n# Requires <gmp.h> as this is a macro\ncheck_c_source_compiles(\n    \"#include <gmp.h>\\nint main() { gmp_randinit_mt(0); return 0;}\"\n    HAVE_GMP_RANDINIT_MT)\n\nif(HAVE_QSORT_R)\n  include(TestGNUQsortR)\nendif()\n\n# Don't test BSD signals on EMSCRIPTEN - hangs the process.\nif(HAVE_SIGNAL AND NOT HAVE_SIGACTION AND NOT EMSCRIPTEN)\n  include(TestBSDSignals)\nendif()\n\n\n################\n# Set of features compatible with the old config tools\n\nif(HAVE_CLOCK_GETTIME AND HAVE_PTHREAD_GETCPUCLOCKID)\n  set(PTHREAD_CPUCLOCKS 1)\nendif()\nif(CMAKE_USE_PTHREADS_INIT)\n  set(O_PLMT 1)\n  if(HAVE_GETRLIMIT AND HAVE_PTHREAD_ATTR_SETSTACKSIZE)\n    set(USE_COPY_STACK_SIZE 1)\n  endif()\nendif()\nif(HAVE_PTHREAD_MUTEX_RECURSIVE_NP OR HAVE_PTHREAD_MUTEX_RECURSIVE)\n  set(RECURSIVE_MUTEXES 1)\nendif()\nif(GMP_FOUND)\n  set(HAVE_GMP_H 1)\nendif()\nif(HAVE_F_SETLKW AND HAVE_FCNTL)\n  set(FCNTL_LOCKS 1)\nendif()\nif(HAVE_SIGPROF)\n  set(O_SIGPROF_PROFILE 1)\nendif()\nif(HAVE_READLINK)\n  set(HAVE_SYMLINKS 1)\nendif()\nif(SWIPL_SHARED_LIB)\n  set(O_SHARED_KERNEL 1)\nendif()\n\n################\n# Stuff we do not need to define is below such that findmacros.pl does\n# not complain about them.\n\n# HAVE_VISITED (locally defined and used)\n# HAVE_SIGNALS (locally defined and used)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/swipl.ico",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/minizip/file.zip",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/libtai/leapsecs.dat",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/src/Tests/charset/UTF-8-test.txt",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/xrefchatdep.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/broadcast.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/swipl.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/xrefchatfile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/by-sa.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/broadcast.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/profnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/profnode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/swipl.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/by-sa.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/xrefchatfile.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/man/figs/xrefchatdep.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/ssl/etc/client/client-cert.p12",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/RDF/suite/t38.rdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/ltx2htm/icons/next.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/ltx2htm/icons/prev.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/ltx2htm/icons/home.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/ltx2htm/icons/index.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/ltx2htm/icons/yellow_pages.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/ltx2htm/icons/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/ltx2htm/icons/info.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/swipl-win/swipl.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/swipl-win/swipl.icns",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/table/test.dat",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/zlib/tests/binary-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/zlib/tests/ascii-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/zlib/tests/utf8-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/zlib/tests/multipart-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/zlib/tests/empty-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/zlib/tests/low-compression.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/zlib/tests/high-compression.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/semweb/modules.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/semweb/figs/modules.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/semweb/figs/modules.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/semweb/Tests/test-002.rdf.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/protobufs/golden_message.2.5.0",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/protobufs/golden_message.2.3.0",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/editpred.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/multi-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/source.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/priv-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/private.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/reload.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/h1-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/public.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/edit.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/h2-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pldoc/pub-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/lib/x11.crs",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/prolog/lib/man/classification.dat",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/prolog/lib/trace/pltracer.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/appl-help/emacs.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/appl-help/event_monitor.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/appl-help/pcefaq.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/appl-help/pcedraw.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/appl-help/dialog.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/appl-help/help.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/appl-help/customise.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/appl-help/plprefs.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/swipl/swipl.ico",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/TeX/figs/manpce.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/TeX/figs/swi.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/userguide/figs/classbrowser.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/userguide/figs/classhierarchy.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/userguide/figs/vishierarchy.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/userguide/figs/layoutmgr.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/userguide/figs/docclasses.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/userguide/figs/broadcast.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/tools.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/topics.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/errors.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/bug_fixes.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/predicates.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/groups.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/objects.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/changes.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/examples.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/constraint.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/colour.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/identity.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/attribute.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/stream.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/text.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/relation_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/modifier.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/parser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/format.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/obtain.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/function.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/tuple.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/while.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/and.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/graphical.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/button.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/text_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/@=.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/table_column.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/browser_select_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/regex.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/pixmap.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/get_method.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/code.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/send_method.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/variable.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/not.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/syntax_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/box.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/tile_adjuster.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/equal.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/text_image.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/visual.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/class_variable.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/lesseq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/char_array.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/point.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/bezier_curve.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/chain_hyper.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/table_cell.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/chain.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/label_box.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/binary_condition.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/tree.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/tile.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/grbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/socket.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/event_node.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/resize_outline_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/hyper.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/greateq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/label.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/when.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/vector.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/device.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/relation.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/move_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/process.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/style.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/tbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/number.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/slider.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/view.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/arrow.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/prolog_term.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/region.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/dict_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/bool.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/pce.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/recogniser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/c_pointer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/message.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/dialog_group.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/popup_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/circle.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/source_location.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/editor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/list_browser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/win_metafile.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/elevation.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/name.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/click_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/browser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/binary_expression.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/lbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/line.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/hash_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/handle.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/file.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/string.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/dialog.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/less.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/sheet.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/program_object.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/resource.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/picture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/scroll_bar.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/quote_function.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/timer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/event_tree.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/text_margin.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/layout_manager.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/win_printer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/bitmap.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/path.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/display.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/handler_group.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/resize_table_slice_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/date.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/tab.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/figure.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/if.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/image.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/host_data.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/nameref.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/ellipse.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/rubber.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/joint.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/noteq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/plus.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/text_cursor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/assign.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/size.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/eq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/key_binding.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/connect_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/code_vector.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/dict.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/dialog_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/popup.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/minus.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/block.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/event.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/create.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/or.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/operator.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/progn.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/connection.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/window.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/error.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/tab_stack.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/vmi.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/constant.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/int_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/arc.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/text_buffer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/frame.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/cursor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/divide.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/class.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/greater.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/font.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/host.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/fragment.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/menu_bar.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/object.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/var.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/parbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/method.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/spatial.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/chain_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/binding.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/times.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/source_sink.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/window_decorator.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/table_slice.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/hbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/menu.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/link.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/type.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/node.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/colour_map.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/display_manager.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/application.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/directory.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/area.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/resize_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/real.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/menu_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/table_row.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/monitor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/tokeniser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/move_outline_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/handler.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/reference/class/behaviour.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/course/figs/hello.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/course/figs/ftp.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/xpce/man/course/figs/control.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pengines/pltpsynch.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pengines/penarch.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pengines/pltpruncolour.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/pengines/examples/web/queen.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/jpl/web/jpl.war",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/jpl/docs/images/screendump.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/jpl/docs/files/libjpl.dylib",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/http/web/icons/generic.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/http/web/icons/folder.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/http/web/icons/compressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/http/web/icons/back.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/http/web/icons/openid-logo-square.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/http/web/icons/layout.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/http/web/icons/c.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-bw7sbyinzktzigcgylb6pmdio6yt5eyy/spack-src/packages/http/web/icons/openid-logo-tiny.png"
    ],
    "total_files": 3902
}