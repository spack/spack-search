{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/configure.cmake": "# Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; version 2 of the License.\n# \n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n#\n\nINCLUDE (CheckCSourceCompiles)\nINCLUDE (CheckCXXSourceCompiles)\nINCLUDE (CheckStructHasMember)\nINCLUDE (CheckLibraryExists)\nINCLUDE (CheckFunctionExists)\nINCLUDE (CheckCCompilerFlag)\nINCLUDE (CheckCSourceRuns)\nINCLUDE (CheckCXXSourceRuns)\nINCLUDE (CheckSymbolExists)\n\n\n# WITH_PIC options.Not of much use, PIC is taken care of on platforms\n# where it makes sense anyway.\nIF(UNIX)\n  IF(APPLE)  \n    # OSX  executable are always PIC\n    SET(WITH_PIC ON)\n  ELSE()\n    OPTION(WITH_PIC \"Generate PIC objects\" OFF)\n    IF(WITH_PIC)\n      SET(CMAKE_C_FLAGS \n        \"${CMAKE_C_FLAGS} ${CMAKE_SHARED_LIBRARY_C_FLAGS}\")\n      SET(CMAKE_CXX_FLAGS \n        \"${CMAKE_CXX_FLAGS} ${CMAKE_SHARED_LIBRARY_CXX_FLAGS}\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND CMAKE_COMPILER_IS_GNUCXX)\n  ## We will be using gcc to generate .so files\n  ## Add C flags (e.g. -m64) to CMAKE_SHARED_LIBRARY_C_FLAGS\n  ## The client library contains C++ code, so add dependency on libstdc++\n  ## See cmake --help-policy CMP0018\n  SET(CMAKE_SHARED_LIBRARY_C_FLAGS\n    \"${CMAKE_SHARED_LIBRARY_C_FLAGS} ${CMAKE_C_FLAGS} -lstdc++\")\nENDIF()\n\n\n# System type affects version_compile_os variable \nIF(NOT SYSTEM_TYPE)\n  IF(PLATFORM)\n    SET(SYSTEM_TYPE ${PLATFORM})\n  ELSE()\n    SET(SYSTEM_TYPE ${CMAKE_SYSTEM_NAME})\n  ENDIF()\nENDIF()\n\n# Probobuf 2.6.1 on Sparc. Both gcc and Solaris Studio need this.\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND\n    SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n  ADD_DEFINITIONS(-DSOLARIS_64BIT_ENABLED)\nENDIF()\n\n# Nothing explicit on command line? Use c++03\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND\n   CMAKE_C_COMPILER_ID MATCHES \"SunPro\" AND\n   NOT CMAKE_CXX_FLAGS MATCHES \"-std=\" AND\n   NOT CMAKE_CXX_FLAGS MATCHES \"-library\" AND\n   NOT CMAKE_CXX_FLAGS MATCHES \"stdcxx4\" AND\n   NOT CMAKE_CXX_FLAGS MATCHES \"stlport\"\n   )\n  IF(SUNPRO_CXX_LIBRARY)\n    MESSAGE(WARNING \"You should upgrade to -std=c++03\")\n  ELSE()\n    # cmake/os/SunOS.cmake has done version check\n    # /opt/solarisstudio12.4/bin/CC has CC_MINOR_VERSION == 13\n    IF(DEFINED CC_MINOR_VERSION AND CC_MINOR_VERSION GREATER 12)\n      MESSAGE(\"Adding -std=c++03\")\n      SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++03\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n# The default C++ library for SunPro is really old, and not standards compliant.\n# http://www.oracle.com/technetwork/server-storage/solaris/cmp-stlport-libcstd-142559.html\n# Use stlport rather than Rogue Wave,\n#   unless otherwise specified on command line.\n# This does *not* work for building the server, only for client libraries,\n# i.e. -DWITHOUT_SERVER=1\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\")\n  IF(CMAKE_CXX_COMPILER_ID MATCHES \"SunPro\")\n    IF(CMAKE_CXX_FLAGS MATCHES \"-std=\")\n      # Nothing here, handled separately below\n    ELSE()\n      IF(SUNPRO_CXX_LIBRARY)\n        SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -library=${SUNPRO_CXX_LIBRARY}\")\n        IF(SUNPRO_CXX_LIBRARY STREQUAL \"stdcxx4\")\n          ADD_DEFINITIONS(-D__MATHERR_RENAME_EXCEPTION)\n          SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -template=extdef\")\n        ENDIF()\n      ELSE()\n        SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -library=stlport4\")\n      ENDIF()\n    ENDIF()\n  ENDIF()\nENDIF()\n\n# Check to see if we are using LLVM's libc++ rather than e.g. libstd++\n# Can then check HAVE_LLBM_LIBCPP later without including e.g. ciso646.\nCHECK_CXX_SOURCE_RUNS(\"\n#include <ciso646>\nint main()\n{\n#ifdef _LIBCPP_VERSION\n  return 0;\n#else\n  return 1;\n#endif\n}\" HAVE_LLVM_LIBCPP)\n\nMACRO(DIRNAME IN OUT)\n  GET_FILENAME_COMPONENT(${OUT} ${IN} PATH)\nENDMACRO()\n\nMACRO(FIND_REAL_LIBRARY SOFTLINK_NAME REALNAME)\n  # We re-distribute libstlport.so/libstdc++.so which are both symlinks.\n  # There is no 'readlink' on solaris, so we use perl to follow links:\n  SET(PERLSCRIPT\n    \"my $link= $ARGV[0]; use Cwd qw(abs_path); my $file = abs_path($link); print $file;\")\n  EXECUTE_PROCESS(\n    COMMAND perl -e \"${PERLSCRIPT}\" ${SOFTLINK_NAME}\n    RESULT_VARIABLE result\n    OUTPUT_VARIABLE real_library\n    )\n  SET(REALNAME ${real_library})\nENDMACRO()\n\nMACRO(EXTEND_CXX_LINK_FLAGS LIBRARY_PATH)\n  # Using the $ORIGIN token with the -R option to locate the libraries\n  # on a path relative to the executable:\n  # We need an extra backslash to pass $ORIGIN to the mysql_config script...\n  SET(QUOTED_CMAKE_CXX_LINK_FLAGS\n    \"${CMAKE_CXX_LINK_FLAGS} -R'\\\\$ORIGIN/../lib' -R${LIBRARY_PATH} \")\n  SET(CMAKE_CXX_LINK_FLAGS\n    \"${CMAKE_CXX_LINK_FLAGS} -R'\\$ORIGIN/../lib' -R${LIBRARY_PATH}\")\n  MESSAGE(STATUS \"CMAKE_CXX_LINK_FLAGS ${CMAKE_CXX_LINK_FLAGS}\")\nENDMACRO()\n\nMACRO(EXTEND_C_LINK_FLAGS LIBRARY_PATH)\n  SET(CMAKE_C_LINK_FLAGS\n    \"${CMAKE_C_LINK_FLAGS} -R'\\$ORIGIN/../lib' -R${LIBRARY_PATH}\")\n  MESSAGE(STATUS \"CMAKE_C_LINK_FLAGS ${CMAKE_C_LINK_FLAGS}\")\n  SET(CMAKE_SHARED_LIBRARY_C_FLAGS\n    \"${CMAKE_SHARED_LIBRARY_C_FLAGS} -R'\\$ORIGIN/../lib' -R${LIBRARY_PATH}\")\nENDMACRO()\n\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND CMAKE_COMPILER_IS_GNUCC)\n  DIRNAME(${CMAKE_CXX_COMPILER} CXX_PATH)\n  SET(LIB_SUFFIX \"lib\")\n  IF(SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n    SET(LIB_SUFFIX \"lib/sparcv9\")\n  ENDIF()\n  IF(SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"i386\")\n    SET(LIB_SUFFIX \"lib/amd64\")\n  ENDIF()\n  FIND_LIBRARY(GPP_LIBRARY_NAME\n    NAMES \"stdc++\"\n    PATHS ${CXX_PATH}/../${LIB_SUFFIX}\n    NO_DEFAULT_PATH\n  )\n  MESSAGE(STATUS \"GPP_LIBRARY_NAME ${GPP_LIBRARY_NAME}\")\n  IF(GPP_LIBRARY_NAME)\n    DIRNAME(${GPP_LIBRARY_NAME} GPP_LIBRARY_PATH)\n    FIND_REAL_LIBRARY(${GPP_LIBRARY_NAME} real_library)\n    MESSAGE(STATUS \"INSTALL ${GPP_LIBRARY_NAME} ${real_library}\")\n    INSTALL(FILES ${GPP_LIBRARY_NAME} ${real_library}\n            DESTINATION ${INSTALL_LIBDIR} COMPONENT SharedLibraries)\n    EXTEND_CXX_LINK_FLAGS(${GPP_LIBRARY_PATH})\n    EXECUTE_PROCESS(\n      COMMAND sh -c \"elfdump ${real_library} | grep SONAME\"\n      RESULT_VARIABLE result\n      OUTPUT_VARIABLE sonameline\n    )\n    IF(NOT result)\n      STRING(REGEX MATCH \"libstdc.*[^\\n]\" soname ${sonameline})\n      MESSAGE(STATUS \"INSTALL ${GPP_LIBRARY_PATH}/${soname}\")\n      INSTALL(FILES \"${GPP_LIBRARY_PATH}/${soname}\"\n              DESTINATION ${INSTALL_LIBDIR} COMPONENT SharedLibraries)\n    ENDIF()\n  ENDIF()\n  FIND_LIBRARY(GCC_LIBRARY_NAME\n    NAMES \"gcc_s\"\n    PATHS ${CXX_PATH}/../${LIB_SUFFIX}\n    NO_DEFAULT_PATH\n  )\n  IF(GCC_LIBRARY_NAME)\n    DIRNAME(${GCC_LIBRARY_NAME} GCC_LIBRARY_PATH)\n    FIND_REAL_LIBRARY(${GCC_LIBRARY_NAME} real_library)\n    MESSAGE(STATUS \"INSTALL ${GCC_LIBRARY_NAME} ${real_library}\")\n    INSTALL(FILES ${GCC_LIBRARY_NAME} ${real_library}\n            DESTINATION ${INSTALL_LIBDIR} COMPONENT SharedLibraries)\n    EXTEND_C_LINK_FLAGS(${GCC_LIBRARY_PATH})\n  ENDIF()\nENDIF()\n\n# TODO: consider to INSTALL this library\n# /opt/developerstudio12.5/lib/compilers/atomic/sparcv9/libstatomic.so\n# see: https://docs.oracle.com/cd/E60778_01/html/E60746/gqhbq.html\n# We assume that developer studio runtime libraries are installed.\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND\n   CMAKE_CXX_COMPILER_ID STREQUAL \"SunPro\" AND\n   CMAKE_CXX_FLAGS MATCHES \"-std=c\")\n  DIRNAME(${CMAKE_CXX_COMPILER} CXX_PATH)\n\n  SET(LIBRARY_SUFFIX \"lib/compilers/CC-gcc/lib\")\n  IF(SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n    SET(LIBRARY_SUFFIX \"${LIBRARY_SUFFIX}/sparcv9\")\n  ENDIF()\n  IF(SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"i386\")\n    SET(LIBRARY_SUFFIX \"${LIBRARY_SUFFIX}/amd64\")\n  ENDIF()\n  FIND_LIBRARY(STL_LIBRARY_NAME\n    NAMES \"stdc++\"\n    PATHS ${CXX_PATH}/../${LIBRARY_SUFFIX}\n    NO_DEFAULT_PATH\n  )\n  MESSAGE(STATUS \"STL_LIBRARY_NAME ${STL_LIBRARY_NAME}\")\n  IF(STL_LIBRARY_NAME)\n    DIRNAME(${STL_LIBRARY_NAME} STL_LIBRARY_PATH)\n    SET(QUOTED_CMAKE_CXX_LINK_FLAGS\n      \"${CMAKE_CXX_LINK_FLAGS} -L${STL_LIBRARY_PATH} -R${STL_LIBRARY_PATH}\")\n    SET(CMAKE_CXX_LINK_FLAGS\n      \"${CMAKE_CXX_LINK_FLAGS} -L${STL_LIBRARY_PATH} -R${STL_LIBRARY_PATH}\")\n    SET(CMAKE_C_LINK_FLAGS\n      \"${CMAKE_C_LINK_FLAGS} -L${STL_LIBRARY_PATH} -R${STL_LIBRARY_PATH}\")\n  ENDIF()\n  SET(CMAKE_C_LINK_FLAGS\n    \"${CMAKE_C_LINK_FLAGS} -lc\")\n  SET(CMAKE_CXX_LINK_FLAGS\n    \"${CMAKE_CXX_LINK_FLAGS} -lstdc++ -lgcc_s -lCrunG3 -lc\")\n  SET(QUOTED_CMAKE_CXX_LINK_FLAGS\n    \"${QUOTED_CMAKE_CXX_LINK_FLAGS} -lstdc++ -lgcc_s -lCrunG3 -lc \")\n  SET(QUOTED_CMAKE_CXX_LINK_FLAGS\n    \"${QUOTED_CMAKE_CXX_LINK_FLAGS} -L/usr/lib -latomic \")\nENDIF()\n\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND\n   CMAKE_C_COMPILER_ID MATCHES \"SunPro\" AND\n   CMAKE_CXX_FLAGS MATCHES \"stlport4\")\n  DIRNAME(${CMAKE_CXX_COMPILER} CXX_PATH)\n  # Also extract real path to the compiler(which is normally\n  # in <install_path>/prod/bin) and try to find the\n  # stlport libs relative to that location as well.\n  GET_FILENAME_COMPONENT(CXX_REALPATH ${CMAKE_CXX_COMPILER} REALPATH)\n\n  # CC -V yields\n  # CC: Studio 12.6 Sun C++ 5.15 SunOS_sparc Beta 2016/12/19\n  # CC: Studio 12.5 Sun C++ 5.14 SunOS_sparc Dodona 2016/04/04\n  # CC: Sun C++ 5.13 SunOS_sparc Beta 2014/03/11\n  # CC: Sun C++ 5.11 SunOS_sparc 2010/08/13\n\n  EXECUTE_PROCESS(\n    COMMAND ${CMAKE_CXX_COMPILER} \"-V\"\n    OUTPUT_VARIABLE stdout\n    ERROR_VARIABLE  stderr\n    RESULT_VARIABLE result\n  )\n  IF(result)\n    MESSAGE(FATAL_ERROR \"Failed to execute ${CMAKE_CXX_COMPILER} -V\")\n  ENDIF()\n\n  STRING(REGEX MATCH \"CC: Sun C\\\\+\\\\+ 5\\\\.([0-9]+)\" VERSION_STRING ${stderr})\n  IF (NOT CMAKE_MATCH_1 OR CMAKE_MATCH_1 STREQUAL \"\")\n    STRING(REGEX MATCH \"CC: Studio 12\\\\.[56] Sun C\\\\+\\\\+ 5\\\\.([0-9]+)\"\n      VERSION_STRING ${stderr})\n  ENDIF()\n  SET(CC_MINOR_VERSION ${CMAKE_MATCH_1})\n\n  IF(${CC_MINOR_VERSION} EQUAL 14)\n    MESSAGE(FATAL_ERROR\n      \"Please run cmake with -DCMAKE_CXX_FLAGS=-std=c++03 for ${stderr}\")\n  ENDIF()\n\n  IF(${CC_MINOR_VERSION} EQUAL 13)\n    SET(STLPORT_SUFFIX \"lib/compilers/stlport4\")\n    IF(SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n      SET(STLPORT_SUFFIX \"lib/compilers/stlport4/sparcv9\")\n    ENDIF()\n    IF(SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"i386\")\n      SET(STLPORT_SUFFIX \"lib/compilers/stlport4/amd64\")\n    ENDIF()\n  ELSE()\n    SET(STLPORT_SUFFIX \"lib/stlport4\")\n    IF(SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n      SET(STLPORT_SUFFIX \"lib/stlport4/v9\")\n    ENDIF()\n    IF(SIZEOF_VOIDP EQUAL 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"i386\")\n      SET(STLPORT_SUFFIX \"lib/stlport4/amd64\")\n    ENDIF()\n  ENDIF()\n\n  FIND_LIBRARY(STL_LIBRARY_NAME\n    NAMES \"stlport\"\n    PATHS ${CXX_PATH}/../${STLPORT_SUFFIX}\n          ${CXX_REALPATH}/../../${STLPORT_SUFFIX}\n  )\n  MESSAGE(STATUS \"STL_LIBRARY_NAME ${STL_LIBRARY_NAME}\")\n  IF(STL_LIBRARY_NAME)\n    DIRNAME(${STL_LIBRARY_NAME} STLPORT_PATH)\n    FIND_REAL_LIBRARY(${STL_LIBRARY_NAME} real_library)\n    MESSAGE(STATUS \"INSTALL ${STL_LIBRARY_NAME} ${real_library}\")\n    INSTALL(FILES ${STL_LIBRARY_NAME} ${real_library}\n            DESTINATION ${INSTALL_LIBDIR} COMPONENT SharedLibraries)\n    EXTEND_C_LINK_FLAGS(${STLPORT_PATH})\n    EXTEND_CXX_LINK_FLAGS(${STLPORT_PATH})\n  ELSE()\n    MESSAGE(STATUS \"Failed to find the reuired stlport library, print some\"\n                   \"variables to help debugging and bail out\")\n    MESSAGE(STATUS \"CMAKE_CXX_COMPILER ${CMAKE_CXX_COMPILER}\")\n    MESSAGE(STATUS \"CXX_PATH ${CXX_PATH}\")\n    MESSAGE(STATUS \"CXX_REALPATH ${CXX_REALPATH}\")\n    MESSAGE(STATUS \"STLPORT_SUFFIX ${STLPORT_SUFFIX}\")\n    MESSAGE(STATUS \"PATH: ${CXX_PATH}/../${STLPORT_SUFFIX}\")\n    MESSAGE(STATUS \"PATH: ${CXX_REALPATH}/../../${STLPORT_SUFFIX}\")\n    MESSAGE(FATAL_ERROR\n      \"Could not find the required stlport library.\")\n  ENDIF()\nENDIF()\n\nIF(CMAKE_COMPILER_IS_GNUCXX)\n  IF (CMAKE_EXE_LINKER_FLAGS MATCHES \" -static \" \n     OR CMAKE_EXE_LINKER_FLAGS MATCHES \" -static$\")\n     SET(HAVE_DLOPEN FALSE CACHE \"Disable dlopen due to -static flag\" FORCE)\n     SET(WITHOUT_DYNAMIC_PLUGINS TRUE)\n  ENDIF()\nENDIF()\n\nIF(WITHOUT_DYNAMIC_PLUGINS)\n  MESSAGE(\"Dynamic plugins are disabled.\")\nENDIF(WITHOUT_DYNAMIC_PLUGINS)\n\n# Large files, common flag\nSET(_LARGEFILE_SOURCE  1)\n\n# Same for structs, setting HAVE_STRUCT_<name> instead\nFUNCTION(MY_CHECK_STRUCT_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"struct ${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_STRUCT_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# Searches function in libraries\n# if function is found, sets output parameter result to the name of the library\n# if function is found in libc, result will be empty \nFUNCTION(MY_SEARCH_LIBS func libs result)\n  IF(${${result}})\n    # Library is already found or was predefined\n    RETURN()\n  ENDIF()\n  CHECK_FUNCTION_EXISTS(${func} HAVE_${func}_IN_LIBC)\n  IF(HAVE_${func}_IN_LIBC)\n    SET(${result} \"\" PARENT_SCOPE)\n    RETURN()\n  ENDIF()\n  FOREACH(lib  ${libs})\n    CHECK_LIBRARY_EXISTS(${lib} ${func} \"\" HAVE_${func}_IN_${lib}) \n    IF(HAVE_${func}_IN_${lib})\n      SET(${result} ${lib} PARENT_SCOPE)\n      SET(HAVE_${result} 1 PARENT_SCOPE)\n      RETURN()\n    ENDIF()\n  ENDFOREACH()\nENDFUNCTION()\n\n# Find out which libraries to use.\n\n# Figure out threading library\n# Defines CMAKE_USE_PTHREADS_INIT and CMAKE_THREAD_LIBS_INIT.\nFIND_PACKAGE (Threads)\n\nIF(UNIX)\n  MY_SEARCH_LIBS(floor m LIBM)\n  IF(NOT LIBM)\n    MY_SEARCH_LIBS(__infinity m LIBM)\n  ENDIF()\n  MY_SEARCH_LIBS(gethostbyname_r  \"nsl_r;nsl\" LIBNSL)\n  MY_SEARCH_LIBS(bind \"bind;socket\" LIBBIND)\n  MY_SEARCH_LIBS(crypt crypt LIBCRYPT)\n  MY_SEARCH_LIBS(setsockopt socket LIBSOCKET)\n  MY_SEARCH_LIBS(dlopen dl LIBDL)\n  MY_SEARCH_LIBS(sched_yield rt LIBRT)\n  IF(NOT LIBRT)\n    MY_SEARCH_LIBS(clock_gettime rt LIBRT)\n  ENDIF()\n  MY_SEARCH_LIBS(timer_create rt LIBRT)\n  MY_SEARCH_LIBS(atomic_thread_fence atomic LIBATOMIC)\n  MY_SEARCH_LIBS(backtrace execinfo LIBEXECINFO)\n\n  SET(CMAKE_REQUIRED_LIBRARIES \n    ${LIBM} ${LIBNSL} ${LIBBIND} ${LIBCRYPT} ${LIBSOCKET} ${LIBDL}\n    ${CMAKE_THREAD_LIBS_INIT} ${LIBRT} ${LIBATOMIC} ${LIBEXECINFO}\n  )\n  # Need explicit pthread for gcc -fsanitize=address\n  IF(CMAKE_C_FLAGS MATCHES \"-fsanitize=\")\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} pthread)\n  ENDIF()\n\n  LIST(LENGTH CMAKE_REQUIRED_LIBRARIES required_libs_length)\n  IF(${required_libs_length} GREATER 0)\n    LIST(REMOVE_DUPLICATES CMAKE_REQUIRED_LIBRARIES)\n  ENDIF()  \n  LINK_LIBRARIES(${CMAKE_THREAD_LIBS_INIT})\n  \n  OPTION(WITH_LIBWRAP \"Compile with tcp wrappers support\" OFF)\n  IF(WITH_LIBWRAP)\n    SET(SAVE_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} wrap)\n    CHECK_C_SOURCE_COMPILES(\n    \"\n    #include <tcpd.h>\n    int allow_severity = 0;\n    int deny_severity  = 0;\n    int main()\n    {\n      hosts_access(0);\n    }\"\n    HAVE_LIBWRAP)\n\n    IF(HAVE_LIBWRAP)\n      CHECK_CXX_SOURCE_COMPILES(\n      \"\n      #include <tcpd.h>\n      int main()\n      {\n        struct request_info req;\n        if (req.sink)\n          (req.sink)(req.fd);\n      }\"\n      HAVE_LIBWRAP_PROTOTYPES)\n    ENDIF()\n\n    SET(CMAKE_REQUIRED_LIBRARIES ${SAVE_CMAKE_REQUIRED_LIBRARIES})\n    IF(HAVE_LIBWRAP)\n      SET(LIBWRAP \"wrap\")\n    ELSE()\n      MESSAGE(FATAL_ERROR \n      \"WITH_LIBWRAP is defined, but can not find a working libwrap. \"\n      \"Make sure both the header files (tcpd.h) \"\n      \"and the library (libwrap) are installed.\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n#\n# Tests for header files\n#\nINCLUDE (CheckIncludeFiles)\n\nCHECK_INCLUDE_FILES (alloca.h HAVE_ALLOCA_H)\nCHECK_INCLUDE_FILES (arpa/inet.h HAVE_ARPA_INET_H)\nCHECK_INCLUDE_FILES (dlfcn.h HAVE_DLFCN_H)\nCHECK_INCLUDE_FILES (execinfo.h HAVE_EXECINFO_H)\nCHECK_INCLUDE_FILES (fpu_control.h HAVE_FPU_CONTROL_H)\nCHECK_INCLUDE_FILES (grp.h HAVE_GRP_H)\nCHECK_INCLUDE_FILES (ieeefp.h HAVE_IEEEFP_H)\nCHECK_INCLUDE_FILES (langinfo.h HAVE_LANGINFO_H)\nCHECK_INCLUDE_FILES (malloc.h HAVE_MALLOC_H)\nCHECK_INCLUDE_FILES (netinet/in.h HAVE_NETINET_IN_H)\nCHECK_INCLUDE_FILES (poll.h HAVE_POLL_H)\nCHECK_INCLUDE_FILES (pwd.h HAVE_PWD_H)\nCHECK_INCLUDE_FILES (strings.h HAVE_STRINGS_H) # Used by NDB\nCHECK_INCLUDE_FILES (sys/cdefs.h HAVE_SYS_CDEFS_H) # Used by libedit\nCHECK_INCLUDE_FILES (sys/ioctl.h HAVE_SYS_IOCTL_H)\nCHECK_INCLUDE_FILES (sys/mman.h HAVE_SYS_MMAN_H)\nCHECK_INCLUDE_FILES (sys/resource.h HAVE_SYS_RESOURCE_H)\nCHECK_INCLUDE_FILES (sys/select.h HAVE_SYS_SELECT_H)\nCHECK_INCLUDE_FILES (sys/socket.h HAVE_SYS_SOCKET_H)\nCHECK_INCLUDE_FILES (\"curses.h;term.h\" HAVE_TERM_H)\nCHECK_INCLUDE_FILES (termios.h HAVE_TERMIOS_H)\nCHECK_INCLUDE_FILES (termio.h HAVE_TERMIO_H)\nCHECK_INCLUDE_FILES (unistd.h HAVE_UNISTD_H)\nCHECK_INCLUDE_FILES (sys/wait.h HAVE_SYS_WAIT_H)\nCHECK_INCLUDE_FILES (sys/param.h HAVE_SYS_PARAM_H) # Used by NDB/libevent\nCHECK_INCLUDE_FILES (fnmatch.h HAVE_FNMATCH_H)\nCHECK_INCLUDE_FILES (sys/un.h HAVE_SYS_UN_H)\nCHECK_INCLUDE_FILES (vis.h HAVE_VIS_H) # Used by libedit\nCHECK_INCLUDE_FILES (sasl/sasl.h HAVE_SASL_SASL_H) # Used by memcached\n\n# For libevent\nCHECK_INCLUDE_FILES(sys/devpoll.h HAVE_DEVPOLL)\nIF(HAVE_DEVPOLL)\n  # Duplicate symbols, but keep it to avoid changing libevent code.\n  SET(HAVE_SYS_DEVPOLL_H 1)\nENDIF()\nCHECK_INCLUDE_FILES(sys/epoll.h HAVE_SYS_EPOLL_H)\nCHECK_SYMBOL_EXISTS (TAILQ_FOREACH \"sys/queue.h\" HAVE_TAILQFOREACH)\n\n#\n# Tests for functions\n#\nCHECK_FUNCTION_EXISTS (_aligned_malloc HAVE_ALIGNED_MALLOC)\nCHECK_FUNCTION_EXISTS (backtrace HAVE_BACKTRACE)\nCHECK_FUNCTION_EXISTS (printstack HAVE_PRINTSTACK)\nCHECK_FUNCTION_EXISTS (index HAVE_INDEX)\nCHECK_FUNCTION_EXISTS (clock_gettime HAVE_CLOCK_GETTIME)\nCHECK_FUNCTION_EXISTS (cuserid HAVE_CUSERID)\nCHECK_FUNCTION_EXISTS (directio HAVE_DIRECTIO)\nCHECK_FUNCTION_EXISTS (ftruncate HAVE_FTRUNCATE)\nCHECK_FUNCTION_EXISTS (compress HAVE_COMPRESS)\nCHECK_FUNCTION_EXISTS (crypt HAVE_CRYPT)\nCHECK_FUNCTION_EXISTS (dlopen HAVE_DLOPEN)\nCHECK_FUNCTION_EXISTS (fchmod HAVE_FCHMOD)\nCHECK_FUNCTION_EXISTS (fcntl HAVE_FCNTL)\nCHECK_FUNCTION_EXISTS (fdatasync HAVE_FDATASYNC)\nCHECK_SYMBOL_EXISTS(fdatasync \"unistd.h\" HAVE_DECL_FDATASYNC)\nCHECK_FUNCTION_EXISTS (fedisableexcept HAVE_FEDISABLEEXCEPT)\nCHECK_FUNCTION_EXISTS (fseeko HAVE_FSEEKO)\nCHECK_FUNCTION_EXISTS (fsync HAVE_FSYNC)\nCHECK_FUNCTION_EXISTS (gethostbyaddr_r HAVE_GETHOSTBYADDR_R)\nCHECK_FUNCTION_EXISTS (gethrtime HAVE_GETHRTIME)\nCHECK_FUNCTION_EXISTS (getnameinfo HAVE_GETNAMEINFO)\nCHECK_FUNCTION_EXISTS (getpass HAVE_GETPASS)\nCHECK_FUNCTION_EXISTS (getpassphrase HAVE_GETPASSPHRASE)\nCHECK_FUNCTION_EXISTS (getpwnam HAVE_GETPWNAM)\nCHECK_FUNCTION_EXISTS (getpwuid HAVE_GETPWUID)\nCHECK_FUNCTION_EXISTS (getrlimit HAVE_GETRLIMIT)\nCHECK_FUNCTION_EXISTS (getrusage HAVE_GETRUSAGE)\nCHECK_FUNCTION_EXISTS (initgroups HAVE_INITGROUPS)\nCHECK_FUNCTION_EXISTS (issetugid HAVE_ISSETUGID)\nCHECK_FUNCTION_EXISTS (getuid HAVE_GETUID)\nCHECK_FUNCTION_EXISTS (geteuid HAVE_GETEUID)\nCHECK_FUNCTION_EXISTS (getgid HAVE_GETGID)\nCHECK_FUNCTION_EXISTS (getegid HAVE_GETEGID)\nCHECK_FUNCTION_EXISTS (lstat HAVE_LSTAT)\nCHECK_FUNCTION_EXISTS (madvise HAVE_MADVISE)\nCHECK_FUNCTION_EXISTS (malloc_info HAVE_MALLOC_INFO)\nCHECK_FUNCTION_EXISTS (memrchr HAVE_MEMRCHR)\nCHECK_FUNCTION_EXISTS (mlock HAVE_MLOCK)\nCHECK_FUNCTION_EXISTS (mlockall HAVE_MLOCKALL)\nCHECK_FUNCTION_EXISTS (mmap64 HAVE_MMAP64)\nCHECK_FUNCTION_EXISTS (poll HAVE_POLL)\nCHECK_FUNCTION_EXISTS (posix_fallocate HAVE_POSIX_FALLOCATE)\nCHECK_FUNCTION_EXISTS (posix_memalign HAVE_POSIX_MEMALIGN)\nCHECK_FUNCTION_EXISTS (pread HAVE_PREAD) # Used by NDB\nCHECK_FUNCTION_EXISTS (pthread_condattr_setclock HAVE_PTHREAD_CONDATTR_SETCLOCK)\nCHECK_FUNCTION_EXISTS (pthread_sigmask HAVE_PTHREAD_SIGMASK)\nCHECK_FUNCTION_EXISTS (readlink HAVE_READLINK)\nCHECK_FUNCTION_EXISTS (realpath HAVE_REALPATH)\nCHECK_FUNCTION_EXISTS (setfd HAVE_SETFD)\nCHECK_FUNCTION_EXISTS (sigaction HAVE_SIGACTION)\nCHECK_FUNCTION_EXISTS (sleep HAVE_SLEEP)\nCHECK_FUNCTION_EXISTS (stpcpy HAVE_STPCPY)\nCHECK_FUNCTION_EXISTS (stpncpy HAVE_STPNCPY)\nCHECK_FUNCTION_EXISTS (strlcpy HAVE_STRLCPY)\nCHECK_FUNCTION_EXISTS (strndup HAVE_STRNDUP) # Used by libbinlogevents\nCHECK_FUNCTION_EXISTS (strnlen HAVE_STRNLEN)\nCHECK_FUNCTION_EXISTS (strlcat HAVE_STRLCAT)\nCHECK_FUNCTION_EXISTS (strsignal HAVE_STRSIGNAL)\nCHECK_FUNCTION_EXISTS (fgetln HAVE_FGETLN)\nCHECK_FUNCTION_EXISTS (strsep HAVE_STRSEP)\nCHECK_FUNCTION_EXISTS (tell HAVE_TELL)\nCHECK_FUNCTION_EXISTS (vasprintf HAVE_VASPRINTF)\nCHECK_FUNCTION_EXISTS (memalign HAVE_MEMALIGN)\nCHECK_FUNCTION_EXISTS (nl_langinfo HAVE_NL_LANGINFO)\nCHECK_FUNCTION_EXISTS (ntohll HAVE_HTONLL)\n\nCHECK_FUNCTION_EXISTS (clock_gettime DNS_USE_CPU_CLOCK_FOR_ID)\nCHECK_FUNCTION_EXISTS (epoll_create HAVE_EPOLL)\n# Temperarily  Quote event port out as we encounter error in port_getn\n# on solaris x86\n# CHECK_FUNCTION_EXISTS (port_create HAVE_EVENT_PORTS)\nCHECK_FUNCTION_EXISTS (inet_ntop HAVE_INET_NTOP)\nCHECK_FUNCTION_EXISTS (kqueue HAVE_WORKING_KQUEUE)\nCHECK_SYMBOL_EXISTS (timeradd \"sys/time.h\" HAVE_TIMERADD)\nCHECK_SYMBOL_EXISTS (timerclear \"sys/time.h\" HAVE_TIMERCLEAR)\nCHECK_SYMBOL_EXISTS (timercmp \"sys/time.h\" HAVE_TIMERCMP)\nCHECK_SYMBOL_EXISTS (timerisset \"sys/time.h\" HAVE_TIMERISSET)\n\n#--------------------------------------------------------------------\n# Support for WL#2373 (Use cycle counter for timing)\n#--------------------------------------------------------------------\n\nCHECK_INCLUDE_FILES(sys/time.h HAVE_SYS_TIME_H)\nCHECK_INCLUDE_FILES(sys/times.h HAVE_SYS_TIMES_H)\n\nCHECK_FUNCTION_EXISTS(times HAVE_TIMES)\nCHECK_FUNCTION_EXISTS(gettimeofday HAVE_GETTIMEOFDAY)\n\n\n#\n# Tests for symbols\n#\n\nCHECK_SYMBOL_EXISTS(lrand48 \"stdlib.h\" HAVE_LRAND48)\nCHECK_SYMBOL_EXISTS(TIOCGWINSZ \"sys/ioctl.h\" GWINSZ_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/ioctl.h\" FIONREAD_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/filio.h\" FIONREAD_IN_SYS_FILIO)\nCHECK_SYMBOL_EXISTS(SIGEV_THREAD_ID \"signal.h;time.h\" HAVE_SIGEV_THREAD_ID)\nCHECK_SYMBOL_EXISTS(SIGEV_PORT \"signal.h;time.h;sys/siginfo.h\" HAVE_SIGEV_PORT)\n\nCHECK_SYMBOL_EXISTS(log2  math.h HAVE_LOG2)\n\n# On Solaris, it is only visible in C99 mode\nCHECK_SYMBOL_EXISTS(isinf \"math.h\" HAVE_C_ISINF)\n\n# isinf() prototype not found on Solaris\nCHECK_CXX_SOURCE_COMPILES(\n\"#include  <math.h>\nint main() { \n  isinf(0.0); \n  return 0;\n}\" HAVE_CXX_ISINF)\n\nIF (HAVE_C_ISINF AND HAVE_CXX_ISINF)\n  SET(HAVE_ISINF 1 CACHE INTERNAL \"isinf visible in C and C++\" FORCE)\nELSE()\n  SET(HAVE_ISINF 0 CACHE INTERNAL \"isinf visible in C and C++\" FORCE)\nENDIF()\n\n\n# The results of these four checks are only needed here, not in code.\nCHECK_FUNCTION_EXISTS (timer_create HAVE_TIMER_CREATE)\nCHECK_FUNCTION_EXISTS (timer_settime HAVE_TIMER_SETTIME)\nCHECK_FUNCTION_EXISTS (kqueue HAVE_KQUEUE)\nCHECK_SYMBOL_EXISTS(EVFILT_TIMER \"sys/types.h;sys/event.h;sys/time.h\" HAVE_EVFILT_TIMER)\nIF(HAVE_KQUEUE AND HAVE_EVFILT_TIMER)\n  SET(HAVE_KQUEUE_TIMERS 1 CACHE INTERNAL \"Have kqueue timer-related filter\")\nELSEIF(HAVE_TIMER_CREATE AND HAVE_TIMER_SETTIME)\n  IF(HAVE_SIGEV_THREAD_ID OR HAVE_SIGEV_PORT)\n    SET(HAVE_POSIX_TIMERS 1 CACHE INTERNAL \"Have POSIX timer-related functions\")\n  ENDIF()\nENDIF()\n\nIF(NOT HAVE_POSIX_TIMERS AND NOT HAVE_KQUEUE_TIMERS AND NOT WIN32)\n  MESSAGE(FATAL_ERROR \"No mysys timer support detected!\")\nENDIF()\n\n#\n# Test for endianess\n#\nINCLUDE(TestBigEndian)\nTEST_BIG_ENDIAN(WORDS_BIGENDIAN)\n\n#\n# Tests for type sizes (and presence)\n#\nINCLUDE (CheckTypeSize)\n\nset(CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS}\n        -D_LARGEFILE_SOURCE -D_LARGE_FILES -D_FILE_OFFSET_BITS=64\n        -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS)\n\nSET(CMAKE_EXTRA_INCLUDE_FILES stdint.h stdio.h sys/types.h time.h)\n\nCHECK_TYPE_SIZE(\"void *\"    SIZEOF_VOIDP)\nCHECK_TYPE_SIZE(\"char *\"    SIZEOF_CHARP)\nCHECK_TYPE_SIZE(\"long\"      SIZEOF_LONG)\nCHECK_TYPE_SIZE(\"short\"     SIZEOF_SHORT)\nCHECK_TYPE_SIZE(\"int\"       SIZEOF_INT)\nCHECK_TYPE_SIZE(\"long long\" SIZEOF_LONG_LONG)\nCHECK_TYPE_SIZE(\"off_t\"     SIZEOF_OFF_T)\nCHECK_TYPE_SIZE(\"time_t\"    SIZEOF_TIME_T)\nCHECK_TYPE_SIZE(\"struct timespec\" STRUCT_TIMESPEC)\n\n# If finds the size of a type, set SIZEOF_<type> and HAVE_<type>\nFUNCTION(MY_CHECK_TYPE_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# We are only interested in presence for these\nMY_CHECK_TYPE_SIZE(uint UINT)\nMY_CHECK_TYPE_SIZE(ulong ULONG)\nMY_CHECK_TYPE_SIZE(u_int32_t U_INT32_T)\n\nIF(HAVE_IEEEFP_H)\n  SET(CMAKE_EXTRA_INCLUDE_FILES ieeefp.h)\n  MY_CHECK_TYPE_SIZE(fp_except FP_EXCEPT)\nENDIF()\n\nSET(CMAKE_EXTRA_INCLUDE_FILES)\n\n# Support for tagging symbols with __attribute__((visibility(\"hidden\")))\nMY_CHECK_CXX_COMPILER_FLAG(\"-fvisibility=hidden\" HAVE_VISIBILITY_HIDDEN)\n\n#\n# Code tests\n#\n\nIF(NOT STACK_DIRECTION)\n  IF(CMAKE_CROSSCOMPILING)\n   MESSAGE(FATAL_ERROR \n   \"STACK_DIRECTION is not defined.  Please specify -DSTACK_DIRECTION=1 \"\n   \"or -DSTACK_DIRECTION=-1 when calling cmake.\")\n  ELSE()\n    TRY_RUN(STACKDIR_RUN_RESULT STACKDIR_COMPILE_RESULT    \n     ${CMAKE_BINARY_DIR} \n     ${CMAKE_SOURCE_DIR}/cmake/stack_direction.c\n     )\n     # Test program returns 0 (down) or 1 (up).\n     # Convert to -1 or 1\n     IF(STACKDIR_RUN_RESULT EQUAL 0)\n       SET(STACK_DIRECTION -1 CACHE INTERNAL \"Stack grows direction\")\n     ELSE()\n       SET(STACK_DIRECTION 1 CACHE INTERNAL \"Stack grows direction\")\n     ENDIF()\n     MESSAGE(STATUS \"Checking stack direction : ${STACK_DIRECTION}\")\n   ENDIF()\nENDIF()\n\nCHECK_INCLUDE_FILES(\"time.h;sys/time.h\" TIME_WITH_SYS_TIME)\nCHECK_SYMBOL_EXISTS(O_NONBLOCK \"unistd.h;fcntl.h\" HAVE_FCNTL_NONBLOCK)\nIF(NOT HAVE_FCNTL_NONBLOCK)\n SET(NO_FCNTL_NONBLOCK 1)\nENDIF()\n\nIF(NOT CMAKE_CROSSCOMPILING AND NOT MSVC)\n  STRING(TOLOWER ${CMAKE_SYSTEM_PROCESSOR}  processor)\n  IF(processor MATCHES \"86\" OR processor MATCHES \"amd64\" OR processor MATCHES \"x64\")\n    IF(NOT CMAKE_SYSTEM_NAME MATCHES \"SunOS\")\n      # The loader in some Solaris versions has a bug due to which it refuses to\n      # start a binary that has been compiled by GCC and uses __asm__(\"pause\")\n      # with the error:\n      # $ ./mysqld\n      # ld.so.1: mysqld: fatal: hardware capability unsupported: 0x2000 [ PAUSE ]\n      # Killed\n      # $\n      # Even though the CPU does have support for the instruction.\n      # Binaries that have been compiled by GCC and use __asm__(\"pause\")\n      # on a non-buggy Solaris get flagged with a \"uses pause\" flag and\n      # thus they are unusable if copied on buggy Solaris version. To\n      # circumvent this we explicitly disable __asm__(\"pause\") when\n      # compiling on Solaris. Subsequently the tests here will enable\n      # HAVE_FAKE_PAUSE_INSTRUCTION which will use __asm__(\"rep; nop\")\n      # which currently generates the same code as __asm__(\"pause\") - 0xf3 0x90\n      # but without flagging the binary as \"uses pause\".\n      CHECK_C_SOURCE_RUNS(\"\n      int main()\n      {\n        __asm__ __volatile__ (\\\"pause\\\");\n        return 0;\n      }\"  HAVE_PAUSE_INSTRUCTION)\n    ENDIF()\n  ENDIF()\n  IF (NOT HAVE_PAUSE_INSTRUCTION)\n    CHECK_C_SOURCE_COMPILES(\"\n    int main()\n    {\n     __asm__ __volatile__ (\\\"rep; nop\\\");\n     return 0;\n    }\n   \" HAVE_FAKE_PAUSE_INSTRUCTION)\n  ENDIF()\n  IF (NOT HAVE_PAUSE_INSTRUCTION)\n    CHECK_C_SOURCE_COMPILES(\"\n    int main()\n    {\n     __asm__ __volatile__ (\\\"or 1,1,1\\\");\n     __asm__ __volatile__ (\\\"or 2,2,2\\\");\n     return 0;\n    }\n    \" HAVE_HMT_PRIORITY_INSTRUCTION)\n  ENDIF()\nENDIF()\n  \nIF(CMAKE_COMPILER_IS_GNUCXX AND HAVE_CXXABI_H)\nCHECK_CXX_SOURCE_COMPILES(\"\n #include <cxxabi.h>\n int main(int argc, char **argv) \n  {\n    char *foo= 0; int bar= 0;\n    foo= abi::__cxa_demangle(foo, foo, 0, &bar);\n    return 0;\n  }\"\n  HAVE_ABI_CXA_DEMANGLE)\nENDIF()\n\nCHECK_C_SOURCE_COMPILES(\"\nint main()\n{\n  __builtin_unreachable();\n  return 0;\n}\" HAVE_BUILTIN_UNREACHABLE)\n\nCHECK_C_SOURCE_COMPILES(\"\nint main()\n{\n  long l= 0;\n  __builtin_expect(l, 0);\n  return 0;\n}\" HAVE_BUILTIN_EXPECT)\n\n# GCC has __builtin_stpcpy but still calls stpcpy\nIF(NOT CMAKE_SYSTEM_NAME MATCHES \"SunOS\" OR NOT CMAKE_COMPILER_IS_GNUCC)\nCHECK_C_SOURCE_COMPILES(\"\nint main()\n{\n  char foo1[1];\n  char foo2[1];\n  __builtin_stpcpy(foo1, foo2);\n  return 0;\n}\" HAVE_BUILTIN_STPCPY)\nENDIF()\n\nCHECK_CXX_SOURCE_COMPILES(\"\n  int main()\n  {\n    int foo= -10; int bar= 10;\n    long long int foo64= -10; long long int bar64= 10;\n    if (!__atomic_fetch_add(&foo, bar, __ATOMIC_SEQ_CST) || foo)\n      return -1;\n    bar= __atomic_exchange_n(&foo, bar, __ATOMIC_SEQ_CST);\n    if (bar || foo != 10)\n      return -1;\n    bar= __atomic_compare_exchange_n(&bar, &foo, 15, 0,\n                                     __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n    if (bar)\n      return -1;\n    if (!__atomic_fetch_add(&foo64, bar64, __ATOMIC_SEQ_CST) || foo64)\n      return -1;\n    bar64= __atomic_exchange_n(&foo64, bar64, __ATOMIC_SEQ_CST);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64= __atomic_compare_exchange_n(&bar64, &foo64, 15, 0,\n                                       __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n    if (bar64)\n      return -1;\n    return 0;\n  }\"\n  HAVE_GCC_ATOMIC_BUILTINS)\n\nCHECK_CXX_SOURCE_COMPILES(\"\n  int main()\n  {\n    int foo= -10; int bar= 10;\n    long long int foo64= -10; long long int bar64= 10;\n    if (!__sync_fetch_and_add(&foo, bar) || foo)\n      return -1;\n    bar= __sync_lock_test_and_set(&foo, bar);\n    if (bar || foo != 10)\n      return -1;\n    bar= __sync_val_compare_and_swap(&bar, foo, 15);\n    if (bar)\n      return -1;\n    if (!__sync_fetch_and_add(&foo64, bar64) || foo64)\n      return -1;\n    bar64= __sync_lock_test_and_set(&foo64, bar64);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64= __sync_val_compare_and_swap(&bar64, foo, 15);\n    if (bar64)\n      return -1;\n    return 0;\n  }\"\n  HAVE_GCC_SYNC_BUILTINS)\n\nIF(WITH_VALGRIND)\n  SET(VALGRIND_HEADERS \"valgrind/memcheck.h;valgrind/valgrind.h\")\n  CHECK_INCLUDE_FILES(\"${VALGRIND_HEADERS}\" HAVE_VALGRIND_HEADERS)\n  IF(HAVE_VALGRIND_HEADERS)\n    SET(HAVE_VALGRIND 1)\n  ELSE()\n    MESSAGE(FATAL_ERROR \"Unable to find Valgrind header files ${VALGRIND_HEADERS}. Make sure you have them in your include path.\")\n  ENDIF()\nENDIF()\n\n#--------------------------------------------------------------------\n# Check for IPv6 support\n#--------------------------------------------------------------------\nCHECK_INCLUDE_FILE(netinet/in6.h HAVE_NETINET_IN6_H) # Used by libevent\n\nIF(UNIX)\n  SET(CMAKE_EXTRA_INCLUDE_FILES sys/types.h netinet/in.h sys/socket.h)\n  IF(HAVE_NETINET_IN6_H)\n    SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} netinet/in6.h)\n  ENDIF()\nELSEIF(WIN32)\n  SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} winsock2.h ws2ipdef.h)\nENDIF()\n\nMY_CHECK_STRUCT_SIZE(\"sockaddr_in6\" SOCKADDR_IN6)\nMY_CHECK_STRUCT_SIZE(\"in6_addr\" IN6_ADDR)\n\nIF(HAVE_STRUCT_SOCKADDR_IN6 OR HAVE_STRUCT_IN6_ADDR)\n  SET(HAVE_IPV6 TRUE CACHE INTERNAL \"\")\nENDIF()\n\n\n# Check for sockaddr_storage.ss_family\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_storage\"\n ss_family \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_STORAGE_SS_FAMILY)\nIF(NOT HAVE_SOCKADDR_STORAGE_SS_FAMILY)\n  CHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_storage\"\n  __ss_family \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_STORAGE___SS_FAMILY)\n  IF(HAVE_SOCKADDR_STORAGE___SS_FAMILY)\n    SET(ss_family __ss_family)\n  ENDIF()\nENDIF()\n\n#\n# Check if struct sockaddr_in::sin_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in\" sin_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN_SIN_LEN)\n\n#\n# Check if struct sockaddr_in6::sin6_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in6\" sin6_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN6_SIN6_LEN)\n\nCHECK_CXX_SOURCE_COMPILES(\n  \"\n  #include <vector>\n  template<typename T>\n  class ct2\n  {\n  public:\n    typedef T type;\n    void func();\n  };\n\n  template<typename T>\n  void ct2<T>::func()\n  {\n    std::vector<T> vec;\n    std::vector<T>::iterator itr = vec.begin();\n  }\n\n  int main(int argc, char **argv)\n  {\n    ct2<double> o2;\n    o2.func();\n    return 0;\n  }\n  \" HAVE_IMPLICIT_DEPENDENT_NAME_TYPING)\n\nSET(CMAKE_EXTRA_INCLUDE_FILES)\n\nCHECK_FUNCTION_EXISTS(chown HAVE_CHOWN)\n\nCHECK_INCLUDE_FILES(numa.h HAVE_NUMA_H)\nCHECK_INCLUDE_FILES(numaif.h HAVE_NUMAIF_H)\n\nIF(HAVE_NUMA_H AND HAVE_NUMAIF_H)\n    SET(SAVE_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} numa)\n    CHECK_C_SOURCE_COMPILES(\n    \"\n    #include <numa.h>\n    #include <numaif.h>\n    int main()\n    {\n       struct bitmask *all_nodes= numa_all_nodes_ptr;\n       set_mempolicy(MPOL_DEFAULT, 0, 0);\n       return all_nodes != NULL;\n    }\"\n    HAVE_LIBNUMA)\n    SET(CMAKE_REQUIRED_LIBRARIES ${SAVE_CMAKE_REQUIRED_LIBRARIES})\nELSE()\n    SET(HAVE_LIBNUMA 0)\nENDIF()\n\nIF(NOT HAVE_LIBNUMA)\n   MESSAGE(STATUS \"NUMA library missing or required version not available\")\nENDIF()\n\nIF(HAVE_LIBNUMA AND HAVE_NUMA_H AND HAVE_NUMAIF_H)\n  OPTION(WITH_NUMA \"Explicitly set NUMA memory allocation policy\" ON)\nELSE()\n  OPTION(WITH_NUMA \"Explicitly set NUMA memory allocation policy\" OFF)\nENDIF()\n\nIF(WITH_NUMA AND NOT HAVE_LIBNUMA)\n  # Forget it in cache, abort the build.\n  UNSET(WITH_NUMA CACHE)\n  MESSAGE(FATAL_ERROR \"NUMA library missing or required version not available\")\nENDIF()\n\nIF(HAVE_LIBNUMA AND NOT WITH_NUMA)\n   SET(HAVE_LIBNUMA 0)\n   MESSAGE(STATUS \"Disabling NUMA on user's request\")\nENDIF()\n\n# needed for libevent\nCHECK_TYPE_SIZE(\"socklen_t\" SIZEOF_SOCKLEN_T)\nIF(SIZEOF_SOCKLEN_T)\n  SET(HAVE_SOCKLEN_T 1)\nENDIF()\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/src/common/portlib/NdbNuma.cpp": "/*\n   Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n*/\n\n#include <NdbNuma.h>\n#include <ndb_global.h>\n\nstatic int NDB_TRACE_NUMA = 0;\n\n#if defined HAVE_DLFCN_H && defined HAVE_DLOPEN\n#include <dlfcn.h>\n\n/**\n * Load libnuma using dlopen, not have to put link dependency on it...\n * - handle fact that there are 2 versions of libnuma...\n *   use existance of symbol \"numa_all_nodes_ptr\" to use v2 abi\n */\nstruct bitmask;\nextern \"C\"\n{\n  typedef int (* fun0)(void);\n  typedef void (* fun1)(struct bitmask*);\n  typedef void (* fun2)(int);\n  typedef int (* fun3)(int node, unsigned long * bug, int buflen);\n  typedef bitmask * (* fun4)();\n  typedef void (* fun5)(struct bitmask*);\n  typedef bitmask * (* fun6)(struct bitmask*);\n};\n\nclass NdbNuma\n{\npublic:\n  NdbNuma() { handle = 0;}\n  ~NdbNuma() { if (handle) dlclose(handle); }\n\n  int open();\n  int build_cputonodemap();\n\n  void * handle;\n  fun0 numa_available;\n\n  fun0 numa_max_node;\n  fun0 numa_max_possible_node;\n  fun1 numa_set_interleave_mask;\n  fun2 numa_set_strict;\n  fun3 numa_node_to_cpus;\n  fun4 numa_allocate_nodemask;\n  fun5 numa_bitmask_free;\n  fun6 numa_bitmask_setall;\n\n  struct bitmask * numa_all_nodes;\n  struct bitmask * numa_all_nodes_ptr;\n};\n\nstatic\nvoid*\nmy_dlopen(const char * name)\n{\n  void * p = dlopen(name, RTLD_LAZY);\n  if (NDB_TRACE_NUMA)\n  {\n    if (p == 0)\n      printf(\"info: failed to load %s\\n\", name);\n    else\n      printf(\"info: loaded %s\\n\", name);\n  }\n  return p;\n}\n\nstatic\nvoid*\nmy_dlsym(void * handle, const char * name)\n{\n  void * p = dlsym(handle, name);\n  if (NDB_TRACE_NUMA)\n  {\n    if (p != 0)\n    {\n      printf(\"info: %s OK\\n\", name);\n    }\n    else\n    {\n      printf(\"info: %s NOT FOUND\\n\", name);\n    }\n  }\n  return p;\n}\n\nint\nNdbNuma::open()\n{\n  handle = my_dlopen(\"libnuma.so\");\n  if (handle == 0)\n  {\n    handle = my_dlopen(\"libnuma.so.1\");\n  }\n  if (handle == 0)\n  {\n    return -1;\n  }\n\n  numa_available = (fun0)my_dlsym(handle, \"numa_available\");\n  if (numa_available == 0)\n  {\n    goto fail;\n  }\n\n  if ((* numa_available)() == -1)\n  {\n    if (NDB_TRACE_NUMA)\n    {\n      printf(\"info: numa_available() returns -1 => no numa support\\n\");\n    }\n    goto fail;\n  }\n\n  numa_max_node = (fun0)my_dlsym(handle, \"numa_max_node\");\n  numa_set_interleave_mask = (fun1)my_dlsym(handle, \"numa_set_interleave_mask\");\n  numa_set_strict = (fun2)my_dlsym(handle, \"numa_set_strict\");\n  numa_node_to_cpus = (fun3)my_dlsym(handle, \"numa_node_to_cpus\");\n  numa_all_nodes = (struct bitmask*)my_dlsym(handle, \"numa_all_nodes\");\n  numa_all_nodes_ptr = (struct bitmask*)my_dlsym(handle, \"numa_all_nodes_ptr\");\n  numa_allocate_nodemask = (fun4)my_dlsym(handle, \"numa_allocate_nodemask\");\n  numa_bitmask_free = (fun5)my_dlsym(handle, \"numa_bitmask_free\");\n  numa_bitmask_setall = (fun6)my_dlsym(handle, \"numa_bitmask_setall\");\n\n\n  return 0;\nfail:\n  dlclose(handle);\n  handle = 0;\n  return -1;\n}\n\nstatic\nbool\nbit_is_set(unsigned long * mask, int bit)\n{\n  int n = bit / (8 * sizeof(unsigned long));\n  int b = bit % (8 * sizeof(unsigned long));\n  return (mask[n] & (1UL << b)) != 0;\n}\n\nint\nNdbNuma::build_cputonodemap()\n{\n  int len = 512;\n  unsigned long * buf = (unsigned long*)malloc(len);\n  if (buf == 0)\n    return -1;\n\n  int m = (* numa_max_node)();\n  for (int i = 0; i <= m; i++)\n  {\nretry:\n    int r = (* numa_node_to_cpus)(i, buf, len);\n    if (r == -1)\n    {\n      if (errno != ERANGE)\n        goto fail;\n\n      len = len + 512;\n      if (len > 4096)\n        goto fail;\n\n      void * p = realloc(buf, len);\n      if (p == 0)\n        goto fail;\n\n      buf = (unsigned long*)p;\n      goto retry;\n    }\n    printf(\"node %d cpu(s): \", i);\n    for (int j = 0; j<8*len;j++)\n      if (bit_is_set(buf, j))\n        printf(\"%d \", j);\n    printf(\"\\n\");\n  }\n  free(buf);\n  return 0;\nfail:\n  free(buf);\n  return -1;\n}\n\nextern \"C\"\nint\nNdbNuma_setInterleaved()\n{\n  NdbNuma numa;\n  if (numa.open() == -1)\n    return -1;\n\n  if (numa.numa_set_interleave_mask == 0)\n    return -1;\n\n  if (numa.numa_all_nodes_ptr != 0)\n  {\n    /**\n     * libnuma v2\n     */\n    if (numa.numa_allocate_nodemask != 0 &&\n        numa.numa_bitmask_setall != 0 &&\n        numa.numa_bitmask_free != 0)\n    {\n      struct bitmask * bm = (* numa.numa_allocate_nodemask)();\n      if (bm != 0)\n      {\n        (* numa.numa_bitmask_setall)(bm);\n        (* numa.numa_set_interleave_mask)(bm);\n        (* numa.numa_bitmask_free)(bm);\n      }\n      else\n      {\n        return -1;\n      }\n    }\n    else\n    {\n      return -1;\n    }\n  }\n  else if (numa.numa_all_nodes != 0)\n  {\n    /**\n     * libnuma v1\n     */\n    (* numa.numa_set_interleave_mask)(numa.numa_all_nodes);\n  }\n  else\n  {\n    return -1;\n  }\n\n  return 0;\n}\n\n#else\nextern \"C\"\nint\nNdbNuma_setInterleaved()\n{\n  return -1;\n}\n\nextern \"C\"\nint\nNdbNuma_setInterleavedOnCpus(unsigned cpu[], unsigned len)\n{\n  return -1;\n}\n#endif\n\n#ifdef TEST_NDBNUMA\n#include <NdbTap.hpp>\n\nTAPTEST(SetInterleaved)\n{\n  NDB_TRACE_NUMA = 1;\n  NdbNuma_setInterleaved();\n  return 1; // OK\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/memcache/extra/memcached/daemon/memcached.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       http://www.danga.com/memcached/\n *\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n */\n#include \"config.h\"\n#include \"memcached.h\"\n#include \"memcached/extension_loggers.h\"\n#include \"utilities/engine_loader.h\"\n\n#include <signal.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stddef.h>\n\nstatic inline void item_set_cas(const void *cookie, item *it, uint64_t cas) {\n    settings.engine.v1->item_set_cas(settings.engine.v0, cookie, it, cas);\n}\n\n/* The item must always be called \"it\" */\n#define SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_stats[info.clsid].slab_op++;\n\n#define THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->thread_op++;\n\n#define THREAD_GUTS2(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_op++; \\\n    thread_stats->thread_op++;\n\n#define SLAB_THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    THREAD_GUTS(conn, thread_stats, slab_op, thread_op)\n\n#define STATS_INCR1(GUTS, conn, slab_op, thread_op, key, nkey) { \\\n    struct independent_stats *independent_stats = get_independent_stats(conn); \\\n    struct thread_stats *thread_stats = \\\n        &independent_stats->thread_stats[conn->thread->index]; \\\n    topkeys_t *topkeys = independent_stats->topkeys; \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    GUTS(conn, thread_stats, slab_op, thread_op); \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n    TK(topkeys, slab_op, key, nkey, current_time); \\\n}\n\n#define STATS_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS, conn, op, op, key, nkey)\n\n#define SLAB_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(SLAB_GUTS, conn, op, op, key, nkey)\n\n#define STATS_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS2, conn, slab_op, thread_op, key, nkey)\n\n#define SLAB_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(SLAB_THREAD_GUTS, conn, slab_op, thread_op, key, nkey)\n\n#define STATS_HIT(conn, op, key, nkey) \\\n    SLAB_TWO(conn, op##_hits, cmd_##op, key, nkey)\n\n#define STATS_MISS(conn, op, key, nkey) \\\n    STATS_TWO(conn, op##_misses, cmd_##op, key, nkey)\n\n#define STATS_NOKEY(conn, op) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_NOKEY2(conn, op1, op2) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op1++; \\\n    thread_stats->op2++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_ADD(conn, op, amt) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op += amt; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\nvolatile sig_atomic_t memcached_shutdown;\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\n\n/*\n * forward declarations\n */\nstatic SOCKET new_socket(struct addrinfo *ai);\nstatic int try_read_command(conn *c);\nstatic inline struct independent_stats *get_independent_stats(conn *c);\nstatic inline struct thread_stats *get_thread_stats(conn *c);\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data);\n\n\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occured (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\n\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void complete_nread(conn *c);\nstatic char *process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic int ensure_iov_space(conn *c);\nstatic int add_iov(conn *c, const void *buf, int len);\nstatic int add_msghdr(conn *c);\n\n\n/* time handling */\nstatic void set_current_time(void);  /* update the global variable holding\n                              global 32-bit seconds-since-start time\n                              (to avoid 64 bit time_t) */\n\n/** exported globals **/\nstruct stats stats;\nstruct settings settings;\nstatic time_t process_started;     /* when the process was started */\n\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic struct event_base *main_base;\nstatic struct independent_stats *default_independent_stats;\n\nstatic struct engine_event_handler *engine_event_handlers[MAX_ENGINE_EVENT_TYPE + 1];\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\nstatic enum transmit_result transmit(conn *c);\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n// Perform all callbacks of a given type for the given connection.\nstatic void perform_callbacks(ENGINE_EVENT_TYPE type,\n                              const void *data,\n                              const void *c) {\n    for (struct engine_event_handler *h = engine_event_handlers[type];\n         h; h = h->next) {\n        h->cb(c, type, data, h->cb_data);\n    }\n}\n\n/*\n * given time value that's either unix time or delta from current unix time,\n * return unix time. Use the fact that delta can't exceed one month\n * (and real time value can't be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\n/**\n * Convert the relative time to an absolute time (relative to EPOC ;) )\n */\nstatic time_t abstime(const rel_time_t exptime)\n{\n    return process_started + exptime;\n}\n\nstatic void stats_init(void) {\n    stats.daemon_conns = 0;\n    stats.rejected_conns = 0;\n    stats.curr_conns = stats.total_conns = stats.conn_structs = 0;\n\n    stats_prefix_init();\n}\n\nstatic void stats_reset(const void *cookie) {\n    struct conn *conn = (struct conn*)cookie;\n    STATS_LOCK();\n    stats.rejected_conns = 0;\n    stats.total_conns = 0;\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset(get_independent_stats(conn)->thread_stats);\n    settings.engine.v1->reset_stats(settings.engine.v0, cookie);\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1000;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.allow_detailed = true;\n    settings.reqs_per_event = DEFAULT_REQS_PER_EVENT;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n    settings.topkeys = 0;\n    settings.require_sasl = false;\n    settings.extensions.logger = get_stderr_logger();\n}\n\n/*\n * Adds a message header to a connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int add_msghdr(conn *c)\n{\n    struct msghdr *msg;\n\n    assert(c != NULL);\n\n    if (c->msgsize == c->msgused) {\n        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));\n        if (! msg)\n            return -1;\n        c->msglist = msg;\n        c->msgsize *= 2;\n    }\n\n    msg = c->msglist + c->msgused;\n\n    /* this wipes msg_iovlen, msg_control, msg_controllen, and\n       msg_flags, the last 3 of which aren't defined on solaris: */\n    memset(msg, 0, sizeof(struct msghdr));\n\n    msg->msg_iov = &c->iov[c->iovused];\n\n    if (c->request_addr_size > 0) {\n        msg->msg_name = &c->request_addr;\n        msg->msg_namelen = c->request_addr_size;\n    }\n\n    c->msgbytes = 0;\n    c->msgused++;\n\n    if (IS_UDP(c->transport)) {\n        /* Leave room for the UDP header, which we'll fill in later. */\n        return add_iov(c, NULL, UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    const char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nstruct {\n    pthread_mutex_t mutex;\n    bool disabled;\n    ssize_t count;\n    uint64_t num_disable;\n} listen_state = { .mutex = PTHREAD_MUTEX_INITIALIZER };\n\nstatic bool is_listen_disabled(void) {\n    bool ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.disabled;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic uint64_t get_listen_disabled_num(void) {\n    uint64_t ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic void disable_listen(void) {\n    conn *next;\n    pthread_mutex_lock(&listen_state.mutex);\n    listen_state.disabled = true;\n    listen_state.count = 10;\n    ++listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n\n    for (next = listen_conn; next; next = next->next) {\n        update_event(next, 0);\n        if (listen(next->sfd, 1) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"listen() failed\",\n                                            strerror(errno));\n        }\n    }\n}\n\nvoid safe_close(SOCKET sfd) {\n    if (sfd != INVALID_SOCKET) {\n        int rval;\n        while ((rval = closesocket(sfd)) == SOCKET_ERROR &&\n               (errno == EINTR || errno == EAGAIN)) {\n            /* go ahead and retry */\n        }\n\n        if (rval == SOCKET_ERROR) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to close socket %d (%s)!!\\n\", (int)sfd,\n                                            strerror(errno));\n        } else {\n            STATS_LOCK();\n            stats.curr_conns--;\n            STATS_UNLOCK();\n\n            if (is_listen_disabled()) {\n                notify_dispatcher();\n            }\n        }\n    }\n}\n\n/*\n * Free list management for connections.\n */\ncache_t *conn_cache;      /* suffix cache */\n\n/**\n * Reset all of the dynamic buffers used by a connection back to their\n * default sizes. The strategy for resizing the buffers is to allocate a\n * new one of the correct size and free the old one if the allocation succeeds\n * instead of using realloc to change the buffer size (because realloc may\n * not shrink the buffers, and will also copy the memory). If the allocation\n * fails the buffer will be unchanged.\n *\n * @param c the connection to resize the buffers for\n * @return true if all allocations succeeded, false if one or more of the\n *         allocations failed.\n */\nstatic bool conn_reset_buffersize(conn *c) {\n    bool ret = true;\n\n    if (c->rsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->rbuf);\n            c->rbuf = ptr;\n            c->rsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->wsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->wbuf);\n            c->wbuf = ptr;\n            c->wsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->isize != ITEM_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(item *) * ITEM_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->ilist);\n            c->ilist = ptr;\n            c->isize = ITEM_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->suffixsize != SUFFIX_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(char *) * SUFFIX_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->suffixlist);\n            c->suffixlist = ptr;\n            c->suffixsize = SUFFIX_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->iovsize != IOV_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct iovec) * IOV_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->iov);\n            c->iov = ptr;\n            c->iovsize = IOV_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->msgsize != MSG_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct msghdr) * MSG_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->msglist);\n            c->msglist = ptr;\n            c->msgsize = MSG_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    return ret;\n}\n\n/**\n * Constructor for all memory allocations of connection objects. Initialize\n * all members and allocate the transfer buffers.\n *\n * @param buffer The memory allocated by the object cache\n * @param unused1 not used\n * @param unused2 not used\n * @return 0 on success, 1 if we failed to allocate memory\n */\nstatic int conn_constructor(void *buffer, void *unused1, int unused2) {\n    conn *c = buffer;\n    memset(c, 0, sizeof(*c));\n    MEMCACHED_CONN_CREATE(c);\n    (void)unused1; (void)unused2;\n\n    if (!conn_reset_buffersize(c)) {\n        free(c->rbuf);\n        free(c->wbuf);\n        free(c->ilist);\n        free(c->suffixlist);\n        free(c->iov);\n        free(c->msglist);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to allocate buffers for connection\\n\");\n        return 1;\n    }\n\n    STATS_LOCK();\n    stats.conn_structs++;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\n/**\n * Destructor for all connection objects. Release all allocated resources.\n *\n * @param buffer The memory allocated by the objec cache\n * @param unused not used\n */\nstatic void conn_destructor(void *buffer, void *unused) {\n    conn *c = buffer;\n    free(c->rbuf);\n    free(c->wbuf);\n    free(c->ilist);\n    free(c->suffixlist);\n    free(c->iov);\n    free(c->msglist);\n\n    STATS_LOCK();\n    stats.conn_structs--;\n    STATS_UNLOCK();\n    (void)unused;\n}\n\nconn *conn_new(const SOCKET sfd, STATE_FUNC init_state,\n               const int event_flags,\n               const int read_buffer_size, enum network_transport transport,\n               struct event_base *base, struct timeval *timeout) {\n    conn *c = cache_alloc(conn_cache);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    assert(c->thread == NULL);\n\n    if (c->rsize < read_buffer_size) {\n        void *mem = malloc(read_buffer_size);\n        if (mem) {\n            c->rsize = read_buffer_size;\n            free(c->rbuf);\n            c->rbuf = mem;\n        } else {\n            assert(c->thread == NULL);\n            cache_free(conn_cache, c);\n            return NULL;\n        }\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    if (IS_UDP(transport)) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (%s)\\n\", sfd,\n                                            prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new auto-negotiating client connection\\n\",\n                                            sfd);\n        } else if (c->protocol == ascii_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new unknown (%d) client connection\\n\",\n                                            sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->sfd = sfd;\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->ascii_cmd = NULL;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->next = NULL;\n    c->list_state = 0;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (!register_event(c, timeout)) {\n        assert(c->thread == NULL);\n        cache_free(conn_cache, c);\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    c->refcount = 1;\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    perform_callbacks(ON_CONNECT, NULL, c);\n\n    return c;\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n\n    if (c->ileft != 0) {\n        for (; c->ileft > 0; c->ileft--,c->icurr++) {\n            settings.engine.v1->release(settings.engine.v0, c, *(c->icurr));\n        }\n    }\n\n    if (c->suffixleft != 0) {\n        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {\n            cache_free(c->thread->suffix_cache, *(c->suffixcurr));\n        }\n    }\n\n    if (c->write_and_free) {\n        free(c->write_and_free);\n        c->write_and_free = 0;\n    }\n\n    if (c->sasl_conn) {\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n\n    c->engine_storage = NULL;\n    c->tap_iterator = NULL;\n    c->thread = NULL;\n    assert(c->next == NULL);\n    c->ascii_cmd = NULL;\n    c->sfd = INVALID_SOCKET;\n}\n\nvoid conn_close(conn *c) {\n    assert(c != NULL);\n    assert(c->sfd == INVALID_SOCKET);\n\n    if (c->ascii_cmd != NULL) {\n        c->ascii_cmd->abort(c->ascii_cmd, c);\n    }\n\n    assert(c->thread);\n    LOCK_THREAD(c->thread);\n    /* remove from pending-io list */\n    if (settings.verbose > 1 && list_contains(c->thread->pending_io, c)) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Current connection was in the pending-io list.. Nuking it\\n\");\n    }\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    c->thread->pending_close = list_remove(c->thread->pending_close, c);\n    UNLOCK_THREAD(c->thread);\n\n    conn_cleanup(c);\n\n    /*\n     * The contract with the object cache is that we should return the\n     * object in a constructed state. Reset the buffers to the default\n     * size\n     */\n    conn_reset_buffersize(c);\n    assert(c->thread == NULL);\n    cache_free(conn_cache, c);\n}\n\n/*\n * Shrinks a connection's buffers if they're too big.  This prevents\n * periodic large \"get\" requests from permanently chewing lots of server\n * memory.\n *\n * This should only be called in between requests since it can wipe output\n * buffers!\n */\nstatic void conn_shrink(conn *c) {\n    assert(c != NULL);\n\n    if (IS_UDP(c->transport))\n        return;\n\n    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {\n        char *newbuf;\n\n        if (c->rcurr != c->rbuf)\n            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);\n\n        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);\n\n        if (newbuf) {\n            c->rbuf = newbuf;\n            c->rsize = DATA_BUFFER_SIZE;\n        }\n        /* TODO check other branch... */\n        c->rcurr = c->rbuf;\n    }\n\n    if (c->isize > ITEM_LIST_HIGHWAT) {\n        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));\n        if (newbuf) {\n            c->ilist = newbuf;\n            c->isize = ITEM_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->msgsize > MSG_LIST_HIGHWAT) {\n        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));\n        if (newbuf) {\n            c->msglist = newbuf;\n            c->msgsize = MSG_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->iovsize > IOV_LIST_HIGHWAT) {\n        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));\n        if (newbuf) {\n            c->iov = newbuf;\n            c->iovsize = IOV_LIST_INITIAL;\n        }\n    /* TODO check return value */\n    }\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nconst char *state_text(STATE_FUNC state) {\n    if (state == conn_listening) {\n        return \"conn_listening\";\n    } else if (state == conn_new_cmd) {\n        return \"conn_new_cmd\";\n    } else if (state == conn_waiting) {\n        return \"conn_waiting\";\n    } else if (state == conn_read) {\n        return \"conn_read\";\n    } else if (state == conn_parse_cmd) {\n        return \"conn_parse_cmd\";\n    } else if (state == conn_write) {\n        return \"conn_write\";\n    } else if (state == conn_nread) {\n        return \"conn_nread\";\n    } else if (state == conn_swallow) {\n        return \"conn_swallow\";\n    } else if (state == conn_closing) {\n        return \"conn_closing\";\n    } else if (state == conn_mwrite) {\n        return \"conn_mwrite\";\n    } else if (state == conn_ship_log) {\n        return \"conn_ship_log\";\n    } else if (state == conn_add_tap_client) {\n        return \"conn_add_tap_client\";\n    } else if (state == conn_setup_tap_stream) {\n        return \"conn_setup_tap_stream\";\n    } else if (state == conn_pending_close) {\n        return \"conn_pending_close\";\n    } else if (state == conn_immediate_close) {\n        return \"conn_immediate_close\";\n    } else {\n        return \"Unknown\";\n    }\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nvoid conn_set_state(conn *c, STATE_FUNC state) {\n    assert(c != NULL);\n\n    if (state != c->state) {\n        /*\n         * The connections in the \"tap thread\" behaves differently than\n         * normal connections because they operate in a full duplex mode.\n         * New messages may appear from both sides, so we can't block on\n         * read from the nework / engine\n         */\n        if (c->thread == tap_thread) {\n            if (state == conn_waiting) {\n                c->which = EV_WRITE;\n                state = conn_ship_log;\n            }\n        }\n\n        if (settings.verbose > 2 || c->state == conn_closing\n            || c->state == conn_add_tap_client) {\n            settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                            \"%d: going from %s to %s\\n\",\n                                            c->sfd, state_text(c->state),\n                                            state_text(state));\n        }\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);\n        }\n\n        c->state = state;\n    }\n}\n\n/*\n * Ensures that there is room for another struct iovec in a connection's\n * iov list.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int ensure_iov_space(conn *c) {\n    assert(c != NULL);\n\n    if (c->iovused >= c->iovsize) {\n        int i, iovnum;\n        struct iovec *new_iov = (struct iovec *)realloc(c->iov,\n                                (c->iovsize * 2) * sizeof(struct iovec));\n        if (! new_iov)\n            return -1;\n        c->iov = new_iov;\n        c->iovsize *= 2;\n\n        /* Point all the msghdr structures at the new list. */\n        for (i = 0, iovnum = 0; i < c->msgused; i++) {\n            c->msglist[i].msg_iov = &c->iov[iovnum];\n            iovnum += c->msglist[i].msg_iovlen;\n        }\n    }\n\n    return 0;\n}\n\n\n/*\n * Adds data to the list of pending data that will be written out to a\n * connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\n\nstatic int add_iov(conn *c, const void *buf, int len) {\n    struct msghdr *m;\n    int leftover;\n    bool limit_to_mtu;\n\n    assert(c != NULL);\n\n    do {\n        m = &c->msglist[c->msgused - 1];\n\n        /*\n         * Limit UDP packets, and the first payloads of TCP replies, to\n         * UDP_MAX_PAYLOAD_SIZE bytes.\n         */\n        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);\n\n        /* We may need to start a new msghdr if this one is full. */\n        if (m->msg_iovlen == IOV_MAX ||\n            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {\n            add_msghdr(c);\n            m = &c->msglist[c->msgused - 1];\n        }\n\n        if (ensure_iov_space(c) != 0)\n            return -1;\n\n        /* If the fragment is too big to fit in the datagram, split it up */\n        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {\n            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;\n            len -= leftover;\n        } else {\n            leftover = 0;\n        }\n\n        m = &c->msglist[c->msgused - 1];\n        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;\n        m->msg_iov[m->msg_iovlen].iov_len = len;\n\n        c->msgbytes += len;\n        c->iovused++;\n        m->msg_iovlen++;\n\n        buf = ((char *)buf) + len;\n        len = leftover;\n    } while (leftover > 0);\n\n    return 0;\n}\n\n\n/*\n * Constructs a set of UDP headers and attaches them to the outgoing messages.\n */\nstatic int build_udp_headers(conn *c) {\n    int i;\n    unsigned char *hdr;\n\n    assert(c != NULL);\n\n    if (c->msgused > c->hdrsize) {\n        void *new_hdrbuf;\n        if (c->hdrbuf)\n            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);\n        else\n            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);\n        if (! new_hdrbuf)\n            return -1;\n        c->hdrbuf = (unsigned char *)new_hdrbuf;\n        c->hdrsize = c->msgused * 2;\n    }\n\n    hdr = c->hdrbuf;\n    for (i = 0; i < c->msgused; i++) {\n        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;\n        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;\n        *hdr++ = c->request_id / 256;\n        *hdr++ = c->request_id % 256;\n        *hdr++ = i / 256;\n        *hdr++ = i % 256;\n        *hdr++ = c->msgused / 256;\n        *hdr++ = c->msgused % 256;\n        *hdr++ = 0;\n        *hdr++ = 0;\n        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n\n    assert(c != NULL);\n\n    if (c->noreply) {\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \">%d NOREPLY %s\\n\", c->sfd, str);\n        }\n        c->noreply = false;\n        if (c->sbytes > 0) {\n            conn_set_state(c, conn_swallow);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n        return;\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d %s\\n\", c->sfd, str);\n    }\n\n    /* Nuke a partial output... */\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    add_msghdr(c);\n\n    len = strlen(str);\n    if ((len + 2) > c->wsize) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(c->wbuf, str, len);\n    memcpy(c->wbuf + len, \"\\r\\n\", 2);\n    c->wbytes = len + 2;\n    c->wcurr = c->wbuf;\n\n    conn_set_state(c, conn_write);\n\n    if (c->sbytes > 0) {\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n\n    return;\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_update_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        out_string(c, \"SERVER_ERROR failed to get item details\");\n        return;\n    }\n\n    c->sbytes = 2; // swallow \\r\\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c, it, &c->cas,\n                                        c->store_op, 0);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->store_op) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_CAS:\n        MEMCACHED_COMMAND_CAS(c->sfd, info.key, info.nkey, info.nbytes, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"STORED\");\n        break;\n    case ENGINE_KEY_EEXISTS:\n        out_string(c, \"EXISTS\");\n        break;\n    case ENGINE_KEY_ENOENT:\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"NOT_STORED\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR invalid arguments\");\n        break;\n    case ENGINE_E2BIG:\n        out_string(c, \"CLIENT_ERROR value too big\");\n        break;\n    case ENGINE_EACCESS:\n        out_string(c, \"CLIENT_ERROR access control violation\");\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        out_string(c, \"SERVER_ERROR not my vbucket\");\n        break;\n    case ENGINE_FAILED:\n        out_string(c, \"SERVER_ERROR failure\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_WANT_MORE:\n        assert(false);\n        c->state = conn_closing;\n        break;\n\n    default:\n        out_string(c, \"SERVER_ERROR internal\");\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\n/**\n * get a pointer to the start of the request struct for the current command\n */\nstatic void* binary_get_request(conn *c) {\n    char *ret = c->rcurr;\n    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +\n            c->binary_header.request.extlen);\n\n    assert(ret >= c->rbuf);\n    return ret;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\n/**\n * Insert a key into a buffer, but replace all non-printable characters\n * with a '.'.\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param key the key to add to the buffer\n * @param nkey the number of bytes in the key\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t key_to_printable_buffer(char *dest, size_t destsz,\n                                       int client, bool from_client,\n                                       const char *prefix,\n                                       const char *key,\n                                       size_t nkey)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s \", from_client ? '>' : '<',\n                          client, prefix);\n    size_t ii;\n    char *ptr = dest + nw;\n    if (nw == -1) {\n        return -1;\n    }\n\n    destsz -= nw;\n    if (nkey > destsz) {\n        nkey = destsz;\n    }\n\n    for (ii = 0; ii < nkey; ++ii, ++key, ++ptr) {\n        if (isgraph(*key)) {\n            *ptr = *key;\n        } else {\n            *ptr = '.';\n        }\n    }\n\n    *ptr = '\\0';\n    return ptr - dest;\n}\n\n/**\n * Convert a byte array to a text string\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param data the data to add to the buffer\n * @param size the number of bytes in data to print\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t bytes_to_output_string(char *dest, size_t destsz,\n                                      int client, bool from_client,\n                                      const char *prefix,\n                                      const char *data,\n                                      size_t size)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s\", from_client ? '>' : '<',\n                          client, prefix);\n    size_t ii;\n    ssize_t offset = nw;\n    if (nw == -1) {\n        return -1;\n    }\n\n    for (ii = 0; ii < size; ++ii) {\n        if (ii % 4 == 0) {\n            if ((nw = snprintf(dest + offset, destsz - offset, \"\\n%c%d  \",\n                               from_client ? '>' : '<', client)) == -1) {\n                return  -1;\n            }\n            offset += nw;\n        }\n        if ((nw = snprintf(dest + offset, destsz - offset,\n                           \" 0x%02x\", (unsigned char)data[ii])) == -1) {\n            return -1;\n        }\n        offset += nw;\n    }\n\n    if ((nw = snprintf(dest + offset, destsz - offset, \"\\n\")) == -1) {\n        return -1;\n    }\n\n    return offset + nw;\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n\n    assert(c);\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        /* XXX:  out_string is inappropriate here */\n        out_string(c, \"SERVER_ERROR out of memory\");\n        return;\n    }\n\n    header = (protocol_binary_response_header *)c->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (bytes_to_output_string(buffer, sizeof(buffer), c->sfd, false,\n                                   \"Writing bin response:\",\n                                   (const char*)header->bytes,\n                                   sizeof(header->bytes)) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%s\", buffer);\n        }\n    }\n\n    add_iov(c, c->wbuf, sizeof(header->response));\n}\n\n/**\n * Convert an error code generated from the storage engine to the corresponding\n * error code used by the protocol layer.\n * @param e the error code as used in the engine\n * @return the error code as used by the protocol layer\n */\nstatic protocol_binary_response_status engine_error_2_protocol_error(ENGINE_ERROR_CODE e) {\n    protocol_binary_response_status ret;\n\n    switch (e) {\n    case ENGINE_SUCCESS:\n        return PROTOCOL_BINARY_RESPONSE_SUCCESS;\n    case ENGINE_KEY_ENOENT:\n        return PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n    case ENGINE_KEY_EEXISTS:\n        return PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n    case ENGINE_ENOMEM:\n        return PROTOCOL_BINARY_RESPONSE_ENOMEM;\n    case ENGINE_TMPFAIL:\n        return PROTOCOL_BINARY_RESPONSE_ETMPFAIL;\n    case ENGINE_NOT_STORED:\n        return PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n    case ENGINE_EINVAL:\n        return PROTOCOL_BINARY_RESPONSE_EINVAL;\n    case ENGINE_ENOTSUP:\n        return PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED;\n    case ENGINE_E2BIG:\n        return PROTOCOL_BINARY_RESPONSE_E2BIG;\n    case ENGINE_NOT_MY_VBUCKET:\n        return PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET;\n    case ENGINE_ERANGE:\n        return PROTOCOL_BINARY_RESPONSE_ERANGE;\n    default:\n        ret = PROTOCOL_BINARY_RESPONSE_EINTERNAL;\n    }\n\n    return ret;\n}\n\nstatic void write_bin_packet(conn *c, protocol_binary_response_status err, int swallow) {\n    ssize_t len;\n    char buffer[1024] = { [sizeof(buffer) - 1] = '\\0' };\n\n    switch (err) {\n    case PROTOCOL_BINARY_RESPONSE_SUCCESS:\n        len = 0;\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n        len = snprintf(buffer, sizeof(buffer), \"Out of memory\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ETMPFAIL:\n        len = snprintf(buffer, sizeof(buffer), \"Temporary failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n        len = snprintf(buffer, sizeof(buffer), \"Unknown command\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n        len = snprintf(buffer, sizeof(buffer), \"Not found\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n        len = snprintf(buffer, sizeof(buffer), \"Invalid arguments\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n        len = snprintf(buffer, sizeof(buffer), \"Data exists for key\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n        len = snprintf(buffer, sizeof(buffer), \"Too large\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"Non-numeric server-side value for incr or decr\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n        len = snprintf(buffer, sizeof(buffer), \"Not stored\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n        len = snprintf(buffer, sizeof(buffer), \"Auth failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED:\n        len = snprintf(buffer, sizeof(buffer), \"Not supported\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"I'm not responsible for this vbucket\");\n        break;\n\n    default:\n        len = snprintf(buffer, sizeof(buffer), \"UNHANDLED ERROR (%d)\", err);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n    }\n\n    /* Allow the engine to pass extra error information */\n    if (settings.engine.v1->errinfo != NULL) {\n        size_t elen = settings.engine.v1->errinfo(settings.engine.v0, c, buffer + len + 2,\n                                                  sizeof(buffer) - len - 3);\n\n        if (elen > 0) {\n            memcpy(buffer + len, \": \", 2);\n            len += elen + 2;\n        }\n    }\n\n    if (err != PROTOCOL_BINARY_RESPONSE_SUCCESS && settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d Writing an error: %s\\n\", c->sfd,\n                                        buffer);\n    }\n\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        add_iov(c, buffer, len);\n    }\n    conn_set_state(c, conn_mwrite);\n    if (swallow > 0) {\n        c->sbytes = swallow;\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, const void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        if(dlen > 0) {\n            add_iov(c, d, dlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        conn_set_state(c, conn_new_cmd);\n    }\n}\n\n\nstatic void complete_incr_bin(conn *c) {\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;\n    protocol_binary_request_incr* req = binary_get_request(c);\n\n    assert(c != NULL);\n    assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    uint64_t delta = ntohll(req->message.body.delta);\n    uint64_t initial = ntohll(req->message.body.initial);\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n    char *key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n    bool incr = (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT ||\n                 c->cmd == PROTOCOL_BINARY_CMD_INCREMENTQ);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        ssize_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     incr ? \"INCR\" : \"DECR\", key, nkey);\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" %\" PRIu64 \", %\" PRIu64 \", %\" PRIu64 \"\\n\",\n                         delta, initial, (uint64_t)expiration) != -1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0,\n                                             c, key, nkey, incr,\n                                             req->message.body.expiration != 0xffffffff,\n                                             delta, initial, expiration,\n                                             &c->cas,\n                                             &rsp->message.body.value,\n                                             c->binary_header.request.vbucket);\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        rsp->message.body.value = htonll(rsp->message.body.value);\n        write_bin_response(c, &rsp->message.body, 0, 0,\n                           sizeof (rsp->message.body.value));\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EINVAL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, 0);\n        break;\n    case ENGINE_NOT_STORED:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n        return;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c,\n                                        it, &c->cas, c->store_op,\n                                        c->binary_header.request.vbucket);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->cmd) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    default:\n        if (c->store_op == OPERATION_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->store_op == OPERATION_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_packet(c, eno, 0);\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\nstatic void process_bin_get(conn *c) {\n    item *it;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"GET\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey,\n                                      c->binary_header.request.vbucket);\n    }\n\n    uint16_t keylen;\n    uint32_t bodylen;\n    item_info info = { .nvalue = 1 };\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to get item info\\n\",\n                                            c->sfd);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            break;\n        }\n\n        keylen = 0;\n        bodylen = sizeof(rsp->message.body) + info.nbytes;\n\n        STATS_HIT(c, get, key, nkey);\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(info.cas);\n\n        // add the flags\n        rsp->message.body.flags = info.flags;\n        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            add_iov(c, info.key, nkey);\n        }\n\n        add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n        conn_set_state(c, conn_mwrite);\n        /* Remember this item so we can garbage collect it later */\n        c->item = it;\n        break;\n    case ENGINE_KEY_ENOENT:\n        STATS_MISS(c, get, key, nkey);\n\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);\n                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                               0, nkey, nkey);\n                memcpy(ofs, key, nkey);\n                add_iov(c, ofs, nkey);\n                conn_set_state(c, conn_mwrite);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            }\n        }\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n\n    default:\n        /* @todo add proper error handling! */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Unknown error code: %d\\n\", ret);\n        abort();\n    }\n\n    if (settings.detail_enabled && ret != ENGINE_EWOULDBLOCK) {\n        stats_prefix_record_get(key, nkey, ret == ENGINE_SUCCESS);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->dynamic_buffer.offset += sizeof(header.response) + bodylen;\n}\n\n/**\n * Append a key-value pair to the stats output buffer. This function assumes\n * that the output buffer is big enough (it will be if you call it through\n * append_stats)\n */\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t nbytes = 5; /* \"END\\r\\n\" or \"STAT \" */\n\n    if (klen == 0 && vlen == 0) {\n        memcpy(pos, \"END\\r\\n\", 5);\n    } else {\n        memcpy(pos, \"STAT \", 5);\n        memcpy(pos + nbytes, key, klen);\n        nbytes += klen;\n        if (vlen != 0) {\n            pos[nbytes] = ' ';\n            ++nbytes;\n            memcpy(pos + nbytes, val, vlen);\n            nbytes += vlen;\n        }\n        memcpy(pos + nbytes, \"\\r\\n\", 2);\n        nbytes += 2;\n    }\n\n    c->dynamic_buffer.offset += nbytes;\n}\n\nstatic bool grow_dynamic_buffer(conn *c, size_t needed) {\n    size_t nsize = c->dynamic_buffer.size;\n    size_t available = nsize - c->dynamic_buffer.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->dynamic_buffer.buffer == NULL) {\n        nsize = 1024;\n        available = c->dynamic_buffer.size = c->dynamic_buffer.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->dynamic_buffer.offset;\n    }\n\n    if (nsize != c->dynamic_buffer.size) {\n        char *ptr = realloc(c->dynamic_buffer.buffer, nsize);\n        if (ptr) {\n            c->dynamic_buffer.buffer = ptr;\n            c->dynamic_buffer.size = nsize;\n        } else {\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                         const char *val, const uint32_t vlen,\n                         const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return ;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->dynamic_buffer.offset <= c->dynamic_buffer.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"STATS\", subcommand, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (nkey == 0) {\n            /* request all statistics */\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, NULL, 0, append_stats);\n            if (ret == ENGINE_SUCCESS) {\n                server_stats(&append_stats, c, false);\n            }\n        } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n            stats_reset(c);\n            settings.engine.v1->reset_stats(settings.engine.v0, c);\n        } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n            process_stat_settings(&append_stats, c);\n        } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n            char *subcmd_pos = subcommand + 6;\n            if (settings.allow_detailed) {\n                if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n                    int len;\n                    char *dump_buf = stats_prefix_dump(&len);\n                    if (dump_buf == NULL || len <= 0) {\n                        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                        return ;\n                    } else {\n                        append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                        free(dump_buf);\n                    }\n                } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n                    settings.detail_enabled = 1;\n                } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n                    settings.detail_enabled = 0;\n                } else {\n                    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                    return;\n                }\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                return;\n            }\n        } else if (strncmp(subcommand, \"aggregate\", 9) == 0) {\n            server_stats(&append_stats, c, true);\n        } else if (strncmp(subcommand, \"topkeys\", 7) == 0) {\n            topkeys_t *tk = get_independent_stats(c)->topkeys;\n            if (tk != NULL) {\n                topkeys_stats(tk, c, current_time, append_stats);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                return;\n            }\n        } else {\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                subcommand, nkey,\n                                                append_stats);\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        append_stats(NULL, 0, NULL, 0, c);\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void bin_read_chunk(conn *c, enum bin_substates next_substate, uint32_t chunk) {\n    assert(c);\n    c->substate = next_substate;\n    c->rlbytes = chunk;\n\n    /* Ok... do we have room for everything in our buffer? */\n    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;\n    if (c->rlbytes > c->rsize - offset) {\n        size_t nsize = c->rsize;\n        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);\n\n        while (size > nsize) {\n            nsize *= 2;\n        }\n\n        if (nsize != c->rsize) {\n            char *newm;\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"%d: Need to grow buffer from %lu to %lu\\n\",\n                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);\n            }\n            newm = realloc(c->rbuf, nsize);\n            if (newm == NULL) {\n                if (settings.verbose) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                            \"%d: Failed to grow buffer.. closing connection\\n\",\n                            c->sfd);\n                }\n                conn_set_state(c, conn_closing);\n                return;\n            }\n\n            c->rbuf= newm;\n            /* rcurr should point to the same offset in the packet */\n            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);\n            c->rsize = nsize;\n        }\n        if (c->rbuf != c->rcurr) {\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n            c->rcurr = c->rbuf;\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: Repack input buffer\\n\",\n                                                c->sfd);\n            }\n        }\n    }\n\n    /* preserve the header in the buffer.. */\n    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);\n    conn_set_state(c, conn_nread);\n}\n\nstatic void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {\n    bin_read_chunk(c, next_substate, c->keylen + extra);\n}\n\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                \"%d: Protocol error (opcode %02x), close connection\\n\",\n                c->sfd, c->binary_header.request.opcode);\n    }\n    c->write_and_go = conn_closing;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL, NULL, NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                         \"%d: Failed to initialize SASL conn.\\n\",\n                         c->sfd);\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void get_auth_data(const void *cookie, auth_data_t *data) {\n    conn *c = (conn*)cookie;\n    if (c->sasl_conn) {\n        sasl_getprop(c->sasl_conn, SASL_USERNAME, (void*)&data->username);\n#ifdef ENABLE_ISASL\n        sasl_getprop(c->sasl_conn, ISASL_CONFIG, (void*)&data->config);\n#endif\n    }\n    (void)(data);\n}\n\n#ifdef SASL_ENABLED\nstatic void bin_list_sasl_mechs(conn *c) {\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                     \"%d: Failed to list SASL mechanisms.\\n\",\n                     c->sfd);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n#endif\n\nstruct sasl_tmp {\n    int ksize;\n    int vsize;\n    char data[]; /* data + ksize == value */\n};\n\nstatic void process_bin_sasl_auth(conn *c) {\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    size_t buffer_size = sizeof(struct sasl_tmp) + nkey + vlen + 2;\n    struct sasl_tmp *data = calloc(sizeof(struct sasl_tmp) + buffer_size, 1);\n    if (!data) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    data->ksize = nkey;\n    data->vsize = vlen;\n    memcpy(data->data, key, nkey);\n\n    c->item = data;\n    c->ritem = data->data + nkey;\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    struct sasl_tmp *stmp = c->item;\n    char mech[nkey+1];\n    memcpy(mech, stmp->data, nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: mech: ``%s'' with %d bytes of data\\n\", c->sfd, mech, vlen);\n    }\n\n    const char *challenge = vlen == 0 ? NULL : (stmp->data + nkey);\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                    \"%d: Unhandled command %d with challenge %s\\n\",\n                    c->sfd, c->cmd, challenge);\n        }\n        break;\n    }\n\n    free(c->item);\n    c->item = NULL;\n    c->ritem = NULL;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"%d: sasl result code:  %d\\n\",\n                                        c->sfd, result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        auth_data_t data;\n        get_auth_data(c, &data);\n        perform_callbacks(ON_AUTH, (const void*)&data, c);\n        STATS_NOKEY(c, auth_cmds);\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if(outlen > 0) {\n            add_iov(c, out, outlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n        break;\n    default:\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"%d: Unknown sasl response:  %d\\n\",\n                                            c->sfd, result);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        STATS_NOKEY2(c, auth_cmds, auth_errors);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        if (c->sasl_conn) {\n            const void *uname = NULL;\n            sasl_getprop(c->sasl_conn, SASL_USERNAME, &uname);\n            rv = uname != NULL;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: authenticated() in cmd 0x%02x is %s\\n\",\n                c->sfd, c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic bool binary_response_handler(const void *key, uint16_t keylen,\n                                    const void *ext, uint8_t extlen,\n                                    const void *body, uint32_t bodylen,\n                                    uint8_t datatype, uint16_t status,\n                                    uint64_t cas, const void *cookie)\n{\n    conn *c = (conn*)cookie;\n    /* Look at append_bin_stats */\n    size_t needed = keylen + extlen + bodylen + sizeof(protocol_binary_response_header);\n    if (!grow_dynamic_buffer(c, needed)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return false;\n    }\n\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = c->binary_header.request.opcode,\n        .response.keylen = (uint16_t)htons(keylen),\n        .response.extlen = extlen,\n        .response.datatype = datatype,\n        .response.status = (uint16_t)htons(status),\n        .response.bodylen = htonl(bodylen + keylen + extlen),\n        .response.opaque = c->opaque,\n        .response.cas = htonll(cas),\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (extlen > 0) {\n        memcpy(buf, ext, extlen);\n        buf += extlen;\n    }\n\n    if (keylen > 0) {\n        memcpy(buf, key, keylen);\n        buf += keylen;\n    }\n\n    if (bodylen > 0) {\n        memcpy(buf, body, bodylen);\n    }\n\n    c->dynamic_buffer.offset += needed;\n\n    return true;\n}\n\n/**\n * Tap stats (these are only used by the tap thread, so they don't need\n * to be in the threadlocal struct right now...\n */\nstruct tap_cmd_stats {\n    uint64_t connect;\n    uint64_t mutation;\n    uint64_t checkpoint_start;\n    uint64_t checkpoint_end;\n    uint64_t delete;\n    uint64_t flush;\n    uint64_t opaque;\n    uint64_t vbucket_set;\n};\n\nstruct tap_stats {\n    pthread_mutex_t mutex;\n    struct tap_cmd_stats sent;\n    struct tap_cmd_stats received;\n} tap_stats = { .mutex = PTHREAD_MUTEX_INITIALIZER };\n\nstatic void ship_tap_log(conn *c) {\n    assert(c->thread->type == TAP);\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to create output headers. Shutting down tap connection\\n\", c->sfd);\n        }\n        conn_set_state(c, conn_closing);\n        return ;\n    }\n    /* @todo add check for buffer overflow of c->wbuf) */\n    c->wcurr = c->wbuf;\n\n    bool more_data = true;\n    bool send_data = false;\n    bool disconnect = false;\n\n    item *it;\n    uint32_t bodylen;\n    int ii = 0;\n    c->icurr = c->ilist;\n    do {\n        /* @todo fixme! */\n        if (ii++ == 10) {\n            break;\n        }\n\n        void *engine;\n        uint16_t nengine;\n        uint8_t ttl;\n        uint16_t tap_flags;\n        uint32_t seqno;\n        uint16_t vbucket;\n\n        tap_event_t event = c->tap_iterator(settings.engine.v0, c, &it,\n                                            &engine, &nengine, &ttl,\n                                            &tap_flags, &seqno, &vbucket);\n        union {\n            protocol_binary_request_tap_mutation mutation;\n            protocol_binary_request_tap_delete delete;\n            protocol_binary_request_tap_flush flush;\n            protocol_binary_request_tap_opaque opaque;\n            protocol_binary_request_noop noop;\n        } msg = {\n            .mutation.message.header.request.magic = (uint8_t)PROTOCOL_BINARY_REQ,\n        };\n\n        msg.opaque.message.header.request.opaque = htonl(seqno);\n        msg.opaque.message.body.tap.enginespecific_length = htons(nengine);\n        msg.opaque.message.body.tap.ttl = ttl;\n        msg.opaque.message.body.tap.flags = htons(tap_flags);\n        msg.opaque.message.header.request.extlen = 8;\n        msg.opaque.message.header.request.vbucket = htons(vbucket);\n        item_info info = { .nvalue = 1 };\n\n        switch (event) {\n        case TAP_NOOP :\n            send_data = true;\n            msg.noop.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n            msg.noop.message.header.request.extlen = 0;\n            msg.noop.message.header.request.bodylen = htonl(0);\n            memcpy(c->wcurr, msg.noop.bytes, sizeof(msg.noop.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.noop.bytes));\n            c->wcurr += sizeof(msg.noop.bytes);\n            c->wbytes += sizeof(msg.noop.bytes);\n            break;\n        case TAP_PAUSE :\n            more_data = false;\n            break;\n        case TAP_CHECKPOINT_START:\n        case TAP_CHECKPOINT_END:\n        case TAP_MUTATION:\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n\n            if (event == TAP_CHECKPOINT_START) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_start++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_CHECKPOINT_END) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_end++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_MUTATION) {\n                msg.mutation.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_MUTATION;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.mutation++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.mutation.message.header.request.cas = htonll(info.cas);\n            msg.mutation.message.header.request.keylen = htons(info.nkey);\n            msg.mutation.message.header.request.extlen = 16;\n\n            bodylen = 16 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.mutation.message.header.request.bodylen = htonl(bodylen);\n            msg.mutation.message.body.item.flags = htonl(info.flags);\n            msg.mutation.message.body.item.expiration = htonl(info.exptime);\n            msg.mutation.message.body.tap.enginespecific_length = htons(nengine);\n            msg.mutation.message.body.tap.ttl = ttl;\n            msg.mutation.message.body.tap.flags = htons(tap_flags);\n            memcpy(c->wcurr, msg.mutation.bytes, sizeof(msg.mutation.bytes));\n\n            add_iov(c, c->wcurr, sizeof(msg.mutation.bytes));\n            c->wcurr += sizeof(msg.mutation.bytes);\n            c->wbytes += sizeof(msg.mutation.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            break;\n        case TAP_DELETION:\n            /* This is a delete */\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n            msg.delete.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_DELETE;\n            msg.delete.message.header.request.cas = htonll(info.cas);\n            msg.delete.message.header.request.keylen = htons(info.nkey);\n\n            bodylen = 8 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.delete.message.header.request.bodylen = htonl(bodylen);\n\n            memcpy(c->wcurr, msg.delete.bytes, sizeof(msg.delete.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.delete.bytes));\n            c->wcurr += sizeof(msg.delete.bytes);\n            c->wbytes += sizeof(msg.delete.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            pthread_mutex_lock(&tap_stats.mutex);\n            tap_stats.sent.delete++;\n            pthread_mutex_unlock(&tap_stats.mutex);\n            break;\n\n        case TAP_DISCONNECT:\n            disconnect = true;\n            more_data = false;\n            break;\n        case TAP_VBUCKET_SET:\n        case TAP_FLUSH:\n        case TAP_OPAQUE:\n            send_data = true;\n\n            if (event == TAP_OPAQUE) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_OPAQUE;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.opaque++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n\n            } else if (event == TAP_FLUSH) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_FLUSH;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.flush++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_VBUCKET_SET) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET;\n                msg.flush.message.body.tap.flags = htons(tap_flags);\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.vbucket_set++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.flush.message.header.request.bodylen = htonl(8 + nengine);\n            memcpy(c->wcurr, msg.flush.bytes, sizeof(msg.flush.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.flush.bytes));\n            c->wcurr += sizeof(msg.flush.bytes);\n            c->wbytes += sizeof(msg.flush.bytes);\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n            break;\n        default:\n            abort();\n        }\n    } while (more_data);\n\n    c->ewouldblock = false;\n    if (send_data) {\n        conn_set_state(c, conn_mwrite);\n        if (disconnect) {\n            c->write_and_go = conn_closing;\n        } else {\n            c->write_and_go = conn_ship_log;\n        }\n    } else {\n        if (disconnect) {\n            conn_set_state(c, conn_closing);\n        } else {\n            /* No more items to ship to the slave at this time.. suspend.. */\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: No more items in tap log.. waiting\\n\",\n                                                c->sfd);\n            }\n            c->ewouldblock = true;\n        }\n    }\n}\n\n\nstatic ENGINE_ERROR_CODE default_unknown_command(EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *descriptor,\n                                                 ENGINE_HANDLE* handle,\n                                                 const void* cookie,\n                                                 protocol_binary_request_header *request,\n                                                 ADD_RESPONSE response)\n{\n    (void)(descriptor);\n    return settings.engine.v1->unknown_command(handle, cookie, request, response);\n}\n\nstruct request_lookup {\n    EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *descriptor;\n    BINARY_COMMAND_CALLBACK callback;\n};\n\nstatic struct request_lookup request_handlers[0x100];\n\nstatic void initialize_binary_lookup_map(void) {\n    for (int ii = 0; ii < 0x100; ++ii) {\n        request_handlers[ii].descriptor = NULL;\n        request_handlers[ii].callback = default_unknown_command;\n    }\n}\n\nstatic void setup_binary_lookup_cmd(EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *descriptor,\n                                    uint8_t cmd,\n                                    BINARY_COMMAND_CALLBACK new_handler) {\n    request_handlers[cmd].descriptor = descriptor;\n    request_handlers[cmd].callback = new_handler;\n}\n\nstatic void process_bin_unknown_packet(conn *c) {\n    void *packet = c->rcurr - (c->binary_header.request.bodylen +\n                               sizeof(c->binary_header));\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        struct request_lookup *rq = request_handlers + c->binary_header.request.opcode;\n        ret = rq->callback(rq->descriptor, settings.engine.v0, c, packet,\n                           binary_response_handler);\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (c->dynamic_buffer.buffer != NULL) {\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        conn_set_state(c, conn_closing);\n        break;\n    default:\n        // Release the dynamic buffer.. it may be partial..\n        free(c->dynamic_buffer.buffer);\n        c->dynamic_buffer.buffer = NULL;\n        write_bin_packet(c, engine_error_2_protocol_error(ret), 0);\n    }\n}\n\nstatic void process_bin_tap_connect(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_connect *req = (void*)packet;\n    const char *key = packet + sizeof(req->bytes);\n    const char *data = key + c->binary_header.request.keylen;\n    uint32_t flags = 0;\n    size_t ndata = c->binary_header.request.bodylen -\n        c->binary_header.request.extlen -\n        c->binary_header.request.keylen;\n\n    if (c->binary_header.request.extlen == 4) {\n        flags = ntohl(req->message.body.flags);\n\n        if (flags & TAP_CONNECT_FLAG_BACKFILL) {\n            /* the userdata has to be at least 8 bytes! */\n            if (ndata < 8) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: ERROR: Invalid tap connect message\\n\",\n                                                c->sfd);\n                conn_set_state(c, conn_closing);\n                return ;\n            }\n        }\n    } else {\n        data -= 4;\n        key -= 4;\n    }\n\n    if (settings.verbose && c->binary_header.request.keylen > 0) {\n        char buffer[1024];\n        unsigned int len = c->binary_header.request.keylen;\n        if (len >= sizeof(buffer)) {\n            len = sizeof(buffer) - 1;\n        }\n        memcpy(buffer, key, len);\n        buffer[len] = '\\0';\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: Trying to connect with named tap connection: <%s>\\n\",\n                                        c->sfd, buffer);\n    }\n\n    TAP_ITERATOR iterator = settings.engine.v1->get_tap_iterator(\n        settings.engine.v0, c, key, c->binary_header.request.keylen,\n        flags, data, ndata);\n\n    if (iterator == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: FATAL: The engine does not support tap\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        c->write_and_go = conn_closing;\n    } else {\n        c->tap_iterator = iterator;\n        c->which = EV_WRITE;\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\nstatic void process_bin_tap_packet(tap_event_t event, conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_no_extras *tap = (void*)packet;\n    uint16_t nengine = ntohs(tap->message.body.tap.enginespecific_length);\n    uint16_t tap_flags = ntohs(tap->message.body.tap.flags);\n    uint32_t seqno = ntohl(tap->message.header.request.opaque);\n    uint8_t ttl = tap->message.body.tap.ttl;\n    char *engine_specific = packet + sizeof(tap->bytes);\n    char *key = engine_specific + nengine;\n    uint16_t nkey = c->binary_header.request.keylen;\n    char *data = key + nkey;\n    uint32_t flags = 0;\n    uint32_t exptime = 0;\n    uint32_t ndata = c->binary_header.request.bodylen - nengine - nkey - 8;\n    ENGINE_ERROR_CODE ret = c->aiostat;\n\n    if (ttl == 0) {\n        ret = ENGINE_EINVAL;\n    } else {\n        if (event == TAP_MUTATION || event == TAP_CHECKPOINT_START ||\n            event == TAP_CHECKPOINT_END) {\n            protocol_binary_request_tap_mutation *mutation = (void*)tap;\n            flags = ntohl(mutation->message.body.item.flags);\n            exptime = ntohl(mutation->message.body.item.expiration);\n            key += 8;\n            data += 8;\n            ndata -= 8;\n        }\n\n        if (ret == ENGINE_SUCCESS) {\n            ret = settings.engine.v1->tap_notify(settings.engine.v0, c,\n                                                 engine_specific, nengine,\n                                                 ttl - 1, tap_flags,\n                                                 event, seqno,\n                                                 key, nkey,\n                                                 flags, exptime,\n                                                 ntohll(tap->message.header.request.cas),\n                                                 data, ndata,\n                                                 c->binary_header.request.vbucket);\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_DISCONNECT:\n        conn_set_state(c, conn_closing);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        if ((tap_flags & TAP_FLAG_ACK) || (ret != ENGINE_SUCCESS)) {\n            write_bin_packet(c, engine_error_2_protocol_error(ret), 0);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n    }\n}\n\nstatic void process_bin_tap_ack(conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_response_no_extras *rsp = (void*)packet;\n    uint32_t seqno = ntohl(rsp->message.header.response.opaque);\n    uint16_t status = ntohs(rsp->message.header.response.status);\n    char *key = packet + sizeof(rsp->bytes);\n\n    ENGINE_ERROR_CODE ret = ENGINE_DISCONNECT;\n    if (settings.engine.v1->tap_notify != NULL) {\n        ret = settings.engine.v1->tap_notify(settings.engine.v0, c, NULL, 0, 0, status,\n                                             TAP_ACK, seqno, key,\n                                             c->binary_header.request.keylen, 0, 0,\n                                             0, NULL, 0, 0);\n    }\n\n    if (ret == ENGINE_DISCONNECT) {\n        conn_set_state(c, conn_closing);\n    } else {\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\n/**\n * We received a noop response.. just ignore it\n */\nstatic void process_bin_noop_response(conn *c) {\n    assert(c != NULL);\n    conn_set_state(c, conn_new_cmd);\n}\n\nstatic void process_bin_verbosity(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_verbosity *req = (void*)packet;\n    uint32_t level = (uint32_t)ntohl(req->message.body.level);\n    if (level > MAX_VERBOSITY_LEVEL) {\n        level = MAX_VERBOSITY_LEVEL;\n    }\n    settings.verbose = (int)level;\n    perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_packet(conn *c) {\n    /* @todo this should be an array of funciton pointers and call through */\n    switch (c->binary_header.request.opcode) {\n    case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.connect++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        conn_set_state(c, conn_add_tap_client);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.mutation++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_MUTATION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_start++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_START, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_end++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_END, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_DELETE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.delete++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_DELETION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.flush++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_FLUSH, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.opaque++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_OPAQUE, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.vbucket_set++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_VBUCKET_SET, c);\n        break;\n    case PROTOCOL_BINARY_CMD_VERBOSITY:\n        process_bin_verbosity(c);\n        break;\n    default:\n        process_bin_unknown_packet(c);\n    }\n}\n\ntypedef void (*RESPONSE_HANDLER)(conn*);\n/**\n * A map between the response packets op-code and the function to handle\n * the response message.\n */\nstatic RESPONSE_HANDLER response_handlers[256] = {\n    [PROTOCOL_BINARY_CMD_NOOP] = process_bin_noop_response,\n    [PROTOCOL_BINARY_CMD_TAP_MUTATION] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_DELETE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_FLUSH] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_OPAQUE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END] = process_bin_tap_ack\n};\n\nstatic void dispatch_bin_command(conn *c) {\n    int protocol_error = 0;\n\n    int extlen = c->binary_header.request.extlen;\n    uint16_t keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (settings.require_sasl && !authenticated(c)) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        c->write_and_go = conn_closing;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                bin_read_key(c, bin_read_flush_exptime, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                bin_read_key(c, bin_reading_set_header, 8);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                bin_read_key(c, bin_reading_get_key, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                bin_read_key(c, bin_reading_del_header, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                bin_read_key(c, bin_reading_incr_header, 20);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                bin_read_key(c, bin_reading_set_header, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                bin_read_key(c, bin_reading_stat, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                c->write_and_go = conn_closing;\n                if (c->noreply) {\n                    conn_set_state(c, conn_closing);\n                }\n            } else {\n                protocol_error = 1;\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n            if (settings.engine.v1->get_tap_iterator == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n       case PROTOCOL_BINARY_CMD_TAP_DELETE:\n       case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n       case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n       case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n            if (settings.engine.v1->tap_notify == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n            break;\n#ifdef SASL_ENABLED\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                bin_read_key(c, bin_reading_sasl_auth, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n#endif\n        case PROTOCOL_BINARY_CMD_VERBOSITY:\n            if (extlen == 4 && keylen == 0 && bodylen == 4) {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            if (settings.engine.v1->unknown_command == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                                bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c) {\n    char *key;\n    uint16_t nkey;\n    uint32_t vlen;\n    item *it;\n    protocol_binary_request_set* req = binary_get_request(c);\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = req->message.body.flags;\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        const char *prefix;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            prefix = \"ADD\";\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            prefix = \"SET\";\n        } else {\n            prefix = \"REPLACE\";\n        }\n\n        size_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     prefix, key, nkey);\n\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" Value len is %d\\n\", vlen)) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen,\n                                           req->message.body.flags,\n                                           expiration);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->store_op = OPERATION_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->store_op = OPERATION_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->store_op = OPERATION_REPLACE;\n            break;\n        default:\n            assert(0);\n        }\n\n        if (c->binary_header.request.cas != 0) {\n            c->store_op = OPERATION_CAS;\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n\n        /*\n         * Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET (but only if cas matches).\n         * Anywhere else too?\n         */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            /* @todo fix this for the ASYNC interface! */\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                       ntohll(req->message.header.request.cas),\n                                       c->binary_header.request.vbucket);\n        }\n\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, 0, 0);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->store_op = OPERATION_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->store_op = OPERATION_PREPEND;\n            break;\n        default:\n            assert(0);\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_flush(conn *c) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = binary_get_request(c);\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: flush %ld\", c->sfd,\n                                        (long)exptime);\n    }\n\n    ENGINE_ERROR_CODE ret;\n    ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n\n    if (ret == ENGINE_SUCCESS) {\n        write_bin_response(c, NULL, 0, 0, 0);\n    } else if (ret == ENGINE_ENOTSUP) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n    } else {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n    STATS_NOKEY(c, cmd_flush);\n}\n\nstatic void process_bin_delete(conn *c) {\n    protocol_binary_request_delete* req = binary_get_request(c);\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"DELETE\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (settings.detail_enabled) {\n            stats_prefix_record_delete(key, nkey);\n        }\n        ret = settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                         ntohll(req->message.header.request.cas),\n                                         c->binary_header.request.vbucket);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        write_bin_response(c, NULL, 0, 0, 0);\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        STATS_INCR(c, delete_misses, key, nkey);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_reading_set_header:\n        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||\n                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n            process_bin_append_prepend(c);\n        } else {\n            process_bin_update(c);\n        }\n        break;\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_get_key:\n        process_bin_get(c);\n        break;\n    case bin_reading_stat:\n        process_bin_stat(c);\n        break;\n    case bin_reading_del_header:\n        process_bin_delete(c);\n        break;\n    case bin_reading_incr_header:\n        complete_incr_bin(c);\n        break;\n    case bin_read_flush_exptime:\n        process_bin_flush(c);\n        break;\n    case bin_reading_sasl_auth:\n        process_bin_sasl_auth(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        break;\n    case bin_reading_packet:\n        if (c->binary_header.request.magic == PROTOCOL_BINARY_RES) {\n            RESPONSE_HANDLER handler;\n            handler = response_handlers[c->binary_header.request.opcode];\n            if (handler) {\n                handler(c);\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                       \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                        c->sfd, (unsigned int)c->binary_header.request.opcode);\n                conn_set_state(c, conn_closing);\n            }\n        } else {\n            process_bin_packet(c);\n        }\n        break;\n    default:\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                \"Not handling substate %d\\n\", c->substate);\n        abort();\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->sbytes = 0;\n    c->ascii_cmd = NULL;\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if(c->item != NULL) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = NULL;\n    }\n    conn_shrink(c);\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic ENGINE_ERROR_CODE ascii_response_handler(const void *cookie,\n                                                int nbytes,\n                                                const char *dta)\n{\n    conn *c = (conn*)cookie;\n    char *buf;\n    if (!grow_dynamic_buffer(c, nbytes)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return ENGINE_ENOMEM;\n    }\n\n    buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    memcpy(buf, dta, nbytes);\n    c->dynamic_buffer.offset += nbytes;\n\n    return ENGINE_SUCCESS;\n}\n\nstatic void complete_nread_ascii(conn *c) {\n    if (c->ascii_cmd != NULL) {\n        c->ewouldblock = false;\n        switch (c->ascii_cmd->execute(c->ascii_cmd->cookie, c, 0, NULL,\n                                      ascii_response_handler)) {\n        case ENGINE_SUCCESS:\n            if (c->dynamic_buffer.buffer != NULL) {\n                write_and_free(c, c->dynamic_buffer.buffer,\n                               c->dynamic_buffer.offset);\n                c->dynamic_buffer.buffer = NULL;\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            break;\n        case ENGINE_DISCONNECT:\n        default:\n            conn_set_state(c, conn_closing);\n        }\n    } else {\n        complete_update_ascii(c);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 30\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    for (s = e = command; ntokens < max_tokens - 1; ++e) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n            }\n            s = e + 1;\n        }\n        else if (*e == '\\0') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n            }\n\n            break; /* string end */\n        }\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\nstatic void detokenize(token_t *tokens, int ntokens, char **out, int *nbytes) {\n    int i, nb;\n    char *buf, *p;\n\n    nb = ntokens; // account for spaces, which is ntokens-1, plus the null\n    for (i = 0; i < ntokens; ++i) {\n        nb += tokens[i].length;\n    }\n\n    buf = malloc(nb * sizeof(char));\n    if (buf != NULL) {\n        p = buf;\n        for (i = 0; i < ntokens; ++i) {\n            memcpy(p, tokens[i].value, tokens[i].length);\n            p += tokens[i].length;\n            *p = ' ';\n            p++;\n        }\n        buf[nb - 1] = '\\0';\n        *nbytes = nb - 1;\n        *out = buf;\n    }\n}\n\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n    return c->noreply;\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (settings.allow_detailed) {\n        if (strcmp(command, \"on\") == 0) {\n            settings.detail_enabled = 1;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"off\") == 0) {\n            settings.detail_enabled = 0;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"dump\") == 0) {\n            int len;\n            char *stats = stats_prefix_dump(&len);\n            write_and_free(c, stats, len);\n        }\n        else {\n            out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n        }\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR detailed stats disabled\");\n    }\n}\n\nstatic void aggregate_callback(void *in, void *out) {\n    struct thread_stats *out_thread_stats = out;\n    struct independent_stats *in_independent_stats = in;\n    threadlocal_stats_aggregate(in_independent_stats->thread_stats,\n                                out_thread_stats);\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_clear(&thread_stats);\n\n    if (aggregate && settings.engine.v1->aggregate_stats != NULL) {\n        settings.engine.v1->aggregate_stats(settings.engine.v0,\n                                            (const void *)c,\n                                            aggregate_callback,\n                                            &thread_stats);\n    } else {\n        threadlocal_stats_aggregate(get_independent_stats(c)->thread_stats,\n                                    &thread_stats);\n    }\n\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n\n#ifndef __WIN32__\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"libevent\", \"%s\", event_get_version());\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef __WIN32__\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif\n\n    APPEND_STAT(\"daemon_connections\", \"%u\", stats.daemon_conns);\n    APPEND_STAT(\"curr_connections\", \"%u\", stats.curr_conns);\n    APPEND_STAT(\"total_connections\", \"%u\", stats.total_conns);\n    APPEND_STAT(\"connection_structures\", \"%u\", stats.conn_structs);\n    APPEND_STAT(\"cmd_get\", \"%\"PRIu64, thread_stats.cmd_get);\n    APPEND_STAT(\"cmd_set\", \"%\"PRIu64, slab_stats.cmd_set);\n    APPEND_STAT(\"cmd_flush\", \"%\"PRIu64, thread_stats.cmd_flush);\n    APPEND_STAT(\"auth_cmds\", \"%\"PRIu64, thread_stats.auth_cmds);\n    APPEND_STAT(\"auth_errors\", \"%\"PRIu64, thread_stats.auth_errors);\n    APPEND_STAT(\"get_hits\", \"%\"PRIu64, slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%\"PRIu64, thread_stats.get_misses);\n    APPEND_STAT(\"delete_misses\", \"%\"PRIu64, thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%\"PRIu64, slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%\"PRIu64, thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%\"PRIu64, thread_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%\"PRIu64, thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%\"PRIu64, thread_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%\"PRIu64, thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%\"PRIu64, slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%\"PRIu64, slab_stats.cas_badval);\n    APPEND_STAT(\"bytes_read\", \"%\"PRIu64, thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%\"PRIu64, thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%\"PRIu64, settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\",  is_listen_disabled() ? 0 : 1);\n    APPEND_STAT(\"listen_disabled_num\", \"%\"PRIu64, get_listen_disabled_num());\n    APPEND_STAT(\"rejected_conns\", \"%\" PRIu64, (unsigned long long)stats.rejected_conns);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%\" PRIu64, (unsigned long long)thread_stats.conn_yields);\n    STATS_UNLOCK();\n\n    /*\n     * Add tap stats (only if non-zero)\n     */\n    struct tap_stats ts;\n    pthread_mutex_lock(&tap_stats.mutex);\n    ts = tap_stats;\n    pthread_mutex_unlock(&tap_stats.mutex);\n\n    if (ts.sent.connect) {\n        APPEND_STAT(\"tap_connect_sent\", \"%\"PRIu64, ts.sent.connect);\n    }\n    if (ts.sent.mutation) {\n        APPEND_STAT(\"tap_mutation_sent\", \"%\"PRIu64, ts.sent.mutation);\n    }\n    if (ts.sent.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_sent\", \"%\"PRIu64, ts.sent.checkpoint_start);\n    }\n    if (ts.sent.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_sent\", \"%\"PRIu64, ts.sent.checkpoint_end);\n    }\n    if (ts.sent.delete) {\n        APPEND_STAT(\"tap_delete_sent\", \"%\"PRIu64, ts.sent.delete);\n    }\n    if (ts.sent.flush) {\n        APPEND_STAT(\"tap_flush_sent\", \"%\"PRIu64, ts.sent.flush);\n    }\n    if (ts.sent.opaque) {\n        APPEND_STAT(\"tap_opaque_sent\", \"%\"PRIu64, ts.sent.opaque);\n    }\n    if (ts.sent.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_sent\", \"%\"PRIu64,\n                    ts.sent.vbucket_set);\n    }\n    if (ts.received.connect) {\n        APPEND_STAT(\"tap_connect_received\", \"%\"PRIu64, ts.received.connect);\n    }\n    if (ts.received.mutation) {\n        APPEND_STAT(\"tap_mutation_received\", \"%\"PRIu64, ts.received.mutation);\n    }\n    if (ts.received.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_received\", \"%\"PRIu64, ts.received.checkpoint_start);\n    }\n    if (ts.received.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_received\", \"%\"PRIu64, ts.received.checkpoint_end);\n    }\n    if (ts.received.delete) {\n        APPEND_STAT(\"tap_delete_received\", \"%\"PRIu64, ts.received.delete);\n    }\n    if (ts.received.flush) {\n        APPEND_STAT(\"tap_flush_received\", \"%\"PRIu64, ts.received.flush);\n    }\n    if (ts.received.opaque) {\n        APPEND_STAT(\"tap_opaque_received\", \"%\"PRIu64, ts.received.opaque);\n    }\n    if (ts.received.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_received\", \"%\"PRIu64,\n                    ts.received.vbucket_set);\n    }\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%u\", (unsigned int)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"num_threads_per_udp\", \"%d\", settings.num_threads_per_udp);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"allow_detailed\", \"%s\",\n                settings.allow_detailed ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"reqs_per_tap_event\", \"%d\", settings.reqs_per_tap_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n#ifdef SASL_ENABLED\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"yes\");\n#else\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"no\");\n#endif\n\n#ifdef ENABLE_ISASL\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"isasl\");\n#elif defined(ENABLE_SASL)\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"cyrus\");\n#else\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"none\");\n#endif\n    APPEND_STAT(\"auth_required_sasl\", \"%s\", settings.require_sasl ? \"yes\" : \"no\");\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n    APPEND_STAT(\"topkeys\", \"%d\", settings.topkeys);\n\n    for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"extension\", \"%s\", ptr->get_name());\n    }\n\n    APPEND_STAT(\"logger\", \"%s\", settings.extensions.logger->get_name());\n\n    for (EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"ascii_extension\", \"%s\", ptr->get_name(ptr->cookie));\n    }\n\n    for (EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.binary;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"binary_extension\", \"%s\", ptr->get_name());\n    }\n}\n\nstatic char *process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    c->dynamic_buffer.offset = 0;\n\n    if (ntokens == 2) {\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            server_stats(&append_stats, c, false);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                NULL, 0, &append_stats);\n            if (ret == ENGINE_EWOULDBLOCK) {\n                c->ewouldblock = true;\n                return c->rcurr + 5;\n            }\n        }\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset(c);\n        out_string(c, \"RESET\");\n        return NULL;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4) {\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        } else {\n            process_stats_detail(c, tokens[2].value);\n        }\n        /* Output already generated */\n        return NULL;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf = NULL;\n        unsigned int bytes = 0, id, limit = 0;\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return NULL;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return NULL;\n        }\n\n        if (id >= POWER_LARGEST) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return NULL;\n        }\n\n#ifdef FUTURE\n        buf = item_cachedump(id, limit, &bytes);\n#endif\n        write_and_free(c, buf, bytes);\n        return NULL;\n    } else if (strcmp(subcommand, \"aggregate\") == 0) {\n        server_stats(&append_stats, c, true);\n    } else if (strcmp(subcommand, \"topkeys\") == 0) {\n        topkeys_t *tk = get_independent_stats(c)->topkeys;\n        if (tk != NULL) {\n            topkeys_stats(tk, c, current_time, append_stats);\n        } else {\n            out_string(c, \"ERROR\");\n            return NULL;\n        }\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            char *buf = NULL;\n            int nb = -1;\n            detokenize(&tokens[1], ntokens - 2, &buf, &nb);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, buf,\n                                                nb, append_stats);\n            free(buf);\n        }\n\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            append_stats(NULL, 0, NULL, 0, c);\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n            break;\n        case ENGINE_ENOMEM:\n            out_string(c, \"SERVER_ERROR out of memory writing stats\");\n            break;\n        case ENGINE_DISCONNECT:\n            c->state = conn_closing;\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return tokens[SUBCOMMAND_TOKEN].value;\n        default:\n            out_string(c, \"ERROR\");\n            break;\n        }\n\n        return NULL;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->dynamic_buffer.buffer == NULL) {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n    }\n\n    return NULL;\n}\n\n/**\n * Get a suffix buffer and insert it into the list of used suffix buffers\n * @param c the connection object\n * @return a pointer to a new suffix buffer or NULL if allocation failed\n */\nstatic char *get_suffix_buffer(conn *c) {\n    if (c->suffixleft == c->suffixsize) {\n        char **new_suffix_list;\n        size_t sz = sizeof(char*) * c->suffixsize * 2;\n\n        new_suffix_list = realloc(c->suffixlist, sz);\n        if (new_suffix_list) {\n            c->suffixsize *= 2;\n            c->suffixlist = new_suffix_list;\n        } else {\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"=%d Failed to resize suffix buffer\\n\", c->sfd);\n            }\n\n            return NULL;\n        }\n    }\n\n    char *suffix = cache_alloc(c->thread->suffix_cache);\n    if (suffix != NULL) {\n        *(c->suffixlist + c->suffixleft) = suffix;\n        ++c->suffixleft;\n    }\n\n    return suffix;\n}\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline char* process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = c->ileft;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n\n            ENGINE_ERROR_CODE ret = c->aiostat;\n            c->aiostat = ENGINE_SUCCESS;\n\n            if (ret == ENGINE_SUCCESS) {\n                ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey, 0);\n            }\n\n            switch (ret) {\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                c->ileft = i;\n                return key;\n\n            case ENGINE_SUCCESS:\n                break;\n            case ENGINE_KEY_ENOENT:\n            default:\n                it = NULL;\n                break;\n            }\n\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n\n            if (it) {\n                item_info info = { .nvalue = 1 };\n                if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it,\n                                                       &info)) {\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    out_string(c, \"SERVER_ERROR error getting item data\");\n                    break;\n                }\n\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        settings.engine.v1->release(settings.engine.v0, c, it);\n                        break;\n                    }\n                }\n\n                /* Rebuild the suffix */\n                char *suffix = get_suffix_buffer(c);\n                if (suffix == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory rebuilding suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                }\n                int suffix_len = snprintf(suffix, SUFFIX_SIZE,\n                                          \" %u %u\\r\\n\", htonl(info.flags),\n                                          info.nbytes);\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                MEMCACHED_COMMAND_GET(c->sfd, info.key, info.nkey,\n                                      info.nbytes, info.cas);\n                if (return_cas)\n                {\n\n                  char *cas = get_suffix_buffer(c);\n                  if (cas == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                  }\n                  int cas_len = snprintf(cas, SUFFIX_SIZE, \" %\"PRIu64\"\\r\\n\",\n                                         info.cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len - 2) != 0 ||\n                      add_iov(c, cas, cas_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n                else\n                {\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \">%d sending key %s\\n\",\n                                                    c->sfd, info.key);\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                STATS_HIT(c, get, key, nkey);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                STATS_MISS(c, get, key, nkey);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    c->suffixcurr = c->suffixlist;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d END\\n\", c->sfd);\n    }\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    return NULL;\n}\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, ENGINE_STORE_OPERATION store_op, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    time_t exptime;\n    int vlen;\n    uint64_t req_cas_id=0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */\n    exptime = exptime_int;\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    if (vlen < 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, htonl(flags), exptime);\n    }\n\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, req_cas_id);\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            out_string(c, \"SERVER_ERROR error getting item data\");\n            break;\n        }\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        c->store_op = store_op;\n        conn_set_state(c, conn_nread);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n        } else {\n            out_string(c, \"SERVER_ERROR out of memory storing object\");\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        c->sbytes = vlen + 2;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (store_op == OPERATION_SET) {\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey, 0, 0);\n        }\n    }\n}\n\nstatic char* process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    uint64_t cas;\n    uint64_t result;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0, c, key, nkey,\n                                             incr, false, delta, 0, 0, &cas,\n                                             &result, 0);\n    }\n\n    char temp[INCR_MAX_STORAGE_LEN];\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        snprintf(temp, sizeof(temp), \"%\"PRIu64, result);\n        out_string(c, temp);\n        break;\n    case ENGINE_KEY_ENOENT:\n        if (incr) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"SERVER_ERROR failed to store item\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    default:\n        abort();\n    }\n\n    return NULL;\n}\n\nstatic char *process_delete_command(conn *c, token_t *tokens,\n                                    const size_t ntokens) {\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, \"0\") == 0;\n        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);\n        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))\n            || (ntokens == 5 && hold_is_zero && sets_noreply);\n        if (!valid) {\n            out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                       \"Usage: delete <key> [noreply]\");\n            return NULL;\n        }\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->remove(settings.engine.v0, c,\n                                         key, nkey, 0, 0);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"DELETED\");\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    default:\n        out_string(c, \"NOT_FOUND\");\n        STATS_INCR(c, delete_misses, key, nkey);\n    }\n\n    if (ret != ENGINE_EWOULDBLOCK && settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n    return NULL;\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n    if (c->noreply && ntokens == 3) {\n        /* \"verbosity noreply\" is not according to the correct syntax */\n        c->noreply = false;\n        out_string(c, \"ERROR\");\n        return;\n    }\n\n    if (safe_strtoul(tokens[1].value, &level)) {\n        settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n        perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n        out_string(c, \"OK\");\n    } else {\n        out_string(c, \"ERROR\");\n    }\n}\n\nstatic char* process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n    char *ret = NULL;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"<%d %s\\n\", c->sfd, command);\n    }\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    if (c->ewouldblock) {\n        /*\n         * If we are retrying after the engine has completed a pending io for\n         * this command, skip add_msghdr() etc and clear the ewouldblock flag.\n         */\n        c->ewouldblock = false;\n    } else {\n        c->msgcurr = 0;\n        c->msgused = 0;\n        c->iovused = 0;\n        if (add_msghdr(c) != 0) {\n            out_string(c, \"SERVER_ERROR out of memory preparing response\");\n            return NULL;\n        }\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        ret = process_get_command(c, tokens, ntokens, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = (int)OPERATION_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = (int)OPERATION_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = (int)OPERATION_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = (int)OPERATION_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = (int)OPERATION_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = (int)OPERATION_CAS))) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        ret = process_get_command(c, tokens, ntokens, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        ret = process_delete_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        ret = process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime;\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        if (ntokens == (c->noreply ? 3 : 2)) {\n            exptime = 0;\n        } else {\n            exptime = strtol(tokens[1].value, NULL, 10);\n            if(errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n        }\n\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n        }\n\n        switch (ret) {\n        case  ENGINE_SUCCESS:\n            out_string(c, \"OK\");\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return c->rcurr + 9;\n        default:\n            out_string(c, \"SERVER_ERROR failed to flush cache\");\n        }\n\n        if (ret != ENGINE_EWOULDBLOCK) {\n            STATS_NOKEY(c, cmd_flush);\n        }\n        return NULL;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_closing);\n\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else if (settings.extensions.ascii != NULL) {\n        EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *cmd;\n        size_t nbytes = 0;\n        char *ptr;\n\n        if (ntokens > 0) {\n            if (ntokens == MAX_TOKENS) {\n                out_string(c, \"ERROR too many arguments\");\n                return NULL;\n            }\n\n            if (tokens[ntokens - 1].length == 0) {\n                --ntokens;\n            }\n        }\n\n        for (cmd = settings.extensions.ascii; cmd != NULL; cmd = cmd->next) {\n            if (cmd->accept(cmd->cookie, c, ntokens, tokens, &nbytes, &ptr)) {\n                break;\n            }\n        }\n\n        if (cmd == NULL) {\n            out_string(c, \"ERROR unknown command\");\n        } else if (nbytes == 0) {\n            switch (cmd->execute(cmd->cookie, c, ntokens, tokens,\n                                 ascii_response_handler)) {\n            case ENGINE_SUCCESS:\n                if (c->dynamic_buffer.buffer != NULL) {\n                    write_and_free(c, c->dynamic_buffer.buffer,\n                                   c->dynamic_buffer.offset);\n                    c->dynamic_buffer.buffer = NULL;\n                } else {\n                    conn_set_state(c, conn_new_cmd);\n                }\n                break;\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                ret = tokens[KEY_TOKEN].value;;\n                break;\n            case ENGINE_DISCONNECT:\n            default:\n                conn_set_state(c, conn_closing);\n\n            }\n        } else {\n            c->rlbytes = nbytes;\n            c->ritem = ptr;\n            c->ascii_cmd = cmd;\n            /* NOT SUPPORTED YET! */\n            conn_set_state(c, conn_nread);\n        }\n    } else {\n        out_string(c, \"ERROR\");\n    }\n    return ret;\n}\n\n/*\n * if we have a complete line in the buffer, process it.\n */\nstatic int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                    \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                             \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                char buffer[1024];\n                ssize_t nw;\n                nw = bytes_to_output_string(buffer, sizeof(buffer), c->sfd,\n                                            true, \"Read binary protocol data:\",\n                                            (const char*)req->bytes,\n                                            sizeof(req->bytes));\n                if (nw != -1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \"%s\", buffer);\n                }\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.vbucket = ntohs(req->request.vbucket);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ &&\n                !(c->binary_header.request.magic == PROTOCOL_BINARY_RES &&\n                  response_handlers[c->binary_header.request.opcode])) {\n                if (settings.verbose) {\n                    if (c->binary_header.request.magic != PROTOCOL_BINARY_RES) {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: Invalid magic:  %x\\n\", c->sfd,\n                              c->binary_header.request.magic);\n                    } else {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                              c->sfd, (unsigned int)c->binary_header.request.opcode);\n\n                    }\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont, *left, lb;\n\n        if (c->rbytes == 0) {\n            return 0;\n        }\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        lb = *el;\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        LIBEVENT_THREAD *thread = c->thread;\n        LOCK_THREAD(thread);\n        left = process_command(c, c->rcurr);\n        if (c->ewouldblock) {\n            unregister_event(c);\n        }\n        UNLOCK_THREAD(thread);\n\n        if (left != NULL) {\n            /*\n             * We have not processed the entire command. This happens\n             * when the engine returns ENGINE_EWOULDBLOCK for one of the\n             * keys in a get/gets request.\n             */\n            assert (left <= el);\n\n            int count = strlen(c->rcurr);\n            if ((c->rcurr + count) == left) {\n                // Retry the entire command\n                cont = c->rcurr;\n            } else {\n                left -= (count + 1);\n                cont = left;\n                assert(cont >= c->rcurr);\n                if (cont > c->rcurr) {\n                    memmove(cont, c->rcurr, count);\n                }\n            }\n\n            /* de-tokenize the command */\n            while ((left = memchr(left, '\\0', el - left)) != NULL) {\n                *left = ' ';\n            }\n            *el = lb;\n        }\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, (struct sockaddr *)&c->request_addr, &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        STATS_ADD(c, bytes_read, res);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes += res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n *\n * To protect us from someone flooding a connection with bogus data causing\n * the connection to eat up all available memory, break out and start looking\n * at the data I've got after a number of reallocs...\n *\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0) {\n                 settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                          \"Couldn't realloc input buffer\\n\");\n                }\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = recv(c->sfd, c->rbuf + c->rbytes, avail, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_read, res);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nbool register_event(conn *c, struct timeval *timeout) {\n    assert(!c->registered_in_libevent);\n\n    if (event_add(&c->event, timeout) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to add connection to libevent: %s\",\n                                        strerror(errno));\n        return false;\n    }\n\n    c->registered_in_libevent = true;\n\n    return true;\n}\n\nbool unregister_event(conn *c) {\n    assert(c->registered_in_libevent);\n\n    if (event_del(&c->event) == -1) {\n        return false;\n    }\n\n    c->registered_in_libevent = false;\n\n    return true;\n}\n\n\nbool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Updated event for %d to read=%s, write=%s\\n\",\n                                    c->sfd, (new_flags & EV_READ ? \"yes\" : \"no\"),\n                                    (new_flags & EV_WRITE ? \"yes\" : \"no\"));\n\n    if (!unregister_event(c)) {\n        return false;\n    }\n\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n\n    return register_event(c, NULL);\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_written, res);\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                            \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to write, and not due to blocking: %s\",\n                                            strerror(errno));\n        }\n\n        if (IS_UDP(c->transport))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}\n\nbool conn_listening(conn *c)\n{\n    int sfd;\n    struct sockaddr_storage addr;\n    socklen_t addrlen = sizeof(addr);\n\n    if ((sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen)) == -1) {\n        if (errno == EMFILE) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Too many open connections\\n\");\n            }\n            disable_listen();\n        } else if (errno != EAGAIN && errno != EWOULDBLOCK) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to accept new client: %s\\n\",\n                                            strerror(errno));\n        }\n\n        return false;\n    }\n\n    STATS_LOCK();\n    int curr_conns = ++stats.curr_conns;\n    STATS_UNLOCK();\n\n    if (curr_conns >= settings.maxconns) {\n        STATS_LOCK();\n        ++stats.rejected_conns;\n        STATS_UNLOCK();\n\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Too many open connections\\n\");\n        }\n\n        safe_close(sfd);\n        return false;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return false;\n    }\n\n    dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                      DATA_BUFFER_SIZE, tcp_transport);\n\n    return false;\n}\n\n/**\n * Ship tap log to the other end. This state differs with all other states\n * in the way that it support full duplex dialog. We're listening to both read\n * and write events from libevent most of the time. If a read event occurs we\n * switch to the conn_read state to read and execute the input message (that would\n * be an ack message from the other side). If a write event occurs we continue to\n * send tap log to the other end.\n * @param c the tap connection to drive\n * @return true if we should continue to process work for this connection, false\n *              if we should start processing events for other connections.\n */\nbool conn_ship_log(conn *c) {\n    bool cont = false;\n\n    if (c->sfd == INVALID_SOCKET) {\n        return false;\n    }\n\n    short mask = EV_READ | EV_PERSIST | EV_WRITE;\n\n    if (c->which & EV_READ || c->rbytes > 0) {\n        if (c->rbytes > 0) {\n            if (try_read_command(c) == 0) {\n                conn_set_state(c, conn_read);\n            }\n        } else {\n            conn_set_state(c, conn_read);\n        }\n\n        // we're going to process something.. let's proceed\n        cont = true;\n\n        // We have a finite number of messages in the input queue\n        // so let's process all of them instead of backing off after\n        // reading a subset of them.\n        // Why? Because we've got every time we're calling ship_tap_log\n        // we try to send a chunk of items.. This means that if we end\n        // up in a situation where we're receiving a burst of nack messages\n        // we'll only process a subset of messages in our input queue,\n        // and it will slowly grow..\n        c->nevents = settings.reqs_per_tap_event;\n    } else if (c->which & EV_WRITE) {\n        --c->nevents;\n        if (c->nevents >= 0) {\n            LOCK_THREAD(c->thread);\n            c->ewouldblock = false;\n            ship_tap_log(c);\n            if (c->ewouldblock) {\n                mask = EV_READ | EV_PERSIST;\n            } else {\n                cont = true;\n            }\n            UNLOCK_THREAD(c->thread);\n        }\n    }\n\n    if (!update_event(c, mask)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                            c, \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n    }\n\n    return cont;\n}\n\nbool conn_waiting(conn *c) {\n    if (!update_event(c, EV_READ | EV_PERSIST)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    conn_set_state(c, conn_read);\n    return false;\n}\n\nbool conn_read(conn *c) {\n    int res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);\n    switch (res) {\n    case READ_NO_DATA_RECEIVED:\n        conn_set_state(c, conn_waiting);\n        break;\n    case READ_DATA_RECEIVED:\n        conn_set_state(c, conn_parse_cmd);\n        break;\n    case READ_ERROR:\n        conn_set_state(c, conn_closing);\n        break;\n    case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n        /* State already set by try_read_network */\n        break;\n    }\n\n    return true;\n}\n\nbool conn_parse_cmd(conn *c) {\n    if (try_read_command(c) == 0) {\n        /* wee need more data! */\n        conn_set_state(c, conn_waiting);\n    }\n\n    return !c->ewouldblock;\n}\n\nbool conn_new_cmd(conn *c) {\n    /* Only process nreqs at a time to avoid starving other connections */\n    --c->nevents;\n    if (c->nevents >= 0) {\n        reset_cmd_handler(c);\n    } else {\n        STATS_NOKEY(c, conn_yields);\n        if (c->rbytes > 0) {\n            /* We have already read in data into the input buffer,\n               so libevent will most likely not signal read events\n               on the socket (unless more data is available. As a\n               hack we should just put in a request to write data,\n               because that should be possible ;-)\n            */\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                                    c, \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    return true;\n}\n\n\nbool conn_swallow(conn *c) {\n    ssize_t res;\n    /* we are reading sbytes and throwing them away */\n    if (c->sbytes == 0) {\n        conn_set_state(c, conn_new_cmd);\n        return true;\n    }\n\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n        c->sbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        return true;\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        c->sbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"Failed to read, and not due to blocking (%s)\\n\",\n                                        strerror(errno));\n    }\n\n    conn_set_state(c, conn_closing);\n\n    return true;\n\n}\n\nbool conn_nread(conn *c) {\n    ssize_t res;\n\n    if (c->rlbytes == 0) {\n        LIBEVENT_THREAD *t = c->thread;\n        LOCK_THREAD(t);\n        bool block = c->ewouldblock = false;\n        complete_nread(c);\n        UNLOCK_THREAD(t);\n        /* Breaking this into two, as complete_nread may have\n           moved us to a different thread */\n        t = c->thread;\n        LOCK_THREAD(t);\n        if (c->ewouldblock) {\n            unregister_event(c);\n            block = true;\n        }\n        UNLOCK_THREAD(t);\n        return !block;\n    }\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n        if (c->ritem != c->rcurr) {\n            memmove(c->ritem, c->rcurr, tocopy);\n        }\n        c->ritem += tocopy;\n        c->rlbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        if (c->rlbytes == 0) {\n            return true;\n        }\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->ritem, c->rlbytes, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        if (c->rcurr == c->ritem) {\n            c->rcurr += res;\n        }\n        c->ritem += res;\n        c->rlbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Failed to read, and not due to blocking:\\n\"\n                                        \"errno: %d %s \\n\"\n                                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                                        errno, strerror(errno),\n                                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                                        (int)c->rlbytes, (int)c->rsize);\n    }\n    conn_set_state(c, conn_closing);\n    return true;\n}\n\nbool conn_write(conn *c) {\n    /*\n     * We want to write out a simple response. If we haven't already,\n     * assemble it into a msgbuf list (this will be a single-entry\n     * list for TCP or a two-entry list for UDP).\n     */\n    if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {\n        if (add_iov(c, c->wcurr, c->wbytes) != 0) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't build response\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n    }\n\n    return conn_mwrite(c);\n}\n\nbool conn_mwrite(conn *c) {\n    if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Failed to build UDP headers\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n    switch (transmit(c)) {\n    case TRANSMIT_COMPLETE:\n        if (c->state == conn_mwrite) {\n            while (c->ileft > 0) {\n                item *it = *(c->icurr);\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                c->icurr++;\n                c->ileft--;\n            }\n            while (c->suffixleft > 0) {\n                char *suffix = *(c->suffixcurr);\n                cache_free(c->thread->suffix_cache, suffix);\n                c->suffixcurr++;\n                c->suffixleft--;\n            }\n            /* XXX:  I don't know why this wasn't the general case */\n            if(c->protocol == binary_prot) {\n                conn_set_state(c, c->write_and_go);\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n        } else if (c->state == conn_write) {\n            if (c->write_and_free) {\n                free(c->write_and_free);\n                c->write_and_free = 0;\n            }\n            conn_set_state(c, c->write_and_go);\n        } else {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Unexpected state %d\\n\", c->state);\n            }\n            conn_set_state(c, conn_closing);\n        }\n        break;\n\n    case TRANSMIT_INCOMPLETE:\n    case TRANSMIT_HARD_ERROR:\n        break;                   /* Continue in state machine. */\n\n    case TRANSMIT_SOFT_ERROR:\n        return false;\n    }\n\n    return true;\n}\n\nbool conn_pending_close(conn *c) {\n    assert(c->sfd == INVALID_SOCKET);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                    \"Awaiting clients to release the cookie (pending close for %p)\",\n                                    (void*)c);\n    LOCK_THREAD(c->thread);\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    if (!list_contains(c->thread->pending_close, c)) {\n        enlist_conn(c, &c->thread->pending_close);\n    }\n    UNLOCK_THREAD(c->thread);\n\n    /*\n     * tell the tap connection that we're disconnecting it now,\n     * but give it a grace period\n     */\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n\n    /*\n     * disconnect callback may have changed the state for the object\n     * so we might complete the disconnect now\n     */\n    return c->state != conn_pending_close;\n}\n\nbool conn_immediate_close(conn *c) {\n    settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                    \"Immediate close of %p\",\n                                    (void*)c);\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n    conn_close(c);\n\n    return false;\n}\n\nbool conn_closing(conn *c) {\n    if (IS_UDP(c->transport)) {\n        conn_cleanup(c);\n        return false;\n    }\n\n    // We don't want any network notifications anymore..\n    unregister_event(c);\n    safe_close(c->sfd);\n    c->sfd = INVALID_SOCKET;\n\n    if (c->refcount > 1) {\n        conn_set_state(c, conn_pending_close);\n    } else {\n        conn_set_state(c, conn_immediate_close);\n    }\n    return true;\n}\n\nbool conn_add_tap_client(conn *c) {\n    LIBEVENT_THREAD *tp = tap_thread;\n    LIBEVENT_THREAD *orig_thread = c->thread;\n\n    assert(orig_thread);\n    assert(orig_thread != tp);\n\n    c->ewouldblock = true;\n\n    unregister_event(c);\n\n    LOCK_THREAD(orig_thread);\n    /* Clean out the lists */\n    orig_thread->pending_io = list_remove(orig_thread->pending_io, c);\n    orig_thread->pending_close = list_remove(orig_thread->pending_close, c);\n\n    LOCK_THREAD(tp);\n    c->ev_flags = 0;\n    conn_set_state(c, conn_setup_tap_stream);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Moving %d conn from %p to %p\\n\",\n                                    c->sfd, c->thread, tp);\n    c->thread = tp;\n    c->event.ev_base = tp->base;\n    assert(c->next == NULL);\n    assert(c->list_state == 0);\n    enlist_conn(c, &tp->pending_io);\n\n    UNLOCK_THREAD(tp);\n\n    UNLOCK_THREAD(orig_thread);\n\n    notify_thread(tp);\n\n    return false;\n}\n\nbool conn_setup_tap_stream(conn *c) {\n    process_bin_tap_connect(c);\n    return true;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(c->event.ev_base);\n        return ;\n    }\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (c->sfd != INVALID_SOCKET) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        }\n        unregister_event(c);\n        if (c->sfd != INVALID_SOCKET && c->thread != NULL) {\n            conn_close(c);\n        }\n        return;\n    }\n\n    perform_callbacks(ON_SWITCH_CONN, c, c);\n\n    c->nevents = settings.reqs_per_event;\n    if (c->state == conn_ship_log) {\n        c->nevents = settings.reqs_per_tap_event;\n    }\n\n    LIBEVENT_THREAD *thr = c->thread;\n\n    // Do we have pending closes?\n    const size_t max_items = 256;\n    conn *pending_close[max_items];\n    size_t n_pending_close = 0;\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        if (thr->pending_close && thr->last_checked != current_time) {\n            assert(!has_cycle(thr->pending_close));\n            thr->last_checked = current_time;\n\n            n_pending_close = list_to_array(pending_close, max_items,\n                                            &thr->pending_close);\n        }\n        UNLOCK_THREAD(thr);\n    }\n\n    if (settings.verbose) {\n        do {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%d - Running task: (%s)\\n\",\n                                            c->sfd, state_text(c->state));\n        } while (c->state(c));\n    } else {\n        while (c->state(c)) {\n            /* empty */\n        }\n    }\n\n    /* Close any connections pending close */\n    if (n_pending_close > 0) {\n        for (size_t i = 0; i < n_pending_close; ++i) {\n            conn *ce = pending_close[i];\n            if (ce->refcount == 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                                \"OK, time to nuke: %p\\n\",\n                                                (void*)ce);\n                conn_close(ce);\n                pending_close[i] = NULL;\n            } else {\n                LOCK_THREAD(ce->thread);\n                enlist_conn(ce, &ce->thread->pending_close);\n                UNLOCK_THREAD(ce->thread);\n            }\n        }\n    }\n\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        finalize_list(pending_close, n_pending_close);\n        UNLOCK_THREAD(thr);\n    }\n}\n\nstatic void dispatch_event_handler(int fd, short which, void *arg) {\n    char buffer[80];\n    ssize_t nr = recv(fd, buffer, sizeof(buffer), 0);\n\n    (void)(which);\n    (void)(arg);\n    if (nr != -1 && is_listen_disabled()) {\n        bool enable = false;\n        pthread_mutex_lock(&listen_state.mutex);\n        listen_state.count -= nr;\n        if (listen_state.count <= 0) {\n            enable = true;\n            listen_state.disabled = false;\n        }\n        pthread_mutex_unlock(&listen_state.mutex);\n        if (enable) {\n            conn *next;\n            for (next = listen_conn; next; next = next->next) {\n                update_event(next, EV_READ | EV_PERSIST);\n                if (listen(next->sfd, settings.backlog) != 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"listen() failed\",\n                                                    strerror(errno));\n                }\n            }\n        }\n    }\n}\n\n\n\nstatic SOCKET new_socket(struct addrinfo *ai) {\n    SOCKET sfd;\n\n    sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n    if (sfd == INVALID_SOCKET) {\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&old_size, &intsize) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"getsockopt(SO_SNDBUF): %s\",\n                                            strerror(errno));\n        }\n\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                 \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n    }\n}\n\n\n\n/**\n * Create a socket and bind it to a specific port number\n * @param interface the interface to bind to\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(const char *interface,\n                         int port,\n                         enum network_transport transport,\n                         FILE *portnumber_file) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(interface, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", strerror(error));\n        }\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == INVALID_SOCKET) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(IPV6_V6ONLY): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_KEEPALIVE): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_LINGER): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(TCP_NODELAY): %s\",\n                                                strerror(errno));\n            }\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == SOCKET_ERROR) {\n            if (errno != EADDRINUSE) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"bind(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            safe_close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == SOCKET_ERROR) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"listen(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads_per_udp; c++) {\n                /* this is guaranteed to hit all threads because we round-robin */\n                dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport);\n                STATS_LOCK();\n                ++stats.curr_conns;\n                ++stats.daemon_conns;\n                STATS_UNLOCK();\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base, NULL))) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n            STATS_LOCK();\n            ++stats.curr_conns;\n            ++stats.daemon_conns;\n            STATS_UNLOCK();\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int server_sockets(int port, enum network_transport transport,\n                          FILE *portnumber_file) {\n    if (settings.inter == NULL) {\n        return server_socket(settings.inter, port, transport, portnumber_file);\n    } else {\n        // tokenize them and bind to each one of them..\n        char *b;\n        int ret = 0;\n        char *list = strdup(settings.inter);\n\n        if (list == NULL) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to allocate memory for parsing server interface string\\n\");\n            return 1;\n        }\n        for (char *p = strtok_r(list, \";,\", &b);\n             p != NULL;\n             p = strtok_r(NULL, \";,\", &b)) {\n            int the_port = port;\n\n            char *s = strchr(p, ':');\n            if (s != NULL) {\n                *s = '\\0';\n                ++s;\n                if (!safe_strtol(s, &the_port)) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Invalid port number: \\\"%s\\\"\", s);\n                    return 1;\n                }\n            }\n            if (strcmp(p, \"*\") == 0) {\n                p = NULL;\n            }\n            ret |= server_socket(p, the_port, transport, portnumber_file);\n        }\n        free(list);\n        return ret;\n    }\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"socket(AF_UNIX, SOCK_STREAM, 0): %s\",\n                                        strerror(errno));\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n    return sfd;\n}\n\n/* this will probably not work on windows */\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some impementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"bind(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"listen(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base, NULL))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    STATS_LOCK();\n    ++stats.daemon_conns;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\nstatic struct event clockevent;\n\n/* time-sensitive callers can call it by hand with this, outside the normal ever-1-second timer */\nstatic void set_current_time(void) {\n    struct timeval timer;\n\n    gettimeofday(&timer, NULL);\n    current_time = (rel_time_t) (timer.tv_sec - process_started);\n}\n\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    (void)(fd);\n    (void)(which);\n    (void)(arg);\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(main_base);\n        return ;\n    }\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n    set_current_time();\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p <num>      TCP port number to listen on (default: 11211)\\n\"\n           \"-U <num>      UDP port number to listen on (default: 11211, 0 is off)\\n\"\n           \"-s <file>     UNIX socket path to listen on (disables network support)\\n\"\n           \"-a <mask>     access mask for UNIX socket, in octal (default: 0700)\\n\"\n           \"-l <addr>     interface to listen on (default: INADDR_ANY, all addresses)\\n\"\n           \"              <addr> may be specified as host:port. If you don't specify\\n\"\n           \"              a port number, the value you specified with -p or -U is\\n\"\n           \"              used. You may specify multiple addresses separated by comma\\n\"\n           \"              or by using -l multiple times\\n\"\n           \"-d            run as a daemon\\n\"\n           \"-r            maximize core file limit\\n\"\n           \"-u <username> assume identity of <username> (only when run as root)\\n\"\n           \"-m <num>      max memory to use for items in megabytes (default: 64 MB)\\n\"\n           \"-M            return error on memory exhausted (rather than removing items)\\n\"\n           \"-c <num>      max simultaneous connections (default: 1000)\\n\"\n           \"-k            lock down all paged memory.  Note that there is a\\n\"\n           \"              limit on how much memory you may lock.  Trying to\\n\"\n           \"              allocate more than that would fail, so be sure you\\n\"\n           \"              set the limit correctly for the user you started\\n\"\n           \"              the daemon with (not for -u <username> user;\\n\"\n           \"              under sh this is done with 'ulimit -S -l NUM_KB').\\n\"\n           \"-v            verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv           very verbose (also print client commands/reponses)\\n\"\n           \"-vvv          extremely verbose (also print internal state transitions)\\n\"\n           \"-h            print this help and exit\\n\"\n           \"-i            print memcached and libevent license\\n\"\n           \"-P <file>     save PID in <file>, only used with -d option\\n\"\n           \"-f <factor>   chunk size growth factor (default: 1.25)\\n\"\n           \"-n <bytes>    minimum space allocated for key+value+flags (default: 48)\\n\");\n    printf(\"-L            Try to use large memory pages (if available). Increasing\\n\"\n           \"              the memory page size could reduce the number of TLB misses\\n\"\n           \"              and improve the performance. In order to get large pages\\n\"\n           \"              from the OS, memcached will allocate the total item-cache\\n\"\n           \"              in one large chunk.\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\":\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\");\n    printf(\"-t <num>      number of threads to use (default: 4)\\n\");\n    printf(\"-R            Maximum number of requests per event, limits the number of\\n\"\n           \"              requests process for a given connection to prevent \\n\"\n           \"              starvation (default: 20)\\n\");\n    printf(\"-C            Disable use of CAS\\n\");\n    printf(\"-b            Set the backlog queue limit (default: 1024)\\n\");\n    printf(\"-B            Binding protocol - one of ascii, binary, or auto (default)\\n\");\n    printf(\"-I            Override the size of each slab page. Adjusts max item size\\n\"\n           \"              (default: 1mb, min: 1k, max: 128m)\\n\");\n    printf(\"-q            Disable detailed stats commands\\n\");\n#ifdef SASL_ENABLED\n    printf(\"-S            Require SASL authentication\\n\");\n#endif\n    printf(\"-X module,cfg Load the module and initialize it with the config\\n\");\n    printf(\"-E engine     Load engine as the storage engine\\n\");\n    printf(\"-e config     Pass config as configuration options to the storage engine\\n\");\n    printf(\"\\nEnvironment variables:\\n\"\n           \"MEMCACHED_PORT_FILENAME   File to write port information to\\n\"\n           \"MEMCACHED_TOP_KEYS        Number of top keys to keep track of\\n\"\n           \"MEMCACHED_REQS_TAP_EVENT  Similar to -R but for tap_ship_log\\n\");\n}\n\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const char *pid_file) {\n    FILE *fp;\n\n    if (access(pid_file, F_OK) == 0) {\n        if ((fp = fopen(pid_file, \"r\")) != NULL) {\n            char buffer[1024];\n            if (fgets(buffer, sizeof(buffer), fp) != NULL) {\n                unsigned int pid;\n                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                               \"WARNING: The pid file contained the following (running) pid: %u\\n\", pid);\n                }\n            }\n            fclose(fp);\n        }\n    }\n\n    if ((fp = fopen(pid_file, \"w\")) == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Could not open the pid file %s for writing: %s\\n\",\n                 pid_file, strerror(errno));\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)getpid());\n    if (fclose(fp) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not close the pid file %s: %s\\n\",\n                pid_file, strerror(errno));\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n    if (pid_file != NULL) {\n        if (unlink(pid_file) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Could not remove the pid file %s: %s\\n\",\n                    pid_file, strerror(errno));\n        }\n    }\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif /* !HAVE_SIGIGNORE */\n\nstatic void sigterm_handler(int sig) {\n    assert(sig == SIGTERM || sig == SIGINT);\n    memcached_shutdown = 1;\n}\n\nstatic int install_sigterm_handler(void) {\n    struct sigaction sa = {.sa_handler = sigterm_handler, .sa_flags = 0};\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(SIGTERM, &sa, 0) == -1 ||\n        sigaction(SIGINT, &sa, 0) == -1) {\n        return -1;\n    }\n\n    return 0;\n}\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                  \"Failed to set large pages: %s\\nWill use default page size\\n\",\n                  strerror(errno));\n        } else {\n            ret = 0;\n        }\n    } else {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n          \"Failed to get supported pagesizes: %s\\nWill use default page size\\n\",\n          strerror(errno));\n    }\n\n    return ret;\n#else\n    return 0;\n#endif\n}\n\nstatic const char* get_server_version(void) {\n    return VERSION;\n}\n\nstatic void store_engine_specific(const void *cookie,\n                                  void *engine_data) {\n    conn *c = (conn*)cookie;\n    c->engine_storage = engine_data;\n}\n\nstatic void *get_engine_specific(const void *cookie) {\n    conn *c = (conn*)cookie;\n    return c->engine_storage;\n}\n\nstatic int get_socket_fd(const void *cookie) {\n    conn *c = (conn *)cookie;\n    return c->sfd;\n}\n\nstatic ENGINE_ERROR_CODE reserve_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    ++c->refcount;\n    return ENGINE_SUCCESS;\n}\n\nstatic ENGINE_ERROR_CODE release_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    --c->refcount;\n    return ENGINE_SUCCESS;\n}\n\nstatic int num_independent_stats(void) {\n    return settings.num_threads + 1;\n}\n\nstatic void *new_independent_stats(void) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = calloc(sizeof(independent_stats) + sizeof(struct thread_stats) * nrecords, 1);\n    if (settings.topkeys > 0)\n        independent_stats->topkeys = topkeys_init(settings.topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_init(&independent_stats->thread_stats[ii].mutex, NULL);\n    return independent_stats;\n}\n\nstatic void release_independent_stats(void *stats) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = stats;\n    if (independent_stats->topkeys)\n        topkeys_free(independent_stats->topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_destroy(&independent_stats->thread_stats[ii].mutex);\n    free(independent_stats);\n}\n\nstatic inline struct independent_stats *get_independent_stats(conn *c) {\n    struct independent_stats *independent_stats;\n    if (settings.engine.v1->get_stats_struct != NULL) {\n        independent_stats = settings.engine.v1->get_stats_struct(settings.engine.v0, (const void *)c);\n        if (independent_stats == NULL)\n            independent_stats = default_independent_stats;\n    } else {\n        independent_stats = default_independent_stats;\n    }\n    return independent_stats;\n}\n\nstatic inline struct thread_stats *get_thread_stats(conn *c) {\n    struct independent_stats *independent_stats = get_independent_stats(c);\n    assert(c->thread->index < num_independent_stats());\n    return &independent_stats->thread_stats[c->thread->index];\n}\n\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data) {\n    struct engine_event_handler *h =\n        calloc(sizeof(struct engine_event_handler), 1);\n\n    assert(h);\n    h->cb = cb;\n    h->cb_data = cb_data;\n    h->next = engine_event_handlers[type];\n    engine_event_handlers[type] = h;\n    (void)(eh); /* unused */\n}\n\nstatic rel_time_t get_current_time(void)\n{\n    return current_time;\n}\n\nstatic void count_eviction(const void *cookie, const void *key, const int nkey) {\n    topkeys_t *tk = get_independent_stats((conn*)cookie)->topkeys;\n    TK(tk, evictions, key, nkey, get_current_time());\n}\n\n/**\n * To make it easy for engine implementors that doesn't want to care about\n * writing their own incr/decr code, they can just set the arithmetic function\n * to NULL and use this implementation. It is not efficient, due to the fact\n * that it does multiple calls through the interface (get and then cas store).\n * If you don't care, feel free to use it..\n */\nstatic ENGINE_ERROR_CODE internal_arithmetic(ENGINE_HANDLE* handle,\n                                             const void* cookie,\n                                             const void* key,\n                                             const int nkey,\n                                             const bool increment,\n                                             const bool create,\n                                             const uint64_t delta,\n                                             const uint64_t initial,\n                                             const rel_time_t exptime,\n                                             uint64_t *cas,\n                                             uint64_t *result,\n                                             uint16_t vbucket)\n{\n    ENGINE_HANDLE_V1 *e = (ENGINE_HANDLE_V1*)handle;\n\n    item *it = NULL;\n\n    ENGINE_ERROR_CODE ret;\n    ret = e->get(handle, cookie, &it, key, nkey, vbucket);\n\n    if (ret == ENGINE_SUCCESS) {\n        item_info info = { .nvalue = 1 };\n\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        char value[80];\n\n        if (info.value[0].iov_len > (sizeof(value) - 1)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        memcpy(value, info.value[0].iov_base, info.value[0].iov_len);\n        value[info.value[0].iov_len] = '\\0';\n\n        uint64_t val;\n        if (!safe_strtoull(value, &val)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        if (increment) {\n            val += delta;\n        } else {\n            if (delta > val) {\n                val = 0;\n            } else {\n                val -= delta;\n            }\n        }\n\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64, val);\n        *result = val;\n        item *nit = NULL;\n        if (e->allocate(handle, cookie, &nit, key,\n                        nkey, nb, info.flags, info.exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info i2 = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, nit, &i2)) {\n            e->release(handle, cookie, it);\n            e->release(handle, cookie, nit);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(i2.value[0].iov_base, value, nb);\n        e->item_set_cas(handle, cookie, nit, info.cas);\n        ret = e->store(handle, cookie, nit, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n        e->release(handle, cookie, nit);\n    } else if (ret == ENGINE_KEY_ENOENT && create) {\n        char value[80];\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64\"\\r\\n\", initial);\n        *result = initial;\n        if (e->allocate(handle, cookie, &it, key, nkey, nb, 0, exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info info = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(info.value[0].iov_base, value, nb);\n        ret = e->store(handle, cookie, it, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n    }\n\n    /* We had a race condition.. just call ourself recursively to retry */\n    if (ret == ENGINE_KEY_EEXISTS) {\n        return internal_arithmetic(handle, cookie, key, nkey, increment, create, delta,\n                                   initial, exptime, cas, result, vbucket);\n    }\n\n    return ret;\n}\n\n/**\n * Register an extension if it's not already registered\n *\n * @param type the type of the extension to register\n * @param extension the extension to register\n * @return true if success, false otherwise\n */\nstatic bool register_extension(extension_type_t type, void *extension)\n{\n    if (extension == NULL) {\n        return false;\n    }\n\n    switch (type) {\n    case EXTENSION_DAEMON:\n        for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n             ptr != NULL;\n             ptr = ptr->next) {\n            if (ptr == extension) {\n                return false;\n            }\n        }\n        ((EXTENSION_DAEMON_DESCRIPTOR *)(extension))->next = settings.extensions.daemons;\n        settings.extensions.daemons = extension;\n        return true;\n    case EXTENSION_LOGGER:\n        settings.extensions.logger = extension;\n        return true;\n    case EXTENSION_ASCII_PROTOCOL:\n        if (settings.extensions.ascii != NULL) {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *last;\n            for (last = settings.extensions.ascii; last->next != NULL;\n                 last = last->next) {\n                if (last == extension) {\n                    return false;\n                }\n            }\n            if (last == extension) {\n                return false;\n            }\n            last->next = extension;\n            last->next->next = NULL;\n        } else {\n            settings.extensions.ascii = extension;\n            settings.extensions.ascii->next = NULL;\n        }\n        return true;\n\n    case EXTENSION_BINARY_PROTOCOL:\n        if (settings.extensions.binary != NULL) {\n            EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *last;\n            for (last = settings.extensions.binary; last->next != NULL;\n                 last = last->next) {\n                if (last == extension) {\n                    return false;\n                }\n            }\n            if (last == extension) {\n                return false;\n            }\n            last->next = extension;\n            last->next->next = NULL;\n        } else {\n            settings.extensions.binary = extension;\n            settings.extensions.binary->next = NULL;\n        }\n\n        ((EXTENSION_BINARY_PROTOCOL_DESCRIPTOR*)extension)->setup(setup_binary_lookup_cmd);\n        return true;\n\n    default:\n        return false;\n    }\n}\n\n/**\n * Unregister an extension\n *\n * @param type the type of the extension to remove\n * @param extension the extension to remove\n */\nstatic void unregister_extension(extension_type_t type, void *extension)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        {\n            EXTENSION_DAEMON_DESCRIPTOR *prev = NULL;\n            EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.daemons == ptr) {\n                settings.extensions.daemons = ptr->next;\n            }\n        }\n        break;\n    case EXTENSION_LOGGER:\n        if (settings.extensions.logger == extension) {\n            if (get_stderr_logger() == extension) {\n                settings.extensions.logger = get_null_logger();\n            } else {\n                settings.extensions.logger = get_stderr_logger();\n            }\n        }\n        break;\n    case EXTENSION_ASCII_PROTOCOL:\n        {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *prev = NULL;\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.ascii == ptr) {\n                settings.extensions.ascii = ptr->next;\n            }\n        }\n        break;\n\n\n    case EXTENSION_BINARY_PROTOCOL:\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"You can't unregister a binary command handler!\");\n        abort();\n        break;\n\n    default:\n        ;\n    }\n\n}\n\n/**\n * Get the named extension\n */\nstatic void* get_extension(extension_type_t type)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        return settings.extensions.daemons;\n\n    case EXTENSION_LOGGER:\n        return settings.extensions.logger;\n\n    case EXTENSION_ASCII_PROTOCOL:\n        return settings.extensions.ascii;\n\n    case EXTENSION_BINARY_PROTOCOL:\n        return settings.extensions.binary;\n\n    default:\n        return NULL;\n    }\n}\n\nstatic void shutdown_server(void) {\n    memcached_shutdown = 1;\n}\n\nstatic EXTENSION_LOGGER_DESCRIPTOR* get_logger(void)\n{\n    return settings.extensions.logger;\n}\n\nstatic EXTENSION_LOG_LEVEL get_log_level(void)\n{\n    EXTENSION_LOG_LEVEL ret;\n    switch (settings.verbose) {\n    case 0: ret = EXTENSION_LOG_WARNING; break;\n    case 1: ret = EXTENSION_LOG_INFO; break;\n    case 2: ret = EXTENSION_LOG_DEBUG; break;\n    default:\n        ret = EXTENSION_LOG_DETAIL;\n    }\n    return ret;\n}\n\nstatic void set_log_level(EXTENSION_LOG_LEVEL severity)\n{\n    switch (severity) {\n    case EXTENSION_LOG_WARNING: settings.verbose = 0; break;\n    case EXTENSION_LOG_INFO: settings.verbose = 1; break;\n    case EXTENSION_LOG_DEBUG: settings.verbose = 2; break;\n    default:\n        settings.verbose = 3;\n    }\n}\n\nstatic void get_config_append_stats(const char *key, const uint16_t klen,\n                                    const char *val, const uint32_t vlen,\n                                    const void *cookie)\n{\n    if (klen == 0  || vlen == 0) {\n        return ;\n    }\n\n    char *pos = (char*)cookie;\n    size_t nbytes = strlen(pos);\n\n    if ((nbytes + klen + vlen + 3) > 1024) {\n        // Not enough size in the buffer..\n        return;\n    }\n\n    memcpy(pos + nbytes, key, klen);\n    nbytes += klen;\n    pos[nbytes] = '=';\n    ++nbytes;\n    memcpy(pos + nbytes, val, vlen);\n    nbytes += vlen;\n    memcpy(pos + nbytes, \";\", 2);\n}\n\nstatic bool get_config(struct config_item items[]) {\n    char config[1024];\n    config[0] = '\\0';\n    process_stat_settings(get_config_append_stats, config);\n    int rval = parse_config(config, items, NULL);\n    return rval >= 0;\n}\n\n/**\n * Callback the engines may call to get the public server interface\n * @return pointer to a structure containing the interface. The client should\n *         know the layout and perform the proper casts.\n */\nstatic SERVER_HANDLE_V1 *get_server_api(void)\n{\n    static SERVER_CORE_API core_api = {\n        .server_version = get_server_version,\n        .hash = hash,\n        .realtime = realtime,\n        .abstime = abstime,\n        .get_current_time = get_current_time,\n        .parse_config = parse_config,\n        .shutdown = shutdown_server,\n        .get_config = get_config\n    };\n\n    static SERVER_COOKIE_API server_cookie_api = {\n        .get_auth_data = get_auth_data,\n        .store_engine_specific = store_engine_specific,\n        .get_engine_specific = get_engine_specific,\n        .get_socket_fd = get_socket_fd,\n        .notify_io_complete = notify_io_complete,\n        .reserve = reserve_cookie,\n        .release = release_cookie\n    };\n\n    static SERVER_STAT_API server_stat_api = {\n        .new_stats = new_independent_stats,\n        .release_stats = release_independent_stats,\n        .evicting = count_eviction\n    };\n\n    static SERVER_LOG_API server_log_api = {\n        .get_logger = get_logger,\n        .get_level = get_log_level,\n        .set_level = set_log_level\n    };\n\n    static SERVER_EXTENSION_API extension_api = {\n        .register_extension = register_extension,\n        .unregister_extension = unregister_extension,\n        .get_extension = get_extension\n    };\n\n    static SERVER_CALLBACK_API callback_api = {\n        .register_callback = register_callback,\n        .perform_callbacks = perform_callbacks,\n    };\n\n    static SERVER_HANDLE_V1 rv = {\n        .interface = 1,\n        .core = &core_api,\n        .stat = &server_stat_api,\n        .extension = &extension_api,\n        .callback = &callback_api,\n        .log = &server_log_api,\n        .cookie = &server_cookie_api\n    };\n\n    if (rv.engine == NULL) {\n        rv.engine = settings.engine.v0;\n    }\n\n    return &rv;\n}\n\n/**\n * Load a shared object and initialize all the extensions in there.\n *\n * @param soname the name of the shared object (may not be NULL)\n * @param config optional configuration parameters\n * @return true if success, false otherwise\n */\nstatic bool load_extension(const char *soname, const char *config) {\n    if (soname == NULL) {\n        return false;\n    }\n\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        MEMCACHED_EXTENSIONS_INITIALIZE initialize;\n        void* voidptr;\n    } funky = {.initialize = NULL };\n\n    void *handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"memcached_extensions_initialize\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"memcached_extensions_initialize\\\" in %s: %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n    funky.voidptr = symbol;\n\n    EXTENSION_ERROR_CODE error = (*funky.initialize)(config, get_server_api);\n\n    if (error != EXTENSION_SUCCESS) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initalize extensions from %s. Error code: %d\\n\",\n                soname, error);\n        dlclose(handle);\n        return false;\n    }\n\n    if (settings.verbose > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                \"Loaded extensions from: %s\\n\", soname);\n    }\n\n    return true;\n}\n\n/**\n * Do basic sanity check of the runtime environment\n * @return true if no errors found, false if we can't use this env\n */\nstatic bool sanitycheck(void) {\n    /* One of our biggest problems is old and bogus libevents */\n    const char *ever = event_get_version();\n    if (ever != NULL) {\n        if (strncmp(ever, \"1.\", 2) == 0) {\n            /* Require at least 1.3 (that's still a couple of years old) */\n            if ((ever[2] == '1' || ever[2] == '2') && !isdigit(ever[3])) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"You are using libevent %s.\\nPlease upgrade to\"\n                        \" a more recent version (1.3 or newer)\\n\",\n                        event_get_version());\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main (int argc, char **argv) {\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char unit = '\\0';\n    int size_max = 0;\n\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n\n    const char *engine = \"default_engine.so\";\n    const char *engine_config = NULL;\n    char old_options[1024] = { [0] = '\\0' };\n    char *old_opts = old_options;\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - 2;\n    set_current_time();\n\n    /* Initialize the socket subsystem */\n    initialize_sockets();\n\n    /* init settings */\n    settings_init();\n\n    initialize_binary_lookup_map();\n\n    if (memcached_initialize_stderr_logger(get_server_api) != EXTENSION_SUCCESS) {\n        fprintf(stderr, \"Failed to initialize log system\\n\");\n        return EX_OSERR;\n    }\n\n    if (!sanitycheck()) {\n        return EX_OSERR;\n    }\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  /* access mask for unix socket */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hi\"  /* help, licence info */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n          \"E:\"  /* Engine to load */\n          \"e:\"  /* Engine options */\n          \"q\"   /* Disallow detailed stats */\n          \"X:\"  /* Load extension */\n        ))) {\n        switch (c) {\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n             old_opts += sprintf(old_opts, \"cache_size=%lu;\",\n                                 (unsigned long)settings.maxbytes);\n           break;\n        case 'M':\n            settings.evict_to_free = 0;\n            old_opts += sprintf(old_opts, \"eviction=false;\");\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                      \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n             old_opts += sprintf(old_opts, \"factor=%f;\",\n                                 settings.factor);\n           break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            old_opts += sprintf(old_opts, \"chunk_size=%u;\",\n                                settings.chunk_size);\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"WARNING: Setting a high number of worker\"\n                        \"threads is not recommended.\\n\"\n                        \" Set this value to the number of cores in\"\n                        \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                old_opts += sprintf(old_opts, \"preallocate=true;\");\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            unit = optarg[strlen(optarg)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                optarg[strlen(optarg)-1] = '\\0';\n                size_max = atoi(optarg);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(optarg);\n            }\n            if (settings.item_size_max < 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n#ifndef __WIN32__\n            old_opts += sprintf(old_opts, \"item_size_max=%zu;\",\n                                settings.item_size_max);\n#else\n            old_opts += sprintf(old_opts, \"item_size_max=%lu;\", (long unsigned)\n                                settings.item_size_max);\n#endif\n            break;\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_config = optarg;\n            break;\n        case 'q':\n            settings.allow_detailed = false;\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef SASL_ENABLED\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#else\n            settings.require_sasl = true;\n#endif\n            break;\n        case 'X' :\n            {\n                char *ptr = strchr(optarg, ',');\n                if (ptr != NULL) {\n                    *ptr = '\\0';\n                    ++ptr;\n                }\n                if (!load_extension(optarg, ptr)) {\n                    exit(EXIT_FAILURE);\n                }\n                if (ptr != NULL) {\n                    *(ptr - 1) = ',';\n                }\n            }\n            break;\n        default:\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    /*\n     * Use one workerthread to serve each UDP port if the user specified\n     * multiple ports\n     */\n    if (settings.inter != NULL && strchr(settings.inter, ',')) {\n        settings.num_threads_per_udp = 1;\n    } else {\n        settings.num_threads_per_udp = settings.num_threads;\n    }\n\n    if (getenv(\"MEMCACHED_REQS_TAP_EVENT\") != NULL) {\n        settings.reqs_per_tap_event = atoi(getenv(\"MEMCACHED_REQS_TAP_EVENT\"));\n    }\n\n    if (settings.reqs_per_tap_event <= 0) {\n        settings.reqs_per_tap_event = DEFAULT_REQS_PER_TAP_EVENT;\n    }\n\n\n    if (install_sigterm_handler() != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"Failed to install SIGTERM handler\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    char *topkeys_env = getenv(\"MEMCACHED_TOP_KEYS\");\n    if (topkeys_env != NULL) {\n        settings.topkeys = atoi(topkeys_env);\n        if (settings.topkeys < 0) {\n            settings.topkeys = 0;\n        }\n    }\n\n    if (settings.require_sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol == negotiating_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use auto-negotiating protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n            if (settings.binding_protocol == ascii_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use only ASCII protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (tcp_specified && !udp_specified) {\n        settings.udpport = settings.port;\n    } else if (udp_specified && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n    if (engine_config != NULL && strlen(old_options) > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"ERROR: You can't mix -e with the old options\\n\");\n        return EX_USAGE;\n    } else if (engine_config == NULL && strlen(old_options) > 0) {\n        engine_config = old_options;\n    }\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        unsigned int maxfiles = settings.maxconns + (3 * (settings.num_threads + 2));\n        int syslimit = rlim.rlim_cur;\n        if (rlim.rlim_cur < maxfiles) {\n            rlim.rlim_cur = maxfiles;\n        }\n        if (rlim.rlim_max < rlim.rlim_cur) {\n            rlim.rlim_max = rlim.rlim_cur;\n        }\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            const char *fmt;\n            fmt = \"WARNING: maxconns cannot be set to (%d) connections due to \"\n                \"system\\nresouce restrictions. Increase the number of file \"\n                \"descriptors allowed\\nto the memcached user process or start \"\n                \"memcached as root (remember\\nto use the -u parameter).\\n\"\n                \"The maximum number of connections is set to %d.\\n\";\n            int req = settings.maxconns;\n            settings.maxconns = syslimit - (3 * (settings.num_threads + 2));\n            if (settings.maxconns < 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                         \"failed to set rlimit for open files. Try starting as\"\n                         \" root or requesting smaller maxconns value.\\n\");\n                exit(EX_OSERR);\n            }\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            fmt, req, settings.maxconns);\n        }\n    }\n\n    /* Sanity check for the connection structures */\n    int nfiles = 0;\n    if (settings.port != 0) {\n        nfiles += 2;\n    }\n    if (settings.udpport != 0) {\n        nfiles += settings.num_threads * 2;\n    }\n\n    if (settings.maxconns <= nfiles) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Configuratioin error. \\n\"\n                \"You specified %d connections, but the system will use at \"\n                \"least %d\\nconnection structures to start.\\n\",\n                settings.maxconns, nfiles);\n        exit(EX_USAGE);\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to assume identity of user %s: %s\\n\", username,\n                    strerror(errno));\n            exit(EX_OSERR);\n        }\n    }\n\n#ifdef SASL_ENABLED\n    init_sasl();\n#endif /* SASL */\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to ignore SIGHUP: \", strerror(errno));\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n             settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n    main_base = event_init();\n\n    /* Load the storage engine */\n    ENGINE_HANDLE *engine_handle = NULL;\n    if (!load_engine(engine,get_server_api,settings.extensions.logger,&engine_handle)) {\n        /* Error already reported */\n        exit(EXIT_FAILURE);\n    }\n\n    if (!init_engine(engine_handle,engine_config,settings.extensions.logger)) {\n        return false;\n    }\n\n    if (settings.verbose > 0) {\n        log_engine_details(engine_handle,settings.extensions.logger);\n    }\n    settings.engine.v1 = (ENGINE_HANDLE_V1 *) engine_handle;\n\n    if (settings.engine.v1->arithmetic == NULL) {\n        settings.engine.v1->arithmetic = internal_arithmetic;\n    }\n\n    /* initialize other stuff */\n    stats_init();\n\n    if (!(conn_cache = cache_create(\"conn\", sizeof(conn), sizeof(void*),\n                                    conn_constructor, conn_destructor))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create connection cache\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    default_independent_stats = new_independent_stats();\n\n#ifndef __WIN32__\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n#endif\n\n    /* start up worker threads if MT mode */\n    thread_init(settings.num_threads, main_base, dispatch_event_handler);\n\n    /* initialise clock event */\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"failed to listen on UNIX socket \\\"%s\\\": %s\",\n                                            settings.socketpath, strerror(errno));\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        int udp_port;\n\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char temp_portnumber_filename[PATH_MAX];\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            snprintf(temp_portnumber_filename,\n                     sizeof(temp_portnumber_filename),\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                            portnumber_file)) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"failed to listen on TCP port %d: %s\",\n                                            settings.port, strerror(errno));\n            exit(EX_OSERR);\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonise if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n        udp_port = settings.udpport ? settings.udpport : settings.port;\n\n        /* create the UDP listening socket and bind it */\n        if (settings.udpport && server_sockets(udp_port, udp_transport,\n                                               portnumber_file)) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"failed to listen on UDP port %d: %s\",\n                                            settings.port, strerror(errno));\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    /* Drop privileges no longer needed */\n    drop_privileges();\n\n    if (!memcached_shutdown) {\n        /* enter the event loop */\n        event_base_loop(main_base, 0);\n    }\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Initiating shutdown\\n\");\n    }\n    threads_shutdown();\n\n    settings.engine.v1->destroy(settings.engine.v0, false);\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n\n    return EXIT_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/memcache/extra/memcached/utilities/engine_loader.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/types.h>\n\nstatic const char * const feature_descriptions[] = {\n    \"compare and swap\",\n    \"persistent storage\",\n    \"secondary engine\",\n    \"access control\",\n    \"multi tenancy\",\n    \"LRU\"\n};\n\nvoid *handle = NULL;\n\nbool load_engine(const char *soname,\n                 SERVER_HANDLE_V1 *(*get_server_api)(void),\n                 EXTENSION_LOGGER_DESCRIPTOR *logger,\n                 ENGINE_HANDLE **engine_handle)\n{\n    ENGINE_HANDLE *engine = NULL;\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        CREATE_INSTANCE create;\n        void* voidptr;\n    } my_create = {.create = NULL };\n\n    handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname ? soname : \"self\",\n                msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"create_instance\");\n    if (symbol == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"create_instance\\\" in %s: %s\\n\",\n                soname ? soname : \"self\",\n                dlerror());\n        return false;\n    }\n    my_create.voidptr = symbol;\n\n    /* request a instance with protocol version 1 */\n    ENGINE_ERROR_CODE error = (*my_create.create)(1, get_server_api, &engine);\n\n    if (error != ENGINE_SUCCESS || engine == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create instance. Error code: %d\\n\", error);\n        dlclose(handle);\n        return false;\n    }\n    *engine_handle = engine;\n    return true;\n}\n\nbool init_engine(ENGINE_HANDLE * engine,\n                 const char *config_str,\n                 EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = NULL;\n\n    if (handle == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initialize engine, engine must fist be loaded.\");\n        return false;\n    }\n\n    if (engine->interface == 1) {\n        engine_v1 = (ENGINE_HANDLE_V1*)engine;\n\n        // validate that the required engine interface is implemented:\n        if (engine_v1->get_info == NULL || engine_v1->initialize == NULL ||\n            engine_v1->destroy == NULL || engine_v1->allocate == NULL ||\n            engine_v1->remove == NULL || engine_v1->release == NULL ||\n            engine_v1->get == NULL || engine_v1->store == NULL ||\n            engine_v1->flush == NULL ||\n            engine_v1->get_stats == NULL || engine_v1->reset_stats == NULL ||\n            engine_v1->item_set_cas == NULL ||\n            engine_v1->get_item_info == NULL)\n        {\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to initialize engine; it does not implement the engine interface.\");\n            return false;\n        }\n\n        ENGINE_ERROR_CODE error = engine_v1->initialize(engine,config_str);\n        if (error != ENGINE_SUCCESS) {\n            engine_v1->destroy(engine, false);\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to initialize instance. Error code: %d\\n\",\n                    error);\n            dlclose(handle);\n            return false;\n        }\n    } else {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Unsupported interface level\\n\");\n        dlclose(handle);\n        return false;\n    }\n    return true;\n}\n\nvoid log_engine_details(ENGINE_HANDLE * engine,\n                        EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = (ENGINE_HANDLE_V1*)engine;\n    const engine_info *info;\n    info = engine_v1->get_info(engine);\n    if (info) {\n        char message[4096];\n        ssize_t nw = snprintf(message, sizeof(message), \"Loaded engine: %s\\n\",\n                                        info->description ?\n                                        info->description : \"Unknown\");\n        if (nw == -1) {\n            return;\n        }\n        ssize_t offset = nw;\n        bool comma = false;\n\n        if (info->num_features > 0) {\n            nw = snprintf(message + offset, sizeof(message) - offset,\n                          \"Supplying the following features: \");\n            if (nw == -1) {\n                return;\n            }\n            offset += nw;\n            for (int ii = 0; ii < info->num_features; ++ii) {\n                if (info->features[ii].description != NULL) {\n                    nw = snprintf(message + offset, sizeof(message) - offset,\n                                  \"%s%s\", comma ? \", \" : \"\",\n                                  info->features[ii].description);\n                } else {\n                    if (info->features[ii].feature <= LAST_REGISTERED_ENGINE_FEATURE) {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%s%s\", comma ? \", \" : \"\",\n                                      feature_descriptions[info->features[ii].feature]);\n                    } else {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%sUnknown feature: %d\", comma ? \", \" : \"\",\n                                      info->features[ii].feature);\n                    }\n                }\n                comma = true;\n                if (nw == -1) {\n                    return;\n                }\n                offset += nw;\n            }\n        }\n        logger->log(EXTENSION_LOG_INFO, NULL, \"%s\\n\", message);\n    } else {\n        logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Loaded engine: Unknown\\n\");\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/memcache/extra/memcached/programs/engine_testapp.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <assert.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <signal.h>\n#include <pthread.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/engine_testapp.h>\n#include <memcached/extension_loggers.h>\n#include <mock_server.h>\n\nstruct mock_engine {\n    ENGINE_HANDLE_V1 me;\n    ENGINE_HANDLE_V1 *the_engine;\n    TAP_ITERATOR iterator;\n};\n\n#ifndef WIN32\nstatic sig_atomic_t alarmed;\n\nstatic void alarm_handler(int sig) {\n    alarmed = 1;\n}\n#endif\n\nstatic inline struct mock_engine* get_handle(ENGINE_HANDLE* handle) {\n    return (struct mock_engine*)handle;\n}\n\nstatic tap_event_t mock_tap_iterator(ENGINE_HANDLE* handle,\n                                     const void *cookie, item **itm,\n                                     void **es, uint16_t *nes, uint8_t *ttl,\n                                     uint16_t *flags, uint32_t *seqno,\n                                     uint16_t *vbucket) {\n   struct mock_engine *me = get_handle(handle);\n   return me->iterator((ENGINE_HANDLE*)me->the_engine, cookie, itm, es, nes,\n                       ttl, flags, seqno, vbucket);\n}\n\nstatic const engine_info* mock_get_info(ENGINE_HANDLE* handle) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_info((ENGINE_HANDLE*)me->the_engine);\n}\n\nstatic ENGINE_ERROR_CODE mock_initialize(ENGINE_HANDLE* handle,\n                                         const char* config_str) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->initialize((ENGINE_HANDLE*)me->the_engine, config_str);\n}\n\nstatic void mock_destroy(ENGINE_HANDLE* handle, const bool force) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->destroy((ENGINE_HANDLE*)me->the_engine, force);\n}\n\nstatic ENGINE_ERROR_CODE mock_allocate(ENGINE_HANDLE* handle,\n                                       const void* cookie,\n                                       item **item,\n                                       const void* key,\n                                       const size_t nkey,\n                                       const size_t nbytes,\n                                       const int flags,\n                                       const rel_time_t exptime) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->allocate((ENGINE_HANDLE*)me->the_engine, c,\n                                           item, key, nkey,\n                                           nbytes, flags,\n                                           exptime)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_remove(ENGINE_HANDLE* handle,\n                                     const void* cookie,\n                                     const void* key,\n                                     const size_t nkey,\n                                     uint64_t cas,\n                                     uint16_t vbucket)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->remove((ENGINE_HANDLE*)me->the_engine, c, key,\n                                         nkey, cas, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_release(ENGINE_HANDLE* handle,\n                         const void *cookie,\n                         item* item) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->release((ENGINE_HANDLE*)me->the_engine, cookie, item);\n}\n\nstatic ENGINE_ERROR_CODE mock_get(ENGINE_HANDLE* handle,\n                                  const void* cookie,\n                                  item** item,\n                                  const void* key,\n                                  const int nkey,\n                                  uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get((ENGINE_HANDLE*)me->the_engine, c, item,\n                                      key, nkey, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_get_stats(ENGINE_HANDLE* handle,\n                                        const void* cookie,\n                                        const char* stat_key,\n                                        int nkey,\n                                        ADD_STAT add_stat)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get_stats((ENGINE_HANDLE*)me->the_engine, c, stat_key,\n                                            nkey, add_stat)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_store(ENGINE_HANDLE* handle,\n                                    const void *cookie,\n                                    item* item,\n                                    uint64_t *cas,\n                                    ENGINE_STORE_OPERATION operation,\n                                    uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->store((ENGINE_HANDLE*)me->the_engine, c, item, cas,\n                                        operation, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_arithmetic(ENGINE_HANDLE* handle,\n                                         const void* cookie,\n                                         const void* key,\n                                         const int nkey,\n                                         const bool increment,\n                                         const bool create,\n                                         const uint64_t delta,\n                                         const uint64_t initial,\n                                         const rel_time_t exptime,\n                                         uint64_t *cas,\n                                         uint64_t *result,\n                                         uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->arithmetic((ENGINE_HANDLE*)me->the_engine, c, key,\n                                             nkey, increment, create,\n                                             delta, initial, exptime,\n                                             cas, result, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_flush(ENGINE_HANDLE* handle,\n                                    const void* cookie, time_t when) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->flush((ENGINE_HANDLE*)me->the_engine, c, when)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_reset_stats(ENGINE_HANDLE* handle, const void *cookie) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->reset_stats((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_unknown_command(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              protocol_binary_request_header *request,\n                                              ADD_RESPONSE response)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->unknown_command((ENGINE_HANDLE*)me->the_engine, c,\n                                                  request, response)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_item_set_cas(ENGINE_HANDLE *handle, const void *cookie,\n                              item* item, uint64_t val)\n{\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->item_set_cas((ENGINE_HANDLE*)me->the_engine, cookie, item, val);\n}\n\n\nstatic bool mock_get_item_info(ENGINE_HANDLE *handle, const void *cookie,\n                               const item* item, item_info *item_info)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_item_info((ENGINE_HANDLE*)me->the_engine,\n                                         cookie, item, item_info);\n}\n\nstatic void *mock_get_stats_struct(ENGINE_HANDLE* handle, const void* cookie)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_stats_struct((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_aggregate_stats(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              void (*callback)(void*, void*),\n                                              void *vptr)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->aggregate_stats((ENGINE_HANDLE*)me->the_engine, c,\n                                                  callback, vptr)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_tap_notify(ENGINE_HANDLE* handle,\n                                        const void *cookie,\n                                        void *engine_specific,\n                                        uint16_t nengine,\n                                        uint8_t ttl,\n                                        uint16_t tap_flags,\n                                        tap_event_t tap_event,\n                                        uint32_t tap_seqno,\n                                        const void *key,\n                                        size_t nkey,\n                                        uint32_t flags,\n                                        uint32_t exptime,\n                                        uint64_t cas,\n                                        const void *data,\n                                        size_t ndata,\n                                         uint16_t vbucket) {\n\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->tap_notify((ENGINE_HANDLE*)me->the_engine, c,\n                                             engine_specific, nengine, ttl, tap_flags,\n                                             tap_event, tap_seqno, key, nkey, flags,\n                                             exptime, cas, data, ndata, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\n\nstatic TAP_ITERATOR mock_get_tap_iterator(ENGINE_HANDLE* handle, const void* cookie,\n                                           const void* client, size_t nclient,\n                                           uint32_t flags,\n                                           const void* userdata, size_t nuserdata) {\n    struct mock_engine *me = get_handle(handle);\n    me->iterator = me->the_engine->get_tap_iterator((ENGINE_HANDLE*)me->the_engine, cookie,\n                                                    client, nclient, flags, userdata, nuserdata);\n    return (me->iterator != NULL) ? mock_tap_iterator : NULL;\n}\n\nstatic size_t mock_errinfo(ENGINE_HANDLE *handle, const void* cookie,\n                           char *buffer, size_t buffsz) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->errinfo((ENGINE_HANDLE*)me->the_engine, cookie,\n                                   buffer, buffsz);\n}\n\n\nstruct mock_engine default_mock_engine = {\n    .me = {\n        .interface = {\n            .interface = 1\n        },\n        .get_info = mock_get_info,\n        .initialize = mock_initialize,\n        .destroy = mock_destroy,\n        .allocate = mock_allocate,\n        .remove = mock_remove,\n        .release = mock_release,\n        .get = mock_get,\n        .store = mock_store,\n        .arithmetic = mock_arithmetic,\n        .flush = mock_flush,\n        .get_stats = mock_get_stats,\n        .reset_stats = mock_reset_stats,\n        .get_stats_struct = mock_get_stats_struct,\n        .aggregate_stats = mock_aggregate_stats,\n        .unknown_command = mock_unknown_command,\n        .tap_notify = mock_tap_notify,\n        .get_tap_iterator = mock_get_tap_iterator,\n        .item_set_cas = mock_item_set_cas,\n        .get_item_info = mock_get_item_info,\n        .errinfo = mock_errinfo\n    }\n};\nstruct mock_engine mock_engine;\n\nEXTENSION_LOGGER_DESCRIPTOR *logger_descriptor = NULL;\nstatic ENGINE_HANDLE *handle = NULL;\nstatic ENGINE_HANDLE_V1 *handle_v1 = NULL;\n\nstatic void usage(void) {\n    printf(\"\\n\");\n    printf(\"engine_testapp -E <path_to_engine_lib> -T <path_to_testlib>\\n\");\n    printf(\"               [-e <engine_config>] [-h]\\n\");\n    printf(\"\\n\");\n    printf(\"-E <path_to_engine_lib>      Path to the engine library file. The\\n\");\n    printf(\"                             engine library file is a library file\\n\");\n    printf(\"                             (.so or .dll) that the contains the \\n\");\n    printf(\"                             implementation of the engine being\\n\");\n    printf(\"                             tested.\\n\");\n    printf(\"\\n\");\n    printf(\"-T <path_to_testlib>         Path to the test library file. The test\\n\");\n    printf(\"                             library file is a library file (.so or\\n\");\n    printf(\"                             .dll) that contains the set of tests\\n\");\n    printf(\"                             to be executed.\\n\");\n    printf(\"\\n\");\n    printf(\"-t <timeout>                 Maximum time to run a test.\\n\");\n    printf(\"-e <engine_config>           Engine configuration string passed to\\n\");\n    printf(\"                             the engine.\\n\");\n    printf(\"-q                           Only print errors.\");\n    printf(\"-.                           Print a . for each executed test.\");\n    printf(\"\\n\");\n    printf(\"-h                           Prints this usage text.\\n\");\n    printf(\"\\n\");\n}\n\nstatic int report_test(const char *name, enum test_result r, bool quiet) {\n    int rc = 0;\n    char *msg = NULL;\n    bool color_enabled = getenv(\"TESTAPP_ENABLE_COLOR\") != NULL;\n    int color = 0;\n    char color_str[8] = { 0 };\n    char *reset_color = \"\\033[m\";\n    switch(r) {\n    case SUCCESS:\n        msg=\"OK\";\n        color = 32;\n        break;\n    case SKIPPED:\n        msg=\"SKIPPED\";\n        color = 32;\n        break;\n    case FAIL:\n        color = 31;\n        msg=\"FAIL\";\n        rc = 1;\n        break;\n    case DIED:\n        color = 31;\n        msg = \"DIED\";\n        rc = 1;\n        break;\n    case TIMEOUT:\n        color = 31;\n        msg = \"TIMED OUT\";\n        rc = 1;\n        break;\n    case CORE:\n        color = 31;\n        msg = \"CORE DUMPED\";\n        rc = 1;\n        break;\n    case PENDING:\n        color = 33;\n        msg = \"PENDING\";\n        break;\n    }\n    assert(msg);\n    if (color_enabled) {\n        snprintf(color_str, sizeof(color_str), \"\\033[%dm\", color);\n    }\n    if (quiet) {\n        if (r != SUCCESS) {\n            printf(\"%s:  %s%s%s\\n\", name, color_str, msg,\n                   color_enabled ? reset_color : \"\");\n            fflush(stdout);\n        }\n    } else {\n        printf(\"%s%s%s\\n\", color_str, msg, color_enabled ? reset_color : \"\");\n    }\n    return rc;\n}\n\nstatic ENGINE_HANDLE_V1 *start_your_engines(const char *engine, const char* cfg, bool engine_init) {\n\n    init_mock_server(handle);\n    if (!load_engine(engine, &get_mock_server_api, logger_descriptor, &handle)) {\n        fprintf(stderr, \"Failed to load engine %s.\\n\", engine);\n        return NULL;\n    }\n\n    if (engine_init) {\n        if(!init_engine(handle, cfg, logger_descriptor)) {\n            fprintf(stderr, \"Failed to init engine %s with config %s.\\n\", engine, cfg);\n            return NULL;\n        }\n    }\n\n    mock_engine = default_mock_engine;\n    handle_v1 = mock_engine.the_engine = (ENGINE_HANDLE_V1*)handle;\n    handle = (ENGINE_HANDLE*)&mock_engine.me;\n    handle_v1 = &mock_engine.me;\n\n    // Reset all members that aren't set (to allow the users to write\n    // testcases to verify that they initialize them..\n    assert(mock_engine.me.interface.interface == mock_engine.the_engine->interface.interface);\n\n    if (mock_engine.the_engine->get_stats_struct == NULL) {\n        mock_engine.me.get_stats_struct = NULL;\n    }\n    if (mock_engine.the_engine->aggregate_stats == NULL) {\n        mock_engine.me.aggregate_stats = NULL;\n    }\n    if (mock_engine.the_engine->unknown_command == NULL) {\n        mock_engine.me.unknown_command = NULL;\n    }\n    if (mock_engine.the_engine->tap_notify == NULL) {\n        mock_engine.me.tap_notify = NULL;\n    }\n    if (mock_engine.the_engine->get_tap_iterator == NULL) {\n        mock_engine.me.get_tap_iterator = NULL;\n    }\n    if (mock_engine.the_engine->errinfo == NULL) {\n        mock_engine.me.errinfo = NULL;\n    }\n\n    return &mock_engine.me;\n}\n\nstatic void destroy_engine(bool force) {\n    if (handle_v1) {\n        handle_v1->destroy(handle, force);\n        handle_v1 = NULL;\n        handle = NULL;\n    }\n}\n\nstatic void reload_engine(ENGINE_HANDLE **h, ENGINE_HANDLE_V1 **h1,\n                          const char* engine, const char *cfg, bool init, bool force) {\n    destroy_engine(force);\n    handle_v1 = start_your_engines(engine, cfg, init);\n    handle = (ENGINE_HANDLE*)(handle_v1);\n    *h1 = handle_v1;\n    *h = handle;\n}\n\nstatic engine_test_t* current_testcase;\n\nstatic const engine_test_t* get_current_testcase(void)\n{\n    return current_testcase;\n}\n\n\nstatic enum test_result run_test(engine_test_t test, const char *engine, const char *default_cfg) {\n    enum test_result ret = PENDING;\n    if (test.tfun != NULL) {\n#if !defined(USE_GCOV) && !defined(WIN32)\n        pid_t pid = fork();\n        if (pid == 0) {\n#endif\n            current_testcase = &test;\n            if (test.prepare != NULL) {\n                if ((ret = test.prepare(&test)) == SUCCESS) {\n                    ret = PENDING;\n                }\n            }\n\n            if (ret == PENDING) {\n                /* Start the engines and go */\n                start_your_engines(engine, test.cfg ? test.cfg : default_cfg, true);\n                if (test.test_setup != NULL) {\n                    if (!test.test_setup(handle, handle_v1)) {\n                        fprintf(stderr, \"Failed to run setup for test %s\\n\", test.name);\n#if !defined(USE_GCOV) && !defined(WIN32)\n                        exit((int)ret);\n#else\n                        return FAIL;\n#endif\n                    }\n                }\n                ret = test.tfun(handle, handle_v1);\n                if (test.test_teardown != NULL) {\n                    if (!test.test_teardown(handle, handle_v1)) {\n                        fprintf(stderr, \"WARNING: Failed to run teardown for test %s\\n\", test.name);\n                    }\n                }\n                destroy_engine(false);\n\n                if (test.cleanup) {\n                    test.cleanup(&test, ret);\n                }\n            }\n#if !defined(USE_GCOV) && !defined(WIN32)\n            exit((int)ret);\n        } else if (pid == (pid_t)-1) {\n            ret = FAIL;\n        } else {\n            int rc;\n            while (alarmed == 0 && waitpid(pid, &rc, 0) == (pid_t)-1) {\n                if (errno != EINTR) {\n                    abort();\n                }\n            }\n\n            if (alarmed) {\n                kill(pid, 9);\n                ret = TIMEOUT;\n            } else if (WIFEXITED(rc)) {\n                ret = (enum test_result)WEXITSTATUS(rc);\n            } else if (WIFSIGNALED(rc) && WCOREDUMP(rc)) {\n                ret = CORE;\n            } else {\n                ret = DIED;\n            }\n        }\n#endif\n    }\n\n    return ret;\n}\n\nstatic void setup_alarm_handler() {\n#ifndef WIN32\n    struct sigaction sig_handler;\n\n    sig_handler.sa_handler = alarm_handler;\n    sig_handler.sa_flags = 0;\n\n    sigaction(SIGALRM, &sig_handler, NULL);\n#endif\n}\n\nstatic void set_test_timeout(int timeout) {\n#ifndef WIN32\n    alarm(timeout);\n#endif\n}\n\nstatic void clear_test_timeout() {\n#ifndef WIN32\n    alarm(0);\n    alarmed = 0;\n#endif\n}\n\nint main(int argc, char **argv) {\n    int c, exitcode = 0, num_cases = 0, timeout = 0;\n    bool quiet = false;\n    bool dot = false;\n    const char *engine = NULL;\n    const char *engine_args = NULL;\n    const char *test_suite = NULL;\n    const char *test_case = NULL;\n    engine_test_t *testcases = NULL;\n    logger_descriptor = get_null_logger();\n\n    /* Hack to remove the warning from C99 */\n    union {\n        GET_TESTS get_tests;\n        void* voidptr;\n    } my_get_test = {.get_tests = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        SETUP_SUITE setup_suite;\n        void* voidptr;\n    } my_setup_suite = {.setup_suite = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        TEARDOWN_SUITE teardown_suite;\n        void* voidptr;\n    } my_teardown_suite = {.teardown_suite = NULL };\n\n\n    /* Use unbuffered stdio */\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n\n    setup_alarm_handler();\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"h\"  /* usage */\n          \"E:\" /* Engine to load */\n          \"e:\" /* Engine options */\n          \"T:\" /* Library with tests to load */\n          \"t:\" /* Timeout */\n          \"q\"  /* Be more quiet (only report failures) */\n          \".\"  /* dot mode. */\n          \"n:\"  /* test case to run */\n        ))) {\n        switch (c) {\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_args = optarg;\n            break;\n        case 'h':\n            usage();\n            return 0;\n        case 'T':\n            test_suite = optarg;\n            break;\n        case 't':\n            timeout = atoi(optarg);\n            break;\n        case 'n':\n            test_case = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case '.':\n            dot = true;\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    //validate args\n    if (engine == NULL) {\n        fprintf(stderr, \"You must provide a path to the storage engine library.\\n\");\n        return 1;\n    }\n\n    if (test_suite == NULL) {\n        fprintf(stderr, \"You must provide a path to the testsuite library.\\n\");\n        return 1;\n    }\n\n    //load test_suite\n    void* handle = dlopen(test_suite, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Failed to load testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n\n    //get the test cases\n    void *symbol = dlsym(handle, \"get_tests\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Could not find get_tests function in testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n    my_get_test.voidptr = symbol;\n    testcases = (*my_get_test.get_tests)();\n\n    //set up the suite if needed\n    struct test_harness harness = { .default_engine_cfg = engine_args,\n                                    .engine_path = engine,\n                                    .reload_engine = reload_engine,\n                                    .start_engine = start_your_engines,\n                                    .create_cookie = create_mock_cookie,\n                                    .destroy_cookie = destroy_mock_cookie,\n                                    .set_ewouldblock_handling = mock_set_ewouldblock_handling,\n                                    .lock_cookie = lock_mock_cookie,\n                                    .unlock_cookie = unlock_mock_cookie,\n                                    .waitfor_cookie = waitfor_mock_cookie,\n                                    .time_travel = mock_time_travel,\n                                    .get_current_testcase = get_current_testcase };\n    symbol = dlsym(handle, \"setup_suite\");\n    if (symbol != NULL) {\n        my_setup_suite.voidptr = symbol;\n        if (!(*my_setup_suite.setup_suite)(&harness)) {\n            fprintf(stderr, \"Failed to set up test suite %s \\n\", test_suite);\n            return 1;\n        }\n    }\n\n\n    for (num_cases = 0; testcases[num_cases].name; num_cases++) {\n        /* Just counting */\n    }\n\n    if (!quiet) {\n        printf(\"1..%d\\n\", num_cases);\n    }\n\n    int i;\n    bool need_newline = false;\n    for (i = 0; testcases[i].name; i++) {\n        if (test_case != NULL && strcmp(test_case, testcases[i].name) != 0)\n            continue;\n        if (!quiet) {\n            printf(\"Running %s... \", testcases[i].name);\n            fflush(stdout);\n        } else if(dot) {\n            printf(\".\");\n            need_newline = true;\n            /* Add a newline every few tests */\n            if ((i+1) % 70 == 0) {\n                printf(\"\\n\");\n                need_newline = false;\n            }\n        }\n        set_test_timeout(timeout);\n        exitcode += report_test(testcases[i].name,\n                                run_test(testcases[i], engine, engine_args),\n                                quiet);\n        clear_test_timeout();\n    }\n\n    if (need_newline) {\n        printf(\"\\n\");\n    }\n\n    //tear down the suite if needed\n    symbol = dlsym(handle, \"teardown_suite\");\n    if (symbol != NULL) {\n        my_teardown_suite.voidptr = symbol;\n        if (!(*my_teardown_suite.teardown_suite)()) {\n            fprintf(stderr, \"Failed to teardown up test suite %s \\n\", test_suite);\n        }\n    }\n\n    printf(\"# Passed %d of %d tests\\n\", num_cases - exitcode, num_cases);\n\n    return exitcode;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/memcache/extra/memcached/win32/dlfcn.h": "#ifndef DLFCN_H\n#define DLFCN_H\nvoid* dlopen(const char* path, int mode);\nvoid* dlsym(void* handle, const char* symbol);\nint dlclose(void* handle);\nconst char *dlerror(void);\n\n#define RTLD_LAZY 1\n#define RTLD_LOCAL 2\n\n#define RTLD_NOW 0x00002\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/memcache/extra/memcached/win32/dlfcn.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include <stdio.h>\n#include <windows.h>\n#include <dlfcn.h>\n#include <stdbool.h>\n\n/*\n * Keep track if the user tried to call dlopen(NULL, xx) to be able to give a sane\n * error message\n */\nstatic bool self = false;\n\nvoid* dlopen(const char* path, int mode) {\n    if (path == NULL) {\n        // We don't support opening ourself\n        self = true;\n        return NULL;\n    }\n\n    void* handle = LoadLibrary(path);\n    if (handle == NULL) {\n        char *buf = malloc(strlen(path) + 20);\n        sprintf(buf, \"%s.dll\", path);\n        handle = LoadLibrary(buf);\n        free(buf);\n    }\n\n    return handle;\n}\n\nvoid* dlsym(void* handle, const char* symbol) {\n    return GetProcAddress(handle, symbol);\n}\n\nint dlclose(void* handle) {\n    // dlclose returns zero on success.\n    // FreeLibrary returns nonzero on success.\n    return FreeLibrary(handle) != 0;\n}\n\nstatic char dlerror_buf[200];\n\nconst char *dlerror(void) {\n    if (self) {\n        return \"not supported\";\n    }\n\n    DWORD err = GetLastError();\n    LPVOID error_msg;\n    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                      FORMAT_MESSAGE_FROM_SYSTEM |\n                      FORMAT_MESSAGE_IGNORE_INSERTS,\n                      NULL, err, 0, (LPTSTR)&error_msg, 0, NULL) != 0) {\n        strncpy(dlerror_buf, error_msg, sizeof(dlerror_buf));\n        dlerror_buf[sizeof(dlerror_buf) - 1] = '\\0';\n        LocalFree(error_msg);\n    } else {\n        return \"Failed to get error message\";\n    }\n\n    return dlerror_buf;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/nodejs/Adapter/impl/test/debug_dlopen.cpp": "/*\n Copyright (c) 2012, Oracle and/or its affiliates. All rights\n reserved.\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; version 2 of\n the License.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n 02110-1301  USA\n */\n\n\n/***** \n *\n *\n *   dlopen() a file and return any errors from the loader.\n * \n *   We do this because Node.js loses the error messages.\n *   This is implemented in a way that minimizes the load-time dependencies \n *   of this module itself.\n *   \n ****/\n\n\n#include <dlfcn.h>\n\n#include \"adapter_global.h\"\n#include \"v8_binder.h\"\n#include \"js_wrapper_macros.h\"\n\nusing namespace v8;\n\nHandle<Value> dlopen_wrapper(const Arguments &args) {\n  HandleScope scope;\n  \n  REQUIRE_ARGS_LENGTH(1);\n\n  v8::String::AsciiValue pathname(args[0]);\n  Local<String> result;\n  \n  if(dlopen(*pathname, RTLD_LAZY) == NULL) {\n    result = String::New(dlerror());\n  }\n  else {\n    result = String::New(\"OK\");\n  }\n  \n  return scope.Close(result);\n}\n\n\nvoid dlopen_initOnLoad(Handle<Object> target) {\n  DEFINE_JS_FUNCTION(target, \"debug_dlopen\", dlopen_wrapper);\n}\n\nV8BINDER_LOADABLE_MODULE(debug_dlopen, dlopen_initOnLoad)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/nodejs/Adapter/impl/test/loadtest.js": "var dbdl = require(\"../build/Release/test/debug_dlopen\");\n\nfunction test(f) { \n  var status;\n  console.log(f);\n  status = dbdl.debug_dlopen(\"../build/Release/\" + f);\n  console.log(status);\n  if(status === \"OK\") {\n    var module = require(\"../build/Release/\" + f);\n    console.dir(module);\n  }\n}\n\ntest(\"ndb_adapter.node\");\ntest(\"test/mapper.node\");\ntest(\"test/outermapper.node\");\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/include/my_global.h": "/*\n   Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#ifndef MY_GLOBAL_INCLUDED\n#define MY_GLOBAL_INCLUDED\n\n/*\n  This include file should be included first in every header file.\n\n  This makes sure my_config.h is included to get platform specific\n  symbols defined and it makes sure a lot of platform/compiler\n  differences are mitigated.\n*/\n\n#include \"my_config.h\"\n\n#define __STDC_LIMIT_MACROS\t/* Enable C99 limit macros */\n#define __STDC_FORMAT_MACROS\t/* Enable C99 printf format macros */\n#define _USE_MATH_DEFINES       /* Get access to M_PI, M_E, etc. in math.h */\n\n#ifdef _WIN32\n/* Include common headers.*/\n# include <winsock2.h>\n# include <ws2tcpip.h> /* SOCKET */\n# include <io.h>       /* access(), chmod() */\n#endif\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <fcntl.h>\n#include <time.h>\n#include <errno.h>\t\t\t\t/* Recommended by debian */\n#include <sys/types.h>\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#if !defined(_WIN32)\n#include <netdb.h>\n#endif\n#ifdef MY_MSCRT_DEBUG\n#include <crtdbg.h>\n#endif\n\n/*\n  A lot of our programs uses asserts, so better to always include it\n  This also fixes a problem when people uses DBUG_ASSERT without including\n  assert.h\n*/\n#include <assert.h>\n\n/* Include standard definitions of operator new and delete. */\n#ifdef __cplusplus\n# include <new>\n#endif\n\n#include \"my_compiler.h\"\n\n\n/*\n  InnoDB depends on some MySQL internals which other plugins should not\n  need.  This is because of InnoDB's foreign key support, \"safe\" binlog\n  truncation, and other similar legacy features.\n\n  We define accessors for these internals unconditionally, but do not\n  expose them in mysql/plugin.h.  They are declared in ha_innodb.h for\n  InnoDB's use.\n*/\n#define INNODB_COMPATIBILITY_HOOKS\n\n/* Macros to make switching between C and C++ mode easier */\n#ifdef __cplusplus\n#define C_MODE_START    extern \"C\" {\n#define C_MODE_END\t}\n#else\n#define C_MODE_START\n#define C_MODE_END\n#endif\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#define HAVE_PSI_INTERFACE\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n/* Make it easier to add conditional code in _expressions_ */\n#ifdef _WIN32\n#define IF_WIN(A,B) A\n#else\n#define IF_WIN(A,B) B\n#endif\n\n#if defined (_WIN32)\n/*\n off_t is 32 bit long. We do not use C runtime functions\n with off_t but native Win32 file IO APIs, that work with\n 64 bit offsets.\n*/\n#undef SIZEOF_OFF_T\n#define SIZEOF_OFF_T 8\n\nstatic inline void sleep(unsigned long seconds)\n{\n  Sleep(seconds * 1000);\n}\n\n/* Define missing access() modes. */\n#define F_OK 0\n#define W_OK 2\n#define R_OK 4                        /* Test for read permission.  */\n\n/* Define missing file locking constants. */\n#define F_RDLCK 1\n#define F_WRLCK 2\n#define F_UNLCK 3\n#define F_TO_EOF 0x3FFFFFFF\n\n#define O_NONBLOCK 1    /* For emulation of fcntl() */\n\n/*\n  SHUT_RDWR is called SD_BOTH in windows and\n  is defined to 2 in winsock2.h\n  #define SD_BOTH 0x02\n*/\n#define SHUT_RDWR 0x02\n\n/* Shared memory and named pipe connections are supported. */\n#define shared_memory_buffer_length 16000\n#define default_shared_memory_base_name \"MYSQL\"\n#endif /* _WIN32*/\n\n/**\n  Cast a member of a structure to the structure that contains it.\n\n  @param  ptr     Pointer to the member.\n  @param  type    Type of the structure that contains the member.\n  @param  member  Name of the member within the structure.\n*/\n#define my_container_of(ptr, type, member)              \\\n  ((type *)((char *)ptr - offsetof(type, member)))\n\n/* an assert that works at compile-time. only for constant expression */\n#define compile_time_assert(X)                                              \\\n  do                                                                        \\\n  {                                                                         \\\n    typedef char compile_time_assert[(X) ? 1 : -1] MY_ATTRIBUTE((unused)); \\\n  } while(0)\n\n#define QUOTE_ARG(x)\t\t#x\t/* Quote argument (before cpp) */\n#define STRINGIFY_ARG(x) QUOTE_ARG(x)\t/* Quote argument, after cpp */\n\n#ifdef _WIN32\n#define SO_EXT \".dll\"\n#elif defined(__APPLE__)\n#define SO_EXT \".dylib\"\n#else\n#define SO_EXT \".so\"\n#endif\n\n#if !defined(HAVE_UINT)\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\n#endif\n\n#define swap_variables(t, a, b) { t dummy; dummy= a; a= b; b= dummy; }\n#define MY_TEST(a)\t\t((a) ? 1 : 0)\n#define set_if_bigger(a,b)  do { if ((a) < (b)) (a)=(b); } while(0)\n#define set_if_smaller(a,b) do { if ((a) > (b)) (a)=(b); } while(0)\n#define test_all_bits(a,b) (((a) & (b)) == (b))\n#define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))\n\n/* Define some general constants */\n#ifndef TRUE\n#define TRUE\t\t(1)\t/* Logical true */\n#define FALSE\t\t(0)\t/* Logical false */\n#endif\n\n/* Some types that is different between systems */\n\ntypedef int\tFile;\t\t/* File descriptor */\n#ifdef _WIN32\ntypedef SOCKET my_socket;\n#else\ntypedef int\tmy_socket;\t/* File descriptor for sockets */\n#define INVALID_SOCKET -1\n#endif\nC_MODE_START\ntypedef void\t(*sig_return)();/* Returns type from signal */\nC_MODE_END\n#if defined(__GNUC__)\ntypedef char\tpchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpbool;\t\t/* Mixed prototypes can take char */\n#else\ntypedef int\tpchar;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpbool;\t\t/* Mixed prototypes can't take char */\n#endif\nC_MODE_START\ntypedef int\t(*qsort_cmp)(const void *,const void *);\ntypedef int\t(*qsort_cmp2)(const void*, const void *,const void *);\nC_MODE_END\n#ifdef _WIN32\ntypedef int       socket_len_t;\ntypedef int       sigset_t;\ntypedef int       mode_t;\ntypedef SSIZE_T   ssize_t;\n#else\ntypedef socklen_t socket_len_t;\n#endif\ntypedef socket_len_t SOCKET_SIZE_TYPE; /* Used by NDB */\n\n/* file create flags */\n\n#ifndef O_SHARE\t\t\t/* Probably not windows */\n#define O_SHARE\t\t0\t/* Flag to my_open for shared files */\n#ifndef O_BINARY\n#define O_BINARY\t0\t/* Flag to my_open for binary files */\n#endif\n#ifndef FILE_BINARY\n#define FILE_BINARY\tO_BINARY /* Flag to my_fopen for binary streams */\n#endif\n#ifdef HAVE_FCNTL\n#define HAVE_FCNTL_LOCK\n#define F_TO_EOF\t0L\t/* Param to lockf() to lock rest of file */\n#endif\n#endif /* O_SHARE */\n\n#ifndef O_TEMPORARY\n#define O_TEMPORARY\t0\n#endif\n#ifndef O_SHORT_LIVED\n#define O_SHORT_LIVED\t0\n#endif\n#ifndef O_NOFOLLOW\n#define O_NOFOLLOW      0\n#endif\n\n/* additional file share flags for win32 */\n#ifdef _WIN32\n#define _SH_DENYRWD     0x110    /* deny read/write mode & delete */\n#define _SH_DENYWRD     0x120    /* deny write mode & delete      */\n#define _SH_DENYRDD     0x130    /* deny read mode & delete       */\n#define _SH_DENYDEL     0x140    /* deny delete only              */\n#endif /* _WIN32 */\n\n\n/* General constants */\n#define FN_LEN\t\t256\t/* Max file name len */\n#define FN_HEADLEN\t253\t/* Max length of filepart of file name */\n#define FN_EXTLEN\t20\t/* Max length of extension (part of FN_LEN) */\n#define FN_REFLEN\t512\t/* Max length of full path-name */\n#define FN_REFLEN_SE\t4000\t/* Max length of full path-name in SE */\n#define FN_EXTCHAR\t'.'\n#define FN_HOMELIB\t'~'\t/* ~/ is used as abbrev for home dir */\n#define FN_CURLIB\t'.'\t/* ./ is used as abbrev for current dir */\n#define FN_PARENTDIR\t\"..\"\t/* Parent directory; Must be a string */\n\n#ifdef _WIN32\n#define FN_LIBCHAR\t'\\\\'\n#define FN_LIBCHAR2\t'/'\n#define FN_DIRSEP       \"/\\\\\"               /* Valid directory separators */\n#define FN_EXEEXT   \".exe\"\n#define FN_SOEXT    \".dll\"\n#define FN_ROOTDIR\t\"\\\\\"\n#define FN_DEVCHAR\t':'\n#define FN_NETWORK_DRIVES\t/* Uses \\\\ to indicate network drives */\n#else\n#define FN_LIBCHAR\t'/'\n/*\n  FN_LIBCHAR2 is not defined on !Windows. Use is_directory_separator().\n*/\n#define FN_DIRSEP       \"/\"     /* Valid directory separators */\n#define FN_EXEEXT   \"\"\n#define FN_SOEXT    \".so\"\n#define FN_ROOTDIR\t\"/\"\n#endif\n\nstatic inline int is_directory_separator(char c)\n{\n#ifdef _WIN32\n  return c == FN_LIBCHAR || c == FN_LIBCHAR2;\n#else\n  return c == FN_LIBCHAR;\n#endif\n}\n\n/* \n  MY_FILE_MIN is  Windows speciality and is used to quickly detect\n  the mismatch of CRT and mysys file IO usage on Windows at runtime.\n  CRT file descriptors can be in the range 0-2047, whereas descriptors returned\n  by my_open() will start with 2048. If a file descriptor with value less then\n  MY_FILE_MIN is passed to mysys IO function, chances are it stemms from\n  open()/fileno() and not my_open()/my_fileno.\n\n  For Posix,  mysys functions are light wrappers around libc, and MY_FILE_MIN\n  is logically 0.\n*/\n\n#ifdef _WIN32\n#define MY_FILE_MIN  2048\n#else\n#define MY_FILE_MIN  0\n#endif\n\n/* \n  MY_NFILE is the default size of my_file_info array.\n\n  It is larger on Windows, because it all file handles are stored in my_file_info\n  Default size is 16384 and this should be enough for most cases.If it is not \n  enough, --max-open-files with larger value can be used.\n\n  For Posix , my_file_info array is only used to store filenames for\n  error reporting and its size is not a limitation for number of open files.\n*/ \n#ifdef _WIN32\n#define MY_NFILE (16384 + MY_FILE_MIN)\n#else\n#define MY_NFILE 64\n#endif\n\n#define OS_FILE_LIMIT\tUINT_MAX\n\n/*\n  Io buffer size; Must be a power of 2 and a multiple of 512. May be\n  smaller what the disk page size. This influences the speed of the\n  isam btree library. eg to big to slow.\n*/\n#define IO_SIZE\t\t\t4096\n/*\n  How much overhead does malloc have. The code often allocates\n  something like 1024-MALLOC_OVERHEAD bytes\n*/\n#define MALLOC_OVERHEAD 8\n\n\t/* get memory in huncs */\n#define ONCE_ALLOC_INIT\t\t(uint) (4096-MALLOC_OVERHEAD)\n\t/* Typical record cash */\n#define RECORD_CACHE_SIZE\t(uint) (64*1024-MALLOC_OVERHEAD)\n\t/* Typical key cash */\n#define KEY_CACHE_SIZE\t\t(uint) (8*1024*1024)\n\t/* Default size of a key cache block  */\n#define KEY_CACHE_BLOCK_SIZE\t(uint) 1024\n\n\n/* Some defines of functions for portability */\n\n#if (_WIN32)\n#if !defined(_WIN64)\ninline double my_ulonglong2double(unsigned long long value)\n{\n  long long nr=(long long) value;\n  if (nr >= 0)\n    return (double) nr;\n  return (18446744073709551616.0 + (double) nr);\n}\n#define ulonglong2double my_ulonglong2double\n#define my_off_t2double  my_ulonglong2double\n#endif /* _WIN64 */\ninline unsigned long long my_double2ulonglong(double d)\n{\n  double t= d - (double) 0x8000000000000000ULL;\n\n  if (t >= 0)\n    return  ((unsigned long long) t) + 0x8000000000000000ULL;\n  return (unsigned long long) d;\n}\n#define double2ulonglong my_double2ulonglong\n#endif /* _WIN32 */\n\n#ifndef ulonglong2double\n#define ulonglong2double(A) ((double) (ulonglong) (A))\n#define my_off_t2double(A)  ((double) (my_off_t) (A))\n#endif\n#ifndef double2ulonglong\n#define double2ulonglong(A) ((ulonglong) (double) (A))\n#endif\n\n#define INT_MIN64       (~0x7FFFFFFFFFFFFFFFLL)\n#define INT_MAX64       0x7FFFFFFFFFFFFFFFLL\n#define INT_MIN32       (~0x7FFFFFFFL)\n#define INT_MAX32       0x7FFFFFFFL\n#define UINT_MAX32      0xFFFFFFFFL\n#define INT_MIN24       (~0x007FFFFF)\n#define INT_MAX24       0x007FFFFF\n#define UINT_MAX24      0x00FFFFFF\n#define INT_MIN16       (~0x7FFF)\n#define INT_MAX16       0x7FFF\n#define UINT_MAX16      0xFFFF\n#define INT_MIN8        (~0x7F)\n#define INT_MAX8        0x7F\n#define UINT_MAX8       0xFF\n\n#ifndef SIZE_T_MAX\n#define SIZE_T_MAX      (~((size_t) 0))\n#endif\n\n// Our ifdef trickery for my_isfinite does not work with gcc/solaris unless we:\n#ifdef HAVE_IEEEFP_H\n#include <ieeefp.h>\n#endif\n\n#if (__cplusplus >= 201103L)\n  /* For C++11 use the new std functions rather than C99 macros. */\n  #include <cmath>\n  #define my_isfinite(X) std::isfinite(X)\n  #define my_isnan(X) std::isnan(X)\n  #define my_isinf(X) std::isinf(X)\n#else\n  #ifdef HAVE_LLVM_LIBCPP /* finite is deprecated in libc++ */\n    #define my_isfinite(X) isfinite(X)\n  #elif defined _WIN32\n    #define my_isfinite(X) _finite(X)\n  #else\n    #define my_isfinite(X) finite(X)\n  #endif\n  #define my_isnan(X) isnan(X)\n  #ifdef HAVE_ISINF\n    /* System-provided isinf() is available and safe to use */\n    #define my_isinf(X) isinf(X)\n  #else /* !HAVE_ISINF */\n    #define my_isinf(X) (!my_isfinite(X) && !my_isnan(X))\n  #endif\n#endif /* __cplusplus >= 201103L */\n\n/*\n  Max size that must be added to a so that we know Size to make\n  adressable obj.\n*/\n#if SIZEOF_CHARP == 4\ntypedef long\t\tmy_ptrdiff_t;\n#else\ntypedef long long\tmy_ptrdiff_t;\n#endif\n\n#define MY_ALIGN(A,L)\t(((A) + (L) - 1) & ~((L) - 1))\n#define ALIGN_SIZE(A)\tMY_ALIGN((A),sizeof(double))\n/* Size to make adressable obj. */\n#define ADD_TO_PTR(ptr,size,type) (type) ((uchar*) (ptr)+size)\n#define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((uchar*) (A) - (uchar*) (B))\n\n/*\n  Custom version of standard offsetof() macro which can be used to get\n  offsets of members in class for non-POD types (according to the current\n  version of C++ standard offsetof() macro can't be used in such cases and\n  attempt to do so causes warnings to be emitted, OTOH in many cases it is\n  still OK to assume that all instances of the class has the same offsets\n  for the same members).\n\n  This is temporary solution which should be removed once File_parser class\n  and related routines are refactored.\n*/\n\n#define my_offsetof(TYPE, MEMBER) \\\n        ((size_t)((char *)&(((TYPE *)0x10)->MEMBER) - (char*)0x10))\n\n#define NullS\t\t(char *) 0\n\n#ifdef _WIN32\n#define STDCALL __stdcall\n#else\n#define STDCALL\n#endif\n\n/* Typdefs for easyier portability */\n\ntypedef unsigned char\tuchar;\t/* Short for unsigned char */\ntypedef signed char int8;       /* Signed integer >= 8  bits */\ntypedef unsigned char uint8;    /* Unsigned integer >= 8  bits */\ntypedef short int16;\ntypedef unsigned short uint16;\n#if SIZEOF_INT == 4\ntypedef int int32;\ntypedef unsigned int uint32;\n#elif SIZEOF_LONG == 4\ntypedef long int32;\ntypedef unsigned long uint32;\n#else\n#error Neither int or long is of 4 bytes width\n#endif\n\n#if !defined(HAVE_ULONG)\ntypedef unsigned long\tulong;\t\t  /* Short for unsigned long */\n#endif\n/* \n  Using [unsigned] long long is preferable as [u]longlong because we use \n  [unsigned] long long unconditionally in many places, \n  for example in constants with [U]LL suffix.\n*/\ntypedef unsigned long long int ulonglong; /* ulong or unsigned long long */\ntypedef long long int\tlonglong;\ntypedef longlong int64;\ntypedef ulonglong uint64;\n\n#if defined (_WIN32)\ntypedef unsigned __int64 my_ulonglong;\n#else\ntypedef unsigned long long my_ulonglong;\n#endif\n\n#if SIZEOF_CHARP == SIZEOF_INT\ntypedef int intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG\ntypedef long intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG_LONG\ntypedef long long intptr;\n#else\n#error sizeof(void *) is neither sizeof(int) nor sizeof(long) nor sizeof(long long)\n#endif\n\n#define MY_ERRPTR ((void*)(intptr)1)\n\n#if defined(_WIN32)\ntypedef unsigned long long my_off_t;\ntypedef unsigned long long os_off_t;\n#else\ntypedef off_t os_off_t;\n#if SIZEOF_OFF_T > 4\ntypedef ulonglong my_off_t;\n#else\ntypedef unsigned long my_off_t;\n#endif\n#endif /*_WIN32*/\n#define MY_FILEPOS_ERROR\t(~(my_off_t) 0)\n\n/*\n  TODO Convert these to use Bitmap class.\n */\ntypedef ulonglong table_map;          /* Used for table bits in join */\ntypedef ulonglong nesting_map;  /* Used for flags of nesting constructs */\n\n#if defined(_WIN32)\n#define socket_errno\tWSAGetLastError()\n#define SOCKET_EINTR\tWSAEINTR\n#define SOCKET_EAGAIN\tWSAEINPROGRESS\n#define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK\n#define SOCKET_EADDRINUSE WSAEADDRINUSE\n#define SOCKET_ETIMEDOUT WSAETIMEDOUT\n#define SOCKET_ECONNRESET WSAECONNRESET\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#else /* Unix */\n#define socket_errno\terrno\n#define closesocket(A)\tclose(A)\n#define SOCKET_EINTR\tEINTR\n#define SOCKET_EAGAIN\tEAGAIN\n#define SOCKET_EWOULDBLOCK EWOULDBLOCK\n#define SOCKET_EADDRINUSE EADDRINUSE\n#define SOCKET_ETIMEDOUT ETIMEDOUT\n#define SOCKET_ECONNRESET ECONNRESET\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#endif\n\ntypedef int\t\tmyf;\t/* Type of MyFlags in my_funcs */\ntypedef char\t\tmy_bool; /* Small bool */\n\n/* Macros for converting *constants* to the right type */\n#define MYF(v)\t\t(myf) (v)\n\n/* Some helper macros */\n#define YESNO(X) ((X) ? \"yes\" : \"no\")\n\n#define MY_HOW_OFTEN_TO_WRITE\t1000\t/* How often we want info on screen */\n\n#include <my_byteorder.h>\n\n#ifdef HAVE_CHARSET_utf8\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET \"utf8\"\n#else\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET MYSQL_DEFAULT_CHARSET_NAME\n#endif\n\n#if defined(_WIN32)\n#define dlsym(lib, name) (void*)GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#ifndef HAVE_DLOPEN\n#define HAVE_DLOPEN\n#endif\n#define DLERROR_GENERATE(errmsg, error_number) \\\n  char win_errormsg[2048]; \\\n  if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, \\\n                   0, error_number, 0, win_errormsg, 2048, NULL)) \\\n  { \\\n    char *ptr; \\\n    for (ptr= &win_errormsg[0] + strlen(win_errormsg) - 1; \\\n         ptr >= &win_errormsg[0] && strchr(\"\\r\\n\\t\\0x20\", *ptr); \\\n         ptr--) \\\n      *ptr= 0; \\\n    errmsg= win_errormsg; \\\n  } \\\n  else \\\n    errmsg= \"\"\n#define dlerror() \"\"\n#define dlopen_errno GetLastError()\n\n#else /* _WIN32 */\n#define DLERROR_GENERATE(errmsg, error_number) errmsg= dlerror()\n#define dlopen_errno errno\n#endif /* _WIN32 */\n\n/* Length of decimal number represented by INT32. */\n#define MY_INT32_NUM_DECIMAL_DIGITS 11U\n\n/* Length of decimal number represented by INT64. */\n#define MY_INT64_NUM_DECIMAL_DIGITS 21U\n\n/* Define some useful general macros (should be done after all headers). */\n#define MY_MAX(a, b)\t((a) > (b) ? (a) : (b))\n#define MY_MIN(a, b)\t((a) < (b) ? (a) : (b))\n\n#if !defined(__cplusplus) && !defined(bool)\n#define bool In_C_you_should_use_my_bool_instead()\n#endif\n\n/* \n  MYSQL_PLUGIN_IMPORT macro is used to export mysqld data\n  (i.e variables) for usage in storage engine loadable plugins.\n  Outside of Windows, it is dummy.\n*/\n#if (defined(_WIN32) && defined(MYSQL_DYNAMIC_PLUGIN))\n#define MYSQL_PLUGIN_IMPORT __declspec(dllimport)\n#else\n#define MYSQL_PLUGIN_IMPORT\n#endif\n\n#include <my_dbug.h>\n\n#ifdef EMBEDDED_LIBRARY\n#define NO_EMBEDDED_ACCESS_CHECKS\n/* Things we don't need in the embedded version of MySQL */\n#undef HAVE_OPENSSL\n#endif /* EMBEDDED_LIBRARY */\n\n\nenum loglevel {\n   ERROR_LEVEL=       0,\n   WARNING_LEVEL=     1,\n   INFORMATION_LEVEL= 2\n};\n\n\n#ifdef _WIN32\n/****************************************************************************\n** Replacements for localtime_r and gmtime_r\n****************************************************************************/\n\nstatic inline struct tm *localtime_r(const time_t *timep, struct tm *tmp)\n{\n  localtime_s(tmp, timep);\n  return tmp;\n}\n\nstatic inline struct tm *gmtime_r(const time_t *clock, struct tm *res)\n{\n  gmtime_s(res, clock);\n  return res;\n}\n#endif /* _WIN32 */\n\n#ifndef HAVE_STRUCT_TIMESPEC /* Windows before VS2015 */\n/*\n  Declare a union to make sure FILETIME is properly aligned\n  so it can be used directly as a 64 bit value. The value\n  stored is in 100ns units.\n*/\nunion ft64 {\n  FILETIME ft;\n  __int64 i64;\n };\n\nstruct timespec {\n  union ft64 tv;\n  /* The max timeout value in millisecond for native_cond_timedwait */\n  long max_timeout_msec;\n};\n\n#endif /* !HAVE_STRUCT_TIMESPEC */\n\nC_MODE_START\nextern ulonglong my_getsystime(void);\nC_MODE_END\n\nstatic inline void set_timespec_nsec(struct timespec *abstime, ulonglong nsec)\n{\n#ifdef HAVE_STRUCT_TIMESPEC\n  ulonglong now= my_getsystime() + (nsec / 100);\n  ulonglong tv_sec= now / 10000000ULL;\n#if SIZEOF_TIME_T < SIZEOF_LONG_LONG\n  /* Ensure that the number of seconds don't overflow. */\n  tv_sec= MY_MIN(tv_sec, ((ulonglong)INT_MAX32));\n#endif\n  abstime->tv_sec=  (time_t)tv_sec;\n  abstime->tv_nsec= (now % 10000000ULL) * 100 + (nsec % 100);\n#else /* !HAVE_STRUCT_TIMESPEC */\n  ulonglong max_timeout_msec= (nsec / 1000000);\n  union ft64 tv;\n  GetSystemTimeAsFileTime(&tv.ft);\n  abstime->tv.i64= tv.i64 + (__int64)(nsec / 100);\n#if SIZEOF_LONG < SIZEOF_LONG_LONG\n  /* Ensure that the msec value doesn't overflow. */\n  max_timeout_msec= MY_MIN(max_timeout_msec, ((ulonglong)INT_MAX32));\n#endif\n  abstime->max_timeout_msec= (long)max_timeout_msec;\n#endif /* !HAVE_STRUCT_TIMESPEC */\n}\n\nstatic inline void set_timespec(struct timespec *abstime, ulonglong sec)\n{\n  set_timespec_nsec(abstime, sec * 1000000000ULL);\n}\n\n/**\n   Compare two timespec structs.\n\n   @retval  1 If ts1 ends after ts2.\n   @retval -1 If ts1 ends before ts2.\n   @retval  0 If ts1 is equal to ts2.\n*/\nstatic inline int cmp_timespec(struct timespec *ts1, struct timespec *ts2)\n{\n#ifdef HAVE_STRUCT_TIMESPEC\n  if (ts1->tv_sec > ts2->tv_sec ||\n      (ts1->tv_sec == ts2->tv_sec && ts1->tv_nsec > ts2->tv_nsec))\n    return 1;\n  if (ts1->tv_sec < ts2->tv_sec ||\n      (ts1->tv_sec == ts2->tv_sec && ts1->tv_nsec < ts2->tv_nsec))\n    return -1;\n#else\n  if (ts1->tv.i64 > ts2->tv.i64)\n    return 1;\n  if (ts1->tv.i64 < ts2->tv.i64)\n    return -1;\n#endif\n  return 0;\n}\n\nstatic inline ulonglong diff_timespec(struct timespec *ts1, struct timespec *ts2)\n{\n#ifdef HAVE_STRUCT_TIMESPEC\n  return (ts1->tv_sec - ts2->tv_sec) * 1000000000ULL +\n    ts1->tv_nsec - ts2->tv_nsec;\n#else\n  return (ts1->tv.i64 - ts2->tv.i64) * 100;\n#endif\n}\n\n#ifdef _WIN32\ntypedef int MY_MODE;\n#else\ntypedef mode_t MY_MODE;\n#endif /* _WIN32 */\n\n/* File permissions */\n#define USER_READ       (1L << 0)\n#define USER_WRITE      (1L << 1)\n#define USER_EXECUTE    (1L << 2)\n#define GROUP_READ      (1L << 3)\n#define GROUP_WRITE     (1L << 4)\n#define GROUP_EXECUTE   (1L << 5)\n#define OTHERS_READ     (1L << 6)\n#define OTHERS_WRITE    (1L << 7)\n#define OTHERS_EXECUTE  (1L << 8)\n#define USER_RWX        USER_READ | USER_WRITE | USER_EXECUTE\n#define GROUP_RWX       GROUP_READ | GROUP_WRITE | GROUP_EXECUTE\n#define OTHERS_RWX      OTHERS_READ | OTHERS_WRITE | OTHERS_EXECUTE\n\n/* Defaults */\n#define DEFAULT_SSL_CA_CERT     \"ca.pem\"\n#define DEFAULT_SSL_CA_KEY      \"ca-key.pem\"\n#define DEFAULT_SSL_SERVER_CERT \"server-cert.pem\"\n#define DEFAULT_SSL_SERVER_KEY  \"server-key.pem\"\n\n#if defined(_WIN32) || defined(_WIN64)\n  #define strcasecmp _stricmp\n#endif\n#endif  // MY_GLOBAL_INCLUDED\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/plugin/innodb_memcached/daemon_memcached/daemon/memcached.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       http://www.danga.com/memcached/\n *  Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *  This file was modified by Oracle on 28-08-2015 and 23-03-2016.\n *  Modifications copyright (c) 2015, 2016, Oracle and/or its affiliates.\n *  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n */\n#include \"config.h\"\n#include \"config_static.h\"\n#include \"memcached.h\"\n#include \"memcached/extension_loggers.h\"\n#include \"utilities/engine_loader.h\"\n\n#include <signal.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <dlfcn.h>\n\n#include \"memcached_mysql.h\"\n\n#define INNODB_MEMCACHED\n\nstatic inline void item_set_cas(const void *cookie, item *it, uint64_t cas) {\n    settings.engine.v1->item_set_cas(settings.engine.v0, cookie, it, cas);\n}\n\n/* The item must always be called \"it\" */\n#define SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_stats[info.clsid].slab_op++;\n\n#define THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->thread_op++;\n\n#define THREAD_GUTS2(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_op++; \\\n    thread_stats->thread_op++;\n\n#define SLAB_THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    THREAD_GUTS(conn, thread_stats, slab_op, thread_op)\n\n#define STATS_INCR1(GUTS, conn, slab_op, thread_op, key, nkey) { \\\n    struct independent_stats *independent_stats = get_independent_stats(conn); \\\n    struct thread_stats *thread_stats = \\\n        &independent_stats->thread_stats[conn->thread->index]; \\\n    topkeys_t *topkeys = independent_stats->topkeys; \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    GUTS(conn, thread_stats, slab_op, thread_op); \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n    TK(topkeys, slab_op, key, nkey, current_time); \\\n}\n\n#define STATS_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS, conn, op, op, key, nkey)\n\n#define SLAB_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(SLAB_GUTS, conn, op, op, key, nkey)\n\n#define STATS_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS2, conn, slab_op, thread_op, key, nkey)\n\n#define SLAB_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(SLAB_THREAD_GUTS, conn, slab_op, thread_op, key, nkey)\n\n#define STATS_HIT(conn, op, key, nkey) \\\n    SLAB_TWO(conn, op##_hits, cmd_##op, key, nkey)\n\n#define STATS_MISS(conn, op, key, nkey) \\\n    STATS_TWO(conn, op##_misses, cmd_##op, key, nkey)\n\n#if defined(HAVE_GCC_SYNC_BUILTINS)\n\n#define STATS_NOKEY(conn, op)\t\\\ndo { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n\t__sync_add_and_fetch(&thread_stats->op, 1); \\\n} while (0)\n\n#define STATS_NOKEY2(conn, op1, op2)\t\\\ndo { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n\t__sync_add_and_fetch(&thread_stats->op1, 1); \\\n\t__sync_add_and_fetch(&thread_stats->op2, 1); \\\n} while (0)\n\n#define STATS_ADD(conn, op, amt)\t\\\ndo { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n\t__sync_add_and_fetch(&thread_stats->op, amt); \\\n} while (0)\n\n#define MEMCACHED_ATOMIC_MSG\t\"InnoDB MEMCACHED: Memcached uses atomic increment \\n\"\n\n#else /* HAVE_GCC_SYNC_BUILTINS */\n#define STATS_NOKEY(conn, op) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_NOKEY2(conn, op1, op2) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op1++; \\\n    thread_stats->op2++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_ADD(conn, op, amt) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op += amt; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define MEMCACHED_ATOMIC_MSG\t\"InnoDB Memcached: Memcached DOES NOT use atomic increment\"\n#endif /* HAVE_GCC_SYNC_BUILTINS */\n\nvolatile sig_atomic_t memcached_shutdown;\nvolatile sig_atomic_t memcached_initialized;\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\n\n/*\n * forward declarations\n */\nstatic SOCKET new_socket(struct addrinfo *ai);\nstatic int try_read_command(conn *c);\nstatic inline struct independent_stats *get_independent_stats(conn *c);\nstatic inline struct thread_stats *get_thread_stats(conn *c);\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data);\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occured (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\n\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void complete_nread(conn *c);\nstatic char *process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic int ensure_iov_space(conn *c);\nstatic int add_iov(conn *c, const void *buf, int len);\nstatic int add_msghdr(conn *c);\n\n\n/* time handling */\nstatic void set_current_time(void);  /* update the global variable holding\n                              global 32-bit seconds-since-start time\n                              (to avoid 64 bit time_t) */\n\n/** exported globals **/\nstruct stats stats;\nstruct settings settings;\nstatic time_t process_started;     /* when the process was started */\n\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic int  udp_socket[100];\nstatic int  num_udp_socket;\nstatic struct event_base *main_base;\nstatic struct independent_stats *default_independent_stats;\n\nstatic struct engine_event_handler *engine_event_handlers[MAX_ENGINE_EVENT_TYPE + 1];\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\nstatic enum transmit_result transmit(conn *c);\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n// Perform all callbacks of a given type for the given connection.\nstatic void perform_callbacks(ENGINE_EVENT_TYPE type,\n                              const void *data,\n                              const void *c) {\n    for (struct engine_event_handler *h = engine_event_handlers[type];\n         h; h = h->next) {\n        h->cb(c, type, data, h->cb_data);\n    }\n}\n\n/*\n * given time value that's either unix time or delta from current unix time,\n * return unix time. Use the fact that delta can't exceed one month\n * (and real time value can't be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\n/**\n * Convert the relative time to an absolute time (relative to EPOC ;) )\n */\nstatic time_t abstime(const rel_time_t exptime)\n{\n    return process_started + exptime;\n}\n\nstatic void stats_init(void) {\n    stats.daemon_conns = 0;\n    stats.rejected_conns = 0;\n    stats.curr_conns = stats.total_conns = stats.conn_structs = 0;\n\n    stats_prefix_init();\n}\n\nstatic void stats_reset(const void *cookie) {\n    struct conn *conn = (struct conn*)cookie;\n    STATS_LOCK();\n    stats.rejected_conns = 0;\n    stats.total_conns = 0;\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset(get_independent_stats(conn)->thread_stats);\n    settings.engine.v1->reset_stats(settings.engine.v0, cookie);\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1000;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.allow_detailed = true;\n    settings.reqs_per_event = DEFAULT_REQS_PER_EVENT;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n    settings.topkeys = 0;\n    settings.require_sasl = false;\n    settings.extensions.logger = get_stderr_logger();\n}\n\n/*\n * Adds a message header to a connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int add_msghdr(conn *c)\n{\n    struct msghdr *msg;\n\n    assert(c != NULL);\n\n    if (c->msgsize == c->msgused) {\n        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));\n        if (! msg)\n            return -1;\n        c->msglist = msg;\n        c->msgsize *= 2;\n    }\n\n    msg = c->msglist + c->msgused;\n\n    /* this wipes msg_iovlen, msg_control, msg_controllen, and\n       msg_flags, the last 3 of which aren't defined on solaris: */\n    memset(msg, 0, sizeof(struct msghdr));\n\n    msg->msg_iov = &c->iov[c->iovused];\n\n    if (c->request_addr_size > 0) {\n        msg->msg_name = &c->request_addr;\n        msg->msg_namelen = c->request_addr_size;\n    }\n\n    c->msgbytes = 0;\n    c->msgused++;\n\n    if (IS_UDP(c->transport)) {\n        /* Leave room for the UDP header, which we'll fill in later. */\n        return add_iov(c, NULL, UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nstruct {\n    pthread_mutex_t mutex;\n    bool disabled;\n    ssize_t count;\n    uint64_t num_disable;\n} listen_state;\n\nstatic bool is_listen_disabled(void) {\n    bool ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.disabled;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic uint64_t get_listen_disabled_num(void) {\n    uint64_t ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic void disable_listen(void) {\n    pthread_mutex_lock(&listen_state.mutex);\n    listen_state.disabled = true;\n    listen_state.count = 10;\n    ++listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n\n    conn *next;\n    for (next = listen_conn; next; next = next->next) {\n        update_event(next, 0);\n        if (listen(next->sfd, 1) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"listen() failed\",\n                                            strerror(errno));\n        }\n    }\n}\n\nvoid safe_close(SOCKET sfd) {\n    if (sfd != INVALID_SOCKET) {\n        int rval;\n        while ((rval = closesocket(sfd)) == SOCKET_ERROR &&\n               (errno == EINTR || errno == EAGAIN)) {\n            /* go ahead and retry */\n        }\n\n        if (rval == SOCKET_ERROR) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to close socket %d (%s)!!\\n\", (int)sfd,\n                                            strerror(errno));\n        } else {\n            STATS_LOCK();\n            stats.curr_conns--;\n            STATS_UNLOCK();\n\n            if (is_listen_disabled()) {\n                notify_dispatcher();\n            }\n        }\n    }\n}\n\n/*\n * Free list management for connections.\n */\ncache_t *conn_cache;      /* suffix cache */\n\n/**\n * Reset all of the dynamic buffers used by a connection back to their\n * default sizes. The strategy for resizing the buffers is to allocate a\n * new one of the correct size and free the old one if the allocation succeeds\n * instead of using realloc to change the buffer size (because realloc may\n * not shrink the buffers, and will also copy the memory). If the allocation\n * fails the buffer will be unchanged.\n *\n * @param c the connection to resize the buffers for\n * @return true if all allocations succeeded, false if one or more of the\n *         allocations failed.\n */\nstatic bool conn_reset_buffersize(conn *c) {\n    bool ret = true;\n\n    if (c->rsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->rbuf);\n            c->rbuf = ptr;\n            c->rsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->wsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->wbuf);\n            c->wbuf = ptr;\n            c->wsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->isize != ITEM_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(item *) * ITEM_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->ilist);\n            c->ilist = ptr;\n            c->isize = ITEM_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->suffixsize != SUFFIX_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(char *) * SUFFIX_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->suffixlist);\n            c->suffixlist = ptr;\n            c->suffixsize = SUFFIX_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->iovsize != IOV_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct iovec) * IOV_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->iov);\n            c->iov = ptr;\n            c->iovsize = IOV_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->msgsize != MSG_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct msghdr) * MSG_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->msglist);\n            c->msglist = ptr;\n            c->msgsize = MSG_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    return ret;\n}\n\n/**\n * Constructor for all memory allocations of connection objects. Initialize\n * all members and allocate the transfer buffers.\n *\n * @param buffer The memory allocated by the object cache\n * @param unused1 not used\n * @param unused2 not used\n * @return 0 on success, 1 if we failed to allocate memory\n */\nstatic int conn_constructor(void *buffer, void *unused1, int unused2) {\n    (void)unused1; (void)unused2;\n\n    conn *c = buffer;\n    memset(c, 0, sizeof(*c));\n    MEMCACHED_CONN_CREATE(c);\n\n    if (!conn_reset_buffersize(c)) {\n        free(c->rbuf);\n        free(c->wbuf);\n        free(c->ilist);\n        free(c->suffixlist);\n        free(c->iov);\n        free(c->msglist);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to allocate buffers for connection\\n\");\n        return 1;\n    }\n\n    STATS_LOCK();\n    stats.conn_structs++;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\n/**\n * Destructor for all connection objects. Release all allocated resources.\n *\n * @param buffer The memory allocated by the objec cache\n * @param unused not used\n */\nstatic void conn_destructor(void *buffer, void *unused) {\n    (void)unused;\n    conn *c = buffer;\n    free(c->rbuf);\n    free(c->wbuf);\n    free(c->ilist);\n    free(c->suffixlist);\n    free(c->iov);\n    free(c->msglist);\n\n    STATS_LOCK();\n    stats.conn_structs--;\n    STATS_UNLOCK();\n}\n\nconn *conn_new(const SOCKET sfd, STATE_FUNC init_state,\n               const int event_flags,\n               const int read_buffer_size, enum network_transport transport,\n               struct event_base *base, struct timeval *timeout) {\n    conn *c = cache_alloc(conn_cache);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    assert(c->thread == NULL);\n\n    if (c->rsize < read_buffer_size) {\n        void *mem = malloc(read_buffer_size);\n        if (mem) {\n            c->rsize = read_buffer_size;\n            free(c->rbuf);\n            c->rbuf = mem;\n        } else {\n            assert(c->thread == NULL);\n            cache_free(conn_cache, c);\n            return NULL;\n        }\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    /* unix socket mode doesn't need this, so zeroed out.  but why\n     * is this done for every command?  presumably for UDP\n     * mode.  */\n    if (!settings.socketpath) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (%s)\\n\", sfd,\n                                            prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new auto-negotiating client connection\\n\",\n                                            sfd);\n        } else if (c->protocol == ascii_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new unknown (%d) client connection\\n\",\n                                            sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->sfd = sfd;\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->ascii_cmd = NULL;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->next = NULL;\n    c->list_state = 0;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (!register_event(c, timeout)) {\n        assert(c->thread == NULL);\n        cache_free(conn_cache, c);\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    c->refcount = 1;\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    perform_callbacks(ON_CONNECT, NULL, c);\n\n    return c;\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n\n    if (c->ileft != 0) {\n        for (; c->ileft > 0; c->ileft--,c->icurr++) {\n            settings.engine.v1->release(settings.engine.v0, c, *(c->icurr));\n        }\n    }\n\n    if (c->suffixleft != 0) {\n        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {\n            cache_free(c->thread->suffix_cache, *(c->suffixcurr));\n        }\n    }\n\n    if (c->write_and_free) {\n        free(c->write_and_free);\n        c->write_and_free = 0;\n    }\n\n    if (c->sasl_conn) {\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n\n    if (c->engine_storage) {\n\tsettings.engine.v1->clean_engine(settings.engine.v0, c,\n\t\t\t\t\t c->engine_storage);\n    }\n\n    c->engine_storage = NULL;\n    c->tap_iterator = NULL;\n    c->thread = NULL;\n    assert(c->next == NULL);\n    c->ascii_cmd = NULL;\n    c->sfd = INVALID_SOCKET;\n    c->tap_nack_mode = false;\n}\n\nvoid conn_close(conn *c) {\n    assert(c != NULL);\n    assert(c->sfd == INVALID_SOCKET);\n\n    if (c->ascii_cmd != NULL) {\n        c->ascii_cmd->abort(c->ascii_cmd, c);\n    }\n\n    assert(c->thread);\n    LOCK_THREAD(c->thread);\n    /* remove from pending-io list */\n    if (settings.verbose > 1 && list_contains(c->thread->pending_io, c)) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Current connection was in the pending-io list.. Nuking it\\n\");\n    }\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    c->thread->pending_close = list_remove(c->thread->pending_close, c);\n    UNLOCK_THREAD(c->thread);\n\n    conn_cleanup(c);\n\n    /*\n     * The contract with the object cache is that we should return the\n     * object in a constructed state. Reset the buffers to the default\n     * size\n     */\n    conn_reset_buffersize(c);\n    assert(c->thread == NULL);\n    cache_free(conn_cache, c);\n}\n\n/*\n * Shrinks a connection's buffers if they're too big.  This prevents\n * periodic large \"get\" requests from permanently chewing lots of server\n * memory.\n *\n * This should only be called in between requests since it can wipe output\n * buffers!\n */\nstatic void conn_shrink(conn *c) {\n    assert(c != NULL);\n\n    if (IS_UDP(c->transport))\n        return;\n\n    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {\n        char *newbuf;\n\n        if (c->rcurr != c->rbuf)\n            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);\n\n        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);\n\n        if (newbuf) {\n            c->rbuf = newbuf;\n            c->rsize = DATA_BUFFER_SIZE;\n        }\n        /* TODO check other branch... */\n        c->rcurr = c->rbuf;\n    }\n\n    if (c->isize > ITEM_LIST_HIGHWAT) {\n        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));\n        if (newbuf) {\n            c->ilist = newbuf;\n            c->isize = ITEM_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->msgsize > MSG_LIST_HIGHWAT) {\n        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));\n        if (newbuf) {\n            c->msglist = newbuf;\n            c->msgsize = MSG_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->iovsize > IOV_LIST_HIGHWAT) {\n        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));\n        if (newbuf) {\n            c->iov = newbuf;\n            c->iovsize = IOV_LIST_INITIAL;\n        }\n    /* TODO check return value */\n    }\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nconst char *state_text(STATE_FUNC state) {\n    if (state == conn_listening) {\n        return \"conn_listening\";\n    } else if (state == conn_new_cmd) {\n        return \"conn_new_cmd\";\n    } else if (state == conn_waiting) {\n        return \"conn_waiting\";\n    } else if (state == conn_read) {\n        return \"conn_read\";\n    } else if (state == conn_parse_cmd) {\n        return \"conn_parse_cmd\";\n    } else if (state == conn_write) {\n        return \"conn_write\";\n    } else if (state == conn_nread) {\n        return \"conn_nread\";\n    } else if (state == conn_swallow) {\n        return \"conn_swallow\";\n    } else if (state == conn_closing) {\n        return \"conn_closing\";\n    } else if (state == conn_mwrite) {\n        return \"conn_mwrite\";\n    } else if (state == conn_ship_log) {\n        return \"conn_ship_log\";\n    } else if (state == conn_add_tap_client) {\n        return \"conn_add_tap_client\";\n    } else if (state == conn_setup_tap_stream) {\n        return \"conn_setup_tap_stream\";\n    } else if (state == conn_pending_close) {\n        return \"conn_pending_close\";\n    } else if (state == conn_immediate_close) {\n        return \"conn_immediate_close\";\n    } else {\n        return \"Unknown\";\n    }\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nvoid conn_set_state(conn *c, STATE_FUNC state) {\n    assert(c != NULL);\n\n    if (state != c->state) {\n        /*\n         * The connections in the \"tap thread\" behaves differently than\n         * normal connections because they operate in a full duplex mode.\n         * New messages may appear from both sides, so we can't block on\n         * read from the nework / engine\n         */\n        if (c->thread == tap_thread) {\n            if (state == conn_waiting) {\n                c->which = EV_WRITE;\n                state = conn_ship_log;\n            }\n        }\n\n        if (settings.verbose > 2 || c->state == conn_closing\n            || c->state == conn_add_tap_client) {\n            settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                            \"%d: going from %s to %s\\n\",\n                                            c->sfd, state_text(c->state),\n                                            state_text(state));\n        }\n\n        c->state = state;\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);\n        }\n    }\n}\n\n/*\n * Ensures that there is room for another struct iovec in a connection's\n * iov list.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int ensure_iov_space(conn *c) {\n    assert(c != NULL);\n\n    if (c->iovused >= c->iovsize) {\n        int i, iovnum;\n        struct iovec *new_iov = (struct iovec *)realloc(c->iov,\n                                (c->iovsize * 2) * sizeof(struct iovec));\n        if (! new_iov)\n            return -1;\n        c->iov = new_iov;\n        c->iovsize *= 2;\n\n        /* Point all the msghdr structures at the new list. */\n        for (i = 0, iovnum = 0; i < c->msgused; i++) {\n            c->msglist[i].msg_iov = &c->iov[iovnum];\n            iovnum += c->msglist[i].msg_iovlen;\n        }\n    }\n\n    return 0;\n}\n\n\n/*\n * Adds data to the list of pending data that will be written out to a\n * connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\n\nstatic int add_iov(conn *c, const void *buf, int len) {\n    struct msghdr *m;\n    int leftover;\n    bool limit_to_mtu;\n\n    assert(c != NULL);\n\n    do {\n        m = &c->msglist[c->msgused - 1];\n\n        /*\n         * Limit UDP packets, and the first payloads of TCP replies, to\n         * UDP_MAX_PAYLOAD_SIZE bytes.\n         */\n        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);\n\n        /* We may need to start a new msghdr if this one is full. */\n        if (m->msg_iovlen == IOV_MAX ||\n            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {\n            add_msghdr(c);\n            m = &c->msglist[c->msgused - 1];\n        }\n\n        if (ensure_iov_space(c) != 0)\n            return -1;\n\n        /* If the fragment is too big to fit in the datagram, split it up */\n        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {\n            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;\n            len -= leftover;\n        } else {\n            leftover = 0;\n        }\n\n        m = &c->msglist[c->msgused - 1];\n        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;\n        m->msg_iov[m->msg_iovlen].iov_len = len;\n\n        c->msgbytes += len;\n        c->iovused++;\n        m->msg_iovlen++;\n\n        buf = ((char *)buf) + len;\n        len = leftover;\n    } while (leftover > 0);\n\n    return 0;\n}\n\n\n/*\n * Constructs a set of UDP headers and attaches them to the outgoing messages.\n */\nstatic int build_udp_headers(conn *c) {\n    int i;\n    unsigned char *hdr;\n\n    assert(c != NULL);\n\n    if (c->msgused > c->hdrsize) {\n        void *new_hdrbuf;\n        if (c->hdrbuf)\n            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);\n        else\n            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);\n        if (! new_hdrbuf)\n            return -1;\n        c->hdrbuf = (unsigned char *)new_hdrbuf;\n        c->hdrsize = c->msgused * 2;\n    }\n\n    hdr = c->hdrbuf;\n    for (i = 0; i < c->msgused; i++) {\n        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;\n        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;\n        *hdr++ = c->request_id / 256;\n        *hdr++ = c->request_id % 256;\n        *hdr++ = i / 256;\n        *hdr++ = i % 256;\n        *hdr++ = c->msgused / 256;\n        *hdr++ = c->msgused % 256;\n        *hdr++ = 0;\n        *hdr++ = 0;\n        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n\n    assert(c != NULL);\n\n    if (c->noreply) {\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \">%d NOREPLY %s\\n\", c->sfd, str);\n        }\n        c->noreply = false;\n        if (c->sbytes > 0) {\n            conn_set_state(c, conn_swallow);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n        return;\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d %s\\n\", c->sfd, str);\n    }\n\n    /* Nuke a partial output... */\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    add_msghdr(c);\n\n    len = strlen(str);\n    if ((len + 2) > c->wsize) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(c->wbuf, str, len);\n    memcpy(c->wbuf + len, \"\\r\\n\", 2);\n    c->wbytes = len + 2;\n    c->wcurr = c->wbuf;\n\n    conn_set_state(c, conn_write);\n\n    if (c->sbytes > 0) {\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n\n    return;\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_update_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        out_string(c, \"SERVER_ERROR failed to get item details\");\n        return;\n    }\n\n    c->sbytes = 2; // swallow \\r\\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c, it, &c->cas,\n                                        c->store_op, 0);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->store_op) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_CAS:\n        MEMCACHED_COMMAND_CAS(c->sfd, info.key, info.nkey, info.nbytes, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"STORED\");\n        break;\n    case ENGINE_KEY_EEXISTS:\n        out_string(c, \"EXISTS\");\n        break;\n    case ENGINE_KEY_ENOENT:\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"NOT_STORED\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR invalid arguments\");\n        break;\n    case ENGINE_E2BIG:\n        out_string(c, \"CLIENT_ERROR value too big\");\n        break;\n    case ENGINE_EACCESS:\n        out_string(c, \"CLIENT_ERROR access control violation\");\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        out_string(c, \"SERVER_ERROR not my vbucket\");\n        break;\n    case ENGINE_FAILED:\n        out_string(c, \"SERVER_ERROR failure\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_WANT_MORE:\n        assert(false);\n        c->state = conn_closing;\n        break;\n\n    default:\n        out_string(c, \"SERVER_ERROR internal\");\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\n/**\n * get a pointer to the start of the request struct for the current command\n */\nstatic void* binary_get_request(conn *c) {\n    char *ret = c->rcurr;\n    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +\n            c->binary_header.request.extlen);\n\n    assert(ret >= c->rbuf);\n    return ret;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\n/**\n * Insert a key into a buffer, but replace all non-printable characters\n * with a '.'.\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param key the key to add to the buffer\n * @param nkey the number of bytes in the key\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t key_to_printable_buffer(char *dest, size_t destsz,\n                                       int client, bool from_client,\n                                       const char *prefix,\n                                       const char *key,\n                                       size_t nkey)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s \", from_client ? '>' : '<',\n                          client, prefix);\n    if (nw == -1) {\n        return -1;\n    }\n\n    char *ptr = dest + nw;\n    destsz -= nw;\n    if (nkey > destsz) {\n        nkey = destsz;\n    }\n\n    for (ssize_t ii = 0; ii < nkey; ++ii, ++key, ++ptr) {\n        if (isgraph(*key)) {\n            *ptr = *key;\n        } else {\n            *ptr = '.';\n        }\n    }\n\n    *ptr = '\\0';\n    return ptr - dest;\n}\n\n/**\n * Convert a byte array to a text string\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param data the data to add to the buffer\n * @param size the number of bytes in data to print\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t bytes_to_output_string(char *dest, size_t destsz,\n                                      int client, bool from_client,\n                                      const char *prefix,\n                                      const char *data,\n                                      size_t size)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s\", from_client ? '>' : '<',\n                          client, prefix);\n    if (nw == -1) {\n        return -1;\n    }\n    ssize_t offset = nw;\n\n    for (ssize_t ii = 0; ii < size; ++ii) {\n        if (ii % 4 == 0) {\n            if ((nw = snprintf(dest + offset, destsz - offset, \"\\n%c%d  \",\n                               from_client ? '>' : '<', client)) == -1) {\n                return  -1;\n            }\n            offset += nw;\n        }\n        if ((nw = snprintf(dest + offset, destsz - offset,\n                           \" 0x%02x\", (unsigned char)data[ii])) == -1) {\n            return -1;\n        }\n        offset += nw;\n    }\n\n    if ((nw = snprintf(dest + offset, destsz - offset, \"\\n\")) == -1) {\n        return -1;\n    }\n\n    return offset + nw;\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n\n    assert(c);\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        /* XXX:  out_string is inappropriate here */\n        out_string(c, \"SERVER_ERROR out of memory\");\n        return;\n    }\n\n    header = (protocol_binary_response_header *)c->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (bytes_to_output_string(buffer, sizeof(buffer), c->sfd, false,\n                                   \"Writing bin response:\",\n                                   (const char*)header->bytes,\n                                   sizeof(header->bytes)) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%s\", buffer);\n        }\n    }\n\n    add_iov(c, c->wbuf, sizeof(header->response));\n}\n\n/**\n * Convert an error code generated from the storage engine to the corresponding\n * error code used by the protocol layer.\n * @param e the error code as used in the engine\n * @return the error code as used by the protocol layer\n */\nstatic protocol_binary_response_status engine_error_2_protocol_error(ENGINE_ERROR_CODE e) {\n    protocol_binary_response_status ret;\n\n    switch (e) {\n    case ENGINE_SUCCESS:\n        return PROTOCOL_BINARY_RESPONSE_SUCCESS;\n    case ENGINE_KEY_ENOENT:\n        return PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n    case ENGINE_KEY_EEXISTS:\n        return PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n    case ENGINE_ENOMEM:\n        return PROTOCOL_BINARY_RESPONSE_ENOMEM;\n    case ENGINE_TMPFAIL:\n        return PROTOCOL_BINARY_RESPONSE_ETMPFAIL;\n    case ENGINE_NOT_STORED:\n        return PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n    case ENGINE_EINVAL:\n        return PROTOCOL_BINARY_RESPONSE_EINVAL;\n    case ENGINE_ENOTSUP:\n        return PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED;\n    case ENGINE_E2BIG:\n        return PROTOCOL_BINARY_RESPONSE_E2BIG;\n    case ENGINE_NOT_MY_VBUCKET:\n        return PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET;\n    default:\n        ret = PROTOCOL_BINARY_RESPONSE_EINTERNAL;\n    }\n\n    return ret;\n}\n\nstatic void write_bin_packet(conn *c, protocol_binary_response_status err, int swallow) {\n    ssize_t len;\n    char buffer[1024] = { [sizeof(buffer) - 1] = '\\0' };\n\n    switch (err) {\n    case PROTOCOL_BINARY_RESPONSE_SUCCESS:\n        len = 0;\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n        len = snprintf(buffer, sizeof(buffer), \"Out of memory\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ETMPFAIL:\n        len = snprintf(buffer, sizeof(buffer), \"Temporary failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n        len = snprintf(buffer, sizeof(buffer), \"Unknown command\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n        len = snprintf(buffer, sizeof(buffer), \"Not found\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n        len = snprintf(buffer, sizeof(buffer), \"Invalid arguments\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n        len = snprintf(buffer, sizeof(buffer), \"Data exists for key\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n        len = snprintf(buffer, sizeof(buffer), \"Too large\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"Non-numeric server-side value for incr or decr\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n        len = snprintf(buffer, sizeof(buffer), \"Not stored\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n        len = snprintf(buffer, sizeof(buffer), \"Auth failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED:\n        len = snprintf(buffer, sizeof(buffer), \"Not supported\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"I'm not responsible for this vbucket\");\n        break;\n\n    default:\n        len = snprintf(buffer, sizeof(buffer), \"UNHANDLED ERROR (%d)\", err);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n    }\n\n    /* Allow the engine to pass extra error information */\n    if (settings.engine.v1->errinfo != NULL) {\n        size_t elen = settings.engine.v1->errinfo(settings.engine.v0, c, buffer + len + 2,\n                                                  sizeof(buffer) - len - 3);\n\n        if (elen > 0) {\n            memcpy(buffer + len, \": \", 2);\n            len += elen + 2;\n        }\n    }\n\n    if (err != PROTOCOL_BINARY_RESPONSE_SUCCESS && settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d Writing an error: %s\\n\", c->sfd,\n                                        buffer);\n    }\n\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        add_iov(c, buffer, len);\n    }\n    conn_set_state(c, conn_mwrite);\n    if (swallow > 0) {\n        c->sbytes = swallow;\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        if(dlen > 0) {\n            add_iov(c, d, dlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        conn_set_state(c, conn_new_cmd);\n    }\n}\n\n\nstatic void complete_incr_bin(conn *c) {\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;\n    protocol_binary_request_incr* req = binary_get_request(c);\n\n    assert(c != NULL);\n    assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    uint64_t delta = ntohll(req->message.body.delta);\n    uint64_t initial = ntohll(req->message.body.initial);\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n    char *key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n    bool incr = (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT ||\n                 c->cmd == PROTOCOL_BINARY_CMD_INCREMENTQ);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        ssize_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     incr ? \"INCR\" : \"DECR\", key, nkey);\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" %\" PRIu64 \", %\" PRIu64 \", %\" PRIu64 \"\\n\",\n                         delta, initial, (uint64_t)expiration) != -1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0,\n                                             c, key, nkey, incr,\n                                             req->message.body.expiration != 0xffffffff,\n                                             delta, initial, expiration,\n                                             &c->cas,\n                                             &rsp->message.body.value,\n                                             c->binary_header.request.vbucket);\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        rsp->message.body.value = htonll(rsp->message.body.value);\n        write_bin_response(c, &rsp->message.body, 0, 0,\n                           sizeof (rsp->message.body.value));\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EINVAL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, 0);\n        break;\n    case ENGINE_NOT_STORED:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n        return;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c,\n                                        it, &c->cas, c->store_op,\n                                        c->binary_header.request.vbucket);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->cmd) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    default:\n        if (c->store_op == OPERATION_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->store_op == OPERATION_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_packet(c, eno, 0);\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\nstatic void process_bin_get(conn *c) {\n    item *it;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"GET\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey,\n                                      c->binary_header.request.vbucket);\n    }\n\n    uint16_t keylen;\n    uint32_t bodylen;\n    item_info info = { .nvalue = 1 };\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to get item info\\n\",\n                                            c->sfd);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            break;\n        }\n\n        keylen = 0;\n        bodylen = sizeof(rsp->message.body) + info.nbytes;\n\n        STATS_HIT(c, get, key, nkey);\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(info.cas);\n\n        // add the flags\n        rsp->message.body.flags = info.flags;\n        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            add_iov(c, info.key, nkey);\n        }\n\n        add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n        conn_set_state(c, conn_mwrite);\n        /* Remember this item so we can garbage collect it later */\n        c->item = it;\n        break;\n    case ENGINE_KEY_ENOENT:\n        STATS_MISS(c, get, key, nkey);\n\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);\n                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                               0, nkey, nkey);\n                memcpy(ofs, key, nkey);\n                add_iov(c, ofs, nkey);\n                conn_set_state(c, conn_mwrite);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            }\n        }\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_TMPFAIL:\n\tbreak;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    default:\n        /* @todo add proper error handling! */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Unknown error code: %d\\n\", ret);\n        abort();\n    }\n\n    if (settings.detail_enabled && ret != ENGINE_EWOULDBLOCK) {\n        stats_prefix_record_get(key, nkey, ret == ENGINE_SUCCESS);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->dynamic_buffer.offset += sizeof(header.response) + bodylen;\n}\n\n/**\n * Append a key-value pair to the stats output buffer. This function assumes\n * that the output buffer is big enough (it will be if you call it through\n * append_stats)\n */\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t nbytes = 5; /* \"END\\r\\n\" or \"STAT \" */\n\n    if (klen == 0 && vlen == 0) {\n        memcpy(pos, \"END\\r\\n\", 5);\n    } else {\n        memcpy(pos, \"STAT \", 5);\n        memcpy(pos + nbytes, key, klen);\n        nbytes += klen;\n        if (vlen != 0) {\n            pos[nbytes] = ' ';\n            ++nbytes;\n            memcpy(pos + nbytes, val, vlen);\n            nbytes += vlen;\n        }\n        memcpy(pos + nbytes, \"\\r\\n\", 2);\n        nbytes += 2;\n    }\n\n    c->dynamic_buffer.offset += nbytes;\n}\n\nstatic bool grow_dynamic_buffer(conn *c, size_t needed) {\n    size_t nsize = c->dynamic_buffer.size;\n    size_t available = nsize - c->dynamic_buffer.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->dynamic_buffer.buffer == NULL) {\n        nsize = 1024;\n        available = c->dynamic_buffer.size = c->dynamic_buffer.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->dynamic_buffer.offset;\n    }\n\n    if (nsize != c->dynamic_buffer.size) {\n        char *ptr = realloc(c->dynamic_buffer.buffer, nsize);\n        if (ptr) {\n            c->dynamic_buffer.buffer = ptr;\n            c->dynamic_buffer.size = nsize;\n        } else {\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                         const char *val, const uint32_t vlen,\n                         const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return ;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->dynamic_buffer.offset <= c->dynamic_buffer.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"STATS\", subcommand, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (nkey == 0) {\n            /* request all statistics */\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, NULL, 0, append_stats);\n            if (ret == ENGINE_SUCCESS) {\n                server_stats(&append_stats, c, false);\n            }\n        } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n            stats_reset(c);\n            settings.engine.v1->reset_stats(settings.engine.v0, c);\n        } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n            process_stat_settings(&append_stats, c);\n        } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n            char *subcmd_pos = subcommand + 6;\n            if (settings.allow_detailed) {\n                if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n                    int len;\n                    char *dump_buf = stats_prefix_dump(&len);\n                    if (dump_buf == NULL || len <= 0) {\n                        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                        return ;\n                    } else {\n                        append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                        free(dump_buf);\n                    }\n                } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n                    settings.detail_enabled = 1;\n                } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n                    settings.detail_enabled = 0;\n                } else {\n                    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                    return;\n                }\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                return;\n            }\n        } else if (strncmp(subcommand, \"aggregate\", 9) == 0) {\n            server_stats(&append_stats, c, true);\n        } else if (strncmp(subcommand, \"topkeys\", 7) == 0) {\n            topkeys_t *tk = get_independent_stats(c)->topkeys;\n            if (tk != NULL) {\n                topkeys_stats(tk, c, current_time, append_stats);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                return;\n            }\n        } else {\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                subcommand, nkey,\n                                                append_stats);\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        append_stats(NULL, 0, NULL, 0, c);\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void bin_read_chunk(conn *c, enum bin_substates next_substate, uint32_t chunk) {\n    assert(c);\n    c->substate = next_substate;\n    c->rlbytes = chunk;\n\n    /* Ok... do we have room for everything in our buffer? */\n    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;\n    if (c->rlbytes > c->rsize - offset) {\n        size_t nsize = c->rsize;\n        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);\n\n        while (size > nsize) {\n            nsize *= 2;\n        }\n\n        if (nsize != c->rsize) {\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"%d: Need to grow buffer from %lu to %lu\\n\",\n                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);\n            }\n            char *newm = realloc(c->rbuf, nsize);\n            if (newm == NULL) {\n                if (settings.verbose) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                            \"%d: Failed to grow buffer.. closing connection\\n\",\n                            c->sfd);\n                }\n                conn_set_state(c, conn_closing);\n                return;\n            }\n\n            c->rbuf= newm;\n            /* rcurr should point to the same offset in the packet */\n            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);\n            c->rsize = nsize;\n        }\n        if (c->rbuf != c->rcurr) {\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n            c->rcurr = c->rbuf;\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: Repack input buffer\\n\",\n                                                c->sfd);\n            }\n        }\n    }\n\n    /* preserve the header in the buffer.. */\n    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);\n    conn_set_state(c, conn_nread);\n}\n\nstatic void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {\n    bin_read_chunk(c, next_substate, c->keylen + extra);\n}\n\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                \"%d: Protocol error (opcode %02x), close connection\\n\",\n                c->sfd, c->binary_header.request.opcode);\n    }\n    c->write_and_go = conn_closing;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL, NULL, NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                         \"%d: Failed to initialize SASL conn.\\n\",\n                         c->sfd);\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void get_auth_data(const void *cookie, auth_data_t *data) {\n    conn *c = (conn*)cookie;\n    if (c->sasl_conn) {\n        sasl_getprop(c->sasl_conn, SASL_USERNAME, (void*)&data->username);\n#ifdef ENABLE_ISASL\n        sasl_getprop(c->sasl_conn, ISASL_CONFIG, (void*)&data->config);\n#endif\n    }\n}\n\n#ifdef SASL_ENABLED\nstatic void bin_list_sasl_mechs(conn *c) {\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                     \"%d: Failed to list SASL mechanisms.\\n\",\n                     c->sfd);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n#endif\n\nstruct sasl_tmp {\n    int ksize;\n    int vsize;\n    char data[]; /* data + ksize == value */\n};\n\nstatic void process_bin_sasl_auth(conn *c) {\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    size_t buffer_size = sizeof(struct sasl_tmp) + nkey + vlen + 2;\n    struct sasl_tmp *data = calloc(sizeof(struct sasl_tmp) + buffer_size, 1);\n    if (!data) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    data->ksize = nkey;\n    data->vsize = vlen;\n    memcpy(data->data, key, nkey);\n\n    c->item = data;\n    c->ritem = data->data + nkey;\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    struct sasl_tmp *stmp = c->item;\n    char mech[nkey+1];\n    memcpy(mech, stmp->data, nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: mech: ``%s'' with %d bytes of data\\n\", c->sfd, mech, vlen);\n    }\n\n    const char *challenge = vlen == 0 ? NULL : (stmp->data + nkey);\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                    \"%d: Unhandled command %d with challenge %s\\n\",\n                    c->sfd, c->cmd, challenge);\n        }\n        break;\n    }\n\n    free(c->item);\n    c->item = NULL;\n    c->ritem = NULL;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"%d: sasl result code:  %d\\n\",\n                                        c->sfd, result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        auth_data_t data;\n        get_auth_data(c, &data);\n        perform_callbacks(ON_AUTH, (const void*)&data, c);\n        STATS_NOKEY(c, auth_cmds);\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if(outlen > 0) {\n            add_iov(c, out, outlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n        break;\n    default:\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"%d: Unknown sasl response:  %d\\n\",\n                                            c->sfd, result);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        STATS_NOKEY2(c, auth_cmds, auth_errors);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        if (c->sasl_conn) {\n            const void *uname = NULL;\n            sasl_getprop(c->sasl_conn, SASL_USERNAME, &uname);\n            rv = uname != NULL;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: authenticated() in cmd 0x%02x is %s\\n\",\n                c->sfd, c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic bool binary_response_handler(const void *key, uint16_t keylen,\n                                    const void *ext, uint8_t extlen,\n                                    const void *body, uint32_t bodylen,\n                                    uint8_t datatype, uint16_t status,\n                                    uint64_t cas, const void *cookie)\n{\n    conn *c = (conn*)cookie;\n    /* Look at append_bin_stats */\n    size_t needed = keylen + extlen + bodylen + sizeof(protocol_binary_response_header);\n    if (!grow_dynamic_buffer(c, needed)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return false;\n    }\n\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = c->binary_header.request.opcode,\n        .response.keylen = (uint16_t)htons(keylen),\n        .response.extlen = extlen,\n        .response.datatype = datatype,\n        .response.status = (uint16_t)htons(status),\n        .response.bodylen = htonl(bodylen + keylen + extlen),\n        .response.opaque = c->opaque,\n        .response.cas = htonll(cas),\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (extlen > 0) {\n        memcpy(buf, ext, extlen);\n        buf += extlen;\n    }\n\n    if (keylen > 0) {\n        memcpy(buf, key, keylen);\n        buf += keylen;\n    }\n\n    if (bodylen > 0) {\n        memcpy(buf, body, bodylen);\n    }\n\n    c->dynamic_buffer.offset += needed;\n\n    return true;\n}\n\n/**\n * Tap stats (these are only used by the tap thread, so they don't need\n * to be in the threadlocal struct right now...\n */\nstruct tap_cmd_stats {\n    uint64_t connect;\n    uint64_t mutation;\n    uint64_t checkpoint_start;\n    uint64_t checkpoint_end;\n    uint64_t delete;\n    uint64_t flush;\n    uint64_t opaque;\n    uint64_t vbucket_set;\n};\n\nstruct tap_stats {\n    pthread_mutex_t mutex;\n    struct tap_cmd_stats sent;\n    struct tap_cmd_stats received;\n} tap_stats = { .mutex = PTHREAD_MUTEX_INITIALIZER };\n\nstatic void ship_tap_log(conn *c) {\n    assert(c->thread->type == TAP);\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to create output headers. Shutting down tap connection\\n\", c->sfd);\n        }\n        conn_set_state(c, conn_closing);\n        return ;\n    }\n    /* @todo add check for buffer overflow of c->wbuf) */\n    c->wcurr = c->wbuf;\n\n    bool more_data = true;\n    bool send_data = false;\n    bool disconnect = false;\n\n    item *it;\n    uint32_t bodylen;\n    int ii = 0;\n    c->icurr = c->ilist;\n    do {\n        /* @todo fixme! */\n        if (ii++ == 10) {\n            break;\n        }\n\n        void *engine;\n        uint16_t nengine;\n        uint8_t ttl;\n        uint16_t tap_flags;\n        uint32_t seqno;\n        uint16_t vbucket;\n\n        tap_event_t event = c->tap_iterator(settings.engine.v0, c, &it,\n                                            &engine, &nengine, &ttl,\n                                            &tap_flags, &seqno, &vbucket);\n        union {\n            protocol_binary_request_tap_mutation mutation;\n            protocol_binary_request_tap_delete delete;\n            protocol_binary_request_tap_flush flush;\n            protocol_binary_request_tap_opaque opaque;\n            protocol_binary_request_noop noop;\n        } msg = {\n            .mutation.message.header.request.magic = (uint8_t)PROTOCOL_BINARY_REQ,\n        };\n\n        msg.opaque.message.header.request.opaque = htonl(seqno);\n        msg.opaque.message.body.tap.enginespecific_length = htons(nengine);\n        msg.opaque.message.body.tap.ttl = ttl;\n        msg.opaque.message.body.tap.flags = htons(tap_flags);\n        msg.opaque.message.header.request.extlen = 8;\n        msg.opaque.message.header.request.vbucket = htons(vbucket);\n        item_info info = { .nvalue = 1 };\n\n        switch (event) {\n        case TAP_NOOP :\n            send_data = true;\n            msg.noop.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n            msg.noop.message.header.request.extlen = 0;\n            msg.noop.message.header.request.bodylen = htonl(0);\n            memcpy(c->wcurr, msg.noop.bytes, sizeof(msg.noop.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.noop.bytes));\n            c->wcurr += sizeof(msg.noop.bytes);\n            c->wbytes += sizeof(msg.noop.bytes);\n            break;\n        case TAP_PAUSE :\n            more_data = false;\n            break;\n        case TAP_CHECKPOINT_START:\n        case TAP_CHECKPOINT_END:\n        case TAP_MUTATION:\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n\n            if (event == TAP_CHECKPOINT_START) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_start++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_CHECKPOINT_END) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_end++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_MUTATION) {\n                msg.mutation.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_MUTATION;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.mutation++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.mutation.message.header.request.cas = htonll(info.cas);\n            msg.mutation.message.header.request.keylen = htons(info.nkey);\n            msg.mutation.message.header.request.extlen = 16;\n\n            bodylen = 16 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.mutation.message.header.request.bodylen = htonl(bodylen);\n            msg.mutation.message.body.item.flags = htonl(info.flags);\n            msg.mutation.message.body.item.expiration = htonl(info.exptime);\n            msg.mutation.message.body.tap.enginespecific_length = htons(nengine);\n            msg.mutation.message.body.tap.ttl = ttl;\n            msg.mutation.message.body.tap.flags = htons(tap_flags);\n            memcpy(c->wcurr, msg.mutation.bytes, sizeof(msg.mutation.bytes));\n\n            add_iov(c, c->wcurr, sizeof(msg.mutation.bytes));\n            c->wcurr += sizeof(msg.mutation.bytes);\n            c->wbytes += sizeof(msg.mutation.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            break;\n        case TAP_DELETION:\n            /* This is a delete */\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n            msg.delete.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_DELETE;\n            msg.delete.message.header.request.cas = htonll(info.cas);\n            msg.delete.message.header.request.keylen = htons(info.nkey);\n\n            bodylen = 8 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.delete.message.header.request.bodylen = htonl(bodylen);\n\n            memcpy(c->wcurr, msg.delete.bytes, sizeof(msg.delete.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.delete.bytes));\n            c->wcurr += sizeof(msg.delete.bytes);\n            c->wbytes += sizeof(msg.delete.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            pthread_mutex_lock(&tap_stats.mutex);\n            tap_stats.sent.delete++;\n            pthread_mutex_unlock(&tap_stats.mutex);\n            break;\n\n        case TAP_DISCONNECT:\n            disconnect = true;\n            more_data = false;\n            break;\n        case TAP_VBUCKET_SET:\n        case TAP_FLUSH:\n        case TAP_OPAQUE:\n            send_data = true;\n\n            if (event == TAP_OPAQUE) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_OPAQUE;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.opaque++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n\n            } else if (event == TAP_FLUSH) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_FLUSH;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.flush++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_VBUCKET_SET) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET;\n                msg.flush.message.body.tap.flags = htons(tap_flags);\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.vbucket_set++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.flush.message.header.request.bodylen = htonl(8 + nengine);\n            memcpy(c->wcurr, msg.flush.bytes, sizeof(msg.flush.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.flush.bytes));\n            c->wcurr += sizeof(msg.flush.bytes);\n            c->wbytes += sizeof(msg.flush.bytes);\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n            break;\n        default:\n            abort();\n        }\n    } while (more_data);\n\n    c->ewouldblock = false;\n    if (send_data) {\n        conn_set_state(c, conn_mwrite);\n        if (disconnect) {\n            c->write_and_go = conn_closing;\n        } else {\n            c->write_and_go = conn_ship_log;\n        }\n    } else {\n        if (disconnect) {\n            conn_set_state(c, conn_closing);\n        } else {\n            /* No more items to ship to the slave at this time.. suspend.. */\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: No more items in tap log.. waiting\\n\",\n                                                c->sfd);\n            }\n            c->ewouldblock = true;\n        }\n    }\n}\n\nstatic void process_bin_unknown_packet(conn *c) {\n    void *packet = c->rcurr - (c->binary_header.request.bodylen +\n                               sizeof(c->binary_header));\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->unknown_command(settings.engine.v0, c, packet,\n                                                  binary_response_handler);\n    }\n\n    if (ret == ENGINE_SUCCESS) {\n        if (c->dynamic_buffer.buffer != NULL) {\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n    } else if (ret == ENGINE_ENOTSUP) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, 0);\n    } else if (ret == ENGINE_EWOULDBLOCK) {\n        c->ewouldblock = true;\n    } else {\n        /* FATAL ERROR, shut down connection */\n        conn_set_state(c, conn_closing);\n    }\n}\n\nstatic void process_bin_tap_connect(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_connect *req = (void*)packet;\n    const char *key = packet + sizeof(req->bytes);\n    const char *data = key + c->binary_header.request.keylen;\n    uint32_t flags = 0;\n    size_t ndata = c->binary_header.request.bodylen -\n        c->binary_header.request.extlen -\n        c->binary_header.request.keylen;\n\n    if (c->binary_header.request.extlen == 4) {\n        flags = ntohl(req->message.body.flags);\n\n        if (flags & TAP_CONNECT_FLAG_BACKFILL) {\n            /* the userdata has to be at least 8 bytes! */\n            if (ndata < 8) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: ERROR: Invalid tap connect message\\n\",\n                                                c->sfd);\n                conn_set_state(c, conn_closing);\n                return ;\n            }\n        }\n    } else {\n        data -= 4;\n        key -= 4;\n    }\n\n    if (settings.verbose && c->binary_header.request.keylen > 0) {\n        char buffer[1024];\n        int len = c->binary_header.request.keylen;\n        if (len >= sizeof(buffer)) {\n            len = sizeof(buffer) - 1;\n        }\n        memcpy(buffer, key, len);\n        buffer[len] = '\\0';\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: Trying to connect with named tap connection: <%s>\\n\",\n                                        c->sfd, buffer);\n    }\n\n    TAP_ITERATOR iterator = settings.engine.v1->get_tap_iterator(\n        settings.engine.v0, c, key, c->binary_header.request.keylen,\n        flags, data, ndata);\n\n    if (iterator == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: FATAL: The engine does not support tap\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        c->write_and_go = conn_closing;\n    } else {\n        c->tap_iterator = iterator;\n        c->which = EV_WRITE;\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\nstatic void process_bin_tap_packet(tap_event_t event, conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_no_extras *tap = (void*)packet;\n    uint16_t nengine = ntohs(tap->message.body.tap.enginespecific_length);\n    uint16_t tap_flags = ntohs(tap->message.body.tap.flags);\n    uint32_t seqno = ntohl(tap->message.header.request.opaque);\n    uint8_t ttl = tap->message.body.tap.ttl;\n    assert(ttl > 0);\n    char *engine_specific = packet + sizeof(tap->bytes);\n    char *key = engine_specific + nengine;\n    uint16_t nkey = c->binary_header.request.keylen;\n    char *data = key + nkey;\n    uint32_t flags = 0;\n    uint32_t exptime = 0;\n    uint32_t ndata = c->binary_header.request.bodylen - nengine - nkey - 8;\n\n    if (event == TAP_MUTATION || event == TAP_CHECKPOINT_START ||\n        event == TAP_CHECKPOINT_END) {\n        protocol_binary_request_tap_mutation *mutation = (void*)tap;\n        flags = ntohl(mutation->message.body.item.flags);\n        exptime = ntohl(mutation->message.body.item.expiration);\n        key += 8;\n        data += 8;\n        ndata -= 8;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->tap_notify(settings.engine.v0, c,\n                                             engine_specific, nengine,\n                                             ttl - 1, tap_flags,\n                                             event, seqno,\n                                             key, nkey,\n                                             flags, exptime,\n                                             ntohll(tap->message.header.request.cas),\n                                             data, ndata,\n                                             c->binary_header.request.vbucket);\n    }\n\n    switch (ret) {\n    case ENGINE_DISCONNECT:\n        conn_set_state(c, conn_closing);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        if ((tap_flags & TAP_FLAG_ACK) ||\n            (ret != ENGINE_SUCCESS && c->tap_nack_mode))\n        {\n            write_bin_packet(c, engine_error_2_protocol_error(ret), 0);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n    }\n}\n\nstatic void process_bin_tap_ack(conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_response_no_extras *rsp = (void*)packet;\n    uint32_t seqno = ntohl(rsp->message.header.response.opaque);\n    uint16_t status = ntohs(rsp->message.header.response.status);\n    char *key = packet + sizeof(rsp->bytes);\n\n    ENGINE_ERROR_CODE ret = ENGINE_DISCONNECT;\n    if (settings.engine.v1->tap_notify != NULL) {\n        ret = settings.engine.v1->tap_notify(settings.engine.v0, c, NULL, 0, 0, status,\n                                             TAP_ACK, seqno, key,\n                                             c->binary_header.request.keylen, 0, 0,\n                                             0, NULL, 0, 0);\n    }\n\n    if (ret == ENGINE_DISCONNECT) {\n        conn_set_state(c, conn_closing);\n    } else {\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\n/**\n * We received a noop response.. just ignore it\n */\nstatic void process_bin_noop_response(conn *c) {\n    assert(c != NULL);\n    conn_set_state(c, conn_new_cmd);\n}\n\nstatic void process_bin_verbosity(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_verbosity *req = (void*)packet;\n    uint32_t level = (uint32_t)ntohl(req->message.body.level);\n    if (level > MAX_VERBOSITY_LEVEL) {\n        level = MAX_VERBOSITY_LEVEL;\n    }\n    settings.verbose = (int)level;\n    perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_packet(conn *c) {\n    /* @todo this should be an array of funciton pointers and call through */\n    switch (c->binary_header.request.opcode) {\n    case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.connect++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        conn_set_state(c, conn_add_tap_client);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.mutation++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_MUTATION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_start++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_START, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_end++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_END, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_DELETE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.delete++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_DELETION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.flush++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_FLUSH, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.opaque++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_OPAQUE, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.vbucket_set++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_VBUCKET_SET, c);\n        break;\n    case PROTOCOL_BINARY_CMD_VERBOSITY:\n        process_bin_verbosity(c);\n        break;\n    default:\n        process_bin_unknown_packet(c);\n    }\n}\n\n\n\ntypedef void (*RESPONSE_HANDLER)(conn*);\n/**\n * A map between the response packets op-code and the function to handle\n * the response message.\n */\nstatic RESPONSE_HANDLER response_handlers[256] = {\n    [PROTOCOL_BINARY_CMD_NOOP] = process_bin_noop_response,\n    [PROTOCOL_BINARY_CMD_TAP_MUTATION] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_DELETE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_FLUSH] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_OPAQUE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END] = process_bin_tap_ack\n};\n\nstatic void dispatch_bin_command(conn *c) {\n    int protocol_error = 0;\n\n    int extlen = c->binary_header.request.extlen;\n    uint16_t keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (settings.require_sasl && !authenticated(c)) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        c->write_and_go = conn_closing;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                bin_read_key(c, bin_read_flush_exptime, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                bin_read_key(c, bin_reading_set_header, 8);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                bin_read_key(c, bin_reading_get_key, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                bin_read_key(c, bin_reading_del_header, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                bin_read_key(c, bin_reading_incr_header, 20);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                bin_read_key(c, bin_reading_set_header, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                bin_read_key(c, bin_reading_stat, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                c->write_and_go = conn_closing;\n                if (c->noreply) {\n                    conn_set_state(c, conn_closing);\n                }\n            } else {\n                protocol_error = 1;\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n            if (settings.engine.v1->get_tap_iterator == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n       case PROTOCOL_BINARY_CMD_TAP_DELETE:\n       case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n       case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n       case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n            if (settings.engine.v1->tap_notify == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n            break;\n#ifdef SASL_ENABLED\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                bin_read_key(c, bin_reading_sasl_auth, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n#endif\n        case PROTOCOL_BINARY_CMD_VERBOSITY:\n            if (extlen == 4 && keylen == 0 && bodylen == 4) {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            if (settings.engine.v1->unknown_command == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                                bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c) {\n    char *key;\n    uint16_t nkey;\n    uint32_t vlen;\n    item *it;\n    protocol_binary_request_set* req = binary_get_request(c);\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = req->message.body.flags;\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        const char *prefix;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            prefix = \"ADD\";\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            prefix = \"SET\";\n        } else {\n            prefix = \"REPLACE\";\n        }\n\n        size_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     prefix, key, nkey);\n\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" Value len is %d\\n\", vlen)) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen,\n                                           req->message.body.flags,\n                                           expiration);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->store_op = OPERATION_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->store_op = OPERATION_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->store_op = OPERATION_REPLACE;\n            break;\n        default:\n            assert(0);\n        }\n\n        if (c->binary_header.request.cas != 0) {\n            c->store_op = OPERATION_CAS;\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n\n        /*\n         * Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET (but only if cas matches).\n         * Anywhere else too?\n         */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            /* @todo fix this for the ASYNC interface! */\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                       ntohll(req->message.header.request.cas),\n                                       c->binary_header.request.vbucket);\n        }\n\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, 0, 0);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->store_op = OPERATION_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->store_op = OPERATION_PREPEND;\n            break;\n        default:\n            assert(0);\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_flush(conn *c) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = binary_get_request(c);\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: flush %ld\", c->sfd,\n                                        (long)exptime);\n    }\n\n    ENGINE_ERROR_CODE ret;\n    ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n\n    if (ret == ENGINE_SUCCESS) {\n        write_bin_response(c, NULL, 0, 0, 0);\n    } else if (ret == ENGINE_ENOTSUP) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n    } else {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n    STATS_NOKEY(c, cmd_flush);\n}\n\nstatic void process_bin_delete(conn *c) {\n    protocol_binary_request_delete* req = binary_get_request(c);\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"DELETE\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (settings.detail_enabled) {\n            stats_prefix_record_delete(key, nkey);\n        }\n        ret = settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                         ntohll(req->message.header.request.cas),\n                                         c->binary_header.request.vbucket);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        write_bin_response(c, NULL, 0, 0, 0);\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        STATS_INCR(c, delete_misses, key, nkey);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_reading_set_header:\n        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||\n                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n            process_bin_append_prepend(c);\n        } else {\n            process_bin_update(c);\n        }\n        break;\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_get_key:\n        process_bin_get(c);\n        break;\n    case bin_reading_stat:\n        process_bin_stat(c);\n        break;\n    case bin_reading_del_header:\n        process_bin_delete(c);\n        break;\n    case bin_reading_incr_header:\n        complete_incr_bin(c);\n        break;\n    case bin_read_flush_exptime:\n        process_bin_flush(c);\n        break;\n    case bin_reading_sasl_auth:\n        process_bin_sasl_auth(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        break;\n    case bin_reading_packet:\n        if (c->binary_header.request.magic == PROTOCOL_BINARY_RES) {\n            RESPONSE_HANDLER handler;\n            handler = response_handlers[c->binary_header.request.opcode];\n            if (handler) {\n                handler(c);\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                       \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                        c->sfd, (unsigned int)c->binary_header.request.opcode);\n                conn_set_state(c, conn_closing);\n            }\n        } else {\n            process_bin_packet(c);\n        }\n        break;\n    default:\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                \"Not handling substate %d\\n\", c->substate);\n        abort();\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->sbytes = 0;\n    c->ascii_cmd = NULL;\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if(c->item != NULL) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = NULL;\n    }\n    conn_shrink(c);\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic ENGINE_ERROR_CODE ascii_response_handler(const void *cookie,\n                                                int nbytes,\n                                                const char *dta)\n{\n    conn *c = (conn*)cookie;\n    if (!grow_dynamic_buffer(c, nbytes)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return ENGINE_ENOMEM;\n    }\n\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    memcpy(buf, dta, nbytes);\n    c->dynamic_buffer.offset += nbytes;\n\n    return ENGINE_SUCCESS;\n}\n\nstatic void complete_nread_ascii(conn *c) {\n    if (c->ascii_cmd != NULL) {\n        c->ewouldblock = false;\n        switch (c->ascii_cmd->execute(c->ascii_cmd->cookie, c, 0, NULL,\n                                      ascii_response_handler)) {\n        case ENGINE_SUCCESS:\n            if (c->dynamic_buffer.buffer != NULL) {\n                write_and_free(c, c->dynamic_buffer.buffer,\n                               c->dynamic_buffer.offset);\n                c->dynamic_buffer.buffer = NULL;\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            break;\n        case ENGINE_DISCONNECT:\n        default:\n            conn_set_state(c, conn_closing);\n        }\n    } else {\n        complete_update_ascii(c);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 30\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    for (s = e = command; ntokens < max_tokens - 1; ++e) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n            }\n            s = e + 1;\n        }\n        else if (*e == '\\0') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n            }\n\n            break; /* string end */\n        }\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\nstatic void detokenize(token_t *tokens, int ntokens, char **out, int *nbytes) {\n    int i, nb;\n    char *buf, *p;\n\n    nb = ntokens; // account for spaces, which is ntokens-1, plus the null\n    for (i = 0; i < ntokens; ++i) {\n        nb += tokens[i].length;\n    }\n\n    buf = malloc(nb * sizeof(char));\n    if (buf != NULL) {\n        p = buf;\n        for (i = 0; i < ntokens; ++i) {\n            memcpy(p, tokens[i].value, tokens[i].length);\n            p += tokens[i].length;\n            *p = ' ';\n            p++;\n        }\n        buf[nb - 1] = '\\0';\n        *nbytes = nb - 1;\n        *out = buf;\n    }\n}\n\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n    return c->noreply;\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (settings.allow_detailed) {\n        if (strcmp(command, \"on\") == 0) {\n            settings.detail_enabled = 1;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"off\") == 0) {\n            settings.detail_enabled = 0;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"dump\") == 0) {\n            int len;\n            char *stats = stats_prefix_dump(&len);\n            write_and_free(c, stats, len);\n        }\n        else {\n            out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n        }\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR detailed stats disabled\");\n    }\n}\n\nstatic void aggregate_callback(void *in, void *out) {\n    struct thread_stats *out_thread_stats = out;\n    struct independent_stats *in_independent_stats = in;\n    threadlocal_stats_aggregate(in_independent_stats->thread_stats,\n                                out_thread_stats);\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_clear(&thread_stats);\n\n    if (aggregate && settings.engine.v1->aggregate_stats != NULL) {\n        settings.engine.v1->aggregate_stats(settings.engine.v0,\n                                            (const void *)c,\n                                            aggregate_callback,\n                                            &thread_stats);\n    } else {\n        threadlocal_stats_aggregate(get_independent_stats(c)->thread_stats,\n                                    &thread_stats);\n    }\n\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n\n#ifndef __WIN32__\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"libevent\", \"%s\", event_get_version());\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef __WIN32__\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif\n\n    APPEND_STAT(\"daemon_connections\", \"%u\", stats.daemon_conns);\n    APPEND_STAT(\"curr_connections\", \"%u\", stats.curr_conns);\n    APPEND_STAT(\"total_connections\", \"%u\", stats.total_conns);\n    APPEND_STAT(\"connection_structures\", \"%u\", stats.conn_structs);\n    APPEND_STAT(\"cmd_get\", \"%\"PRIu64, thread_stats.cmd_get);\n    APPEND_STAT(\"cmd_set\", \"%\"PRIu64, slab_stats.cmd_set);\n    APPEND_STAT(\"cmd_flush\", \"%\"PRIu64, thread_stats.cmd_flush);\n    APPEND_STAT(\"auth_cmds\", \"%\"PRIu64, thread_stats.auth_cmds);\n    APPEND_STAT(\"auth_errors\", \"%\"PRIu64, thread_stats.auth_errors);\n    APPEND_STAT(\"get_hits\", \"%\"PRIu64, slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%\"PRIu64, thread_stats.get_misses);\n    APPEND_STAT(\"delete_misses\", \"%\"PRIu64, thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%\"PRIu64, slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%\"PRIu64, thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%\"PRIu64, thread_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%\"PRIu64, thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%\"PRIu64, thread_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%\"PRIu64, thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%\"PRIu64, slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%\"PRIu64, slab_stats.cas_badval);\n    APPEND_STAT(\"bytes_read\", \"%\"PRIu64, thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%\"PRIu64, thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%\"PRIu64, settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\",  is_listen_disabled() ? 0 : 1);\n    APPEND_STAT(\"listen_disabled_num\", \"%\"PRIu64, get_listen_disabled_num());\n    APPEND_STAT(\"rejected_conns\", \"%\" PRIu64, (unsigned long long)stats.rejected_conns);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%\" PRIu64, (unsigned long long)thread_stats.conn_yields);\n    STATS_UNLOCK();\n\n    /*\n     * Add tap stats (only if non-zero)\n     */\n    struct tap_stats ts;\n    pthread_mutex_lock(&tap_stats.mutex);\n    ts = tap_stats;\n    pthread_mutex_unlock(&tap_stats.mutex);\n\n    if (ts.sent.connect) {\n        APPEND_STAT(\"tap_connect_sent\", \"%\"PRIu64, ts.sent.connect);\n    }\n    if (ts.sent.mutation) {\n        APPEND_STAT(\"tap_mutation_sent\", \"%\"PRIu64, ts.sent.mutation);\n    }\n    if (ts.sent.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_sent\", \"%\"PRIu64, ts.sent.checkpoint_start);\n    }\n    if (ts.sent.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_sent\", \"%\"PRIu64, ts.sent.checkpoint_end);\n    }\n    if (ts.sent.delete) {\n        APPEND_STAT(\"tap_delete_sent\", \"%\"PRIu64, ts.sent.delete);\n    }\n    if (ts.sent.flush) {\n        APPEND_STAT(\"tap_flush_sent\", \"%\"PRIu64, ts.sent.flush);\n    }\n    if (ts.sent.opaque) {\n        APPEND_STAT(\"tap_opaque_sent\", \"%\"PRIu64, ts.sent.opaque);\n    }\n    if (ts.sent.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_sent\", \"%\"PRIu64,\n                    ts.sent.vbucket_set);\n    }\n    if (ts.received.connect) {\n        APPEND_STAT(\"tap_connect_received\", \"%\"PRIu64, ts.received.connect);\n    }\n    if (ts.received.mutation) {\n        APPEND_STAT(\"tap_mutation_received\", \"%\"PRIu64, ts.received.mutation);\n    }\n    if (ts.received.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_received\", \"%\"PRIu64, ts.received.checkpoint_start);\n    }\n    if (ts.received.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_received\", \"%\"PRIu64, ts.received.checkpoint_end);\n    }\n    if (ts.received.delete) {\n        APPEND_STAT(\"tap_delete_received\", \"%\"PRIu64, ts.received.delete);\n    }\n    if (ts.received.flush) {\n        APPEND_STAT(\"tap_flush_received\", \"%\"PRIu64, ts.received.flush);\n    }\n    if (ts.received.opaque) {\n        APPEND_STAT(\"tap_opaque_received\", \"%\"PRIu64, ts.received.opaque);\n    }\n    if (ts.received.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_received\", \"%\"PRIu64,\n                    ts.received.vbucket_set);\n    }\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%u\", (unsigned int)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"num_threads_per_udp\", \"%d\", settings.num_threads_per_udp);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"allow_detailed\", \"%s\",\n                settings.allow_detailed ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"reqs_per_tap_event\", \"%d\", settings.reqs_per_tap_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n#ifdef SASL_ENABLED\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"yes\");\n#else\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"no\");\n#endif\n\n#ifdef ENABLE_ISASL\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"isasl\");\n#elif defined(ENABLE_SASL)\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"cyrus\");\n#else\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"none\");\n#endif\n    APPEND_STAT(\"auth_required_sasl\", \"%s\", settings.require_sasl ? \"yes\" : \"no\");\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n    APPEND_STAT(\"topkeys\", \"%d\", settings.topkeys);\n\n    for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"extension\", \"%s\", ptr->get_name());\n    }\n\n    APPEND_STAT(\"logger\", \"%s\", settings.extensions.logger->get_name());\n\n    for (EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"ascii_extension\", \"%s\", ptr->get_name(ptr->cookie));\n    }\n}\n\nstatic char *process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    c->dynamic_buffer.offset = 0;\n\n    if (ntokens == 2) {\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            server_stats(&append_stats, c, false);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                NULL, 0, &append_stats);\n            if (ret == ENGINE_EWOULDBLOCK) {\n                c->ewouldblock = true;\n                return c->rcurr + 5;\n            }\n        }\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset(c);\n        out_string(c, \"RESET\");\n        return NULL;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4) {\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        } else {\n            process_stats_detail(c, tokens[2].value);\n        }\n        /* Output already generated */\n        return NULL;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf = NULL;\n        unsigned int bytes = 0, id, limit = 0;\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return NULL;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return NULL;\n        }\n\n        if (id >= POWER_LARGEST) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return NULL;\n        }\n\n#ifdef FUTURE\n        buf = item_cachedump(id, limit, &bytes);\n#endif\n        write_and_free(c, buf, bytes);\n        return NULL;\n    } else if (strcmp(subcommand, \"aggregate\") == 0) {\n        server_stats(&append_stats, c, true);\n    } else if (strcmp(subcommand, \"topkeys\") == 0) {\n        topkeys_t *tk = get_independent_stats(c)->topkeys;\n        if (tk != NULL) {\n            topkeys_stats(tk, c, current_time, append_stats);\n        } else {\n            out_string(c, \"ERROR\");\n            return NULL;\n        }\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            char *buf = NULL;\n            int nb = -1;\n            detokenize(&tokens[1], ntokens - 2, &buf, &nb);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, buf,\n                                                nb, append_stats);\n            free(buf);\n        }\n\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            append_stats(NULL, 0, NULL, 0, c);\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n            break;\n        case ENGINE_ENOMEM:\n            out_string(c, \"SERVER_ERROR out of memory writing stats\");\n            break;\n        case ENGINE_DISCONNECT:\n            c->state = conn_closing;\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return tokens[SUBCOMMAND_TOKEN].value;\n        default:\n            out_string(c, \"ERROR\");\n            break;\n        }\n\n        return NULL;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->dynamic_buffer.buffer == NULL) {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n    }\n\n    return NULL;\n}\n\n/**\n * Get a suffix buffer and insert it into the list of used suffix buffers\n * @param c the connection object\n * @return a pointer to a new suffix buffer or NULL if allocation failed\n */\nstatic char *get_suffix_buffer(conn *c) {\n    if (c->suffixleft == c->suffixsize) {\n        char **new_suffix_list;\n        size_t sz = sizeof(char*) * c->suffixsize * 2;\n\n        new_suffix_list = realloc(c->suffixlist, sz);\n        if (new_suffix_list) {\n            c->suffixsize *= 2;\n            c->suffixlist = new_suffix_list;\n        } else {\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"=%d Failed to resize suffix buffer\\n\", c->sfd);\n            }\n\n            return NULL;\n        }\n    }\n\n    char *suffix = cache_alloc(c->thread->suffix_cache);\n    if (suffix != NULL) {\n        *(c->suffixlist + c->suffixleft) = suffix;\n        ++c->suffixleft;\n    }\n\n    return suffix;\n}\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline char* process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = c->ileft;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    assert(c != NULL);\n\n    /* We temporarily block the mgets commands till wl6650 checked in. */\n    if ((key_token + 1)->length > 0) {\n\tout_string(c, \"We temporarily don't support multiple get option.\");\n\treturn NULL;\n    }\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n\n            ENGINE_ERROR_CODE ret = c->aiostat;\n            c->aiostat = ENGINE_SUCCESS;\n\n            if (ret == ENGINE_SUCCESS) {\n                ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey, 0);\n            }\n\n            switch (ret) {\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                c->ileft = i;\n                return key;\n\n            case ENGINE_SUCCESS:\n                break;\n            case ENGINE_KEY_ENOENT:\n            default:\n                it = NULL;\n                break;\n            }\n\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n\n            if (it) {\n                item_info info = { .nvalue = 1 };\n                if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it,\n                                                       &info)) {\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    out_string(c, \"SERVER_ERROR error getting item data\");\n                    break;\n                }\n\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        settings.engine.v1->release(settings.engine.v0, c, it);\n                        break;\n                    }\n                }\n\n                /* Rebuild the suffix */\n                char *suffix = get_suffix_buffer(c);\n                if (suffix == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory rebuilding suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                }\n                int suffix_len = snprintf(suffix, SUFFIX_SIZE,\n                                          \" %u %u\\r\\n\", htonl(info.flags),\n                                          info.nbytes);\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                MEMCACHED_COMMAND_GET(c->sfd, info.key, info.nkey,\n                                      info.nbytes, info.cas);\n                if (return_cas)\n                {\n\n                  char *cas = get_suffix_buffer(c);\n                  if (cas == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                  }\n                  int cas_len = snprintf(cas, SUFFIX_SIZE, \" %\"PRIu64\"\\r\\n\",\n                                         info.cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len - 2) != 0 ||\n                      add_iov(c, cas, cas_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n                else\n                {\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \">%d sending key %s\\n\",\n                                                    c->sfd, info.key);\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                STATS_HIT(c, get, key, nkey);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                STATS_MISS(c, get, key, nkey);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    c->suffixcurr = c->suffixlist;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d END\\n\", c->sfd);\n    }\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    return NULL;\n}\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, ENGINE_STORE_OPERATION store_op, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    time_t exptime;\n    int vlen;\n    uint64_t req_cas_id=0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    /* Negative expire values not allowed */\n\n    if (exptime_int < 0) {\n        out_string(c, \"CLIENT_ERROR Invalid expire time\");\n        return;\n    }\n\n    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */\n    exptime = exptime_int;\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    if (vlen < 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, htonl(flags), exptime);\n    }\n\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, req_cas_id);\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            out_string(c, \"SERVER_ERROR error getting item data\");\n            break;\n        }\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        c->store_op = store_op;\n        conn_set_state(c, conn_nread);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n        } else {\n            out_string(c, \"SERVER_ERROR out of memory storing object\");\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        c->sbytes = vlen + 2;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (store_op == OPERATION_SET) {\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey, 0, 0);\n        }\n    }\n}\n\nstatic char* process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    uint64_t cas;\n    uint64_t result;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0, c, key, nkey,\n                                             incr, false, delta, 0, 0, &cas,\n                                             &result, 0);\n    }\n\n    char temp[INCR_MAX_STORAGE_LEN];\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        snprintf(temp, sizeof(temp), \"%\"PRIu64, result);\n        out_string(c, temp);\n        break;\n    case ENGINE_KEY_ENOENT:\n        if (incr) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"SERVER_ERROR failed to store item\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    default:\n        abort();\n    }\n\n    return NULL;\n}\n\nstatic char *process_delete_command(conn *c, token_t *tokens,\n                                    const size_t ntokens) {\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, \"0\") == 0;\n        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);\n        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))\n            || (ntokens == 5 && hold_is_zero && sets_noreply);\n        if (!valid) {\n            out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                       \"Usage: delete <key> [noreply]\");\n            return NULL;\n        }\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->remove(settings.engine.v0, c,\n                                         key, nkey, 0, 0);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"DELETED\");\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    default:\n        out_string(c, \"NOT_FOUND\");\n        STATS_INCR(c, delete_misses, key, nkey);\n    }\n\n    if (ret != ENGINE_EWOULDBLOCK && settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n    return NULL;\n}\n\nstatic char *process_bind_command(conn *c, token_t *tokens,\n                                  const size_t ntokens) {\n    char *name;\n    size_t name_len;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                      \"Usage: bind <table_id_name>\");\n        return NULL;\n    }\n\n    name = tokens[KEY_TOKEN].value;\n    name_len = tokens[KEY_TOKEN].length;\n\n    if (name_len > KEY_MAX_LENGTH || name_len == 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->bind(settings.engine.v0, c,\n                                       name, name_len);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"SUCCEED\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return name;\n    case ENGINE_TMPFAIL:\n    default:\n        out_string(c, \"NOT_FOUND\");\n    }\n\n    return NULL;\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n    if (c->noreply && ntokens == 3) {\n        /* \"verbosity noreply\" is not according to the correct syntax */\n        c->noreply = false;\n        out_string(c, \"ERROR\");\n        return;\n    }\n\n    if (safe_strtoul(tokens[1].value, &level)) {\n        settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n        perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n        out_string(c, \"OK\");\n    } else {\n        out_string(c, \"ERROR\");\n    }\n}\n\nstatic char* process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n    char *ret = NULL;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"<%d %s\\n\", c->sfd, command);\n    }\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    if (c->ewouldblock) {\n        /*\n         * If we are retrying after the engine has completed a pending io for\n         * this command, skip add_msghdr() etc and clear the ewouldblock flag.\n         */\n        c->ewouldblock = false;\n    } else {\n        c->msgcurr = 0;\n        c->msgused = 0;\n        c->iovused = 0;\n        if (add_msghdr(c) != 0) {\n            out_string(c, \"SERVER_ERROR out of memory preparing response\");\n            return NULL;\n        }\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        ret = process_get_command(c, tokens, ntokens, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = (int)OPERATION_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = (int)OPERATION_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = (int)OPERATION_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = (int)OPERATION_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = (int)OPERATION_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = (int)OPERATION_CAS))) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        ret = process_get_command(c, tokens, ntokens, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        ret = process_delete_command(c, tokens, ntokens);\n\n    } else if (ntokens == 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"bind\") == 0)) {\n\n        ret = process_bind_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        ret = process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime;\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        if (ntokens == (c->noreply ? 3 : 2)) {\n            exptime = 0;\n        } else {\n            exptime = strtol(tokens[1].value, NULL, 10);\n            if(errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n        }\n\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n        }\n\n        switch (ret) {\n        case  ENGINE_SUCCESS:\n            out_string(c, \"OK\");\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return c->rcurr + 9;\n        default:\n            out_string(c, \"SERVER_ERROR failed to flush cache\");\n        }\n\n        if (ret != ENGINE_EWOULDBLOCK) {\n            STATS_NOKEY(c, cmd_flush);\n        }\n        return NULL;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_closing);\n\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else if (settings.extensions.ascii != NULL) {\n        EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *cmd;\n        size_t nbytes = 0;\n        char *ptr;\n\n        if (ntokens > 0) {\n            if (ntokens == MAX_TOKENS) {\n                out_string(c, \"ERROR too many arguments\");\n                return NULL;\n            }\n\n            if (tokens[ntokens - 1].length == 0) {\n                --ntokens;\n            }\n        }\n\n        for (cmd = settings.extensions.ascii; cmd != NULL; cmd = cmd->next) {\n            if (cmd->accept(cmd->cookie, c, ntokens, tokens, &nbytes, &ptr)) {\n                break;\n            }\n        }\n\n        if (cmd == NULL) {\n            out_string(c, \"ERROR unknown command\");\n        } else if (nbytes == 0) {\n            switch (cmd->execute(cmd->cookie, c, ntokens, tokens,\n                                 ascii_response_handler)) {\n            case ENGINE_SUCCESS:\n                if (c->dynamic_buffer.buffer != NULL) {\n                    write_and_free(c, c->dynamic_buffer.buffer,\n                                   c->dynamic_buffer.offset);\n                    c->dynamic_buffer.buffer = NULL;\n                } else {\n                    conn_set_state(c, conn_new_cmd);\n                }\n                break;\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                ret = tokens[KEY_TOKEN].value;;\n                break;\n            case ENGINE_DISCONNECT:\n            default:\n                conn_set_state(c, conn_closing);\n\n            }\n        } else {\n            c->rlbytes = nbytes;\n            c->ritem = ptr;\n            c->ascii_cmd = cmd;\n            /* NOT SUPPORTED YET! */\n            conn_set_state(c, conn_nread);\n        }\n    } else {\n        out_string(c, \"ERROR\");\n    }\n    return ret;\n}\n\n/*\n * if we have a complete line in the buffer, process it.\n */\nstatic int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                    \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                             \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                char buffer[1024];\n                ssize_t nw;\n                nw = bytes_to_output_string(buffer, sizeof(buffer), c->sfd,\n                                            true, \"Read binary protocol data:\",\n                                            (const char*)req->bytes,\n                                            sizeof(req->bytes));\n                if (nw != -1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \"%s\", buffer);\n                }\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.vbucket = ntohs(req->request.vbucket);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ &&\n                !(c->binary_header.request.magic == PROTOCOL_BINARY_RES &&\n                  response_handlers[c->binary_header.request.opcode])) {\n                if (settings.verbose) {\n                    if (c->binary_header.request.magic != PROTOCOL_BINARY_RES) {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: Invalid magic:  %x\\n\", c->sfd,\n                              c->binary_header.request.magic);\n                    } else {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                              c->sfd, (unsigned int)c->binary_header.request.opcode);\n\n                    }\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont, *left, lb;\n\n        if (c->rbytes == 0) {\n            return 0;\n        }\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        lb = *el;\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        LIBEVENT_THREAD *thread = c->thread;\n        LOCK_THREAD(thread);\n        left = process_command(c, c->rcurr);\n        if (c->ewouldblock) {\n            unregister_event(c);\n        }\n        UNLOCK_THREAD(thread);\n\n        if (left != NULL) {\n            /*\n             * We have not processed the entire command. This happens\n             * when the engine returns ENGINE_EWOULDBLOCK for one of the\n             * keys in a get/gets request.\n             */\n            assert (left <= el);\n\n            int count = strlen(c->rcurr);\n            if ((c->rcurr + count) == left) {\n                // Retry the entire command\n                cont = c->rcurr;\n            } else {\n                left -= (count + 1);\n                cont = left;\n                assert(cont >= c->rcurr);\n                if (cont > c->rcurr) {\n                    memmove(cont, c->rcurr, count);\n                }\n            }\n\n            /* de-tokenize the command */\n            while ((left = memchr(left, '\\0', el - left)) != NULL) {\n                *left = ' ';\n            }\n            *el = lb;\n        }\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, (struct sockaddr *)&c->request_addr, &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        STATS_ADD(c, bytes_read, res);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes += res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n *\n * To protect us from someone flooding a connection with bogus data causing\n * the connection to eat up all available memory, break out and start looking\n * at the data I've got after a number of reallocs...\n *\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0) {\n                 settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                          \"Couldn't realloc input buffer\\n\");\n                }\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = recv(c->sfd, c->rbuf + c->rbytes, avail, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_read, res);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nbool register_event(conn *c, struct timeval *timeout) {\n#ifdef DEBUG\n    assert(!c->registered_in_libevent);\n#endif\n\n    if (event_add(&c->event, timeout) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to add connection to libevent: %s\",\n                                        strerror(errno));\n        return false;\n    }\n\n#ifdef DEBUG\n    c->registered_in_libevent = true;\n#endif\n\n    return true;\n}\n\nbool unregister_event(conn *c) {\n#ifdef DEBUG\n    assert(c->registered_in_libevent);\n#endif\n\n    if (event_del(&c->event) == -1) {\n        return false;\n    }\n\n#ifdef DEBUG\n    c->registered_in_libevent = false;\n#endif\n\n    return true;\n}\n\n\nbool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Updated event for %d to read=%s, write=%s\\n\",\n                                    c->sfd, (new_flags & EV_READ ? \"yes\" : \"no\"),\n                                    (new_flags & EV_WRITE ? \"yes\" : \"no\"));\n\n    if (!unregister_event(c)) {\n        return false;\n    }\n\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n\n    return register_event(c, NULL);\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_written, res);\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                            \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to write, and not due to blocking: %s\",\n                                            strerror(errno));\n        }\n\n        if (IS_UDP(c->transport))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}\n\nbool conn_listening(conn *c)\n{\n    int sfd;\n    struct sockaddr_storage addr;\n    socklen_t addrlen = sizeof(addr);\n\n    if ((sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen)) == -1) {\n        if (errno == EMFILE) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Too many open connections\\n\");\n            }\n            disable_listen();\n        } else if (errno != EAGAIN && errno != EWOULDBLOCK) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to accept new client: %s\\n\",\n                                            strerror(errno));\n        }\n\n        return false;\n    }\n\n    STATS_LOCK();\n    int curr_conns = ++stats.curr_conns;\n    STATS_UNLOCK();\n\n    if (curr_conns >= settings.maxconns) {\n        STATS_LOCK();\n        ++stats.rejected_conns;\n        STATS_UNLOCK();\n\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Too many open connections\\n\");\n        }\n\n        safe_close(sfd);\n        return false;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return false;\n    }\n\n    dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                      DATA_BUFFER_SIZE, tcp_transport);\n\n    return false;\n}\n\n/**\n * Ship tap log to the other end. This state differs with all other states\n * in the way that it support full duplex dialog. We're listening to both read\n * and write events from libevent most of the time. If a read event occurs we\n * switch to the conn_read state to read and execute the input message (that would\n * be an ack message from the other side). If a write event occurs we continue to\n * send tap log to the other end.\n * @param c the tap connection to drive\n * @return true if we should continue to process work for this connection, false\n *              if we should start processing events for other connections.\n */\nbool conn_ship_log(conn *c) {\n    bool cont = false;\n\n    if (c->sfd == INVALID_SOCKET) {\n        return false;\n    }\n\n    short mask = EV_READ | EV_PERSIST | EV_WRITE;\n\n    if (c->which & EV_READ || c->rbytes > 0) {\n        if (c->rbytes > 0) {\n            if (try_read_command(c) == 0) {\n                conn_set_state(c, conn_read);\n            }\n        } else {\n            conn_set_state(c, conn_read);\n        }\n\n        // we're going to process something.. let's proceed\n        cont = true;\n\n        // We have a finite number of messages in the input queue\n        // so let's process all of them instead of backing off after\n        // reading a subset of them.\n        // Why? Because we've got every time we're calling ship_tap_log\n        // we try to send a chunk of items.. This means that if we end\n        // up in a situation where we're receiving a burst of nack messages\n        // we'll only process a subset of messages in our input queue,\n        // and it will slowly grow..\n        c->nevents = settings.reqs_per_tap_event;\n    } else if (c->which & EV_WRITE) {\n        --c->nevents;\n        if (c->nevents >= 0) {\n            LOCK_THREAD(c->thread);\n            c->ewouldblock = false;\n            ship_tap_log(c);\n            if (c->ewouldblock) {\n                mask = EV_READ | EV_PERSIST;\n            } else {\n                cont = true;\n            }\n            UNLOCK_THREAD(c->thread);\n        }\n    }\n\n    if (!update_event(c, mask)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                            c, \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n    }\n\n    return cont;\n}\n\nbool conn_waiting(conn *c) {\n    if (!update_event(c, EV_READ | EV_PERSIST)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    conn_set_state(c, conn_read);\n    return false;\n}\n\nbool conn_read(conn *c) {\n    int res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);\n    switch (res) {\n    case READ_NO_DATA_RECEIVED:\n        conn_set_state(c, conn_waiting);\n        break;\n    case READ_DATA_RECEIVED:\n        conn_set_state(c, conn_parse_cmd);\n        break;\n    case READ_ERROR:\n        conn_set_state(c, conn_closing);\n        break;\n    case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n        /* State already set by try_read_network */\n        break;\n    }\n\n    return true;\n}\n\nbool conn_parse_cmd(conn *c) {\n    if (try_read_command(c) == 0) {\n        /* wee need more data! */\n        conn_set_state(c, conn_waiting);\n    }\n\n    return !c->ewouldblock;\n}\n\nbool conn_new_cmd(conn *c) {\n    /* Only process nreqs at a time to avoid starving other connections */\n    --c->nevents;\n    if (c->nevents >= 0) {\n        reset_cmd_handler(c);\n    } else {\n        STATS_NOKEY(c, conn_yields);\n        if (c->rbytes > 0) {\n            /* We have already read in data into the input buffer,\n               so libevent will most likely not signal read events\n               on the socket (unless more data is available. As a\n               hack we should just put in a request to write data,\n               because that should be possible ;-)\n            */\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                                    c, \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    return true;\n}\n\n\nbool conn_swallow(conn *c) {\n    ssize_t res;\n    /* we are reading sbytes and throwing them away */\n    if (c->sbytes == 0) {\n        conn_set_state(c, conn_new_cmd);\n        return true;\n    }\n\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n        c->sbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        return true;\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        c->sbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"Failed to read, and not due to blocking (%s)\\n\",\n                                        strerror(errno));\n    }\n\n    conn_set_state(c, conn_closing);\n\n    return true;\n\n}\n\nbool conn_nread(conn *c) {\n    ssize_t res;\n\n    if (c->rlbytes == 0) {\n        LIBEVENT_THREAD *t = c->thread;\n        LOCK_THREAD(t);\n        bool block = c->ewouldblock = false;\n        complete_nread(c);\n        UNLOCK_THREAD(t);\n        /* Breaking this into two, as complete_nread may have\n           moved us to a different thread */\n        t = c->thread;\n        LOCK_THREAD(t);\n        if (c->ewouldblock) {\n            unregister_event(c);\n            block = true;\n        }\n        UNLOCK_THREAD(t);\n        return !block;\n    }\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n        if (c->ritem != c->rcurr) {\n            memmove(c->ritem, c->rcurr, tocopy);\n        }\n        c->ritem += tocopy;\n        c->rlbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        if (c->rlbytes == 0) {\n            return true;\n        }\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->ritem, c->rlbytes, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        if (c->rcurr == c->ritem) {\n            c->rcurr += res;\n        }\n        c->ritem += res;\n        c->rlbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n#ifdef INNODB_MEMCACHED\n    /* MEMCACHED_RESOLVE: on solaris platform, when connect through\n    telnet and waiting for input from an \"add\" or \"set\" command,\n    it could have res == -1 and errno == 0. Thus causing early termination\n    Add \"!errno\" condition here to deal with this scenario for now */\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK || !errno)) {\n#else\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n#endif /* INNODB_MEMCACHED */\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Failed to read, and not due to blocking:\\n\"\n                                        \"errno: %d %s \\n\"\n                                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                                        errno, strerror(errno),\n                                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                                        (int)c->rlbytes, (int)c->rsize);\n    }\n    conn_set_state(c, conn_closing);\n    return true;\n}\n\nbool conn_write(conn *c) {\n    /*\n     * We want to write out a simple response. If we haven't already,\n     * assemble it into a msgbuf list (this will be a single-entry\n     * list for TCP or a two-entry list for UDP).\n     */\n    if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {\n        if (add_iov(c, c->wcurr, c->wbytes) != 0) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't build response\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n    }\n\n    return conn_mwrite(c);\n}\n\nbool conn_mwrite(conn *c) {\n    if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Failed to build UDP headers\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n    switch (transmit(c)) {\n    case TRANSMIT_COMPLETE:\n        if (c->state == conn_mwrite) {\n            while (c->ileft > 0) {\n                item *it = *(c->icurr);\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                c->icurr++;\n                c->ileft--;\n            }\n            while (c->suffixleft > 0) {\n                char *suffix = *(c->suffixcurr);\n                cache_free(c->thread->suffix_cache, suffix);\n                c->suffixcurr++;\n                c->suffixleft--;\n            }\n            /* XXX:  I don't know why this wasn't the general case */\n            if(c->protocol == binary_prot) {\n                conn_set_state(c, c->write_and_go);\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n        } else if (c->state == conn_write) {\n            if (c->write_and_free) {\n                free(c->write_and_free);\n                c->write_and_free = 0;\n            }\n            conn_set_state(c, c->write_and_go);\n        } else {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Unexpected state %d\\n\", c->state);\n            }\n            conn_set_state(c, conn_closing);\n        }\n        break;\n\n    case TRANSMIT_INCOMPLETE:\n    case TRANSMIT_HARD_ERROR:\n        break;                   /* Continue in state machine. */\n\n    case TRANSMIT_SOFT_ERROR:\n        return false;\n    }\n\n    return true;\n}\n\nbool conn_pending_close(conn *c) {\n    assert(c->sfd == INVALID_SOCKET);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                    \"Awaiting clients to release the cookie (pending close for %p)\",\n                                    (void*)c);\n    LOCK_THREAD(c->thread);\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    if (!list_contains(c->thread->pending_close, c)) {\n        enlist_conn(c, &c->thread->pending_close);\n    }\n    UNLOCK_THREAD(c->thread);\n\n    /*\n     * tell the tap connection that we're disconnecting it now,\n     * but give it a grace period\n     */\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n\n    /*\n     * disconnect callback may have changed the state for the object\n     * so we might complete the disconnect now\n     */\n    return c->state != conn_pending_close;\n}\n\nbool conn_immediate_close(conn *c) {\n    settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                    \"Immediate close of %p\",\n                                    (void*)c);\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n    conn_close(c);\n\n    return false;\n}\n\nbool conn_closing(conn *c) {\n    if (IS_UDP(c->transport)) {\n        conn_cleanup(c);\n        return false;\n    }\n\n    // We don't want any network notifications anymore..\n    unregister_event(c);\n    safe_close(c->sfd);\n    c->sfd = INVALID_SOCKET;\n\n    if (c->refcount > 1) {\n        conn_set_state(c, conn_pending_close);\n    } else {\n        conn_set_state(c, conn_immediate_close);\n    }\n    return true;\n}\n\nbool conn_add_tap_client(conn *c) {\n    LIBEVENT_THREAD *tp = tap_thread;\n    LIBEVENT_THREAD *orig_thread = c->thread;\n\n    assert(orig_thread);\n    assert(orig_thread != tp);\n\n    c->ewouldblock = true;\n\n    unregister_event(c);\n\n    LOCK_THREAD(orig_thread);\n    /* Clean out the lists */\n    orig_thread->pending_io = list_remove(orig_thread->pending_io, c);\n    orig_thread->pending_close = list_remove(orig_thread->pending_close, c);\n\n    LOCK_THREAD(tp);\n    c->ev_flags = 0;\n    conn_set_state(c, conn_setup_tap_stream);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Moving %d conn from %p to %p\\n\",\n                                    c->sfd, c->thread, tp);\n    c->thread = tp;\n    c->event.ev_base = tp->base;\n    assert(c->next == NULL);\n    assert(c->list_state == 0);\n    enlist_conn(c, &tp->pending_io);\n\n    UNLOCK_THREAD(tp);\n\n    UNLOCK_THREAD(orig_thread);\n\n    notify_thread(tp);\n\n    return false;\n}\n\nbool conn_setup_tap_stream(conn *c) {\n    process_bin_tap_connect(c);\n    return true;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(c->event.ev_base);\n        return ;\n    }\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                    \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        }\n        conn_close(c);\n        return;\n    }\n\n    perform_callbacks(ON_SWITCH_CONN, c, c);\n\n    c->nevents = settings.reqs_per_event;\n    if (c->state == conn_ship_log) {\n        c->nevents = settings.reqs_per_tap_event;\n    }\n\n    LIBEVENT_THREAD *thr = c->thread;\n\n    // Do we have pending closes?\n    const size_t max_items = 256;\n    conn *pending_close[max_items];\n    size_t n_pending_close = 0;\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        if (thr->pending_close && thr->last_checked != current_time) {\n            assert(!has_cycle(thr->pending_close));\n            thr->last_checked = current_time;\n\n            n_pending_close = list_to_array(pending_close, max_items,\n                                            &thr->pending_close);\n        }\n        UNLOCK_THREAD(thr);\n    }\n\n    if (settings.verbose) {\n        do {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%d - Running task: (%s)\\n\",\n                                            c->sfd, state_text(c->state));\n        } while (c->state(c));\n    } else {\n        while (c->state(c)) {\n            /* empty */\n        }\n    }\n\n    /* Close any connections pending close */\n    if (n_pending_close > 0) {\n        for (size_t i = 0; i < n_pending_close; ++i) {\n            conn *ce = pending_close[i];\n            if (ce->refcount == 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                                \"OK, time to nuke: %p\\n\",\n                                                (void*)ce);\n                conn_close(ce);\n            } else {\n                LOCK_THREAD(ce->thread);\n                enlist_conn(ce, &ce->thread->pending_close);\n                UNLOCK_THREAD(ce->thread);\n            }\n        }\n    }\n\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        finalize_list(pending_close, n_pending_close);\n        UNLOCK_THREAD(thr);\n    }\n}\n\nstatic void dispatch_event_handler(int fd, short which, void *arg) {\n    char buffer[80];\n    ssize_t nr = recv(fd, buffer, sizeof(buffer), 0);\n\n    if (nr != -1 && is_listen_disabled()) {\n        bool enable = false;\n        pthread_mutex_lock(&listen_state.mutex);\n        listen_state.count -= nr;\n        if (listen_state.count <= 0) {\n            enable = true;\n            listen_state.disabled = false;\n        }\n        pthread_mutex_unlock(&listen_state.mutex);\n        if (enable) {\n            conn *next;\n            for (next = listen_conn; next; next = next->next) {\n                update_event(next, EV_READ | EV_PERSIST);\n                if (listen(next->sfd, settings.backlog) != 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"listen() failed\",\n                                                    strerror(errno));\n                }\n            }\n        }\n    }\n}\n\n\n\nstatic SOCKET new_socket(struct addrinfo *ai) {\n    SOCKET sfd;\n\n    sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n    if (sfd == INVALID_SOCKET) {\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&old_size, &intsize) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"getsockopt(SO_SNDBUF): %s\",\n                                            strerror(errno));\n        }\n\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                 \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n    }\n}\n\n\n\n/**\n * Create a socket and bind it to a specific port number\n * @param interface the interface to bind to\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(const char *interface,\n                         int port,\n                         enum network_transport transport,\n                         FILE *portnumber_file) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n    num_udp_socket = 0;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(interface, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", strerror(error));\n        }\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == INVALID_SOCKET) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(IPV6_V6ONLY): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n\t    udp_socket[num_udp_socket] = sfd;\n\t    num_udp_socket++;\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_KEEPALIVE): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_LINGER): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(TCP_NODELAY): %s\",\n                                                strerror(errno));\n            }\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == SOCKET_ERROR) {\n            if (errno != EADDRINUSE) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"bind(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            safe_close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == SOCKET_ERROR) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"listen(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads_per_udp; c++) {\n                /* this is guaranteed to hit all threads because we round-robin */\n                dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport);\n                STATS_LOCK();\n                ++stats.curr_conns;\n                ++stats.daemon_conns;\n                STATS_UNLOCK();\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base, NULL))) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n            STATS_LOCK();\n            ++stats.curr_conns;\n            ++stats.daemon_conns;\n            STATS_UNLOCK();\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int server_sockets(int port, enum network_transport transport,\n                          FILE *portnumber_file) {\n    if (settings.inter == NULL) {\n        return server_socket(settings.inter, port, transport, portnumber_file);\n    } else {\n        // tokenize them and bind to each one of them..\n        char *b;\n        int ret = 0;\n        char *list = strdup(settings.inter);\n\n        if (list == NULL) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to allocate memory for parsing server interface string\\n\");\n            return 1;\n        }\n        for (char *p = strtok_r(list, \";,\", &b);\n             p != NULL;\n             p = strtok_r(NULL, \";,\", &b)) {\n            int the_port = port;\n\n            char *s = strchr(p, ':');\n            if (s != NULL) {\n                *s = '\\0';\n                ++s;\n                if (!safe_strtol(s, &the_port)) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Invalid port number: \\\"%s\\\"\", s);\n                    return 1;\n                }\n            }\n            if (strcmp(p, \"*\") == 0) {\n                p = NULL;\n            }\n            ret |= server_socket(p, the_port, transport, portnumber_file);\n        }\n        free(list);\n        return ret;\n    }\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"socket(AF_UNIX, SOCK_STREAM, 0): %s\",\n                                        strerror(errno));\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n    return sfd;\n}\n\n/* this will probably not work on windows */\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some impementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"bind(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"listen(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base, NULL))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n    STATS_LOCK();\n    ++stats.daemon_conns;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\nstatic struct event clockevent;\n\n/* time-sensitive callers can call it by hand with this, outside the normal ever-1-second timer */\nstatic void set_current_time(void) {\n    struct timeval timer;\n\n    gettimeofday(&timer, NULL);\n    current_time = (rel_time_t) (timer.tv_sec - process_started);\n}\n\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(main_base);\n        return ;\n    }\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n    set_current_time();\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p <num>      TCP port number to listen on (default: 11211)\\n\"\n           \"-U <num>      UDP port number to listen on (default: 11211, 0 is off)\\n\"\n           \"-s <file>     UNIX socket path to listen on (disables network support)\\n\"\n           \"-a <mask>     access mask for UNIX socket, in octal (default: 0700)\\n\"\n           \"-l <addr>     interface to listen on (default: INADDR_ANY, all addresses)\\n\"\n           \"              <addr> may be specified as host:port. If you don't specify\\n\"\n           \"              a port number, the value you specified with -p or -U is\\n\"\n           \"              used. You may specify multiple addresses separated by comma\\n\"\n           \"              or by using -l multiple times\\n\"\n           \"-d            run as a daemon\\n\"\n           \"-r            maximize core file limit\\n\"\n           \"-u <username> assume identity of <username> (only when run as root)\\n\"\n           \"-m <num>      max memory to use for items in megabytes (default: 64 MB)\\n\"\n           \"-M            return error on memory exhausted (rather than removing items)\\n\"\n           \"-c <num>      max simultaneous connections (default: 1000)\\n\"\n           \"-k            lock down all paged memory.  Note that there is a\\n\"\n           \"              limit on how much memory you may lock.  Trying to\\n\"\n           \"              allocate more than that would fail, so be sure you\\n\"\n           \"              set the limit correctly for the user you started\\n\"\n           \"              the daemon with (not for -u <username> user;\\n\"\n           \"              under sh this is done with 'ulimit -S -l NUM_KB').\\n\"\n           \"-v            verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv           very verbose (also print client commands/reponses)\\n\"\n           \"-vvv          extremely verbose (also print internal state transitions)\\n\"\n           \"-h            print this help and exit\\n\"\n           \"-i            print memcached and libevent license\\n\"\n           \"-P <file>     save PID in <file>, only used with -d option\\n\"\n           \"-f <factor>   chunk size growth factor (default: 1.25)\\n\"\n           \"-n <bytes>    minimum space allocated for key+value+flags (default: 48)\\n\");\n    printf(\"-L            Try to use large memory pages (if available). Increasing\\n\"\n           \"              the memory page size could reduce the number of TLB misses\\n\"\n           \"              and improve the performance. In order to get large pages\\n\"\n           \"              from the OS, memcached will allocate the total item-cache\\n\"\n           \"              in one large chunk.\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\":\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\");\n    printf(\"-t <num>      number of threads to use (default: 4)\\n\");\n    printf(\"-R            Maximum number of requests per event, limits the number of\\n\"\n           \"              requests process for a given connection to prevent \\n\"\n           \"              starvation (default: 20)\\n\");\n    printf(\"-C            Disable use of CAS\\n\");\n    printf(\"-b            Set the backlog queue limit (default: 1024)\\n\");\n    printf(\"-B            Binding protocol - one of ascii, binary, or auto (default)\\n\");\n    printf(\"-I            Override the size of each slab page. Adjusts max item size\\n\"\n           \"              (default: 1mb, min: 1k, max: 128m)\\n\");\n    printf(\"-q            Disable detailed stats commands\\n\");\n#ifdef SASL_ENABLED\n    printf(\"-S            Require SASL authentication\\n\");\n#endif\n    printf(\"-X module,cfg Load the module and initialize it with the config\\n\");\n    printf(\"-E engine     Load engine as the storage engine\\n\");\n    printf(\"-e config     Pass config as configuration options to the storage engine\\n\");\n    printf(\"\\nEnvironment variables:\\n\"\n           \"MEMCACHED_PORT_FILENAME   File to write port information to\\n\"\n           \"MEMCACHED_TOP_KEYS        Number of top keys to keep track of\\n\"\n           \"MEMCACHED_REQS_TAP_EVENT  Similar to -R but for tap_ship_log\\n\");\n}\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const char *pid_file) {\n    FILE *fp;\n\n    if (access(pid_file, F_OK) == 0) {\n        if ((fp = fopen(pid_file, \"r\")) != NULL) {\n            char buffer[1024];\n            if (fgets(buffer, sizeof(buffer), fp) != NULL) {\n                unsigned int pid;\n                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                               \"WARNING: The pid file contained the following (running) pid: %u\\n\", pid);\n                }\n            }\n            fclose(fp);\n        }\n    }\n\n    if ((fp = fopen(pid_file, \"w\")) == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Could not open the pid file %s for writing: %s\\n\",\n                 pid_file, strerror(errno));\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)getpid());\n    if (fclose(fp) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not close the pid file %s: %s\\n\",\n                pid_file, strerror(errno));\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n    if (pid_file != NULL) {\n        if (unlink(pid_file) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Could not remove the pid file %s: %s\\n\",\n                    pid_file, strerror(errno));\n        }\n    }\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif /* !HAVE_SIGIGNORE */\n\nstatic void sigterm_handler(int sig) {\n    assert(sig == SIGTERM || sig == SIGINT);\n    memcached_shutdown = 1;\n}\n\nstatic int install_sigterm_handler(void) {\n    struct sigaction sa = {.sa_handler = sigterm_handler, .sa_flags = 0};\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(SIGTERM, &sa, 0) == -1 ||\n        sigaction(SIGINT, &sa, 0) == -1) {\n        return -1;\n    }\n\n    return 0;\n}\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                  \"Failed to set large pages: %s\\nWill use default page size\\n\",\n                  strerror(errno));\n        } else {\n            ret = 0;\n        }\n    } else {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n          \"Failed to get supported pagesizes: %s\\nWill use default page size\\n\",\n          strerror(errno));\n    }\n\n    return ret;\n#else\n    return 0;\n#endif\n}\n\nstatic const char* get_server_version(void) {\n    return VERSION;\n}\n\nstatic void store_engine_specific(const void *cookie,\n                                  void *engine_data) {\n    conn *c = (conn*)cookie;\n    c->engine_storage = engine_data;\n}\n\nstatic void *get_engine_specific(const void *cookie) {\n    conn *c = (conn*)cookie;\n    return c->engine_storage;\n}\n\nstatic int get_socket_fd(const void *cookie) {\n    conn *c = (conn *)cookie;\n    return c->sfd;\n}\n\nstatic void set_tap_nack_mode(const void *cookie, bool enable) {\n    conn *c = (conn *)cookie;\n    c->tap_nack_mode = enable;\n}\n\nstatic void reserve_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    ++c->refcount;\n}\n\nstatic void release_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    --c->refcount;\n}\n\nstatic int num_independent_stats(void) {\n    return settings.num_threads + 1;\n}\n\nstatic void *new_independent_stats(void) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = calloc(sizeof(independent_stats) + sizeof(struct thread_stats) * nrecords, 1);\n\n#ifdef INNODB_MEMCACHED\n    if (independent_stats == NULL) {\n\tfprintf(stderr, \"Unable to allocate memory for\"\n\t\t       \"independent_stats...\\n\");\n       return (NULL);\n    }\n#endif\n\n    if (settings.topkeys > 0)\n        independent_stats->topkeys = topkeys_init(settings.topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_init(&independent_stats->thread_stats[ii].mutex, NULL);\n    return independent_stats;\n}\n\nstatic void release_independent_stats(void *stats) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = stats;\n    if (independent_stats->topkeys)\n        topkeys_free(independent_stats->topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_destroy(&independent_stats->thread_stats[ii].mutex);\n    free(independent_stats);\n}\n\nstatic inline struct independent_stats *get_independent_stats(conn *c) {\n    struct independent_stats *independent_stats;\n    if (settings.engine.v1->get_stats_struct != NULL) {\n        independent_stats = settings.engine.v1->get_stats_struct(settings.engine.v0, (const void *)c);\n        if (independent_stats == NULL)\n            independent_stats = default_independent_stats;\n    } else {\n        independent_stats = default_independent_stats;\n    }\n    return independent_stats;\n}\n\nstatic inline struct thread_stats *get_thread_stats(conn *c) {\n    struct independent_stats *independent_stats = get_independent_stats(c);\n    assert(c->thread->index < num_independent_stats());\n    return &independent_stats->thread_stats[c->thread->index];\n}\n\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data) {\n    struct engine_event_handler *h =\n        calloc(sizeof(struct engine_event_handler), 1);\n\n    assert(h);\n    h->cb = cb;\n    h->cb_data = cb_data;\n    h->next = engine_event_handlers[type];\n    engine_event_handlers[type] = h;\n}\n\nstatic rel_time_t get_current_time(void)\n{\n    return current_time;\n}\n\nstatic void count_eviction(const void *cookie, const void *key, const int nkey) {\n    topkeys_t *tk = get_independent_stats((conn*)cookie)->topkeys;\n    TK(tk, evictions, key, nkey, get_current_time());\n}\n\n/**\n * To make it easy for engine implementors that doesn't want to care about\n * writing their own incr/decr code, they can just set the arithmetic function\n * to NULL and use this implementation. It is not efficient, due to the fact\n * that it does multiple calls through the interface (get and then cas store).\n * If you don't care, feel free to use it..\n */\nstatic ENGINE_ERROR_CODE internal_arithmetic(ENGINE_HANDLE* handle,\n                                             const void* cookie,\n                                             const void* key,\n                                             const int nkey,\n                                             const bool increment,\n                                             const bool create,\n                                             const uint64_t delta,\n                                             const uint64_t initial,\n                                             const rel_time_t exptime,\n                                             uint64_t *cas,\n                                             uint64_t *result,\n                                             uint16_t vbucket)\n{\n    ENGINE_HANDLE_V1 *e = (ENGINE_HANDLE_V1*)handle;\n\n    item *it = NULL;\n\n    ENGINE_ERROR_CODE ret;\n    ret = e->get(handle, cookie, &it, key, nkey, vbucket);\n\n    if (ret == ENGINE_SUCCESS) {\n        item_info info = { .nvalue = 1 };\n\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        char value[80];\n\n        if (info.value[0].iov_len > (sizeof(value) - 1)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        memcpy(value, info.value[0].iov_base, info.value[0].iov_len);\n        value[info.value[0].iov_len] = '\\0';\n\n        uint64_t val;\n        if (!safe_strtoull(value, &val)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        if (increment) {\n            val += delta;\n        } else {\n            if (delta > val) {\n                val = 0;\n            } else {\n                val -= delta;\n            }\n        }\n\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64, val);\n        *result = val;\n        item *nit = NULL;\n        if (e->allocate(handle, cookie, &nit, key,\n                        nkey, nb, info.flags, info.exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info i2 = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, nit, &i2)) {\n            e->release(handle, cookie, it);\n            e->release(handle, cookie, nit);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(i2.value[0].iov_base, value, nb);\n        e->item_set_cas(handle, cookie, nit, info.cas);\n        ret = e->store(handle, cookie, nit, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n        e->release(handle, cookie, nit);\n    } else if (ret == ENGINE_KEY_ENOENT && create) {\n        char value[80];\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64\"\\r\\n\", initial);\n        *result = initial;\n        if (e->allocate(handle, cookie, &it, key, nkey, nb, 0, exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info info = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(info.value[0].iov_base, value, nb);\n        ret = e->store(handle, cookie, it, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n    }\n\n    /* We had a race condition.. just call ourself recursively to retry */\n    if (ret == ENGINE_KEY_EEXISTS) {\n        return internal_arithmetic(handle, cookie, key, nkey, increment, create, delta,\n                                   initial, exptime, cas, result, vbucket);\n    }\n\n    return ret;\n}\n\n/**\n * Register an extension if it's not already registered\n *\n * @param type the type of the extension to register\n * @param extension the extension to register\n * @return true if success, false otherwise\n */\nstatic bool register_extension(extension_type_t type, void *extension)\n{\n    if (extension == NULL) {\n        return false;\n    }\n\n    switch (type) {\n    case EXTENSION_DAEMON:\n        for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n             ptr != NULL;\n             ptr = ptr->next) {\n            if (ptr == extension) {\n                return false;\n            }\n        }\n        ((EXTENSION_DAEMON_DESCRIPTOR *)(extension))->next = settings.extensions.daemons;\n        settings.extensions.daemons = extension;\n        return true;\n    case EXTENSION_LOGGER:\n        settings.extensions.logger = extension;\n        return true;\n    case EXTENSION_ASCII_PROTOCOL:\n        if (settings.extensions.ascii != NULL) {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *last;\n            for (last = settings.extensions.ascii; last->next != NULL;\n                 last = last->next) {\n                if (last == extension) {\n                    return false;\n                }\n            }\n            if (last == extension) {\n                return false;\n            }\n            last->next = extension;\n            last->next->next = NULL;\n        } else {\n            settings.extensions.ascii = extension;\n            settings.extensions.ascii->next = NULL;\n        }\n        return true;\n\n    default:\n        return false;\n    }\n}\n\n/**\n * Unregister an extension\n *\n * @param type the type of the extension to remove\n * @param extension the extension to remove\n */\nstatic void unregister_extension(extension_type_t type, void *extension)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        {\n            EXTENSION_DAEMON_DESCRIPTOR *prev = NULL;\n            EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.daemons == ptr) {\n                settings.extensions.daemons = ptr->next;\n            }\n        }\n        break;\n    case EXTENSION_LOGGER:\n        if (settings.extensions.logger == extension) {\n            if (get_stderr_logger() == extension) {\n                settings.extensions.logger = get_null_logger();\n            } else {\n                settings.extensions.logger = get_stderr_logger();\n            }\n        }\n        break;\n    case EXTENSION_ASCII_PROTOCOL:\n        {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *prev = NULL;\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.ascii == ptr) {\n                settings.extensions.ascii = ptr->next;\n            }\n        }\n        break;\n\n    default:\n        ;\n    }\n\n}\n\n/**\n * Get the named extension\n */\nstatic void* get_extension(extension_type_t type)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        return settings.extensions.daemons;\n\n    case EXTENSION_LOGGER:\n        return settings.extensions.logger;\n\n    case EXTENSION_ASCII_PROTOCOL:\n        return settings.extensions.ascii;\n\n    default:\n        return NULL;\n    }\n}\n\n#ifdef INNODB_MEMCACHED\nvoid shutdown_server(void) {\n#else\nstatic void shutdown_server(void) {\n#endif /* INNODB_MEMCACHED */\n#ifdef INNODB_MEMCACHED\n    int i;\n    /* Clean up connections */\n    while (listen_conn) {\n\tconn_closing(listen_conn);\n\tlisten_conn = listen_conn->next;\n    }\n\n    for (i = 0; i < num_udp_socket; i++) {\n\tsafe_close(udp_socket[i]);\n    }\n#endif\n    memcached_shutdown = 1;\n}\n\n#ifdef INNODB_MEMCACHED\nbool shutdown_complete(void)\n{\n    return(memcached_shutdown == 2);\n}\n\nbool init_complete(void)\n{\n    return(memcached_initialized == 1);\n}\n#endif\n\nstatic EXTENSION_LOGGER_DESCRIPTOR* get_logger(void)\n{\n    return settings.extensions.logger;\n}\n\nstatic EXTENSION_LOG_LEVEL get_log_level(void)\n{\n    EXTENSION_LOG_LEVEL ret;\n    switch (settings.verbose) {\n    case 0: ret = EXTENSION_LOG_WARNING; break;\n    case 1: ret = EXTENSION_LOG_INFO; break;\n    case 2: ret = EXTENSION_LOG_DEBUG; break;\n    default:\n        ret = EXTENSION_LOG_DETAIL;\n    }\n    return ret;\n}\n\nstatic void set_log_level(EXTENSION_LOG_LEVEL severity)\n{\n    switch (severity) {\n    case EXTENSION_LOG_WARNING: settings.verbose = 0; break;\n    case EXTENSION_LOG_INFO: settings.verbose = 1; break;\n    case EXTENSION_LOG_DEBUG: settings.verbose = 2; break;\n    default:\n        settings.verbose = 3;\n    }\n}\n\nstatic void get_config_append_stats(const char *key, const uint16_t klen,\n                                    const char *val, const uint32_t vlen,\n                                    const void *cookie)\n{\n    if (klen == 0  || vlen == 0) {\n        return ;\n    }\n\n    char *pos = (char*)cookie;\n    size_t nbytes = strlen(pos);\n\n    if ((nbytes + klen + vlen + 3) > 1024) {\n        // Not enough size in the buffer..\n        return;\n    }\n\n    memcpy(pos + nbytes, key, klen);\n    nbytes += klen;\n    pos[nbytes] = '=';\n    ++nbytes;\n    memcpy(pos + nbytes, val, vlen);\n    nbytes += vlen;\n    memcpy(pos + nbytes, \";\", 2);\n}\n\nstatic bool get_config(struct config_item items[]) {\n    char config[1024];\n    config[0] = '\\0';\n    process_stat_settings(get_config_append_stats, config);\n    int rval = parse_config(config, items, NULL);\n    return rval >= 0;\n}\n\n/**\n * Callback the engines may call to get the public server interface\n * @return pointer to a structure containing the interface. The client should\n *         know the layout and perform the proper casts.\n */\nstatic SERVER_HANDLE_V1 *get_server_api(void)\n{\n    static SERVER_CORE_API core_api = {\n        .server_version = get_server_version,\n        .hash = hash,\n        .realtime = realtime,\n        .abstime = abstime,\n        .get_current_time = get_current_time,\n        .parse_config = parse_config,\n        .shutdown = shutdown_server,\n        .get_config = get_config\n    };\n\n    static SERVER_COOKIE_API server_cookie_api = {\n        .get_auth_data = get_auth_data,\n        .store_engine_specific = store_engine_specific,\n        .get_engine_specific = get_engine_specific,\n        .get_socket_fd = get_socket_fd,\n        .set_tap_nack_mode = set_tap_nack_mode,\n        .notify_io_complete = notify_io_complete,\n        .reserve = reserve_cookie,\n        .release = release_cookie\n    };\n\n    static SERVER_STAT_API server_stat_api = {\n        .new_stats = new_independent_stats,\n        .release_stats = release_independent_stats,\n        .evicting = count_eviction\n    };\n\n    static SERVER_LOG_API server_log_api = {\n        .get_logger = get_logger,\n        .get_level = get_log_level,\n        .set_level = set_log_level\n    };\n    static SERVER_EXTENSION_API extension_api = {\n        .register_extension = register_extension,\n        .unregister_extension = unregister_extension,\n        .get_extension = get_extension\n    };\n\n    static SERVER_CALLBACK_API callback_api = {\n        .register_callback = register_callback,\n        .perform_callbacks = perform_callbacks,\n    };\n\n    static SERVER_HANDLE_V1 rv = {\n        .interface = 1,\n        .core = &core_api,\n        .stat = &server_stat_api,\n        .extension = &extension_api,\n        .callback = &callback_api,\n        .log = &server_log_api,\n        .cookie = &server_cookie_api\n    };\n\n    if (rv.engine == NULL) {\n        rv.engine = settings.engine.v0;\n    }\n\n    return &rv;\n}\n\n/**\n * Load a shared object and initialize all the extensions in there.\n *\n * @param soname the name of the shared object (may not be NULL)\n * @param config optional configuration parameters\n * @return true if success, false otherwise\n */\nstatic bool load_extension(const char *soname, const char *config) {\n    if (soname == NULL) {\n        return false;\n    }\n\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        MEMCACHED_EXTENSIONS_INITIALIZE initialize;\n        void* voidptr;\n    } funky = {.initialize = NULL };\n\n    void *handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"memcached_extensions_initialize\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"memcached_extensions_initialize\\\" in %s: %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n    funky.voidptr = symbol;\n\n    EXTENSION_ERROR_CODE error = (*funky.initialize)(config, get_server_api);\n\n    if (error != EXTENSION_SUCCESS) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initalize extensions from %s. Error code: %d\\n\",\n                soname, error);\n        dlclose(handle);\n        return false;\n    }\n\n    if (settings.verbose > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                \"Loaded extensions from: %s\\n\", soname);\n    }\n\n    return true;\n}\n\n/**\n * Do basic sanity check of the runtime environment\n * @return true if no errors found, false if we can't use this env\n */\nstatic bool sanitycheck(void) {\n    /* One of our biggest problems is old and bogus libevents */\n    const char *ever = event_get_version();\n    if (ever != NULL) {\n        if (strncmp(ever, \"1.\", 2) == 0) {\n            /* Require at least 1.3 (that's still a couple of years old) */\n            if ((ever[2] == '1' || ever[2] == '2') && !isdigit(ever[3])) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"You are using libevent %s.\\nPlease upgrade to\"\n                        \" a more recent version (1.3 or newer)\\n\",\n                        event_get_version());\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n#ifdef INNODB_MEMCACHED\nstatic\nchar*\nmy_strdupl(const char* str, int len)\n{\n\tchar*   s = (char*) malloc(len + 1);\n\ts[len] = 0;\n\treturn((char*) memcpy(s, str, len));\n}\n\n/** Function that messages MySQL config variable string to something\nthat can be parsed by getopt() */\nstatic\nvoid\ndaemon_memcached_make_option(char* option, int* option_argc,\n                             char*** option_argv)\n{\n\tstatic const char*      sep = \" \";\n\tchar*                   last;\n\tchar*                   opt_str;\n\tchar*                   my_str;\n\tint                     num_arg = 0;\n\tint                     i = 1;\n\n\tmy_str = my_strdupl(option, strlen(option));\n\n\tfor (opt_str = strtok_r(my_str, sep, &last);\n\t     opt_str;\n\t     opt_str = strtok_r(NULL, sep, &last)) {\n\t\tnum_arg++;\n\t}\n\n\t/* reset my_str, since strtok_r could alter it */\n\tstrncpy(my_str, option, strlen(option));\n\n\t*option_argv = (char**) malloc((num_arg + 1)\n\t\t\t\t       * sizeof(**option_argv));\n\n\tfor (opt_str = strtok_r(my_str, sep, &last);\n\t     opt_str;\n\t     opt_str = strtok_r(NULL, sep, &last)) {\n\t\t(*option_argv)[i] = opt_str;\n\t\ti++;\n\t}\n\n\tassert(i == num_arg + 1);\n\n\t*option_argc = (num_arg + 1);\n\n\treturn;\n}\n\n/* Structure that adds the call back functions struture pointers,\npassed to InnoDB engine */\ntypedef struct eng_config_info {\n\tchar*           option_string;\n\tvoid*           cb_ptr;\n\tunsigned int    eng_r_batch_size;\n\tunsigned int    eng_w_batch_size;\n\tbool\t\tenable_binlog;\n} eng_config_info_t;\n#endif /* INNODB_MEMCACHED */\n\n#ifdef INNODB_MEMCACHED\nvoid* daemon_memcached_main(void *p) {\n#else\nint main (int argc, char **argv) {\n#endif\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    bool preallocate = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char unit = '\\0';\n    int size_max = 0;\n\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n    memcached_context_t* m_config = (memcached_context_t*)p;\n    const char *engine;\n    const char *engine_config = NULL;\n    char old_options[1024] = { [0] = '\\0' };\n    char *old_opts = old_options;\n#ifdef INNODB_MEMCACHED\n    int option_argc = 0;\n    char** option_argv = NULL;\n    eng_config_info_t my_eng_config;\n\n    memcached_initialized = 0;\n\n    if (m_config->m_engine_library) {\n\tengine = m_config->m_engine_library;\n\n\t/* FIXME: We should have a better way to pass the callback structure\n\tpoint to storage engine. It is now appended in the configure\n\tstring in eng_config_info_t structure */\n\tmy_eng_config.cb_ptr = m_config->m_innodb_api_cb;\n\tmy_eng_config.eng_r_batch_size = m_config->m_r_batch_size;\n\tmy_eng_config.eng_w_batch_size = m_config->m_w_batch_size;\n\tmy_eng_config.enable_binlog = m_config->m_enable_binlog;\n\tmy_eng_config.option_string = old_opts;\n\tengine_config = (const char *) (&my_eng_config);\n\n    } else {\n\tengine = \"default_engine.so\";\n    }\n#else\n    engine = \"default_engine.so\";\n#endif /* INNODB_MEMCACHED */\n\n    memcached_shutdown = 0;\n    memcached_initialized = 0;\n\n    if (!sanitycheck()) {\n        return(NULL);\n    }\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - 2;\n    set_current_time();\n\n    /* Initialize the socket subsystem */\n    initialize_sockets();\n\n    /* init settings */\n    settings_init();\n\n    if (memcached_initialize_stderr_logger(get_server_api) != EXTENSION_SUCCESS) {\n        fprintf(stderr, \"Failed to initialize log system\\n\");\n        return (NULL);\n    }\n\n    if (m_config->m_mem_option) {\n\tdaemon_memcached_make_option(m_config->m_mem_option,\n\t\t\t\t     &option_argc,\n\t\t\t\t     &option_argv);\n    }\n\n#ifdef INNODB_MEMCACHED\n\n    if (option_argc > 0 && option_argv) {\n\t    /* Always reset the index to 1, since this function can\n\t    be invoked multiple times with install/uninstall plugins */\n\t    optind = 1;\n\t    while (-1 != (c = getopt(option_argc, option_argv,\n\t\t  \"a:\"  /* access mask for unix socket */\n\t\t  \"p:\"  /* TCP port number to listen on */\n\t\t  \"s:\"  /* unix socket path to listen on */\n\t\t  \"U:\"  /* UDP port number to listen on */\n\t\t  \"m:\"  /* max memory to use for items in megabytes */\n\t\t  \"M\"   /* return error on memory exhausted */\n\t\t  \"c:\"  /* max simultaneous connections */\n\t\t  \"k\"   /* lock down all paged memory */\n\t\t  \"hi\"  /* help, licence info */\n\t\t  \"r\"   /* maximize core file limit */\n\t\t  \"v\"   /* verbose */\n\t\t  \"d\"   /* daemon mode */\n\t\t  \"l:\"  /* interface to listen on */\n\t\t  \"u:\"  /* user identity to run as */\n\t\t  \"P:\"  /* save PID in file */\n\t\t  \"f:\"  /* factor? */\n\t\t  \"n:\"  /* minimum space allocated for key+value+flags */\n\t\t  \"t:\"  /* threads */\n\t\t  \"D:\"  /* prefix delimiter? */\n\t\t  \"L\"   /* Large memory pages */\n\t\t  \"R:\"  /* max requests per event */\n\t\t  \"C\"   /* Disable use of CAS */\n\t\t  \"b:\"  /* backlog queue limit */\n\t\t  \"B:\"  /* Binding protocol */\n\t\t  \"I:\"  /* Max item size */\n\t\t  \"S\"   /* Sasl ON */\n\t\t  \"E:\"  /* Engine to load */\n\t\t  \"e:\"  /* Engine options */\n\t\t  \"q\"   /* Disallow detailed stats */\n\t\t  \"X:\"  /* Load extension */\n\t\t))) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t    /* access for unix domain socket, as octal mask (like chmod)*/\n\t\t    settings.access= strtol(optarg,NULL,8);\n\t\t    break;\n\n\t\tcase 'U':\n\t\t    settings.udpport = atoi(optarg);\n\t\t    udp_specified = true;\n\t\t    break;\n\t\tcase 'p':\n\t\t    settings.port = atoi(optarg);\n\t\t    tcp_specified = true;\n\t\t    break;\n\t\tcase 's':\n\t\t    settings.socketpath = optarg;\n\t\t    break;\n\t\tcase 'm':\n\t\t    settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n\t\t     old_opts += sprintf(old_opts, \"cache_size=%lu;\",\n\t\t\t\t\t (unsigned long)settings.maxbytes);\n\t\t   break;\n\t\tcase 'M':\n\t\t    settings.evict_to_free = 0;\n\t\t    old_opts += sprintf(old_opts, \"eviction=false;\");\n\t\t    break;\n\t\tcase 'c':\n\t\t    settings.maxconns = atoi(optarg);\n\t\t    break;\n\t\tcase 'h':\n\t\t    usage();\n\t\t    exit(EXIT_SUCCESS);\n\t\tcase 'i':\n\t\t    usage_license();\n\t\t    exit(EXIT_SUCCESS);\n\t\tcase 'k':\n\t\t    lock_memory = true;\n\t\t    break;\n\t\tcase 'v':\n\t\t    settings.verbose++;\n\t\t    perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n\t\t    break;\n\t\tcase 'l':\n\t\t    settings.inter= strdup(optarg);\n\t\t    break;\n\t\tcase 'd':\n\t\t    do_daemonize = true;\n\t\t    break;\n\t\tcase 'r':\n\t\t    maxcore = 1;\n\t\t    break;\n\t\tcase 'R':\n\t\t    settings.reqs_per_event = atoi(optarg);\n\t\t    if (settings.reqs_per_event <= 0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t      \"Number of requests per event must be greater than 0\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    break;\n\t\tcase 'u':\n\t\t    username = optarg;\n\t\t    break;\n\t\tcase 'P':\n\t\t    pid_file = optarg;\n\t\t    break;\n\t\tcase 'f':\n\t\t    settings.factor = atof(optarg);\n\t\t    if (settings.factor <= 1.0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Factor must be greater than 1\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t     old_opts += sprintf(old_opts, \"factor=%f;\",\n\t\t\t\t\t settings.factor);\n\t\t   break;\n\t\tcase 'n':\n\t\t    settings.chunk_size = atoi(optarg);\n\t\t    if (settings.chunk_size == 0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Chunk size must be greater than 0\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    old_opts += sprintf(old_opts, \"chunk_size=%u;\",\n\t\t\t\t\tsettings.chunk_size);\n\t\t    break;\n\t\tcase 't':\n\t\t    settings.num_threads = atoi(optarg);\n\t\t    if (settings.num_threads <= 0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Number of threads must be greater than 0\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    /* There're other problems when you get above 64 threads.\n\t\t     * In the future we should portably detect # of cores for the\n\t\t     * default.\n\t\t     */\n\t\t    if (settings.num_threads > 64) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"WARNING: Setting a high number of worker\"\n\t\t\t\t\"threads is not recommended.\\n\"\n\t\t\t\t\" Set this value to the number of cores in\"\n\t\t\t\t\" your machine or less.\\n\");\n\t\t    }\n\t\t    break;\n\t\tcase 'D':\n\t\t    settings.prefix_delimiter = optarg[0];\n\t\t    settings.detail_enabled = 1;\n\t\t    break;\n\t\tcase 'L' :\n\t\t    if (enable_large_pages() == 0) {\n\t\t\tpreallocate = true;\n\t\t\told_opts += sprintf(old_opts, \"preallocate=true;\");\n\t\t    }\n\t\t    break;\n\t\tcase 'C' :\n\t\t    settings.use_cas = false;\n\t\t    break;\n\t\tcase 'b' :\n\t\t    settings.backlog = atoi(optarg);\n\t\t    break;\n\t\tcase 'B':\n\t\t    protocol_specified = true;\n\t\t    if (strcmp(optarg, \"auto\") == 0) {\n\t\t\tsettings.binding_protocol = negotiating_prot;\n\t\t    } else if (strcmp(optarg, \"binary\") == 0) {\n\t\t\tsettings.binding_protocol = binary_prot;\n\t\t    } else if (strcmp(optarg, \"ascii\") == 0) {\n\t\t\tsettings.binding_protocol = ascii_prot;\n\t\t    } else {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Invalid value for binding protocol: %s\\n\"\n\t\t\t\t\" -- should be one of auto, binary, or ascii\\n\", optarg);\n\t\t\texit(EX_USAGE);\n\t\t    }\n\t\t    break;\n\t\tcase 'I':\n\t\t    unit = optarg[strlen(optarg)-1];\n\t\t    if (unit == 'k' || unit == 'm' ||\n\t\t\tunit == 'K' || unit == 'M') {\n\t\t\toptarg[strlen(optarg)-1] = '\\0';\n\t\t\tsize_max = atoi(optarg);\n\t\t\tif (unit == 'k' || unit == 'K')\n\t\t\t    size_max *= 1024;\n\t\t\tif (unit == 'm' || unit == 'M')\n\t\t\t    size_max *= 1024 * 1024;\n\t\t\tsettings.item_size_max = size_max;\n\t\t    } else {\n\t\t\tsettings.item_size_max = atoi(optarg);\n\t\t    }\n\t\t    if (settings.item_size_max < 1024) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Item max size cannot be less than 1024 bytes.\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    if (settings.item_size_max > 1024 * 1024 * 128) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Cannot set item size limit higher than 128 mb.\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    if (settings.item_size_max > 1024 * 1024) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t    \"WARNING: Setting item max size above 1MB is not\"\n\t\t\t    \" recommended!\\n\"\n\t\t\t    \" Raising this limit increases the minimum memory requirements\\n\"\n\t\t\t    \" and will decrease your memory efficiency.\\n\"\n\t\t\t);\n\t\t    }\n#ifndef __WIN32__\n\t\t    old_opts += sprintf(old_opts, \"item_size_max=%zu;\",\n\t\t\t\t\tsettings.item_size_max);\n#else\n\t\t    old_opts += sprintf(old_opts, \"item_size_max=%lu;\", (long unsigned)\n\t\t\t\t\tsettings.item_size_max);\n#endif\n\t\t    break;\n\t\tcase 'E':\n\t\t    engine = optarg;\n\t\t    break;\n\t\tcase 'e':\n\t\t    /* FIXME, we use engine_config to pass callback function\n\t\t    for now. Will need a better solution \n\t\t    engine_config = optarg; */\n\t\t    break;\n\t\tcase 'q':\n\t\t    settings.allow_detailed = false;\n\t\t    break;\n\t\tcase 'S': /* set Sasl authentication to true. Default is false */\n# ifdef ENABLE_MEMCACHED_SASL\n#  ifndef SASL_ENABLED\n\t\t    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t    \"This server is not built with SASL support.\\n\");\n\t\t    exit(EX_USAGE);\n#  endif /* !SASL_ENABLED */\n\t\t    settings.require_sasl = true;\n# endif /* ENABLE_MEMCACHED_SASL */\n\t\t    break;\n\t\tcase 'X' :\n\t\t    {\n\t\t\tchar *ptr = strchr(optarg, ',');\n\t\t\tif (ptr != NULL) {\n\t\t\t    *ptr = '\\0';\n\t\t\t    ++ptr;\n\t\t\t}\n\t\t\tif (!load_extension(optarg, ptr)) {\n\t\t\t    exit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tif (ptr != NULL) {\n\t\t\t    *(ptr - 1) = ',';\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t    \"Illegal argument \\\"%c\\\"\\n\", c);\n\t\t    return (void*)1;\n\t\t}\n\t}\n\n\tfree(option_argv);\n    }\n    fprintf(stderr, MEMCACHED_ATOMIC_MSG);\n#else\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  /* access mask for unix socket */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hi\"  /* help, licence info */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n          \"E:\"  /* Engine to load */\n          \"e:\"  /* Engine options */\n          \"q\"   /* Disallow detailed stats */\n          \"X:\"  /* Load extension */\n        ))) {\n        switch (c) {\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n             old_opts += sprintf(old_opts, \"cache_size=%lu;\",\n                                 (unsigned long)settings.maxbytes);\n           break;\n        case 'M':\n            settings.evict_to_free = 0;\n            old_opts += sprintf(old_opts, \"eviction=false;\");\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                      \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n             old_opts += sprintf(old_opts, \"factor=%f;\",\n                                 settings.factor);\n           break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            old_opts += sprintf(old_opts, \"chunk_size=%u;\",\n                                settings.chunk_size);\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"WARNING: Setting a high number of worker\"\n                        \"threads is not recommended.\\n\"\n                        \" Set this value to the number of cores in\"\n                        \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                preallocate = true;\n                old_opts += sprintf(old_opts, \"preallocate=true;\");\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            unit = optarg[strlen(optarg)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                optarg[strlen(optarg)-1] = '\\0';\n                size_max = atoi(optarg);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(optarg);\n            }\n            if (settings.item_size_max < 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n#ifndef __WIN32__\n            old_opts += sprintf(old_opts, \"item_size_max=%zu;\",\n                                settings.item_size_max);\n#else\n            old_opts += sprintf(old_opts, \"item_size_max=%lu;\", (long unsigned)\n                                settings.item_size_max);\n#endif\n            break;\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_config = optarg;\n            break;\n        case 'q':\n            settings.allow_detailed = false;\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef SASL_ENABLED\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#endif\n            settings.require_sasl = true;\n            break;\n        case 'X' :\n            {\n                char *ptr = strchr(optarg, ',');\n                if (ptr != NULL) {\n                    *ptr = '\\0';\n                    ++ptr;\n                }\n                if (!load_extension(optarg, ptr)) {\n                    exit(EXIT_FAILURE);\n                }\n                if (ptr != NULL) {\n                    *(ptr - 1) = ',';\n                }\n            }\n            break;\n        default:\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n#endif /* INNODB_MEMCACHED */\n\n    if (getenv(\"MEMCACHED_REQS_TAP_EVENT\") != NULL) {\n        settings.reqs_per_tap_event = atoi(getenv(\"MEMCACHED_REQS_TAP_EVENT\"));\n    }\n\n    if (settings.reqs_per_tap_event <= 0) {\n        settings.reqs_per_tap_event = DEFAULT_REQS_PER_TAP_EVENT;\n    }\n\n\n    if (install_sigterm_handler() != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"Failed to install SIGTERM handler\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    char *topkeys_env = getenv(\"MEMCACHED_TOP_KEYS\");\n    if (topkeys_env != NULL) {\n        settings.topkeys = atoi(topkeys_env);\n        if (settings.topkeys < 0) {\n            settings.topkeys = 0;\n        }\n    }\n\n    if (settings.require_sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol == negotiating_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use auto-negotiating protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n            if (settings.binding_protocol == ascii_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use only ASCII protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (tcp_specified && !udp_specified) {\n        settings.udpport = settings.port;\n    } else if (udp_specified && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n    /*\n    if (engine_config != NULL && strlen(old_options) > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"ERROR: You can't mix -e with the old options\\n\");\n        return (NULL);\n    } else if (engine_config == NULL && strlen(old_options) > 0) {\n        engine_config = old_options;\n    } */\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        int maxfiles = settings.maxconns;\n        if (rlim.rlim_cur < maxfiles)\n            rlim.rlim_cur = maxfiles;\n        if (rlim.rlim_max < rlim.rlim_cur)\n            rlim.rlim_max = rlim.rlim_cur;\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to set rlimit for open files. Try running as\"\n                    \" root or requesting smaller maxconns value.\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /* Sanity check for the connection structures */\n    int nfiles = 0;\n    if (settings.port != 0) {\n        nfiles += 2;\n    }\n    if (settings.udpport != 0) {\n        nfiles += settings.num_threads * 2;\n    }\n\n    if (settings.maxconns <= nfiles) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Configuratioin error. \\n\"\n                \"You specified %d connections, but the system will use at \"\n                \"least %d\\nconnection structures to start.\\n\",\n                settings.maxconns, nfiles);\n        exit(EX_USAGE);\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to assume identity of user %s: %s\\n\", username,\n                    strerror(errno));\n            exit(EX_OSERR);\n        }\n    }\n\n#ifdef SASL_ENABLED\n    init_sasl();\n#endif /* SASL */\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to ignore SIGHUP: \", strerror(errno));\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n             settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n    main_base = event_init();\n\n    /* Load the storage engine */\n    ENGINE_HANDLE *engine_handle = NULL;\n    if (!load_engine(engine,get_server_api,settings.extensions.logger,&engine_handle)) {\n        /* Error already reported */\n        exit(EXIT_FAILURE);\n    }\n\n    if(!init_engine(engine_handle,engine_config,settings.extensions.logger)) {\n#ifdef INNODB_MEMCACHED\n        shutdown_server();\n        goto func_exit;\n#else\n\treturn(false);\n#endif /* INNODB_MEMCACHED */\n    }\n\n    if(settings.verbose > 0) {\n        log_engine_details(engine_handle,settings.extensions.logger);\n    }\n    settings.engine.v1 = (ENGINE_HANDLE_V1 *) engine_handle;\n\n    if (settings.engine.v1->arithmetic == NULL) {\n        settings.engine.v1->arithmetic = internal_arithmetic;\n    }\n\n    /* initialize other stuff */\n    stats_init();\n\n    if (!(conn_cache = cache_create(\"conn\", sizeof(conn), sizeof(void*),\n                                    conn_constructor, conn_destructor))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create connection cache\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    default_independent_stats = new_independent_stats();\n\n#ifdef INNODB_MEMCACHED\n    if (!default_independent_stats) {\n\texit(EXIT_FAILURE);\n    }\n#endif\n\n#ifndef __WIN32__\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n#endif\n\n    /* start up worker threads if MT mode */\n    thread_init(settings.num_threads, main_base, dispatch_event_handler);\n\n    /* initialise clock event */\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        int udp_port;\n\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char temp_portnumber_filename[PATH_MAX];\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            snprintf(temp_portnumber_filename,\n                     sizeof(temp_portnumber_filename),\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                            portnumber_file)) {\n\t\tvperror(\"failed to listen on TCP port %d\", settings.port);\n#ifdef INNODB_MEMCACHED\n\t\tshutdown_server();\n\t\tgoto func_exit;\n#else\n\t\texit(EX_OSERR);\n#endif /* INNODB_MEMCACHED */\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonise if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n        udp_port = settings.udpport ? settings.udpport : settings.port;\n\n        /* create the UDP listening socket and bind it */\n        if (settings.udpport && server_sockets(settings.udpport, udp_transport,\n                                               portnumber_file)) {\n            vperror(\"failed to listen on UDP port %d\", settings.udpport);\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    /* Drop privileges no longer needed */\n    drop_privileges();\n\n    memcached_initialized = 1;\n\n    /* enter the event loop */\n    event_base_loop(main_base, 0);\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Initiating shutdown\\n\");\n    }\n\nfunc_exit:\n\n    if (settings.engine.v1)\n      settings.engine.v1->destroy(settings.engine.v0, false);\n\n    threads_shutdown();\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n\n#ifdef INNODB_MEMCACHED\n    /* free event base */\n    if (main_base) {\n        event_base_free(main_base);\n        main_base = NULL;\n    }\n#endif\n\n    memcached_shutdown = 2;\n    memcached_initialized = 2;\n\n    return EXIT_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/plugin/innodb_memcached/daemon_memcached/utilities/engine_loader.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <dlfcn.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/types.h>\n\nstatic const char * const feature_descriptions[] = {\n    \"compare and swap\",\n    \"persistent storage\",\n    \"secondary engine\",\n    \"access control\",\n    \"multi tenancy\",\n    \"LRU\"\n};\n\nvoid *handle = NULL;\n\nbool load_engine(const char *soname,\n                 SERVER_HANDLE_V1 *(*get_server_api)(void),\n                 EXTENSION_LOGGER_DESCRIPTOR *logger,\n                 ENGINE_HANDLE **engine_handle)\n{\n    ENGINE_HANDLE *engine = NULL;\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        CREATE_INSTANCE create;\n        void* voidptr;\n    } my_create = {.create = NULL };\n\n    handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname ? soname : \"self\",\n                msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"create_instance\");\n    if (symbol == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"create_instance\\\" in %s: %s\\n\",\n                soname ? soname : \"self\",\n                dlerror());\n        return false;\n    }\n    my_create.voidptr = symbol;\n\n    /* request a instance with protocol version 1 */\n    ENGINE_ERROR_CODE error = (*my_create.create)(1, get_server_api, &engine);\n\n    if (error != ENGINE_SUCCESS || engine == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create instance. Error code: %d\\n\", error);\n        dlclose(handle);\n        return false;\n    }\n    *engine_handle = engine;\n    return true;\n}\n\nbool init_engine(ENGINE_HANDLE * engine,\n                 const char *config_str,\n                 EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = NULL;\n\n    if (handle == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initialize engine, engine must fist be loaded.\");\n        return false;\n    }\n\n    if (engine->interface == 1) {\n        engine_v1 = (ENGINE_HANDLE_V1*)engine;\n\n        // validate that the required engine interface is implemented:\n        if (engine_v1->get_info == NULL || engine_v1->initialize == NULL ||\n            engine_v1->destroy == NULL || engine_v1->allocate == NULL ||\n            engine_v1->remove == NULL || engine_v1->release == NULL ||\n            engine_v1->get == NULL || engine_v1->store == NULL ||\n            engine_v1->flush == NULL ||\n            engine_v1->get_stats == NULL || engine_v1->reset_stats == NULL ||\n            engine_v1->item_set_cas == NULL ||\n            engine_v1->get_item_info == NULL)\n        {\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to initialize engine; it does not implement the engine interface.\");\n            return false;\n        }\n\n        ENGINE_ERROR_CODE error = engine_v1->initialize(engine,config_str);\n        if (error != ENGINE_SUCCESS) {\n            engine_v1->destroy(engine, false);\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to initialize instance. Error code: %d\\n\",\n                    error);\n            dlclose(handle);\n            return false;\n        }\n    } else {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Unsupported interface level\\n\");\n        dlclose(handle);\n        return false;\n    }\n    return true;\n}\n\nvoid log_engine_details(ENGINE_HANDLE * engine,\n                        EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = (ENGINE_HANDLE_V1*)engine;\n    const engine_info *info;\n    info = engine_v1->get_info(engine);\n    if (info) {\n        char message[4096];\n        ssize_t nw = snprintf(message, sizeof(message), \"Loaded engine: %s\\n\",\n                                        info->description ?\n                                        info->description : \"Unknown\");\n        if (nw == -1) {\n            return;\n        }\n        ssize_t offset = nw;\n        bool comma = false;\n\n        if (info->num_features > 0) {\n            nw = snprintf(message + offset, sizeof(message) - offset,\n                          \"Supplying the following features: \");\n            if (nw == -1) {\n                return;\n            }\n            offset += nw;\n            for (int ii = 0; ii < info->num_features; ++ii) {\n                if (info->features[ii].description != NULL) {\n                    // We don't want to write partially from source\n                    if (sizeof(message)-offset <=\n                        2+strlen(info->features[ii].description))\n                    {\n                        return;\n                    }\n\n                    nw = snprintf(message + offset, sizeof(message) - offset,\n                                  \"%s%s\", comma ? \", \" : \"\",\n                                  info->features[ii].description);\n                } else {\n                    if (info->features[ii].feature <= LAST_REGISTERED_ENGINE_FEATURE) {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%s%s\", comma ? \", \" : \"\",\n                                      feature_descriptions[info->features[ii].feature]);\n                    } else {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%sUnknown feature: %d\", comma ? \", \" : \"\",\n                                      info->features[ii].feature);\n                    }\n                }\n                comma = true;\n                if (nw == -1) {\n                    return;\n                }\n                offset += nw;\n            }\n        }\n        logger->log(EXTENSION_LOG_INFO, NULL, \"%s\\n\", message);\n    } else {\n        logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Loaded engine: Unknown\\n\");\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/plugin/innodb_memcached/daemon_memcached/programs/engine_testapp.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <assert.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <signal.h>\n#include <pthread.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/engine_testapp.h>\n#include <memcached/extension_loggers.h>\n#include <mock_server.h>\n\nstruct mock_engine {\n    ENGINE_HANDLE_V1 me;\n    ENGINE_HANDLE_V1 *the_engine;\n    TAP_ITERATOR iterator;\n};\n\n#ifndef WIN32\nstatic sig_atomic_t alarmed;\n\nstatic void alarm_handler(int sig) {\n    alarmed = 1;\n}\n#endif\n\nstatic inline struct mock_engine* get_handle(ENGINE_HANDLE* handle) {\n    return (struct mock_engine*)handle;\n}\n\nstatic tap_event_t mock_tap_iterator(ENGINE_HANDLE* handle,\n                                     const void *cookie, item **itm,\n                                     void **es, uint16_t *nes, uint8_t *ttl,\n                                     uint16_t *flags, uint32_t *seqno,\n                                     uint16_t *vbucket) {\n   struct mock_engine *me = get_handle(handle);\n   return me->iterator((ENGINE_HANDLE*)me->the_engine, cookie, itm, es, nes,\n                       ttl, flags, seqno, vbucket);\n}\n\nstatic const engine_info* mock_get_info(ENGINE_HANDLE* handle) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_info((ENGINE_HANDLE*)me->the_engine);\n}\n\nstatic ENGINE_ERROR_CODE mock_initialize(ENGINE_HANDLE* handle,\n                                         const char* config_str) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->initialize((ENGINE_HANDLE*)me->the_engine, config_str);\n}\n\nstatic void mock_destroy(ENGINE_HANDLE* handle, const bool force) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->destroy((ENGINE_HANDLE*)me->the_engine, force);\n}\n\nstatic ENGINE_ERROR_CODE mock_allocate(ENGINE_HANDLE* handle,\n                                       const void* cookie,\n                                       item **item,\n                                       const void* key,\n                                       const size_t nkey,\n                                       const size_t nbytes,\n                                       const int flags,\n                                       const rel_time_t exptime) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->allocate((ENGINE_HANDLE*)me->the_engine, c,\n                                           item, key, nkey,\n                                           nbytes, flags,\n                                           exptime)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_remove(ENGINE_HANDLE* handle,\n                                     const void* cookie,\n                                     const void* key,\n                                     const size_t nkey,\n                                     uint64_t cas,\n                                     uint16_t vbucket)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->remove((ENGINE_HANDLE*)me->the_engine, c, key,\n                                         nkey, cas, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_release(ENGINE_HANDLE* handle,\n                         const void *cookie,\n                         item* item) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->release((ENGINE_HANDLE*)me->the_engine, cookie, item);\n}\n\nstatic ENGINE_ERROR_CODE mock_get(ENGINE_HANDLE* handle,\n                                  const void* cookie,\n                                  item** item,\n                                  const void* key,\n                                  const int nkey,\n                                  uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get((ENGINE_HANDLE*)me->the_engine, c, item,\n                                      key, nkey, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_get_stats(ENGINE_HANDLE* handle,\n                                        const void* cookie,\n                                        const char* stat_key,\n                                        int nkey,\n                                        ADD_STAT add_stat)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get_stats((ENGINE_HANDLE*)me->the_engine, c, stat_key,\n                                            nkey, add_stat)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_store(ENGINE_HANDLE* handle,\n                                    const void *cookie,\n                                    item* item,\n                                    uint64_t *cas,\n                                    ENGINE_STORE_OPERATION operation,\n                                    uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->store((ENGINE_HANDLE*)me->the_engine, c, item, cas,\n                                        operation, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_arithmetic(ENGINE_HANDLE* handle,\n                                         const void* cookie,\n                                         const void* key,\n                                         const int nkey,\n                                         const bool increment,\n                                         const bool create,\n                                         const uint64_t delta,\n                                         const uint64_t initial,\n                                         const rel_time_t exptime,\n                                         uint64_t *cas,\n                                         uint64_t *result,\n                                         uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->arithmetic((ENGINE_HANDLE*)me->the_engine, c, key,\n                                             nkey, increment, create,\n                                             delta, initial, exptime,\n                                             cas, result, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_flush(ENGINE_HANDLE* handle,\n                                    const void* cookie, time_t when) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->flush((ENGINE_HANDLE*)me->the_engine, c, when)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_reset_stats(ENGINE_HANDLE* handle, const void *cookie) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->reset_stats((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_unknown_command(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              protocol_binary_request_header *request,\n                                              ADD_RESPONSE response)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->unknown_command((ENGINE_HANDLE*)me->the_engine, c,\n                                                  request, response)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_item_set_cas(ENGINE_HANDLE *handle, const void *cookie,\n                              item* item, uint64_t val)\n{\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->item_set_cas((ENGINE_HANDLE*)me->the_engine, cookie, item, val);\n}\n\n\nstatic bool mock_get_item_info(ENGINE_HANDLE *handle, const void *cookie,\n                               const item* item, item_info *item_info)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_item_info((ENGINE_HANDLE*)me->the_engine,\n                                         cookie, item, item_info);\n}\n\nstatic void *mock_get_stats_struct(ENGINE_HANDLE* handle, const void* cookie)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_stats_struct((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_aggregate_stats(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              void (*callback)(void*, void*),\n                                              void *vptr)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->aggregate_stats((ENGINE_HANDLE*)me->the_engine, c,\n                                                  callback, vptr)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_tap_notify(ENGINE_HANDLE* handle,\n                                        const void *cookie,\n                                        void *engine_specific,\n                                        uint16_t nengine,\n                                        uint8_t ttl,\n                                        uint16_t tap_flags,\n                                        tap_event_t tap_event,\n                                        uint32_t tap_seqno,\n                                        const void *key,\n                                        size_t nkey,\n                                        uint32_t flags,\n                                        uint32_t exptime,\n                                        uint64_t cas,\n                                        const void *data,\n                                        size_t ndata,\n                                         uint16_t vbucket) {\n\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->tap_notify((ENGINE_HANDLE*)me->the_engine, c,\n                                             engine_specific, nengine, ttl, tap_flags,\n                                             tap_event, tap_seqno, key, nkey, flags,\n                                             exptime, cas, data, ndata, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\n\nstatic TAP_ITERATOR mock_get_tap_iterator(ENGINE_HANDLE* handle, const void* cookie,\n                                           const void* client, size_t nclient,\n                                           uint32_t flags,\n                                           const void* userdata, size_t nuserdata) {\n    struct mock_engine *me = get_handle(handle);\n    me->iterator = me->the_engine->get_tap_iterator((ENGINE_HANDLE*)me->the_engine, cookie,\n                                                    client, nclient, flags, userdata, nuserdata);\n    return (me->iterator != NULL) ? mock_tap_iterator : NULL;\n}\n\nstatic size_t mock_errinfo(ENGINE_HANDLE *handle, const void* cookie,\n                           char *buffer, size_t buffsz) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->errinfo((ENGINE_HANDLE*)me->the_engine, cookie,\n                                   buffer, buffsz);\n}\n\n\nstruct mock_engine default_mock_engine = {\n    .me = {\n        .interface = {\n            .interface = 1\n        },\n        .get_info = mock_get_info,\n        .initialize = mock_initialize,\n        .destroy = mock_destroy,\n        .allocate = mock_allocate,\n        .remove = mock_remove,\n        .release = mock_release,\n        .get = mock_get,\n        .store = mock_store,\n        .arithmetic = mock_arithmetic,\n        .flush = mock_flush,\n        .get_stats = mock_get_stats,\n        .reset_stats = mock_reset_stats,\n        .get_stats_struct = mock_get_stats_struct,\n        .aggregate_stats = mock_aggregate_stats,\n        .unknown_command = mock_unknown_command,\n        .tap_notify = mock_tap_notify,\n        .get_tap_iterator = mock_get_tap_iterator,\n        .item_set_cas = mock_item_set_cas,\n        .get_item_info = mock_get_item_info,\n        .errinfo = mock_errinfo\n    }\n};\nstruct mock_engine mock_engine;\n\nEXTENSION_LOGGER_DESCRIPTOR *logger_descriptor = NULL;\nstatic ENGINE_HANDLE *handle = NULL;\nstatic ENGINE_HANDLE_V1 *handle_v1 = NULL;\n\nstatic void usage(void) {\n    printf(\"\\n\");\n    printf(\"engine_testapp -E <path_to_engine_lib> -T <path_to_testlib>\\n\");\n    printf(\"               [-e <engine_config>] [-h]\\n\");\n    printf(\"\\n\");\n    printf(\"-E <path_to_engine_lib>      Path to the engine library file. The\\n\");\n    printf(\"                             engine library file is a library file\\n\");\n    printf(\"                             (.so or .dll) that the contains the \\n\");\n    printf(\"                             implementation of the engine being\\n\");\n    printf(\"                             tested.\\n\");\n    printf(\"\\n\");\n    printf(\"-T <path_to_testlib>         Path to the test library file. The test\\n\");\n    printf(\"                             library file is a library file (.so or\\n\");\n    printf(\"                             .dll) that contains the set of tests\\n\");\n    printf(\"                             to be executed.\\n\");\n    printf(\"\\n\");\n    printf(\"-t <timeout>                 Maximum time to run a test.\\n\");\n    printf(\"-e <engine_config>           Engine configuration string passed to\\n\");\n    printf(\"                             the engine.\\n\");\n    printf(\"-q                           Only print errors.\");\n    printf(\"-.                           Print a . for each executed test.\");\n    printf(\"\\n\");\n    printf(\"-h                           Prints this usage text.\\n\");\n    printf(\"\\n\");\n}\n\nstatic int report_test(const char *name, enum test_result r, bool quiet) {\n    int rc = 0;\n    char *msg = NULL;\n    bool color_enabled = getenv(\"TESTAPP_ENABLE_COLOR\") != NULL;\n    int color = 0;\n    char color_str[8] = { 0 };\n    char *reset_color = \"\\033[m\";\n    switch(r) {\n    case SUCCESS:\n        msg=\"OK\";\n        color = 32;\n        break;\n    case SKIPPED:\n        msg=\"SKIPPED\";\n        color = 32;\n        break;\n    case FAIL:\n        color = 31;\n        msg=\"FAIL\";\n        rc = 1;\n        break;\n    case DIED:\n        color = 31;\n        msg = \"DIED\";\n        rc = 1;\n        break;\n    case TIMEOUT:\n        color = 31;\n        msg = \"TIMED OUT\";\n        rc = 1;\n        break;\n    case CORE:\n        color = 31;\n        msg = \"CORE DUMPED\";\n        rc = 1;\n        break;\n    case PENDING:\n        color = 33;\n        msg = \"PENDING\";\n        break;\n    }\n    assert(msg);\n    if (color_enabled) {\n        snprintf(color_str, sizeof(color_str), \"\\033[%dm\", color);\n    }\n    if (quiet) {\n        if (r != SUCCESS) {\n            printf(\"%s:  %s%s%s\\n\", name, color_str, msg,\n                   color_enabled ? reset_color : \"\");\n            fflush(stdout);\n        }\n    } else {\n        printf(\"%s%s%s\\n\", color_str, msg, color_enabled ? reset_color : \"\");\n    }\n    return rc;\n}\n\nstatic ENGINE_HANDLE_V1 *start_your_engines(const char *engine, const char* cfg, bool engine_init) {\n\n    init_mock_server(handle);\n    if (!load_engine(engine, &get_mock_server_api, logger_descriptor, &handle)) {\n        fprintf(stderr, \"Failed to load engine %s.\\n\", engine);\n        return NULL;\n    }\n\n    if (engine_init) {\n        if(!init_engine(handle, cfg, logger_descriptor)) {\n            fprintf(stderr, \"Failed to init engine %s with config %s.\\n\", engine, cfg);\n            return NULL;\n        }\n    }\n\n    mock_engine = default_mock_engine;\n    handle_v1 = mock_engine.the_engine = (ENGINE_HANDLE_V1*)handle;\n    handle = (ENGINE_HANDLE*)&mock_engine.me;\n    handle_v1 = &mock_engine.me;\n\n    // Reset all members that aren't set (to allow the users to write\n    // testcases to verify that they initialize them..\n    assert(mock_engine.me.interface.interface == mock_engine.the_engine->interface.interface);\n\n    if (mock_engine.the_engine->get_stats_struct == NULL) {\n        mock_engine.me.get_stats_struct = NULL;\n    }\n    if (mock_engine.the_engine->aggregate_stats == NULL) {\n        mock_engine.me.aggregate_stats = NULL;\n    }\n    if (mock_engine.the_engine->unknown_command == NULL) {\n        mock_engine.me.unknown_command = NULL;\n    }\n    if (mock_engine.the_engine->tap_notify == NULL) {\n        mock_engine.me.tap_notify = NULL;\n    }\n    if (mock_engine.the_engine->get_tap_iterator == NULL) {\n        mock_engine.me.get_tap_iterator = NULL;\n    }\n    if (mock_engine.the_engine->errinfo == NULL) {\n        mock_engine.me.errinfo = NULL;\n    }\n\n    return &mock_engine.me;\n}\n\nstatic void destroy_engine(bool force) {\n    if (handle_v1) {\n        handle_v1->destroy(handle, force);\n        handle_v1 = NULL;\n        handle = NULL;\n    }\n}\n\nstatic void reload_engine(ENGINE_HANDLE **h, ENGINE_HANDLE_V1 **h1,\n                          const char* engine, const char *cfg, bool init, bool force) {\n    destroy_engine(force);\n    handle_v1 = start_your_engines(engine, cfg, init);\n    handle = (ENGINE_HANDLE*)(handle_v1);\n    *h1 = handle_v1;\n    *h = handle;\n}\n\nstatic enum test_result run_test(engine_test_t test, const char *engine, const char *default_cfg) {\n    enum test_result ret = PENDING;\n    if (test.tfun != NULL) {\n#if !defined(USE_GCOV) && !defined(WIN32)\n        pid_t pid = fork();\n        if (pid == 0) {\n#endif\n            /* Start the engines and go */\n            start_your_engines(engine, test.cfg ? test.cfg : default_cfg, true);\n            if (test.test_setup != NULL) {\n                if (!test.test_setup(handle, handle_v1)) {\n                    fprintf(stderr, \"Failed to run setup for test %s\\n\", test.name);\n                    return FAIL;\n                }\n            }\n            ret = test.tfun(handle, handle_v1);\n            if (test.test_teardown != NULL) {\n                if (!test.test_teardown(handle, handle_v1)) {\n                    fprintf(stderr, \"WARNING: Failed to run teardown for test %s\\n\", test.name);\n                }\n            }\n            destroy_engine(false);\n#if !defined(USE_GCOV) && !defined(WIN32)\n            exit((int)ret);\n        } else if (pid == (pid_t)-1) {\n            ret = FAIL;\n        } else {\n            int rc;\n            while (alarmed == 0 && waitpid(pid, &rc, 0) == (pid_t)-1) {\n                if (errno != EINTR) {\n                    abort();\n                }\n            }\n\n            if (alarmed) {\n                kill(pid, 9);\n                ret = TIMEOUT;\n            } else if (WIFEXITED(rc)) {\n                ret = (enum test_result)WEXITSTATUS(rc);\n            } else if (WIFSIGNALED(rc) && WCOREDUMP(rc)) {\n                ret = CORE;\n            } else {\n                ret = DIED;\n            }\n        }\n#endif\n    }\n\n    return ret;\n}\n\nstatic void setup_alarm_handler() {\n#ifndef WIN32\n    struct sigaction sig_handler;\n\n    sig_handler.sa_handler = alarm_handler;\n    sig_handler.sa_flags = 0;\n\n    sigaction(SIGALRM, &sig_handler, NULL);\n#endif\n}\n\nstatic void set_test_timeout(int timeout) {\n#ifndef WIN32\n    alarm(timeout);\n#endif\n}\n\nstatic void clear_test_timeout() {\n#ifndef WIN32\n    alarm(0);\n    alarmed = 0;\n#endif\n}\n\nint main(int argc, char **argv) {\n    int c, exitcode = 0, num_cases = 0, timeout = 0;\n    bool quiet = false;\n    bool dot = false;\n    const char *engine = NULL;\n    const char *engine_args = NULL;\n    const char *test_suite = NULL;\n    const char *test_case = NULL;\n    engine_test_t *testcases = NULL;\n    logger_descriptor = get_null_logger();\n\n    /* Hack to remove the warning from C99 */\n    union {\n        GET_TESTS get_tests;\n        void* voidptr;\n    } my_get_test = {.get_tests = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        SETUP_SUITE setup_suite;\n        void* voidptr;\n    } my_setup_suite = {.setup_suite = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        TEARDOWN_SUITE teardown_suite;\n        void* voidptr;\n    } my_teardown_suite = {.teardown_suite = NULL };\n\n\n    /* Use unbuffered stdio */\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n\n    setup_alarm_handler();\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"h\"  /* usage */\n          \"E:\" /* Engine to load */\n          \"e:\" /* Engine options */\n          \"T:\" /* Library with tests to load */\n          \"t:\" /* Timeout */\n          \"q\"  /* Be more quiet (only report failures) */\n          \".\"  /* dot mode. */\n          \"n:\"  /* test case to run */\n        ))) {\n        switch (c) {\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_args = optarg;\n            break;\n        case 'h':\n            usage();\n            return 0;\n        case 'T':\n            test_suite = optarg;\n            break;\n        case 't':\n            timeout = atoi(optarg);\n            break;\n        case 'n':\n            test_case = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case '.':\n            dot = true;\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    //validate args\n    if (engine == NULL) {\n        fprintf(stderr, \"You must provide a path to the storage engine library.\\n\");\n        return 1;\n    }\n\n    if (test_suite == NULL) {\n        fprintf(stderr, \"You must provide a path to the testsuite library.\\n\");\n        return 1;\n    }\n\n    //load test_suite\n    void* handle = dlopen(test_suite, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Failed to load testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n\n    //get the test cases\n    void *symbol = dlsym(handle, \"get_tests\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Could not find get_tests function in testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n    my_get_test.voidptr = symbol;\n    testcases = (*my_get_test.get_tests)();\n\n    //set up the suite if needed\n    struct test_harness harness = { .default_engine_cfg = engine_args,\n                                    .engine_path = engine,\n                                    .reload_engine = reload_engine,\n                                    .start_engine = start_your_engines,\n                                    .create_cookie = create_mock_cookie,\n                                    .destroy_cookie = destroy_mock_cookie,\n                                    .set_ewouldblock_handling = mock_set_ewouldblock_handling,\n                                    .lock_cookie = lock_mock_cookie,\n                                    .unlock_cookie = unlock_mock_cookie,\n                                    .waitfor_cookie = waitfor_mock_cookie,\n                                    .time_travel = mock_time_travel };\n    symbol = dlsym(handle, \"setup_suite\");\n    if (symbol != NULL) {\n        my_setup_suite.voidptr = symbol;\n        if (!(*my_setup_suite.setup_suite)(&harness)) {\n            fprintf(stderr, \"Failed to set up test suite %s \\n\", test_suite);\n            return 1;\n        }\n    }\n\n\n    for (num_cases = 0; testcases[num_cases].name; num_cases++) {\n        /* Just counting */\n    }\n\n    if (!quiet) {\n        printf(\"1..%d\\n\", num_cases);\n    }\n\n    int i;\n    bool need_newline = false;\n    for (i = 0; testcases[i].name; i++) {\n        if (test_case != NULL && strcmp(test_case, testcases[i].name) != 0)\n            continue;\n        if (!quiet) {\n            printf(\"Running %s... \", testcases[i].name);\n            fflush(stdout);\n        } else if(dot) {\n            printf(\".\");\n            need_newline = true;\n            /* Add a newline every few tests */\n            if ((i+1) % 70 == 0) {\n                printf(\"\\n\");\n                need_newline = false;\n            }\n        }\n        set_test_timeout(timeout);\n        exitcode += report_test(testcases[i].name,\n                                run_test(testcases[i], engine, engine_args),\n                                quiet);\n        clear_test_timeout();\n    }\n\n    if (need_newline) {\n        printf(\"\\n\");\n    }\n\n    //tear down the suite if needed\n    symbol = dlsym(handle, \"teardown_suite\");\n    if (symbol != NULL) {\n        my_teardown_suite.voidptr = symbol;\n        if (!(*my_teardown_suite.teardown_suite)()) {\n            fprintf(stderr, \"Failed to teardown up test suite %s \\n\", test_suite);\n        }\n    }\n\n    printf(\"# Passed %d of %d tests\\n\", num_cases - exitcode, num_cases);\n\n    return exitcode;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/plugin/innodb_memcached/daemon_memcached/win32/dlfcn.h": "#ifndef DLFCN_H\n#define DLFCN_H\nvoid* dlopen(const char* path, int mode);\nvoid* dlsym(void* handle, const char* symbol);\nint dlclose(void* handle);\nconst char *dlerror(void);\n\n#define RTLD_LAZY 1\n#define RTLD_LOCAL 2\n\n#define RTLD_NOW 0x00002\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/plugin/innodb_memcached/daemon_memcached/win32/dlfcn.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include <stdio.h>\n#include <windows.h>\n#include <dlfcn.h>\n#include <stdbool.h>\n\n/*\n * Keep track if the user tried to call dlopen(NULL, xx) to be able to give a sane\n * error message\n */\nstatic bool self = false;\n\nvoid* dlopen(const char* path, int mode) {\n    if (path == NULL) {\n        // We don't support opening ourself\n        self = true;\n        return NULL;\n    }\n\n    void* handle = LoadLibrary(path);\n    if (handle == NULL) {\n        char *buf = malloc(strlen(path) + 20);\n        sprintf(buf, \"%s.dll\", path);\n        handle = LoadLibrary(buf);\n        free(buf);\n    }\n\n    return handle;\n}\n\nvoid* dlsym(void* handle, const char* symbol) {\n    return GetProcAddress(handle, symbol);\n}\n\nint dlclose(void* handle) {\n    // dlclose returns zero on success.\n    // FreeLibrary returns nonzero on success.\n    return FreeLibrary(handle) != 0;\n}\n\nstatic char dlerror_buf[200];\n\nconst char *dlerror(void) {\n    if (self) {\n        return \"not supported\";\n    }\n\n    DWORD err = GetLastError();\n    LPVOID error_msg;\n    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                      FORMAT_MESSAGE_FROM_SYSTEM |\n                      FORMAT_MESSAGE_IGNORE_INSERTS,\n                      NULL, err, 0, (LPTSTR)&error_msg, 0, NULL) != 0) {\n        strncpy(dlerror_buf, error_msg, sizeof(dlerror_buf));\n        dlerror_buf[sizeof(dlerror_buf) - 1] = '\\0';\n        LocalFree(error_msg);\n    } else {\n        return \"Failed to get error message\";\n    }\n\n    return dlerror_buf;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/sql-common/client_plugin.c": "/* Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n  \n  Support code for the client side (libmysql) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n#include <my_global.h>\n#include \"mysql.h\"\n#include <my_sys.h>\n#include <m_string.h>\n#include <my_thread.h>\n\n#include <sql_common.h>\n#include \"errmsg.h\"\n#include <mysql/client_plugin.h>\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#if defined(CLIENT_PROTOCOL_TRACING)\n#include <mysql/plugin_trace.h>\n#endif\n\nPSI_memory_key key_memory_root;\nPSI_memory_key key_memory_load_env_plugins;\n\n#ifdef HAVE_PSI_INTERFACE\nPSI_mutex_key key_mutex_LOCK_load_client_plugin;\n\nstatic PSI_mutex_info all_client_plugin_mutexes[]=\n{\n  {&key_mutex_LOCK_load_client_plugin, \"LOCK_load_client_plugin\", PSI_FLAG_GLOBAL}\n};\n\nstatic PSI_memory_info all_client_plugin_memory[]=\n{\n  {&key_memory_root, \"root\", PSI_FLAG_GLOBAL},\n  {&key_memory_load_env_plugins, \"load_env_plugins\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_client_plugin_psi_keys()\n{\n  const char* category= \"sql\";\n  int count;\n\n  count= array_elements(all_client_plugin_mutexes);\n  mysql_mutex_register(category, all_client_plugin_mutexes, count);\n\n  count= array_elements(all_client_plugin_memory);\n  mysql_memory_register(category, all_client_plugin_memory, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void   *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic my_bool initialized= 0;\nstatic MEM_ROOT mem_root;\n\nstatic const char *plugin_declarations_sym= \"_mysql_client_plugin_declaration_\";\nstatic uint plugin_version[MYSQL_CLIENT_MAX_PLUGINS]=\n{\n  0, /* these two are taken by Connector/C */\n  0, /* these two are taken by Connector/C */\n  MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION,\n  MYSQL_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION,\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS];\nstatic mysql_mutex_t LOCK_load_client_plugin;\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name)\n{\n  if (initialized)\n    return 0;\n\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                           unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                           name, \"not initialized\");\n  return 1;\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n  \n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\nfind_plugin(const char *name, int type)\n{\n  struct st_client_plugin_int *p;\n\n  DBUG_ASSERT(initialized);\n  DBUG_ASSERT(type >= 0 && type < MYSQL_CLIENT_MAX_PLUGINS);\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n    return 0;\n\n  for (p= plugin_list[type]; p; p= p->next)\n  {\n    if (strcmp(p->plugin->name, name) == 0)\n      return p->plugin;\n  }\n  return NULL;\n}\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\ndo_add_plugin(MYSQL *mysql, struct st_mysql_client_plugin *plugin,\n              void *dlhandle,\n              int argc, va_list args)\n{\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin= plugin;\n  plugin_int.dlhandle= dlhandle;\n\n  if (plugin->type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    errmsg= \"Unknown client plugin type\";\n    goto err1;\n  }\n\n  if (plugin->interface_version < plugin_version[plugin->type] ||\n      (plugin->interface_version >> 8) >\n       (plugin_version[plugin->type] >> 8))\n  {\n    errmsg= \"Incompatible client plugin interface\";\n    goto err1;\n  }\n\n#if defined(CLIENT_PROTOCOL_TRACING) && !defined(MYSQL_SERVER)\n  /*\n    If we try to load a protocol trace plugin but one is already\n    loaded (global trace_plugin pointer is not NULL) then we ignore\n    the new trace plugin and give error. This is done before the\n    new plugin gets initialized.\n  */\n  if (plugin->type == MYSQL_CLIENT_TRACE_PLUGIN && NULL != trace_plugin)\n  {\n    errmsg= \"Can not load another trace plugin while one is already loaded\";\n    goto err1;\n  }\n#endif\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args))\n  {\n    errmsg= errbuf;\n    goto err1;\n  }\n\n  p= (struct st_client_plugin_int *)\n    memdup_root(&mem_root, &plugin_int, sizeof(plugin_int));\n\n  if (!p)\n  {\n    errmsg= \"Out of memory\";\n    goto err2;\n  }\n\n  mysql_mutex_assert_owner(&LOCK_load_client_plugin);\n\n  p->next= plugin_list[plugin->type];\n  plugin_list[plugin->type]= p;\n  net_clear_error(&mysql->net);\n\n#if defined(CLIENT_PROTOCOL_TRACING) && !defined(MYSQL_SERVER)\n  /*\n    If loaded plugin is a protocol trace one, then set the global\n    trace_plugin pointer to point at it. When trace_plugin is not NULL,\n    each new connection will be traced using the plugin pointed by it\n    (see MYSQL_TRACE_STAGE() macro in libmysql/mysql_trace.h).\n  */\n  if (plugin->type == MYSQL_CLIENT_TRACE_PLUGIN)\n  {\n    trace_plugin = (struct st_mysql_client_plugin_TRACE*)plugin;\n  }\n#endif\n\n  return plugin;\n\nerr2:\n  if (plugin->deinit)\n    plugin->deinit();\nerr1:\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name,\n                           errmsg);\n  if (dlhandle)\n    dlclose(dlhandle);\n  return NULL;\n}\n\n\nstatic struct st_mysql_client_plugin *\nadd_plugin_noargs(MYSQL *mysql, struct st_mysql_client_plugin *plugin,\n                  void *dlhandle,\n                  int argc, ...)\n{\n  struct st_mysql_client_plugin *retval= NULL;\n  va_list ap;\n  va_start(ap, argc);\n  retval= do_add_plugin(mysql, plugin, dlhandle, argc, ap);\n  va_end(ap);\n  return retval;\n}\n\n\nstatic struct st_mysql_client_plugin *\nadd_plugin_withargs(MYSQL *mysql, struct st_mysql_client_plugin *plugin,\n                    void *dlhandle,\n                    int argc, va_list args)\n{\n  return do_add_plugin(mysql, plugin, dlhandle, argc, args);\n}\n\n\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n  \n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\nstatic void load_env_plugins(MYSQL *mysql)\n{\n  char *plugs, *free_env, *s= getenv(\"LIBMYSQL_PLUGINS\");\n  char *enable_cleartext_plugin= getenv(\"LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN\");\n\n  if (enable_cleartext_plugin && strchr(\"1Yy\", enable_cleartext_plugin[0]))\n    libmysql_cleartext_plugin_enabled= 1;\n\n  /* no plugins to load */\n  if(!s)\n    return;\n\n  free_env= plugs= my_strdup(key_memory_load_env_plugins,\n                             s, MYF(MY_WME));\n\n  do {\n    if ((s= strchr(plugs, ';')))\n      *s= '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs= s + 1;\n  } while (s);\n\n  my_free(free_env);\n\n}\n\n\n/********** extern functions to be used by libmysql *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occured\n*/\nint mysql_client_plugin_init()\n{\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n\n  if (initialized)\n    return 0;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_client_plugin_psi_keys();\n#endif /* HAVE_PSI_INTERFACE */\n\n  memset(&mysql, 0, sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n\n  mysql_mutex_init(key_mutex_LOCK_load_client_plugin,\n                   &LOCK_load_client_plugin, MY_MUTEX_INIT_SLOW);\n  init_alloc_root(key_memory_root, &mem_root, 128, 128);\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n\n  initialized= 1;\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    add_plugin_noargs(&mysql, *builtin, 0, 0);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  mysql_close_free(&mysql);\n\n  return 0;\n}\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\nvoid mysql_client_plugin_deinit()\n{\n  int i;\n  struct st_client_plugin_int *p;\n\n  if (!initialized)\n    return;\n\n  for (i=0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p= plugin_list[i]; p; p= p->next)\n    {\n      if (p->plugin->deinit)\n        p->plugin->deinit();\n      if (p->dlhandle)\n        dlclose(p->dlhandle);\n    }\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n  initialized= 0;\n  free_root(&mem_root, MYF(0));\n  mysql_mutex_destroy(&LOCK_load_client_plugin);\n}\n\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_register_plugin(MYSQL *mysql,\n                             struct st_mysql_client_plugin *plugin)\n{\n  if (is_not_initialized(mysql, plugin->name))\n    return NULL;\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type))\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                             unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                             plugin->name, \"it is already loaded\");\n    plugin= NULL;\n  }\n  else\n    plugin= add_plugin_noargs(mysql, plugin, 0, 0);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  return plugin;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin_v(MYSQL *mysql, const char *name, int type,\n                    int argc, va_list args)\n{\n  const char *errmsg;\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n  const char *plugindir;\n#ifdef _WIN32\n  char win_errormsg[2048];\n#endif\n\n  DBUG_ENTER (\"mysql_load_plugin_v\");\n  DBUG_PRINT (\"entry\", (\"name=%s type=%d int argc=%d\", name, type, argc));\n  if (is_not_initialized(mysql, name))\n  {\n    DBUG_PRINT (\"leave\", (\"mysql not initialized\"));\n    DBUG_RETURN (NULL);\n  }\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  if (mysql->options.extension && mysql->options.extension->plugin_dir)\n  {\n    plugindir= mysql->options.extension->plugin_dir;\n  }\n  else\n  {\n    plugindir= getenv(\"LIBMYSQL_PLUGIN_DIR\");\n    if (!plugindir)\n    {\n      plugindir= PLUGINDIR;\n    }\n  }\n\n  /* Compile dll path */\n  strxnmov(dlpath, sizeof(dlpath) - 1,\n           plugindir, \"/\",\n           name, SO_EXT, NullS);\n   \n  DBUG_PRINT (\"info\", (\"dlopeninig %s\", dlpath));\n  /* Open new dll handle */\n  if (!(dlhandle= dlopen(dlpath, RTLD_NOW)))\n  {\n#if defined(__APPLE__)\n    /* Apple supports plugins with .so also, so try this as well */\n    strxnmov(dlpath, sizeof(dlpath) - 1,\n             plugindir, \"/\",\n             name, \".so\", NullS);\n    if ((dlhandle= dlopen(dlpath, RTLD_NOW)))\n      goto have_plugin;\n#endif\n\n#ifdef _WIN32\n    /* There should be no win32 calls between failed dlopen() and GetLastError() */\n    if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                  0, GetLastError(), 0, win_errormsg, 2048, NULL))\n      errmsg= win_errormsg;\n    else\n      errmsg= \"\";\n#else\n    errmsg= dlerror();\n#endif\n    DBUG_PRINT (\"info\", (\"failed to dlopen\"));\n    goto err;\n  }\n\n#if defined(__APPLE__)\nhave_plugin:  \n#endif\n  if (!(sym= dlsym(dlhandle, plugin_declarations_sym)))\n  {\n    errmsg= \"not a plugin\";\n    dlclose(dlhandle);\n    goto err;\n  }\n\n  plugin= (struct st_mysql_client_plugin*)sym;\n\n  if (type >=0 && type != plugin->type)\n  {\n    errmsg= \"type mismatch\";\n    goto err;\n  }\n\n  if (strcmp(name, plugin->name))\n  {\n    errmsg= \"name mismatch\";\n    goto err;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  plugin= add_plugin_withargs(mysql, plugin, dlhandle, argc, args);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  DBUG_PRINT (\"leave\", (\"plugin loaded ok\"));\n  DBUG_RETURN (plugin);\n\nerr:\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  DBUG_PRINT (\"leave\", (\"plugin load error : %s\", errmsg));\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  DBUG_RETURN (NULL);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin(MYSQL *mysql, const char *name, int type, int argc, ...)\n{\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  va_start(args, argc);\n  p= mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  return p;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_find_plugin(MYSQL *mysql, const char *name, int type)\n{\n  struct st_mysql_client_plugin *p;\n\n  DBUG_ENTER (\"mysql_client_find_plugin\");\n  DBUG_PRINT (\"entry\", (\"name=%s, type=%d\", name, type));\n  if (is_not_initialized(mysql, name))\n    DBUG_RETURN (NULL);\n\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                             ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name,\n                             \"invalid type\");\n  }\n\n  if ((p= find_plugin(name, type)))\n  {\n    DBUG_PRINT (\"leave\", (\"found %p\", p));\n    DBUG_RETURN (p);\n  }\n\n  /* not found, load it */\n  p= mysql_load_plugin(mysql, name, type, 0);\n  DBUG_PRINT (\"leave\", (\"loaded %p\", p));\n  DBUG_RETURN (p);\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nint mysql_plugin_options(struct st_mysql_client_plugin *plugin,\n                                 const char *option,\n                                 const void *value)\n{\n  DBUG_ENTER(\"mysql_plugin_options\");\n  /* does the plugin support options call? */\n  if (!plugin || !plugin->options)\n    DBUG_RETURN(1);\n  DBUG_RETURN(plugin->options(option, value));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/valgrind.supp": "# Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Library General Public\n# License as published by the Free Software Foundation; version 2\n# of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Library General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n#\n# Suppress some common (not fatal) errors in system libraries found by valgrind\n#\n\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:allocate_stack\n   fun:pthread_create*\n}\n\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n\n}\n\n{\n   pthead_exit memory loss 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread_exit memory loss 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread allocate_dtv memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread allocate_dtv memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   pthread memalign memory loss\n   Memcheck:Leak\n   fun:memalign\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread pthread_key_create\n   Memcheck:Leak\n   fun:malloc\n   fun:*\n   fun:*\n   fun:pthread_key_create\n   fun:my_thread_global_init\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   strlen/_dl_init_paths/dl_main/_dl_sysdep_start(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:_dl_init_paths\n   fun:dl_main\n   fun:_dl_sysdep_start\n}\n\n{\n   pthread errno\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlsym\n   fun:__errno_location\n}\n\n\n#\n# Warnings in libz becasue it works with aligned memory(?)\n#\n\n{\n   libz tr_flush_block\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n   fun:gzclose\n}\n\n{\n   libz tr_flush_block2\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n}\n\n{\n   libz deflate\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz deflate2\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   obj:*/libz.so.*\n   fun:gzflush\n}\n\n{\n   libz deflate3\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:do_flush\n}\n\n{\n  libz deflate4\n  Memcheck:Param\n  write(buf)\n  fun:*\n  fun:my_write\n  fun:do_flush\n  fun:azclose\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n\n# Red Hat AS 4 32 bit\n{\n   dl_relocate_object\n   Memcheck:Cond\n   fun:_dl_relocate_object\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n#\n# Leaks reported in _dl_* internal functions on Linux amd64 / glibc2.3.2.\n#\n\n{\n   _dl_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_start\n}\n\n{\n   _dl_start invalid write4\n   Memcheck:Addr4\n   fun:_dl_start\n}\n\n{\n   _dl_start/_dl_setup_hash invalid read8\n   Memcheck:Addr8\n   fun:_dl_setup_hash\n   fun:_dl_start\n}\n\n{\n   _dl_sysdep_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_sysdep_start\n}\n\n{\n   _dl_init invalid write8\n   Memcheck:Addr8\n   fun:_dl_init\n}\n\n{\n   _dl_init invalid write4\n   Memcheck:Addr4\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_init invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_initialize\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_debug_state invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_state\n   fun:_dl_init\n}\n\n{\n   init invalid write8\n   Memcheck:Addr8\n   fun:init\n}\n\n{\n   fixup invalid write8\n   Memcheck:Addr8\n   fun:fixup\n}\n\n{\n   fixup/_dl_lookup_versioned_symbol invalid read8\n   Memcheck:Addr8\n   fun:_dl_lookup_versioned_symbol\n   fun:fixup\n}\n\n{\n   _dl_runtime_resolve invalid read8\n   Memcheck:Addr8\n   fun:_dl_runtime_resolve\n}\n\n{\n   __libc_start_main invalid write8\n   Memcheck:Addr8\n   fun:__libc_start_main\n}\n\n{\n   __libc_start_main/__sigjmp_save invalid write4\n   Memcheck:Addr4\n   fun:__sigjmp_save\n   fun:__libc_start_main\n}\n\n#\n# These seem to be libc threading stuff, not related to MySQL code (allocations\n# during pthread_exit()). Googling shows other projects also using these\n# suppressions.\n#\n# Note that these all stem from pthread_exit() deeper in the call stack, but\n# Valgrind only allows the top four calls in the suppressions.\n#\n\n{\n   libc pthread_exit 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 6\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:openaux\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 7\n   Memcheck:Leak\n   fun:malloc\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n}\n\n{\n   libc pthread_exit 8\n   Memcheck:Leak\n   fun:malloc\n   fun:local_strdup\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n#\n# This is seen internally in the system libraries on 64-bit RHAS3.\n#\n\n{\n   __lll_mutex_unlock_wake uninitialized\n   Memcheck:Param\n   futex(utime)\n   fun:__lll_mutex_unlock_wake\n}\n\n#\n# BUG#19940: NDB sends uninitialized parts of field buffers across the wire.\n# This is \"works as designed\"; the uninitialized part is not used at the\n# other end (but Valgrind cannot see this).\n#\n{\n   bug19940\n   Memcheck:Param\n   socketcall.sendto(msg)\n   fun:send\n   fun:_ZN15TCP_Transporter6doSendEv\n   fun:_ZN19TransporterRegistry11performSendEv\n   fun:_ZN19TransporterRegistry14forceSendCheckEi\n}\n# Warning when printing stack trace (to suppress some not needed warnings)\n#\n\n{\n   vprintf on stacktrace\n   Memcheck:Cond\n   fun:vfprintf\n   fun:uffered_vfprintf\n   fun:vfprintf\n   fun:fprintf\n   fun:print_stacktrace\n}\n\n#\n# Safe warnings, that may happen because of thread scheduling\n#\n\n{\n   dbug initialization by kill_server\n   Memcheck:Leak\n   fun:malloc\n   fun:DbugMalloc\n   fun:code_state\n   fun:_db_enter_\n   fun:kill_server\n}\n\n#\n# Warning caused by small memory leak in threaded dlopen\n#\n\n{\n   dlopen threaded memory leak\n   Memcheck:Leak\n   fun:calloc\n   obj:*/libdl-*.so\n   fun:dlopen*\n}\n\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss in 2.6.1.\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   buf_buddy_relocate peeking (space,page) in potentially free blocks\n   Memcheck:Addr1\n   fun:buf_buddy_relocate\n}\n\n#\n# Bug#56666 is fixed by WL#6407\n# Also, as part of WL#6407, call to shutdown_performance_schema()\n# is uncommented in sql/mysqld.cc. As this call was commented out\n# for long time, there are still some leaks which needs to be\n# addressed by pfs.\n{\n   missing shutdown_performance_schema 1b\n   Memcheck:Leak\n   fun:memalign\n   fun:posix_memalign\n   fun:_Z10pfs_mallocmi\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 2\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:my_malloc\n   fun:lf_alloc_new\n   fun:lf_hash_insert\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 2-mem\n   Memcheck:Leak\n   ...\n   fun:my_malloc\n   fun:lf_alloc_new\n   fun:lf_hash_insert\n}\n\n#\n# Note that initialize_bucket() is reccursive,\n# can't provide more stack context.\n#\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 3a\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:my_malloc\n   fun:initialize_bucket\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 3a-mem\n   Memcheck:Leak\n   ...\n   fun:my_malloc\n   fun:initialize_bucket\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 3b\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:initialize_bucket\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 3b-mem\n   Memcheck:Leak\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:initialize_bucket\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 4\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:lf_pinbox_get_pins\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 4-mem\n   Memcheck:Leak\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:lf_pinbox_get_pins\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 5\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:lf_hash_insert\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 5-mem\n   Memcheck:Leak\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:lf_hash_insert\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 6\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:lf_hash_delete\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 6-mem\n   Memcheck:Leak\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:lf_hash_delete\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 7\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:lf_hash_search\n}\n\n# The '...' wildcard is for 'fun:my_raw_malloc' which is hidden with HAVE_VALGRIND\n{\n   missing shutdown_performance_schema 7-mem\n   Memcheck:Leak\n   ...\n   fun:my_malloc\n   fun:lf_dynarray_lvalue\n   fun:lf_hash_search\n}\n\n{\n   Bug 59874 Valgrind warning in InnoDB compression code\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields_func\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress_deflate\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_zip_reorganize\n   fun:page_cur_insert_rec_zip_reorg\n   fun:page_cur_insert_rec_zip\n   fun:page_cur_tuple_insert\n   fun:btr_cur_optimistic_insert\n   fun:btr_cur_pessimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_zip_reorganize\n   fun:page_cur_insert_rec_zip_reorg\n   fun:page_cur_insert_rec_zip\n   fun:page_cur_tuple_insert\n   fun:btr_cur_optimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_copy_rec_list_end\n   fun:page_move_rec_list_end\n   fun:btr_page_split_and_insert\n   fun:btr_root_raise_and_insert\n   fun:btr_cur_pessimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_cur_insert_rec_zip_reorg\n   fun:page_cur_insert_rec_zip\n   fun:page_cur_tuple_insert\n   fun:btr_cur_optimistic_insert\n   fun:btr_cur_pessimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   Bug 59875 Valgrind warning in buf0buddy.c\n   Memcheck:Addr1\n   fun:mach_read_from_4\n   fun:buf_buddy_relocate\n   fun:buf_buddy_free_low\n   fun:buf_buddy_free\n}\n\n#\n# NDB packfrm vs deflate\n#\n{\n   NDB packfrm case 1\n   Memcheck:Cond\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n   fun:packfrm\n}\n\n{\n   NDB packfrm case 2\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n   fun:packfrm\n}\n\n#\n# pfs vs compress\n#\n{\n   pfs vs. compress case 1\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n}\n\n{\n   pfs vs. compress case 2\n   Memcheck:Cond\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n}\n\n# Note the wildcard in the (mangled) function signatures of\n# write_keys() and find_all_keys().\n# They both return ha_rows, which is platform dependent.\n#\n# The '...' wildcards are for 'fun:inline_mysql_file_write' which *may*\n# be inlined.\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / one\n   Memcheck:Param\n   write(buf)\n   ...\n   fun:my_b_flush_io_cache\n   fun:_my_b_write\n   fun:_Z*10write_keysP10Sort_paramP13Filesort_infojP11st_io_cacheS4_\n   ...\n   fun:_Z8filesortP3THDP8FilesortbPyS3_S3_\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / three\n   Memcheck:Param\n   write(buf)\n   ...\n   fun:my_b_flush_io_cache\n   fun:_Z8filesortP3THDP8FilesortbPyS3_S3_\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   ...\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:engine_cleanup_add_last\n   fun:ENGINE_add\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:engine_cleanup_add_last\n   fun:ENGINE_add\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ENGINE_new\n}\n\n{\n   Bug#16039908 \"BYTES STILL REACHABLE\" IN VALGRIND TEST ON 5.6/TRUNK\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlclose\n   fun:_ZL15free_plugin_memP12st_plugin_dl\n   fun:_ZL13plugin_dl_delPK19st_mysql_lex_string\n   fun:_ZL10plugin_delP13st_plugin_int\n   fun:_ZL12reap_pluginsv\n   fun:_Z15plugin_shutdownv\n   fun:_Z*8clean_upb*\n}\n\n{\n   main.udf gives similar warning as Bug#16039908\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlclose\n   fun:_Z8udf_freev\n   fun:_Z*8clean_upb*\n}\n\n#Suppress warnings from glibc implementation of 'malloc_info' \n{\n   Malloc_info uninitialised value of size 8\n   Memcheck:Value8\n   fun:_itoa_word\n   fun:vfprintf\n   fun:fprintf\n   fun:mi_arena.*\n   fun:malloc_info\n}\n\n{\n   Malloc_info conditional jump depends on uninitialised values\n   Memcheck:Cond\n   ...\n   fun:mi_arena.*\n   fun:malloc_info\n}\n\n\n#supress warnings from openssl random generator\n\n{\n   OpenSSL conditional jump in ssl3_ctx_ctrl\n   Memcheck:Cond\n   ...\n   fun:ssl3_ctx_ctrl\n   fun:new_VioSSLFd\n}\n\n{\n   OpenSSL uninitialised value of size 8 in new_VioSSLFd\n   Memcheck:Value8\n   fun:BN_num_bits_word\n   fun:BN_num_bits\n   ...\n   fun:new_VioSSLFd\n}\n\n{\n   OpenSSL uninitialised value of size 8 in new_VioSSLFd\n   Memcheck:Value8\n   fun:BN_mod_exp_mont_consttime\n   ...\n   fun:new_VioSSLFd\n}\n\n{\n   OpenSSL PB2 / 1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_Z8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   OpenSSL PB2 / 2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_ZL8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n\n{\n   OpenSSL libstdc++ version 5 / one\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/lib/x86_64-linux-gnu/libssl.so.1.0.0\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_ZL8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   OpenSSL libstdc++ version 5 / two\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/lib/x86_64-linux-gnu/libssl.so.1.0.0\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_ZL8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   OpenSSL libstdc++ version 5 / three\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   obj:/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21\n   fun:call_init.part.0\n   fun:call_init\n   fun:_dl_init\n}\n\n# supress uninitialized because some SSL libraries do random like that\n{\n   OpenSSL conditional jump in generate_user_salt due to randomness\n   Memcheck:Cond\n   fun:generate_user_salt\n   fun:native_password_authenticate\n}\n\n{\n   General protobuf globals\n   Memcheck:Leak\n   fun:_Znwm\n   ...\n   fun:_GLOBAL__sub_I_mysqlx*.pb.cc\n   ...\n}\n\n\n{\n   mysqlx plugin install\n   Memcheck:Leak\n   fun:*alloc\n   ...\n   fun:_dl_catch_error\n   ...\n   fun:dlopen*\n   ...\n   fun:_ZL13plugin_dl_addPK19st_mysql_lex_stringi*\n   ...\n}\n\n# supress inability to cleanup OpenSSL error contexts in GR\n{\n   OpenSSL GR suppress leak 1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_clear_error\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   fun:_ZN14Trans_delegate13before_commitEP3THDbP11st_io_cacheS3_y\n   fun:_ZN13MYSQL_BIN_LOG6commitEP3THDb\n   fun:_Z17trans_commit_stmtP3THD\n}\n\n{\n   OpenSSL GR suppress leak 2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_clear_error\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   fun:_ZN14Trans_delegate13before_commitEP3THDbP11st_io_cacheS3_y\n   fun:_ZN13MYSQL_BIN_LOG6commitEP3THDb\n   fun:_Z15ha_commit_transP3THDbb\n}\n\n{\n   OpenSSL GR suppress leak 3\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:lh_insert\n   fun:int_thread_set_item\n   fun:ERR_get_state\n   fun:ERR_clear_error\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   fun:_ZN14Trans_delegate13before_commitEP3THDbP11st_io_cacheS3_y\n}\n\n{\n   OpenSSL GR suppress leak 4\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:lh_new\n   fun:int_thread_get\n   fun:int_thread_set_item\n   fun:ERR_get_state\n   fun:ERR_put_error\n   fun:PEM_read_bio\n   fun:PEM_X509_INFO_read_bio\n   fun:X509_load_cert_crl_file\n   fun:by_file_ctrl\n   fun:X509_STORE_load_locations\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  fun:vio_ssl_read\n  ...\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  ...\n  fun:sslaccept\n  ...\n  fun:server_mpvio_read_packet\n  ...\n}\n\n#\n# Rules to suppress leaks from plugin dependencies\n#\n\n{\n  TPL leak 1\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:BUF_strndup\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 2\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:BUF_strndup\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 3\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 4\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:sk_new\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 5\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:sk_new\n  fun:SSL_COMP_get_compression_methods\n  fun:SSL_library_init\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 6\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 7\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 8\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:lh_new\n  fun:int_thread_get\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 9\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 10\n  Memcheck:Leak\n  match-leak-kinds: definite\n  fun:malloc\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{ \n  TPL leak 11\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:ERR_get_state\n  fun:ERR_put_error\n  fun:PEM_read_bio\n  fun:PEM_X509_INFO_read_bio\n  fun:X509_load_cert_crl_file\n  fun:by_file_ctrl\n  fun:X509_STORE_load_locations\n  obj:*\n  obj:* \n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n}\n\n{\n  TPL leak 12\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:BUF_strndup\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 13\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 14\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:sk_new\n  fun:SSL_COMP_get_compression_methods\n  fun:SSL_library_init\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 15\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_put_error\n  fun:PEM_read_bio\n  fun:PEM_X509_INFO_read_bio\n  fun:X509_load_cert_crl_file\n  fun:by_file_ctrl\n  fun:X509_STORE_load_locations\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 16\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:realloc\n  fun:CRYPTO_realloc\n  fun:sk_insert\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 17\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 18\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 19\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 20\n  Memcheck:Leak\n  match-leak-kinds: definite\n  fun:malloc\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 21\n  Memcheck:Leak\n  match-leak-kinds: possible\n  fun:malloc\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/sp-error.test": "#\n# Stored PROCEDURE error tests\n#\n\n--disable_warnings ONCE\ndrop table if exists t1, t2;\n\n# Backup the mysql.proc table\n--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR\neval SELECT * FROM mysql.proc INTO OUTFILE '$MYSQLTEST_VARDIR/tmp/proc.txt';\n\n# Make sure we don't have any procedures left.\ndelete from mysql.proc;\n\ndelimiter |;\n\n# This should give three syntax errors (sometimes crashed; bug #643)\n# (Unfortunately, this is not a 100% test, on some platforms this\n#  passed despite the bug.)\n--error 1064\ncreate procedure syntaxerror(t int)|\n--error 1064\ncreate procedure syntaxerror(t int)|\n--error 1064\ncreate procedure syntaxerror(t int)|\n\n# Check that we get the right error, i.e. UDF declaration parses correctly,\n# but foo.so doesn't exist.\n#    This generates an error message containing a misleading errno which\n#    might vary between systems (it usually doesn't have anything to do with\n#    the actual failing dlopen()).\n#--error 1126\n#create function foo returns real soname \"foo.so\"|\n\n\n--disable_warnings ONCE\ndrop table if exists t3|\ncreate table t3 ( x int )|\ninsert into t3 values (2), (3)|\n\ncreate procedure bad_into(out param int)\n  select x from t3 into param|\n\n--error 1172\ncall bad_into(@x)|\n\ndrop procedure bad_into|\ndrop table t3|\n\n\ncreate procedure proc1()\n  set @x = 42|\n\ncreate function func1() returns int\n  return 42|\n\n# Can't create recursively\n--error 1303\ncreate procedure foo()\n  create procedure bar() set @x=3|\n--error 1303\ncreate procedure foo()\n  create function bar() returns double return 2.3|\n\n# Already exists\n--error 1304\ncreate procedure proc1()\n  set @x = 42|\n--error 1304\ncreate function func1() returns int\n  return 42|\n\ndrop procedure proc1|\ndrop function func1|\n\n# Does not exist\n--error 1305\nalter procedure foo|\n--error 1305\nalter function foo|\n--error 1305\ndrop procedure foo|\n--error 1305\ndrop function foo|\n--error 1305\ncall foo()|\ndrop procedure if exists foo|\n--error 1305\nshow create procedure foo|\n--error 1305\nshow create function foo|\n\n# LEAVE/ITERATE with no match\n--error 1308\ncreate procedure foo()\nfoo: loop\n  leave bar;\nend loop|\n--error 1308\ncreate procedure foo()\nfoo: loop\n  iterate bar;\nend loop|\n--error 1308\ncreate procedure foo()\nfoo: begin\n  iterate foo;\nend|\n\n# Redefining label\n--error 1309\ncreate procedure foo()\nfoo: loop\n  foo: loop\n    set @x=2;\n  end loop foo;\nend loop foo|\n\n# End label mismatch\n--error 1310\ncreate procedure foo()\nfoo: loop\n  set @x=2;\nend loop bar|\n\n# RETURN in FUNCTION only\n--error 1313\ncreate procedure foo()\n  return 42|\n\n# Wrong number of arguments\ncreate procedure p(x int)\n  set @x = x|\ncreate function f(x int) returns int\n  return x+42|\n\n--error 1318\ncall p()|\n--error 1318\ncall p(1, 2)|\n--error 1318\nselect f()|\n--error 1318\nselect f(1, 2)|\n\ndrop procedure p|\ndrop function f|\n\n--error 1319 \ncreate procedure p(val int, out res int)\nbegin\n  declare x int default 0;\n  declare continue handler for foo set x = 1;\n\n  insert into test.t1 values (val);\n  if (x) then\n    set res = 0;\n  else\n    set res = 1;\n  end if;\nend|\n\n--error 1319 \ncreate procedure p(val int, out res int)\nbegin\n  declare x int default 0;\n  declare foo condition for 1146;\n  declare continue handler for bar set x = 1;\n\n  insert into test.t1 values (val);\n  if (x) then\n    set res = 0;\n  else\n    set res = 1;\n  end if;\nend|\n\n--error 1320\ncreate function f(val int) returns int\nbegin\n  declare x int;\n\n  set x = val+3;\nend|\n\ncreate function f(val int) returns int\nbegin\n  declare x int;\n\n  set x = val+3;\n  if x < 4 then\n    return x;\n  end if;\nend|\n\n--error 1321\nselect f(10)|\n\ndrop function f|\n\n--error ER_PARSE_ERROR\ncreate procedure p()\nbegin\n  declare c cursor for insert into test.t1 values (\"foo\", 42);\n\n  open c;\n  close c;\nend|\n\n--error 1323\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * into x from test.t limit 1;\n\n  open c;\n  close c;\nend|\n\n--error 1324\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t;\n\n  open cc;\n  close c;\nend|\n\n--disable_warnings ONCE\ndrop table if exists t1|\ncreate table t1 (val int)|\n\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t1;\n\n  open c;\n  open c;\n  close c;\nend|\n--error 1325\ncall p()|\ndrop procedure p|\n\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t1;\n\n  open c;\n  close c;\n  close c;\nend|\n--error 1326\ncall p()|\ndrop procedure p|\n\n--error 1305\nalter procedure bar3 sql security invoker|\n\ndrop table t1|\n\n--disable_warnings ONCE\ndrop table if exists t1|\ncreate table t1 (val int, x float)|\ninsert into t1 values (42, 3.1), (19, 1.2)|\n\n--error 1327\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x, y;\n  close c;\nend|\n\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x;\n  close c;\nend|\n--error 1328\ncall p()|\ndrop procedure p|\n\ncreate procedure p()\nbegin\n  declare x int;\n  declare y float;\n  declare z int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x, y, z;\n  close c;\nend|\n--error 1328\ncall p()|\ndrop procedure p|\n\n--error 1330\ncreate procedure p(in x int, x char(10))\nbegin\nend|\n--error 1330\ncreate function p(x int, x char(10))\nbegin\nend|\n\n--error 1331\ncreate procedure p()\nbegin\n  declare x float;\n  declare x int;\nend|\n\n--error 1332\ncreate procedure p()\nbegin\n  declare c condition for 1064;\n  declare c condition for 1065;\nend|\n\n--error 1333\ncreate procedure p()\nbegin\n  declare c cursor for select * from t1;\n  declare c cursor for select field from t1;\nend|\n\n# USE is not allowed\n--error ER_SP_BADSTATEMENT \ncreate procedure u()\n  use sptmp|\n\n# Enforced standard order of declarations\n--error 1337\ncreate procedure p()\nbegin\n  declare c cursor for select * from t1;\n  declare x int;\nend|\n--error 1337\ncreate procedure p()\nbegin\n  declare x int;\n  declare continue handler for sqlstate '42S99' set x = 1;\n  declare foo condition for sqlstate '42S99';\nend|\n\n--error 1338\ncreate procedure p()\nbegin\n  declare x int;\n  declare continue handler for sqlstate '42S99' set x = 1;\n  declare c cursor for select * from t1;\nend|\n\n# Check in and inout arguments.\n--disable_warnings ONCE\ndrop procedure if exists p|\ncreate procedure p(in x int, inout y int, out z int)\nbegin\n  set y = x+y;\n  set z = x+y;\nend|\n\nset @tmp_x = 42|\nset @tmp_y = 3|\nset @tmp_z = 0|\n# For reference: this is ok\ncall p(@tmp_x, @tmp_y, @tmp_z)|\nselect @tmp_x, @tmp_y, @tmp_z|\n\n--error ER_SP_NOT_VAR_ARG\ncall p(42, 43, @tmp_z)|\n--error ER_SP_NOT_VAR_ARG\ncall p(42, @tmp_y, 43)|\n\ndrop procedure p|\n\n\n#\n# Let us test that we can access mysql.proc table for routines\n# definitions lookup without locking it explicitly.\n#\ncreate procedure p() begin end|\nlock table t1 read|\n# This should succeed\ncall p()|\nunlock tables|\ndrop procedure p|\n# Let us check restrictions which this ability puts on mysql.proc locking.\n--error ER_WRONG_LOCK_OF_SYSTEM_TABLE\nlock tables t1 read, mysql.proc write|\n--error ER_WRONG_LOCK_OF_SYSTEM_TABLE\nlock tables mysql.proc write, mysql.user write|\n# Locking for read should be OK\nlock tables t1 read, mysql.proc read|\nunlock tables|\n# You also should be able lock only mysql.proc for write\nlock tables mysql.proc write|\nunlock tables|\n\n\n#\n# Check that in functions we don't allow to update tables which\n# are used by statements which invoke these functions.\n#\n--disable_warnings ONCE\ndrop function if exists f1|\ncreate function f1(i int) returns int\nbegin\n  insert into t1 (val) values (i);\n  return 0;\nend|\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nselect val, f1(val) from t1|\n# Table alias should not matter\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nselect val, f1(val) from t1 as tab|\nselect * from t1|\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nupdate t1 set val= f1(val)|\nselect * from t1|\n# But this should be OK\nselect f1(17)|\nselect * from t1|\n# Cleanup\ndelete from t1 where val= 17|\ndrop function f1|\n\n\n#\n# BUG#1965\n#\ncreate procedure bug1965()\nbegin\n  declare c cursor for select val from t1 order by valname;\n  open c;\n  close c;\nend|\n\n--error 1054\ncall bug1965()|\ndrop procedure bug1965|\n\n#\n# BUG#1966\n#\n--error 1327\nselect 1 into a|\n\n#\n# BUG#1653\n#\n--disable_warnings ONCE\ndrop table if exists t3|\ncreate table t3 (column_1_0 int)|\n\ncreate procedure bug1653()\n  update t3 set column_1 = 0|\n\n--error 1054\ncall bug1653()|\ndrop table t3|\ncreate table t3 (column_1 int)|\ncall bug1653()|\n\ndrop procedure bug1653|\ndrop table t3|\n\n#\n# BUG#2259\n#\n# Note: When this bug existed, it did not necessarily cause a crash\n#       in all builds, but valgrind did give warnings.\ncreate procedure bug2259()\nbegin\n  declare v1 int;\n  declare c1 cursor for select s1 from t1;\n\n  fetch c1 into v1;\nend|\n\n--error 1326\ncall bug2259()|\ndrop procedure bug2259|\n\n#\n# BUG#2272\n#\ncreate procedure bug2272()\nbegin\n  declare v int;\n\n  update t1 set v = 42;\nend|\n\ninsert into t1 values (666, 51.3)|\n--error 1054\ncall bug2272()|\ntruncate table t1|\ndrop procedure bug2272|\n\n#\n# BUG#2329\n#\ncreate procedure bug2329_1()\nbegin\n  declare v int;\n\n  insert into t1 (v) values (5);\nend|\n\ncreate procedure bug2329_2()\nbegin\n  declare v int;\n\n  replace t1 set v = 5;\nend|\n\n--error 1054\ncall bug2329_1()|\n--error 1054\ncall bug2329_2()|\ndrop procedure bug2329_1|\ndrop procedure bug2329_2|\n\n#\n# BUG#3287\n#\ncreate function bug3287() returns int\nbegin\n  declare v int default null;\n\n  case\n    when v is not null then return 1;\n  end case;\n  return 2;\nend|\n--error 1339\nselect bug3287()|\ndrop function bug3287|\n\ncreate procedure bug3287(x int)\ncase x\nwhen 0 then\n  insert into test.t1 values (x, 0.1);\nwhen 1 then\n  insert into test.t1 values (x, 1.1);\nend case|\n--error 1339\ncall bug3287(2)|\ndrop procedure bug3287|\n\n#\n# BUG#3297\n#\n--disable_warnings ONCE\ndrop table if exists t3|\ncreate table t3 (s1 int, primary key (s1))|\ninsert into t3 values (5),(6)|\n\ncreate procedure bug3279(out y int) \nbegin\n  declare x int default 0;\n  begin\n    declare exit handler for sqlexception set x = x+1;\n    insert into t3 values (5);\n  end;\n  if x < 2 then\n    set x = x+1;\n    insert into t3 values (6);\n  end if;\n  set y = x;\nend|\n\nset @x = 0|\n--error ER_DUP_ENTRY\ncall bug3279(@x)|\nselect @x|\ndrop procedure bug3279|\ndrop table t3|\n\n#\n# BUG#3339\n#\n--error 1049\ncreate procedure nodb.bug3339() begin end|\n\n#\n# BUG#2653\n#\ncreate procedure bug2653_1(a int, out b int)\n  set b = aa|\n\ncreate procedure bug2653_2(a int, out b int)\nbegin\n  if aa < 0 then\n    set b = - a;\n  else\n    set b = a;\n  end if;\nend|\n\n--error 1054\ncall bug2653_1(1, @b)|\n--error 1054\ncall bug2653_2(2, @b)|\n\ndrop procedure bug2653_1|\ndrop procedure bug2653_2|\n\n#\n# BUG#4344\n#\n--error 1357\ncreate procedure bug4344() drop procedure bug4344|\n--error 1357\ncreate procedure bug4344() drop function bug4344|\n\n#\n# BUG#3294: Stored procedure crash if table dropped before use\n# (Actually, when an error occurs within an error handler.)\n--disable_warnings ONCE\ndrop procedure if exists bug3294|\ncreate procedure bug3294()\nbegin\n  declare continue handler for sqlexception drop table t5;\n  drop table t5;\n  drop table t5;\nend|\n\ncreate table t5 (x int)|\n--error 1051\ncall bug3294()|\ndrop procedure bug3294|\n\n#\n# BUG#876: Stored Procedures: Invalid SQLSTATE is allowed in \n#          a DECLARE ? HANDLER FOR stmt.\n#\n--disable_warnings\ndrop procedure if exists bug8776_1|\ndrop procedure if exists bug8776_2|\ndrop procedure if exists bug8776_3|\ndrop procedure if exists bug8776_4|\n--enable_warnings\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_1()\nbegin\n  declare continue handler for sqlstate '42S0200test' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_2()\nbegin\n  declare continue handler for sqlstate '4200' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_3()\nbegin\n  declare continue handler for sqlstate '420000' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_4()\nbegin\n  declare continue handler for sqlstate '42x00' begin end;\n  begin end;\nend|\n\n\n#\n# BUG#6600: Stored procedure crash after repeated calls with check table\n#\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  check table t1|\n\n# Check these two as well, while we're at it. (Although it isn't really\n# related to the bug report, but to the fix.)\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  lock table t1 read|\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  unlock table t1|\n\n#\n# BUG#9566: explicit LOCK TABLE and store procedures result in illegal state\n#\n# We should not think that mysql.proc table does not exist if we are unable\n# to open it under LOCK TABLE or in prelocked mode.\n#\n--disable_warnings ONCE\ndrop procedure if exists bug9566|\ncreate procedure bug9566()\nbegin\n  select * from t1;\nend|\nlock table t1 read|\n# This should fail since we forgot to lock mysql.proc for writing\n# explicitly, and we can't open mysql.proc for _writing_ if there\n# are locked tables.\n--error ER_LOCK_OR_ACTIVE_TRANSACTION\nalter procedure bug9566 comment 'Some comment'|\nunlock tables|\n# This should succeed\ndrop procedure bug9566|\n\n\n#\n# BUG#7299: Stored procedures: exception handler catches not-found conditions\n#\n--disable_warnings ONCE\ndrop procedure if exists bug7299|\ncreate procedure bug7299()\nbegin\n  declare v int;\n  declare c cursor for select val from t1;\n  declare exit handler for sqlexception select 'Error!'; \n\n  open c;\n  fetch c into v;\nend|\n\ntruncate table t1|\n--error ER_SP_FETCH_NO_DATA\ncall bug7299()|\ndrop procedure bug7299|\n\n\n#\n# BUG#9073: Able to declare two handlers for same condition in same scope\n#\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare continue handler for sqlexception select 1;\n  declare continue handler for sqlexception select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for 1234;\n  declare continue handler for condname1 select 1;\n  declare exit handler for condname1 select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare condname2 condition for sqlstate '42000';\n  declare exit handler for condname1 select 1;\n  declare continue handler for condname2 select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare exit handler for condname1 select 1;\n  declare exit handler for sqlstate '42000' select 2;\nend|\n\n# This should still work.\n--disable_warnings ONCE\ndrop procedure if exists bug9073|\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare continue handler for condname1 select 1;\n  begin\n    declare exit handler for sqlstate '42000' select 2;\n    begin\n      declare continue handler for sqlstate '42000' select 3;\n    end;\n  end;\nend|\ndrop procedure bug9073|\n\n\n#\n# BUG#7047: Stored procedure crash if alter procedure\n#\n--error ER_SP_NO_DROP_SP\ncreate procedure bug7047()\n  alter procedure bug7047|\n--error ER_SP_NO_DROP_SP\ncreate function bug7047() returns int\nbegin\n  alter function bug7047;\n  return 0;\nend|\n\n\n#\n# BUG#8408: Stored procedure crash if function contains SHOW\n# BUG#9058: Stored Procedures: Crash if function included SELECT\n#\n\n# Some things are caught when parsing\n--error ER_SP_NO_RETSET\ncreate function bug8408() returns int\nbegin\n  select * from t1;\n  return 0;\nend|\n--error ER_SP_NO_RETSET\ncreate function bug8408() returns int\nbegin\n  show warnings;\n  return 0;\nend|\n--error ER_SP_NO_RETSET\ncreate function bug8408(a int) returns int\nbegin\n  declare b int;\n  select b;\n  return b;\nend|\n\n--disable_warnings\ndrop function if exists bug8408_f|\ndrop procedure if exists bug8408_p|\n--enable_warnings\n\n# Some things must be caught at invokation time\ncreate function bug8408_f() returns int\nbegin\n  call bug8408_p();\n  return 0;\nend|\ncreate procedure bug8408_p()\n  select * from t1|\n\ncall bug8408_p()|\n--error ER_SP_NO_RETSET\nselect bug8408_f()|\n\ndrop procedure bug8408_p|\ndrop function bug8408_f|\n\n# But this is ok\ncreate function bug8408() returns int\nbegin\n  declare n int default 0;\n  select count(*) into n from t1;\n  return n;\nend|\n\ninsert into t1 value (2, 2.7), (3, 3.14), (7, 7.0)|\nselect *,bug8408() from t1|\n\ndrop function bug8408|\ntruncate table t1|\n\n\n#\n# BUG#10537: Server crashes while loading data file into table through\n#            procedure.\n# Disable load until it's PS and SP safe\n--disable_warnings ONCE\ndrop procedure if exists bug10537|\n--error ER_SP_BADSTATEMENT\ncreate procedure bug10537()\n  load data local infile '/tmp/somefile' into table t1|\n\n\n#\n# BUG#8409: Stored procedure crash if function contains FLUSH\n#\n--disable_warnings ONCE\ndrop function if exists bug8409|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409()\n  returns int\nbegin\n  flush tables;\n  return 5;\nend|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset query cache;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset master;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset slave;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush hosts;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush privileges;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush tables with read lock;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush tables;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush logs;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush status;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush des_key_file;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush user_resources;\nreturn 1; end|\n\n\n#\n# BUG#9529: Stored Procedures: No Warning on truncation of procedure name\n#           during creation.\n# BUG#17015: Routine name truncation not an error\n#            When we started using utf8 for mysql.proc, this limit appeared\n#            to be higher, but in reality the names were truncated.\n--error ER_TOO_LONG_IDENT\ncreate procedure bug9529_901234567890123456789012345678901234567890123456789012345()\nbegin\nend|\n\n--disable_warnings ONCE\ndrop procedure if exists bug17015_0123456789012345678901234567890123456789012345678901234|\n# Check the upper limit, just to make sure.\ncreate procedure bug17015_0123456789012345678901234567890123456789012345678901234()\nbegin\nend|\n\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status like 'bug17015%'|\ndrop procedure bug17015_0123456789012345678901234567890123456789012345678901234|\n\n\n#\n# BUG#10969: Stored procedures: crash if default() function\n#\n--disable_warnings ONCE\ndrop procedure if exists bug10969|\n--error ER_WRONG_COLUMN_NAME\ncreate procedure bug10969()\nbegin\n  declare s1 int default 0;\n  select default(s1) from t30;\nend|\n\n# This should work\ncreate procedure bug10969()\nbegin\n  declare s1 int default 0;\n  select default(t30.s1) from t30;\nend|\n\ndrop procedure bug10969|\n\n\ndrop table t1|\n\ndelimiter ;|\n\n# BUG#9814: Closing a cursor that is not open \ncreate table t1(f1 int);\ncreate table t2(f1 int);\n \ndelimiter |;\nCREATE PROCEDURE SP001()\nP1: BEGIN\n  DECLARE ENDTABLE INT DEFAULT 0;\n  DECLARE TEMP_NUM INT;\n  DECLARE TEMP_SUM INT;\n  DECLARE C1 CURSOR FOR SELECT F1 FROM t1;\n  DECLARE C2 CURSOR FOR SELECT F1 FROM t2;\n  DECLARE CONTINUE HANDLER FOR NOT FOUND SET ENDTABLE = 1;\n\n  SET ENDTABLE=0;\n  SET TEMP_SUM=0;\n  SET TEMP_NUM=0;\n  \n  OPEN C1;\n\n  FETCH C1 INTO TEMP_NUM;\n  WHILE ENDTABLE = 0 DO\n          SET TEMP_SUM=TEMP_NUM+TEMP_SUM;\n          FETCH C1 INTO TEMP_NUM;\n  END WHILE;\n  SELECT TEMP_SUM;\n  CLOSE C1;\n  CLOSE C1;\n  SELECT 'end of proc';\nEND P1|\ndelimiter ;|\n--error 1326\ncall SP001();\ndrop procedure SP001;\ndrop table t1, t2;\n\n# Bug #11394 \"Recursion in SP crash server\" and bug #11600 \"Stored\n# procedures: crash with function calling itself\".\n# We have to disable recursion since in many cases LEX and many\n# Item's can't be used in reentrant way nowdays.\ndelimiter |;\n--disable_warnings\ndrop function if exists bug11394|\ndrop function if exists bug11394_1|\ndrop function if exists bug11394_2|\ndrop procedure if exists bug11394|\n--enable_warnings\ncreate function bug11394(i int) returns int\nbegin\n  if i <= 0 then\n    return 0;\n  else\n    return (i in (100, 200, bug11394(i-1), 400));\n  end if;\nend|\n# If we allow recursive functions without additional modifications\n# this will crash server since Item for \"IN\" is not reenterable.\n--error 1424\nselect bug11394(2)|\ndrop function bug11394|\ncreate function bug11394_1(i int) returns int\nbegin\n  if i <= 0 then\n    return 0;\n  else\n    return (select bug11394_1(i-1));\n  end if;\nend|\n# The following statement will crash because some LEX members responsible\n# for selects cannot be used in reentrant fashion.\n--error 1424\nselect bug11394_1(2)|\ndrop function bug11394_1|\n# Note that the following should be allowed since it does not contains\n# recursion\ncreate function bug11394_2(i int) returns int return i|\nselect bug11394_2(bug11394_2(10))|\ndrop function bug11394_2|\ncreate procedure bug11394(i int, j int)\nbegin\n  if i > 0 then\n    call bug11394(i - 1,(select 1));\n  end if;\nend|\n--error ER_SP_RECURSION_LIMIT\ncall bug11394(2, 1)|\nset @@max_sp_recursion_depth=10|\ncall bug11394(2, 1)|\nset @@max_sp_recursion_depth=default|\ndrop procedure bug11394|\ndelimiter ;|\n\n\n#\n# BUG 12490 (Packets out of order if calling HELP CONTENTS from Stored Procedure)\n#\n--error ER_SP_BADSTATEMENT\nCREATE PROCEDURE BUG_12490() HELP CONTENTS;\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION BUG_12490() RETURNS INT HELP CONTENTS;\nCREATE TABLE t_bug_12490(a int);\n--error ER_SP_BADSTATEMENT\nCREATE TRIGGER BUG_12490 BEFORE UPDATE ON t_bug_12490 FOR EACH ROW HELP CONTENTS;\nDROP TABLE t_bug_12490;\n\n#\n# Bug#11834 \"Re-execution of prepared statement with dropped function\n# crashes server\". Also tests handling of prepared stmts which use\n# stored functions but does not require prelocking.\n#\n--disable_warnings\ndrop function if exists bug11834_1;\ndrop function if exists bug11834_2;\n--enable_warnings\ncreate function bug11834_1() returns int return 10;\ncreate function bug11834_2() returns int return bug11834_1();\nprepare stmt from \"select bug11834_2()\";\nexecute stmt;\n# Re-execution of statement should not crash server.\nexecute stmt;\ndrop function bug11834_1;\n# Attempt to execute statement should return proper error and \n# should not crash server.\n\n# NOTE! The error we get from the below query indicates that the sp bug11834_2\n# does not exist(this is wrong but can be accepted)\n# This behaviour has been reported as bug#21294\n--error ER_SP_DOES_NOT_EXIST\nexecute stmt;\ndeallocate prepare stmt;\ndrop function bug11834_2;\n\n#\n# Bug#12953 \"Stored procedures: crash if OPTIMIZE TABLE in function\"\n#\ndelimiter |;\n--disable_warnings ONCE\nDROP FUNCTION IF EXISTS bug12953|\n--error ER_SP_NO_RETSET\nCREATE FUNCTION bug12953() RETURNS INT\nBEGIN\n  OPTIMIZE TABLE t1;\n  RETURN 1;\nEND|\ndelimiter ;|\n\n#\n# Bug##12995 \"Inside function \"Table 't4' was not locked with LOCK TABLES\"\n#\ndelimiter |;\n--disable_warnings ONCE\nDROP FUNCTION IF EXISTS bug12995|\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 OPEN;\n  RETURN 1;\nEND|\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 READ FIRST;\n  RETURN 1;\nEND|\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 CLOSE;\n  RETURN 1;\nEND|\n--error 1305\nSELECT bug12995()|\ndelimiter ;|\n\n\n#\n# BUG#12712: SET AUTOCOMMIT should fail within SP/functions/triggers\n#\n--disable_warnings\ndrop procedure if exists bug12712;\ndrop function if exists bug12712;\n--enable_warnings\n# Can...\ncreate procedure bug12712()\n  set session autocommit = 0;\n\nselect @@autocommit;\nset @au = @@autocommit;\ncall bug12712();\nselect @@autocommit;\nset session autocommit = @au;\n\ndelimiter |;\ncreate function bug12712()\n  returns int\nbegin\n  call bug12712();\n  return 0;\nend|\n\n# Can't...\n--error ER_SP_CANT_SET_AUTOCOMMIT\nset @x = bug12712()|\ndrop procedure bug12712|\ndrop function bug12712|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set session autocommit = 0;\n  return 0;\nend|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set @@autocommit = 0;\n  return 0;\nend|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set local autocommit = 0;\n  return 0;\nend|\ndelimiter ;|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate trigger bug12712\n  before insert on t1 for each row set session autocommit = 0;\n\n#\n# BUG#9367: Stored procedures: client hang after \"show warnings\"\n#\n--disable_parsing\n--disable_warnings ONCE\ndrop procedure if exists bug9367;\ncreate table t1 (s1 int);\nselect s1 from t1;\ndelimiter |;\ncreate procedure bug9367()\nbegin\n  declare v int;\n  declare c cursor for select s1 from t1;\n  open c;\n  show warnings;\n  fetch c into v;\n  select v;\nend|\ndelimiter ;|\ncall bug9367();\ndrop procedure bug9367;\ndrop table t1;\n--enable_parsing\n\n#\n# BUG#13510: Setting password local variable changes current password\n#\ndelimiter |;\n--disable_warnings\ndrop procedure if exists bug13510_1|\ndrop procedure if exists bug13510_2|\ndrop procedure if exists bug13510_3|\ndrop procedure if exists bug13510_4|\n--enable_warnings\n\n--error ER_SP_BAD_VAR_SHADOW\ncreate procedure bug13510_1()\nbegin\n  declare password varchar(10);\n\n  set password = 'foo1';\n  select password;\nend|\n\n# Check that an error message is sent\n--error ER_PARSE_ERROR\nset names='foo2'|\n\n--error ER_SP_BAD_VAR_SHADOW\ncreate procedure bug13510_2()\nbegin\n  declare names varchar(10);\n\n  set names = 'foo2';\n  select names;\nend|\n\ncreate procedure bug13510_3()\nbegin\n  declare password varchar(10);\n\n  set `password` = 'foo3';\n  select password;\nend|\n\ncreate procedure bug13510_4()\nbegin\n  declare names varchar(10);\n\n  set `names` = 'foo4';\n  select names;\nend|\n\ncall bug13510_3()|\ncall bug13510_4()|\n\ndrop procedure bug13510_3|\ndrop procedure bug13510_4|\n\n\n#\n# Test that statements which implicitly commit transaction are prohibited\n# in stored function and triggers. Attempt to create function or trigger\n# containing such statement should produce error (includes test for\n# bug #13627).\n#\n--disable_warnings ONCE\ndrop function if exists bug_13627_f|\n\nCREATE TABLE t1 (a int)|\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DROP TRIGGER test1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN DROP TRIGGER test1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create table t2 (a int); END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create table t2 (a int); return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create index t1_i on t1 (a); END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create index t1_i on t1 (a); return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter table t1 add column  b int; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN alter table t1 add column  b int; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename table t1 to t2; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN rename table t1 to t2; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN truncate table t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN truncate table t1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop table t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop table t1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop index t1_i on t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop index t1_i on t1; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN unlock tables; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN unlock tables; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN LOCK TABLE t1 READ; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN LOCK TABLE t1 READ; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create database mysqltest; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create database mysqltest; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop database mysqltest; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop database mysqltest; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create user 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create user 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN grant select on t1 to 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN grant select on t1 to 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke select on t1 from 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN revoke select on t1 from 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke all privileges on *.* from 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN revoke all privileges on *.* from 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop user 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop user 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create view v1 as select 1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create view v1 as select 1; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter view v1 as select 1; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN alter view v1 as select 1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop view v1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop view v1; return 1; END |\n\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create trigger tr2 before insert on t1 for each row do select 1; END |\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE FUNCTION bug_13627_f() returns int BEGIN create trigger tr2 before insert on t1 for each row do select 1; return 1; END |\n\n-- error ER_SP_NO_DROP_SP\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop function bug_13627_f; END |\n-- error ER_SP_NO_DROP_SP\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop function bug_13627_f; return 1; END |\n\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create function f2 () returns int return 1; END |\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE FUNCTION bug_13627_f() returns int BEGIN create function f2 () returns int return 1; return 1; END |\n\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW\n  BEGIN\n    CREATE TEMPORARY TABLE t2 (a int);\n    DROP TEMPORARY TABLE t2;\n  END |\nCREATE FUNCTION bug_13627_f() returns int\n  BEGIN\n    CREATE TEMPORARY TABLE t2 (a int);\n    DROP TEMPORARY TABLE t2;\n    return 1;\n  END |\n\ndrop table t1|\ndrop function bug_13627_f|\n\ndelimiter ;|\n\n# BUG#12329: \"Bogus error msg when executing PS with stored procedure after\n# SP was re-created\". See also test for related bug#13399 in trigger.test\ndrop function if exists bug12329;\n--enable_warnings\ncreate table t1 as select 1 a;\ncreate table t2 as select 1 a;\ncreate function bug12329() returns int return (select a from t1);\nprepare stmt1 from 'select bug12329()';\nexecute stmt1;\ndrop function bug12329;\ncreate function bug12329() returns int return (select a+100 from t2);\nselect bug12329();\nexecute stmt1;\ndeallocate prepare stmt1;\ndrop function bug12329; \ndrop table t1, t2;\n\n#\n# Bug#13514 \"server crash when create a stored procedure before choose a\n# database\" and\n# Bug#13587 \"Server crash when SP is created without database\n# selected\"\n#\ncreate database mysqltest1;\nuse mysqltest1;\ndrop database mysqltest1;\n--error ER_NO_DB_ERROR \ncreate function f1() returns int return 1;\ndelimiter |;\n--error ER_NO_DB_ERROR \ncreate procedure p1(out param1 int)\nbegin\n  select count(*) into param1 from t3;\nend|\ndelimiter ;|\nuse test;\n\n\n#\n# BUG#13037: undefined variable in IF cause erroneous error-message\n#\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS bug13037_p1;\nDROP PROCEDURE IF EXISTS bug13037_p2;\nDROP PROCEDURE IF EXISTS bug13037_p3;\n--enable_warnings\n\ndelimiter |;\n\nCREATE PROCEDURE bug13037_p1()\nBEGIN\n  IF bug13037_foo THEN\n    SELECT 1;\n  END IF;\nEND|\n\nCREATE PROCEDURE bug13037_p2()\nBEGIN\n  SET @bug13037_foo = bug13037_bar;\nEND|\n\nCREATE PROCEDURE bug13037_p3()\nBEGIN\n  SELECT bug13037_foo;\nEND|\n\ndelimiter ;|\n\n--echo\n\n--error 1054\nCALL bug13037_p1();\n--error 1054\nCALL bug13037_p2();\n--error 1054\nCALL bug13037_p3();\n\n--error 1054\nCALL bug13037_p1();\n--error 1054\nCALL bug13037_p2();\n--error 1054\nCALL bug13037_p3();\n\nDROP PROCEDURE bug13037_p1;\nDROP PROCEDURE bug13037_p2;\nDROP PROCEDURE bug13037_p3;\n\n#\n# Bug#14569 \"editing a stored procedure kills mysqld-nt\"\n#\ncreate database mysqltest1;\ncreate database mysqltest2;\nuse mysqltest1;\ndrop database mysqltest1;\ncreate procedure mysqltest2.p1() select version();\n--error ER_NO_DB_ERROR \ncreate procedure p2() select version();\nuse mysqltest2;\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status;\ndrop database mysqltest2;\nuse test;\n\n#\n# Bug#13012 \"SP: REPAIR/BACKUP/RESTORE TABLE crashes the server\"\n#\ndelimiter |;\n--disable_warnings ONCE\nDROP FUNCTION IF EXISTS bug13012|\n--error ER_SP_NO_RETSET\nCREATE FUNCTION bug13012() RETURNS INT\nBEGIN\n  REPAIR TABLE t1;\n  RETURN 1;\nEND|\ncreate table t1 (a int)|\nCREATE PROCEDURE bug13012_1() REPAIR TABLE t1|\nCREATE FUNCTION bug13012_2() RETURNS INT\nBEGIN\n  CALL bug13012_1();\n  RETURN 1;\nEND|\n--error ER_SP_NO_RETSET\nSELECT bug13012_2()|\ndrop table t1|\ndrop procedure bug13012_1|\ndrop function bug13012_2|\ndelimiter ;|\n\n#\n# BUG#11555 \"Stored procedures: current SP tables locking make \n# impossible view security\". We should not expose names of tables\n# which are implicitly used by view (via stored routines/triggers).\n#\n# Note that SQL standard assumes that you simply won't be able drop table\n# and leave some objects (routines/views/triggers) which were depending on\n# it. Such objects should be dropped in advance (by default) or will be\n# dropped simultaneously with table (DROP TABLE with CASCADE clause).\n# So these tests probably should go away once we will implement standard\n# behavior.\n--disable_warnings\ndrop function if exists bug11555_1;\ndrop function if exists bug11555_2;\ndrop view if exists v1, v2, v3, v4;\n--enable_warnings\ncreate function bug11555_1() returns int return (select max(i) from t1);\ncreate function bug11555_2() returns int return bug11555_1();\n# It is OK to report name of implicitly used table which is missing\n# when we create view.\n# For stored functions however, because of exceptions handlers, there is\n# no easy way to find out if a missing table makes the view invalid.\ncreate view v1 as select bug11555_1();\ndrop view v1;\ncreate view v2 as select bug11555_2();\ndrop view v2;\n# But we should hide name of missing implicitly used table when we use view\ncreate table t1 (i int);\ncreate view v1 as select bug11555_1();\ncreate view v2 as select bug11555_2();\ncreate view v3 as select * from v1;\ndrop table t1;\n--error ER_VIEW_INVALID\nselect * from v1;\n--error ER_VIEW_INVALID\nselect * from v2;\n--error ER_VIEW_INVALID\nselect * from v3;\n# Note that creation of view which depends on broken view is yet \n# another form of view usage.\ncreate view v4 as select * from v1;\ndrop view v1, v2, v3, v4;\n# We also should hide details about broken triggers which are\n# invoked for view.\ndrop function bug11555_1;\ndrop function bug11555_2;\ncreate table t1 (i int);\ncreate table t2 (i int);\ncreate trigger t1_ai after insert on t1 for each row insert into t2 values (new.i);\ncreate view v1 as select * from t1;\ndrop table t2;\n# Limitation, the desired error is ER_VIEW_INVALID\n--error ER_NO_SUCH_TABLE\ninsert into v1 values (1);\ndrop trigger t1_ai;\ncreate function bug11555_1() returns int return (select max(i) from t2);\ncreate trigger t1_ai after insert on t1 for each row set @a:=bug11555_1();\n# Limitation, the desired error is ER_VIEW_INVALID\n--error ER_NO_SUCH_TABLE \ninsert into v1 values (2);\ndrop function bug11555_1;\ndrop table t1;\ndrop view v1;\n\n#\n# BUG#15658: Server crashes after creating function as empty string\n#\n--disable_warnings ONCE\ndrop procedure if exists ` bug15658`;\n\n--error ER_SP_WRONG_NAME\ncreate procedure ``() select 1;\n--error ER_SP_WRONG_NAME\ncreate procedure ` `() select 1;\n--error ER_SP_WRONG_NAME\ncreate procedure `bug15658 `() select 1;\n--error ER_WRONG_DB_NAME\ncreate procedure ``.bug15658() select 1;\n--error ER_WRONG_DB_NAME\ncreate procedure `x `.bug15658() select 1;\n\n# This should work\ncreate procedure ` bug15658`() select 1;\ncall ` bug15658`();\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status;\ndrop procedure ` bug15658`;\n\n\n#\n# BUG#14270: Stored procedures: crash if load index\n#\n--disable_warnings\ndrop function if exists bug14270;\ndrop table if exists t1;\n--enable_warnings\n\ncreate table t1 (s1 int primary key);\n\ndelimiter |;\n--error ER_SP_NO_RETSET\ncreate function bug14270() returns int\nbegin\n  load index into cache t1;\n  return 1;\nend|\n\n--error ER_SP_NO_RETSET\ncreate function bug14270() returns int\nbegin\n  cache index t1 key (`primary`) in keycache1;\n  return 1;\nend|\ndelimiter ;|\n\ndrop table t1;\n\n\n#\n# BUG#15091: Sp Returns Unknown error in order clause....and \n#            there is no order by clause\n#\n--disable_warnings ONCE\ndrop procedure if exists bug15091;\n\ndelimiter |;\ncreate procedure bug15091()\nbegin\n  declare selectstr varchar(6000) default ' ';\n  declare conditionstr varchar(5000)  default '';\n\n  set selectstr = concat(selectstr,\n                         ' and ',\n                         c.operatorid,\n                         'in (',conditionstr, ')');\nend|\ndelimiter ;|\n\n# The error message used to be:\n#   ERROR 1109 (42S02): Unknown table 'c' in order clause\n# but is now rephrased to something less misleading:\n#   ERROR 1109 (42S02): Unknown table 'c' in field list\n--error ER_UNKNOWN_TABLE\ncall bug15091();\n\ndrop procedure bug15091;\n\n\n#\n# BUG#16896: Stored function: unused AGGREGATE-clause in CREATE FUNCTION\n#\n--disable_warnings ONCE\ndrop function if exists bug16896;\n\n--error ER_PARSE_ERROR\ncreate aggregate function bug16896() returns int return 1;\n\n#\n#\n# BUG#14702: misleading error message when syntax error in CREATE\n# PROCEDURE\n#\n# Misleading error message was given when IF NOT EXISTS was used in\n# CREATE PROCEDURE.\n#\n--disable_warnings ONCE\nDROP PROCEDURE IF EXISTS bug14702;\n\n--error ER_PARSE_ERROR\nCREATE IF NOT EXISTS PROCEDURE bug14702()\nBEGIN\nEND;\n\n--error ER_PARSE_ERROR\nCREATE PROCEDURE IF NOT EXISTS bug14702()\nBEGIN\nEND;\n\n\n#\n# BUG#20953: create proc with a create view that uses local\n# vars/params should fail to create\n#\n# See test case for what syntax is forbidden in a view.\n#\n--disable_warnings ONCE\nDROP TABLE IF EXISTS t1;\n\nCREATE TABLE t1 (i INT);\n\n# We do not have to drop this procedure and view because they won't be\n# created.\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO @a;\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO DUMPFILE \"file\";\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO OUTFILE \"file\";\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953()\n  CREATE VIEW v AS SELECT i FROM t1 PROCEDURE ANALYSE();\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 FROM (SELECT 1) AS d1;\nDROP PROCEDURE bug20953;\n--error ER_VIEW_SELECT_VARIABLE\nCREATE PROCEDURE bug20953(i INT) CREATE VIEW v AS SELECT i;\ndelimiter |;\n--error ER_VIEW_SELECT_VARIABLE\nCREATE PROCEDURE bug20953()\nBEGIN\n  DECLARE i INT;\n  CREATE VIEW v AS SELECT i;\nEND |\ndelimiter ;|\n--error ER_VIEW_SELECT_VARIABLE\nPREPARE stmt FROM \"CREATE VIEW v AS SELECT ?\";\n\nDROP TABLE t1;\n\n\n#\n# BUG#24491 \"using alias from source table in insert ... on duplicate key\"\n#\n--disable_warnings\ndrop tables if exists t1;\ndrop procedure if exists bug24491;\n--enable_warnings\ncreate table t1 (id int primary key auto_increment, value varchar(10));\ninsert into t1 (id, value) values (1, 'FIRST'), (2, 'SECOND'), (3, 'THIRD');\n# Let us create routine with INSERT ... SELECT ... ON DUPLICATE KEY UPDATE \n# statement which in its ON DUPLICATE KEY clause erroneously tries to assign\n# value to a column which is mentioned only in SELECT part.\ncreate procedure bug24491()\n  insert into t1 (id, value) select * from (select 4 as i, 'FOURTH' as v) as y on duplicate key update v = 'DUP';\n# Both first and second calls to it should fail\n--error ER_BAD_FIELD_ERROR \ncall bug24491();\n--error ER_BAD_FIELD_ERROR\ncall bug24491();\ndrop procedure bug24491;\n# And now the same test for more complex case which is more close\n# to the one that was reported originally.\ncreate procedure bug24491()\n  insert into t1 (id, value) select * from (select 4 as id, 'FOURTH' as value) as y on duplicate key update y.value = 'DUP';\n--error ER_BAD_FIELD_ERROR \ncall bug24491();\n--error ER_BAD_FIELD_ERROR\ncall bug24491();\ndrop procedure bug24491;\ndrop tables t1;\n\n#\n# BUG#18914: Calling certain SPs from triggers fail\n#\n# Failing to call a procedure that does implicit commit from a trigger\n# is a correct behaviour, however the error message was misleading.\n#\n# DROP TABLE IF EXISTS is also fixed to give correct error instead of\n# \"Table doesn't exist\". \n#\n--disable_warnings\nDROP FUNCTION IF EXISTS bug18914_f1;\nDROP FUNCTION IF EXISTS bug18914_f2;\nDROP PROCEDURE IF EXISTS bug18914_p1;\nDROP PROCEDURE IF EXISTS bug18914_p2;\nDROP TABLE IF EXISTS t1, t2;\n--enable_warnings\n\nCREATE TABLE t1 (i INT);\n\nCREATE PROCEDURE bug18914_p1() CREATE TABLE t2 (i INT);\nCREATE PROCEDURE bug18914_p2() DROP TABLE IF EXISTS no_such_table;\n\ndelimiter |;\nCREATE FUNCTION bug18914_f1() RETURNS INT\nBEGIN\n  CALL bug18914_p1();\n  RETURN 1;\nEND |\n\nCREATE FUNCTION bug18914_f2() RETURNS INT\nBEGIN\n  CALL bug18914_p2();\n  RETURN 1;\nEND |\ndelimiter ;|\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\n  CALL bug18914_p1();\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nINSERT INTO t1 VALUES (1);\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nSELECT bug18914_f1();\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nSELECT bug18914_f2();\n\n--error ER_NO_SUCH_TABLE\nSELECT * FROM t2;\n\nDROP FUNCTION bug18914_f1;\nDROP FUNCTION bug18914_f2;\nDROP PROCEDURE bug18914_p1;\nDROP PROCEDURE bug18914_p2;\nDROP TABLE t1;\n\n#\n# Bug#20713 (Functions will not not continue for SQLSTATE VALUE '42S02')\n#\n\n--disable_warnings\ndrop table if exists bogus_table_20713;\ndrop function if exists func_20713_a;\ndrop function if exists func_20713_b;\n--enable_warnings\n\ncreate table bogus_table_20713( id int(10) not null primary key);\ninsert into bogus_table_20713 values (1), (2), (3);\n\ndelimiter //;\n\ncreate function func_20713_a() returns int(11)\nbegin\n  declare id int;\n\n  declare continue handler for sqlexception set id=null;\n\n  set @in_func := 1;\n  set id = (select id from bogus_table_20713 where id = 3);\n  set @in_func := 2;\n\n  return id;\nend//\n\ncreate function func_20713_b() returns int(11)\nbegin\n  declare id int;\n\n  declare continue handler for sqlstate value '42S02' set id=null;\n\n  set @in_func := 1;\n  set id = (select id from bogus_table_20713 where id = 3);\n  set @in_func := 2;\n\n  return id;\nend//\n\ndelimiter ;//\n\nset @in_func := 0;\nselect func_20713_a();\nselect @in_func;\n\nset @in_func := 0;\nselect func_20713_b();\nselect @in_func;\n\ndrop table bogus_table_20713;\n\nset @in_func := 0;\nselect func_20713_a();\nselect @in_func;\n\nset @in_func := 0;\nselect func_20713_b();\nselect @in_func;\n\ndrop function if exists func_20713_a;\ndrop function if exists func_20713_b;\n\n#\n# Bug#25345 (Cursors from Functions)\n#\n\n--disable_warnings\ndrop table if exists table_25345_a;\ndrop table if exists table_25345_b;\ndrop procedure if exists proc_25345;\ndrop function if exists func_25345;\ndrop function if exists func_25345_b;\n--enable_warnings\n\ncreate table table_25345_a (a int);\ncreate table table_25345_b (b int);\n\ndelimiter ||;\n\ncreate procedure proc_25345()\nbegin\n  declare c1 cursor for select a from table_25345_a;\n  declare c2 cursor for select b from table_25345_b;\n\n  select 1 as result;\nend ||\n\ncreate function func_25345() returns int(11)\nbegin\n  call proc_25345();\n  return 1;\nend ||\n\ncreate function func_25345_b() returns int(11)\nbegin\n  declare c1 cursor for select a from table_25345_a;\n  declare c2 cursor for select b from table_25345_b;\n\n  return 1;\nend ||\n\ndelimiter ;||\n\ncall proc_25345();\n--error ER_SP_NO_RETSET\nselect func_25345();\nselect func_25345_b();\n\ndrop table table_25345_a;\n\ncall proc_25345();\n--error ER_SP_NO_RETSET\nselect func_25345();\nselect func_25345_b();\n\ndrop table table_25345_b;\ndrop procedure proc_25345;\ndrop function func_25345;\ndrop function func_25345_b;\n\n#\n# End of 5.0 tests\n#\n--echo End of 5.0 tests\n\n#\n# BUG#20701: BINARY keyword should be forbidden in stored routines\n#\n--disable_warnings ONCE\ndrop function if exists bug20701;\n#\n# This was disabled in 5.1.12. See bug #20701\n# When collation support in SP is implemented, then this test should\n# be removed.\n#\n--error ER_NOT_SUPPORTED_YET\ncreate function bug20701() returns varchar(25) binary return \"test\";\ncreate function bug20701() returns varchar(25) return \"test\";\ndrop function bug20701;\n\n#\n# Bug#26503 (Illegal SQL exception handler code causes the server to crash)\n#\n\ndelimiter //;\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_1()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n      begin\n        iterate retry;\n      end\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_2()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n        iterate retry;\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_3()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n      begin\n        leave retry;\n      end\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_4()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n        leave retry;\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\ndelimiter ;//\n\n\n#\n# Bug#28360 (RENAME DATABASE destroys routines)\n#\n\n--disable_warnings\ndrop procedure if exists proc_28360;\ndrop function if exists func_28360;\n--enable_warnings\n\ndelimiter //;\n\n--error ER_SP_NO_DROP_SP\nCREATE PROCEDURE proc_28360()\nBEGIN\n  ALTER DATABASE `#mysql50#upgrade-me` UPGRADE DATA DIRECTORY NAME;\nEND//\n\n--error ER_SP_NO_DROP_SP\nCREATE FUNCTION func_28360() RETURNS int\nBEGIN\n  ALTER DATABASE `#mysql50#upgrade-me` UPGRADE DATA DIRECTORY NAME;\n  RETURN 0;\nEND//\n\ndelimiter ;//\n\n\n#\n# Bug#29223 declare cursor c for SHOW .....\n#\n\n--disable_warnings ONCE\nDROP PROCEDURE IF EXISTS p1;\n--delimiter |\n--error ER_PARSE_ERROR\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE c char(100);\n  DECLARE cur1 CURSOR FOR SHOW TABLES;\n\n  OPEN cur1;\n  FETCH cur1 INTO c;\n  select c;\n  CLOSE cur1;\nEND|\n--delimiter ;\n\n#\n# Bug#29816 Syntactically wrong query fails with misleading error message\n#\n\n--disable_warnings ONCE\nDROP DATABASE IF EXISTS mysqltest;\nCREATE DATABASE mysqltest;\nUSE mysqltest;\nDROP DATABASE mysqltest;\n# Both ER_SP_DOES_NOT_EXIST and ER_PARSE_ERROR are valid here, the result is\n# implementation dependent: See Bug#29816 for details.  \n# ER_SP_DOES_NOT_EXIST has been replaced by ER_NO_DB_ERROR since it is valid in\n# this scenario. See Bug# 13864485 for details.\n--error ER_PARSE_ERROR\nSELECT inexistent(), 1 + ,;\n--error ER_NO_DB_ERROR\nSELECT inexistent();\n--error ER_PARSE_ERROR\nSELECT .inexistent();\n--error ER_PARSE_ERROR\nSELECT ..inexistent();\nUSE test;\n\n#\n# Bug#30904 SET PASSWORD statement is non-transactional\n#\n\ndelimiter |;\n\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function f1() returns int\nbegin\n set password = 'foo';\n  return 1;\nend|\n\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate trigger t1\n  before insert on t2 for each row set password = 'foo';|\n\ndelimiter ;|\n\n#\n# Bug#30882 Dropping a temporary table inside a stored function may cause a server crash\n#\n\n--disable_warnings\ndrop function if exists f1;\ndrop function if exists f2;\ndrop table if exists t1, t2;\n--enable_warnings\n\ndelimiter |;\ncreate function f1() returns int\nbegin\n drop temporary table t1;\n return 1;\nend|\ndelimiter ;|\n--error ER_CANT_REOPEN_TABLE\ncreate temporary table t1 as select f1();\n\ndelimiter |;\ncreate function f2() returns int\nbegin\n create temporary table t2 as select f1();\n return 1;\nend|\ndelimiter ;|\n--error ER_CANT_REOPEN_TABLE\ncreate temporary table t1 as select f2();\n\ndrop function f1;\ndrop function f2;\n\ndelimiter |;\ncreate function f1() returns int\nbegin\n drop temporary table t2,t1;\n return 1;\nend|\ncreate function f2() returns int\nbegin\n create temporary table t2 as select f1();\n return 1;\nend|\ndelimiter ;|\n--error ER_CANT_REOPEN_TABLE\ncreate temporary table t1 as select f2();\n\ndrop function f1;\ndrop function f2;\n\ncreate temporary table t2(a int);\nselect * from t2;\ndelimiter |;\ncreate function f2() returns int\nbegin\n drop temporary table t2;\n return 1;\nend|\ndelimiter ;|\nselect f2();\n\ndrop function f2;\n--error ER_BAD_TABLE_ERROR\ndrop table t2;\n\n--echo End of 5.1 tests\n\n#\n# Bug#33983 (Stored Procedures: wrong end <label> syntax is accepted)\n#\n\n--disable_warnings\ndrop procedure if exists proc_33983_a;\ndrop procedure if exists proc_33983_b;\ndrop procedure if exists proc_33983_c;\ndrop procedure if exists proc_33983_d;\n--enable_warnings\n\ndelimiter |;\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_a()\nbegin\n  label1:\n    begin\n      label2:\n      begin\n        select 1;\n      end label1;\n    end;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_b()\nbegin\n  label1:\n    repeat\n      label2:\n      repeat\n        select 1;\n      until FALSE end repeat label1;\n    until FALSE end repeat;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_c()\nbegin\n  label1:\n    while TRUE do\n      label2:\n      while TRUE do\n        select 1;\n      end while label1;\n    end while;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_d()\nbegin\n  label1:\n    loop\n      label2:\n      loop\n        select 1;\n      end loop label1;\n    end loop;\nend|\n\nCREATE TABLE t1 (a INT)|\nINSERT INTO t1 VALUES (1),(2)|\nCREATE PROCEDURE p1(a INT) BEGIN END|\n--error ER_SUBQUERY_NO_1_ROW\nCALL p1((SELECT * FROM t1))|\nDROP PROCEDURE IF EXISTS p1|\nDROP TABLE t1|\n\ndelimiter ;|\n\n#\n# Bug#21801: SQL exception handlers and warnings\n#\n\n--disable_warnings ONCE\ndrop procedure if exists p1;\ndelimiter |;\ncreate procedure p1()\nbegin\n  create table t1 (a int);\n  drop table t1;\nend|\ndelimiter ;|\ncall p1();\ncall p1();\ndrop procedure p1;\n\n#\n# Bug#8759 (Stored Procedures: SQLSTATE '00000' should be illegal)\n#\n\n--disable_warnings ONCE\ndrop procedure if exists proc_8759;\n\ndelimiter $$;\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_8759()\nbegin\n  declare should_be_illegal condition for sqlstate '00000';\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_8759()\nbegin\n  declare continue handler for sqlstate '00000' set @x=0;\nend$$\n\ndelimiter ;$$\n\n#\n# Bug#36510 (Stored Procedures: mysql_error_code 0 should be illegal)\n#\n\n--disable_warnings ONCE\ndrop procedure if exists proc_36510;\n\ndelimiter $$;\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_36510()\nbegin\n  declare should_be_illegal condition for sqlstate '00123';\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_36510()\nbegin\n  declare continue handler for sqlstate '00123' set @x=0;\nend$$\n\n--error ER_WRONG_VALUE\ncreate procedure proc_36510()\nbegin\n  declare should_be_illegal condition for 0;\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_WRONG_VALUE\ncreate procedure proc_36510()\nbegin\n  declare continue handler for 0 set @x=0;\nend$$\ndelimiter ;$$\n\n#\n# Bug#15192: \"fatal errors\" are caught by handlers in stored procedures\n#\n\n--disable_warnings ONCE\ndrop procedure if exists p1;\nset @old_recursion_depth = @@max_sp_recursion_depth;\nset @@max_sp_recursion_depth = 255;\ndelimiter |;\ncreate procedure p1(a int)\nbegin\n  declare continue handler for 1436 -- ER_STACK_OVERRUN_NEED_MORE\n    select 'exception';\n  call p1(a+1);\nend|\ndelimiter ;|\n--error 0,ER_STACK_OVERRUN_NEED_MORE,ER_SP_RECURSION_LIMIT\ncall p1(1);\nset @@max_sp_recursion_depth = @old_recursion_depth;\ndrop procedure p1;\n\n#\n# BUG#NNNN: New bug synopsis\n#\n#--disable_warnings\n#drop procedure if exists bugNNNN;\n#drop function if exists bugNNNN;\n#--enable_warnings\n#create procedure bugNNNN...\n#create function bugNNNN...\n\n#\n# CLEANUP and RESTORE\n#\nLOAD DATA INFILE '../../tmp/proc.txt' INTO TABLE mysql.proc;\nremove_file $MYSQLTEST_VARDIR/tmp/proc.txt;\n\n#\n# Bug #38159: Function parsing problem generates misleading error message\n#\n\nCREATE TABLE t1 (a INT, b INT);\nINSERT INTO t1 VALUES (1,1), (2,2);\n--error ER_FUNC_INEXISTENT_NAME_COLLISION\nSELECT MAX (a) FROM t1 WHERE b = 999999;\nSELECT AVG (a) FROM t1 WHERE b = 999999;\n--error ER_SP_DOES_NOT_EXIST\nSELECT non_existent (a) FROM t1 WHERE b = 999999;\nDROP TABLE t1;\n\n\n#\n# Bug #46374 crash, INSERT INTO t1 uses function, function modifies t1\n#\nCREATE TABLE t1 ( f2 INTEGER, f3 INTEGER );\nINSERT INTO t1 VALUES  ( 1, 1 );\n\ndelimiter |;\n\nCREATE FUNCTION func_1 () RETURNS INTEGER\nBEGIN\n  INSERT INTO t1 SELECT * FROM t1 ;\n  RETURN 1 ;\nEND|\n\ndelimiter ;|\n\n# The bug caused the following INSERT statement to trigger\n# an assertion.   Error 1442 is the correct response\n#\n--error 1442\nINSERT INTO t1 SELECT * FROM (SELECT 2 AS f1, 2 AS f2) AS A WHERE func_1() = 5;\n\n# Cleanup\nDROP FUNCTION func_1;\nDROP TABLE t1;\n\n\n\n--echo #\n--echo # Bug #47788: Crash in TABLE_LIST::hide_view_error on UPDATE + VIEW + \n--echo #   SP + MERGE + ALTER\n--echo #\n\nCREATE TABLE t1 (pk INT, b INT, KEY (b));\nCREATE ALGORITHM = TEMPTABLE VIEW v1 AS SELECT * FROM t1;\n\nCREATE PROCEDURE p1 (a int) UPDATE IGNORE v1 SET b = a; \n\n--error ER_NON_UPDATABLE_TABLE\nCALL p1(5);\n\nALTER TABLE t1 CHANGE COLUMN b b2 INT;\n\n--error ER_VIEW_INVALID\nCALL p1(7);\n\nDROP PROCEDURE p1;\nDROP VIEW v1;\nDROP TABLE t1;\n\n--echo #\n--echo # Bug#12428824 - PARSER STACK OVERFLOW AND CRASH IN SP_ADD_USED_ROUTINE\n--echo #                WITH OBSCURE QUERY\n--echo #\n\n--error ER_TOO_LONG_IDENT\nSELECT very_long_fn_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();\n\n--error ER_TOO_LONG_IDENT\nCALL very_long_pr_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();\n\n--error ER_WRONG_DB_NAME\nSELECT very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_func();\n\n--error ER_WRONG_DB_NAME\nCALL very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_proc();\n\n--error ER_TOO_LONG_IDENT\nSELECT db_name.very_long_fn_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();\n\n--error ER_TOO_LONG_IDENT\nCALL db_name.very_long_pr_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();\n--echo End of 5.1 tests\n\n--echo #\n--echo # Bug#23032: Handlers declared in a SP do not handle warnings generated in sub-SP\n--echo #\n\n--echo\n--echo # - Case 1\n--echo\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\nDROP PROCEDURE IF EXISTS p3;\nDROP PROCEDURE IF EXISTS p4;\nDROP PROCEDURE IF EXISTS p5;\nDROP PROCEDURE IF EXISTS p6;\n--enable_warnings\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\ndelimiter |;\n\nCREATE PROCEDURE p1()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    SELECT 1;\n    CALL p2();\n  END|\n\nCREATE PROCEDURE p2()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n  END|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\n\n--echo\n--echo # - Case 2\n--echo\n\n--disable_warnings ONCE\nDROP TABLE IF EXISTS t1;\n\nCREATE TABLE t1(a INT);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\n  BEGIN\n    DECLARE c INT DEFAULT 0;\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      SET c = c + 1;\n      SELECT 'Warning caught!' AS Msg;\n    END;\n    CALL p2(); # 1 warning\n    CALL p3(); # 1 warning\n    CALL p4(); # No warnings\n    CALL p5(); # 1 warning\n    SELECT c;\n    SELECT @@warning_count;\n    SHOW WARNINGS;\n  END|\n\nCREATE PROCEDURE p2()\n  BEGIN\n    SELECT CAST('2 ' as unsigned integer);\n  END| # 1 warning is passed to the caller\n\nCREATE PROCEDURE p3()\n  BEGIN\n    SELECT CAST('3 ' as unsigned integer);\n    GET DIAGNOSTICS @n = NUMBER; # does not clear the warning\n  END| # 1 warning is passed to the caller\n\nCREATE PROCEDURE p4()\n  BEGIN\n    SELECT CAST('4 ' as unsigned integer);\n    INSERT INTO t1 VALUES(1); # Clears the warning\n  END| # No warnings to pass\n\nCREATE PROCEDURE p5()\n  BEGIN\n    SELECT CAST('5 ' as unsigned integer);\n    CALL p2();\n  END|\n\nCREATE PROCEDURE p6()\n  BEGIN\n    SELECT CAST('6 ' as unsigned integer);\n    SHOW WARNINGS;\n  END|\n\nCREATE PROCEDURE p7()\n  BEGIN\n    DECLARE c INT DEFAULT 0;\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      SET c = c + 1;\n      SELECT 'Warning caught!' AS Msg;\n    END;\n    CALL p6();\n    SELECT c;\n  END|\n\ndelimiter ;|\n\n--echo\nCALL p1();\n\n--echo\nCALL p7();\n\n--echo\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\nDROP PROCEDURE p7;\n\nDROP TABLE t1;\nSET sql_mode = default;\n--echo\n--echo # - Case 3: check that \"Exception trumps No Data\".\n--echo\n\n--disable_warnings ONCE\nDROP TABLE IF EXISTS t1;\n\nCREATE TABLE t1(a INT);\nINSERT INTO t1 VALUES (1), (2), (3);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE c CURSOR FOR SELECT a FROM t1;\n\n  OPEN c;\n  \n  BEGIN\n    DECLARE v1 INT;\n    DECLARE v2 INT;\n\n    DECLARE EXIT HANDLER FOR SQLEXCEPTION\n      SELECT \"Error caught (expected)\";\n\n    DECLARE EXIT HANDLER FOR NOT FOUND\n      SELECT \"End of Result Set found!\";\n\n    WHILE TRUE DO\n      FETCH c INTO v1, v2;\n    END WHILE;\n  END;\n\n  CLOSE c;\n\n  SELECT a INTO @foo FROM t1 LIMIT 1; # Clear warning stack\nEND|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP PROCEDURE p1;\nDROP TABLE t1;\n\n--echo #\n--echo # Bug#36185: Incorrect precedence for warning and exception handlers\n--echo #\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n\nCREATE TABLE t1 (a INT, b INT NOT NULL);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'warning';\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'exception';\n  INSERT INTO t1 VALUES (CAST('10 ' AS SIGNED), NULL);\nEND|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP TABLE t1;\nDROP PROCEDURE p1;\n\n--echo #\n--echo # Bug#5889: Exit handler for a warning doesn't hide the warning in trigger\n--echo #\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\nCREATE TABLE t1(a INT, b INT);\nINSERT INTO t1 VALUES (1, 2);\n\ndelimiter |;\n\nCREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROW\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING\n    SET NEW.a = 10;\n\n  SET NEW.a = 99999999999;\nEND|\n\ndelimiter ;|\n\nUPDATE t1 SET b = 20;\n\nSHOW WARNINGS;\n\nSELECT * FROM t1;\n\nDROP TRIGGER t1_bu;\nDROP TABLE t1;\nSET sql_mode = default;\n--echo #\n--echo # Bug#9857: Stored procedures: handler for sqlwarning ignored\n--echo #\n\nCREATE TABLE t1(a INT PRIMARY KEY);\nINSERT INTO t1 VALUES(1);\nSET @sql_mode_saved = @@sql_mode;\nSET sql_mode = traditional;\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'warning caught (expected)';\n  \n  INSERT IGNORE INTO t1 VALUES (1);\nEND|\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'error caught (unexpected)';\n  \n  INSERT IGNORE INTO t1 VALUES (1);\nEND|\n\ndelimiter ;|\n\nCALL p1();\nSHOW WARNINGS;\n\nCALL p2();\nSHOW WARNINGS;\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP TABLE t1;\nSET sql_mode = @sql_mode_saved;\n\n--echo #\n--echo # Bug#55850: Trigger warnings not cleared.\n--echo #\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP TABLE IF EXISTS t2;\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n\nCREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT,\n                d SMALLINT, e SMALLINT, f SMALLINT);\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\n  INSERT INTO t2(a, b, c) VALUES(99999, 99999, 99999);\n\nCREATE TRIGGER t1_ai AFTER INSERT ON t1 FOR EACH ROW\n  INSERT INTO t2(d, e, f) VALUES(99999, 99999, 99999);\n\nCREATE PROCEDURE p1()\n  INSERT INTO t1 VALUES(99999, 99999, 99999);\n\n# What happened before the patch was:\n#  - INSERT INTO t1 added 3 warnings about overflow in 'x', 'y' and 'z' columns;\n#  - t1_bi run and added 3 warnings about overflow in 'a', 'b' and 'c' columns;\n#  - t1_ai run and added 3 warnings about overflow in 'd', 'e' and 'f' columns;\n# => we had 9 warnings.\n#\n# Now what happens is:\n#  - INSERT INTO t1 adds 3 warnings about overflow in 'x', 'y' and 'z' columns;\n#  - t1_bi adds 3 warnings about overflow in 'a', 'b' and 'c' columns;\n#  - The warnings added by triggers are cleared;\n#  - t1_ai run and added 3 warnings about overflow in 'd', 'e' and 'f' columns;\n#  - The warnings added by triggers are cleared;\n# => we have 3 warnings.\n\n--echo\nCALL p1();\n\n--echo\nSHOW WARNINGS;\n\n--echo\nDROP TABLE t1;\nDROP TABLE t2;\nDROP PROCEDURE p1;\n\n--echo # ----------------------------------------------------------------------\n\nCREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT NOT NULL);\n\ndelimiter |;\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\nBEGIN\n  INSERT INTO t2 VALUES(\n    CAST('111111 ' AS SIGNED),\n    CAST('222222 ' AS SIGNED),\n    NULL);\nEND|\n\ndelimiter ;|\n\nCREATE PROCEDURE p1()\n  INSERT INTO t1 VALUES(99999, 99999, 99999);\n\n--echo\n--error ER_BAD_NULL_ERROR\nCALL p1();\n\n--echo\nSHOW WARNINGS;\n\n--echo\nDROP TABLE t1;\nDROP TABLE t2;\nDROP PROCEDURE p1;\nSET sql_mode = default;\n--echo\n--echo ###################################################################\n--echo # Tests for the following bugs:\n--echo #   - Bug#11763171: 55852 - Possibly inappropriate handler activation.\n--echo #   - Bug#11749343: 38806 - Wrong scope for SQL HANDLERS in SP.\n--echo ###################################################################\n--echo\n\n#\n# Structure of SQL-block:\n# BEGIN\n#   <Handler declaration block>\n#   <Statement block>\n# END\n#\n# Scope of Handler-decl-block is Statement-block.\n# I.e. SQL-conditions thrown in the Handler-decl-block can not be handled by\n# the same block, only by outer SQL-blocks.\n#\n# This rule is recursive, i.e. if a Handler-decl-block has nested SQL-blocks,\n# the SQL-conditions from those nested blocks can not be handled by the this\n# Handler-decl-block, only by outer SQL-blocks.\n#\n\ndelimiter |;\n\n--echo\n--echo # -- Check that SQL-conditions thrown by Statement-blocks are\n--echo # -- handled by Handler-decl blocks properly.\n--echo\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  SIGNAL SQLSTATE '01000'; # Should be handled by H2.\nEND|\n\n--echo\nCALL p1()|\n\n--echo\n--echo # -- Check that SQL-conditions thrown by Statement-blocks are\n--echo # -- handled by Handler-decl blocks properly in case of nested\n--echo # -- SQL-blocks.\n--echo\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n\n    SELECT 'B1' AS BlockId;\n    BEGIN\n\n      SELECT 'B2' AS BlockId;\n      BEGIN\n        SELECT 'B3' AS BlockId;\n        SIGNAL SQLSTATE '01000'; # Should be handled by H2.\n      END;\n\n    END;\n\n  END;\n\nEND|\n\n--echo\nCALL p2()|\n\n--echo\n--echo # -- Check SQL-handler resolution rules.\n--echo\n\nCREATE PROCEDURE p3()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H3' AS HandlerId;\n\n  SIGNAL SQLSTATE '01000'; # Should be handled by H3.\nEND|\n\n--echo\nCALL p3()|\n--echo\n\nCREATE PROCEDURE p4()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H2' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H3' AS HandlerId;\n\n  SIGNAL SQLSTATE '01000'; # Should be handled by H2.\nEND|\n\n--echo\nCALL p4()|\n--echo\n\nCREATE PROCEDURE p5()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n      SELECT 'H3' AS HandlerId;\n\n    SIGNAL SQLSTATE '01000'; # Should be handled by H3.\n  END;\nEND|\n\n--echo\nCALL p5()|\n\n--echo\n--echo # -- Check that handlers don't handle its own exceptions.\n--echo\n\nCREATE PROCEDURE p6()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SELECT 'H1' AS HandlerId;\n    SIGNAL SQLSTATE 'HY000'; # Should *not* be handled by H1.\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # Should be handled by H1.\nEND|\n\n--echo\n--error ER_SIGNAL_EXCEPTION\nCALL p6()|\n\n--echo\n--echo # -- Check that handlers don't handle its own warnings.\n--echo\n\nCREATE PROCEDURE p7()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    SELECT 'H1' AS HandlerId;\n    SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1.\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE '01000'; # Should be handled by H1.\nEND|\n\n--echo\nCALL p7()|\n\n--echo\n--echo # -- Check that conditions for handlers are not handled by the handlers\n--echo # -- from the same block.\n--echo\n\nCREATE PROCEDURE p8()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SELECT 'H2' AS HandlerId;\n    SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1.\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # Should be handled by H2.\nEND|\n\n--echo\nCALL p8()|\n\n--echo\n--echo # -- Check that conditions for handlers are not handled by the handlers\n--echo # -- from the same block even if they are thrown deep down the stack.\n--echo\n\nCREATE PROCEDURE p9()\nBEGIN\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'Wrong:H1:1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'Wrong:H1:2' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n      SELECT 'Wrong:H2:1' AS HandlerId;\n\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n      SELECT 'Wrong:H2:2' AS HandlerId;\n\n    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    BEGIN\n\n      DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n        SELECT 'Wrong:H3:1' AS HandlerId;\n\n      DECLARE CONTINUE HANDLER FOR SQLWARNING\n        SELECT 'Wrong:H3:2' AS HandlerId;\n\n      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n      BEGIN\n\n        DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n          SELECT 'Wrong:H4:1' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          SELECT 'Wrong:H4:2' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n        BEGIN\n\n          DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n            SELECT 'Wrong:H5:1' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLWARNING\n            SELECT 'Wrong:H5:2' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n          BEGIN\n\n            DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n              SELECT 'Wrong:H6:1' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLWARNING\n              SELECT 'Wrong:H6:2' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n            BEGIN\n              SELECT 'H2' AS HandlerId;\n              SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1.\n            END;\n\n            SELECT 'S6' AS SignalId;\n            SIGNAL SQLSTATE 'HY000';\n          END;\n\n          SELECT 'S5' AS SignalId;\n          SIGNAL SQLSTATE 'HY000';\n\n        END;\n\n        SELECT 'S4' AS SignalId;\n        SIGNAL SQLSTATE 'HY000';\n\n      END;\n\n      SELECT 'S3' AS SignalId;\n      SIGNAL SQLSTATE 'HY000';\n\n    END;\n\n    SELECT 'S2' AS SignalId;\n    SIGNAL SQLSTATE 'HY000';\n\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # Should be handled by H2.\n\nEND|\n\n--echo\nCALL p9()|\n\n--echo\n--echo # -- Check that handlers are choosen properly in case of deep stack and\n--echo # -- nested SQL-blocks.\n--echo\n\nCREATE PROCEDURE p10()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n    BEGIN\n      BEGIN\n\n        DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n          SELECT 'Wrong:H1:1' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          SELECT 'Wrong:H1:2' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n        BEGIN\n\n          DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n            SELECT 'Wrong:H2:1' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLWARNING\n            SELECT 'Wrong:H2:2' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n          BEGIN\n\n            DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n              SELECT 'Wrong:H3:1' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLWARNING\n              SELECT 'Wrong:H3:2' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n            BEGIN\n\n              DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n                SELECT 'Wrong:H4:1' AS HandlerId;\n\n              DECLARE CONTINUE HANDLER FOR SQLWARNING\n                SELECT 'Wrong:H4:2' AS HandlerId;\n\n              DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n              BEGIN\n\n                DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n                  SELECT 'Wrong:H5:1' AS HandlerId;\n\n                DECLARE CONTINUE HANDLER FOR SQLWARNING\n                  SELECT 'Wrong:H5:2' AS HandlerId;\n\n                DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n                BEGIN\n\n                  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n                    SELECT 'Wrong:H6:1' AS HandlerId;\n\n                  DECLARE CONTINUE HANDLER FOR SQLWARNING\n                    SELECT 'Wrong:H6:2' AS HandlerId;\n\n                  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n                  BEGIN\n                    SELECT 'H2' AS HandlerId;\n                    SIGNAL SQLSTATE '01000'; # Should be handled by H1.\n                  END;\n\n                  SELECT 'S6' AS SignalId;\n                  SIGNAL SQLSTATE 'HY000';\n                END;\n\n                SELECT 'S5' AS SignalId;\n                SIGNAL SQLSTATE 'HY000';\n\n              END;\n\n              SELECT 'S4' AS SignalId;\n              SIGNAL SQLSTATE 'HY000';\n\n            END;\n\n            SELECT 'S3' AS SignalId;\n            SIGNAL SQLSTATE 'HY000';\n\n          END;\n\n          SELECT 'S2' AS SignalId;\n          SIGNAL SQLSTATE 'HY000';\n\n        END;\n\n        SELECT 'S1' AS SignalId;\n        SIGNAL SQLSTATE 'HY000'; # Should be handled by H2.\n\n      END;\n    END;\n  END;\nEND|\n\n--echo\nCALL p10()|\n\n--echo\n--echo # -- Test stored procedure from Peter's mail.\n--echo\n\nCREATE PROCEDURE p11()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '01000', 1249\n    BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n        SELECT 'H3' AS HandlerId;\n\n      DECLARE CONTINUE HANDLER FOR SQLWARNING\n        SELECT 'H4' AS HandlerId;\n\n      BEGIN\n        SELECT 'H5' AS HandlerId;\n\n        SELECT 'S3' AS SignalId;\n        SIGNAL SQLSTATE 'HY000'; # H3\n\n        SELECT 'S4' AS SignalId;\n        SIGNAL SQLSTATE '22003'; # H3\n\n        SELECT 'S5' AS SignalId;\n        SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H4\n      END;\n    END;\n\n    SELECT 'S6' AS SignalId;\n    SIGNAL SQLSTATE 'HY000'; # H1\n\n    SELECT 'S7' AS SignalId;\n    SIGNAL SQLSTATE '22003'; # H1\n\n    SELECT 'S8' AS SignalId;\n    SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H5\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # H1\n\n  SELECT 'S2' AS SignalId;\n  SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H2\nEND|\n\n--echo\nCALL p11()|\n\n--echo\n--echo # -- Check that runtime stack-trace can be deeper than parsing-time one.\n--echo\n\nCREATE PROCEDURE p12()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n    BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n        BEGIN\n          DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n          BEGIN\n            SELECT 'H1:5' AS HandlerId;\n            SIGNAL SQLSTATE '01002';\n          END;\n          SELECT 'H1:4' AS HandlerId;\n          SIGNAL SQLSTATE '01001';\n        END;\n        SELECT 'H1:3' AS HandlerId;\n        SIGNAL SQLSTATE '01001';\n      END;\n      SELECT 'H1:2' AS HandlerId;\n      SIGNAL SQLSTATE '01001';\n    END;\n    SELECT 'H1:1' AS HandlerId;\n    SIGNAL SQLSTATE '01001';\n  END;\n\n  #########################################################\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01002'\n    SELECT 'OK' AS Msg;\n\n  #########################################################\n\n  BEGIN\n\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLWARNING\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n        BEGIN\n          DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            DECLARE CONTINUE HANDLER FOR SQLWARNING\n            BEGIN\n              SELECT 'H2:5' AS HandlerId;\n              SIGNAL SQLSTATE '01001';\n            END;\n            SELECT 'H2:4' AS HandlerId;\n            SIGNAL SQLSTATE '01000';\n          END;\n          SELECT 'H2:3' AS HandlerId;\n          SIGNAL SQLSTATE '01000';\n        END;\n        SELECT 'H2:2' AS HandlerId;\n        SIGNAL SQLSTATE '01000';\n      END;\n      SELECT 'H2:1' AS HandlerId;\n      SIGNAL SQLSTATE '01000';\n    END;\n\n    #######################################################\n\n    SELECT 'Throw 01000' AS Msg;\n    SIGNAL SQLSTATE '01000';\n  END;\n\nEND|\n\n--echo\nCALL p12()|\n\n--echo\n--echo # -- Check that handler-call-frames are removed properly for EXIT\n--echo # -- handlers.\n--echo\n\nCREATE PROCEDURE p13()\nBEGIN\n  \n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      DECLARE EXIT HANDLER FOR SQLWARNING\n      BEGIN\n        SELECT 'EXIT handler 3' AS Msg;\n      END;\n\n      SELECT 'CONTINUE handler 2: 1' AS Msg;\n      SIGNAL SQLSTATE '01000';\n      SELECT 'CONTINUE handler 2: 2' AS Msg;\n    END;\n\n    SELECT 'CONTINUE handler 1: 1' AS Msg;\n    SIGNAL SQLSTATE '01000';\n    SELECT 'CONTINUE handler 1: 2' AS Msg;\n  END;\n\n  SELECT 'Throw 01000' AS Msg;\n  SIGNAL SQLSTATE '01000';\nEND|\n\n--echo\nCALL p13()|\n\ndelimiter ;|\n\n--echo\n--echo # That's it. Cleanup.\n--echo\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\nDROP PROCEDURE p7;\nDROP PROCEDURE p8;\nDROP PROCEDURE p9;\nDROP PROCEDURE p10;\nDROP PROCEDURE p11;\nDROP PROCEDURE p12;\nDROP PROCEDURE p13;\n\n--echo\n--echo # Bug#12731619: NESTED SP HANDLERS CAN TRIGGER ASSERTION\n--echo\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\n--disable_warnings\nDROP FUNCTION IF EXISTS f1;\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\nCREATE TABLE t1(msg VARCHAR(255));\n\ndelimiter |;\nCREATE FUNCTION f1() RETURNS INT\nBEGIN\n\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION               # handler 1\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION             # handler 2\n    BEGIN\n      INSERT INTO t1 VALUE('WRONG: Inside H2');\n      RETURN 2;\n    END;\n\n    INSERT INTO t1 VALUE('CORRECT: Inside H1');\n    RETURN 1;\n  END;\n\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLWARNING               # handler 3\n    BEGIN\n      INSERT INTO t1 VALUE('WRONG: Inside H3');\n      RETURN 3;\n    END;\n\n    INSERT INTO t1 VALUE('CORRECT: Calling f1()');\n    RETURN f1(); # -- exception here\n  END;\n\n  INSERT INTO t1 VALUE('WRONG: Returning 10');\n  RETURN 10;\n\nEND|\n\ndelimiter ;|\n\n--echo\nSELECT f1();\n--echo\nSELECT * FROM t1;\n--echo\n\nDROP FUNCTION f1;\nDROP TABLE t1;\n\n\n--echo\n--echo # Check that handled SQL-conditions are properly cleared from DA.\n--echo\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP TABLE IF EXISTS t2;\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\nDROP PROCEDURE IF EXISTS p3;\nDROP PROCEDURE IF EXISTS p4;\nDROP PROCEDURE IF EXISTS p5;\n--enable_warnings\n\nCREATE TABLE t1(a CHAR, b CHAR, c CHAR);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT);\n\ndelimiter |;\n\n--echo\n--echo # Check that SQL-conditions for which SQL-handler has been invoked,\n--echo # are cleared from the Diagnostics Area. Note, there might be several\n--echo # SQL-conditions, but SQL-handler must be invoked only once.\n--echo\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING\n    SELECT 'Warning caught' AS msg;\n\n  # The INSERT below raises 3 SQL-conditions (warnings). The EXIT HANDLER\n  # above must be invoked once (for one condition), but all three conditions\n  # must be cleared from the Diagnostics Area.\n\n  INSERT INTO t1 VALUES('qqqq', 'ww', 'eee');\n\n  # The following INSERT will not be executed, because of the EXIT HANDLER.\n\n  INSERT INTO t1 VALUES('zzz', 'xx', 'yyyy');\nEND|\n\n--echo\nCALL p1()|\n--echo\nSELECT * FROM t1|\n\n--echo\n--echo # Check that SQL-conditions for which SQL-handler has *not* been\n--echo # invoked, are *still* cleared from the Diagnostics Area.\n--echo\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n    SELECT 'Warning 1292 caught' AS msg;\n\n  # The following INSERT raises 6 SQL-warnings with code 1292,\n  # and 3 SQL-warnings with code 1264. The CONTINUE HANDLER above must be\n  # invoked once, and all nine SQL-warnings must be cleared from\n  # the Diagnostics Area.\n\n  INSERT INTO t2\n  SELECT\n    CAST(CONCAT(CAST('1 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p2()|\n\n--echo\n--echo # Check that if there are two equally ranked SQL-handlers to handle\n--echo # SQL-conditions from SQL-statement, only one of them will be invoked.\n--echo\n\nCREATE PROCEDURE p3()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n    SELECT 'Warning 1292 caught' AS msg;\n\n  DECLARE CONTINUE HANDLER FOR 1264\n    SELECT 'Warning 1264 caught' AS msg;\n\n  # The following INSERT raises 6 SQL-warnings with code 1292,\n  # and 3 SQL-warnings with code 1264. Only one of the CONTINUE HANDLERs above\n  # must be called, and only once. The SQL Standard does not define, which one\n  # should be invoked.\n\n  INSERT INTO t2\n  SELECT\n    CAST(CONCAT(CAST('1 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p3()|\n\n--echo\n--echo # The same as p3, but 1264 comes first.\n--echo\n\nCREATE PROCEDURE p4()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n    SELECT 'Warning 1292 caught' AS msg;\n\n  DECLARE CONTINUE HANDLER FOR 1264\n    SELECT 'Warning 1264 caught' AS msg;\n\n  # The following INSERT raises 4 SQL-warnings with code 1292,\n  # and 3 SQL-warnings with code 1264. Only one of the CONTINUE HANDLERs above\n  # must be called, and only once. The SQL Standard does not define, which one\n  # should be invoked.\n\n  INSERT INTO t2\n  SELECT\n    CAST(999999 AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p4()|\n\n--echo\n--echo # Check that if a SQL-handler raised its own SQL-conditions, there are\n--echo # preserved after handler exit.\n--echo\n\nCREATE PROCEDURE p5()\nBEGIN\n  DECLARE EXIT HANDLER FOR 1292\n  BEGIN\n    SELECT 'Handler for 1292' AS Msg;\n    SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1234;\n    SHOW WARNINGS;\n  END;\n\n  INSERT INTO t2\n  SELECT\n    CAST(999999 AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p5()|\n\n--echo\n--echo # Check that SQL-conditions are available inside the handler, but\n--echo # cleared after the handler exits.\n--echo\n\nCREATE PROCEDURE p6()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n  BEGIN\n    SHOW WARNINGS;\n    SELECT 'Handler for 1292' Msg;\n  END;\n\n  INSERT INTO t2\n  SELECT\n    CAST(CONCAT(CAST('1 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p6()|\n\ndelimiter ;|\n\n--echo\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\nDROP TABLE t1;\nDROP TABLE t2;\nSET sql_mode = default;\n--echo\n--echo # Bug#13059316: ASSERTION FAILURE IN SP_RCONTEXT.CC \n--echo # Check DECLARE statements that raise conditions before handlers\n--echo # are declared.\n--echo\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\n--enable_warnings\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE var1 INTEGER DEFAULT 'string';\n  DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H1';\nEND|\n\n--echo\nCALL p1()|\n--echo\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H2';\n  CALL p1();\nEND|\n\n--echo\nCALL p2()|\n\ndelimiter ;|\n\n--echo\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nSET sql_mode = default;\n\n--echo #\n--echo # Bug#13113222 RQG_SIGNAL_RESIGNAL FAILED WITH ASSERTION.\n--echo #\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\n--enable_warnings\n\ndelimiter |;\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'triggered p1';\n  # This will trigger an error.\n  SIGNAL SQLSTATE 'HY000';\nEND|\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'triggered p2';\n  # This will trigger a warning.\n  SIGNAL SQLSTATE '01000';\nEND|\ndelimiter ;|\n\nSET @old_max_error_count=  @@session.max_error_count;\nSET SESSION max_error_count= 0;\nCALL p1();\nCALL p2();\nSET SESSION max_error_count= @old_max_error_count;\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\n\n--echo\n--echo # Bug#12652873: 61392: Continue handler for NOT FOUND being triggered\n--echo # from internal stored function.\n--echo\n\n--disable_warnings\nDROP FUNCTION IF EXISTS f1;\nDROP FUNCTION IF EXISTS f2;\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\n--echo\n\nCREATE TABLE t1 (a INT, b INT);\nINSERT INTO t1 VALUES (1, 2);\n\ndelimiter |;\n\n--echo\n--echo # f1() raises NOT_FOUND condition.\n--echo # Raising NOT_FOUND can not be simulated by SIGNAL,\n--echo # because SIGNAL would raise SQL-error in that case.\n--echo\n\nCREATE FUNCTION f1() RETURNS INTEGER\nBEGIN\n  DECLARE v VARCHAR(5) DEFAULT -1;\n  SELECT b FROM t1 WHERE a = 2 INTO v;\n  RETURN v;\nEND|\n\n--echo\n--echo # Here we check that the NOT_FOUND condition raised in f1()\n--echo # is not visible in the outer function (f2), i.e. the continue\n--echo # handler in f2() will not be called.\n--echo\n\nCREATE FUNCTION f2() RETURNS INTEGER\nBEGIN\n  DECLARE v INTEGER;\n\n  DECLARE CONTINUE HANDLER FOR NOT FOUND\n    SET @msg = 'Handler activated.';\n\n  SELECT f1() INTO v;\n\n  RETURN v;\nEND|\n\ndelimiter ;|\n\nSET @msg = '';\n\n--echo\nSELECT f2();\n--echo\nSELECT @msg;\n--echo\n\nDROP FUNCTION f1;\nDROP FUNCTION f2;\nDROP TABLE t1;\n\n\n--echo #\n--echo # Bug #17903490 \"ASSERT FAILURE IN MDL.H WHEN DROP FUNCTION CALLED\n--echo #                WITH INVALID FUNCTION NAME\".\n--echo #\n--error ER_TOO_LONG_IDENT\ndrop function f111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkk;\n--error ER_TOO_LONG_IDENT\ndrop function test.f111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkk;\n--error ER_WRONG_DB_NAME \ndrop function mysqltest111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjj.test;\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/sql/mysqld.cc": "/* Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#include \"mysqld.h\"\n#include \"mysqld_daemon.h\"\n\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <list>\n#include <set>\n#include <string>\n\n#include <fenv.h>\n#include <signal.h>\n#ifdef HAVE_SYS_WAIT_H\n#include <sys/wait.h>\n#endif\n#ifdef HAVE_PWD_H\n#include <pwd.h>\n#endif\n#ifdef HAVE_GRP_H\n#include <grp.h>\n#endif\n#ifdef HAVE_SYS_RESOURCE_H\n#include <sys/resource.h>\n#endif\n#ifdef _WIN32\n#include <crtdbg.h>\n#endif\n\n#include \"sql_parse.h\"    // test_if_data_home_dir\n#include \"sql_cache.h\"    // query_cache, query_cache_*\n#include \"sql_locale.h\"   // MY_LOCALES, my_locales, my_locale_by_name\n#include \"sql_show.h\"     // free_status_vars, add_status_vars,\n                          // reset_status_vars\n#include \"strfunc.h\"      // find_set_from_flags\n#include \"parse_file.h\"   // File_parser_dummy_hook\n#include \"sql_db.h\"       // my_dboptions_cache_free\n                          // my_dboptions_cache_init\n#include \"sql_table.h\"    // release_ddl_log, execute_ddl_log_recovery\n#include \"sql_connect.h\"  // free_max_user_conn, init_max_user_conn,\n                          // handle_one_connection\n#include \"sql_time.h\"     // known_date_time_formats,\n                          // get_date_time_format_str\n#include \"tztime.h\"       // my_tz_free, my_tz_init, my_tz_SYSTEM\n#include \"hostname.h\"     // hostname_cache_free, hostname_cache_init\n#include \"auth_common.h\"  // set_default_auth_plugin\n                          // acl_free, acl_init\n                          // grant_free, grant_init\n#include \"sql_base.h\"     // table_def_free, table_def_init,\n                          // Table_cache,\n                          // cached_table_definitions\n#include \"sql_test.h\"     // mysql_print_status\n#include \"item_create.h\"  // item_create_cleanup, item_create_init\n#include \"sql_servers.h\"  // servers_free, servers_init\n#include \"init.h\"         // unireg_init\n#include \"derror.h\"       // init_errmessage\n#include \"des_key_file.h\" // load_des_key_file\n#include \"sql_manager.h\"  // stop_handle_manager, start_handle_manager\n#include \"bootstrap.h\"    // bootstrap\n#include <m_ctype.h>\n#include <my_dir.h>\n#include <my_bit.h>\n#include \"rpl_gtid.h\"\n#include \"rpl_gtid_persist.h\"\n#include \"rpl_slave.h\"\n#include \"rpl_msr.h\"\n#include \"rpl_master.h\"\n#include \"rpl_mi.h\"\n#include \"rpl_filter.h\"\n#include <sql_common.h>\n#include <my_stacktrace.h>\n#include \"mysqld_suffix.h\"\n#include \"mysys_err.h\"\n#include \"events.h\"\n#include \"sql_audit.h\"\n#include \"probes_mysql.h\"\n#include \"debug_sync.h\"\n#include \"sql_callback.h\"\n#include \"opt_trace_context.h\"\n#include \"opt_costconstantcache.h\"\n#include \"sql_plugin.h\"                         // plugin_shutdown\n#include \"sql_initialize.h\"\n#include \"log_event.h\"\n#include \"log.h\"\n#include \"binlog.h\"\n#include \"rpl_rli.h\"     // Relay_log_info\n#include \"replication.h\" // thd_enter_cond\n\n#include \"my_default.h\"\n#include \"mysql_version.h\"\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"../storage/perfschema/pfs_server.h\"\n#include <pfs_idle_provider.h>\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#include \"pfs_file_provider.h\"\n#include \"mysql/psi/mysql_file.h\"\n\n#include <mysql/psi/mysql_idle.h>\n#include <mysql/psi/mysql_socket.h>\n#include <mysql/psi/mysql_memory.h>\n#include <mysql/psi/mysql_statement.h>\n\n#include \"migrate_keyring.h\"            // Migrate_keyring\n#include \"mysql_com_server.h\"\n#include \"keycaches.h\"\n#include \"../storage/myisam/ha_myisam.h\"\n#include \"set_var.h\"\n#include \"sys_vars_shared.h\"\n#include \"rpl_injector.h\"\n#include \"rpl_handler.h\"\n#include <ft_global.h>\n#include <errmsg.h>\n#include \"sp_rcontext.h\"\n#include \"sql_reload.h\"  // reload_acl_and_cache\n#include \"sp_head.h\"  // init_sp_psi_keys\n#include \"event_data_objects.h\" //init_scheduler_psi_keys\n#include \"my_timer.h\"    // my_timer_init, my_timer_deinit\n#include \"table_cache.h\"                // table_cache_manager\n#include \"connection_acceptor.h\"        // Connection_acceptor\n#include \"connection_handler_impl.h\"    // *_connection_handler\n#include \"connection_handler_manager.h\" // Connection_handler_manager\n#include \"socket_connection.h\"          // Mysqld_socket_listener\n#include \"mysqld_thd_manager.h\"         // Global_THD_manager\n#include \"my_getopt.h\"\n#include \"partitioning/partition_handler.h\" // partitioning_init\n#include \"item_cmpfunc.h\"               // arg_cmp_func\n#include \"item_strfunc.h\"               // Item_func_uuid\n#include \"handler.h\"\n\n#ifndef EMBEDDED_LIBRARY\n#include \"srv_session.h\"\n#endif\n\n#ifdef _WIN32\n#include \"named_pipe.h\"\n#include \"named_pipe_connection.h\"\n#include \"shared_memory_connection.h\"\n#endif\n\nusing std::min;\nusing std::max;\nusing std::vector;\n\n#define mysqld_charset &my_charset_latin1\n\n#if defined(HAVE_SOLARIS_LARGE_PAGES) && defined(__GNUC__)\nextern \"C\" int getpagesizes(size_t *, int);\nextern \"C\" int memcntl(caddr_t, size_t, int, caddr_t, int, int);\n#endif\n\n#ifdef HAVE_FPU_CONTROL_H\n# include <fpu_control.h>\n#elif defined(__i386__)\n# define fpu_control_t unsigned int\n# define _FPU_EXTENDED 0x300\n# define _FPU_DOUBLE 0x200\n# if defined(__GNUC__) || defined(__SUNPRO_CC)\n#  define _FPU_GETCW(cw) asm volatile (\"fnstcw %0\" : \"=m\" (*&cw))\n#  define _FPU_SETCW(cw) asm volatile (\"fldcw %0\" : : \"m\" (*&cw))\n# else\n#  define _FPU_GETCW(cw) (cw= 0)\n#  define _FPU_SETCW(cw)\n# endif\n#endif\n\ninline void setup_fpu()\n{\n#ifdef HAVE_FEDISABLEEXCEPT\n  fedisableexcept(FE_ALL_EXCEPT);\n#endif\n\n  /* Set FPU rounding mode to \"round-to-nearest\" */\n  fesetround(FE_TONEAREST);\n\n  /*\n    x86 (32-bit) requires FPU precision to be explicitly set to 64 bit\n    (double precision) for portable results of floating point operations.\n    However, there is no need to do so if compiler is using SSE2 for floating\n    point, double values will be stored and processed in 64 bits anyway.\n  */\n#if defined(__i386__) && !defined(__SSE2_MATH__)\n#if defined(_WIN32)\n#if !defined(_WIN64)\n  _control87(_PC_53, MCW_PC);\n#endif /* !_WIN64 */\n#else /* !_WIN32 */\n  fpu_control_t cw;\n  _FPU_GETCW(cw);\n  cw= (cw & ~_FPU_EXTENDED) | _FPU_DOUBLE;\n  _FPU_SETCW(cw);\n#endif /* _WIN32 && */\n#endif /* __i386__ */\n\n}\n\n#ifndef EMBEDDED_LIBRARY\nextern \"C\" void handle_fatal_signal(int sig);\n#endif\n\n/* Constants */\n\n#include <welcome_copyright_notice.h> // ORACLE_WELCOME_COPYRIGHT_NOTICE\n\nconst char *show_comp_option_name[]= {\"YES\", \"NO\", \"DISABLED\"};\n\nstatic const char *tc_heuristic_recover_names[]=\n{\n  \"OFF\", \"COMMIT\", \"ROLLBACK\", NullS\n};\nstatic TYPELIB tc_heuristic_recover_typelib=\n{\n  array_elements(tc_heuristic_recover_names)-1,\"\",\n  tc_heuristic_recover_names, NULL\n};\n\nconst char *first_keyword= \"first\", *binary_keyword= \"BINARY\";\nconst char *my_localhost= \"localhost\";\n\nbool opt_large_files= sizeof(my_off_t) > 4;\nstatic my_bool opt_autocommit; ///< for --autocommit command-line option\n\n/*\n  Used with --help for detailed option\n*/\nmy_bool opt_help= 0, opt_verbose= 0;\n\narg_cmp_func Arg_comparator::comparator_matrix[5][2] =\n{{&Arg_comparator::compare_string,     &Arg_comparator::compare_e_string},\n {&Arg_comparator::compare_real,       &Arg_comparator::compare_e_real},\n {&Arg_comparator::compare_int_signed, &Arg_comparator::compare_e_int},\n {&Arg_comparator::compare_row,        &Arg_comparator::compare_e_row},\n {&Arg_comparator::compare_decimal,    &Arg_comparator::compare_e_decimal}};\n\n#ifdef HAVE_PSI_INTERFACE\n#ifndef EMBEDDED_LIBRARY\n#if defined(_WIN32)\nstatic PSI_thread_key key_thread_handle_con_namedpipes;\nstatic PSI_thread_key key_thread_handle_con_sharedmem;\nstatic PSI_thread_key key_thread_handle_con_sockets;\nstatic PSI_mutex_key key_LOCK_handler_count;\nstatic PSI_cond_key key_COND_handler_count;\nstatic PSI_thread_key key_thread_handle_shutdown;\n#else\nstatic PSI_mutex_key key_LOCK_socket_listener_active;\nstatic PSI_cond_key key_COND_socket_listener_active;\nstatic PSI_mutex_key key_LOCK_start_signal_handler;\nstatic PSI_cond_key key_COND_start_signal_handler;\n#endif // _WIN32\n#endif // !EMBEDDED_LIBRARY\n#endif /* HAVE_PSI_INTERFACE */\n\n/**\n  Statement instrumentation key for replication.\n*/\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\nPSI_statement_info stmt_info_rpl;\n#endif\n\n/* the default log output is log tables */\nstatic bool lower_case_table_names_used= 0;\n#if !defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\nstatic bool socket_listener_active= false;\nstatic int pipe_write_fd= -1;\nstatic my_bool opt_daemonize= 0;\n#endif\nstatic my_bool opt_debugging= 0, opt_external_locking= 0, opt_console= 0;\nstatic my_bool opt_short_log_format= 0;\nstatic char *mysqld_user, *mysqld_chroot;\nstatic char *default_character_set_name;\nstatic char *character_set_filesystem_name;\nstatic char *lc_messages;\nstatic char *lc_time_names_name;\nchar *my_bind_addr_str;\nstatic char *default_collation_name;\nchar *default_storage_engine;\nchar *default_tmp_storage_engine;\n/**\n   Use to mark which engine should be choosen to create internal\n   temp table\n */\nulong internal_tmp_disk_storage_engine;\nstatic char compiled_default_collation_name[]= MYSQL_DEFAULT_COLLATION_NAME;\nstatic bool binlog_format_used= false;\n\nLEX_STRING opt_init_connect, opt_init_slave;\n\n/* Global variables */\n\nbool opt_bin_log, opt_ignore_builtin_innodb= 0;\nbool opt_general_log, opt_slow_log, opt_general_log_raw;\nulonglong log_output_options;\nmy_bool opt_log_queries_not_using_indexes= 0;\nulong opt_log_throttle_queries_not_using_indexes= 0;\nbool opt_disable_networking=0, opt_skip_show_db=0;\nbool opt_skip_name_resolve=0;\nmy_bool opt_character_set_client_handshake= 1;\nbool server_id_supplied = false;\nbool opt_endinfo, using_udf_functions;\nmy_bool locked_in_memory;\nbool opt_using_transactions;\nbool volatile abort_loop;\nulong opt_tc_log_size;\n\nstatic enum_server_operational_state server_operational_state= SERVER_BOOTING;\nulong log_warnings;\nbool  opt_log_syslog_enable;\nchar *opt_log_syslog_tag= NULL;\nchar *opt_keyring_migration_user= NULL;\nchar *opt_keyring_migration_host= NULL;\nchar *opt_keyring_migration_password= NULL;\nchar *opt_keyring_migration_socket= NULL;\nchar *opt_keyring_migration_source= NULL;\nchar *opt_keyring_migration_destination= NULL;\nulong opt_keyring_migration_port= 0;\nbool migrate_connect_options= 0;\n#ifndef _WIN32\nbool  opt_log_syslog_include_pid;\nchar *opt_log_syslog_facility;\n\n#else\n/*\n  Thread handle of shutdown event handler thread.\n  It is used as argument during thread join.\n*/\nmy_thread_handle shutdown_thr_handle;\n#endif\nuint host_cache_size;\nulong log_error_verbosity= 3; // have a non-zero value during early start-up\n\n#if MYSQL_VERSION_ID >= 50800\n#error \"show_compatibility_56 is to be removed in MySQL 5.8\"\n#else\n/*\n  Default value TRUE for the EMBEDDED_LIBRARY,\n  default value from Sys_show_compatibility_56 otherwise.\n*/\nmy_bool show_compatibility_56= TRUE;\n#endif /* MYSQL_VERSION_ID >= 50800 */\n\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\nulong slow_start_timeout;\n#endif\n\nmy_bool opt_bootstrap= 0;\nmy_bool opt_initialize= 0;\nmy_bool opt_disable_partition_check= TRUE;\nmy_bool opt_skip_slave_start = 0; ///< If set, slave is not autostarted\nmy_bool opt_reckless_slave = 0;\nmy_bool opt_enable_named_pipe= 0;\nmy_bool opt_local_infile, opt_slave_compressed_protocol;\nmy_bool opt_safe_user_create = 0;\nmy_bool opt_show_slave_auth_info;\nmy_bool opt_log_slave_updates= 0;\nchar *opt_slave_skip_errors;\nmy_bool opt_slave_allow_batching= 0;\n\n/**\n  compatibility option:\n    - index usage hints (USE INDEX without a FOR clause) behave as in 5.0\n*/\nmy_bool old_mode;\n\n/*\n  Legacy global handlerton. These will be removed (please do not add more).\n*/\nhandlerton *heap_hton;\nhandlerton *myisam_hton;\nhandlerton *innodb_hton;\n\nchar *opt_disabled_storage_engines;\nuint opt_server_id_bits= 0;\nulong opt_server_id_mask= 0;\nmy_bool read_only= 0, opt_readonly= 0;\nmy_bool super_read_only= 0, opt_super_readonly= 0;\nmy_bool opt_require_secure_transport= 0;\nmy_bool use_temp_pool, relay_log_purge;\nmy_bool relay_log_recovery;\nmy_bool opt_sync_frm, opt_allow_suspicious_udfs;\nmy_bool opt_secure_auth= 0;\nchar* opt_secure_file_priv;\nmy_bool opt_log_slow_admin_statements= 0;\nmy_bool opt_log_slow_slave_statements= 0;\nmy_bool lower_case_file_system= 0;\nmy_bool opt_large_pages= 0;\nmy_bool opt_super_large_pages= 0;\nmy_bool opt_myisam_use_mmap= 0;\nmy_bool offline_mode= 0;\nmy_bool opt_log_builtin_as_identified_by_password= 0;\nuint   opt_large_page_size= 0;\nuint default_password_lifetime= 0;\n\nmysql_mutex_t LOCK_default_password_lifetime;\n\n#if defined(ENABLED_DEBUG_SYNC)\nMYSQL_PLUGIN_IMPORT uint    opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\nmy_bool opt_old_style_user_limits= 0, trust_function_creators= 0;\nmy_bool check_proxy_users= 0, mysql_native_password_proxy_users= 0, sha256_password_proxy_users= 0;\n/*\n  True if there is at least one per-hour limit for some user, so we should\n  check them before each query (and possibly reset counters when hour is\n  changed). False otherwise.\n*/\nvolatile bool mqh_used = 0;\nmy_bool opt_noacl= 0;\nmy_bool sp_automatic_privileges= 1;\n\nulong opt_binlog_rows_event_max_size;\nconst char *binlog_checksum_default= \"NONE\";\nulong binlog_checksum_options;\nmy_bool opt_master_verify_checksum= 0;\nmy_bool opt_slave_sql_verify_checksum= 1;\nconst char *binlog_format_names[]= {\"MIXED\", \"STATEMENT\", \"ROW\", NullS};\nmy_bool binlog_gtid_simple_recovery;\nulong binlog_error_action;\nconst char *binlog_error_action_list[]= {\"IGNORE_ERROR\", \"ABORT_SERVER\", NullS};\nuint32 gtid_executed_compression_period= 0;\nmy_bool opt_log_unsafe_statements;\n\n#ifdef HAVE_INITGROUPS\nvolatile sig_atomic_t calling_initgroups= 0; /**< Used in SIGSEGV handler. */\n#endif\nconst char *timestamp_type_names[]= {\"UTC\", \"SYSTEM\", NullS};\nulong opt_log_timestamps;\nuint mysqld_port, test_flags, select_errors, dropping_tables, ha_open_options;\nuint mysqld_port_timeout;\nulong delay_key_write_options;\nuint protocol_version;\nuint lower_case_table_names;\nlong tc_heuristic_recover;\nulong back_log, connect_timeout, server_id;\nulong table_cache_size, table_def_size;\nulong table_cache_instances;\nulong table_cache_size_per_instance;\nulong what_to_log;\nulong slow_launch_time;\nAtomic_int32 slave_open_temp_tables;\nulong open_files_limit, max_binlog_size, max_relay_log_size;\nulong slave_trans_retries;\nuint  slave_net_timeout;\nulong slave_exec_mode_options;\nulonglong slave_type_conversions_options;\nulong opt_mts_slave_parallel_workers;\nulonglong opt_mts_pending_jobs_size_max;\nulonglong slave_rows_search_algorithms_options;\n\n#ifdef HAVE_REPLICATION\nmy_bool opt_slave_preserve_commit_order;\n#endif\n\n#ifndef DBUG_OFF\nuint slave_rows_last_search_algorithm_used;\n#endif\nulong mts_parallel_option;\nulong binlog_cache_size=0;\nulonglong  max_binlog_cache_size=0;\nulong slave_max_allowed_packet= 0;\nulong binlog_stmt_cache_size=0;\nint32 opt_binlog_max_flush_queue_time= 0;\nulong opt_binlog_group_commit_sync_delay= 0;\nulong opt_binlog_group_commit_sync_no_delay_count= 0;\nulonglong  max_binlog_stmt_cache_size=0;\nulong query_cache_size=0;\nulong refresh_version;  /* Increments on each reload */\nquery_id_t global_query_id;\nulong aborted_threads;\nulong delayed_insert_timeout, delayed_insert_limit, delayed_queue_size;\nulong delayed_insert_threads, delayed_insert_writes, delayed_rows_in_use;\nulong delayed_insert_errors,flush_time;\nulong specialflag=0;\nulong binlog_cache_use= 0, binlog_cache_disk_use= 0;\nulong binlog_stmt_cache_use= 0, binlog_stmt_cache_disk_use= 0;\nulong max_connections, max_connect_errors;\nulong rpl_stop_slave_timeout= LONG_TIMEOUT;\nmy_bool log_bin_use_v1_row_events= 0;\nbool thread_cache_size_specified= false;\nbool host_cache_size_specified= false;\nbool table_definition_cache_specified= false;\nulong locked_account_connection_count= 0;\nbool opt_keyring_operations= TRUE;\n\n/**\n  Limit of the total number of prepared statements in the server.\n  Is necessary to protect the server against out-of-memory attacks.\n*/\nulong max_prepared_stmt_count;\n/**\n  Current total number of prepared statements in the server. This number\n  is exact, and therefore may not be equal to the difference between\n  `com_stmt_prepare' and `com_stmt_close' (global status variables), as\n  the latter ones account for all registered attempts to prepare\n  a statement (including unsuccessful ones).  Prepared statements are\n  currently connection-local: if the same SQL query text is prepared in\n  two different connections, this counts as two distinct prepared\n  statements.\n*/\nulong prepared_stmt_count=0;\nulong current_pid;\nuint sync_binlog_period= 0, sync_relaylog_period= 0,\n     sync_relayloginfo_period= 0, sync_masterinfo_period= 0,\n     opt_mts_checkpoint_period, opt_mts_checkpoint_group;\nulong expire_logs_days = 0;\n/**\n  Soft upper limit for number of sp_head objects that can be stored\n  in the sp_cache for one connection.\n*/\nulong stored_program_cache_size= 0;\n/**\n  Compatibility option to prevent auto upgrade of old temporals\n  during certain ALTER TABLE operations.\n*/\nmy_bool avoid_temporal_upgrade;\n\nconst double log_10[] = {\n  1e000, 1e001, 1e002, 1e003, 1e004, 1e005, 1e006, 1e007, 1e008, 1e009,\n  1e010, 1e011, 1e012, 1e013, 1e014, 1e015, 1e016, 1e017, 1e018, 1e019,\n  1e020, 1e021, 1e022, 1e023, 1e024, 1e025, 1e026, 1e027, 1e028, 1e029,\n  1e030, 1e031, 1e032, 1e033, 1e034, 1e035, 1e036, 1e037, 1e038, 1e039,\n  1e040, 1e041, 1e042, 1e043, 1e044, 1e045, 1e046, 1e047, 1e048, 1e049,\n  1e050, 1e051, 1e052, 1e053, 1e054, 1e055, 1e056, 1e057, 1e058, 1e059,\n  1e060, 1e061, 1e062, 1e063, 1e064, 1e065, 1e066, 1e067, 1e068, 1e069,\n  1e070, 1e071, 1e072, 1e073, 1e074, 1e075, 1e076, 1e077, 1e078, 1e079,\n  1e080, 1e081, 1e082, 1e083, 1e084, 1e085, 1e086, 1e087, 1e088, 1e089,\n  1e090, 1e091, 1e092, 1e093, 1e094, 1e095, 1e096, 1e097, 1e098, 1e099,\n  1e100, 1e101, 1e102, 1e103, 1e104, 1e105, 1e106, 1e107, 1e108, 1e109,\n  1e110, 1e111, 1e112, 1e113, 1e114, 1e115, 1e116, 1e117, 1e118, 1e119,\n  1e120, 1e121, 1e122, 1e123, 1e124, 1e125, 1e126, 1e127, 1e128, 1e129,\n  1e130, 1e131, 1e132, 1e133, 1e134, 1e135, 1e136, 1e137, 1e138, 1e139,\n  1e140, 1e141, 1e142, 1e143, 1e144, 1e145, 1e146, 1e147, 1e148, 1e149,\n  1e150, 1e151, 1e152, 1e153, 1e154, 1e155, 1e156, 1e157, 1e158, 1e159,\n  1e160, 1e161, 1e162, 1e163, 1e164, 1e165, 1e166, 1e167, 1e168, 1e169,\n  1e170, 1e171, 1e172, 1e173, 1e174, 1e175, 1e176, 1e177, 1e178, 1e179,\n  1e180, 1e181, 1e182, 1e183, 1e184, 1e185, 1e186, 1e187, 1e188, 1e189,\n  1e190, 1e191, 1e192, 1e193, 1e194, 1e195, 1e196, 1e197, 1e198, 1e199,\n  1e200, 1e201, 1e202, 1e203, 1e204, 1e205, 1e206, 1e207, 1e208, 1e209,\n  1e210, 1e211, 1e212, 1e213, 1e214, 1e215, 1e216, 1e217, 1e218, 1e219,\n  1e220, 1e221, 1e222, 1e223, 1e224, 1e225, 1e226, 1e227, 1e228, 1e229,\n  1e230, 1e231, 1e232, 1e233, 1e234, 1e235, 1e236, 1e237, 1e238, 1e239,\n  1e240, 1e241, 1e242, 1e243, 1e244, 1e245, 1e246, 1e247, 1e248, 1e249,\n  1e250, 1e251, 1e252, 1e253, 1e254, 1e255, 1e256, 1e257, 1e258, 1e259,\n  1e260, 1e261, 1e262, 1e263, 1e264, 1e265, 1e266, 1e267, 1e268, 1e269,\n  1e270, 1e271, 1e272, 1e273, 1e274, 1e275, 1e276, 1e277, 1e278, 1e279,\n  1e280, 1e281, 1e282, 1e283, 1e284, 1e285, 1e286, 1e287, 1e288, 1e289,\n  1e290, 1e291, 1e292, 1e293, 1e294, 1e295, 1e296, 1e297, 1e298, 1e299,\n  1e300, 1e301, 1e302, 1e303, 1e304, 1e305, 1e306, 1e307, 1e308\n};\n\ntime_t server_start_time, flush_status_time;\n\nchar server_uuid[UUID_LENGTH+1];\nconst char *server_uuid_ptr;\nchar mysql_home[FN_REFLEN], pidfile_name[FN_REFLEN], system_time_zone[30];\nchar default_logfile_name[FN_REFLEN];\nchar *default_tz_name;\nstatic char errorlog_filename_buff[FN_REFLEN];\nconst char *log_error_dest;\nchar glob_hostname[FN_REFLEN];\nchar mysql_real_data_home[FN_REFLEN],\n     lc_messages_dir[FN_REFLEN], reg_ext[FN_EXTLEN],\n     mysql_charsets_dir[FN_REFLEN],\n     *opt_init_file, *opt_tc_log_file;\nchar *lc_messages_dir_ptr;\nchar mysql_unpacked_real_data_home[FN_REFLEN];\nsize_t mysql_unpacked_real_data_home_len;\nsize_t mysql_real_data_home_len, mysql_data_home_len= 1;\nuint reg_ext_length;\nconst key_map key_map_empty(0);\nkey_map key_map_full(0);                        // Will be initialized later\nchar logname_path[FN_REFLEN];\nchar slow_logname_path[FN_REFLEN];\nchar secure_file_real_path[FN_REFLEN];\n\nDate_time_format global_date_format, global_datetime_format, global_time_format;\nTime_zone *default_tz;\n\nchar *mysql_data_home= const_cast<char*>(\".\");\nconst char *mysql_real_data_home_ptr= mysql_real_data_home;\nchar server_version[SERVER_VERSION_LENGTH];\nchar *mysqld_unix_port, *opt_mysql_tmpdir;\n\n/** name of reference on left expression in rewritten IN subquery */\nconst char *in_left_expr_name= \"<left expr>\";\n/** name of additional condition */\nconst char *in_additional_cond= \"<IN COND>\";\nconst char *in_having_cond= \"<IN HAVING>\";\n\nmy_decimal decimal_zero;\n#ifndef EMBEDDED_LIBRARY\n/** Number of connection errors from internal server errors. */\nulong connection_errors_internal= 0;\n/** Number of errors when reading the peer address. */\nulong connection_errors_peer_addr= 0;\n#endif\n\n/* classes for comparation parsing/processing */\nEq_creator eq_creator;\nNe_creator ne_creator;\nEqual_creator equal_creator;\nGt_creator gt_creator;\nLt_creator lt_creator;\nGe_creator ge_creator;\nLe_creator le_creator;\n\nRpl_filter* rpl_filter;\nRpl_filter* binlog_filter;\n\nstruct system_variables global_system_variables;\nstruct system_variables max_system_variables;\nstruct system_status_var global_status_var;\n\nMY_TMPDIR mysql_tmpdir_list;\nMY_BITMAP temp_pool;\n\nCHARSET_INFO *system_charset_info, *files_charset_info ;\nCHARSET_INFO *national_charset_info, *table_alias_charset;\nCHARSET_INFO *character_set_filesystem;\nCHARSET_INFO *error_message_charset_info;\n\nMY_LOCALE *my_default_lc_messages;\nMY_LOCALE *my_default_lc_time_names;\n\nSHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen, have_query_cache;\nSHOW_COMP_OPTION have_geometry, have_rtree_keys;\nSHOW_COMP_OPTION have_crypt, have_compress;\nSHOW_COMP_OPTION have_profiling;\nSHOW_COMP_OPTION have_statement_timeout= SHOW_OPTION_DISABLED;\n\n/* Thread specific variables */\n\nthread_local_key_t THR_MALLOC;\nbool THR_MALLOC_initialized= false;\nthread_local_key_t THR_THD;\nbool THR_THD_initialized= false;\nmysql_mutex_t\n  LOCK_status, LOCK_uuid_generator,\n  LOCK_crypt,\n  LOCK_global_system_variables,\n  LOCK_user_conn, LOCK_slave_list,\n  LOCK_error_messages;\nmysql_mutex_t LOCK_sql_rand;\n\n/**\n  The below lock protects access to two global server variables:\n  max_prepared_stmt_count and prepared_stmt_count. These variables\n  set the limit and hold the current total number of prepared statements\n  in the server, respectively. As PREPARE/DEALLOCATE rate in a loaded\n  server may be fairly high, we need a dedicated lock.\n*/\nmysql_mutex_t LOCK_prepared_stmt_count;\n\n/*\n The below two locks are introudced as guards (second mutex) for\n  the global variables sql_slave_skip_counter and slave_net_timeout\n  respectively. See fix_slave_skip_counter/fix_slave_net_timeout\n  for more details\n*/\nmysql_mutex_t LOCK_sql_slave_skip_counter;\nmysql_mutex_t LOCK_slave_net_timeout;\nmysql_mutex_t LOCK_log_throttle_qni;\nmysql_mutex_t LOCK_offline_mode;\n#ifdef HAVE_OPENSSL\nmysql_mutex_t LOCK_des_key_file;\n#endif\nmysql_rwlock_t LOCK_sys_init_connect, LOCK_sys_init_slave;\nmysql_rwlock_t LOCK_system_variables_hash;\nmy_thread_handle signal_thread_id;\nmy_thread_attr_t connection_attrib;\nmysql_mutex_t LOCK_server_started;\nmysql_cond_t COND_server_started;\nmysql_mutex_t LOCK_reset_gtid_table;\nmysql_mutex_t LOCK_compress_gtid_table;\nmysql_cond_t COND_compress_gtid_table;\nmysql_mutex_t LOCK_group_replication_handler;\n#if !defined (EMBEDDED_LIBRARY) && !defined(_WIN32)\nmysql_mutex_t LOCK_socket_listener_active;\nmysql_cond_t COND_socket_listener_active;\nmysql_mutex_t LOCK_start_signal_handler;\nmysql_cond_t COND_start_signal_handler;\n#endif\n\nbool mysqld_server_started= false;\n\n/*\n  The below lock protects access to global server variable\n  keyring_operations.\n*/\nmysql_mutex_t LOCK_keyring_operations;\n\nFile_parser_dummy_hook file_parser_dummy_hook;\n\n/* replication parameters, if master_host is not NULL, we are a slave */\nuint report_port= 0;\nulong master_retry_count=0;\nchar *master_info_file;\nchar *relay_log_info_file, *report_user, *report_password, *report_host;\nchar *opt_relay_logname = 0, *opt_relaylog_index_name=0;\nchar *opt_general_logname, *opt_slow_logname, *opt_bin_logname;\n\n/* Static variables */\n\nstatic volatile sig_atomic_t kill_in_progress;\n\n\nstatic my_bool opt_myisam_log;\nstatic int cleanup_done;\nstatic ulong opt_specialflag;\nstatic char *opt_update_logname;\nchar *opt_binlog_index_name;\nchar *mysql_home_ptr, *pidfile_name_ptr;\nchar *default_auth_plugin;\n/** Initial command line arguments (count), after load_defaults().*/\nstatic int defaults_argc;\n/**\n  Initial command line arguments (arguments), after load_defaults().\n  This memory is allocated by @c load_defaults() and should be freed\n  using @c free_defaults().\n  Do not modify defaults_argc / defaults_argv,\n  use remaining_argc / remaining_argv instead to parse the command\n  line arguments in multiple steps.\n*/\nstatic char **defaults_argv;\n/** Remaining command line arguments (count), filtered by handle_options().*/\nstatic int remaining_argc;\n/** Remaining command line arguments (arguments), filtered by handle_options().*/\nstatic char **remaining_argv;\n\nint orig_argc;\nchar **orig_argv;\n\n#if defined(HAVE_OPENSSL) && !defined(HAVE_YASSL)\nbool init_rsa_keys(void);\nvoid deinit_rsa_keys(void);\nint show_rsa_public_key(THD *thd, SHOW_VAR *var, char *buff);\n#endif\n\nConnection_acceptor<Mysqld_socket_listener> *mysqld_socket_acceptor= NULL;\n#ifdef _WIN32\nConnection_acceptor<Named_pipe_listener> *named_pipe_acceptor= NULL;\nConnection_acceptor<Shared_mem_listener> *shared_mem_acceptor= NULL;\n#endif\n\nCheckable_rwlock *global_sid_lock= NULL;\nSid_map *global_sid_map= NULL;\nGtid_state *gtid_state= NULL;\nGtid_table_persistor *gtid_table_persistor= NULL;\n\n\nvoid set_remaining_args(int argc, char **argv)\n{\n  remaining_argc= argc;\n  remaining_argv= argv;\n}\n/* \n  Multiple threads of execution use the random state maintained in global\n  sql_rand to generate random numbers. sql_rnd_with_mutex use mutex\n  LOCK_sql_rand to protect sql_rand across multiple instantiations that use\n  sql_rand to generate random numbers.\n */\nulong sql_rnd_with_mutex()\n{\n  mysql_mutex_lock(&LOCK_sql_rand);\n  ulong tmp=(ulong) (my_rnd(&sql_rand) * 0xffffffff); /* make all bits random */\n  mysql_mutex_unlock(&LOCK_sql_rand);\n  return tmp;\n}\n\n\nC_MODE_START\n\nstatic void option_error_reporter(enum loglevel level, const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n\n  /* Don't print warnings for --loose options during bootstrap */\n  if (level == ERROR_LEVEL || !opt_bootstrap ||\n      (log_error_verbosity > 1))\n  {\n    error_log_print(level, format, args);\n  }\n  va_end(args);\n}\n\n/**\n  Character set and collation error reporter that prints to sql error log.\n  @param level          log message level\n  @param format         log message format string\n\n  This routine is used to print character set and collation\n  warnings and errors inside an already running mysqld server,\n  e.g. when a character set or collation is requested for the very first time\n  and its initialization does not go well for some reasons.\n*/\nstatic void charset_error_reporter(enum loglevel level,\n                                   const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  error_log_print(level, format, args);\n  va_end(args);\n}\nC_MODE_END\n\nstruct rand_struct sql_rand; ///< used by sql_class.cc:THD::THD()\n\n#ifndef EMBEDDED_LIBRARY\nstruct passwd *user_info= NULL;\n#ifndef _WIN32\nstatic my_thread_t main_thread_id;\n#endif // !_WIN32\n#endif // !EMBEDDED_LIBRARY\n\n/* OS specific variables */\n\n#ifdef _WIN32\n#include <process.h>\n\nstatic bool windows_service= false;\nstatic bool use_opt_args;\nstatic int opt_argc;\nstatic char **opt_argv;\n\n#if !defined(EMBEDDED_LIBRARY)\nstatic mysql_mutex_t LOCK_handler_count;\nstatic mysql_cond_t COND_handler_count;\nstatic HANDLE hEventShutdown;\nchar *shared_memory_base_name= default_shared_memory_base_name;\nmy_bool opt_enable_shared_memory;\nstatic char shutdown_event_name[40];\n#include \"nt_servc.h\"\nstatic   NTService  Service;        ///< Service object for WinNT\n#endif /* EMBEDDED_LIBRARY */\n#endif /* _WIN32 */\n\n#ifndef EMBEDDED_LIBRARY\nbool mysqld_embedded=0;\n#else\nbool mysqld_embedded=1;\n#endif\n\nstatic my_bool plugins_are_initialized= FALSE;\n\n#ifndef DBUG_OFF\nstatic const char* default_dbug_option;\n#endif\nulong query_cache_min_res_unit= QUERY_CACHE_MIN_RESULT_DATA_SIZE;\nQuery_cache query_cache;\n\nmy_bool opt_use_ssl= 1;\nchar *opt_ssl_ca= NULL, *opt_ssl_capath= NULL, *opt_ssl_cert= NULL,\n     *opt_ssl_cipher= NULL, *opt_ssl_key= NULL, *opt_ssl_crl= NULL,\n     *opt_ssl_crlpath= NULL, *opt_tls_version= NULL;\n\n#ifdef HAVE_OPENSSL\nchar *des_key_file;\n#ifndef EMBEDDED_LIBRARY\nstruct st_VioSSLFd *ssl_acceptor_fd;\nSSL *ssl_acceptor;\n#endif\n#endif /* HAVE_OPENSSL */\n\n/* Function declarations */\n\nextern \"C\" void *signal_hand(void *arg);\nstatic int mysql_init_variables(void);\nstatic int get_options(int *argc_ptr, char ***argv_ptr);\nstatic void add_terminator(vector<my_option> *options);\nextern \"C\" my_bool mysqld_get_one_option(int, const struct my_option *, char *);\nstatic void set_server_version(void);\nstatic int init_thread_environment();\nstatic char *get_relative_path(const char *path);\nstatic int fix_paths(void);\nstatic bool read_init_file(char *file_name);\nstatic void clean_up(bool print_message);\nstatic int test_if_case_insensitive(const char *dir_name);\nstatic void end_ssl();\nstatic void start_processing_signals();\n\n#ifndef EMBEDDED_LIBRARY\nstatic bool pid_file_created= false;\nstatic void usage(void);\nstatic void clean_up_mutexes(void);\nstatic void create_pid_file();\nstatic void mysqld_exit(int exit_code) MY_ATTRIBUTE((noreturn));\nstatic void delete_pid_file(myf flags);\n#endif\n\n\n#ifndef EMBEDDED_LIBRARY\n/****************************************************************************\n** Code to end mysqld\n****************************************************************************/\n\n/**\n  This class implements callback function used by close_connections()\n  to set KILL_CONNECTION flag on all thds in thd list.\n  If m_kill_dump_thread_flag is not set it kills all other threads\n  except dump threads. If this flag is set, it kills dump threads.\n*/\nclass Set_kill_conn : public Do_THD_Impl\n{\nprivate:\n  int m_dump_thread_count;\n  bool m_kill_dump_threads_flag;\npublic:\n  Set_kill_conn()\n    : m_dump_thread_count(0),\n      m_kill_dump_threads_flag(false)\n  {}\n\n  void set_dump_thread_flag()\n  {\n    m_kill_dump_threads_flag= true;\n  }\n\n  int get_dump_thread_count() const\n  {\n    return m_dump_thread_count;\n  }\n\n  virtual void operator()(THD *killing_thd)\n  {\n    DBUG_PRINT(\"quit\",(\"Informing thread %u that it's time to die\",\n                       killing_thd->thread_id()));\n    if (!m_kill_dump_threads_flag)\n    {\n      // We skip slave threads & scheduler on this first loop through.\n      if (killing_thd->slave_thread)\n        return;\n\n      if (killing_thd->get_command() == COM_BINLOG_DUMP ||\n          killing_thd->get_command() == COM_BINLOG_DUMP_GTID)\n      {\n        ++m_dump_thread_count;\n        return;\n      }\n      DBUG_EXECUTE_IF(\"Check_dump_thread_is_alive\",\n                      {\n                        DBUG_ASSERT(killing_thd->get_command() != COM_BINLOG_DUMP &&\n                                    killing_thd->get_command() != COM_BINLOG_DUMP_GTID);\n                      };);\n    }\n    mysql_mutex_lock(&killing_thd->LOCK_thd_data);\n    killing_thd->killed= THD::KILL_CONNECTION;\n    MYSQL_CALLBACK(Connection_handler_manager::event_functions,\n                   post_kill_notification, (killing_thd));\n    if (killing_thd->is_killable)\n    {\n      mysql_mutex_lock(&killing_thd->LOCK_current_cond);\n      if (killing_thd->current_cond)\n      {\n        mysql_mutex_lock(killing_thd->current_mutex);\n        mysql_cond_broadcast(killing_thd->current_cond);\n        mysql_mutex_unlock(killing_thd->current_mutex);\n      }\n      mysql_mutex_unlock(&killing_thd->LOCK_current_cond);\n    }\n    mysql_mutex_unlock(&killing_thd->LOCK_thd_data);\n  }\n};\n\n/**\n  This class implements callback function used by close_connections()\n  to close vio connection for all thds in thd list\n*/\nclass Call_close_conn : public Do_THD_Impl\n{\npublic:\n  Call_close_conn(bool server_shutdown) : is_server_shutdown(server_shutdown)\n  {}\n\n  virtual void operator()(THD *closing_thd)\n  {\n    if (closing_thd->get_protocol()->connection_alive())\n    {\n      LEX_CSTRING main_sctx_user= closing_thd->m_main_security_ctx.user();\n      sql_print_warning(ER_DEFAULT(ER_FORCING_CLOSE),my_progname,\n                        closing_thd->thread_id(),\n                        (main_sctx_user.length ? main_sctx_user.str : \"\"));\n      /*\n        Do not generate MYSQL_AUDIT_CONNECTION_DISCONNECT event, when closing\n        thread close sessions. Each session will generate DISCONNECT event by\n        itself.\n      */\n      close_connection(closing_thd, 0, is_server_shutdown, false);\n    }\n  }\nprivate:\n  bool is_server_shutdown;\n};\n\nstatic void close_connections(void)\n{\n  DBUG_ENTER(\"close_connections\");\n  (void) RUN_HOOK(server_state, before_server_shutdown, (NULL));\n\n  Per_thread_connection_handler::kill_blocked_pthreads();\n\n  uint dump_thread_count= 0;\n  uint dump_thread_kill_retries= 8;\n\n  // Close listeners.\n  if (mysqld_socket_acceptor != NULL)\n    mysqld_socket_acceptor->close_listener();\n#ifdef _WIN32\n  if (named_pipe_acceptor != NULL)\n    named_pipe_acceptor->close_listener();\n\n  if (shared_mem_acceptor != NULL)\n    shared_mem_acceptor->close_listener();\n#endif\n\n  /*\n    First signal all threads that it's time to die\n    This will give the threads some time to gracefully abort their\n    statements and inform their clients that the server is about to die.\n  */\n\n  Global_THD_manager *thd_manager= Global_THD_manager::get_instance();\n  sql_print_information(\"Giving %d client threads a chance to die gracefully\",\n                        static_cast<int>(thd_manager->get_thd_count()));\n\n  Set_kill_conn set_kill_conn;\n  thd_manager->do_for_all_thd(&set_kill_conn);\n  sql_print_information(\"Shutting down slave threads\");\n  end_slave();\n\n  if (set_kill_conn.get_dump_thread_count())\n  {\n    /*\n      Replication dump thread should be terminated after the clients are\n      terminated. Wait for few more seconds for other sessions to end.\n     */\n    while (thd_manager->get_thd_count() > dump_thread_count &&\n           dump_thread_kill_retries)\n    {\n      sleep(1);\n      dump_thread_kill_retries--;\n    }\n    set_kill_conn.set_dump_thread_flag();\n    thd_manager->do_for_all_thd(&set_kill_conn);\n  }\n  if (thd_manager->get_thd_count() > 0)\n    sleep(2);         // Give threads time to die\n\n  /*\n    Force remaining threads to die by closing the connection to the client\n    This will ensure that threads that are waiting for a command from the\n    client on a blocking read call are aborted.\n  */\n\n  sql_print_information(\"Forcefully disconnecting %d remaining clients\",\n                        static_cast<int>(thd_manager->get_thd_count()));\n\n  Call_close_conn call_close_conn(true);\n  thd_manager->do_for_all_thd(&call_close_conn);\n\n  (void) RUN_HOOK(server_state, after_server_shutdown, (NULL));\n\n  /*\n    All threads have now been aborted. Stop event scheduler thread\n    after aborting all client connections, otherwise user may\n    start/stop event scheduler after Events::deinit() deallocates\n    scheduler object(static member in Events class)\n  */\n  Events::deinit();\n  DBUG_PRINT(\"quit\",(\"Waiting for threads to die (count=%u)\",\n                     thd_manager->get_thd_count()));\n  thd_manager->wait_till_no_thd();\n\n  /*\n    Connection threads might take a little while to go down after removing from\n    global thread list. Give it some time.\n  */\n  Connection_handler_manager::wait_till_no_connection();\n\n  delete_slave_info_objects();\n  DBUG_PRINT(\"quit\",(\"close_connections thread\"));\n\n  DBUG_VOID_RETURN;\n}\n\n\nvoid kill_mysql(void)\n{\n  DBUG_ENTER(\"kill_mysql\");\n\n#if defined(_WIN32)\n  {\n    if (!SetEvent(hEventShutdown))\n    {\n      DBUG_PRINT(\"error\",(\"Got error: %ld from SetEvent\",GetLastError()));\n    }\n    /*\n      or:\n      HANDLE hEvent=OpenEvent(0, FALSE, \"MySqlShutdown\");\n      SetEvent(hEventShutdown);\n      CloseHandle(hEvent);\n    */\n  }\n#else\n  if (pthread_kill(signal_thread_id.thread, SIGTERM))\n  {\n    DBUG_PRINT(\"error\",(\"Got error %d from pthread_kill\",errno)); /* purecov: inspected */\n  }\n#endif\n  DBUG_PRINT(\"quit\",(\"After pthread_kill\"));\n  DBUG_VOID_RETURN;\n}\n\n\nextern \"C\" void unireg_abort(int exit_code)\n{\n  DBUG_ENTER(\"unireg_abort\");\n\n  // At this point it does not make sense to buffer more messages.\n  // Just flush what we have and write directly to stderr.\n  flush_error_log_messages();\n\n  if (opt_help)\n    usage();\n  if (exit_code)\n    sql_print_error(\"Aborting\\n\");\n\n  mysql_audit_notify(MYSQL_AUDIT_SERVER_SHUTDOWN_SHUTDOWN,\n                     MYSQL_AUDIT_SERVER_SHUTDOWN_REASON_ABORT, exit_code);\n#ifndef _WIN32\n  if (signal_thread_id.thread != 0)\n  {\n    start_processing_signals();\n\n    pthread_kill(signal_thread_id.thread, SIGTERM);\n    my_thread_join(&signal_thread_id, NULL);\n  }\n  signal_thread_id.thread= 0;\n\n  if (opt_daemonize)\n  {\n    mysqld::runtime::signal_parent(pipe_write_fd,0);\n  }\n#endif\n\n  clean_up(!opt_help && (exit_code || !opt_bootstrap)); /* purecov: inspected */\n  DBUG_PRINT(\"quit\",(\"done with cleanup in unireg_abort\"));\n  mysqld_exit(exit_code);\n}\n\nstatic void mysqld_exit(int exit_code)\n{\n  DBUG_ASSERT(exit_code >= MYSQLD_SUCCESS_EXIT\n              && exit_code <= MYSQLD_FAILURE_EXIT);\n  mysql_audit_finalize();\n#ifndef EMBEDDED_LIBRARY\n  Srv_session::module_deinit();\n#endif\n  delete_optimizer_cost_module();\n  clean_up_mutexes();\n  my_end(opt_endinfo ? MY_CHECK_ERROR | MY_GIVE_INFO : 0);\n  destroy_error_log();\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  shutdown_performance_schema();\n#endif\n#if defined(_WIN32)\n  if (Service.IsNT() && windows_service)\n  {\n    Service.Stop();\n  }\n  else\n  {\n    Service.SetShutdownEvent(0);\n    if (hEventShutdown)\n      CloseHandle(hEventShutdown);\n  }\n#endif\n  exit(exit_code); /* purecov: inspected */\n}\n\n#endif /* !EMBEDDED_LIBRARY */\n\n/**\n   GTID cleanup destroys objects and reset their pointer.\n   Function is reentrant.\n*/\nvoid gtid_server_cleanup()\n{\n  if (gtid_state != NULL)\n  {\n    delete gtid_state;\n    gtid_state= NULL;\n  }\n  if (global_sid_map != NULL)\n  {\n    delete global_sid_map;\n    global_sid_map= NULL;\n  }\n  if (global_sid_lock != NULL)\n  {\n    delete global_sid_lock;\n    global_sid_lock= NULL;\n  }\n  if (gtid_table_persistor != NULL)\n  {\n    delete gtid_table_persistor;\n    gtid_table_persistor= NULL;\n  }\n  if (gtid_mode_lock)\n  {\n    delete gtid_mode_lock;\n    gtid_mode_lock= NULL;\n  }\n}\n\n/**\n   GTID initialization.\n\n   @return true if allocation does not succeed\n           false if OK\n*/\nbool gtid_server_init()\n{\n  bool res=\n    (!(global_sid_lock= new Checkable_rwlock(\n#ifdef HAVE_PSI_INTERFACE\n                                             key_rwlock_global_sid_lock\n#endif\n                                            )) ||\n     !(gtid_mode_lock= new Checkable_rwlock(\n#ifdef HAVE_PSI_INTERFACE\n                                            key_rwlock_gtid_mode_lock\n#endif\n                                           )) ||\n     !(global_sid_map= new Sid_map(global_sid_lock)) ||\n     !(gtid_state= new Gtid_state(global_sid_lock, global_sid_map))||\n     !(gtid_table_persistor= new Gtid_table_persistor()));\n  if (res)\n  {\n    gtid_server_cleanup();\n  }\n  return res;\n}\n\n#ifndef EMBEDDED_LIBRARY\n// Free connection acceptors\nstatic void free_connection_acceptors()\n{\n  delete mysqld_socket_acceptor;\n  mysqld_socket_acceptor= NULL;\n\n#ifdef _WIN32\n  delete named_pipe_acceptor;\n  named_pipe_acceptor= NULL;\n  delete shared_mem_acceptor;\n  shared_mem_acceptor= NULL;\n#endif\n}\n#endif\n\n\nvoid clean_up(bool print_message)\n{\n  DBUG_PRINT(\"exit\",(\"clean_up\"));\n  if (cleanup_done++)\n    return; /* purecov: inspected */\n\n  stop_handle_manager();\n  release_ddl_log();\n\n  memcached_shutdown();\n\n  /*\n    make sure that handlers finish up\n    what they have that is dependent on the binlog\n  */\n  if ((opt_help == 0) || (opt_verbose > 0))\n    sql_print_information(\"Binlog end\");\n  ha_binlog_end(current_thd);\n\n  injector::free_instance();\n  mysql_bin_log.cleanup();\n  gtid_server_cleanup();\n\n#ifdef HAVE_REPLICATION\n  if (use_slave_mask)\n    bitmap_free(&slave_error_mask);\n#endif\n  my_tz_free();\n  my_dboptions_cache_free();\n  ignore_db_dirs_free();\n  servers_free(1);\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  acl_free(1);\n  grant_free();\n#endif\n  query_cache.destroy();\n  hostname_cache_free();\n  item_func_sleep_free();\n  lex_free();       /* Free some memory */\n  item_create_cleanup();\n  if (!opt_noacl)\n  {\n#ifdef HAVE_DLOPEN\n    udf_free();\n#endif\n  }\n  table_def_start_shutdown();\n  plugin_shutdown();\n  delete_optimizer_cost_module();\n  ha_end();\n  if (tc_log)\n  {\n    tc_log->close();\n    tc_log= NULL;\n  }\n  delegates_destroy();\n  transaction_cache_free();\n  table_def_free();\n  mdl_destroy();\n  key_caches.delete_elements((void (*)(const char*, uchar*)) free_key_cache);\n  multi_keycache_free();\n  free_status_vars();\n  query_logger.cleanup();\n  my_free_open_file_info();\n  if (defaults_argv)\n    free_defaults(defaults_argv);\n  free_tmpdir(&mysql_tmpdir_list);\n  my_free(opt_bin_logname);\n  bitmap_free(&temp_pool);\n  free_max_user_conn();\n#ifdef HAVE_REPLICATION\n  end_slave_list();\n#endif\n  delete binlog_filter;\n  delete rpl_filter;\n  end_ssl();\n  vio_end();\n  my_regex_end();\n#if defined(ENABLED_DEBUG_SYNC)\n  /* End the debug sync facility. See debug_sync.cc. */\n  debug_sync_end();\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n#ifndef EMBEDDED_LIBRARY\n  delete_pid_file(MYF(0));\n#endif\n\n  if (print_message && my_default_lc_messages && server_start_time)\n    sql_print_information(ER_DEFAULT(ER_SHUTDOWN_COMPLETE),my_progname);\n  cleanup_errmsgs();\n\n#ifndef EMBEDDED_LIBRARY\n  free_connection_acceptors();\n  Connection_handler_manager::destroy_instance();\n#endif\n\n  mysql_client_plugin_deinit();\n  finish_client_errs();\n  deinit_errmessage(); // finish server errs\n  DBUG_PRINT(\"quit\", (\"Error messages freed\"));\n\n  free_charsets();\n  sys_var_end();\n  Global_THD_manager::destroy_instance();\n\n  my_free(const_cast<char*>(log_bin_basename));\n  my_free(const_cast<char*>(log_bin_index));\n#ifndef EMBEDDED_LIBRARY\n  my_free(const_cast<char*>(relay_log_basename));\n  my_free(const_cast<char*>(relay_log_index));\n#endif\n  free_list(opt_early_plugin_load_list_ptr);\n  free_list(opt_plugin_load_list_ptr);\n\n  if (THR_THD_initialized)\n  {\n    THR_THD_initialized= false;\n    (void) my_delete_thread_local_key(THR_THD);\n  }\n\n  if (THR_MALLOC_initialized)\n  {\n    THR_MALLOC_initialized= false;\n    (void) my_delete_thread_local_key(THR_MALLOC);\n  }\n\n  if (have_statement_timeout == SHOW_OPTION_YES)\n    my_timer_deinitialize();\n\n  have_statement_timeout= SHOW_OPTION_DISABLED;\n\n  log_syslog_exit();\n\n  /*\n    The following lines may never be executed as the main thread may have\n    killed us\n  */\n  DBUG_PRINT(\"quit\", (\"done with cleanup\"));\n} /* clean_up */\n\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void clean_up_mutexes()\n{\n  mysql_mutex_destroy(&LOCK_log_throttle_qni);\n  mysql_mutex_destroy(&LOCK_status);\n  mysql_mutex_destroy(&LOCK_manager);\n  mysql_mutex_destroy(&LOCK_crypt);\n  mysql_mutex_destroy(&LOCK_user_conn);\n#ifdef HAVE_OPENSSL\n  mysql_mutex_destroy(&LOCK_des_key_file);\n#endif\n  mysql_rwlock_destroy(&LOCK_sys_init_connect);\n  mysql_rwlock_destroy(&LOCK_sys_init_slave);\n  mysql_mutex_destroy(&LOCK_global_system_variables);\n  mysql_rwlock_destroy(&LOCK_system_variables_hash);\n  mysql_mutex_destroy(&LOCK_uuid_generator);\n  mysql_mutex_destroy(&LOCK_sql_rand);\n  mysql_mutex_destroy(&LOCK_prepared_stmt_count);\n  mysql_mutex_destroy(&LOCK_sql_slave_skip_counter);\n  mysql_mutex_destroy(&LOCK_slave_net_timeout);\n  mysql_mutex_destroy(&LOCK_error_messages);\n  mysql_mutex_destroy(&LOCK_offline_mode);\n  mysql_mutex_destroy(&LOCK_default_password_lifetime);\n  mysql_cond_destroy(&COND_manager);\n#ifdef _WIN32\n  mysql_cond_destroy(&COND_handler_count);\n  mysql_mutex_destroy(&LOCK_handler_count);\n#endif\n#ifndef _WIN32\n  mysql_cond_destroy(&COND_socket_listener_active);\n  mysql_mutex_destroy(&LOCK_socket_listener_active);\n  mysql_cond_destroy(&COND_start_signal_handler);\n  mysql_mutex_destroy(&LOCK_start_signal_handler);\n#endif\n  mysql_mutex_destroy(&LOCK_keyring_operations);\n}\n\n\n/****************************************************************************\n** Init IP and UNIX socket\n****************************************************************************/\n\nstatic void set_ports()\n{\n  char  *env;\n  if (!mysqld_port && !opt_disable_networking)\n  {         // Get port if not from commandline\n    mysqld_port= MYSQL_PORT;\n\n    /*\n      if builder specifically requested a default port, use that\n      (even if it coincides with our factory default).\n      only if they didn't do we check /etc/services (and, failing\n      on that, fall back to the factory default of 3306).\n      either default can be overridden by the environment variable\n      MYSQL_TCP_PORT, which in turn can be overridden with command\n      line options.\n    */\n\n#if MYSQL_PORT_DEFAULT == 0\n    struct  servent *serv_ptr;\n    if ((serv_ptr= getservbyname(\"mysql\", \"tcp\")))\n      mysqld_port= ntohs((u_short) serv_ptr->s_port); /* purecov: inspected */\n#endif\n    if ((env = getenv(\"MYSQL_TCP_PORT\")))\n      mysqld_port= (uint) atoi(env);    /* purecov: inspected */\n  }\n  if (!mysqld_unix_port)\n  {\n#ifdef _WIN32\n    mysqld_unix_port= (char*) MYSQL_NAMEDPIPE;\n#else\n    mysqld_unix_port= (char*) MYSQL_UNIX_ADDR;\n#endif\n    if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n      mysqld_unix_port= env;      /* purecov: inspected */\n  }\n}\n\n\n#if !defined(_WIN32)\n/* Change to run as another user if started with --user */\n\nstatic struct passwd *check_user(const char *user)\n{\n  struct passwd *tmp_user_info;\n  uid_t user_id= geteuid();\n\n  // Don't bother if we aren't superuser\n  if (user_id)\n  {\n    if (user)\n    {\n      /* Don't give a warning, if real user is same as given with --user */\n      tmp_user_info= getpwnam(user);\n      if ((!tmp_user_info || user_id != tmp_user_info->pw_uid))\n        sql_print_warning(\n                    \"One can only use the --user switch if running as root\\n\");\n    }\n    return NULL;\n  }\n  if (!user)\n  {\n    if (!opt_bootstrap && !opt_help)\n    {\n      sql_print_error(\"Fatal error: Please read \\\"Security\\\" section of the manual to find out how to run mysqld as root!\\n\");\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n    return NULL;\n  }\n  /* purecov: begin tested */\n  if (!strcmp(user,\"root\"))\n    return NULL;                        // Avoid problem with dynamic libraries\n\n  if (!(tmp_user_info= getpwnam(user)))\n  {\n    // Allow a numeric uid to be used\n    const char *pos;\n    for (pos= user; my_isdigit(mysqld_charset,*pos); pos++) ;\n    if (*pos)                                   // Not numeric id\n      goto err;\n    if (!(tmp_user_info= getpwuid(atoi(user))))\n      goto err;\n  }\n  return tmp_user_info;\n  /* purecov: end */\n\nerr:\n  sql_print_error(\"Fatal error: Can't change to run as user '%s' ;  Please check that the user exists!\\n\",user);\n  unireg_abort(MYSQLD_ABORT_EXIT);\n\n#ifdef PR_SET_DUMPABLE\n  if (test_flags & TEST_CORE_ON_SIGNAL)\n  {\n    /* inform kernel that process is dumpable */\n    (void) prctl(PR_SET_DUMPABLE, 1);\n  }\n#endif\n\n  return NULL;\n}\n\nstatic void set_user(const char *user, struct passwd *user_info_arg)\n{\n  /* purecov: begin tested */\n  DBUG_ASSERT(user_info_arg != 0);\n#ifdef HAVE_INITGROUPS\n  /*\n    We can get a SIGSEGV when calling initgroups() on some systems when NSS\n    is configured to use LDAP and the server is statically linked.  We set\n    calling_initgroups as a flag to the SIGSEGV handler that is then used to\n    output a specific message to help the user resolve this problem.\n  */\n  calling_initgroups= 1;\n  initgroups((char*) user, user_info_arg->pw_gid);\n  calling_initgroups= 0;\n#endif\n  if (setgid(user_info_arg->pw_gid) == -1)\n  {\n    sql_print_error(\"setgid: %s\", strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  if (setuid(user_info_arg->pw_uid) == -1)\n  {\n    sql_print_error(\"setuid: %s\", strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  /* purecov: end */\n}\n\n\nstatic void set_effective_user(struct passwd *user_info_arg)\n{\n  DBUG_ASSERT(user_info_arg != 0);\n  if (setregid((gid_t)-1, user_info_arg->pw_gid) == -1)\n  {\n    sql_print_error(\"setregid: %s\", strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  if (setreuid((uid_t)-1, user_info_arg->pw_uid) == -1)\n  {\n    sql_print_error(\"setreuid: %s\", strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n}\n\n\n/** Change root user if started with @c --chroot . */\nstatic void set_root(const char *path)\n{\n  if (chroot(path) == -1)\n  {\n    sql_print_error(\"chroot: %s\", strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  my_setwd(\"/\", MYF(0));\n}\n#endif // !_WIN32\n\n\nstatic bool network_init(void)\n{\n  if (opt_bootstrap)\n    return false;\n\n  set_ports();\n\n#ifdef HAVE_SYS_UN_H\n  std::string const unix_sock_name(mysqld_unix_port ? mysqld_unix_port : \"\");\n#else\n  std::string const unix_sock_name(\"\");\n#endif\n\n  if (!opt_disable_networking || unix_sock_name != \"\")\n  {\n    std::string const bind_addr_str(my_bind_addr_str ? my_bind_addr_str : \"\");\n\n    Mysqld_socket_listener *mysqld_socket_listener=\n      new (std::nothrow) Mysqld_socket_listener(bind_addr_str,\n                                                mysqld_port, back_log,\n                                                mysqld_port_timeout,\n                                                unix_sock_name);\n    if (mysqld_socket_listener == NULL)\n      return true;\n\n    mysqld_socket_acceptor=\n      new (std::nothrow) Connection_acceptor<Mysqld_socket_listener>(mysqld_socket_listener);\n    if (mysqld_socket_acceptor == NULL)\n    {\n      delete mysqld_socket_listener;\n      mysqld_socket_listener= NULL;\n      return true;\n    }\n\n    if (mysqld_socket_acceptor->init_connection_acceptor())\n      return true; // mysqld_socket_acceptor would be freed in unireg_abort.\n\n    if (report_port == 0)\n      report_port= mysqld_port;\n\n    if (!opt_disable_networking)\n      DBUG_ASSERT(report_port != 0);\n  }\n#ifdef _WIN32\n  // Create named pipe\n  if (opt_enable_named_pipe)\n  {\n    std::string pipe_name= mysqld_unix_port ? mysqld_unix_port : \"\";\n\n    Named_pipe_listener *named_pipe_listener=\n      new (std::nothrow) Named_pipe_listener(&pipe_name);\n    if (named_pipe_listener == NULL)\n      return true;\n\n    named_pipe_acceptor=\n      new (std::nothrow) Connection_acceptor<Named_pipe_listener>(named_pipe_listener);\n    if (named_pipe_acceptor == NULL)\n    {\n      delete named_pipe_listener;\n      named_pipe_listener= NULL;\n      return true;\n    }\n\n    if (named_pipe_acceptor->init_connection_acceptor())\n      return true; // named_pipe_acceptor would be freed in unireg_abort.\n  }\n\n  // Setup shared_memory acceptor\n  if (opt_enable_shared_memory)\n  {\n    std::string shared_mem_base_name= shared_memory_base_name ? shared_memory_base_name : \"\";\n\n    Shared_mem_listener *shared_mem_listener=\n      new (std::nothrow) Shared_mem_listener(&shared_mem_base_name);\n    if (shared_mem_listener == NULL)\n      return true;\n\n    shared_mem_acceptor=\n      new (std::nothrow) Connection_acceptor<Shared_mem_listener>(shared_mem_listener);\n    if (shared_mem_acceptor == NULL)\n    {\n      delete shared_mem_listener;\n      shared_mem_listener= NULL;\n      return true;\n    }\n\n    if (shared_mem_acceptor->init_connection_acceptor())\n      return true; // shared_mem_acceptor would be freed in unireg_abort.\n  }\n#endif // _WIN32\n  return false;\n}\n\n#ifdef _WIN32\nstatic uint handler_count= 0;\n\n\nstatic inline void decrement_handler_count()\n{\n  mysql_mutex_lock(&LOCK_handler_count);\n  handler_count--;\n  mysql_cond_signal(&COND_handler_count);\n  mysql_mutex_unlock(&LOCK_handler_count);\n}\n\n\nextern \"C\" void *socket_conn_event_handler(void *arg)\n{\n  my_thread_init();\n\n  Connection_acceptor<Mysqld_socket_listener> *conn_acceptor=\n    static_cast<Connection_acceptor<Mysqld_socket_listener>*>(arg);\n  conn_acceptor->connection_event_loop();\n\n  decrement_handler_count();\n  my_thread_end();\n  return 0;\n}\n\n\nextern \"C\" void *named_pipe_conn_event_handler(void *arg)\n{\n  my_thread_init();\n\n  Connection_acceptor<Named_pipe_listener> *conn_acceptor=\n    static_cast<Connection_acceptor<Named_pipe_listener>*>(arg);\n  conn_acceptor->connection_event_loop();\n\n  decrement_handler_count();\n  my_thread_end();\n  return 0;\n}\n\n\nextern \"C\" void *shared_mem_conn_event_handler(void *arg)\n{\n  my_thread_init();\n\n  Connection_acceptor<Shared_mem_listener> *conn_acceptor=\n    static_cast<Connection_acceptor<Shared_mem_listener>*>(arg);\n  conn_acceptor->connection_event_loop();\n\n  decrement_handler_count();\n  my_thread_end();\n  return 0;\n}\n\n\nvoid setup_conn_event_handler_threads()\n{\n  my_thread_handle hThread;\n\n  DBUG_ENTER(\"handle_connections_methods\");\n\n  if ((!have_tcpip || opt_disable_networking) &&\n      !opt_enable_shared_memory && !opt_enable_named_pipe)\n  {\n    sql_print_error(\"TCP/IP, --shared-memory, or --named-pipe should be configured on NT OS\");\n    unireg_abort(MYSQLD_ABORT_EXIT);        // Will not return\n  }\n\n  mysql_mutex_lock(&LOCK_handler_count);\n  handler_count=0;\n\n  if (opt_enable_named_pipe)\n  {\n    int error= mysql_thread_create(key_thread_handle_con_namedpipes,\n                                   &hThread, &connection_attrib,\n                                   named_pipe_conn_event_handler,\n                                   named_pipe_acceptor);\n    if (!error)\n      handler_count++;\n    else\n      sql_print_warning(\"Can't create thread to handle named pipes\"\n                        \" (errno= %d)\", error);\n  }\n\n  if (have_tcpip && !opt_disable_networking)\n  {\n    int error= mysql_thread_create(key_thread_handle_con_sockets,\n                                   &hThread, &connection_attrib,\n                                   socket_conn_event_handler,\n                                   mysqld_socket_acceptor);\n    if (!error)\n      handler_count++;\n    else\n      sql_print_warning(\"Can't create thread to handle TCP/IP (errno= %d)\",\n                        error);\n  }\n\n  if (opt_enable_shared_memory)\n  {\n    int error= mysql_thread_create(key_thread_handle_con_sharedmem,\n                                   &hThread, &connection_attrib,\n                                   shared_mem_conn_event_handler,\n                                   shared_mem_acceptor);\n    if (!error)\n      handler_count++;\n    else\n      sql_print_warning(\"Can't create thread to handle shared memory\"\n                        \" (errno= %d)\", error);\n  }\n\n  // Block until all connection listener threads have exited.\n  while (handler_count > 0)\n    mysql_cond_wait(&COND_handler_count, &LOCK_handler_count);\n  mysql_mutex_unlock(&LOCK_handler_count);\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  On Windows, we use native SetConsoleCtrlHandler for handle events like Ctrl-C\n  with graceful shutdown.\n  Also, we do not use signal(), but SetUnhandledExceptionFilter instead - as it\n  provides possibility to pass the exception to just-in-time debugger, collect\n  dumps and potentially also the exception and thread context used to output\n  callstack.\n*/\n\nstatic BOOL WINAPI console_event_handler( DWORD type )\n{\n  DBUG_ENTER(\"console_event_handler\");\n  if(type == CTRL_C_EVENT)\n  {\n     /*\n       Do not shutdown before startup is finished and shutdown\n       thread is initialized. Otherwise there is a race condition\n       between main thread doing initialization and CTRL-C thread doing\n       cleanup, which can result into crash.\n     */\n     if(hEventShutdown)\n       kill_mysql();\n     else\n       sql_print_warning(\"CTRL-C ignored during startup\");\n     DBUG_RETURN(TRUE);\n  }\n  DBUG_RETURN(FALSE);\n}\n\n\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n#define DEBUGGER_ATTACH_TIMEOUT 120\n/*\n  Wait for debugger to attach and break into debugger. If debugger is not attached,\n  resume after timeout.\n*/\nstatic void wait_for_debugger(int timeout_sec)\n{\n   if(!IsDebuggerPresent())\n   {\n     int i;\n     printf(\"Waiting for debugger to attach, pid=%u\\n\",GetCurrentProcessId());\n     fflush(stdout);\n     for(i= 0; i < timeout_sec; i++)\n     {\n       Sleep(1000);\n       if(IsDebuggerPresent())\n       {\n         /* Break into debugger */\n         __debugbreak();\n         return;\n       }\n     }\n     printf(\"pid=%u, debugger not attached after %d seconds, resuming\\n\",GetCurrentProcessId(),\n       timeout_sec);\n     fflush(stdout);\n   }\n}\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n\nLONG WINAPI my_unhandler_exception_filter(EXCEPTION_POINTERS *ex_pointers)\n{\n   static BOOL first_time= TRUE;\n   if(!first_time)\n   {\n     /*\n       This routine can be called twice, typically\n       when detaching in JIT debugger.\n       Return EXCEPTION_EXECUTE_HANDLER to terminate process.\n     */\n     return EXCEPTION_EXECUTE_HANDLER;\n   }\n   first_time= FALSE;\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n   /*\n    Unfortunately there is no clean way to debug unhandled exception filters,\n    as debugger does not stop there(also documented in MSDN)\n    To overcome, one could put a MessageBox, but this will not work in service.\n    Better solution is to print error message and sleep some minutes\n    until debugger is attached\n  */\n  wait_for_debugger(DEBUGGER_ATTACH_TIMEOUT);\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n  __try\n  {\n    my_set_exception_pointers(ex_pointers);\n    handle_fatal_signal(ex_pointers->ExceptionRecord->ExceptionCode);\n  }\n  __except(EXCEPTION_EXECUTE_HANDLER)\n  {\n    DWORD written;\n    const char msg[] = \"Got exception in exception handler!\\n\";\n    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),msg, sizeof(msg)-1,\n      &written,NULL);\n  }\n  /*\n    Return EXCEPTION_CONTINUE_SEARCH to give JIT debugger\n    (drwtsn32 or vsjitdebugger) possibility to attach,\n    if JIT debugger is configured.\n    Windows Error reporting might generate a dump here.\n  */\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n\n\nvoid my_init_signals()\n{\n  if(opt_console)\n    SetConsoleCtrlHandler(console_event_handler,TRUE);\n\n    /* Avoid MessageBox()es*/\n  _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\n   /*\n     Do not use SEM_NOGPFAULTERRORBOX in the following SetErrorMode (),\n     because it would prevent JIT debugger and Windows error reporting\n     from working. We need WER or JIT-debugging, since our own unhandled\n     exception filter is not guaranteed to work in all situation\n     (like heap corruption or stack overflow)\n   */\n  SetErrorMode(SetErrorMode(0) | SEM_FAILCRITICALERRORS\n                               | SEM_NOOPENFILEERRORBOX);\n  SetUnhandledExceptionFilter(my_unhandler_exception_filter);\n}\n\n#else // !_WIN32\n\nextern \"C\" {\nstatic void empty_signal_handler(int sig MY_ATTRIBUTE((unused)))\n{ }\n}\n\n\nvoid my_init_signals()\n{\n  DBUG_ENTER(\"my_init_signals\");\n  struct sigaction sa;\n  (void) sigemptyset(&sa.sa_mask);\n\n  if (!(test_flags & TEST_NO_STACKTRACE) || (test_flags & TEST_CORE_ON_SIGNAL))\n  {\n#ifdef HAVE_STACKTRACE\n    my_init_stacktrace();\n#endif\n\n    if (test_flags & TEST_CORE_ON_SIGNAL)\n    {\n      // Change limits so that we will get a core file.\n      struct rlimit rl;\n      rl.rlim_cur= rl.rlim_max= RLIM_INFINITY;\n      if (setrlimit(RLIMIT_CORE, &rl))\n        sql_print_warning(\"setrlimit could not change the size of core files to\"\n                          \" 'infinity';  We may not be able to generate a\"\n                          \" core file on signals\");\n    }\n\n    /*\n      SA_RESETHAND resets handler action to default when entering handler.\n      SA_NODEFER allows receiving the same signal during handler.\n      E.g. SIGABRT during our signal handler will dump core (default action).\n    */\n    sa.sa_flags= SA_RESETHAND | SA_NODEFER;\n    sa.sa_handler= handle_fatal_signal;\n    // Treat all these as fatal and handle them.\n    (void) sigaction(SIGSEGV, &sa, NULL);\n    (void) sigaction(SIGABRT, &sa, NULL);\n    (void) sigaction(SIGBUS, &sa, NULL);\n    (void) sigaction(SIGILL, &sa, NULL);\n    (void) sigaction(SIGFPE, &sa, NULL);\n  }\n\n  // Ignore SIGPIPE and SIGALRM\n  sa.sa_flags= 0;\n  sa.sa_handler= SIG_IGN;\n  (void) sigaction(SIGPIPE, &sa, NULL);\n  (void) sigaction(SIGALRM, &sa, NULL);\n\n  // SIGUSR1 is used to interrupt the socket listener.\n  sa.sa_handler= empty_signal_handler;\n  (void) sigaction(SIGUSR1, &sa, NULL);\n\n  // Fix signals if ignored by parents (can happen on Mac OS X).\n  sa.sa_handler= SIG_DFL;\n  (void) sigaction(SIGTERM, &sa, NULL);\n  (void) sigaction(SIGHUP, &sa, NULL);\n\n  sigset_t set;\n  (void) sigemptyset(&set);\n  /*\n    Block SIGQUIT, SIGHUP and SIGTERM.\n    The signal handler thread does sigwait() on these.\n  */\n  (void) sigaddset(&set, SIGQUIT);\n  (void) sigaddset(&set, SIGHUP);\n  (void) sigaddset(&set, SIGTERM);\n  (void) sigaddset(&set, SIGTSTP);\n  /*\n    Block SIGINT unless debugging to prevent Ctrl+C from causing\n    unclean shutdown of the server.\n  */\n  if (!(test_flags & TEST_SIGINT))\n    (void) sigaddset(&set, SIGINT);\n  pthread_sigmask(SIG_SETMASK, &set, NULL);\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void start_signal_handler()\n{\n  int error;\n  my_thread_attr_t thr_attr;\n  DBUG_ENTER(\"start_signal_handler\");\n\n  (void) my_thread_attr_init(&thr_attr);\n  (void) pthread_attr_setscope(&thr_attr, PTHREAD_SCOPE_SYSTEM);\n  (void) my_thread_attr_setdetachstate(&thr_attr, MY_THREAD_CREATE_JOINABLE);\n\n  size_t guardize= 0;\n  (void) pthread_attr_getguardsize(&thr_attr, &guardize);\n#if defined(__ia64__) || defined(__ia64)\n  /*\n    Peculiar things with ia64 platforms - it seems we only have half the\n    stack size in reality, so we have to double it here\n  */\n  guardize= my_thread_stack_size;\n#endif\n  (void) my_thread_attr_setstacksize(&thr_attr, my_thread_stack_size + guardize);\n\n  /*\n    Set main_thread_id so that SIGTERM/SIGQUIT/SIGKILL can interrupt\n    the socket listener successfully.\n  */\n  main_thread_id= my_thread_self();\n\n  mysql_mutex_lock(&LOCK_start_signal_handler);\n  if ((error=\n       mysql_thread_create(key_thread_signal_hand,\n                           &signal_thread_id, &thr_attr, signal_hand, 0)))\n  {\n    sql_print_error(\"Can't create interrupt-thread (error %d, errno: %d)\",\n                    error, errno);\n    flush_error_log_messages();\n    exit(MYSQLD_ABORT_EXIT);\n  }\n  mysql_cond_wait(&COND_start_signal_handler, &LOCK_start_signal_handler);\n  mysql_mutex_unlock(&LOCK_start_signal_handler);\n\n  (void) my_thread_attr_destroy(&thr_attr);\n  DBUG_VOID_RETURN;\n}\n\n\n/** This thread handles SIGTERM, SIGQUIT and SIGHUP signals. */\n/* ARGSUSED */\nextern \"C\" void *signal_hand(void *arg MY_ATTRIBUTE((unused)))\n{\n  my_thread_init();\n\n  sigset_t set;\n  (void) sigemptyset(&set);\n  (void) sigaddset(&set, SIGTERM);\n  (void) sigaddset(&set, SIGQUIT);\n  (void) sigaddset(&set, SIGHUP);\n\n  /*\n    Signal to start_signal_handler that we are ready.\n    This works by waiting for start_signal_handler to free mutex,\n    after which we signal it that we are ready.\n  */\n  mysql_mutex_lock(&LOCK_start_signal_handler);\n  mysql_cond_broadcast(&COND_start_signal_handler);\n  mysql_mutex_unlock(&LOCK_start_signal_handler);\n\n  /*\n    Waiting until mysqld_server_started == true to ensure that all server\n    components have been successfully initialized. This step is mandatory\n    since signal processing can be done safely only when all server components\n    have been initialized.\n  */\n  mysql_mutex_lock(&LOCK_server_started);\n  while (!mysqld_server_started)\n    mysql_cond_wait(&COND_server_started, &LOCK_server_started);\n  mysql_mutex_unlock(&LOCK_server_started);\n\n  for (;;)\n  {\n    int sig;\n    while (sigwait(&set, &sig) == EINTR)\n    {}\n    if (cleanup_done)\n    {\n      my_thread_end();\n      my_thread_exit(0);      // Safety\n      return NULL;            // Avoid compiler warnings\n    }\n    switch (sig) {\n    case SIGTERM:\n    case SIGQUIT:\n      // Switch to the file log message processing.\n      query_logger.set_handlers((log_output_options != LOG_NONE) ?\n                                LOG_FILE : LOG_NONE);\n      DBUG_PRINT(\"info\", (\"Got signal: %d  abort_loop: %d\", sig, abort_loop));\n      if (!abort_loop)\n      {\n        abort_loop= true;       // Mark abort for threads.\n#ifdef HAVE_PSI_THREAD_INTERFACE\n        // Delete the instrumentation for the signal thread.\n        PSI_THREAD_CALL(delete_current_thread)();\n#endif\n        /*\n          Kill the socket listener.\n          The main thread will then set socket_listener_active= false,\n          and wait for us to finish all the cleanup below.\n        */\n        mysql_mutex_lock(&LOCK_socket_listener_active);\n        while (socket_listener_active)\n        {\n          DBUG_PRINT(\"info\",(\"Killing socket listener\"));\n          if (pthread_kill(main_thread_id, SIGUSR1))\n          {\n            DBUG_ASSERT(false);\n            break;\n          }\n          mysql_cond_wait(&COND_socket_listener_active,\n                          &LOCK_socket_listener_active);\n        }\n        mysql_mutex_unlock(&LOCK_socket_listener_active);\n\n        close_connections();\n      }\n      my_thread_end();\n      my_thread_exit(0);\n      return NULL;  // Avoid compiler warnings\n      break;\n    case SIGHUP:\n      if (!abort_loop)\n      {\n        int not_used;\n        mysql_print_status();   // Print some debug info\n        reload_acl_and_cache(NULL,\n                             (REFRESH_LOG | REFRESH_TABLES | REFRESH_FAST |\n                              REFRESH_GRANT | REFRESH_THREADS | REFRESH_HOSTS),\n                             NULL, &not_used); // Flush logs\n        // Reenable query logs after the options were reloaded.\n        query_logger.set_handlers(log_output_options);\n      }\n      break;\n    default:\n      break;          /* purecov: tested */\n    }\n  }\n  return NULL;        /* purecov: deadcode */\n}\n\n#endif // !_WIN32\n#endif // !EMBEDDED_LIBRARY\n\n/**\n  Starts processing signals initialized in the signal_hand function.\n\n  @see signal_hand\n*/\nstatic void start_processing_signals()\n{\n  mysql_mutex_lock(&LOCK_server_started);\n  mysqld_server_started= true;\n  mysql_cond_broadcast(&COND_server_started);\n  mysql_mutex_unlock(&LOCK_server_started);\n}\n\n#if HAVE_BACKTRACE && HAVE_ABI_CXA_DEMANGLE\n#include <cxxabi.h>\nextern \"C\" char *my_demangle(const char *mangled_name, int *status)\n{\n  return abi::__cxa_demangle(mangled_name, NULL, NULL, status);\n}\n#endif\n\n\n/**\n  All global error messages are sent here where the first one is stored\n  for the client.\n*/\n/* ARGSUSED */\nextern \"C\" void my_message_sql(uint error, const char *str, myf MyFlags);\n\nvoid my_message_sql(uint error, const char *str, myf MyFlags)\n{\n  THD *thd= current_thd;\n  DBUG_ENTER(\"my_message_sql\");\n  DBUG_PRINT(\"error\", (\"error: %u  message: '%s'\", error, str));\n\n  DBUG_ASSERT(str != NULL);\n  /*\n    An error should have a valid error number (!= 0), so it can be caught\n    in stored procedures by SQL exception handlers.\n    Calling my_error() with error == 0 is a bug.\n    Remaining known places to fix:\n    - storage/myisam/mi_create.c, my_printf_error()\n    TODO:\n    DBUG_ASSERT(error != 0);\n  */\n\n  if (error == 0)\n  {\n    /* At least, prevent new abuse ... */\n    DBUG_ASSERT(strncmp(str, \"MyISAM table\", 12) == 0);\n    error= ER_UNKNOWN_ERROR;\n  }\n\n  if (thd)\n  {\n    Sql_condition::enum_severity_level level= Sql_condition::SL_ERROR;\n\n    /**\n      Reporting an error invokes audit API call that notifies the error\n      to the plugin. Audit API that generate the error adds a protection\n      (condition handler) that prevents entering infinite recursion, when\n      a plugin signals error, when already handling the error.\n\n      handle_condition is normally invoked from within raise_condition,\n      but we need to prevent recursion befere notifying error to the plugin.\n\n      Additionaly, handle_condition must be called once during reporting\n      an error, so the raise_condition is called depending on the result of\n      the handle_condition call.\n    */\n    bool handle= thd->handle_condition(error,\n                                       mysql_errno_to_sqlstate(error),\n                                       &level,\n                                       str ? str : ER(error));\n#ifndef EMBEDDED_LIBRARY\n    if (!handle)\n      mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_ERROR),\n                         error, str, strlen(str));\n#endif\n\n    if (MyFlags & ME_FATALERROR)\n      thd->is_fatal_error= 1;\n\n    if (!handle)\n      (void) thd->raise_condition(error, NULL, level, str, false);\n  }\n\n  /* When simulating OOM, skip writing to error log to avoid mtr errors */\n  DBUG_EXECUTE_IF(\"simulate_out_of_memory\", DBUG_VOID_RETURN;);\n\n  if (!thd || MyFlags & ME_ERRORLOG)\n    sql_print_error(\"%s: %s\",my_progname,str); /* purecov: inspected */\n  DBUG_VOID_RETURN;\n}\n\n\n#ifndef EMBEDDED_LIBRARY\nextern \"C\" void *my_str_malloc_mysqld(size_t size);\nextern \"C\" void my_str_free_mysqld(void *ptr);\nextern \"C\" void *my_str_realloc_mysqld(void *ptr, size_t size);\n\nvoid *my_str_malloc_mysqld(size_t size)\n{\n  return my_malloc(key_memory_my_str_malloc,\n                   size, MYF(MY_FAE));\n}\n\n\nvoid my_str_free_mysqld(void *ptr)\n{\n  my_free(ptr);\n}\n\nvoid *my_str_realloc_mysqld(void *ptr, size_t size)\n{\n  return my_realloc(key_memory_my_str_malloc,\n                    ptr, size, MYF(MY_FAE));\n}\n#endif // !EMBEDDED_LIBRARY\n\nconst char *load_default_groups[]= {\n#ifdef WITH_NDBCLUSTER_STORAGE_ENGINE\n\"mysql_cluster\",\n#endif\n\"mysqld\",\"server\", MYSQL_BASE_VERSION, 0, 0};\n\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\nstatic const int load_default_groups_sz=\nsizeof(load_default_groups)/sizeof(load_default_groups[0]);\n#endif\n\n#ifndef EMBEDDED_LIBRARY\n/**\n  This function is used to check for stack overrun for pathological\n  cases of regular expressions and 'like' expressions.\n  The call to current_thd is quite expensive, so we try to avoid it\n  for the normal cases.\n  The size of each stack frame for the wildcmp() routines is ~128 bytes,\n  so checking *every* recursive call is not necessary.\n */\nextern \"C\" int\ncheck_enough_stack_size(int recurse_level)\n{\n  uchar stack_top;\n  if (recurse_level % 16 != 0)\n    return 0;\n\n  THD *my_thd= current_thd;\n  if (my_thd != NULL)\n    return check_stack_overrun(my_thd, STACK_MIN_SIZE * 2, &stack_top);\n  return 0;\n}\n#endif\n\n\n/**\n  Initialize one of the global date/time format variables.\n\n  @param format_type    What kind of format should be supported\n  @param var_ptr    Pointer to variable that should be updated\n\n  @retval\n    0 ok\n  @retval\n    1 error\n*/\n\nstatic bool init_global_datetime_format(timestamp_type format_type,\n                                        Date_time_format *format)\n{\n  /*\n    Get command line option\n    format->format.str is already set by my_getopt\n  */\n  format->format.length= strlen(format->format.str);\n\n  if (parse_date_time_format(format_type, format))\n  {\n    sql_print_error(\"Wrong date/time format specifier: %s\",\n                    format->format.str);\n    return true;\n  }\n  return false;\n}\n\nSHOW_VAR com_status_vars[]= {\n  {\"admin_commands\",       (char*) offsetof(STATUS_VAR, com_other),                                          SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"assign_to_keycache\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ASSIGN_TO_KEYCACHE]),         SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_db\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_DB]),                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_db_upgrade\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_DB_UPGRADE]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_event\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_EVENT]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_function\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_FUNCTION]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_instance\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_INSTANCE]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_procedure\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_PROCEDURE]),            SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_server\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_SERVER]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_table\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_TABLE]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_tablespace\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_TABLESPACE]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"alter_user\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_USER]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"analyze\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ANALYZE]),                    SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"begin\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_BEGIN]),                      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"binlog\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_BINLOG_BASE64_EVENT]),        SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"call_procedure\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CALL]),                       SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"change_db\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHANGE_DB]),                  SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"change_master\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHANGE_MASTER]),              SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"change_repl_filter\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHANGE_REPLICATION_FILTER]),  SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"check\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHECK]),                      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"checksum\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHECKSUM]),                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"commit\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_COMMIT]),                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_db\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_DB]),                  SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_event\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_EVENT]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_function\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_SPFUNCTION]),          SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_index\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_INDEX]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_procedure\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_PROCEDURE]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_server\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_SERVER]),              SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_table\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_TABLE]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_trigger\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_TRIGGER]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_udf\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_FUNCTION]),            SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_user\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_USER]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"create_view\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_VIEW]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"dealloc_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DEALLOCATE_PREPARE]),         SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"delete\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DELETE]),                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"delete_multi\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DELETE_MULTI]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"do\",                   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DO]),                         SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_db\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_DB]),                    SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_event\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_EVENT]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_function\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_FUNCTION]),              SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_index\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_INDEX]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_procedure\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_PROCEDURE]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_server\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_SERVER]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_table\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_TABLE]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_trigger\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_TRIGGER]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_user\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_USER]),                  SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"drop_view\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_VIEW]),                  SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"empty_query\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EMPTY_QUERY]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"execute_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EXECUTE]),                    SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"explain_other\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EXPLAIN_OTHER]),              SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"flush\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_FLUSH]),                      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"get_diagnostics\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_GET_DIAGNOSTICS]),            SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"grant\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_GRANT]),                      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"ha_close\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_CLOSE]),                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"ha_open\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_OPEN]),                    SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"ha_read\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_READ]),                    SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"help\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HELP]),                       SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"insert\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSERT]),                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"insert_select\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSERT_SELECT]),              SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"install_plugin\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSTALL_PLUGIN]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"kill\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_KILL]),                       SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"load\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOAD]),                       SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"lock_tables\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOCK_TABLES]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"optimize\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_OPTIMIZE]),                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"preload_keys\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PRELOAD_KEYS]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"prepare_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PREPARE]),                    SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"purge\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PURGE]),                      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"purge_before_date\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PURGE_BEFORE]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"release_savepoint\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RELEASE_SAVEPOINT]),          SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"rename_table\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RENAME_TABLE]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"rename_user\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RENAME_USER]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"repair\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPAIR]),                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"replace\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPLACE]),                    SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"replace_select\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPLACE_SELECT]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"reset\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RESET]),                      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"resignal\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RESIGNAL]),                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"revoke\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REVOKE]),                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"revoke_all\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REVOKE_ALL]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"rollback\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ROLLBACK]),                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"rollback_to_savepoint\",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ROLLBACK_TO_SAVEPOINT]),      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"savepoint\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SAVEPOINT]),                  SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"select\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SELECT]),                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"set_option\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SET_OPTION]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"signal\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SIGNAL]),                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_binlog_events\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOG_EVENTS]),         SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_binlogs\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOGS]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_charsets\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CHARSETS]),              SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_collations\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_COLLATIONS]),            SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_create_db\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_DB]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_create_event\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_EVENT]),          SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_create_func\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_FUNC]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_create_proc\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_PROC]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_create_table\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_create_trigger\",  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_TRIGGER]),        SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_databases\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_DATABASES]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_engine_logs\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_LOGS]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_engine_mutex\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_MUTEX]),          SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_engine_status\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_STATUS]),         SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_events\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_EVENTS]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_errors\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ERRORS]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_fields\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_FIELDS]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_function_code\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_FUNC_CODE]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_function_status\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS_FUNC]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_grants\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_GRANTS]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_keys\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_KEYS]),                  SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_master_status\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_MASTER_STAT]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_open_tables\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_OPEN_TABLES]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_plugins\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PLUGINS]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_privileges\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PRIVILEGES]),            SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_procedure_code\",  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROC_CODE]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_procedure_status\",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS_PROC]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_processlist\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROCESSLIST]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_profile\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROFILE]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_profiles\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROFILES]),              SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_relaylog_events\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_RELAYLOG_EVENTS]),       SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_slave_hosts\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_HOSTS]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_slave_status\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_STAT]),            SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_status\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_storage_engines\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STORAGE_ENGINES]),       SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_table_status\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATUS]),          SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_tables\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLES]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_triggers\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TRIGGERS]),              SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_variables\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_VARIABLES]),             SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_warnings\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_WARNS]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"show_create_user\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_USER]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"shutdown\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHUTDOWN]),                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"slave_start\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SLAVE_START]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"slave_stop\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SLAVE_STOP]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"group_replication_start\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_START_GROUP_REPLICATION]), SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"group_replication_stop\",  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_STOP_GROUP_REPLICATION]),  SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"stmt_execute\",         (char*) offsetof(STATUS_VAR, com_stmt_execute),                                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"stmt_close\",           (char*) offsetof(STATUS_VAR, com_stmt_close),                                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"stmt_fetch\",           (char*) offsetof(STATUS_VAR, com_stmt_fetch),                                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"stmt_prepare\",         (char*) offsetof(STATUS_VAR, com_stmt_prepare),                                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"stmt_reset\",           (char*) offsetof(STATUS_VAR, com_stmt_reset),                                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"stmt_send_long_data\",  (char*) offsetof(STATUS_VAR, com_stmt_send_long_data),                            SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"truncate\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_TRUNCATE]),                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"uninstall_plugin\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UNINSTALL_PLUGIN]),           SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"unlock_tables\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UNLOCK_TABLES]),              SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"update\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UPDATE]),                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"update_multi\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UPDATE_MULTI]),               SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"xa_commit\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_COMMIT]),                  SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"xa_end\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_END]),                     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"xa_prepare\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_PREPARE]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"xa_recover\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_RECOVER]),                 SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"xa_rollback\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_ROLLBACK]),                SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {\"xa_start\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_START]),                   SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n  {NullS, NullS, SHOW_LONG, SHOW_SCOPE_ALL}\n};\n\n\n#ifndef EMBEDDED_LIBRARY\nLEX_CSTRING sql_statement_names[(uint) SQLCOM_END + 1];\n\nstatic void init_sql_statement_names()\n{\n  static LEX_CSTRING empty= { C_STRING_WITH_LEN(\"\") };\n\n  char *first_com= (char*) offsetof(STATUS_VAR, com_stat[0]);\n  char *last_com= (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_END]);\n  int record_size= (char*) offsetof(STATUS_VAR, com_stat[1])\n                   - (char*) offsetof(STATUS_VAR, com_stat[0]);\n  char *ptr;\n  uint i;\n  uint com_index;\n\n  for (i= 0; i < ((uint) SQLCOM_END + 1); i++)\n    sql_statement_names[i]= empty;\n\n  SHOW_VAR *var= &com_status_vars[0];\n  while (var->name != NULL)\n  {\n    ptr= var->value;\n    if ((first_com <= ptr) && (ptr <= last_com))\n    {\n      com_index= ((int)(ptr - first_com))/record_size;\n      DBUG_ASSERT(com_index < (uint) SQLCOM_END);\n      sql_statement_names[com_index].str= var->name;\n      /* TODO: Change SHOW_VAR::name to a LEX_STRING, to avoid strlen() */\n      sql_statement_names[com_index].length= strlen(var->name);\n    }\n    var++;\n  }\n\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint) SQLCOM_SELECT].str, \"select\") == 0);\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint) SQLCOM_SIGNAL].str, \"signal\") == 0);\n\n  sql_statement_names[(uint) SQLCOM_END].str= \"error\";\n}\n#endif // !EMBEDDED_LIBRARY\n\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\nPSI_statement_info sql_statement_info[(uint) SQLCOM_END + 1];\nPSI_statement_info com_statement_info[(uint) COM_END + 1];\nPSI_statement_info stmt_info_new_packet;\n\n/**\n  Initialize the command names array.\n  Since we do not want to maintain a separate array,\n  this is populated from data mined in com_status_vars,\n  which already has one name for each command.\n*/\nvoid init_sql_statement_info()\n{\n  uint i;\n\n  for (i= 0; i < ((uint) SQLCOM_END + 1); i++)\n  {\n    sql_statement_info[i].m_name= sql_statement_names[i].str;\n    sql_statement_info[i].m_flags= 0;\n  }\n\n  /* \"statement/sql/error\" represents broken queries (syntax error). */\n  sql_statement_info[(uint) SQLCOM_END].m_name= \"error\";\n  sql_statement_info[(uint) SQLCOM_END].m_flags= 0;\n}\n\nvoid init_com_statement_info()\n{\n  uint index;\n\n  for (index= 0; index < (uint) COM_END + 1; index++)\n  {\n    com_statement_info[index].m_name= command_name[index].str;\n    com_statement_info[index].m_flags= 0;\n  }\n\n  /* \"statement/abstract/query\" can mutate into \"statement/sql/...\" */\n  com_statement_info[(uint) COM_QUERY].m_flags= PSI_FLAG_MUTABLE;\n}\n#endif\n\n/**\n  Create a replication file name or base for file names.\n\n  @param[in] opt Value of option, or NULL\n  @param[in] def Default value if option value is not set.\n  @param[in] ext Extension to use for the path\n\n  @returns Pointer to string containing the full file path, or NULL if\n  it was not possible to create the path.\n */\nstatic inline const char *\nrpl_make_log_name(PSI_memory_key key,\n                  const char *opt,\n                  const char *def,\n                  const char *ext)\n{\n  DBUG_ENTER(\"rpl_make_log_name\");\n  DBUG_PRINT(\"enter\", (\"opt: %s, def: %s, ext: %s\", (opt && opt[0])? opt : \"\", def, ext));\n  char buff[FN_REFLEN];\n  /*\n    opt[0] needs to be checked to make sure opt name is not an empty\n    string, incase it is an empty string default name will be considered\n  */\n  const char *base= (opt && opt[0]) ? opt : def;\n  unsigned int options=\n    MY_REPLACE_EXT | MY_UNPACK_FILENAME | MY_SAFE_PATH;\n\n  /* mysql_real_data_home_ptr may be null if no value of datadir has been\n     specified through command-line or througha cnf file. If that is the \n     case we make mysql_real_data_home_ptr point to mysql_real_data_home\n     which, in that case holds the default path for data-dir.\n  */\n\n  DBUG_EXECUTE_IF(\"emulate_empty_datadir_param\",\n                  {\n                    mysql_real_data_home_ptr= NULL;\n                  };\n                 );\n\n  if(mysql_real_data_home_ptr == NULL)\n    mysql_real_data_home_ptr= mysql_real_data_home;\n\n  if (fn_format(buff, base, mysql_real_data_home_ptr, ext, options))\n    DBUG_RETURN(my_strdup(key, buff, MYF(0)));\n  else\n    DBUG_RETURN(NULL);\n}\n\n\nint init_common_variables()\n{\n  umask(((~my_umask) & 0666));\n  my_decimal_set_zero(&decimal_zero); // set decimal_zero constant;\n  tzset();      // Set tzname\n\n  max_system_variables.pseudo_thread_id= (my_thread_id) ~0;\n  server_start_time= flush_status_time= my_time(0);\n\n  rpl_filter= new Rpl_filter;\n  binlog_filter= new Rpl_filter;\n  if (!rpl_filter || !binlog_filter)\n  {\n    sql_print_error(\"Could not allocate replication and binlog filters: %s\",\n                    strerror(errno));\n    return 1;\n  }\n\n  if (init_thread_environment() ||\n      mysql_init_variables())\n    return 1;\n\n  ignore_db_dirs_init();\n\n  {\n    struct tm tm_tmp;\n    localtime_r(&server_start_time,&tm_tmp);\n#ifdef _WIN32\n    strmake(system_time_zone, _tzname[tm_tmp.tm_isdst != 0 ? 1 : 0],\n            sizeof(system_time_zone) - 1);\n#else\n    strmake(system_time_zone, tzname[tm_tmp.tm_isdst != 0 ? 1 : 0],\n            sizeof(system_time_zone)-1);\n#endif\n\n }\n\n  /*\n    We set SYSTEM time zone as reasonable default and\n    also for failure of my_tz_init() and bootstrap mode.\n    If user explicitly set time zone with --default-time-zone\n    option we will change this value in my_tz_init().\n  */\n  global_system_variables.time_zone= my_tz_SYSTEM;\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Complete the mysql_bin_log initialization.\n    Instrumentation keys are known only after the performance schema initialization,\n    and can not be set in the MYSQL_BIN_LOG constructor (called before main()).\n  */\n  mysql_bin_log.set_psi_keys(key_BINLOG_LOCK_index,\n                             key_BINLOG_LOCK_commit,\n                             key_BINLOG_LOCK_commit_queue,\n                             key_BINLOG_LOCK_done,\n                             key_BINLOG_LOCK_flush_queue,\n                             key_BINLOG_LOCK_log,\n                             key_BINLOG_LOCK_binlog_end_pos,\n                             key_BINLOG_LOCK_sync,\n                             key_BINLOG_LOCK_sync_queue,\n                             key_BINLOG_LOCK_xids,\n                             key_BINLOG_COND_done,\n                             key_BINLOG_update_cond,\n                             key_BINLOG_prep_xids_cond,\n                             key_file_binlog,\n                             key_file_binlog_index,\n                             key_file_binlog_cache,\n                             key_file_binlog_index_cache);\n#endif\n\n  /*\n    Init mutexes for the global MYSQL_BIN_LOG objects.\n    As safe_mutex depends on what MY_INIT() does, we can't init the mutexes of\n    global MYSQL_BIN_LOGs in their constructors, because then they would be\n    inited before MY_INIT(). So we do it here.\n  */\n  mysql_bin_log.init_pthread_objects();\n\n  /* TODO: remove this when my_time_t is 64 bit compatible */\n  if (!IS_TIME_T_VALID_FOR_TIMESTAMP(server_start_time))\n  {\n    sql_print_error(\"This MySQL server doesn't support dates later then 2038\");\n    return 1;\n  }\n\n  if (gethostname(glob_hostname,sizeof(glob_hostname)) < 0)\n  {\n    strmake(glob_hostname, STRING_WITH_LEN(\"localhost\"));\n    sql_print_warning(\"gethostname failed, using '%s' as hostname\",\n                      glob_hostname);\n    strmake(default_logfile_name, STRING_WITH_LEN(\"mysql\"));\n  }\n  else\n    strmake(default_logfile_name, glob_hostname,\n      sizeof(default_logfile_name)-5);\n\n  strmake(pidfile_name, default_logfile_name, sizeof(pidfile_name)-5);\n  my_stpcpy(fn_ext(pidfile_name),\".pid\");    // Add proper extension\n\n\n  /*\n    The default-storage-engine entry in my_long_options should have a\n    non-null default value. It was earlier intialized as\n    (longlong)\"MyISAM\" in my_long_options but this triggered a\n    compiler error in the Sun Studio 12 compiler. As a work-around we\n    set the def_value member to 0 in my_long_options and initialize it\n    to the correct value here.\n\n    From MySQL 5.5 onwards, the default storage engine is InnoDB\n    (except in the embedded server, where the default continues to\n    be MyISAM)\n  */\n#ifdef EMBEDDED_LIBRARY\n  default_storage_engine= const_cast<char *>(\"MyISAM\");\n#else\n  default_storage_engine= const_cast<char *>(\"InnoDB\");\n#endif\n  default_tmp_storage_engine= default_storage_engine;\n\n\n  /*\n    Add server status variables to the dynamic list of\n    status variables that is shown by SHOW STATUS.\n    Later, in plugin_init, and mysql_install_plugin\n    new entries could be added to that list.\n  */\n  if (add_status_vars(status_vars))\n    return 1; // an error was already reported\n\n#ifndef DBUG_OFF\n  /*\n    We have few debug-only commands in com_status_vars, only visible in debug\n    builds. for simplicity we enable the assert only in debug builds\n\n    There are 8 Com_ variables which don't have corresponding SQLCOM_ values:\n    (TODO strictly speaking they shouldn't be here, should not have Com_ prefix\n    that is. Perhaps Stmt_ ? Comstmt_ ? Prepstmt_ ?)\n\n      Com_admin_commands       => com_other\n      Com_stmt_close           => com_stmt_close\n      Com_stmt_execute         => com_stmt_execute\n      Com_stmt_fetch           => com_stmt_fetch\n      Com_stmt_prepare         => com_stmt_prepare\n      Com_stmt_reprepare       => com_stmt_reprepare\n      Com_stmt_reset           => com_stmt_reset\n      Com_stmt_send_long_data  => com_stmt_send_long_data\n\n    With this correction the number of Com_ variables (number of elements in\n    the array, excluding the last element - terminator) must match the number\n    of SQLCOM_ constants.\n  */\n  compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==\n                     SQLCOM_END + 7);\n#endif\n\n  if (get_options(&remaining_argc, &remaining_argv))\n    return 1;\n\n  update_parser_max_mem_size();\n\n  if (log_syslog_init())\n    opt_log_syslog_enable= 0;\n\n  if (set_default_auth_plugin(default_auth_plugin, strlen(default_auth_plugin)))\n  {\n    sql_print_error(\"Can't start server: \"\n\t\t    \"Invalid value for --default-authentication-plugin\");\n    return 1;\n  }\n  set_server_version();\n\n  log_warnings= log_error_verbosity - 1; // backward compatibility\n\n  sql_print_information(\"%s (mysqld %s) starting as process %lu ...\",\n                        my_progname, server_version, (ulong) getpid());\n\n\n#ifndef EMBEDDED_LIBRARY\n  if (opt_help && !opt_verbose)\n    unireg_abort(MYSQLD_SUCCESS_EXIT);\n#endif /*!EMBEDDED_LIBRARY*/\n\n  DBUG_PRINT(\"info\",(\"%s  Ver %s for %s on %s\\n\",my_progname,\n         server_version, SYSTEM_TYPE,MACHINE_TYPE));\n\n#ifdef HAVE_LINUX_LARGE_PAGES\n  /* Initialize large page size */\n  if (opt_large_pages && (opt_large_page_size= my_get_large_page_size()))\n  {\n      DBUG_PRINT(\"info\", (\"Large page set, large_page_size = %d\",\n                 opt_large_page_size));\n      my_use_large_pages= 1;\n      my_large_page_size= opt_large_page_size;\n  }\n  else\n  {\n    opt_large_pages= 0;\n    /*\n       Either not configured to use large pages or Linux haven't\n       been compiled with large page support\n    */\n  }\n#endif /* HAVE_LINUX_LARGE_PAGES */\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#define LARGE_PAGESIZE (4*1024*1024)  /* 4MB */\n#define SUPER_LARGE_PAGESIZE (256*1024*1024)  /* 256MB */\n  if (opt_large_pages)\n  {\n  /*\n    tell the kernel that we want to use 4/256MB page for heap storage\n    and also for the stack. We use 4 MByte as default and if the\n    super-large-page is set we increase it to 256 MByte. 256 MByte\n    is for server installations with GBytes of RAM memory where\n    the MySQL Server will have page caches and other memory regions\n    measured in a number of GBytes.\n    We use as big pages as possible which isn't bigger than the above\n    desired page sizes.\n  */\n   int nelem;\n   size_t max_desired_page_size;\n   if (opt_super_large_pages)\n     max_desired_page_size= SUPER_LARGE_PAGESIZE;\n   else\n     max_desired_page_size= LARGE_PAGESIZE;\n   nelem = getpagesizes(NULL, 0);\n   if (nelem > 0)\n   {\n     size_t *pagesize = (size_t *) malloc(sizeof(size_t) * nelem);\n     if (pagesize != NULL && getpagesizes(pagesize, nelem) > 0)\n     {\n       size_t max_page_size= 0;\n       for (int i= 0; i < nelem; i++)\n       {\n         if (pagesize[i] > max_page_size &&\n             pagesize[i] <= max_desired_page_size)\n            max_page_size= pagesize[i];\n       }\n       free(pagesize);\n       if (max_page_size > 0)\n       {\n         struct memcntl_mha mpss;\n\n         mpss.mha_cmd= MHA_MAPSIZE_BSSBRK;\n         mpss.mha_pagesize= max_page_size;\n         mpss.mha_flags= 0;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n         mpss.mha_cmd= MHA_MAPSIZE_STACK;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n       }\n     }\n   }\n  }\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n  longlong default_value;\n  sys_var *var;\n#ifndef EMBEDDED_LIBRARY\n  /* Calculate and update default value for thread_cache_size. */\n  if ((default_value= 8 + max_connections / 100) > 100)\n    default_value= 100;\n  var= intern_find_sys_var(STRING_WITH_LEN(\"thread_cache_size\"));\n  var->update_default(default_value);\n#endif\n\n  /* Calculate and update default value for host_cache_size. */\n  if ((default_value= 128 + max_connections) > 628 &&\n      (default_value= 628 + ((max_connections - 500) / 20)) > 2000)\n    default_value= 2000;\n  var= intern_find_sys_var(STRING_WITH_LEN(\"host_cache_size\"));\n  var->update_default(default_value);\n\n#ifndef EMBEDDED_LIBRARY\n  /* Fix thread_cache_size. */\n  if (!thread_cache_size_specified &&\n      (Per_thread_connection_handler::max_blocked_pthreads=\n       8 + max_connections / 100) > 100)\n    Per_thread_connection_handler::max_blocked_pthreads= 100;\n#endif // !EMBEDDED_LIBRARY\n\n  /* Fix host_cache_size. */\n  if (!host_cache_size_specified &&\n      (host_cache_size= 128 + max_connections) > 628 &&\n      (host_cache_size= 628 + ((max_connections - 500) / 20)) > 2000)\n    host_cache_size= 2000;\n\n  /* Fix back_log */\n  if (back_log == 0 && (back_log= 50 + max_connections / 5) > 900)\n    back_log= 900;\n\n  unireg_init(opt_specialflag); /* Set up extern variabels */\n  if (!(my_default_lc_messages=\n        my_locale_by_name(lc_messages)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_messages);\n    return 1;\n  }\n  global_system_variables.lc_messages= my_default_lc_messages;\n  if (init_errmessage())  /* Read error messages from file */\n    return 1;\n  init_client_errs();\n\n  mysql_client_plugin_init();\n  if (item_create_init())\n    return 1;\n  item_init();\n#ifndef EMBEDDED_LIBRARY\n  my_regex_init(&my_charset_latin1, check_enough_stack_size);\n  my_string_stack_guard= check_enough_stack_size;\n#else\n  my_regex_init(&my_charset_latin1, NULL);\n#endif\n  /*\n    Process a comma-separated character set list and choose\n    the first available character set. This is mostly for\n    test purposes, to be able to start \"mysqld\" even if\n    the requested character set is not available (see bug#18743).\n  */\n  for (;;)\n  {\n    char *next_character_set_name= strchr(default_character_set_name, ',');\n    if (next_character_set_name)\n      *next_character_set_name++= '\\0';\n    if (!(default_charset_info=\n          get_charset_by_csname(default_character_set_name,\n                                MY_CS_PRIMARY, MYF(MY_WME))))\n    {\n      if (next_character_set_name)\n      {\n        default_character_set_name= next_character_set_name;\n        default_collation_name= 0;          // Ignore collation\n      }\n      else\n        return 1;                           // Eof of the list\n    }\n    else\n      break;\n  }\n\n  if (default_collation_name)\n  {\n    CHARSET_INFO *default_collation;\n    default_collation= get_charset_by_name(default_collation_name, MYF(0));\n    if (!default_collation)\n    {\n      sql_print_error(ER_DEFAULT(ER_UNKNOWN_COLLATION), default_collation_name);\n      return 1;\n    }\n    if (!my_charset_same(default_charset_info, default_collation))\n    {\n      sql_print_error(ER_DEFAULT(ER_COLLATION_CHARSET_MISMATCH),\n          default_collation_name,\n          default_charset_info->csname);\n      return 1;\n    }\n    default_charset_info= default_collation;\n  }\n  /* Set collactions that depends on the default collation */\n  global_system_variables.collation_server=  default_charset_info;\n  global_system_variables.collation_database=  default_charset_info;\n\n  if (is_supported_parser_charset(default_charset_info))\n  {\n    global_system_variables.collation_connection= default_charset_info;\n    global_system_variables.character_set_results= default_charset_info;\n    global_system_variables.character_set_client= default_charset_info;\n  }\n  else\n  {\n    sql_print_information(\"'%s' can not be used as client character set. \"\n                          \"'%s' will be used as default client character set.\",\n                          default_charset_info->csname,\n                          my_charset_latin1.csname);\n    global_system_variables.collation_connection= &my_charset_latin1;\n    global_system_variables.character_set_results= &my_charset_latin1;\n    global_system_variables.character_set_client= &my_charset_latin1;\n  }\n\n  if (!(character_set_filesystem=\n        get_charset_by_csname(character_set_filesystem_name,\n                              MY_CS_PRIMARY, MYF(MY_WME))))\n    return 1;\n  global_system_variables.character_set_filesystem= character_set_filesystem;\n\n  if (lex_init())\n  {\n    sql_print_error(\"Out of memory\");\n    return 1;\n  }\n\n  if (!(my_default_lc_time_names=\n        my_locale_by_name(lc_time_names_name)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_time_names_name);\n    return 1;\n  }\n  global_system_variables.lc_time_names= my_default_lc_time_names;\n\n  /* check log options and issue warnings if needed */\n  if (opt_general_log && opt_general_logname && !(log_output_options & LOG_FILE) &&\n      !(log_output_options & LOG_NONE))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--general-log-file option, log tables are used. \"\n                      \"To enable logging to files use the --log-output=file option.\");\n\n  if (opt_slow_log && opt_slow_logname && !(log_output_options & LOG_FILE)\n      && !(log_output_options & LOG_NONE))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--slow-query-log-file option, log tables are used. \"\n                      \"To enable logging to files use the --log-output=file option.\");\n\n  if (opt_general_logname &&\n      !is_valid_log_name(opt_general_logname, strlen(opt_general_logname)))\n  {\n    sql_print_error(\"Invalid value for --general_log_file: %s\",\n                    opt_general_logname);\n    return 1;\n  }\n\n  if (opt_slow_logname &&\n      !is_valid_log_name(opt_slow_logname, strlen(opt_slow_logname)))\n  {\n    sql_print_error(\"Invalid value for --slow_query_log_file: %s\",\n                    opt_slow_logname);\n    return 1;\n  }\n\n#define FIX_LOG_VAR(VAR, ALT)                                   \\\n  if (!VAR || !*VAR)                                            \\\n    VAR= ALT;\n\n  FIX_LOG_VAR(opt_general_logname,\n              make_query_log_name(logname_path, QUERY_LOG_GENERAL));\n  FIX_LOG_VAR(opt_slow_logname,\n              make_query_log_name(slow_logname_path, QUERY_LOG_SLOW));\n\n#if defined(ENABLED_DEBUG_SYNC)\n  /* Initialize the debug sync facility. See debug_sync.cc. */\n  if (debug_sync_init())\n    return 1; /* purecov: tested */\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n#if defined(__linux__)\n  if (use_temp_pool && bitmap_init(&temp_pool,0,1024,1))\n    return 1;\n#else\n  use_temp_pool= 0;\n#endif\n\n  if (my_dboptions_cache_init())\n    return 1;\n\n  if (ignore_db_dirs_process_additions())\n  {\n    sql_print_error(\"An error occurred while storing ignore_db_dirs to a hash.\");\n    return 1;\n  }\n\n  /* create the data directory if requested */\n  if (unlikely(opt_initialize) &&\n      initialize_create_data_directory(mysql_real_data_home))\n      return 1;\n\n\n  /*\n    Ensure that lower_case_table_names is set on system where we have case\n    insensitive names.  If this is not done the users MyISAM tables will\n    get corrupted if accesses with names of different case.\n  */\n  DBUG_PRINT(\"info\", (\"lower_case_table_names: %d\", lower_case_table_names));\n  lower_case_file_system= test_if_case_insensitive(mysql_real_data_home);\n  if (!lower_case_table_names && lower_case_file_system == 1)\n  {\n    if (lower_case_table_names_used)\n    {\n      sql_print_error(\"The server option 'lower_case_table_names' is \"\n                      \"configured to use case sensitive table names but the \"\n                      \"data directory is on a case-insensitive file system \"\n                      \"which is an unsupported combination. Please consider \"\n                      \"either using a case sensitive file system for your data \"\n                      \"directory or switching to a case-insensitive table name \"\n                      \"mode.\");\n      return 1;\n    }\n    else\n    {\n      sql_print_warning(\"Setting lower_case_table_names=2 because file system for %s is case insensitive\", mysql_real_data_home);\n      lower_case_table_names= 2;\n    }\n  }\n  else if (lower_case_table_names == 2 &&\n           !(lower_case_file_system=\n             (test_if_case_insensitive(mysql_real_data_home) == 1)))\n  {\n    sql_print_warning(\"lower_case_table_names was set to 2, even though your \"\n                        \"the file system '%s' is case sensitive.  Now setting \"\n                        \"lower_case_table_names to 0 to avoid future problems.\",\n      mysql_real_data_home);\n    lower_case_table_names= 0;\n  }\n  else\n  {\n    lower_case_file_system=\n      (test_if_case_insensitive(mysql_real_data_home) == 1);\n  }\n\n  /* Reset table_alias_charset, now that lower_case_table_names is set. */\n  table_alias_charset= (lower_case_table_names ?\n      &my_charset_utf8_tolower_ci :\n      &my_charset_bin);\n\n  /*\n    Build do_table and ignore_table rules to hush\n    after the resetting of table_alias_charset\n  */\n  if (rpl_filter->build_do_table_hash() ||\n      rpl_filter->build_ignore_table_hash())\n  {\n    sql_print_error(\"An error occurred while building do_table\"\n                    \"and ignore_table rules to hush.\");\n    return 1;\n  }\n\n  return 0;\n}\n\n\nstatic int init_thread_environment()\n{\n  mysql_mutex_init(key_LOCK_status, &LOCK_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_manager,\n                   &LOCK_manager, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_crypt, &LOCK_crypt, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_user_conn, &LOCK_user_conn, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_system_variables,\n                   &LOCK_global_system_variables, MY_MUTEX_INIT_FAST);\n  mysql_rwlock_init(key_rwlock_LOCK_system_variables_hash,\n                    &LOCK_system_variables_hash);\n  mysql_mutex_init(key_LOCK_prepared_stmt_count,\n                   &LOCK_prepared_stmt_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_sql_slave_skip_counter,\n                   &LOCK_sql_slave_skip_counter, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_slave_net_timeout,\n                   &LOCK_slave_net_timeout, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_error_messages,\n                   &LOCK_error_messages, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_uuid_generator,\n                   &LOCK_uuid_generator, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_sql_rand,\n                   &LOCK_sql_rand, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_log_throttle_qni,\n                   &LOCK_log_throttle_qni, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_offline_mode,\n                   &LOCK_offline_mode, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_default_password_lifetime,\n                   &LOCK_default_password_lifetime, MY_MUTEX_INIT_FAST);\n#ifdef HAVE_OPENSSL\n  mysql_mutex_init(key_LOCK_des_key_file,\n                   &LOCK_des_key_file, MY_MUTEX_INIT_FAST);\n#endif\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_connect, &LOCK_sys_init_connect);\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_slave, &LOCK_sys_init_slave);\n  mysql_cond_init(key_COND_manager, &COND_manager);\n  mysql_mutex_init(key_LOCK_server_started,\n                   &LOCK_server_started, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_keyring_operations,\n                   &LOCK_keyring_operations, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_server_started, &COND_server_started);\n  mysql_mutex_init(key_LOCK_reset_gtid_table,\n                   &LOCK_reset_gtid_table, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_compress_gtid_table,\n                   &LOCK_compress_gtid_table, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_compress_gtid_table,\n                  &COND_compress_gtid_table);\n  mysql_mutex_init(key_LOCK_group_replication_handler,\n                   &LOCK_group_replication_handler, MY_MUTEX_INIT_FAST);\n#ifndef EMBEDDED_LIBRARY\n  Events::init_mutexes();\n#if defined(_WIN32)\n  mysql_mutex_init(key_LOCK_handler_count,\n                   &LOCK_handler_count, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_handler_count, &COND_handler_count);\n#else\n  mysql_mutex_init(key_LOCK_socket_listener_active,\n                   &LOCK_socket_listener_active, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_socket_listener_active,\n                  &COND_socket_listener_active);\n  mysql_mutex_init(key_LOCK_start_signal_handler,\n                   &LOCK_start_signal_handler, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_start_signal_handler,\n                  &COND_start_signal_handler);\n#endif // _WIN32\n#endif // !EMBEDDED_LIBRARY\n  /* Parameter for threads created for connections */\n  (void) my_thread_attr_init(&connection_attrib);\n  my_thread_attr_setdetachstate(&connection_attrib, MY_THREAD_CREATE_DETACHED);\n#ifndef _WIN32\n  pthread_attr_setscope(&connection_attrib, PTHREAD_SCOPE_SYSTEM);\n#endif\n\n  DBUG_ASSERT(! THR_THD_initialized);\n  DBUG_ASSERT(! THR_MALLOC_initialized);\n  if (my_create_thread_local_key(&THR_THD,NULL) ||\n      my_create_thread_local_key(&THR_MALLOC,NULL))\n  {\n    sql_print_error(\"Can't create thread-keys\");\n    return 1;\n  }\n  THR_THD_initialized= true;\n  THR_MALLOC_initialized= true;\n  return 0;\n}\n\n#ifndef EMBEDDED_LIBRARY\nssl_artifacts_status auto_detect_ssl()\n{\n  MY_STAT cert_stat, cert_key, ca_stat;\n  uint result= 1;\n  ssl_artifacts_status ret_status= SSL_ARTIFACTS_VIA_OPTIONS;\n\n  if ((!opt_ssl_cert || !opt_ssl_cert[0]) &&\n      (!opt_ssl_key || !opt_ssl_key[0]) &&\n      (!opt_ssl_ca || !opt_ssl_ca[0]) &&\n      (!opt_ssl_capath || !opt_ssl_capath[0]) &&\n      (!opt_ssl_crl || !opt_ssl_crl[0]) &&\n      (!opt_ssl_crlpath || !opt_ssl_crlpath[0]))\n  {\n    result= result << (my_stat(DEFAULT_SSL_SERVER_CERT, &cert_stat, MYF(0)) ? 1 : 0)\n                   << (my_stat(DEFAULT_SSL_SERVER_KEY, &cert_key, MYF(0)) ? 1 : 0)\n                   << (my_stat(DEFAULT_SSL_CA_CERT, &ca_stat, MYF(0)) ? 1 : 0);\n\n    switch(result)\n    {\n      case 8:\n        opt_ssl_ca= (char *)DEFAULT_SSL_CA_CERT;\n        opt_ssl_cert= (char *)DEFAULT_SSL_SERVER_CERT;\n        opt_ssl_key= (char *)DEFAULT_SSL_SERVER_KEY;\n        ret_status= SSL_ARTIFACTS_AUTO_DETECTED;\n        break;\n      case 4:\n      case 2:\n        ret_status= SSL_ARTIFACT_TRACES_FOUND;\n        break;\n      default:\n        ret_status= SSL_ARTIFACTS_NOT_FOUND;\n        break;\n    };\n  }\n\n  return ret_status;\n}\n\nint warn_one(const char *file_name)\n{\n  FILE *fp;\n  char *issuer= NULL;\n  char *subject= NULL;\n\n  if (!(fp= my_fopen(file_name, O_RDONLY | O_BINARY, MYF(MY_WME))))\n  {\n    sql_print_error(\"Error opening CA certificate file\");\n    return 1;\n  }\n\n  X509 *ca_cert= PEM_read_X509(fp, 0, 0, 0);\n\n  if (!ca_cert)\n  {\n    /* We are not interested in anything other than X509 certificates */\n    my_fclose(fp, MYF(MY_WME));\n    return 0;\n  }\n\n  issuer= X509_NAME_oneline(X509_get_issuer_name(ca_cert), 0, 0);\n  subject= X509_NAME_oneline(X509_get_subject_name(ca_cert), 0, 0);\n\n  if (!strcmp(issuer, subject))\n  {\n    sql_print_warning(\"CA certificate %s is self signed.\", file_name);\n  }\n\n  OPENSSL_free(issuer);\n  OPENSSL_free(subject);\n  X509_free(ca_cert);\n  my_fclose(fp, MYF(MY_WME));\n  return 0;\n\n}\n\nint warn_self_signed_ca()\n{\n  int ret_val= 0;\n  if (opt_ssl_ca && opt_ssl_ca[0])\n  {\n    if (warn_one(opt_ssl_ca))\n      return 1;\n  }\n#ifndef HAVE_YASSL\n  if (opt_ssl_capath && opt_ssl_capath[0])\n  {\n    /* We have ssl-capath. So search all files in the dir */\n    MY_DIR *ca_dir;\n    uint file_count;\n    DYNAMIC_STRING file_path;\n    char dir_separator[FN_REFLEN];\n    size_t dir_path_length;\n\n    init_dynamic_string(&file_path, opt_ssl_capath, FN_REFLEN, FN_REFLEN);\n    dir_separator[0]= FN_LIBCHAR;\n    dir_separator[1]= 0;\n    dynstr_append(&file_path, dir_separator);\n    dir_path_length= file_path.length;\n\n    if (!(ca_dir= my_dir(opt_ssl_capath,MY_WANT_STAT|MY_DONT_SORT|MY_WME)))\n    {\n      sql_print_error(\"Error accessing directory pointed by --ssl-capath\");\n      return 1;\n    }\n\n    for (file_count = 0; file_count < ca_dir->number_off_files; file_count++)\n    {\n      if (!MY_S_ISDIR(ca_dir->dir_entry[file_count].mystat->st_mode))\n      {\n        file_path.length= dir_path_length;\n        dynstr_append(&file_path, ca_dir->dir_entry[file_count].name);\n        if ((ret_val= warn_one(file_path.str)))\n          break;\n      }\n    }\n    my_dirend(ca_dir);\n    dynstr_free(&file_path);\n\n    ca_dir= 0;\n    memset(&file_path, 0, sizeof(file_path));\n  }\n#endif /* HAVE_YASSL */\n  return ret_val;\n}\n\n#endif /* EMBEDDED_LIBRARY */\n\nstatic int init_ssl()\n{\n#ifdef HAVE_OPENSSL\n#ifndef HAVE_YASSL\n  CRYPTO_malloc_init();\n#endif\n  ssl_start();\n#ifndef EMBEDDED_LIBRARY\n\n  if (opt_use_ssl)\n  {\n    ssl_artifacts_status auto_detection_status= auto_detect_ssl();\n    if (auto_detection_status == SSL_ARTIFACTS_AUTO_DETECTED)\n      sql_print_information(\"Found %s, %s and %s in data directory. \"\n                            \"Trying to enable SSL support using them.\",\n                            DEFAULT_SSL_CA_CERT, DEFAULT_SSL_SERVER_CERT,\n                            DEFAULT_SSL_SERVER_KEY);\n#ifndef HAVE_YASSL\n    if (do_auto_cert_generation(auto_detection_status) == false)\n      return 1;\n#endif\n\n    enum enum_ssl_init_error error= SSL_INITERR_NOERROR;\n    long ssl_ctx_flags= process_tls_version(opt_tls_version);\n    /* having ssl_acceptor_fd != 0 signals the use of SSL */\n    ssl_acceptor_fd= new_VioSSLAcceptorFd(opt_ssl_key, opt_ssl_cert,\n\t\t\t\t\t  opt_ssl_ca, opt_ssl_capath,\n\t\t\t\t\t  opt_ssl_cipher, &error,\n                                          opt_ssl_crl, opt_ssl_crlpath, ssl_ctx_flags);\n    DBUG_PRINT(\"info\",(\"ssl_acceptor_fd: 0x%lx\", (long) ssl_acceptor_fd));\n    ERR_remove_state(0);\n    if (!ssl_acceptor_fd)\n    {\n      /*\n        No real need for opt_use_ssl to be enabled in bootstrap mode,\n        but we want the SSL materal generation and/or validation (if supplied).\n        So we keep it on.\n\n        For yaSSL (since it can't auto-generate the certs from inside the\n        server) we need to hush the warning if in bootstrap mode, as in\n        that mode the server won't be listening for connections and thus\n        the lack of SSL material makes no real difference.\n        However if the user specified any of the --ssl options we keep the\n        warning as it's showing problems with the values supplied.\n\n        For openssl, we don't hush the option since it would indicate a failure\n        in auto-generation, bad key material explicitly specified or\n        auto-generation disabled explcitly while SSL is still on.\n      */\n#ifdef HAVE_YASSL\n      if (!opt_bootstrap || SSL_ARTIFACTS_NOT_FOUND != auto_detection_status)\n#endif\n      {\n        sql_print_warning(\"Failed to set up SSL because of the\"\n                          \" following SSL library error: %s\",\n                          sslGetErrString(error));\n      }\n      opt_use_ssl = 0;\n      have_ssl= SHOW_OPTION_DISABLED;\n    }\n    else\n    {\n      /* Check if CA certificate is self signed */\n      if (warn_self_signed_ca())\n        return 1;\n      /* create one SSL that we can use to read information from */\n      if (!(ssl_acceptor= SSL_new(ssl_acceptor_fd->ssl_context)))\n        return 1;\n    }\n  }\n  else\n  {\n    have_ssl= SHOW_OPTION_DISABLED;\n  }\n#else\n  have_ssl= SHOW_OPTION_DISABLED;\n#endif /* ! EMBEDDED_LIBRARY */\n  if (des_key_file)\n    load_des_key_file(des_key_file);\n#ifndef HAVE_YASSL\n  if (init_rsa_keys())\n    return 1;\n#endif\n#endif /* HAVE_OPENSSL */\n  return 0;\n}\n\n\nstatic void end_ssl()\n{\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  if (ssl_acceptor_fd)\n  {\n    if (ssl_acceptor)\n      SSL_free(ssl_acceptor);\n    free_vio_ssl_acceptor_fd(ssl_acceptor_fd);\n    ssl_acceptor_fd= 0;\n  }\n#endif /* ! EMBEDDED_LIBRARY */\n#ifndef HAVE_YASSL\n  deinit_rsa_keys();\n#endif\n#endif /* HAVE_OPENSSL */\n}\n\n/**\n  Generate a UUID and save it into server_uuid variable.\n\n  @return Retur 0 or 1 if an error occurred.\n */\nstatic int generate_server_uuid()\n{\n  THD *thd;\n  Item_func_uuid *func_uuid;\n  String uuid;\n\n  /*\n    To be able to run this from boot, we allocate a temporary THD\n   */\n  if (!(thd=new THD))\n  {\n    sql_print_error(\"Failed to generate a server UUID because it is failed\"\n                    \" to allocate the THD.\");\n    return 1;\n  }\n\n  thd->thread_stack= (char*) &thd;\n  thd->store_globals();\n\n  /*\n    Initialize the variables which are used during \"uuid generator\n    initialization\" with values that should normally differ between\n    mysqlds on the same host. This avoids that another mysqld started\n    at the same time on the same host get the same \"server_uuid\".\n  */\n  sql_print_information(\"Salting uuid generator variables, current_pid: %lu, \"\n                        \"server_start_time: %lu, bytes_sent: %llu, \",\n                        current_pid,\n                        (ulong)server_start_time, thd->status_var.bytes_sent);\n\n  const time_t save_server_start_time= server_start_time;\n  server_start_time+= ((ulonglong)current_pid << 48) + current_pid;\n  thd->status_var.bytes_sent= (ulonglong)thd;\n\n  lex_start(thd);\n  func_uuid= new (thd->mem_root) Item_func_uuid();\n  func_uuid->fixed= 1;\n  func_uuid->val_str(&uuid);\n\n  sql_print_information(\"Generated uuid: '%s', \"\n                        \"server_start_time: %lu, bytes_sent: %llu\",\n                        uuid.c_ptr(),\n                        (ulong)server_start_time, thd->status_var.bytes_sent);\n  // Restore global variables used for salting\n  server_start_time = save_server_start_time;\n\n  delete thd;\n\n  strncpy(server_uuid, uuid.c_ptr(), UUID_LENGTH);\n  DBUG_EXECUTE_IF(\"server_uuid_deterministic\",\n                  strncpy(server_uuid, \"00000000-1111-0000-1111-000000000000\", UUID_LENGTH););\n  server_uuid[UUID_LENGTH]= '\\0';\n  return 0;\n}\n\n/**\n  Save all options which was auto-generated by server-self into the given file.\n\n  @param fname The name of the file in which the auto-generated options will b\n  e saved.\n\n  @return Return 0 or 1 if an error occurred.\n */\nint flush_auto_options(const char* fname)\n{\n  File fd;\n  IO_CACHE io_cache;\n  int result= 0;\n\n  if ((fd= my_open(fname, O_CREAT|O_RDWR, MYF(MY_WME))) < 0)\n  {\n    sql_print_error(\"Failed to create file(file: '%s', errno %d)\", fname, my_errno());\n    return 1;\n  }\n\n  if (init_io_cache(&io_cache, fd, IO_SIZE*2, WRITE_CACHE, 0L, 0, MYF(MY_WME)))\n  {\n    sql_print_error(\"Failed to create a cache on (file: %s', errno %d)\", fname, my_errno());\n    my_close(fd, MYF(MY_WME));\n    return 1;\n  }\n\n  my_b_seek(&io_cache, 0L);\n  my_b_printf(&io_cache, \"%s\\n\", \"[auto]\");\n  my_b_printf(&io_cache, \"server-uuid=%s\\n\", server_uuid);\n\n  if (flush_io_cache(&io_cache) || my_sync(fd, MYF(MY_WME)))\n    result= 1;\n\n  my_close(fd, MYF(MY_WME));\n  end_io_cache(&io_cache);\n  return result;\n}\n\n/**\n  File 'auto.cnf' resides in the data directory to hold values of options that\n  server evaluates itself and that needs to be durable to sustain the server\n  restart. There is only a section ['auto'] in the file. All these options are\n  in the section. Only one option exists now, it is server_uuid.\n  Note, the user may not supply any literal value to these auto-options, and\n  only allowed to trigger (re)evaluation.\n  For instance, 'server_uuid' value will be evaluated and stored if there is\n  no corresponding line in the file.\n  Because of the specifics of the auto-options, they need a seperate storage.\n  Meanwhile, it is the 'auto.cnf' that has the same structure as 'my.cnf'.\n\n  @todo consider to implement sql-query-able persistent storage by WL#5279.\n  @return Return 0 or 1 if an error occurred.\n */\nstatic int init_server_auto_options()\n{\n  bool flush= false;\n  char fname[FN_REFLEN];\n  char *name= (char *)\"auto\";\n  const char *groups[]= {\"auto\", NULL};\n  char *uuid= 0;\n  my_option auto_options[]= {\n    {\"server-uuid\", 0, \"\", &uuid, &uuid,\n      0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n  };\n\n  DBUG_ENTER(\"init_server_auto_options\");\n\n  if (NULL == fn_format(fname, \"auto.cnf\", mysql_data_home, \"\",\n                        MY_UNPACK_FILENAME | MY_SAFE_PATH))\n    DBUG_RETURN(1);\n\n  /* load_defaults require argv[0] is not null */\n  char **argv= &name;\n  int argc= 1;\n  if (!check_file_permissions(fname, false))\n  {\n    /*\n      Found a world writable file hence removing it as it is dangerous to write\n      a new UUID into the same file.\n     */\n    my_delete(fname,MYF(MY_WME));\n    sql_print_warning(\"World-writable config file '%s' has been removed.\\n\",\n                      fname);\n  }\n\n  /* load all options in 'auto.cnf'. */\n  if (my_load_defaults(fname, groups, &argc, &argv, NULL))\n    DBUG_RETURN(1);\n\n  /*\n    Record the origial pointer allocated by my_load_defaults for free,\n    because argv will be changed by handle_options\n   */\n  char **old_argv= argv;\n  if (handle_options(&argc, &argv, auto_options, mysqld_get_one_option))\n    DBUG_RETURN(1);\n\n  DBUG_PRINT(\"info\", (\"uuid=%p=%s server_uuid=%s\", uuid, uuid, server_uuid));\n  if (uuid)\n  {\n    if (!Uuid::is_valid(uuid))\n    {\n      sql_print_error(\"The server_uuid stored in auto.cnf file is not a valid UUID.\");\n      goto err;\n    }\n    /*\n      Uuid::is_valid() cannot do strict check on the length as it will be\n      called by GTID::is_valid() as well (GTID = UUID:seq_no). We should\n      explicitly add the *length check* here in this function.\n\n      If UUID length is less than '36' (UUID_LENGTH), that error case would have\n      got caught in above is_valid check. The below check is to make sure that\n      length is not greater than UUID_LENGTH i.e., there are no extra characters\n      (Garbage) at the end of the valid UUID.\n    */\n    if (strlen(uuid) > UUID_LENGTH)\n    {\n      sql_print_error(\"Garbage characters found at the end of the server_uuid \"\n                      \"value in auto.cnf file. It should be of length '%d' \"\n                      \"(UUID_LENGTH). Clear it and restart the server. \",\n                      UUID_LENGTH);\n      goto err;\n    }\n    strcpy(server_uuid, uuid);\n  }\n  else\n  {\n    DBUG_PRINT(\"info\", (\"generating server_uuid\"));\n    flush= TRUE;\n    /* server_uuid will be set in the function */\n    if (generate_server_uuid())\n      goto err;\n    DBUG_PRINT(\"info\", (\"generated server_uuid=%s\", server_uuid));\n    sql_print_warning(\"No existing UUID has been found, so we assume that this\"\n                      \" is the first time that this server has been started.\"\n                      \" Generating a new UUID: %s.\",\n                      server_uuid);\n  }\n  /*\n    The uuid has been copied to server_uuid, so the memory allocated by\n    my_load_defaults can be freed now.\n   */\n  free_defaults(old_argv);\n\n  if (flush)\n    DBUG_RETURN(flush_auto_options(fname));\n  DBUG_RETURN(0);\nerr:\n  free_defaults(argv);\n  DBUG_RETURN(1);\n}\n\n\nstatic bool\ninitialize_storage_engine(char *se_name, const char *se_kind,\n                          plugin_ref *dest_plugin)\n{\n  LEX_STRING name= { se_name, strlen(se_name) };\n  plugin_ref plugin;\n  handlerton *hton;\n  if ((plugin= ha_resolve_by_name(0, &name, FALSE)))\n    hton= plugin_data<handlerton*>(plugin);\n  else\n  {\n    sql_print_error(\"Unknown/unsupported storage engine: %s\", se_name);\n    return true;\n  }\n  if (!ha_storage_engine_is_enabled(hton))\n  {\n    if (!opt_bootstrap)\n    {\n      sql_print_error(\"Default%s storage engine (%s) is not available\",\n                      se_kind, se_name);\n      return true;\n    }\n    DBUG_ASSERT(*dest_plugin);\n  }\n  else\n  {\n    /*\n      Need to unlock as global_system_variables.table_plugin\n      was acquired during plugin_init()\n    */\n    plugin_unlock(0, *dest_plugin);\n    *dest_plugin= plugin;\n  }\n  return false;\n}\n\n\nstatic void init_server_query_cache()\n{\n  ulong set_cache_size;\n\n  query_cache.set_min_res_unit(query_cache_min_res_unit);\n  query_cache.init();\n\t\n  set_cache_size= query_cache.resize(query_cache_size);\n  if (set_cache_size != query_cache_size)\n  {\n    sql_print_warning(ER_DEFAULT(ER_WARN_QC_RESIZE), query_cache_size,\n                      set_cache_size);\n    query_cache_size= set_cache_size;\n  }\n}\n\n\nstatic int init_server_components()\n{\n  DBUG_ENTER(\"init_server_components\");\n  /*\n    We need to call each of these following functions to ensure that\n    all things are initialized so that unireg_abort() doesn't fail\n  */\n  mdl_init();\n  partitioning_init();\n  if (table_def_init() | hostname_cache_init(host_cache_size))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n  if (my_timer_initialize())\n    sql_print_error(\"Failed to initialize timer component (errno %d).\", errno);\n  else\n    have_statement_timeout= SHOW_OPTION_YES;\n\n  init_server_query_cache();\n\n  randominit(&sql_rand,(ulong) server_start_time,(ulong) server_start_time/2);\n  setup_fpu();\n#ifdef HAVE_REPLICATION\n  init_slave_list();\n#endif\n\n  /* Setup logs */\n\n  /*\n    Enable old-fashioned error log, except when the user has requested\n    help information. Since the implementation of plugin server\n    variables the help output is now written much later.\n\n    log_error_dest can be:\n    disabled_my_option     --log-error was not used or --log-error=\n    \"\"                     --log-error without arguments (no '=')\n    filename               --log-error=filename\n  */\n#ifdef _WIN32\n  /*\n    Enable the error log file only if console option is not specified\n    and --help is not used.\n  */\n  bool log_errors_to_file= !opt_help && !opt_console;\n#else\n  /*\n    Enable the error log file only if --log-error=filename or --log-error\n    was used. Logging to file is disabled by default unlike on Windows.\n  */\n  bool log_errors_to_file= !opt_help && (log_error_dest != disabled_my_option);\n#endif\n\n  if (log_errors_to_file)\n  {\n    // Construct filename if no filename was given by the user.\n    if (!log_error_dest[0] || log_error_dest == disabled_my_option)\n      fn_format(errorlog_filename_buff, pidfile_name, mysql_data_home, \".err\",\n                MY_REPLACE_EXT); /* replace '.<domain>' by '.err', bug#4997 */\n    else\n      fn_format(errorlog_filename_buff, log_error_dest, mysql_data_home, \".err\",\n                MY_UNPACK_FILENAME);\n    /*\n      log_error_dest may have been set to disabled_my_option or \"\" if no\n      argument was passed, but we need to show the real name in SHOW VARIABLES.\n    */\n    log_error_dest= errorlog_filename_buff;\n\n    if (open_error_log(errorlog_filename_buff))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n#ifdef _WIN32\n    FreeConsole();        // Remove window\n#endif\n  }\n  else\n  {\n    // We are logging to stderr and SHOW VARIABLES should reflect that.\n    log_error_dest= \"stderr\";\n    // Flush messages buffered so far.\n    flush_error_log_messages();\n  }\n\n  enter_cond_hook= thd_enter_cond;\n  exit_cond_hook= thd_exit_cond;\n  is_killed_hook= (int(*)(const void*))thd_killed;\n\n  if (transaction_cache_init())\n  {\n    sql_print_error(\"Out of memory\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /*\n    initialize delegates for extension observers, errors have already\n    been reported in the function\n  */\n  if (delegates_init())\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n  /* need to configure logging before initializing storage engines */\n  if (opt_log_slave_updates && !opt_bin_log)\n  {\n    sql_print_warning(\"You need to use --log-bin to make \"\n                    \"--log-slave-updates work.\");\n  }\n  if (binlog_format_used && !opt_bin_log)\n    sql_print_warning(\"You need to use --log-bin to make \"\n                      \"--binlog-format work.\");\n\n  /* Check that we have not let the format to unspecified at this point */\n  DBUG_ASSERT((uint)global_system_variables.binlog_format <=\n              array_elements(binlog_format_names)-1);\n\n#ifdef HAVE_REPLICATION\n  if (opt_log_slave_updates && replicate_same_server_id)\n  {\n    if (opt_bin_log)\n    {\n      sql_print_error(\"using --replicate-same-server-id in conjunction with \\\n--log-slave-updates is impossible, it would lead to infinite loops in this \\\nserver.\");\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n    else\n      sql_print_warning(\"using --replicate-same-server-id in conjunction with \\\n--log-slave-updates would lead to infinite loops in this server. However this \\\nwill be ignored as the --log-bin option is not defined.\");\n  }\n#endif\n\n  opt_server_id_mask = ~ulong(0);\n#ifdef HAVE_REPLICATION\n  opt_server_id_mask = (opt_server_id_bits == 32)?\n    ~ ulong(0) : (1 << opt_server_id_bits) -1;\n  if (server_id != (server_id & opt_server_id_mask))\n  {\n    sql_print_error(\"server-id configured is too large to represent with\"\n                    \"server-id-bits configured.\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n#endif\n\n  if (opt_bin_log)\n  {\n    /* Reports an error and aborts, if the --log-bin's path\n       is a directory.*/\n    if (opt_bin_logname &&\n        opt_bin_logname[strlen(opt_bin_logname) - 1] == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \\\na file name for --log-bin option\", opt_bin_logname);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    /* Reports an error and aborts, if the --log-bin-index's path\n       is a directory.*/\n    if (opt_binlog_index_name &&\n        opt_binlog_index_name[strlen(opt_binlog_index_name) - 1]\n        == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \\\na file name for --log-bin-index option\", opt_binlog_index_name);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    char buf[FN_REFLEN];\n    const char *ln;\n    ln= mysql_bin_log.generate_name(opt_bin_logname, \"-bin\", buf);\n    if (!opt_bin_logname && !opt_binlog_index_name)\n    {\n      /*\n        User didn't give us info to name the binlog index file.\n        Picking `hostname`-bin.index like did in 4.x, causes replication to\n        fail if the hostname is changed later. So, we would like to instead\n        require a name. But as we don't want to break many existing setups, we\n        only give warning, not error.\n      */\n      sql_print_warning(\"No argument was provided to --log-bin, and \"\n                        \"--log-bin-index was not used; so replication \"\n                        \"may break when this MySQL server acts as a \"\n                        \"master and has his hostname changed!! Please \"\n                        \"use '--log-bin=%s' to avoid this problem.\", ln);\n    }\n    if (ln == buf)\n    {\n      my_free(opt_bin_logname);\n      opt_bin_logname=my_strdup(key_memory_opt_bin_logname,\n                                buf, MYF(0));\n    }\n\n    /*\n      Skip opening the index file if we start with --help. This is necessary\n      to avoid creating the file in an otherwise empty datadir, which will\n      cause a succeeding 'mysqld --initialize' to fail.\n    */\n    if (!opt_help && mysql_bin_log.open_index_file(opt_binlog_index_name, ln, TRUE))\n    {\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n  }\n\n  if (opt_bin_log)\n  {\n    /*\n      opt_bin_logname[0] needs to be checked to make sure opt binlog name is\n      not an empty string, incase it is an empty string default file\n      extension will be passed\n     */\n    log_bin_basename=\n      rpl_make_log_name(key_memory_MYSQL_BIN_LOG_basename,\n                        opt_bin_logname, default_logfile_name,\n                        (opt_bin_logname && opt_bin_logname[0]) ? \"\" : \"-bin\");\n    log_bin_index=\n      rpl_make_log_name(key_memory_MYSQL_BIN_LOG_index,\n                        opt_binlog_index_name, log_bin_basename, \".index\");\n    if (log_bin_basename == NULL || log_bin_index == NULL)\n    {\n      sql_print_error(\"Unable to create replication path names:\"\n                      \" out of memory or path names too long\"\n                      \" (path name exceeds \" STRINGIFY_ARG(FN_REFLEN)\n                      \" or file name exceeds \" STRINGIFY_ARG(FN_LEN) \").\");\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n  }\n\n#ifndef EMBEDDED_LIBRARY\n  DBUG_PRINT(\"debug\",\n             (\"opt_bin_logname: %s, opt_relay_logname: %s, pidfile_name: %s\",\n              opt_bin_logname, opt_relay_logname, pidfile_name));\n  /*\n    opt_relay_logname[0] needs to be checked to make sure opt relaylog name is\n    not an empty string, incase it is an empty string default file\n    extension will be passed\n   */\n  relay_log_basename=\n    rpl_make_log_name(key_memory_MYSQL_RELAY_LOG_basename,\n                      opt_relay_logname, default_logfile_name,\n                      (opt_relay_logname && opt_relay_logname[0]) ? \"\" : \"-relay-bin\");\n\n  if (relay_log_basename != NULL)\n    relay_log_index=\n      rpl_make_log_name(key_memory_MYSQL_RELAY_LOG_index,\n                        opt_relaylog_index_name, relay_log_basename, \".index\");\n\n  if (relay_log_basename == NULL || relay_log_index == NULL)\n  {\n    sql_print_error(\"Unable to create replication path names:\"\n                    \" out of memory or path names too long\"\n                    \" (path name exceeds \" STRINGIFY_ARG(FN_REFLEN)\n                    \" or file name exceeds \" STRINGIFY_ARG(FN_LEN) \").\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n#endif /* !EMBEDDED_LIBRARY */\n\n  /* call ha_init_key_cache() on all key caches to init them */\n  process_key_caches(&ha_init_key_cache);\n\n  /* Allow storage engine to give real error messages */\n  if (ha_init_errors())\n    DBUG_RETURN(1);\n\n  if (opt_ignore_builtin_innodb)\n    sql_print_warning(\"ignore-builtin-innodb is ignored \"\n                      \"and will be removed in future releases.\");\n  if (gtid_server_init())\n  {\n    sql_print_error(\"Failed to initialize GTID structures.\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /*\n    Set tc_log to point to TC_LOG_DUMMY early in order to allow plugin_init()\n    to commit attachable transaction after reading from mysql.plugin table.\n    If necessary tc_log will be adjusted to point to correct TC_LOG instance\n    later.\n  */\n  tc_log= &tc_log_dummy;\n\n  /*Load early plugins */\n  if (plugin_register_early_plugins(&remaining_argc, remaining_argv,\n                                    opt_help ?\n                                      PLUGIN_INIT_SKIP_INITIALIZATION : 0))\n  {\n    sql_print_error(\"Failed to initialize early plugins.\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  /* Load builtin plugins, initialize MyISAM, CSV and InnoDB */\n  if (plugin_register_builtin_and_init_core_se(&remaining_argc,\n                                               remaining_argv))\n  {\n    sql_print_error(\"Failed to initialize builtin plugins.\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  /*\n    Skip reading the plugin table when starting with --help in order\n    to also skip initializing InnoDB. This provides a simpler and more\n    uniform handling of various startup use cases, e.g. when the data\n    directory does not exist, exists but is empty, exists with InnoDB\n    system tablespaces present etc.\n  */\n  if (plugin_register_dynamic_and_init_all(&remaining_argc, remaining_argv,\n                  (opt_noacl ? PLUGIN_INIT_SKIP_PLUGIN_TABLE : 0) |\n                  (opt_help ? (PLUGIN_INIT_SKIP_INITIALIZATION |\n                               PLUGIN_INIT_SKIP_PLUGIN_TABLE) : 0)))\n  {\n    sql_print_error(\"Failed to initialize dynamic plugins.\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  plugins_are_initialized= TRUE;  /* Don't separate from init function */\n\n  Session_tracker session_track_system_variables_check;\n  LEX_STRING var_list;\n  char *tmp_str;\n  size_t len= strlen(global_system_variables.track_sysvars_ptr);\n  tmp_str= (char *)my_malloc(PSI_NOT_INSTRUMENTED, len*sizeof(char)+2,\n                             MYF(MY_WME));\n  strcpy(tmp_str,global_system_variables.track_sysvars_ptr);\n  var_list.length= len;\n  var_list.str= tmp_str;\n  if (session_track_system_variables_check.server_boot_verify(system_charset_info,\n\t                                                      var_list))\n  {\n    sql_print_error(\"The variable session_track_system_variables either has \"\n\t            \"duplicate values or invalid values.\");\n    if (tmp_str)\n      my_free(tmp_str);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  if (tmp_str)\n    my_free(tmp_str);\n  /* we do want to exit if there are any other unknown options */\n  if (remaining_argc > 1)\n  {\n    int ho_error;\n    struct my_option no_opts[]=\n    {\n      {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n    };\n    /*\n      We need to eat any 'loose' arguments first before we conclude\n      that there are unprocessed options.\n    */\n    my_getopt_skip_unknown= 0;\n\n    if ((ho_error= handle_options(&remaining_argc, &remaining_argv, no_opts,\n                                  mysqld_get_one_option)))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n    my_getopt_skip_unknown= TRUE;\n\n    if (remaining_argc > 1)\n    {\n      sql_print_error(\"Too many arguments (first extra is '%s').\",\n                      remaining_argv[1]);\n      sql_print_information(\"Use --verbose --help to get a list \"\n                            \"of available options!\");\n      unireg_abort(MYSQLD_ABORT_EXIT);\n\n    }\n  }\n\n  if (opt_help)\n    unireg_abort(MYSQLD_SUCCESS_EXIT);\n\n  /* if the errmsg.sys is not loaded, terminate to maintain behaviour */\n  if (!my_default_lc_messages->errmsgs->is_loaded())\n  {\n    sql_print_error(\"Unable to read errmsg.sys file\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /* We have to initialize the storage engines before CSV logging */\n  if (ha_init())\n  {\n    sql_print_error(\"Can't init databases\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (opt_bootstrap)\n    log_output_options= LOG_FILE;\n\n  /*\n    Issue a warning if there were specified additional options to the\n    log-output along with NONE. Probably this wasn't what user wanted.\n  */\n  if ((log_output_options & LOG_NONE) && (log_output_options & ~LOG_NONE))\n    sql_print_warning(\"There were other values specified to \"\n                      \"log-output besides NONE. Disabling slow \"\n                      \"and general logs anyway.\");\n\n  if (log_output_options & LOG_TABLE)\n  {\n    /* Fall back to log files if the csv engine is not loaded. */\n    LEX_CSTRING csv_name={C_STRING_WITH_LEN(\"csv\")};\n    if (!plugin_is_ready(csv_name, MYSQL_STORAGE_ENGINE_PLUGIN))\n    {\n      sql_print_error(\"CSV engine is not present, falling back to the \"\n                      \"log files\");\n      log_output_options= (log_output_options & ~LOG_TABLE) | LOG_FILE;\n    }\n  }\n\n  query_logger.set_handlers(log_output_options);\n\n  // Open slow log file if enabled.\n  if (opt_slow_log && query_logger.reopen_log_file(QUERY_LOG_SLOW))\n    opt_slow_log= false;\n\n  // Open general log file if enabled.\n  if (opt_general_log && query_logger.reopen_log_file(QUERY_LOG_GENERAL))\n    opt_general_log= false;\n\n  /*\n    Set the default storage engines\n  */\n  if (initialize_storage_engine(default_storage_engine, \"\",\n                                &global_system_variables.table_plugin))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  if (initialize_storage_engine(default_tmp_storage_engine, \" temp\",\n                                &global_system_variables.temp_table_plugin))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n  if (!opt_bootstrap && !opt_noacl)\n  {\n    std::string disabled_se_str(opt_disabled_storage_engines);\n    ha_set_normalized_disabled_se_str(disabled_se_str);\n\n    // Log warning if default_storage_engine is a disabled storage engine.\n    handlerton *default_se_handle=\n      plugin_data<handlerton*>(global_system_variables.table_plugin);\n    if (ha_is_storage_engine_disabled(default_se_handle))\n      sql_print_warning(\"default_storage_engine is set to a \"\n                        \"disabled storage engine %s.\", default_storage_engine);\n\n    // Log warning if default_tmp_storage_engine is a disabled storage engine.\n    handlerton *default_tmp_se_handle=\n      plugin_data<handlerton*>(global_system_variables.temp_table_plugin);\n    if (ha_is_storage_engine_disabled(default_tmp_se_handle))\n      sql_print_warning(\"default_tmp_storage_engine is set to a \"\n                        \"disabled storage engine %s.\",\n                        default_tmp_storage_engine);\n\n  }\n\n  if (total_ha_2pc > 1 || (1 == total_ha_2pc && opt_bin_log))\n  {\n    if (opt_bin_log)\n      tc_log= &mysql_bin_log;\n    else\n      tc_log= &tc_log_mmap;\n  }\n\n  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file))\n  {\n    sql_print_error(\"Can't init tc log\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  (void)RUN_HOOK(server_state, before_recovery, (NULL));\n\n  if (ha_recover(0))\n  {\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /// @todo: this looks suspicious, revisit this /sven\n  enum_gtid_mode gtid_mode= get_gtid_mode(GTID_MODE_LOCK_NONE);\n\n  if (gtid_mode == GTID_MODE_ON &&\n      _gtid_consistency_mode != GTID_CONSISTENCY_MODE_ON)\n  {\n    sql_print_error(\"GTID_MODE = ON requires ENFORCE_GTID_CONSISTENCY = ON.\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (opt_bin_log)\n  {\n    /*\n      Configures what object is used by the current log to store processed\n      gtid(s). This is necessary in the MYSQL_BIN_LOG::MYSQL_BIN_LOG to\n      corretly compute the set of previous gtids.\n    */\n    DBUG_ASSERT(!mysql_bin_log.is_relay_log);\n    mysql_mutex_t *log_lock= mysql_bin_log.get_log_lock();\n    mysql_mutex_lock(log_lock);\n\n    if (mysql_bin_log.open_binlog(opt_bin_logname, 0,\n                                  max_binlog_size, false,\n                                  true/*need_lock_index=true*/,\n                                  true/*need_sid_lock=true*/,\n                                  NULL))\n    {\n      mysql_mutex_unlock(log_lock);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n    mysql_mutex_unlock(log_lock);\n  }\n\n#ifdef HAVE_REPLICATION\n  if (opt_bin_log && expire_logs_days)\n  {\n    time_t purge_time= server_start_time - expire_logs_days*24*60*60;\n    if (purge_time >= 0)\n      mysql_bin_log.purge_logs_before_date(purge_time, true);\n  }\n#endif\n\n  if (opt_myisam_log)\n    (void) mi_log(1);\n\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT) && !defined(EMBEDDED_LIBRARY)\n  if (locked_in_memory && !getuid())\n  {\n    if (setreuid((uid_t)-1, 0) == -1)\n    {                        // this should never happen\n      sql_print_error(\"setreuid: %s\", strerror(errno));\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n    if (mlockall(MCL_CURRENT))\n    {\n      sql_print_warning(\"Failed to lock memory. Errno: %d\\n\",errno); /* purecov: inspected */\n      locked_in_memory= 0;\n    }\n#ifndef _WIN32\n    if (user_info)\n      set_user(mysqld_user, user_info);\n#endif\n  }\n  else\n#endif\n    locked_in_memory=0;\n\n  /* Initialize the optimizer cost module */\n  init_optimizer_cost_module(true);\n  ft_init_stopwords();\n\n  init_max_user_conn();\n  init_update_queries();\n  DBUG_RETURN(0);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n#ifdef _WIN32\n\nextern \"C\" void *handle_shutdown(void *arg)\n{\n  MSG msg;\n  my_thread_init();\n  /* This call should create the message queue for this thread. */\n  PeekMessage(&msg, NULL, 1, 65534,PM_NOREMOVE);\n  if (WaitForSingleObject(hEventShutdown,INFINITE)==WAIT_OBJECT_0)\n  {\n    sql_print_information(ER_DEFAULT(ER_NORMAL_SHUTDOWN), my_progname);\n    abort_loop= true;\n    close_connections();\n    my_thread_end();\n    my_thread_exit(0);\n  }\n  return 0;\n}\n\n\nstatic void create_shutdown_thread()\n{\n  hEventShutdown=CreateEvent(0, FALSE, FALSE, shutdown_event_name);\n  my_thread_attr_t thr_attr;\n  DBUG_ENTER(\"create_shutdown_thread\");\n\n  my_thread_attr_init(&thr_attr);\n\n  if (my_thread_create(&shutdown_thr_handle, &thr_attr, handle_shutdown, 0))\n    sql_print_warning(\"Can't create thread to handle shutdown requests\"\n                      \" (errno= %d)\", errno);\n  my_thread_attr_destroy(&thr_attr);\n  // On \"Stop Service\" we have to do regular shutdown\n  Service.SetShutdownEvent(hEventShutdown);\n}\n#endif /* _WIN32 */\n\n#ifndef DBUG_OFF\n/*\n  Debugging helper function to keep the locale database\n  (see sql_locale.cc) and max_month_name_length and\n  max_day_name_length variable values in consistent state.\n*/\nstatic void test_lc_time_sz()\n{\n  DBUG_ENTER(\"test_lc_time_sz\");\n  for (MY_LOCALE **loc= my_locales; *loc; loc++)\n  {\n    size_t max_month_len= 0;\n    size_t max_day_len = 0;\n    for (const char **month= (*loc)->month_names->type_names; *month; month++)\n    {\n      set_if_bigger(max_month_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *month, *month + strlen(*month)));\n    }\n    for (const char **day= (*loc)->day_names->type_names; *day; day++)\n    {\n      set_if_bigger(max_day_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *day, *day + strlen(*day)));\n    }\n    if ((*loc)->max_month_name_length != max_month_len ||\n        (*loc)->max_day_name_length != max_day_len)\n    {\n      DBUG_PRINT(\"Wrong max day name(or month name) length for locale:\",\n                 (\"%s\", (*loc)->name));\n      DBUG_ASSERT(0);\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n#endif//DBUG_OFF\n\n/*\n  @brief : Set opt_super_readonly to user supplied value before\n           enabling communication channels to accept user connections\n*/\n\nstatic void set_super_read_only_post_init()\n{\n  opt_super_readonly= super_read_only;\n}\n\n#ifdef _WIN32\nint win_main(int argc, char **argv)\n#else\nint mysqld_main(int argc, char **argv)\n#endif\n{\n  /*\n    Perform basic thread library and malloc initialization,\n    to be able to read defaults files and parse options.\n  */\n  my_progname= argv[0];\n\n#ifndef _WIN32\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  pre_initialize_performance_schema();\n#endif /*WITH_PERFSCHEMA_STORAGE_ENGINE */\n  // For windows, my_init() is called from the win specific mysqld_main\n  if (my_init())                 // init my_sys library & pthreads\n  {\n    sql_print_error(\"my_init() failed.\");\n    flush_error_log_messages();\n    return 1;\n  }\n#endif /* _WIN32 */\n\n  orig_argc= argc;\n  orig_argv= argv;\n  my_getopt_use_args_separator= TRUE;\n  my_defaults_read_login_file= FALSE;\n  if (load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv))\n  {\n    flush_error_log_messages();\n    return 1;\n  }\n  my_getopt_use_args_separator= FALSE;\n  defaults_argc= argc;\n  defaults_argv= argv;\n  remaining_argc= argc;\n  remaining_argv= argv;\n\n  /* Must be initialized early for comparison of options name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n  /* Write mysys error messages to the error log. */\n  local_message_hook= error_log_print;\n\n  int ho_error;\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    Initialize the array of performance schema instrument configurations.\n  */\n  init_pfs_instrument_array();\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n  ho_error= handle_early_options();\n\n#if !defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n\n  if (opt_bootstrap && opt_daemonize)\n  {\n    fprintf(stderr, \"Bootstrap and daemon options are incompatible.\\n\");\n    exit(MYSQLD_ABORT_EXIT);\n  }\n\n  if (opt_daemonize && log_error_dest == disabled_my_option &&\n      (isatty(STDOUT_FILENO) || isatty(STDERR_FILENO)))\n  {\n    fprintf(stderr, \"Please enable --log-error option or set appropriate \"\n                    \"redirections for standard output and/or standard error \"\n                    \"in daemon mode.\\n\");\n    exit(MYSQLD_ABORT_EXIT);\n  }\n\n  if (opt_daemonize)\n  {\n    if (chdir(\"/\") < 0)\n    {\n      fprintf(stderr, \"Cannot change to root director: %s\\n\",\n                      strerror(errno));\n      exit(MYSQLD_ABORT_EXIT);\n    }\n\n    if ((pipe_write_fd= mysqld::runtime::mysqld_daemonize()) < 0)\n    {\n      fprintf(stderr, \"mysqld_daemonize failed \\n\");\n      exit(MYSQLD_ABORT_EXIT);\n    }\n  }\n#endif\n\n  init_sql_statement_names();\n  sys_var_init();\n  ulong requested_open_files;\n  adjust_related_options(&requested_open_files);\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  if (ho_error == 0)\n  {\n    if (!opt_help && !opt_bootstrap)\n    {\n      /* Add sizing hints from the server sizing parameters. */\n      pfs_param.m_hints.m_table_definition_cache= table_def_size;\n      pfs_param.m_hints.m_table_open_cache= table_cache_size;\n      pfs_param.m_hints.m_max_connections= max_connections;\n      pfs_param.m_hints.m_open_files_limit= requested_open_files;\n      pfs_param.m_hints.m_max_prepared_stmt_count= max_prepared_stmt_count;\n\n      PSI_hook= initialize_performance_schema(&pfs_param);\n      if (PSI_hook == NULL && pfs_param.m_enabled)\n      {\n        pfs_param.m_enabled= false;\n        sql_print_warning(\"Performance schema disabled (reason: init failed).\");\n      }\n    }\n  }\n#else\n  /*\n    Other provider of the instrumentation interface should\n    initialize PSI_hook here:\n    - HAVE_PSI_INTERFACE is for the instrumentation interface\n    - WITH_PERFSCHEMA_STORAGE_ENGINE is for one implementation\n      of the interface,\n    but there could be alternate implementations, which is why\n    these two defines are kept separate.\n  */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Obtain the current performance schema instrumentation interface,\n    if available.\n  */\n  if (PSI_hook)\n  {\n    PSI *psi_server= (PSI*) PSI_hook->get_interface(PSI_CURRENT_VERSION);\n    if (likely(psi_server != NULL))\n    {\n      set_psi_server(psi_server);\n\n      /*\n        Now that we have parsed the command line arguments, and have initialized\n        the performance schema itself, the next step is to register all the\n        server instruments.\n      */\n      init_server_psi_keys();\n      /* Instrument the main thread */\n      PSI_thread *psi= PSI_THREAD_CALL(new_thread)(key_thread_main, NULL, 0);\n      PSI_THREAD_CALL(set_thread_os_id)(psi);\n      PSI_THREAD_CALL(set_thread)(psi);\n\n      /*\n        Now that some instrumentation is in place,\n        recreate objects which were initialised early,\n        so that they are instrumented as well.\n      */\n      my_thread_global_reinit();\n    }\n  }\n#endif /* HAVE_PSI_INTERFACE */\n\n  init_error_log();\n\n  /* Initialize audit interface globals. Audit plugins are inited later. */\n  mysql_audit_initialize();\n\n#ifndef EMBEDDED_LIBRARY\n  Srv_session::module_init();\n#endif\n\n  /*\n    Perform basic query log initialization. Should be called after\n    MY_INIT, as it initializes mutexes.\n  */\n  query_logger.init();\n\n  if (ho_error)\n  {\n    /*\n      Parsing command line option failed,\n      Since we don't have a workable remaining_argc/remaining_argv\n      to continue the server initialization, this is as far as this\n      code can go.\n      This is the best effort to log meaningful messages:\n      - messages will be printed to stderr, which is not redirected yet,\n      - messages will be printed in the NT event log, for windows.\n    */\n    flush_error_log_messages();\n    /*\n      Not enough initializations for unireg_abort()\n      Using exit() for windows.\n    */\n    exit (MYSQLD_ABORT_EXIT);\n  }\n\n  if (init_common_variables())\n    unireg_abort(MYSQLD_ABORT_EXIT);        // Will do exit\n\n  my_init_signals();\n\n  size_t guardize= 0;\n#ifndef _WIN32\n  int retval= pthread_attr_getguardsize(&connection_attrib, &guardize);\n  DBUG_ASSERT(retval == 0);\n  if (retval != 0)\n    guardize= my_thread_stack_size;\n#endif\n\n#if defined(__ia64__) || defined(__ia64)\n  /*\n    Peculiar things with ia64 platforms - it seems we only have half the\n    stack size in reality, so we have to double it here\n  */\n  guardize= my_thread_stack_size;\n#endif\n\n  my_thread_attr_setstacksize(&connection_attrib,\n                            my_thread_stack_size + guardize);\n\n  {\n    /* Retrieve used stack size;  Needed for checking stack overflows */\n    size_t stack_size= 0;\n    my_thread_attr_getstacksize(&connection_attrib, &stack_size);\n\n    /* We must check if stack_size = 0 as Solaris 2.9 can return 0 here */\n    if (stack_size && stack_size < (my_thread_stack_size + guardize))\n    {\n      sql_print_warning(\"Asked for %lu thread stack, but got %ld\",\n                        my_thread_stack_size + guardize, (long) stack_size);\n#if defined(__ia64__) || defined(__ia64)\n      my_thread_stack_size= stack_size / 2;\n#else\n      my_thread_stack_size= static_cast<ulong>(stack_size - guardize);\n#endif\n    }\n  }\n\n#ifndef DBUG_OFF\n  test_lc_time_sz();\n  srand(static_cast<uint>(time(NULL)));\n#endif\n\n#ifndef _WIN32\n  if ((user_info= check_user(mysqld_user)))\n  {\n#if HAVE_CHOWN\n    if (unlikely(opt_initialize))\n    {\n      /* need to change the owner of the freshly created data directory */\n      MY_STAT stat;\n      char errbuf[MYSYS_STRERROR_SIZE];\n      bool must_chown= true;\n\n      /* fetch the directory's owner */\n      if (!my_stat(mysql_real_data_home, &stat, MYF(0)))\n      {\n        sql_print_information(\"Can't read data directory's stats (%d): %s.\"\n                              \"Assuming that it's not owned by the same user/group\",\n                              my_errno(),\n                              my_strerror(errbuf, sizeof(errbuf), my_errno()));\n      }\n      /* Don't change it if it's already the same as SElinux stops this */\n      else if(stat.st_uid == user_info->pw_uid &&\n              stat.st_gid == user_info->pw_gid)\n        must_chown= false;\n\n      if (must_chown &&\n          chown(mysql_real_data_home, user_info->pw_uid, user_info->pw_gid)\n         )\n      {\n        sql_print_error(\"Can't change data directory owner to %s\", mysqld_user);\n        unireg_abort(1);\n      }\n    }\n#endif\n\n\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT)\n    if (locked_in_memory) // getuid() == 0 here\n      set_effective_user(user_info);\n    else\n#endif\n      set_user(mysqld_user, user_info);\n  }\n#endif // !_WIN32\n\n  /*\n   initiate key migration if any one of the migration specific\n   options are provided.\n  */\n  if (opt_keyring_migration_source ||\n      opt_keyring_migration_destination ||\n      migrate_connect_options)\n  {\n    Migrate_keyring mk;\n    if (mk.init(remaining_argc, remaining_argv,\n                opt_keyring_migration_source,\n                opt_keyring_migration_destination,\n                opt_keyring_migration_user,\n                opt_keyring_migration_host,\n                opt_keyring_migration_password,\n                opt_keyring_migration_socket,\n                opt_keyring_migration_port))\n    {\n      sql_print_error(ER_DEFAULT(ER_KEYRING_MIGRATION_STATUS),\n                      \"failed\");\n      log_error_dest= \"stderr\";\n      flush_error_log_messages();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    if (mk.execute())\n    {\n      sql_print_error(ER_DEFAULT(ER_KEYRING_MIGRATION_STATUS),\n                      \"failed\");\n      log_error_dest= \"stderr\";\n      flush_error_log_messages();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    sql_print_information(ER_DEFAULT(ER_KEYRING_MIGRATION_STATUS),\n                          \"successfull\");\n    log_error_dest= \"stderr\";\n    flush_error_log_messages();\n    unireg_abort(MYSQLD_SUCCESS_EXIT);\n  }\n\n  /*\n   We have enough space for fiddling with the argv, continue\n  */\n  if (my_setwd(mysql_real_data_home,MYF(MY_WME)) && !opt_help)\n  {\n    sql_print_error(\"failed to set datadir to %s\", mysql_real_data_home);\n    unireg_abort(MYSQLD_ABORT_EXIT);        /* purecov: inspected */\n  }\n\n  //If the binlog is enabled, one needs to provide a server-id\n  if (opt_bin_log && !(server_id_supplied) )\n  {\n    sql_print_error(\"You have enabled the binary log, but you haven't provided \"\n                    \"the mandatory server-id. Please refer to the proper \"\n                    \"server start-up parameters documentation\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /* \n   The subsequent calls may take a long time : e.g. innodb log read.\n   Thus set the long running service control manager timeout\n  */\n#if defined(_WIN32)\n  Service.SetSlowStarting(slow_start_timeout);\n#endif\n\n  if (init_server_components())\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n  /*\n    Each server should have one UUID. We will create it automatically, if it\n    does not exist.\n   */\n  if (init_server_auto_options())\n  {\n    sql_print_error(\"Initialization of the server's UUID failed because it could\"\n                    \" not be read from the auto.cnf file. If this is a new\"\n                    \" server, the initialization failed because it was not\"\n                    \" possible to generate a new UUID.\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /*\n    Add server_uuid to the sid_map.  This must be done after\n    server_uuid has been initialized in init_server_auto_options and\n    after the binary log (and sid_map file) has been initialized in\n    init_server_components().\n\n    No error message is needed: init_sid_map() prints a message.\n\n    Strictly speaking, this is not currently needed when\n    opt_bin_log==0, since the variables that gtid_state->init\n    initializes are not currently used in that case.  But we call it\n    regardless to avoid possible future bugs if gtid_state ever\n    needs to do anything else.\n  */\n  global_sid_lock->wrlock();\n  int gtid_ret= gtid_state->init();\n  global_sid_lock->unlock();\n\n  if (gtid_ret)\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n  // Initialize executed_gtids from mysql.gtid_executed table.\n  if (gtid_state->read_gtid_executed_from_table() == -1)\n    unireg_abort(1);\n\n  if (opt_bin_log)\n  {\n    /*\n      Initialize GLOBAL.GTID_EXECUTED and GLOBAL.GTID_PURGED from\n      gtid_executed table and binlog files during server startup.\n    */\n    Gtid_set *executed_gtids=\n      const_cast<Gtid_set *>(gtid_state->get_executed_gtids());\n    Gtid_set *lost_gtids=\n      const_cast<Gtid_set *>(gtid_state->get_lost_gtids());\n    Gtid_set *gtids_only_in_table=\n      const_cast<Gtid_set *>(gtid_state->get_gtids_only_in_table());\n    Gtid_set *previous_gtids_logged=\n      const_cast<Gtid_set *>(gtid_state->get_previous_gtids_logged());\n\n    Gtid_set purged_gtids_from_binlog(global_sid_map, global_sid_lock);\n    Gtid_set gtids_in_binlog(global_sid_map, global_sid_lock);\n    Gtid_set gtids_in_binlog_not_in_table(global_sid_map, global_sid_lock);\n\n    if (mysql_bin_log.init_gtid_sets(&gtids_in_binlog,\n                                     &purged_gtids_from_binlog,\n                                     opt_master_verify_checksum,\n                                     true/*true=need lock*/,\n                                     NULL/*trx_parser*/,\n                                     NULL/*gtid_partial_trx*/,\n                                     true/*is_server_starting*/))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n\n    global_sid_lock->wrlock();\n\n    purged_gtids_from_binlog.dbug_print(\"purged_gtids_from_binlog\");\n    gtids_in_binlog.dbug_print(\"gtids_in_binlog\");\n\n    if (!gtids_in_binlog.is_empty() &&\n        !gtids_in_binlog.is_subset(executed_gtids))\n    {\n      gtids_in_binlog_not_in_table.add_gtid_set(&gtids_in_binlog);\n      if (!executed_gtids->is_empty())\n        gtids_in_binlog_not_in_table.remove_gtid_set(executed_gtids);\n      /*\n        Save unsaved GTIDs into gtid_executed table, in the following\n        four cases:\n          1. the upgrade case.\n          2. the case that a slave is provisioned from a backup of\n             the master and the slave is cleaned by RESET MASTER\n             and RESET SLAVE before this.\n          3. the case that no binlog rotation happened from the\n             last RESET MASTER on the server before it crashes.\n          4. The set of GTIDs of the last binlog is not saved into the\n             gtid_executed table if server crashes, so we save it into\n             gtid_executed table and executed_gtids during recovery\n             from the crash.\n      */\n      if (gtid_state->save(&gtids_in_binlog_not_in_table) == -1)\n      {\n        global_sid_lock->unlock();\n        unireg_abort(MYSQLD_ABORT_EXIT);\n      }\n      executed_gtids->add_gtid_set(&gtids_in_binlog_not_in_table);\n    }\n\n    /* gtids_only_in_table= executed_gtids - gtids_in_binlog */\n    if (gtids_only_in_table->add_gtid_set(executed_gtids) !=\n        RETURN_STATUS_OK)\n    {\n      global_sid_lock->unlock();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n    gtids_only_in_table->remove_gtid_set(&gtids_in_binlog);\n    /*\n      lost_gtids = executed_gtids -\n                   (gtids_in_binlog - purged_gtids_from_binlog)\n                 = gtids_only_in_table + purged_gtids_from_binlog;\n    */\n    DBUG_ASSERT(lost_gtids->is_empty());\n    if (lost_gtids->add_gtid_set(gtids_only_in_table) != RETURN_STATUS_OK ||\n        lost_gtids->add_gtid_set(&purged_gtids_from_binlog) !=\n        RETURN_STATUS_OK)\n    {\n      global_sid_lock->unlock();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    /* Prepare previous_gtids_logged for next binlog */\n    if (previous_gtids_logged->add_gtid_set(&gtids_in_binlog) !=\n        RETURN_STATUS_OK)\n    {\n      global_sid_lock->unlock();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    /*\n      Write the previous set of gtids at this point because during\n      the creation of the binary log this is not done as we cannot\n      move the init_gtid_sets() to a place before openning the binary\n      log. This requires some investigation.\n\n      /Alfranio\n    */\n    Previous_gtids_log_event prev_gtids_ev(&gtids_in_binlog);\n\n    global_sid_lock->unlock();\n\n    (prev_gtids_ev.common_footer)->checksum_alg=\n      static_cast<enum_binlog_checksum_alg>(binlog_checksum_options);\n\n    if (prev_gtids_ev.write(mysql_bin_log.get_log_file()))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    mysql_bin_log.add_bytes_written(\n      prev_gtids_ev.common_header->data_written);\n\n    if (flush_io_cache(mysql_bin_log.get_log_file()) ||\n        mysql_file_sync(mysql_bin_log.get_log_file()->file, MYF(MY_WME)))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    mysql_bin_log.update_binlog_end_pos();\n\n    (void) RUN_HOOK(server_state, after_engine_recovery, (NULL));\n  }\n\n\n  if (init_ssl())\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  if (network_init())\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n#ifdef _WIN32\n#ifndef EMBEDDED_LIBRARY\n  if (opt_require_secure_transport &&\n      !opt_enable_shared_memory && !opt_use_ssl &&\n      !opt_initialize && !opt_bootstrap)\n  {\n    sql_print_error(\"Server is started with --require-secure-transport=ON \"\n                    \"but no secure transports (SSL or Shared Memory) are \"\n                    \"configured.\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n#endif\n\n#endif\n\n  /*\n   Initialize my_str_malloc(), my_str_realloc() and my_str_free()\n  */\n  my_str_malloc= &my_str_malloc_mysqld;\n  my_str_free= &my_str_free_mysqld;\n  my_str_realloc= &my_str_realloc_mysqld;\n\n  error_handler_hook= my_message_sql;\n\n  /* Save pid of this process in a file */\n  if (!opt_bootstrap)\n    create_pid_file();\n\n\n  /* Read the optimizer cost model configuration tables */\n  if (!opt_bootstrap)\n    reload_optimizer_cost_constants();\n\n  if (mysql_rm_tmp_tables() || acl_init(opt_noacl) ||\n      my_tz_init((THD *)0, default_tz_name, opt_bootstrap) ||\n      grant_init(opt_noacl))\n  {\n    abort_loop= true;\n\n    delete_pid_file(MYF(MY_WME));\n\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (!opt_bootstrap)\n    servers_init(0);\n\n  if (!opt_noacl)\n  {\n#ifdef HAVE_DLOPEN\n    udf_init();\n#endif\n  }\n\n  init_status_vars();\n  /* If running with bootstrap, do not start replication. */\n  if (opt_bootstrap)\n    opt_skip_slave_start= 1;\n\n  check_binlog_cache_size(NULL);\n  check_binlog_stmt_cache_size(NULL);\n\n  binlog_unsafe_map_init();\n\n  /* If running with bootstrap, do not start replication. */\n  if (!opt_bootstrap)\n  {\n    // Make @@slave_skip_errors show the nice human-readable value.\n    set_slave_skip_errors(&opt_slave_skip_errors);\n\n    /*\n      init_slave() must be called after the thread keys are created.\n    */\n    if (server_id != 0)\n      init_slave(); /* Ignoring errors while configuring replication. */\n  }\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  initialize_performance_schema_acl(opt_bootstrap);\n  /*\n    Do not check the structure of the performance schema tables\n    during bootstrap:\n    - the tables are not supposed to exist yet, bootstrap will create them\n    - a check would print spurious error messages\n  */\n  if (! opt_bootstrap)\n    check_performance_schema();\n#endif\n\n  initialize_information_schema_acl();\n\n  execute_ddl_log_recovery();\n  (void) RUN_HOOK(server_state, after_recovery, (NULL));\n\n  if (Events::init(opt_noacl || opt_bootstrap))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n#ifndef _WIN32\n  //  Start signal handler thread.\n  start_signal_handler();\n#endif\n\n  if (opt_bootstrap)\n  {\n    start_processing_signals();\n\n    int error= bootstrap(mysql_stdin);\n    unireg_abort(error ? MYSQLD_ABORT_EXIT : MYSQLD_SUCCESS_EXIT);\n  }\n\n  if (opt_init_file && *opt_init_file)\n  {\n    if (read_init_file(opt_init_file))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /*\n    Event must be invoked after error_handler_hook is assigned to\n    my_message_sql, otherwise my_message will not cause the event to abort.\n  */\n  if (mysql_audit_notify(AUDIT_EVENT(MYSQL_AUDIT_SERVER_STARTUP_STARTUP),\n                         (const char **) argv, argc))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n#ifdef _WIN32\n  create_shutdown_thread();\n#endif\n  start_handle_manager();\n\n  create_compress_gtid_table_thread();\n\n  sql_print_information(ER_DEFAULT(ER_STARTUP),\n                        my_progname,\n                        server_version,\n#ifdef HAVE_SYS_UN_H\n                        (opt_bootstrap ? (char*) \"\" : mysqld_unix_port),\n#else\n                        (char*) \"\",\n#endif\n                         mysqld_port,\n                         MYSQL_COMPILATION_COMMENT);\n#if defined(_WIN32)\n  Service.SetRunning();\n#endif\n\n  start_processing_signals();\n\n#ifdef WITH_NDBCLUSTER_STORAGE_ENGINE\n  /* engine specific hook, to be made generic */\n  if (ndb_wait_setup_func && ndb_wait_setup_func(opt_ndb_wait_setup))\n  {\n    sql_print_warning(\"NDB : Tables not available after %lu seconds.\"\n                      \"  Consider increasing --ndb-wait-setup value\",\n                      opt_ndb_wait_setup);\n  }\n#endif\n\n  if (!opt_bootstrap)\n  {\n    /*\n      Execute an I_S query to implicitly check for tables using the deprecated\n      partition engine. No need to do this during bootstrap. We ignore the\n      return value from the query execution. Note that this must be done after\n      NDB is initialized to avoid polluting the server with invalid table shares.\n    */\n    if (!opt_disable_partition_check)\n    {\n      sql_print_information(\n              \"Executing 'SELECT * FROM INFORMATION_SCHEMA.TABLES;' \"\n              \"to get a list of tables using the deprecated partition \"\n              \"engine.\");\n\n      sql_print_information(\"Beginning of list of non-natively partitioned tables\");\n      (void) bootstrap_single_query(\n              \"SELECT TABLE_SCHEMA, TABLE_NAME FROM INFORMATION_SCHEMA.TABLES \"\n              \"WHERE CREATE_OPTIONS LIKE '%partitioned%';\");\n      sql_print_information(\"End of list of non-natively partitioned tables\");\n    }\n  }\n\n  /*\n    Set opt_super_readonly here because if opt_super_readonly is set\n    in get_option, it will create problem while setting up event scheduler.\n  */\n  set_super_read_only_post_init();\n\n  DBUG_PRINT(\"info\", (\"Block, listening for incoming connections\"));\n\n  (void)MYSQL_SET_STAGE(0 ,__FILE__, __LINE__);\n\n  server_operational_state= SERVER_OPERATING;\n\n  (void) RUN_HOOK(server_state, before_handle_connection, (NULL));\n\n#if defined(_WIN32)\n  setup_conn_event_handler_threads();\n#else\n  mysql_mutex_lock(&LOCK_socket_listener_active);\n  // Make it possible for the signal handler to kill the listener.\n  socket_listener_active= true;\n  mysql_mutex_unlock(&LOCK_socket_listener_active);\n\n  if (opt_daemonize)\n    mysqld::runtime::signal_parent(pipe_write_fd,1);\n\n  mysqld_socket_acceptor->connection_event_loop();\n#endif /* _WIN32 */\n  server_operational_state= SERVER_SHUTTING_DOWN;\n\n  DBUG_PRINT(\"info\", (\"No longer listening for incoming connections\"));\n\n  mysql_audit_notify(MYSQL_AUDIT_SERVER_SHUTDOWN_SHUTDOWN,\n                     MYSQL_AUDIT_SERVER_SHUTDOWN_REASON_SHUTDOWN,\n                     MYSQLD_SUCCESS_EXIT);\n\n  terminate_compress_gtid_table_thread();\n  /*\n    Save set of GTIDs of the last binlog into gtid_executed table\n    on server shutdown.\n  */\n  if (opt_bin_log)\n    if (gtid_state->save_gtids_of_last_binlog_into_table(false))\n      sql_print_warning(\"Failed to save the set of Global Transaction \"\n                        \"Identifiers of the last binary log into the \"\n                        \"mysql.gtid_executed table while the server was \"\n                        \"shutting down. The next server restart will make \"\n                        \"another attempt to save Global Transaction \"\n                        \"Identifiers into the table.\");\n\n#ifndef _WIN32\n  mysql_mutex_lock(&LOCK_socket_listener_active);\n  // Notify the signal handler that we have stopped listening for connections.\n  socket_listener_active= false;\n  mysql_cond_broadcast(&COND_socket_listener_active);\n  mysql_mutex_unlock(&LOCK_socket_listener_active);\n#endif // !_WIN32\n\n#ifdef HAVE_PSI_THREAD_INTERFACE\n  /*\n    Disable the main thread instrumentation,\n    to avoid recording events during the shutdown.\n  */\n  PSI_THREAD_CALL(delete_current_thread)();\n#endif\n\n  DBUG_PRINT(\"info\", (\"Waiting for shutdown proceed\"));\n  int ret= 0;\n#ifdef _WIN32\n  if (shutdown_thr_handle.handle)\n    ret= my_thread_join(&shutdown_thr_handle, NULL);\n  shutdown_thr_handle.handle= NULL;\n  if (0 != ret)\n    sql_print_warning(\"Could not join shutdown thread. error:%d\", ret);\n#else\n  if (signal_thread_id.thread != 0)\n    ret= my_thread_join(&signal_thread_id, NULL);\n  signal_thread_id.thread= 0;\n  if (0 != ret)\n    sql_print_warning(\"Could not join signal_thread. error:%d\", ret);\n#endif\n\n  clean_up(1);\n  mysqld_exit(MYSQLD_SUCCESS_EXIT);\n}\n\n\n/****************************************************************************\n  Main and thread entry function for Win32\n  (all this is needed only to run mysqld as a service on WinNT)\n****************************************************************************/\n\n#if defined(_WIN32)\nint mysql_service(void *p)\n{\n  if (my_thread_init())\n  {\n    flush_error_log_messages();\n    return 1;\n  }\n\n  if (use_opt_args)\n    win_main(opt_argc, opt_argv);\n  else\n    win_main(Service.my_argc, Service.my_argv);\n\n  my_thread_end();\n  return 0;\n}\n\n\n/* Quote string if it contains space, else copy */\n\nstatic char *add_quoted_string(char *to, const char *from, char *to_end)\n{\n  uint length= (uint) (to_end-to);\n\n  if (!strchr(from, ' '))\n    return strmake(to, from, length-1);\n  return strxnmov(to, length-1, \"\\\"\", from, \"\\\"\", NullS);\n}\n\n\n/**\n  Handle basic handling of services, like installation and removal.\n\n  @param argv             Pointer to argument list\n  @param servicename    Internal name of service\n  @param displayname    Display name of service (in taskbar ?)\n  @param file_path    Path to this program\n  @param startup_option Startup option to mysqld\n\n  @retval\n    0   option handled\n  @retval\n    1   Could not handle option\n*/\n\nstatic bool\ndefault_service_handling(char **argv,\n       const char *servicename,\n       const char *displayname,\n       const char *file_path,\n       const char *extra_opt,\n       const char *account_name)\n{\n  char path_and_service[FN_REFLEN+FN_REFLEN+32], *pos, *end;\n  const char *opt_delim;\n  end= path_and_service + sizeof(path_and_service)-3;\n\n  /* We have to quote filename if it contains spaces */\n  pos= add_quoted_string(path_and_service, file_path, end);\n  if (extra_opt && *extra_opt)\n  {\n    /*\n     Add option after file_path. There will be zero or one extra option.  It's\n     assumed to be --defaults-file=file but isn't checked.  The variable (not\n     the option name) should be quoted if it contains a string.\n    */\n    *pos++= ' ';\n    if (opt_delim= strchr(extra_opt, '='))\n    {\n      size_t length= ++opt_delim - extra_opt;\n      pos= my_stpnmov(pos, extra_opt, length);\n    }\n    else\n      opt_delim= extra_opt;\n\n    pos= add_quoted_string(pos, opt_delim, end);\n  }\n  /* We must have servicename last */\n  *pos++= ' ';\n  (void) add_quoted_string(pos, servicename, end);\n\n  if (Service.got_service_option(argv, \"install\"))\n  {\n    Service.Install(1, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"install-manual\"))\n  {\n    Service.Install(0, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"remove\"))\n  {\n    Service.Remove(servicename);\n    return 0;\n  }\n  return 1;\n}\n\n\nint mysqld_main(int argc, char **argv)\n{\n  /*\n    When several instances are running on the same machine, we\n    need to have an  unique  named  hEventShudown  through the\n    application PID e.g.: MySQLShutdown1890; MySQLShutdown2342\n  */\n  int10_to_str((int) GetCurrentProcessId(),my_stpcpy(shutdown_event_name,\n                                                  \"MySQLShutdown\"), 10);\n\n  /* Must be initialized early for comparison of service name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  pre_initialize_performance_schema();\n#endif /*WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n  if (my_init())\n  {\n    sql_print_error(\"my_init() failed.\");\n    flush_error_log_messages();\n    return 1;\n  }\n\n  if (Service.GetOS())  /* true NT family */\n  {\n    char file_path[FN_REFLEN];\n    my_path(file_path, argv[0], \"\");          /* Find name in path */\n    fn_format(file_path,argv[0],file_path,\"\",\n              MY_REPLACE_DIR | MY_UNPACK_FILENAME | MY_RESOLVE_SYMLINKS);\n\n    if (argc == 2)\n    {\n      if (!default_service_handling(argv, MYSQL_SERVICENAME, MYSQL_SERVICENAME,\n                                    file_path, \"\", NULL))\n        return 0;\n      if (Service.IsService(argv[1]))        /* Start an optional service */\n      {\n        /*\n          Only add the service name to the groups read from the config file\n          if it's not \"MySQL\". (The default service name should be 'mysqld'\n          but we started a bad tradition by calling it MySQL from the start\n          and we are now stuck with it.\n        */\n        if (my_strcasecmp(system_charset_info, argv[1],\"mysql\"))\n          load_default_groups[load_default_groups_sz-2]= argv[1];\n        windows_service= true;\n        Service.Init(argv[1], mysql_service);\n        return 0;\n      }\n    }\n    else if (argc == 3) /* install or remove any optional service */\n    {\n      if (!default_service_handling(argv, argv[2], argv[2], file_path, \"\",\n                                    NULL))\n        return 0;\n      if (Service.IsService(argv[2]))\n      {\n        /*\n          mysqld was started as\n          mysqld --defaults-file=my_path\\my.ini service-name\n        */\n        use_opt_args=1;\n        opt_argc= 2;        // Skip service-name\n        opt_argv=argv;\n        windows_service= true;\n        if (my_strcasecmp(system_charset_info, argv[2],\"mysql\"))\n          load_default_groups[load_default_groups_sz-2]= argv[2];\n        Service.Init(argv[2], mysql_service);\n        return 0;\n      }\n    }\n    else if (argc == 4 || argc == 5)\n    {\n      /*\n        This may seem strange, because we handle --local-service while\n        preserving 4.1's behavior of allowing any one other argument that is\n        passed to the service on startup. (The assumption is that this is\n        --defaults-file=file, but that was not enforced in 4.1, so we don't\n        enforce it here.)\n      */\n      const char *extra_opt= NullS;\n      const char *account_name = NullS;\n      int index;\n      for (index = 3; index < argc; index++)\n      {\n        if (!strcmp(argv[index], \"--local-service\"))\n          account_name= \"NT AUTHORITY\\\\LocalService\";\n        else\n          extra_opt= argv[index];\n      }\n\n      if (argc == 4 || account_name)\n        if (!default_service_handling(argv, argv[2], argv[2], file_path,\n                                      extra_opt, account_name))\n          return 0;\n    }\n    else if (argc == 1 && Service.IsService(MYSQL_SERVICENAME))\n    {\n      /* start the default service */\n      windows_service= true;\n      Service.Init(MYSQL_SERVICENAME, mysql_service);\n      return 0;\n    }\n  }\n  /* Start as standalone server */\n  Service.my_argc=argc;\n  Service.my_argv=argv;\n  mysql_service(NULL);\n  return 0;\n}\n#endif // _WIN32\n#endif // !EMBEDDED_LIBRARY\n\n\nstatic bool read_init_file(char *file_name)\n{\n  MYSQL_FILE *file;\n  DBUG_ENTER(\"read_init_file\");\n  DBUG_PRINT(\"enter\",(\"name: %s\",file_name));\n\n  sql_print_information(\"Execution of init_file \\'%s\\' started.\", file_name);\n\n  if (!(file= mysql_file_fopen(key_file_init, file_name,\n                               O_RDONLY, MYF(MY_WME))))\n    DBUG_RETURN(TRUE);\n  (void) bootstrap(file);\n  mysql_file_fclose(file, MYF(MY_WME));\n\n  sql_print_information(\"Execution of init_file \\'%s\\' ended.\", file_name);\n\n  DBUG_RETURN(FALSE);\n}\n\n\n/****************************************************************************\n  Handle start options\n******************************************************************************/\n\n/**\n  Process command line options flagged as 'early'.\n  Some components needs to be initialized as early as possible,\n  because the rest of the server initialization depends on them.\n  Options that needs to be parsed early includes:\n  - the performance schema, when compiled in,\n  - options related to the help,\n  - options related to the bootstrap\n  The performance schema needs to be initialized as early as possible,\n  before to-be-instrumented objects of the server are initialized.\n*/\nint handle_early_options()\n{\n  int ho_error;\n  vector<my_option> all_early_options;\n  all_early_options.reserve(100);\n\n  my_getopt_register_get_addr(NULL);\n  /* Skip unknown options so that they may be processed later */\n  my_getopt_skip_unknown= TRUE;\n\n  /* Add the system variables parsed early */\n  sys_var_add_options(&all_early_options, sys_var::PARSE_EARLY);\n\n  /* Add the command line options parsed early */\n  for (my_option *opt= my_long_early_options;\n       opt->name != NULL;\n       opt++)\n    all_early_options.push_back(*opt);\n\n  add_terminator(&all_early_options);\n\n  my_getopt_error_reporter= option_error_reporter;\n  my_charset_error_reporter= charset_error_reporter;\n\n  ho_error= handle_options(&remaining_argc, &remaining_argv,\n                           &all_early_options[0], mysqld_get_one_option);\n  if (ho_error == 0)\n  {\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n\n    /* adjust the bootstrap options */\n    if (opt_bootstrap)\n    {\n      sql_print_warning(\"--bootstrap is deprecated. \"\n                        \"Please consider using --initialize instead\");\n    }\n    if (opt_initialize_insecure)\n      opt_initialize= TRUE;\n    if (opt_initialize)\n    {\n      if (opt_bootstrap)\n      {\n        sql_print_error(\"Both --bootstrap and --initialize specified.\"\n                        \" Please pick one. Exiting.\");\n        ho_error= EXIT_AMBIGUOUS_OPTION;\n      }\n      opt_bootstrap= TRUE;\n    }\n  }\n\n  // Swap with an empty vector, i.e. delete elements and free allocated space.\n  vector<my_option>().swap(all_early_options);\n\n  return ho_error;\n}\n\n/**\n  Adjust @c open_files_limit.\n  Computation is  based on:\n  - @c max_connections,\n  - @c table_cache_size,\n  - the platform max open file limit.\n*/\nvoid adjust_open_files_limit(ulong *requested_open_files)\n{\n  ulong limit_1;\n  ulong limit_2;\n  ulong limit_3;\n  ulong request_open_files;\n  ulong effective_open_files;\n\n  /* MyISAM requires two file handles per table. */\n  limit_1= 10 + max_connections + table_cache_size * 2;\n\n  /*\n    We are trying to allocate no less than max_connections*5 file\n    handles (i.e. we are trying to set the limit so that they will\n    be available).\n  */\n  limit_2= max_connections * 5;\n\n  /* Try to allocate no less than 5000 by default. */\n  limit_3= open_files_limit ? open_files_limit : 5000;\n\n  request_open_files= max<ulong>(max<ulong>(limit_1, limit_2), limit_3);\n\n  /* Notice: my_set_max_open_files() may return more than requested. */\n  effective_open_files= my_set_max_open_files(request_open_files);\n\n  if (effective_open_files < request_open_files)\n  {\n    if (open_files_limit == 0)\n    {\n      sql_print_warning(\"Changed limits: max_open_files: %lu (requested %lu)\",\n                        effective_open_files, request_open_files);\n    }\n    else\n    {\n      sql_print_warning(\"Could not increase number of max_open_files to \"\n                        \"more than %lu (request: %lu)\",\n                        effective_open_files, request_open_files);\n    }\n  }\n\n  open_files_limit= effective_open_files;\n  if (requested_open_files)\n    *requested_open_files= min<ulong>(effective_open_files, request_open_files);\n}\n\nvoid adjust_max_connections(ulong requested_open_files)\n{\n  ulong limit;\n\n  limit= requested_open_files - 10 - TABLE_OPEN_CACHE_MIN * 2;\n\n  if (limit < max_connections)\n  {\n    sql_print_warning(\"Changed limits: max_connections: %lu (requested %lu)\",\n                      limit, max_connections);\n\n    // This can be done unprotected since it is only called on startup.\n    max_connections= limit;\n  }\n}\n\nvoid adjust_table_cache_size(ulong requested_open_files)\n{\n  ulong limit;\n\n  limit= max<ulong>((requested_open_files - 10 - max_connections) / 2,\n                    TABLE_OPEN_CACHE_MIN);\n\n  if (limit < table_cache_size)\n  {\n    sql_print_warning(\"Changed limits: table_open_cache: %lu (requested %lu)\",\n                      limit, table_cache_size);\n\n    table_cache_size= limit;\n  }\n\n  table_cache_size_per_instance= table_cache_size / table_cache_instances;\n}\n\nvoid adjust_table_def_size()\n{\n  ulong default_value;\n  sys_var *var;\n\n  default_value= min<ulong> (400 + table_cache_size / 2, 2000);\n  var= intern_find_sys_var(STRING_WITH_LEN(\"table_definition_cache\"));\n  DBUG_ASSERT(var != NULL);\n  var->update_default(default_value);\n\n  if (! table_definition_cache_specified)\n    table_def_size= default_value;\n}\n\nvoid adjust_related_options(ulong *requested_open_files)\n{\n  /* In bootstrap, disable grant tables (we are about to create them) */\n  if (opt_bootstrap)\n    opt_noacl= 1;\n\n  /* The order is critical here, because of dependencies. */\n  adjust_open_files_limit(requested_open_files);\n  adjust_max_connections(*requested_open_files);\n  adjust_table_cache_size(*requested_open_files);\n  adjust_table_def_size();\n}\n\nvector<my_option> all_options;\n\nstruct my_option my_long_early_options[]=\n{\n  {\"bootstrap\", OPT_BOOTSTRAP, \"Used by mysql installation scripts.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#if !defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  {\"daemonize\", 0, \"Run mysqld as sysv daemon\", &opt_daemonize,\n    &opt_daemonize, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,0},\n#endif\n  {\"skip-grant-tables\", 0,\n   \"Start without grant tables. This gives all users FULL ACCESS to all tables.\",\n   &opt_noacl, &opt_noacl, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n  {\"help\", '?', \"Display this help and exit.\",\n   &opt_help, &opt_help, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0,\n   0, 0},\n  {\"verbose\", 'v', \"Used with --help option for detailed help.\",\n   &opt_verbose, &opt_verbose, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"version\", 'V', \"Output version information and exit.\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"initialize\", 0, \"Create the default database and exit.\"\n   \" Create a super user with a random expired password and store it into the log.\",\n   &opt_initialize, &opt_initialize, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"initialize-insecure\", 0, \"Create the default database and exit.\"\n   \" Create a super user with empty password.\",\n   &opt_initialize_insecure, &opt_initialize_insecure, 0, GET_BOOL, NO_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"disable-partition-engine-check\", 0,\n   \"Skip the check for non-natively partitioned tables during bootstrap. \"\n   \"This option is deprecated along with the partition engine.\",\n   &opt_disable_partition_check, &opt_disable_partition_check, 0, GET_BOOL,\n   NO_ARG, TRUE, 0, 0, 0, 0, 0},\n  {\"keyring-migration-source\", OPT_KEYRING_MIGRATION_SOURCE,\n   \"Keyring plugin from where the keys needs to \"\n   \"be migrated to. This option must be specified along with \"\n   \"--keyring-migration-destination.\",\n   &opt_keyring_migration_source, &opt_keyring_migration_source,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"keyring-migration-destination\", OPT_KEYRING_MIGRATION_DESTINATION,\n   \"Keyring plugin to which the keys are \"\n   \"migrated to. This option must be specified along with \"\n   \"--keyring-migration-source.\",\n   &opt_keyring_migration_destination, &opt_keyring_migration_destination,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"keyring-migration-user\", OPT_KEYRING_MIGRATION_USER,\n   \"User to login to server.\",\n   &opt_keyring_migration_user, &opt_keyring_migration_user,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"keyring-migration-host\", OPT_KEYRING_MIGRATION_HOST, \"Connect to host.\",\n   &opt_keyring_migration_host, &opt_keyring_migration_host,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"keyring-migration-password\", OPT_KEYRING_MIGRATION_PASSWORD,\n   \"Password to use when connecting to server during keyring migration. \"\n   \"If password value is not specified then it will be asked from the tty.\",\n   0, 0, 0, GET_PASSWORD, OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"keyring-migration-socket\", OPT_KEYRING_MIGRATION_SOCKET,\n   \"The socket file to use for connection.\",\n   &opt_keyring_migration_socket, &opt_keyring_migration_socket,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"keyring-migration-port\", OPT_KEYRING_MIGRATION_PORT,\n   \"Port number to use for connection.\",\n   &opt_keyring_migration_port, &opt_keyring_migration_port,\n   0, GET_ULONG, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  { 0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0 }\n};\n\n/**\n  System variables are automatically command-line options (few\n  exceptions are documented in sys_var.h), so don't need\n  to be listed here.\n*/\n\nstruct my_option my_long_options[]=\n{\n#ifdef HAVE_REPLICATION\n  {\"abort-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &abort_slave_event_count,  &abort_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"allow-suspicious-udfs\", 0,\n   \"Allows use of UDFs consisting of only one symbol xxx() \"\n   \"without corresponding xxx_init() or xxx_deinit(). That also means \"\n   \"that one can load any function from any library, for example exit() \"\n   \"from libc.so\",\n   &opt_allow_suspicious_udfs, &opt_allow_suspicious_udfs,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"ansi\", 'a', \"Use ANSI SQL syntax instead of MySQL syntax. This mode \"\n   \"will also set transaction isolation level 'serializable'.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /*\n    Because Sys_var_bit does not support command-line options, we need to\n    explicitely add one for --autocommit\n  */\n  {\"autocommit\", 0, \"Set default value for autocommit (0 or 1)\",\n   &opt_autocommit, &opt_autocommit, 0,\n   GET_BOOL, OPT_ARG, 1, 0, 0, 0, 0, NULL},\n  {\"binlog-do-db\", OPT_BINLOG_DO_DB,\n   \"Tells the master it should log updates for the specified database, \"\n   \"and exclude all others not explicitly mentioned.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-ignore-db\", OPT_BINLOG_IGNORE_DB,\n   \"Tells the master that updates to the given database should not be logged to the binary log.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-row-event-max-size\", 0,\n   \"The maximum size of a row-based binary log event in bytes. Rows will be \"\n   \"grouped into events smaller than this size if possible. \"\n   \"The value has to be a multiple of 256.\",\n   &opt_binlog_rows_event_max_size, &opt_binlog_rows_event_max_size,\n   0, GET_ULONG, REQUIRED_ARG,\n   /* def_value */ 8192, /* min_value */  256, /* max_value */ ULONG_MAX,\n   /* sub_size */     0, /* block_size */ 256,\n   /* app_type */ 0\n  },\n  {\"character-set-client-handshake\", 0,\n   \"Don't ignore client side character set value sent during handshake.\",\n   &opt_character_set_client_handshake,\n   &opt_character_set_client_handshake,\n    0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n  {\"character-set-filesystem\", 0,\n   \"Set the filesystem character set.\",\n   &character_set_filesystem_name,\n   &character_set_filesystem_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"character-set-server\", 'C', \"Set the default character set.\",\n   &default_character_set_name, &default_character_set_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"chroot\", 'r', \"Chroot mysqld daemon during startup.\",\n   &mysqld_chroot, &mysqld_chroot, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"collation-server\", 0, \"Set the default collation.\",\n   &default_collation_name, &default_collation_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"console\", OPT_CONSOLE, \"Write error output on screen; don't remove the console window on windows.\",\n   &opt_console, &opt_console, 0, GET_BOOL, NO_ARG, 0, 0, 0,\n   0, 0, 0},\n  {\"core-file\", OPT_WANT_CORE, \"Write core on errors.\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  /* default-storage-engine should have \"MyISAM\" as def_value. Instead\n     of initializing it here it is done in init_common_variables() due\n     to a compiler bug in Sun Studio compiler. */\n  {\"default-storage-engine\", 0, \"The default storage engine for new tables\",\n   &default_storage_engine, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"default-tmp-storage-engine\", 0, \n    \"The default storage engine for new explict temporary tables\",\n   &default_tmp_storage_engine, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"default-time-zone\", 0, \"Set the default time zone.\",\n   &default_tz_name, &default_tz_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n#ifdef HAVE_OPENSSL\n  {\"des-key-file\", 0,\n   \"Load keys for des_encrypt() and des_encrypt from given file.\",\n   &des_key_file, &des_key_file, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_REPLICATION\n  {\"disconnect-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &disconnect_slave_event_count, &disconnect_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"exit-info\", 'T', \"Used for debugging. Use at your own risk.\", 0, 0, 0,\n   GET_LONG, OPT_ARG, 0, 0, 0, 0, 0, 0},\n\n  {\"external-locking\", 0, \"Use system (external) locking (disabled by \"\n   \"default).  With this option enabled you can run myisamchk to test \"\n   \"(not repair) tables while the MySQL server is running. Disable with \"\n   \"--skip-external-locking.\", &opt_external_locking, &opt_external_locking,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /* We must always support the next option to make scripts like mysqltest\n     easier to do */\n  {\"gdb\", 0,\n   \"Set up signals usable for debugging.\",\n   &opt_debugging, &opt_debugging,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#if defined(HAVE_LINUX_LARGE_PAGES) || defined (HAVE_SOLARIS_LARGE_PAGES)\n  {\"super-large-pages\", 0, \"Enable support for super large pages.\",\n   &opt_super_large_pages, &opt_super_large_pages, 0,\n   GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},\n#endif\n  {\"ignore-db-dir\", OPT_IGNORE_DB_DIRECTORY,\n   \"Specifies a directory to add to the ignore list when collecting \"\n   \"database names from the datadir. Put a blank argument to reset \"\n   \"the list accumulated so far.\", 0, 0, 0, GET_STR, REQUIRED_ARG, \n   0, 0, 0, 0, 0, 0},\n  {\"language\", 'L',\n   \"Client error messages in given language. May be given as a full path. \"\n   \"Deprecated. Use --lc-messages-dir instead.\",\n   &lc_messages_dir_ptr, &lc_messages_dir_ptr, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"lc-messages\", 0,\n   \"Set the language used for the error messages.\",\n   &lc_messages, &lc_messages, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"lc-time-names\", 0,\n   \"Set the language used for the month names and the days of the week.\",\n   &lc_time_names_name, &lc_time_names_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"log-bin\", OPT_BIN_LOG,\n   \"Log update queries in binary format. Optional (but strongly recommended \"\n   \"to avoid replication problems if server's hostname changes) argument \"\n   \"should be the chosen location for the binary log files.\",\n   &opt_bin_logname, &opt_bin_logname, 0, GET_STR_ALLOC,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-bin-index\", 0,\n   \"File that holds the names for binary log files.\",\n   &opt_binlog_index_name, &opt_binlog_index_name, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"relay-log-index\", 0,\n   \"File that holds the names for relay log files.\",\n   &opt_relaylog_index_name, &opt_relaylog_index_name, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-isam\", OPT_ISAM_LOG, \"Log all MyISAM changes to file.\",\n   &myisam_log_filename, &myisam_log_filename, 0, GET_STR,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-raw\", 0,\n   \"Log to general log before any rewriting of the query. For use in debugging, not production as \"\n   \"sensitive information may be logged.\",\n   &opt_general_log_raw, &opt_general_log_raw,\n   0, GET_BOOL, NO_ARG, 0, 0, 1, 0, 1, 0 },\n  {\"log-short-format\", 0,\n   \"Don't log extra information to update and slow-query logs.\",\n   &opt_short_log_format, &opt_short_log_format,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-tc\", 0,\n   \"Path to transaction coordinator log (used for transactions that affect \"\n   \"more than one storage engine, when binary log is disabled).\",\n   &opt_tc_log_file, &opt_tc_log_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-tc-size\", 0, \"Size of transaction coordinator log.\",\n   &opt_tc_log_size, &opt_tc_log_size, 0, GET_ULONG,\n   REQUIRED_ARG, TC_LOG_MIN_PAGES * my_getpagesize(),\n   TC_LOG_MIN_PAGES * my_getpagesize(), ULONG_MAX, 0,\n   my_getpagesize(), 0},\n  {\"master-info-file\", 0,\n   \"The location and name of the file that remembers the master and where \"\n   \"the I/O replication thread is in the master's binlogs.\",\n   &master_info_file, &master_info_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"master-retry-count\", OPT_MASTER_RETRY_COUNT,\n   \"The number of tries the slave will make to connect to the master before giving up. \"\n   \"Deprecated option, use 'CHANGE MASTER TO master_retry_count = <num>' instead.\",\n   &master_retry_count, &master_retry_count, 0, GET_ULONG,\n   REQUIRED_ARG, 3600*24, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"max-binlog-dump-events\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &max_binlog_dump_events, &max_binlog_dump_events, 0,\n   GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"memlock\", 0, \"Lock mysqld in memory.\", &locked_in_memory,\n   &locked_in_memory, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"old-style-user-limits\", 0,\n   \"Enable old-style user limits (before 5.0.3, user resources were counted \"\n   \"per each user+host vs. per account).\",\n   &opt_old_style_user_limits, &opt_old_style_user_limits,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"port-open-timeout\", 0,\n   \"Maximum time in seconds to wait for the port to become free. \"\n   \"(Default: No wait).\", &mysqld_port_timeout, &mysqld_port_timeout, 0,\n   GET_UINT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-db\", OPT_REPLICATE_DO_DB,\n   \"Tells the slave thread to restrict replication to the specified database. \"\n   \"To specify more than one database, use the directive multiple times, \"\n   \"once for each database. Note that this will only work if you do not use \"\n   \"cross-database queries such as UPDATE some_db.some_table SET foo='bar' \"\n   \"while having selected a different or no database. If you need cross \"\n   \"database updates to work, make sure you have 3.23.28 or later, and use \"\n   \"replicate-wild-do-table=db_name.%.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-table\", OPT_REPLICATE_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the specified table. \"\n   \"To specify more than one table, use the directive multiple times, once \"\n   \"for each table. This will work for cross-database updates, in contrast \"\n   \"to replicate-do-db.\", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-db\", OPT_REPLICATE_IGNORE_DB,\n   \"Tells the slave thread to not replicate to the specified database. To \"\n   \"specify more than one database to ignore, use the directive multiple \"\n   \"times, once for each database. This option will not work if you use \"\n   \"cross database updates. If you need cross database updates to work, \"\n   \"make sure you have 3.23.28 or later, and use replicate-wild-ignore-\"\n   \"table=db_name.%. \", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-table\", OPT_REPLICATE_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the specified table. To specify \"\n   \"more than one table to ignore, use the directive multiple times, once for \"\n   \"each table. This will work for cross-database updates, in contrast to \"\n   \"replicate-ignore-db.\", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-rewrite-db\", OPT_REPLICATE_REWRITE_DB,\n   \"Updates to a database with a different name than the original. Example: \"\n   \"replicate-rewrite-db=master_db_name->slave_db_name.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"replicate-same-server-id\", 0,\n   \"In replication, if set to 1, do not skip events having our server id. \"\n   \"Default value is 0 (to break infinite loops in circular replication). \"\n   \"Can't be set to 1 if --log-slave-updates is used.\",\n   &replicate_same_server_id, &replicate_same_server_id,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"replicate-wild-do-table\", OPT_REPLICATE_WILD_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the tables that match \"\n   \"the specified wildcard pattern. To specify more than one table, use the \"\n   \"directive multiple times, once for each table. This will work for cross-\"\n   \"database updates. Example: replicate-wild-do-table=foo%.bar% will \"\n   \"replicate only updates to tables in all databases that start with foo \"\n   \"and whose table names start with bar.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-wild-ignore-table\", OPT_REPLICATE_WILD_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the tables that match the \"\n   \"given wildcard pattern. To specify more than one table to ignore, use \"\n   \"the directive multiple times, once for each table. This will work for \"\n   \"cross-database updates. Example: replicate-wild-ignore-table=foo%.bar% \"\n   \"will not do updates to tables in databases that start with foo and whose \"\n   \"table names start with bar.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"safe-user-create\", 0,\n   \"Don't allow new user creation by the user who has no write privileges to the mysql.user table.\",\n   &opt_safe_user_create, &opt_safe_user_create, 0, GET_BOOL,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"show-slave-auth-info\", 0,\n   \"Show user and password in SHOW SLAVE HOSTS on this master.\",\n   &opt_show_slave_auth_info, &opt_show_slave_auth_info, 0,\n   GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-host-cache\", OPT_SKIP_HOST_CACHE, \"Don't cache host names.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-new\", OPT_SKIP_NEW, \"Don't use new, possibly wrong routines.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-slave-start\", 0,\n   \"If set, slave is not autostarted.\", &opt_skip_slave_start,\n   &opt_skip_slave_start, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-stack-trace\", OPT_SKIP_STACK_TRACE,\n   \"Don't print a stack trace on failure.\", 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0,\n   0, 0, 0, 0},\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  {\"slow-start-timeout\", 0,\n   \"Maximum number of milliseconds that the service control manager should wait \"\n   \"before trying to kill the windows service during startup\"\n   \"(Default: 15000).\", &slow_start_timeout, &slow_start_timeout, 0,\n   GET_ULONG, REQUIRED_ARG, 15000, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_REPLICATION\n  {\"sporadic-binlog-dump-fail\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &opt_sporadic_binlog_dump_fail,\n   &opt_sporadic_binlog_dump_fail, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n#endif /* HAVE_REPLICATION */\n#ifdef HAVE_OPENSSL\n  {\"ssl\", 0,\n   \"Enable SSL for connection (automatically enabled with other flags).\",\n   &opt_use_ssl, &opt_use_ssl, 0, GET_BOOL, OPT_ARG, 1, 0, 0,\n   0, 0, 0},\n#endif\n#ifdef _WIN32\n  {\"standalone\", 0,\n  \"Dummy option to start as a standalone program (NT).\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"symbolic-links\", 's', \"Enable symbolic link support.\",\n   &my_enable_symlinks, &my_enable_symlinks, 0, GET_BOOL, NO_ARG,\n   1, 0, 0, 0, 0, 0},\n  {\"sysdate-is-now\", 0,\n   \"Non-default option to alias SYSDATE() to NOW() to make it safe-replicable. \"\n   \"Since 5.0, SYSDATE() returns a `dynamic' value different for different \"\n   \"invocations, even within the same statement.\",\n   &global_system_variables.sysdate_is_now,\n   0, 0, GET_BOOL, NO_ARG, 0, 0, 1, 0, 1, 0},\n  {\"tc-heuristic-recover\", 0,\n   \"Decision to use in heuristic recover process. Possible values are OFF, \"\n   \"COMMIT or ROLLBACK.\", &tc_heuristic_recover, &tc_heuristic_recover,\n   &tc_heuristic_recover_typelib, GET_ENUM, REQUIRED_ARG,\n   TC_HEURISTIC_NOT_USED, 0, 0, 0, 0, 0},\n#if defined(ENABLED_DEBUG_SYNC)\n  {\"debug-sync-timeout\", OPT_DEBUG_SYNC_TIMEOUT,\n   \"Enable the debug sync facility \"\n   \"and optionally specify a default wait timeout in seconds. \"\n   \"A zero value keeps the facility disabled.\",\n   &opt_debug_sync_timeout, 0,\n   0, GET_UINT, OPT_ARG, 0, 0, UINT_MAX, 0, 0, 0},\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  {\"temp-pool\", 0,\n   \"This option is deprecated and will be removed in a future version. \"\n#if defined(__linux__)\n   \"Using this option will cause most temporary files created to use a small \"\n   \"set of names, rather than a unique name for each new file.\",\n#else\n   \"This option is ignored on this OS.\",\n#endif\n   &use_temp_pool, &use_temp_pool, 0, GET_BOOL, NO_ARG, 1,\n   0, 0, 0, 0, 0},\n  {\"transaction-isolation\", OPT_TRANSACTION_ISOLATION,\n   \"Default transaction isolation level.\",\n   &global_system_variables.tx_isolation,\n   &global_system_variables.tx_isolation, &tx_isolation_typelib,\n   GET_ENUM, REQUIRED_ARG, ISO_REPEATABLE_READ, 0, 0, 0, 0, 0},\n  {\"transaction-read-only\", OPT_TRANSACTION_READ_ONLY,\n   \"Default transaction access mode. \"\n   \"True if transactions are read-only.\",\n   &global_system_variables.tx_read_only,\n   &global_system_variables.tx_read_only, 0,\n   GET_BOOL, OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"user\", 'u', \"Run mysqld daemon as user.\", 0, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"early-plugin-load\", OPT_EARLY_PLUGIN_LOAD,\n   \"Optional semicolon-separated list of plugins to load before storage engine \"\n   \"initialization, where each plugin is identified as name=library, where \"\n   \"name is the plugin name and library is the plugin library in plugin_dir.\",\n   0, 0, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"plugin-load\", OPT_PLUGIN_LOAD,\n   \"Optional semicolon-separated list of plugins to load, where each plugin is \"\n   \"identified as name=library, where name is the plugin name and library \"\n   \"is the plugin library in plugin_dir.\",\n   0, 0, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"plugin-load-add\", OPT_PLUGIN_LOAD_ADD,\n   \"Optional semicolon-separated list of plugins to load, where each plugin is \"\n   \"identified as name=library, where name is the plugin name and library \"\n   \"is the plugin library in plugin_dir. This option adds to the list \"\n   \"specified by --plugin-load in an incremental way. \"\n   \"Multiple --plugin-load-add are supported.\",\n   0, 0, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n\n  {\"innodb\", OPT_SKIP_INNODB,\n   \"Deprecated option. Provided for backward compatibility only. \"\n   \"The option has no effect on the server behaviour. InnoDB is always enabled. \"\n   \"The option will be removed in a future release.\",\n   0, 0, 0, GET_BOOL, OPT_ARG,\n   0, 0, 0, 0, 0, 0},\n\n  {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n};\n\n\nstatic int show_queries(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= (char *)&thd->query_id;\n  return 0;\n}\n\n\nstatic int show_net_compression(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_MY_BOOL;\n  var->value= buff;\n  *((bool *)buff)= thd->get_protocol()->get_compression();\n  return 0;\n}\n\nstatic int show_starttime(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= buff;\n  *((longlong *)buff)= (longlong) (thd->query_start() - server_start_time);\n  return 0;\n}\n\nstatic int show_max_used_connections_time(THD *thd, SHOW_VAR *var, char *buff)\n{\n  MYSQL_TIME max_used_connections_time;\n  var->type= SHOW_CHAR;\n  var->value= buff;\n  thd->variables.time_zone->gmt_sec_to_TIME(&max_used_connections_time,\n    Connection_handler_manager::max_used_connections_time);\n  my_datetime_to_str(&max_used_connections_time, buff, 0);\n  return 0;\n}\n\nstatic int show_num_thread_running(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= buff;\n  long long *value= reinterpret_cast<long long*>(buff);\n  *value= static_cast<long long>(Global_THD_manager::get_instance()->\n                                 get_num_thread_running());\n  return 0;\n}\n\n\nstatic int show_num_thread_created(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  long *value= reinterpret_cast<long*>(buff);\n  *value= static_cast<long>(Global_THD_manager::get_instance()->\n                            get_num_thread_created());\n  return 0;\n}\n\nstatic int show_thread_id_count(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  long *value= reinterpret_cast<long*>(buff);\n  *value= static_cast<long>(Global_THD_manager::get_instance()->\n                            get_thread_id());\n  return 0;\n}\n\n\n#ifndef EMBEDDED_LIBRARY\nstatic int show_aborted_connects(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  long *value= reinterpret_cast<long*>(buff);\n  *value= static_cast<long>(Connection_handler_manager::get_instance()->\n                            aborted_connects());\n  return 0;\n}\n\n\nstatic int show_connection_errors_max_connection(THD *thd, SHOW_VAR *var,\n                                                 char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  long *value= reinterpret_cast<long*>(buff);\n  *value= static_cast<long>(Connection_handler_manager::get_instance()->\n                            connection_errors_max_connection());\n  return 0;\n}\n\nstatic int show_connection_errors_select(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  long *value= reinterpret_cast<long*>(buff);\n  *value=\n    static_cast<long>(Mysqld_socket_listener::get_connection_errors_select());\n  return 0;\n}\n\nstatic int show_connection_errors_accept(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  long *value= reinterpret_cast<long*>(buff);\n  *value=\n    static_cast<long>(Mysqld_socket_listener::get_connection_errors_accept());\n  return 0;\n}\n\nstatic int show_connection_errors_tcpwrap(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  long *value= reinterpret_cast<long*>(buff);\n  *value=\n    static_cast<long>(Mysqld_socket_listener::get_connection_errors_tcpwrap());\n  return 0;\n}\n#endif\n\n\n#ifdef ENABLED_PROFILING\nstatic int show_flushstatustime(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= buff;\n  *((longlong *)buff)= (longlong) (thd->query_start() - flush_status_time);\n  return 0;\n}\n#endif\n\n#ifdef HAVE_REPLICATION\n/**\n  After Multisource replication, this function only shows the value\n  of default channel.\n\n  To know the status of other channels, performance schema replication\n  tables comes to the rescue.\n\n  @TODO: any warning needed if multiple channels exist to request\n         the users to start using replication performance schema\n         tables.\n*/\nstatic int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)\n{\n  channel_map.rdlock();\n  Master_info *mi= channel_map.get_default_channel_mi();\n\n  if (mi)\n  {\n    var->type= SHOW_MY_BOOL;\n    var->value= buff;\n    *((my_bool *)buff)= (my_bool) (mi &&\n                                   mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&\n                                   mi->rli->slave_running);\n  }\n  else\n    var->type= SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n\n/**\n  This status variable is also exclusively (look comments on\n  show_slave_running()) for default channel.\n*/\nstatic int show_slave_retried_trans(THD *thd, SHOW_VAR *var, char *buff)\n{\n  channel_map.rdlock();\n  Master_info *mi= channel_map.get_default_channel_mi();\n\n  if (mi)\n  {\n    var->type= SHOW_LONG;\n    var->value= buff;\n    *((long *)buff)= (long)mi->rli->retried_trans;\n  }\n  else\n    var->type= SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n/**\n  Only for default channel. Refer to comments on show_slave_running()\n*/\nstatic int show_slave_received_heartbeats(THD *thd, SHOW_VAR *var, char *buff)\n{\n  channel_map.rdlock();\n  Master_info *mi= channel_map.get_default_channel_mi();\n\n  if (mi)\n  {\n    var->type= SHOW_LONGLONG;\n    var->value= buff;\n    *((longlong *)buff)= mi->received_heartbeats;\n  }\n  else\n    var->type= SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n/**\n  Only for default channel. Refer to comments on show_slave_running()\n*/\nstatic int show_slave_last_heartbeat(THD *thd, SHOW_VAR *var, char *buff)\n{\n  MYSQL_TIME received_heartbeat_time;\n\n  channel_map.rdlock();\n  Master_info *mi= channel_map.get_default_channel_mi();\n\n  if (mi)\n  {\n    var->type= SHOW_CHAR;\n    var->value= buff;\n    if (mi->last_heartbeat == 0)\n      buff[0]='\\0';\n    else\n    {\n      thd->variables.time_zone->gmt_sec_to_TIME(&received_heartbeat_time, \n        static_cast<my_time_t>(mi->last_heartbeat));\n      my_datetime_to_str(&received_heartbeat_time, buff, 0);\n    }\n  }\n  else\n    var->type= SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n/**\n  Only for default channel. For details, refer to show_slave_running()\n*/\nstatic int show_heartbeat_period(THD *thd, SHOW_VAR *var, char *buff)\n{\n  DEBUG_SYNC(thd, \"dsync_show_heartbeat_period\");\n\n  channel_map.rdlock();\n  Master_info *mi= channel_map.get_default_channel_mi();\n\n  if (mi)\n  {\n    var->type= SHOW_CHAR;\n    var->value= buff;\n    sprintf(buff, \"%.3f\", mi->heartbeat_period);\n  }\n  else\n    var->type= SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n#ifndef DBUG_OFF\nstatic int show_slave_rows_last_search_algorithm_used(THD *thd, SHOW_VAR *var, char *buff)\n{\n  uint res= slave_rows_last_search_algorithm_used;\n  const char* s= ((res == Rows_log_event::ROW_LOOKUP_TABLE_SCAN) ? \"TABLE_SCAN\" :\n                  ((res == Rows_log_event::ROW_LOOKUP_HASH_SCAN) ? \"HASH_SCAN\" : \n                   \"INDEX_SCAN\"));\n\n  var->type= SHOW_CHAR;\n  var->value= buff;\n  sprintf(buff, \"%s\", s);\n\n  return 0;\n}\n\nstatic int show_ongoing_automatic_gtid_violating_transaction_count(\n  THD *thd, SHOW_VAR *var, char *buf)\n{\n  var->type= SHOW_CHAR;\n  var->value= buf;\n  sprintf(buf, \"%d\",\n          gtid_state->get_automatic_gtid_violating_transaction_count());\n  return 0;\n}\n\nstatic int show_ongoing_anonymous_gtid_violating_transaction_count(\n  THD *thd, SHOW_VAR *var, char *buf)\n{\n  var->type= SHOW_CHAR;\n  var->value= buf;\n  sprintf(buf, \"%d\",\n          gtid_state->get_anonymous_gtid_violating_transaction_count());\n  return 0;\n}\n\n#endif\n\nstatic int show_ongoing_anonymous_transaction_count(\n  THD *thd, SHOW_VAR *var, char *buf)\n{\n  var->type= SHOW_CHAR;\n  var->value= buf;\n  sprintf(buf, \"%d\", gtid_state->get_anonymous_ownership_count());\n  return 0;\n}\n\n#endif /* HAVE_REPLICATION */\n\nstatic int show_open_tables(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long)table_cache_manager.cached_tables();\n  return 0;\n}\n\nstatic int show_prepared_stmt_count(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  mysql_mutex_lock(&LOCK_prepared_stmt_count);\n  *((long *)buff)= (long)prepared_stmt_count;\n  mysql_mutex_unlock(&LOCK_prepared_stmt_count);\n  return 0;\n}\n\nstatic int show_table_definitions(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long)cached_table_definitions();\n  return 0;\n}\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n/* Functions relying on CTX */\nstatic int show_ssl_ctx_sess_accept(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_accept_good(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept_good(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect_good(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect_good(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_accept_renegotiate(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept_renegotiate(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect_renegotiate(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect_renegotiate(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_cb_hits(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_cb_hits(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_hits(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_hits(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_cache_full(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_cache_full(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_misses(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_misses(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_timeouts(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_timeouts(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_number(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_number(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_get_cache_size(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_get_cache_size(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_get_verify_mode(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_get_verify_depth(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_session_cache_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if (!ssl_acceptor_fd)\n    var->value= const_cast<char*>(\"NONE\");\n  else\n    switch (SSL_CTX_get_session_cache_mode(ssl_acceptor_fd->ssl_context))\n    {\n    case SSL_SESS_CACHE_OFF:\n      var->value= const_cast<char*>(\"OFF\"); break;\n    case SSL_SESS_CACHE_CLIENT:\n      var->value= const_cast<char*>(\"CLIENT\"); break;\n    case SSL_SESS_CACHE_SERVER:\n      var->value= const_cast<char*>(\"SERVER\"); break;\n    case SSL_SESS_CACHE_BOTH:\n      var->value= const_cast<char*>(\"BOTH\"); break;\n    case SSL_SESS_CACHE_NO_AUTO_CLEAR:\n      var->value= const_cast<char*>(\"NO_AUTO_CLEAR\"); break;\n    case SSL_SESS_CACHE_NO_INTERNAL_LOOKUP:\n      var->value= const_cast<char*>(\"NO_INTERNAL_LOOKUP\"); break;\n    default:\n      var->value= const_cast<char*>(\"Unknown\"); break;\n    }\n  return 0;\n}\n\n/*\n   Functions relying on SSL\n   Note: In the show_ssl_* functions, we need to check if we have a\n         valid vio-object since this isn't always true, specifically\n         when session_status or global_status is requested from\n         inside an Event.\n */\nstatic int show_ssl_get_version(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if (thd->get_protocol()->get_ssl())\n    var->value=\n      const_cast<char*>(SSL_get_version(thd->get_protocol()->get_ssl()));\n  else\n    var->value= (char *)\"\";\n  return 0;\n}\n\nstatic int show_ssl_session_reused(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if (thd->get_protocol()->get_ssl())\n    *((long *)buff)=\n        (long)SSL_session_reused(thd->get_protocol()->get_ssl());\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_default_timeout(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if (thd->get_protocol()->get_ssl())\n    *((long *)buff)=\n      (long)SSL_get_default_timeout(thd->get_protocol()->get_ssl());\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if (thd->get_protocol()->get_ssl())\n    *((long *)buff)=\n      (long)SSL_get_verify_mode(thd->get_protocol()->get_ssl());\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if (thd->get_protocol()->get_ssl())\n    *((long *)buff)=\n        (long)SSL_get_verify_depth(thd->get_protocol()->get_ssl());\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_cipher(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if (thd->get_protocol()->get_ssl())\n    var->value=\n      const_cast<char*>(SSL_get_cipher(thd->get_protocol()->get_ssl()));\n  else\n    var->value= (char *)\"\";\n  return 0;\n}\n\nstatic int show_ssl_get_cipher_list(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  var->value= buff;\n  if (thd->get_protocol()->get_ssl())\n  {\n    int i;\n    const char *p;\n    char *end= buff + SHOW_VAR_FUNC_BUFF_SIZE;\n    for (i=0; (p= SSL_get_cipher_list(thd->get_protocol()->get_ssl(),i)) &&\n               buff < end; i++)\n    {\n      buff= my_stpnmov(buff, p, end-buff-1);\n      *buff++= ':';\n    }\n    if (i)\n      buff--;\n  }\n  *buff=0;\n  return 0;\n}\n\n\n#ifdef HAVE_YASSL\n\nstatic char *\nmy_asn1_time_to_string(ASN1_TIME *time, char *buf, size_t len)\n{\n  return yaSSL_ASN1_TIME_to_string(time, buf, len);\n}\n\n#else /* openssl */\n\nstatic char *\nmy_asn1_time_to_string(ASN1_TIME *time, char *buf, size_t len)\n{\n  int n_read;\n  char *res= NULL;\n  BIO *bio= BIO_new(BIO_s_mem());\n\n  if (bio == NULL)\n    return NULL;\n\n  if (!ASN1_TIME_print(bio, time))\n    goto end;\n\n  n_read= BIO_read(bio, buf, (int) (len - 1));\n\n  if (n_read > 0)\n  {\n    buf[n_read]= 0;\n    res= buf;\n  }\n\nend:\n  BIO_free(bio);\n  return res;\n}\n\n#endif\n\n\n/**\n  Handler function for the 'ssl_get_server_not_before' variable\n\n  @param      thd  the mysql thread structure\n  @param      var  the data for the variable\n  @param[out] buf  the string to put the value of the variable into\n\n  @return          status\n  @retval     0    success\n*/\n\nstatic int\nshow_ssl_get_server_not_before(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if (ssl_acceptor_fd)\n  {\n    X509 *cert= SSL_get_certificate(ssl_acceptor);\n    ASN1_TIME *not_before= X509_get_notBefore(cert);\n\n    if (not_before == NULL)\n    {\n      var->value= empty_c_string;\n      return 0;\n    }\n\n    var->value= my_asn1_time_to_string(not_before, buff,\n                                       SHOW_VAR_FUNC_BUFF_SIZE);\n    if (var->value == NULL)\n    {\n      var->value= empty_c_string;\n      return 1;\n    }\n  }\n  else\n    var->value= empty_c_string;\n  return 0;\n}\n\n\n/**\n  Handler function for the 'ssl_get_server_not_after' variable\n\n  @param      thd  the mysql thread structure\n  @param      var  the data for the variable\n  @param[out] buf  the string to put the value of the variable into\n\n  @return          status\n  @retval     0    success\n*/\n\nstatic int\nshow_ssl_get_server_not_after(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if (ssl_acceptor_fd)\n  {\n    X509 *cert= SSL_get_certificate(ssl_acceptor);\n    ASN1_TIME *not_after= X509_get_notAfter(cert);\n\n    if (not_after == NULL)\n    {\n      var->value= empty_c_string;\n      return 0;\n    }\n\n    var->value= my_asn1_time_to_string(not_after, buff,\n                                       SHOW_VAR_FUNC_BUFF_SIZE);\n    if (var->value == NULL)\n    {\n      var->value= empty_c_string;\n      return 1;\n    }\n  }\n  else\n    var->value= empty_c_string;\n  return 0;\n}\n\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY */\n\nstatic int show_slave_open_temp_tables(THD *thd, SHOW_VAR *var, char *buf)\n{\n  var->type= SHOW_INT;\n  var->value= buf;\n  *((int *) buf)= slave_open_temp_tables.atomic_get();\n  return 0;\n}\n\n/*\n  Variables shown by SHOW STATUS in alphabetical order\n*/\n\nSHOW_VAR status_vars[]= {\n  {\"Aborted_clients\",          (char*) &aborted_threads,                              SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n#ifndef EMBEDDED_LIBRARY\n  {\"Aborted_connects\",         (char*) &show_aborted_connects,                        SHOW_FUNC,               SHOW_SCOPE_GLOBAL},\n#endif\n#ifdef HAVE_REPLICATION\n#ifndef DBUG_OFF\n  {\"Ongoing_anonymous_gtid_violating_transaction_count\",(char*) &show_ongoing_anonymous_gtid_violating_transaction_count, SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n#endif//!DBUG_OFF\n  {\"Ongoing_anonymous_transaction_count\",(char*) &show_ongoing_anonymous_transaction_count, SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n#ifndef DBUG_OFF\n  {\"Ongoing_automatic_gtid_violating_transaction_count\",(char*) &show_ongoing_automatic_gtid_violating_transaction_count, SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n#endif//!DBUG_OFF\n#endif//HAVE_REPLICATION\n  {\"Binlog_cache_disk_use\",    (char*) &binlog_cache_disk_use,                        SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Binlog_cache_use\",         (char*) &binlog_cache_use,                             SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Binlog_stmt_cache_disk_use\",(char*) &binlog_stmt_cache_disk_use,                  SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Binlog_stmt_cache_use\",    (char*) &binlog_stmt_cache_use,                        SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Bytes_received\",           (char*) offsetof(STATUS_VAR, bytes_received),          SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Bytes_sent\",               (char*) offsetof(STATUS_VAR, bytes_sent),              SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Com\",                      (char*) com_status_vars,                               SHOW_ARRAY,              SHOW_SCOPE_ALL},\n  {\"Com_stmt_reprepare\",       (char*) offsetof(STATUS_VAR, com_stmt_reprepare),      SHOW_LONG_STATUS,        SHOW_SCOPE_ALL},\n  {\"Compression\",              (char*) &show_net_compression,                         SHOW_FUNC,               SHOW_SCOPE_SESSION},\n  {\"Connections\",              (char*) &show_thread_id_count,                         SHOW_FUNC,               SHOW_SCOPE_GLOBAL},\n#ifndef EMBEDDED_LIBRARY\n  {\"Connection_errors_accept\",   (char*) &show_connection_errors_accept,              SHOW_FUNC,               SHOW_SCOPE_GLOBAL},\n  {\"Connection_errors_internal\", (char*) &connection_errors_internal,                 SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Connection_errors_max_connections\",   (char*) &show_connection_errors_max_connection, SHOW_FUNC,           SHOW_SCOPE_GLOBAL},\n  {\"Connection_errors_peer_address\", (char*) &connection_errors_peer_addr,            SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Connection_errors_select\",   (char*) &show_connection_errors_select,              SHOW_FUNC,               SHOW_SCOPE_GLOBAL},\n  {\"Connection_errors_tcpwrap\",  (char*) &show_connection_errors_tcpwrap,             SHOW_FUNC,               SHOW_SCOPE_GLOBAL},\n#endif\n  {\"Created_tmp_disk_tables\",  (char*) offsetof(STATUS_VAR, created_tmp_disk_tables), SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Created_tmp_files\",        (char*) &my_tmp_file_created,                          SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Created_tmp_tables\",       (char*) offsetof(STATUS_VAR, created_tmp_tables),      SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Delayed_errors\",           (char*) &delayed_insert_errors,                        SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Delayed_insert_threads\",   (char*) &delayed_insert_threads,                       SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Delayed_writes\",           (char*) &delayed_insert_writes,                        SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Flush_commands\",           (char*) &refresh_version,                              SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Handler_commit\",           (char*) offsetof(STATUS_VAR, ha_commit_count),         SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_delete\",           (char*) offsetof(STATUS_VAR, ha_delete_count),         SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_discover\",         (char*) offsetof(STATUS_VAR, ha_discover_count),       SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_external_lock\",    (char*) offsetof(STATUS_VAR, ha_external_lock_count),  SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_mrr_init\",         (char*) offsetof(STATUS_VAR, ha_multi_range_read_init_count), SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n  {\"Handler_prepare\",          (char*) offsetof(STATUS_VAR, ha_prepare_count),        SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_read_first\",       (char*) offsetof(STATUS_VAR, ha_read_first_count),     SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_read_key\",         (char*) offsetof(STATUS_VAR, ha_read_key_count),       SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_read_last\",        (char*) offsetof(STATUS_VAR, ha_read_last_count),      SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_read_next\",        (char*) offsetof(STATUS_VAR, ha_read_next_count),      SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_read_prev\",        (char*) offsetof(STATUS_VAR, ha_read_prev_count),      SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_read_rnd\",         (char*) offsetof(STATUS_VAR, ha_read_rnd_count),       SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_read_rnd_next\",    (char*) offsetof(STATUS_VAR, ha_read_rnd_next_count),  SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_rollback\",         (char*) offsetof(STATUS_VAR, ha_rollback_count),       SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_savepoint\",        (char*) offsetof(STATUS_VAR, ha_savepoint_count),      SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_savepoint_rollback\",(char*) offsetof(STATUS_VAR, ha_savepoint_rollback_count), SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n  {\"Handler_update\",           (char*) offsetof(STATUS_VAR, ha_update_count),         SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Handler_write\",            (char*) offsetof(STATUS_VAR, ha_write_count),          SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Key_blocks_not_flushed\",   (char*) offsetof(KEY_CACHE, global_blocks_changed),    SHOW_KEY_CACHE_LONG,     SHOW_SCOPE_GLOBAL},\n  {\"Key_blocks_unused\",        (char*) offsetof(KEY_CACHE, blocks_unused),            SHOW_KEY_CACHE_LONG,     SHOW_SCOPE_GLOBAL},\n  {\"Key_blocks_used\",          (char*) offsetof(KEY_CACHE, blocks_used),              SHOW_KEY_CACHE_LONG,     SHOW_SCOPE_GLOBAL},\n  {\"Key_read_requests\",        (char*) offsetof(KEY_CACHE, global_cache_r_requests),  SHOW_KEY_CACHE_LONGLONG, SHOW_SCOPE_GLOBAL},\n  {\"Key_reads\",                (char*) offsetof(KEY_CACHE, global_cache_read),        SHOW_KEY_CACHE_LONGLONG, SHOW_SCOPE_GLOBAL},\n  {\"Key_write_requests\",       (char*) offsetof(KEY_CACHE, global_cache_w_requests),  SHOW_KEY_CACHE_LONGLONG, SHOW_SCOPE_GLOBAL},\n  {\"Key_writes\",               (char*) offsetof(KEY_CACHE, global_cache_write),       SHOW_KEY_CACHE_LONGLONG, SHOW_SCOPE_GLOBAL},\n  {\"Last_query_cost\",          (char*) offsetof(STATUS_VAR, last_query_cost),         SHOW_DOUBLE_STATUS,      SHOW_SCOPE_SESSION},\n  {\"Last_query_partial_plans\", (char*) offsetof(STATUS_VAR, last_query_partial_plans),SHOW_LONGLONG_STATUS,    SHOW_SCOPE_SESSION},\n#ifndef EMBEDDED_LIBRARY\n  {\"Locked_connects\",          (char*) &locked_account_connection_count,              SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n#endif\n  {\"Max_execution_time_exceeded\",   (char*) offsetof(STATUS_VAR, max_execution_time_exceeded),   SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n  {\"Max_execution_time_set\",        (char*) offsetof(STATUS_VAR, max_execution_time_set),        SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n  {\"Max_execution_time_set_failed\", (char*) offsetof(STATUS_VAR, max_execution_time_set_failed), SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n  {\"Max_used_connections\",     (char*) &Connection_handler_manager::max_used_connections,        SHOW_LONG,        SHOW_SCOPE_GLOBAL},\n  {\"Max_used_connections_time\",(char*) &show_max_used_connections_time,               SHOW_FUNC,               SHOW_SCOPE_GLOBAL},\n  {\"Not_flushed_delayed_rows\", (char*) &delayed_rows_in_use,                          SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Open_files\",               (char*) &my_file_opened,                               SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Open_streams\",             (char*) &my_stream_opened,                             SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Open_table_definitions\",   (char*) &show_table_definitions,                       SHOW_FUNC,               SHOW_SCOPE_GLOBAL},\n  {\"Open_tables\",              (char*) &show_open_tables,                             SHOW_FUNC,               SHOW_SCOPE_ALL},\n  {\"Opened_files\",             (char*) &my_file_total_opened,                         SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Opened_tables\",            (char*) offsetof(STATUS_VAR, opened_tables),           SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Opened_table_definitions\", (char*) offsetof(STATUS_VAR, opened_shares),           SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Prepared_stmt_count\",      (char*) &show_prepared_stmt_count,                     SHOW_FUNC,               SHOW_SCOPE_GLOBAL},\n  {\"Qcache_free_blocks\",       (char*) &query_cache.free_memory_blocks,               SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Qcache_free_memory\",       (char*) &query_cache.free_memory,                      SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Qcache_hits\",              (char*) &query_cache.hits,                             SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Qcache_inserts\",           (char*) &query_cache.inserts,                          SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Qcache_lowmem_prunes\",     (char*) &query_cache.lowmem_prunes,                    SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Qcache_not_cached\",        (char*) &query_cache.refused,                          SHOW_LONG,               SHOW_SCOPE_GLOBAL},\n  {\"Qcache_queries_in_cache\",  (char*) &query_cache.queries_in_cache,                 SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Qcache_total_blocks\",      (char*) &query_cache.total_blocks,                     SHOW_LONG_NOFLUSH,       SHOW_SCOPE_GLOBAL},\n  {\"Queries\",                  (char*) &show_queries,                                 SHOW_FUNC,               SHOW_SCOPE_ALL},\n  {\"Questions\",                (char*) offsetof(STATUS_VAR, questions),               SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Select_full_join\",         (char*) offsetof(STATUS_VAR, select_full_join_count),  SHOW_LONGLONG_STATUS,    SHOW_SCOPE_ALL},\n  {\"Select_full_range_join\",   (char*) offsetof(STATUS_VAR, select_full_range_join_count), SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n  {\"Select_range\",             (char*) offsetof(STATUS_VAR, select_range_count),       SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n  {\"Select_range_check\",       (char*) offsetof(STATUS_VAR, select_range_check_count), SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n  {\"Select_scan\",\t       (char*) offsetof(STATUS_VAR, select_scan_count),              SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n  {\"Slave_open_temp_tables\",   (char*) &show_slave_open_temp_tables,                   SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n#ifdef HAVE_REPLICATION\n  {\"Slave_retried_transactions\",(char*) &show_slave_retried_trans,                     SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Slave_heartbeat_period\",   (char*) &show_heartbeat_period,                         SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Slave_received_heartbeats\",(char*) &show_slave_received_heartbeats,                SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Slave_last_heartbeat\",     (char*) &show_slave_last_heartbeat,                     SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n#ifndef DBUG_OFF\n  {\"Slave_rows_last_search_algorithm_used\",(char*) &show_slave_rows_last_search_algorithm_used, SHOW_FUNC,     SHOW_SCOPE_GLOBAL},\n#endif\n  {\"Slave_running\",            (char*) &show_slave_running,                            SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n#endif\n#ifndef EMBEDDED_LIBRARY\n  {\"Slow_launch_threads\",      (char*) &Per_thread_connection_handler::slow_launch_threads, SHOW_LONG,         SHOW_SCOPE_ALL},\n#endif\n  {\"Slow_queries\",             (char*) offsetof(STATUS_VAR, long_query_count),         SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n  {\"Sort_merge_passes\",        (char*) offsetof(STATUS_VAR, filesort_merge_passes),    SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n  {\"Sort_range\",               (char*) offsetof(STATUS_VAR, filesort_range_count),     SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n  {\"Sort_rows\",                (char*) offsetof(STATUS_VAR, filesort_rows),            SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n  {\"Sort_scan\",                (char*) offsetof(STATUS_VAR, filesort_scan_count),      SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  {\"Ssl_accept_renegotiates\",  (char*) &show_ssl_ctx_sess_accept_renegotiate,          SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_accepts\",              (char*) &show_ssl_ctx_sess_accept,                      SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_callback_cache_hits\",  (char*) &show_ssl_ctx_sess_cb_hits,                     SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_cipher\",               (char*) &show_ssl_get_cipher,                           SHOW_FUNC,              SHOW_SCOPE_ALL},\n  {\"Ssl_cipher_list\",          (char*) &show_ssl_get_cipher_list,                      SHOW_FUNC,              SHOW_SCOPE_ALL},\n  {\"Ssl_client_connects\",      (char*) &show_ssl_ctx_sess_connect,                     SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_connect_renegotiates\", (char*) &show_ssl_ctx_sess_connect_renegotiate,         SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_ctx_verify_depth\",     (char*) &show_ssl_ctx_get_verify_depth,                 SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_ctx_verify_mode\",      (char*) &show_ssl_ctx_get_verify_mode,                  SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_default_timeout\",      (char*) &show_ssl_get_default_timeout,                  SHOW_FUNC,              SHOW_SCOPE_ALL},\n  {\"Ssl_finished_accepts\",     (char*) &show_ssl_ctx_sess_accept_good,                 SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_finished_connects\",    (char*) &show_ssl_ctx_sess_connect_good,                SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_session_cache_hits\",   (char*) &show_ssl_ctx_sess_hits,                        SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_session_cache_misses\", (char*) &show_ssl_ctx_sess_misses,                      SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_session_cache_mode\",   (char*) &show_ssl_ctx_get_session_cache_mode,           SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_session_cache_overflows\", (char*) &show_ssl_ctx_sess_cache_full,               SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_session_cache_size\",   (char*) &show_ssl_ctx_sess_get_cache_size,              SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_session_cache_timeouts\", (char*) &show_ssl_ctx_sess_timeouts,                  SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_sessions_reused\",      (char*) &show_ssl_session_reused,                       SHOW_FUNC,              SHOW_SCOPE_ALL},\n  {\"Ssl_used_session_cache_entries\",(char*) &show_ssl_ctx_sess_number,                 SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Ssl_verify_depth\",         (char*) &show_ssl_get_verify_depth,                     SHOW_FUNC,              SHOW_SCOPE_ALL},\n  {\"Ssl_verify_mode\",          (char*) &show_ssl_get_verify_mode,                      SHOW_FUNC,              SHOW_SCOPE_ALL},\n  {\"Ssl_version\",              (char*) &show_ssl_get_version,                          SHOW_FUNC,              SHOW_SCOPE_ALL},\n  {\"Ssl_server_not_before\",    (char*) &show_ssl_get_server_not_before,                SHOW_FUNC,              SHOW_SCOPE_ALL},\n  {\"Ssl_server_not_after\",     (char*) &show_ssl_get_server_not_after,                 SHOW_FUNC,              SHOW_SCOPE_ALL},\n#ifndef HAVE_YASSL\n  {\"Rsa_public_key\",           (char*) &show_rsa_public_key,                           SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n#endif\n#endif\n#endif /* HAVE_OPENSSL */\n  {\"Table_locks_immediate\",    (char*) &locks_immediate,                               SHOW_LONG,              SHOW_SCOPE_GLOBAL},\n  {\"Table_locks_waited\",       (char*) &locks_waited,                                  SHOW_LONG,              SHOW_SCOPE_GLOBAL},\n  {\"Table_open_cache_hits\",    (char*) offsetof(STATUS_VAR, table_open_cache_hits),    SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n  {\"Table_open_cache_misses\",  (char*) offsetof(STATUS_VAR, table_open_cache_misses),  SHOW_LONGLONG_STATUS,   SHOW_SCOPE_ALL},\n  {\"Table_open_cache_overflows\",(char*) offsetof(STATUS_VAR, table_open_cache_overflows), SHOW_LONGLONG_STATUS,SHOW_SCOPE_ALL},\n  {\"Tc_log_max_pages_used\",    (char*) &tc_log_max_pages_used,                         SHOW_LONG,              SHOW_SCOPE_GLOBAL},\n  {\"Tc_log_page_size\",         (char*) &tc_log_page_size,                              SHOW_LONG_NOFLUSH,      SHOW_SCOPE_GLOBAL},\n  {\"Tc_log_page_waits\",        (char*) &tc_log_page_waits,                             SHOW_LONG,              SHOW_SCOPE_GLOBAL},\n#ifndef EMBEDDED_LIBRARY\n  {\"Threads_cached\",           (char*) &Per_thread_connection_handler::blocked_pthread_count, SHOW_LONG_NOFLUSH, SHOW_SCOPE_GLOBAL},\n#endif\n  {\"Threads_connected\",        (char*) &Connection_handler_manager::connection_count,  SHOW_INT,               SHOW_SCOPE_GLOBAL},\n  {\"Threads_created\",          (char*) &show_num_thread_created,                       SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Threads_running\",          (char*) &show_num_thread_running,                       SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n  {\"Uptime\",                   (char*) &show_starttime,                                SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n#ifdef ENABLED_PROFILING\n  {\"Uptime_since_flush_status\",(char*) &show_flushstatustime,                          SHOW_FUNC,              SHOW_SCOPE_GLOBAL},\n#endif\n  {NullS, NullS, SHOW_LONG, SHOW_SCOPE_ALL}\n};\n\nvoid add_terminator(vector<my_option> *options)\n{\n  my_option empty_element=\n    {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0};\n  options->push_back(empty_element);\n}\n\n#ifndef EMBEDDED_LIBRARY\nstatic void print_version(void)\n{\n  set_server_version();\n\n  printf(\"%s  Ver %s for %s on %s (%s)\\n\",my_progname,\n   server_version,SYSTEM_TYPE,MACHINE_TYPE, MYSQL_COMPILATION_COMMENT);\n}\n\n/** Compares two options' names, treats - and _ the same */\nstatic bool operator<(const my_option &a, const my_option &b)\n{\n  const char *sa= a.name;\n  const char *sb= b.name;\n  for (; *sa || *sb; sa++, sb++)\n  {\n    if (*sa < *sb)\n    {\n      if (*sa == '-' && *sb == '_')\n        continue;\n      else\n        return true;\n    }\n    if (*sa > *sb)\n    {\n      if (*sa == '_' && *sb == '-')\n        continue;\n      else\n        return false;\n    }\n  }\n  DBUG_ASSERT(a.name == b.name);\n  return false;\n}\n\nstatic void print_help()\n{\n  MEM_ROOT mem_root;\n  init_alloc_root(key_memory_help, &mem_root, 4096, 4096);\n\n  all_options.pop_back();\n  sys_var_add_options(&all_options, sys_var::PARSE_EARLY);\n  for (my_option *opt= my_long_early_options;\n       opt->name != NULL;\n       opt++)\n  {\n    all_options.push_back(*opt);\n  }\n  add_plugin_options(&all_options, &mem_root);\n  std::sort(all_options.begin(), all_options.end(), std::less<my_option>());\n  add_terminator(&all_options);\n\n  my_print_help(&all_options[0]);\n  my_print_variables(&all_options[0]);\n\n  free_root(&mem_root, MYF(0));\n  vector<my_option>().swap(all_options);  // Deletes the vector contents.\n}\n\nstatic void usage(void)\n{\n  DBUG_ENTER(\"usage\");\n  if (!(default_charset_info= get_charset_by_csname(default_character_set_name,\n                     MY_CS_PRIMARY,\n               MYF(MY_WME))))\n    exit(MYSQLD_ABORT_EXIT);\n  if (!default_collation_name)\n    default_collation_name= (char*) default_charset_info->name;\n  print_version();\n  puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n  puts(\"Starts the MySQL database server.\\n\");\n  printf(\"Usage: %s [OPTIONS]\\n\", my_progname);\n  if (!opt_verbose)\n    puts(\"\\nFor more help options (several pages), use mysqld --verbose --help.\");\n  else\n  {\n#ifdef _WIN32\n  puts(\"NT and Win32 specific options:\\n\\\n  --install                     Install the default service (NT).\\n\\\n  --install-manual              Install the default service started manually (NT).\\n\\\n  --install service_name        Install an optional service (NT).\\n\\\n  --install-manual service_name Install an optional service started manually (NT).\\n\\\n  --remove                      Remove the default service from the service list (NT).\\n\\\n  --remove service_name         Remove the service_name from the service list (NT).\\n\\\n  --enable-named-pipe           Only to be used for the default server (NT).\\n\\\n  --standalone                  Dummy option to start as a standalone server (NT).\\\n\");\n  puts(\"\");\n#endif\n  print_defaults(MYSQL_CONFIG_NAME,load_default_groups);\n  puts(\"\");\n  set_ports();\n\n  /* Print out all the options including plugin supplied options */\n  print_help();\n\n  if (! plugins_are_initialized)\n  {\n    puts(\"\\n\\\nPlugins have parameters that are not reflected in this list\\n\\\nbecause execution stopped before plugins were initialized.\");\n  }\n\n  puts(\"\\n\\\nTo see what values a running MySQL server is using, type\\n\\\n'mysqladmin variables' instead of 'mysqld --verbose --help'.\");\n  }\n  DBUG_VOID_RETURN;\n}\n#endif /*!EMBEDDED_LIBRARY*/\n\n/**\n  Initialize MySQL global variables to default values.\n\n  @note\n    The reason to set a lot of global variables to zero is to allow one to\n    restart the embedded server with a clean environment\n    It's also needed on some exotic platforms where global variables are\n    not set to 0 when a program starts.\n\n    We don't need to set variables refered to in my_long_options\n    as these are initialized by my_getopt.\n*/\n\nstatic int mysql_init_variables(void)\n{\n  /* Things reset to zero */\n  opt_skip_slave_start= opt_reckless_slave = 0;\n  mysql_home[0]= pidfile_name[0]= 0;\n  myisam_test_invalid_symlink= test_if_data_home_dir;\n  opt_general_log= opt_slow_log= false;\n  opt_bin_log= 0;\n  opt_disable_networking= opt_skip_show_db=0;\n  opt_skip_name_resolve= 0;\n  opt_ignore_builtin_innodb= 0;\n  opt_general_logname= opt_update_logname= opt_binlog_index_name= opt_slow_logname= NULL;\n  opt_tc_log_file= (char *)\"tc.log\";      // no hostname in tc_log file name !\n  opt_secure_auth= 0;\n  opt_myisam_log= 0;\n  mqh_used= 0;\n  kill_in_progress= 0;\n  cleanup_done= 0;\n  server_id_supplied= false;\n  test_flags= select_errors= dropping_tables= ha_open_options=0;\n  slave_open_temp_tables.atomic_set(0);\n  opt_endinfo= using_udf_functions= 0;\n  opt_using_transactions= 0;\n  abort_loop= false;\n  server_operational_state= SERVER_BOOTING;\n  aborted_threads= 0;\n  delayed_insert_threads= delayed_insert_writes= delayed_rows_in_use= 0;\n  delayed_insert_errors= 0;\n  specialflag= 0;\n  binlog_cache_use=  binlog_cache_disk_use= 0;\n  mysqld_user= mysqld_chroot= opt_init_file= opt_bin_logname = 0;\n  prepared_stmt_count= 0;\n  mysqld_unix_port= opt_mysql_tmpdir= my_bind_addr_str= NullS;\n  memset(&mysql_tmpdir_list, 0, sizeof(mysql_tmpdir_list));\n  memset(&global_status_var, 0, sizeof(global_status_var));\n  opt_large_pages= 0;\n  opt_super_large_pages= 0;\n#if defined(ENABLED_DEBUG_SYNC)\n  opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  key_map_full.set_all();\n  server_uuid[0]= 0;\n\n  /* Character sets */\n  system_charset_info= &my_charset_utf8_general_ci;\n  files_charset_info= &my_charset_utf8_general_ci;\n  national_charset_info= &my_charset_utf8_general_ci;\n  table_alias_charset= &my_charset_bin;\n  character_set_filesystem= &my_charset_bin;\n\n  opt_specialflag= 0;\n  mysql_home_ptr= mysql_home;\n  pidfile_name_ptr= pidfile_name;\n  lc_messages_dir_ptr= lc_messages_dir;\n  protocol_version= PROTOCOL_VERSION;\n  what_to_log= ~ (1L << (uint) COM_TIME);\n  refresh_version= 1L;  /* Increments on each reload */\n  global_query_id= 1L;\n  my_stpcpy(server_version, MYSQL_SERVER_VERSION);\n  key_caches.empty();\n  if (!(dflt_key_cache= get_or_create_key_cache(default_key_cache_base.str,\n                                                default_key_cache_base.length)))\n  {\n    sql_print_error(\"Cannot allocate the keycache\");\n    return 1;\n  }\n  /* set key_cache_hash.default_value = dflt_key_cache */\n  multi_keycache_init();\n\n  /* Set directory paths */\n  mysql_real_data_home_len=\n    strmake(mysql_real_data_home, get_relative_path(MYSQL_DATADIR),\n            sizeof(mysql_real_data_home)-1) - mysql_real_data_home;\n  /* Replication parameters */\n  master_info_file= (char*) \"master.info\",\n    relay_log_info_file= (char*) \"relay-log.info\";\n  report_user= report_password = report_host= 0;  /* TO BE DELETED */\n  opt_relay_logname= opt_relaylog_index_name= 0;\n  log_bin_basename= NULL;\n  log_bin_index= NULL;\n\n  /* Handler variables */\n  total_ha= 0;\n  total_ha_2pc= 0;\n  /* Variables in libraries */\n  charsets_dir= 0;\n  default_character_set_name= (char*) MYSQL_DEFAULT_CHARSET_NAME;\n  default_collation_name= compiled_default_collation_name;\n  character_set_filesystem_name= (char*) \"binary\";\n  lc_messages= (char*) \"en_US\";\n  lc_time_names_name= (char*) \"en_US\";\n\n  /* Variables that depends on compile options */\n#ifndef DBUG_OFF\n  default_dbug_option=IF_WIN(\"d:t:i:O,\\\\mysqld.trace\",\n           \"d:t:i:o,/tmp/mysqld.trace\");\n#endif\n#ifdef ENABLED_PROFILING\n    have_profiling = SHOW_OPTION_YES;\n#else\n    have_profiling = SHOW_OPTION_NO;\n#endif\n\n#ifdef HAVE_OPENSSL\n  have_ssl=SHOW_OPTION_YES;\n#else\n  have_ssl=SHOW_OPTION_NO;\n#endif\n\n  have_symlink= SHOW_OPTION_YES;\n\n#ifdef HAVE_DLOPEN\n  have_dlopen=SHOW_OPTION_YES;\n#else\n  have_dlopen=SHOW_OPTION_NO;\n#endif\n\n  have_query_cache=SHOW_OPTION_YES;\n\n  have_geometry=SHOW_OPTION_YES;\n\n  have_rtree_keys=SHOW_OPTION_YES;\n\n#ifdef HAVE_CRYPT\n  have_crypt=SHOW_OPTION_YES;\n#else\n  have_crypt=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_COMPRESS\n  have_compress= SHOW_OPTION_YES;\n#else\n  have_compress= SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_OPENSSL\n  des_key_file = 0;\n#ifndef EMBEDDED_LIBRARY\n  ssl_acceptor_fd= 0;\n#endif /* ! EMBEDDED_LIBRARY */\n#endif /* HAVE_OPENSSL */\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  shared_memory_base_name= default_shared_memory_base_name;\n#endif\n\n#if defined(_WIN32)\n  /* Allow Win32 users to move MySQL anywhere */\n  {\n    char prg_dev[LIBLEN];\n    char executing_path_name[LIBLEN];\n    if (!test_if_hard_path(my_progname))\n    {\n      // we don't want to use GetModuleFileName inside of my_path since\n      // my_path is a generic path dereferencing function and here we care\n      // only about the executing binary.\n      GetModuleFileName(NULL, executing_path_name, sizeof(executing_path_name));\n      my_path(prg_dev, executing_path_name, NULL);\n    }\n    else\n      my_path(prg_dev, my_progname, \"mysql/bin\");\n    strcat(prg_dev,\"/../\");     // Remove 'bin' to get base dir\n    cleanup_dirname(mysql_home,prg_dev);\n  }\n#else\n  const char *tmpenv;\n  if (!(tmpenv = getenv(\"MY_BASEDIR_VERSION\")))\n    tmpenv = DEFAULT_MYSQL_HOME;\n  (void) strmake(mysql_home, tmpenv, sizeof(mysql_home)-1);\n#endif\n  return 0;\n}\n\nmy_bool\nmysqld_get_one_option(int optid,\n                      const struct my_option *opt MY_ATTRIBUTE((unused)),\n                      char *argument)\n{\n  switch(optid) {\n  case '#':\n#ifndef DBUG_OFF\n    DBUG_SET_INITIAL(argument ? argument : default_dbug_option);\n#endif\n    opt_endinfo=1;        /* unireg: memory allocation */\n    break;\n  case 'a':\n    global_system_variables.sql_mode= MODE_ANSI;\n    global_system_variables.tx_isolation=\n           global_system_variables.transaction_isolation= ISO_SERIALIZABLE;\n    break;\n  case 'b':\n    strmake(mysql_home,argument,sizeof(mysql_home)-1);\n    mysql_home_ptr= mysql_home;\n    break;\n  case 'C':\n    if (default_collation_name == compiled_default_collation_name)\n      default_collation_name= 0;\n    break;\n  case 'h':\n    strmake(mysql_real_data_home,argument, sizeof(mysql_real_data_home)-1);\n    /* Correct pointer set by my_getopt (for embedded library) */\n    mysql_real_data_home_ptr= mysql_real_data_home;\n    break;\n  case 'u':\n    if (!mysqld_user || !strcmp(mysqld_user, argument))\n      mysqld_user= argument;\n    else\n      sql_print_warning(\"Ignoring user change to '%s' because the user was set to '%s' earlier on the command line\\n\", argument, mysqld_user);\n    break;\n  case 'L':\n    push_deprecated_warn(NULL, \"--language/-l\", \"'--lc-messages-dir'\");\n    /* Note:  fall-through */\n  case OPT_LC_MESSAGES_DIRECTORY:\n    strmake(lc_messages_dir, argument, sizeof(lc_messages_dir)-1);\n    lc_messages_dir_ptr= lc_messages_dir;\n    break;\n  case OPT_BINLOG_FORMAT:\n    binlog_format_used= true;\n    break;\n  case OPT_BINLOG_MAX_FLUSH_QUEUE_TIME:\n    push_deprecated_warn_no_replacement(NULL, \"--binlog_max_flush_queue_time\");\n    break;\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  case OPT_SSL_KEY:\n  case OPT_SSL_CERT:\n  case OPT_SSL_CA:  \n  case OPT_SSL_CAPATH:\n  case OPT_SSL_CIPHER:\n  case OPT_SSL_CRL:   \n  case OPT_SSL_CRLPATH:\n  case OPT_TLS_VERSION:\n    /*\n      Enable use of SSL if we are using any ssl option.\n      One can disable SSL later by using --skip-ssl or --ssl=0.\n    */\n    opt_use_ssl= true;\n#ifdef HAVE_YASSL\n    /* crl has no effect in yaSSL. */\n    opt_ssl_crl= NULL;\n    opt_ssl_crlpath= NULL;\n#endif /* HAVE_YASSL */   \n    break;\n#endif /* HAVE_OPENSSL */\n#ifndef EMBEDDED_LIBRARY\n  case 'V':\n    print_version();\n    exit(MYSQLD_SUCCESS_EXIT);\n#endif /*EMBEDDED_LIBRARY*/\n  case 'W':\n    push_deprecated_warn(NULL, \"--log_warnings/-W\", \"'--log_error_verbosity'\");\n    if (!argument)\n      log_error_verbosity++;\n    else if (argument == disabled_my_option)\n     log_error_verbosity= 1L;\n    else\n      log_error_verbosity= 1 + atoi(argument);\n    log_error_verbosity= min(3UL, log_error_verbosity);\n    break;\n  case 'T':\n    test_flags= argument ? (uint) atoi(argument) : 0;\n    opt_endinfo=1;\n    break;\n  case (int) OPT_ISAM_LOG:\n    opt_myisam_log=1;\n    break;\n  case (int) OPT_BIN_LOG:\n    opt_bin_log= MY_TEST(argument != disabled_my_option);\n    break;\n#ifdef HAVE_REPLICATION\n  case (int)OPT_REPLICATE_IGNORE_DB:\n  {\n    rpl_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_DB:\n  {\n    rpl_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_REWRITE_DB:\n  {\n    char* key = argument,*p, *val;\n\n    if (!(p= strstr(argument, \"->\")))\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - missing '->'!\\n\");\n      return 1;\n    }\n    val= p + 2;\n    while(p > argument && my_isspace(mysqld_charset, p[-1]))\n      p--;\n    *p= 0;\n    if (!*key)\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty FROM db!\\n\");\n      return 1;\n    }\n    while (*val && my_isspace(mysqld_charset, *val))\n      val++;\n    if (!*val)\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty TO db!\\n\");\n      return 1;\n    }\n\n    rpl_filter->add_db_rewrite(key, val);\n    break;\n  }\n\n  case (int)OPT_BINLOG_IGNORE_DB:\n  {\n    binlog_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_BINLOG_DO_DB:\n  {\n    binlog_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_TABLE:\n  {\n    if (rpl_filter->add_do_table_array(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_DO_TABLE:\n  {\n    if (rpl_filter->add_wild_do_table(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_IGNORE_TABLE:\n  {\n    if (rpl_filter->add_wild_ignore_table(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_IGNORE_TABLE:\n  {\n    if (rpl_filter->add_ignore_table_array(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n#endif /* HAVE_REPLICATION */\n  case (int) OPT_MASTER_RETRY_COUNT:\n    push_deprecated_warn(NULL, \"--master-retry-count\", \"'CHANGE MASTER TO master_retry_count = <num>'\");\n    break;\n  case (int) OPT_SKIP_NEW:\n    opt_specialflag|= SPECIAL_NO_NEW_FUNC;\n    delay_key_write_options= DELAY_KEY_WRITE_NONE;\n    myisam_concurrent_insert=0;\n    myisam_recover_options= HA_RECOVER_OFF;\n    sp_automatic_privileges=0;\n    my_enable_symlinks= 0;\n    ha_open_options&= ~(HA_OPEN_ABORT_IF_CRASHED | HA_OPEN_DELAY_KEY_WRITE);\n    query_cache_size=0;\n    break;\n  case (int) OPT_SKIP_HOST_CACHE:\n    opt_specialflag|= SPECIAL_NO_HOST_CACHE;\n    break;\n  case (int) OPT_SKIP_RESOLVE:\n    opt_skip_name_resolve= 1;\n    opt_specialflag|=SPECIAL_NO_RESOLVE;\n    break;\n  case (int) OPT_WANT_CORE:\n    test_flags |= TEST_CORE_ON_SIGNAL;\n    break;\n  case (int) OPT_SKIP_STACK_TRACE:\n    test_flags|=TEST_NO_STACKTRACE;\n    break;\n  case OPT_BOOTSTRAP:\n    opt_bootstrap= 1;\n    break;\n  case OPT_SERVER_ID:\n    /*\n     Consider that one received a Server Id when 2 conditions are present:\n     1) The argument is on the list\n     2) There is a value present\n    */\n    server_id_supplied= (*argument != 0);\n\n    break;\n  case OPT_LOWER_CASE_TABLE_NAMES:\n    lower_case_table_names_used= 1;\n    break;\n#if defined(ENABLED_DEBUG_SYNC)\n  case OPT_DEBUG_SYNC_TIMEOUT:\n    /*\n      Debug Sync Facility. See debug_sync.cc.\n      Default timeout for WAIT_FOR action.\n      Default value is zero (facility disabled).\n      If option is given without an argument, supply a non-zero value.\n    */\n    if (!argument)\n    {\n      /* purecov: begin tested */\n      opt_debug_sync_timeout= DEBUG_SYNC_DEFAULT_WAIT_TIMEOUT;\n      /* purecov: end */\n    }\n    break;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  case OPT_LOG_ERROR:\n    /*\n      \"No --log-error\" == \"write errors to stderr\",\n      \"--log-error without argument\" == \"write errors to a file\".\n    */\n    if (argument == NULL) /* no argument */\n      log_error_dest= \"\";\n    break;\n\n  case OPT_IGNORE_DB_DIRECTORY:\n    if (*argument == 0)\n      ignore_db_dirs_reset();\n    else\n    {\n      if (push_ignored_db_dir(argument))\n      {\n        sql_print_error(\"Can't start server: \"\n                        \"cannot process --ignore-db-dir=%.*s\", \n                        FN_REFLEN, argument);\n        return 1;\n      }\n    }\n    break;\n\n  case OPT_EARLY_PLUGIN_LOAD:\n    free_list(opt_early_plugin_load_list_ptr);\n    opt_early_plugin_load_list_ptr->push_back(new i_string(argument));\n    break;\n  case OPT_PLUGIN_LOAD:\n    free_list(opt_plugin_load_list_ptr);\n    /* fall through */\n  case OPT_PLUGIN_LOAD_ADD:\n    opt_plugin_load_list_ptr->push_back(new i_string(argument));\n    break;\n  case OPT_SECURE_AUTH:\n    push_deprecated_warn_no_replacement(NULL, \"--secure-auth\");\n    if (!opt_secure_auth)\n    {\n      sql_print_error(\"Unsupported value 0 for secure-auth\");\n      return 1;\n    }\n    break;\n  case OPT_PFS_INSTRUMENT:\n    {\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#ifndef EMBEDDED_LIBRARY\n\n      /*\n        Parse instrument name and value from argument string. Handle leading\n        and trailing spaces. Also handle single quotes.\n\n        Acceptable:\n          performance_schema_instrument = ' foo/%/bar/  =  ON  '\n          performance_schema_instrument = '%=OFF'\n        Not acceptable:\n          performance_schema_instrument = '' foo/%/bar = ON ''\n          performance_schema_instrument = '%='OFF''\n      */\n      char *name= argument,*p= NULL, *val= NULL;\n      my_bool quote= false; /* true if quote detected */\n      my_bool error= true;  /* false if no errors detected */\n      const int PFS_BUFFER_SIZE= 128;\n      char orig_argument[PFS_BUFFER_SIZE+1];\n      orig_argument[0]= 0;\n\n      if (!argument)\n        goto pfs_error;\n\n      /* Save original argument string for error reporting */\n      strncpy(orig_argument, argument, PFS_BUFFER_SIZE);\n\n      /* Split instrument name and value at the equal sign */\n      if (!(p= strchr(argument, '=')))\n        goto pfs_error;\n\n      /* Get option value */\n      val= p + 1;\n      if (!*val)\n        goto pfs_error;\n\n      /* Trim leading spaces and quote from the instrument name */\n      while (*name && (my_isspace(mysqld_charset, *name) || (*name == '\\'')))\n      {\n        /* One quote allowed */\n        if (*name == '\\'')\n        {\n          if (!quote)\n            quote= true;\n          else\n            goto pfs_error;\n        }\n        name++;\n      }\n\n      /* Trim trailing spaces from instrument name */\n      while ((p > name) && my_isspace(mysqld_charset, p[-1]))\n        p--;\n      *p= 0;\n\n      /* Remove trailing slash from instrument name */\n      if (p > name && (p[-1] == '/'))\n        p[-1]= 0;\n\n      if (!*name)\n        goto pfs_error;\n\n      /* Trim leading spaces from option value */\n      while (*val && my_isspace(mysqld_charset, *val))\n        val++;\n\n      /* Trim trailing spaces and matching quote from value */\n      p= val + strlen(val);\n      while (p > val && (my_isspace(mysqld_charset, p[-1]) || p[-1] == '\\''))\n      {\n        /* One matching quote allowed */\n        if (p[-1] == '\\'')\n        {\n          if (quote)\n            quote= false;\n          else\n            goto pfs_error;\n        }\n        p--;\n      }\n\n      *p= 0;\n\n      if (!*val)\n        goto pfs_error;\n\n      /* Add instrument name and value to array of configuration options */\n      if (add_pfs_instr_to_array(name, val))\n        goto pfs_error;\n\n      error= false;\n\npfs_error:\n      if (error)\n      {\n        sql_print_warning(\"Invalid instrument name or value for \"\n                          \"performance_schema_instrument '%s'\",\n                          orig_argument);\n        return 0;\n      }\n#endif /* EMBEDDED_LIBRARY */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n      break;\n    }\n  case OPT_THREAD_CACHE_SIZE:\n    thread_cache_size_specified= true;\n    break;\n  case OPT_HOST_CACHE_SIZE:\n    host_cache_size_specified= true;\n    break;\n  case OPT_TABLE_DEFINITION_CACHE:\n    table_definition_cache_specified= true;\n    break;\n  case OPT_MDL_CACHE_SIZE:\n    push_deprecated_warn_no_replacement(NULL, \"--metadata_locks_cache_size\");\n    break;\n  case OPT_MDL_HASH_INSTANCES:\n    push_deprecated_warn_no_replacement(NULL,\n                                        \"--metadata_locks_hash_instances\");\n    break;\n  case OPT_SKIP_INNODB:\n    sql_print_warning(\"The use of InnoDB is mandatory since MySQL 5.7. \"\n                      \"The former options like '--innodb=0/1/OFF/ON' or \"\n                      \"'--skip-innodb' are ignored.\");\n    break;\n  case OPT_AVOID_TEMPORAL_UPGRADE:\n    push_deprecated_warn_no_replacement(NULL, \"avoid_temporal_upgrade\");\n    break;\n  case OPT_SHOW_OLD_TEMPORALS:\n    push_deprecated_warn_no_replacement(NULL, \"show_old_temporals\");\n    break;\n  case OPT_KEYRING_MIGRATION_PASSWORD:\n    if (argument)\n    {\n      char *start= argument;\n      opt_keyring_migration_password= my_strdup(PSI_NOT_INSTRUMENTED,\n        argument, MYF(MY_FAE));\n      while (*argument) *argument++= 'x';\n      if (*start)\n       start[1]= 0;\n    }\n    else\n      opt_keyring_migration_password= get_tty_password(NullS);\n    migrate_connect_options= 1;\n    break;\n  case OPT_KEYRING_MIGRATION_USER:\n  case OPT_KEYRING_MIGRATION_HOST:\n  case OPT_KEYRING_MIGRATION_SOCKET:\n  case OPT_KEYRING_MIGRATION_PORT:\n    migrate_connect_options= 1;\n    break;\n  case OPT_ENFORCE_GTID_CONSISTENCY:\n  {\n    const char *wrong_value=\n      fixup_enforce_gtid_consistency_command_line(argument);\n    if (wrong_value != NULL)\n      sql_print_warning(\"option 'enforce-gtid-consistency': value '%s' \"\n                        \"was not recognized. Setting enforce-gtid-consistency \"\n                        \"to OFF.\", wrong_value);\n    break;\n  }\n  case OPT_TRANSACTION_READ_ONLY:\n    global_system_variables.transaction_read_only=\n                            global_system_variables.tx_read_only;\n    break;\n  case OPT_TRANSACTION_ISOLATION:\n    global_system_variables.transaction_isolation=\n                            global_system_variables.tx_isolation;\n    break;\n  }\n  return 0;\n}\n\n\n/** Handle arguments for multiple key caches. */\n\nC_MODE_START\n\nstatic void*\nmysql_getopt_value(const char *keyname, size_t key_length,\n       const struct my_option *option, int *error)\n{\n  if (error)\n    *error= 0;\n  switch (option->id) {\n  case OPT_KEY_BUFFER_SIZE:\n  case OPT_KEY_CACHE_BLOCK_SIZE:\n  case OPT_KEY_CACHE_DIVISION_LIMIT:\n  case OPT_KEY_CACHE_AGE_THRESHOLD:\n  {\n    KEY_CACHE *key_cache;\n    if (!(key_cache= get_or_create_key_cache(keyname, key_length)))\n    {\n      if (error)\n        *error= EXIT_OUT_OF_MEMORY;\n      return 0;\n    }\n    switch (option->id) {\n    case OPT_KEY_BUFFER_SIZE:\n      return &key_cache->param_buff_size;\n    case OPT_KEY_CACHE_BLOCK_SIZE:\n      return &key_cache->param_block_size;\n    case OPT_KEY_CACHE_DIVISION_LIMIT:\n      return &key_cache->param_division_limit;\n    case OPT_KEY_CACHE_AGE_THRESHOLD:\n      return &key_cache->param_age_threshold;\n    }\n  }\n  }\n  return option->value;\n}\n\nC_MODE_END\n\n/**\n  Ensure all the deprecared options with 1 possible value are\n  within acceptable range.\n\n  @retval true error in the values set\n  @retval false all checked\n*/\nbool check_ghost_options()\n{\n  if (global_system_variables.old_passwords == 1)\n  {\n    sql_print_error(\"Invalid old_passwords mode: 1. Valid values are 2 and 0\\n\");\n    return true;\n  }\n  if (!opt_secure_auth)\n  {\n    sql_print_error(\"Invalid secure_auth mode: 0. Valid value is 1\\n\");\n    return true;\n  }\n\n  return false;\n}\n\n\n/**\n  Get server options from the command line,\n  and perform related server initializations.\n  @param [in, out] argc_ptr       command line options (count)\n  @param [in, out] argv_ptr       command line options (values)\n  @return 0 on success\n\n  @todo\n  - FIXME add EXIT_TOO_MANY_ARGUMENTS to \"mysys_err.h\" and return that code?\n*/\nstatic int get_options(int *argc_ptr, char ***argv_ptr)\n{\n  int ho_error;\n\n  my_getopt_register_get_addr(mysql_getopt_value);\n\n  /* prepare all_options array */\n  all_options.reserve(array_elements(my_long_options));\n  for (my_option *opt= my_long_options;\n       opt < my_long_options + array_elements(my_long_options) - 1;\n       opt++)\n  {\n    all_options.push_back(*opt);\n  }\n  sys_var_add_options(&all_options, sys_var::PARSE_NORMAL);\n  add_terminator(&all_options);\n\n  if (opt_help || opt_bootstrap)\n  {\n    /*\n      Show errors during --help, but gag everything else so the info the\n      user actually wants isn't lost in the spam.  (For --help --verbose,\n      we need to set up far enough to be able to print variables provided\n      by plugins, so a good number of warnings/notes might get printed.)\n      Likewise for --bootstrap.\n    */\n    struct my_option *opt= &all_options[0];\n    for (; opt->name; opt++)\n      if (!strcmp(\"log_error_verbosity\", opt->name))\n        opt->def_value= opt_initialize ? 2 : 1;\n  }\n\n  /* Skip unknown options so that they may be processed later by plugins */\n  my_getopt_skip_unknown= TRUE;\n\n  if ((ho_error= handle_options(argc_ptr, argv_ptr, &all_options[0],\n                                mysqld_get_one_option)))\n    return ho_error;\n\n  if (!opt_help)\n    vector<my_option>().swap(all_options);  // Deletes the vector contents.\n\n  /* Add back the program name handle_options removes */\n  (*argc_ptr)++;\n  (*argv_ptr)--;\n\n  /*\n    Options have been parsed. Now some of them need additional special\n    handling, like custom value checking, checking of incompatibilites\n    between options, setting of multiple variables, etc.\n    Do them here.\n  */\n\n  if (!opt_help && opt_verbose)\n    sql_print_error(\"--verbose is for use with --help; \"\n                    \"did you mean --log-error-verbosity?\");\n\n  if ((opt_log_slow_admin_statements || opt_log_queries_not_using_indexes ||\n       opt_log_slow_slave_statements) &&\n      !opt_slow_log)\n    sql_print_warning(\"options --log-slow-admin-statements, \"\n                      \"--log-queries-not-using-indexes and \"\n                      \"--log-slow-slave-statements have no effect if \"\n                      \"--slow-query-log is not set\");\n  if (global_system_variables.net_buffer_length >\n      global_system_variables.max_allowed_packet)\n  {\n    sql_print_warning(\"net_buffer_length (%lu) is set to be larger \"\n                      \"than max_allowed_packet (%lu). Please rectify.\",\n                      global_system_variables.net_buffer_length,\n                      global_system_variables.max_allowed_packet);\n  }\n\n  /*\n    TIMESTAMP columns get implicit DEFAULT values when\n    --explicit_defaults_for_timestamp is not set. \n    This behavior is deprecated now.\n  */\n  if (!opt_help && !global_system_variables.explicit_defaults_for_timestamp)\n    sql_print_warning(\"TIMESTAMP with implicit DEFAULT value is deprecated. \"\n                      \"Please use --explicit_defaults_for_timestamp server \"\n                      \"option (see documentation for more details).\");\n\n  opt_init_connect.length=strlen(opt_init_connect.str);\n  opt_init_slave.length=strlen(opt_init_slave.str);\n\n  if (global_system_variables.low_priority_updates)\n    thr_upgraded_concurrent_insert_lock= TL_WRITE_LOW_PRIORITY;\n\n  if (ft_boolean_check_syntax_string((uchar*) ft_boolean_syntax))\n  {\n    sql_print_error(\"Invalid ft-boolean-syntax string: %s\\n\",\n                    ft_boolean_syntax);\n    return 1;\n  }\n\n  if (opt_disable_networking)\n    mysqld_port= 0;\n\n  if (opt_skip_show_db)\n    opt_specialflag|= SPECIAL_SKIP_SHOW_DB;\n\n  if (check_ghost_options())\n    return 1;\n\n  if (myisam_flush)\n    flush_time= 0;\n\n#ifdef HAVE_REPLICATION\n  if (opt_slave_skip_errors)\n    add_slave_skip_errors(opt_slave_skip_errors);\n#endif\n\n  if (global_system_variables.max_join_size == HA_POS_ERROR)\n    global_system_variables.option_bits|= OPTION_BIG_SELECTS;\n  else\n    global_system_variables.option_bits&= ~OPTION_BIG_SELECTS;\n\n  // Synchronize @@global.autocommit on --autocommit\n  const ulonglong turn_bit_on= opt_autocommit ?\n    OPTION_AUTOCOMMIT : OPTION_NOT_AUTOCOMMIT;\n  global_system_variables.option_bits=\n    (global_system_variables.option_bits &\n     ~(OPTION_NOT_AUTOCOMMIT | OPTION_AUTOCOMMIT)) | turn_bit_on;\n\n  global_system_variables.sql_mode=\n    expand_sql_mode(global_system_variables.sql_mode, NULL);\n\n  if (!(global_system_variables.sql_mode & MODE_NO_AUTO_CREATE_USER))\n  {\n    sql_print_warning(\"'NO_AUTO_CREATE_USER' sql mode was not set.\");\n  }\n\n  if (!my_enable_symlinks)\n    have_symlink= SHOW_OPTION_DISABLED;\n\n  if (opt_debugging)\n  {\n    /* Allow break with SIGINT, no core or stack trace */\n    test_flags|= TEST_SIGINT | TEST_NO_STACKTRACE;\n    test_flags&= ~TEST_CORE_ON_SIGNAL;\n  }\n  /* Set global MyISAM variables from delay_key_write_options */\n  fix_delay_key_write(0, 0, OPT_GLOBAL);\n\n#ifndef EMBEDDED_LIBRARY\n#ifndef _WIN32\n  if (mysqld_chroot)\n    set_root(mysqld_chroot);\n#endif\n#else\n  max_allowed_packet= global_system_variables.max_allowed_packet;\n  net_buffer_length= global_system_variables.net_buffer_length;\n#endif\n  if (fix_paths())\n    return 1;\n\n  /*\n    Set some global variables from the global_system_variables\n    In most cases the global variables will not be used\n  */\n  my_disable_locking= myisam_single_user= MY_TEST(opt_external_locking == 0);\n  my_default_record_cache_size=global_system_variables.read_buff_size;\n\n  global_system_variables.long_query_time= (ulonglong)\n    (global_system_variables.long_query_time_double * 1e6);\n\n  if (opt_short_log_format)\n    opt_specialflag|= SPECIAL_SHORT_LOG_FORMAT;\n\n  if (init_global_datetime_format(MYSQL_TIMESTAMP_DATE,\n                                  &global_date_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_TIME,\n                                  &global_time_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_DATETIME,\n                                  &global_datetime_format))\n    return 1;\n\n#ifndef EMBEDDED_LIBRARY\n  if (Connection_handler_manager::init())\n  {\n    sql_print_error(\"Could not allocate memory for connection handling\");\n    return 1;\n  }\n#endif\n  if (Global_THD_manager::create_instance())\n  {\n    sql_print_error(\"Could not allocate memory for thread handling\");\n    return 1;\n  }\n\n  /* If --super-read-only was specified, set read_only to 1 */\n  read_only= super_read_only ? super_read_only : read_only;\n  opt_readonly= read_only;\n\n  return 0;\n}\n\n\n/*\n  Create version name for running mysqld version\n  We automaticly add suffixes -debug, -embedded, -log, -valgrind and -asan\n  to the version name to make the version more descriptive.\n  (MYSQL_SERVER_SUFFIX is set by the compilation environment)\n*/\n\nstatic void set_server_version(void)\n{\n  char *end= strxmov(server_version, MYSQL_SERVER_VERSION,\n                     MYSQL_SERVER_SUFFIX_STR, NullS);\n#ifdef EMBEDDED_LIBRARY\n  end= my_stpcpy(end, \"-embedded\");\n#endif\n#ifndef DBUG_OFF\n  if (!strstr(MYSQL_SERVER_SUFFIX_STR, \"-debug\"))\n    end= my_stpcpy(end, \"-debug\");\n#endif\n  if (opt_general_log || opt_slow_log || opt_bin_log)\n    end= my_stpcpy(end, \"-log\");          // This may slow down system\n#ifdef HAVE_VALGRIND\n  if (SERVER_VERSION_LENGTH - (end - server_version) >\n      static_cast<int>(sizeof(\"-valgrind\")))\n    end= my_stpcpy(end, \"-valgrind\"); \n#endif\n#ifdef HAVE_ASAN\n  if (SERVER_VERSION_LENGTH - (end - server_version) >\n      static_cast<int>(sizeof(\"-asan\")))\n    end= my_stpcpy(end, \"-asan\");\n#endif\n}\n\n\nstatic char *get_relative_path(const char *path)\n{\n  if (test_if_hard_path(path) &&\n      is_prefix(path,DEFAULT_MYSQL_HOME) &&\n      strcmp(DEFAULT_MYSQL_HOME,FN_ROOTDIR))\n  {\n    path+= strlen(DEFAULT_MYSQL_HOME);\n    while (is_directory_separator(*path))\n      path++;\n  }\n  return (char*) path;\n}\n\n\n/**\n  Fix filename and replace extension where 'dir' is relative to\n  mysql_real_data_home.\n  @return\n    1 if len(path) > FN_REFLEN\n*/\n\nbool\nfn_format_relative_to_data_home(char * to, const char *name,\n        const char *dir, const char *extension)\n{\n  char tmp_path[FN_REFLEN];\n  if (!test_if_hard_path(dir))\n  {\n    strxnmov(tmp_path,sizeof(tmp_path)-1, mysql_real_data_home,\n       dir, NullS);\n    dir=tmp_path;\n  }\n  return !fn_format(to, name, dir, extension,\n        MY_APPEND_EXT | MY_UNPACK_FILENAME | MY_SAFE_PATH);\n}\n\n\n/**\n  Test a file path to determine if the path is compatible with the secure file\n  path restriction.\n\n  @param path null terminated character string\n\n  @return\n    @retval TRUE The path is secure\n    @retval FALSE The path isn't secure\n*/\n\nbool is_secure_file_path(char *path)\n{\n  char buff1[FN_REFLEN], buff2[FN_REFLEN];\n  size_t opt_secure_file_priv_len;\n  /*\n    All paths are secure if opt_secure_file_priv is 0\n  */\n  if (!opt_secure_file_priv[0])\n    return TRUE;\n\n  opt_secure_file_priv_len= strlen(opt_secure_file_priv);\n\n  if (strlen(path) >= FN_REFLEN)\n    return FALSE;\n\n  if (!my_strcasecmp(system_charset_info, opt_secure_file_priv, \"NULL\"))\n    return FALSE;\n\n  if (my_realpath(buff1, path, 0))\n  {\n    /*\n      The supplied file path might have been a file and not a directory.\n    */\n    int length= (int)dirname_length(path);\n    if (length >= FN_REFLEN)\n      return FALSE;\n    memcpy(buff2, path, length);\n    buff2[length]= '\\0';\n    if (length == 0 || my_realpath(buff1, buff2, 0))\n      return FALSE;\n  }\n  convert_dirname(buff2, buff1, NullS);\n  if (!lower_case_file_system)\n  {\n    if (strncmp(opt_secure_file_priv, buff2, opt_secure_file_priv_len))\n      return FALSE;\n  }\n  else\n  {\n    if (files_charset_info->coll->strnncoll(files_charset_info,\n                                            (uchar *) buff2, strlen(buff2),\n                                            (uchar *) opt_secure_file_priv,\n                                            opt_secure_file_priv_len,\n                                            TRUE))\n      return FALSE;\n  }\n  return TRUE;\n}\n\n\n/**\n  check_secure_file_priv_path : Checks path specified through\n  --secure-file-priv and raises warning in following cases:\n  1. If path is empty string or NULL and mysqld is not running\n     with --bootstrap mode.\n  2. If path can access data directory\n  3. If path points to a directory which is accessible by\n     all OS users (non-Windows build only)\n\n  It throws error in following cases:\n\n  1. If path normalization fails\n  2. If it can not get stats of the directory\n\n  @params NONE\n\n  Assumptions :\n  1. Data directory path has been normalized\n  2. opt_secure_file_priv has been normalized unless it is set\n     to \"NULL\".\n\n  @returns Status of validation\n    @retval true : Validation is successful with/without warnings\n    @retval false : Validation failed. Error is raised.\n*/\n\nbool check_secure_file_priv_path()\n{\n  char datadir_buffer[FN_REFLEN+1]={0};\n  char plugindir_buffer[FN_REFLEN+1]={0};\n  char whichdir[20]= {0};\n  size_t opt_plugindir_len= 0;\n  size_t opt_datadir_len= 0;\n  size_t opt_secure_file_priv_len= 0;\n  bool warn= false;\n  bool case_insensitive_fs;\n#ifndef _WIN32\n  MY_STAT dir_stat;\n#endif\n\n  if (!opt_secure_file_priv[0])\n  {\n    if (opt_bootstrap)\n    {\n      /*\n        Do not impose --secure-file-priv restriction\n        in --bootstrap mode\n      */\n      sql_print_information(\"Ignoring --secure-file-priv value as server is \"\n                            \"running with --initialize(-insecure) or \"\n                            \"--bootstrap.\");\n    }\n    else\n    {\n      sql_print_warning(\"Insecure configuration for --secure-file-priv: \"\n                        \"Current value does not restrict location of generated \"\n                        \"files. Consider setting it to a valid, \"\n                        \"non-empty path.\");\n    }\n    return true;\n  }\n\n  /*\n    Setting --secure-file-priv to NULL would disable\n    reading/writing from/to file\n  */\n  if(!my_strcasecmp(system_charset_info, opt_secure_file_priv, \"NULL\"))\n  {\n    sql_print_information(\"--secure-file-priv is set to NULL. \"\n                          \"Operations related to importing and exporting \"\n                          \"data are disabled\");\n    return true;\n  }\n\n  /*\n    Check if --secure-file-priv can access data directory\n  */\n  opt_secure_file_priv_len= strlen(opt_secure_file_priv);\n\n  /*\n    Adds dir seperator at the end.\n    This is required in subsequent comparison\n  */\n  convert_dirname(datadir_buffer, mysql_unpacked_real_data_home, NullS);\n  opt_datadir_len= strlen(datadir_buffer);\n\n  case_insensitive_fs=\n    (test_if_case_insensitive(datadir_buffer) == 1);\n\n  if (!case_insensitive_fs)\n  {\n    if (!strncmp(datadir_buffer, opt_secure_file_priv,\n          opt_datadir_len < opt_secure_file_priv_len ?\n          opt_datadir_len : opt_secure_file_priv_len))\n    {\n      warn= true;\n      strcpy(whichdir, \"Data directory\");\n    }\n  }\n  else\n  {\n    if (!files_charset_info->coll->strnncoll(files_charset_info,\n          (uchar *) datadir_buffer,\n          opt_datadir_len,\n          (uchar *) opt_secure_file_priv,\n          opt_secure_file_priv_len,\n          TRUE))\n    {\n      warn= true;\n      strcpy(whichdir, \"Data directory\");\n    }\n  }\n\n  /*\n    Don't bother comparing --secure-file-priv with --plugin-dir\n    if we already have a match against --datdir or\n    --plugin-dir is not pointing to a valid directory.\n  */\n  if (!warn && !my_realpath(plugindir_buffer, opt_plugin_dir, 0))\n  {\n    convert_dirname(plugindir_buffer, plugindir_buffer, NullS);\n    opt_plugindir_len= strlen(plugindir_buffer);\n\n    if (!case_insensitive_fs)\n    {\n      if (!strncmp(plugindir_buffer, opt_secure_file_priv,\n          opt_plugindir_len < opt_secure_file_priv_len ?\n          opt_plugindir_len : opt_secure_file_priv_len))\n      {\n        warn= true;\n        strcpy(whichdir, \"Plugin directory\");\n      }\n    }\n    else\n    {\n      if (!files_charset_info->coll->strnncoll(files_charset_info,\n          (uchar *) plugindir_buffer,\n          opt_plugindir_len,\n          (uchar *) opt_secure_file_priv,\n          opt_secure_file_priv_len,\n          TRUE))\n      {\n        warn= true;\n        strcpy(whichdir, \"Plugin directory\");\n      }\n    }\n  }\n\n\n  if (warn)\n    sql_print_warning(\"Insecure configuration for --secure-file-priv: \"\n                      \"%s is accessible through \"\n                      \"--secure-file-priv. Consider choosing a different \"\n                      \"directory.\", whichdir);\n\n#ifndef _WIN32\n  /*\n     Check for --secure-file-priv directory's permission\n  */\n  if (!(my_stat(opt_secure_file_priv, &dir_stat, MYF(0))))\n  {\n    sql_print_error(\"Failed to get stat for directory pointed out \"\n                    \"by --secure-file-priv\");\n    return false;\n  }\n\n  if (dir_stat.st_mode & S_IRWXO)\n    sql_print_warning(\"Insecure configuration for --secure-file-priv: \"\n                      \"Location is accessible to all OS users. \"\n                      \"Consider choosing a different directory.\");\n#endif\n  return true;\n}\n\nstatic int fix_paths(void)\n{\n  char buff[FN_REFLEN],*pos;\n  bool secure_file_priv_nonempty= false;\n  convert_dirname(mysql_home,mysql_home,NullS);\n  /* Resolve symlinks to allow 'mysql_home' to be a relative symlink */\n  my_realpath(mysql_home,mysql_home,MYF(0));\n  /* Ensure that mysql_home ends in FN_LIBCHAR */\n  pos=strend(mysql_home);\n  if (pos[-1] != FN_LIBCHAR)\n  {\n    pos[0]= FN_LIBCHAR;\n    pos[1]= 0;\n  }\n  convert_dirname(lc_messages_dir, lc_messages_dir, NullS);\n  convert_dirname(mysql_real_data_home,mysql_real_data_home,NullS);\n  (void) my_load_path(mysql_home,mysql_home,\"\"); // Resolve current dir\n  (void) my_load_path(mysql_real_data_home,mysql_real_data_home,mysql_home);\n  (void) my_load_path(pidfile_name, pidfile_name_ptr, mysql_real_data_home);\n\n  convert_dirname(opt_plugin_dir, opt_plugin_dir_ptr ? opt_plugin_dir_ptr : \n                                  get_relative_path(PLUGINDIR), NullS);\n  (void) my_load_path(opt_plugin_dir, opt_plugin_dir, mysql_home);\n  opt_plugin_dir_ptr= opt_plugin_dir;\n\n  my_realpath(mysql_unpacked_real_data_home, mysql_real_data_home, MYF(0));\n  mysql_unpacked_real_data_home_len=\n    strlen(mysql_unpacked_real_data_home);\n  if (mysql_unpacked_real_data_home[mysql_unpacked_real_data_home_len-1] == FN_LIBCHAR)\n    --mysql_unpacked_real_data_home_len;\n\n  char *sharedir=get_relative_path(SHAREDIR);\n  if (test_if_hard_path(sharedir))\n    strmake(buff,sharedir,sizeof(buff)-1);    /* purecov: tested */\n  else\n    strxnmov(buff,sizeof(buff)-1,mysql_home,sharedir,NullS);\n  convert_dirname(buff,buff,NullS);\n  (void) my_load_path(lc_messages_dir, lc_messages_dir, buff);\n\n  /* If --character-sets-dir isn't given, use shared library dir */\n  if (charsets_dir)\n    strmake(mysql_charsets_dir, charsets_dir, sizeof(mysql_charsets_dir)-1);\n  else\n    strxnmov(mysql_charsets_dir, sizeof(mysql_charsets_dir)-1, buff,\n       CHARSET_DIR, NullS);\n  (void) my_load_path(mysql_charsets_dir, mysql_charsets_dir, buff);\n  convert_dirname(mysql_charsets_dir, mysql_charsets_dir, NullS);\n  charsets_dir=mysql_charsets_dir;\n\n  if (init_tmpdir(&mysql_tmpdir_list, opt_mysql_tmpdir))\n    return 1;\n  if (!opt_mysql_tmpdir)\n    opt_mysql_tmpdir= mysql_tmpdir;\n#ifdef HAVE_REPLICATION\n  if (!slave_load_tmpdir)\n    slave_load_tmpdir= mysql_tmpdir;\n#endif /* HAVE_REPLICATION */\n  /*\n    Convert the secure-file-priv option to system format, allowing\n    a quick strcmp to check if read or write is in an allowed dir\n  */\n  if (opt_bootstrap)\n    opt_secure_file_priv= EMPTY_STR.str;\n  secure_file_priv_nonempty= opt_secure_file_priv[0] ? true : false;\n\n  if (secure_file_priv_nonempty && strlen(opt_secure_file_priv) > FN_REFLEN)\n  {\n    sql_print_warning(\"Value for --secure-file-priv is longer than maximum \"\n                      \"limit of %d\", FN_REFLEN-1);\n    return 1;\n  }\n\n  memset(buff, 0, sizeof(buff));\n  if (secure_file_priv_nonempty &&\n      my_strcasecmp(system_charset_info, opt_secure_file_priv, \"NULL\"))\n  {\n    int retval= my_realpath(buff, opt_secure_file_priv, MYF(MY_WME));\n    if (!retval)\n    {\n      convert_dirname(secure_file_real_path, buff, NullS);\n#ifdef WIN32\n      MY_DIR *dir= my_dir(secure_file_real_path, MYF(MY_DONT_SORT+MY_WME));\n      if (!dir)\n      {\n        retval= 1;\n      }\n      else\n      {\n        my_dirend(dir);\n      }\n#endif\n    }\n\n    if (retval)\n    {\n      char err_buffer[FN_REFLEN];\n      my_snprintf(err_buffer, FN_REFLEN-1,\n                  \"Failed to access directory for --secure-file-priv.\"\n                  \" Please make sure that directory exists and is \"\n                  \"accessible by MySQL Server. Supplied value : %s\",\n                  opt_secure_file_priv);\n      err_buffer[FN_REFLEN-1]='\\0';\n      sql_print_error(\"%s\", err_buffer);\n      return 1;\n    }\n    opt_secure_file_priv= secure_file_real_path;\n  }\n\n  if (!check_secure_file_priv_path())\n    return 1;\n\n  return 0;\n}\n\n/**\n  Check if file system used for databases is case insensitive.\n\n  @param dir_name     Directory to test\n\n  @retval\n    -1  Don't know (Test failed)\n  @retval\n    0   File system is case sensitive\n  @retval\n    1   File system is case insensitive\n*/\n\nstatic int test_if_case_insensitive(const char *dir_name)\n{\n  int result= 0;\n  File file;\n  char buff[FN_REFLEN], buff2[FN_REFLEN];\n  MY_STAT stat_info;\n  DBUG_ENTER(\"test_if_case_insensitive\");\n\n  fn_format(buff, glob_hostname, dir_name, \".lower-test\",\n      MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  fn_format(buff2, glob_hostname, dir_name, \".LOWER-TEST\",\n      MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  mysql_file_delete(key_file_casetest, buff2, MYF(0));\n  if ((file= mysql_file_create(key_file_casetest,\n                               buff, 0666, O_RDWR, MYF(0))) < 0)\n  {\n    sql_print_warning(\"Can't create test file %s\", buff);\n    DBUG_RETURN(-1);\n  }\n  mysql_file_close(file, MYF(0));\n  if (mysql_file_stat(key_file_casetest, buff2, &stat_info, MYF(0)))\n    result= 1;          // Can access file\n  mysql_file_delete(key_file_casetest, buff, MYF(MY_WME));\n  DBUG_PRINT(\"exit\", (\"result: %d\", result));\n  DBUG_RETURN(result);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n\n/**\n  Create file to store pid number.\n*/\nstatic void create_pid_file()\n{\n  File file;\n  if ((file= mysql_file_create(key_file_pid, pidfile_name, 0664,\n                               O_WRONLY | O_TRUNC, MYF(MY_WME))) >= 0)\n  {\n    char buff[MAX_BIGINT_WIDTH + 1], *end;\n    end= int10_to_str((long) getpid(), buff, 10);\n    *end++= '\\n';\n    if (!mysql_file_write(file, (uchar*) buff, (uint) (end-buff),\n                          MYF(MY_WME | MY_NABP)))\n    {\n      mysql_file_close(file, MYF(0));\n      pid_file_created= true;\n      return;\n    }\n    mysql_file_close(file, MYF(0));\n  }\n  sql_print_error(\"Can't start server: can't create PID file: %s\",\n                  strerror(errno));\n  exit(MYSQLD_ABORT_EXIT);\n}\n\n\n/**\n  Remove the process' pid file.\n\n  @param  flags  file operation flags\n*/\n\nstatic void delete_pid_file(myf flags)\n{\n  File file;\n  if (opt_bootstrap ||\n      !pid_file_created ||\n      !(file= mysql_file_open(key_file_pid, pidfile_name,\n                              O_RDONLY, flags)))\n    return;\n\n  if (file == -1)\n  {\n    sql_print_information(\"Unable to delete pid file: %s\", strerror(errno));\n    return;\n  }\n\n  uchar buff[MAX_BIGINT_WIDTH + 1];\n  /* Make sure that the pid file was created by the same process. */\n  size_t error= mysql_file_read(file, buff, sizeof(buff), flags);\n  mysql_file_close(file, flags);\n  buff[sizeof(buff) - 1]= '\\0';\n  if (error != MY_FILE_ERROR &&\n      atol((char *) buff) == (long) getpid())\n  {\n    mysql_file_delete(key_file_pid, pidfile_name, flags);\n    pid_file_created= false;\n  }\n  return;\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n/**\n  Returns the current state of the server : booting, operational or shutting\n  down.\n\n  @return\n    SERVER_BOOTING        Server is not operational. It is starting.\n    SERVER_OPERATING      Server is fully initialized and operating.\n    SERVER_SHUTTING_DOWN  Server is shutting down.\n*/\nenum_server_operational_state get_server_state()\n{\n  return server_operational_state;\n}\n\n/**\n  Reset status for all threads.\n*/\nclass Reset_thd_status : public Do_THD_Impl\n{\npublic:\n  Reset_thd_status() { }\n  virtual void operator()(THD *thd)\n  {\n    /*\n      Add thread's status variabes to global status\n      and reset thread's status variables.\n    */\n    add_to_status(&global_status_var, &thd->status_var, true);\n  }\n};\n\n/**\n  Reset global and session status variables.\n*/\nvoid refresh_status(THD *thd)\n{\n  mysql_mutex_lock(&LOCK_status);\n\n  if (show_compatibility_56)\n  {\n    /*\n      Add thread's status variabes to global status\n      and reset current thread's status variables.\n    */\n    add_to_status(&global_status_var, &thd->status_var, true);\n  }\n  else\n  {\n    /* For all threads, add status to global status and then reset. */\n    Reset_thd_status reset_thd_status;\n    Global_THD_manager::get_instance()->do_for_all_thd_copy(&reset_thd_status);\n#ifndef EMBEDDED_LIBRARY\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n    /* Reset aggregated status counters. */\n    reset_pfs_status_stats();\n#endif\n#endif\n  }\n\n  /* Reset some global variables. */\n  reset_status_vars();\n\n  /* Reset the counters of all key caches (default and named). */\n  process_key_caches(reset_key_cache_counters);\n  flush_status_time= time((time_t*) 0);\n  mysql_mutex_unlock(&LOCK_status);\n\n#ifndef EMBEDDED_LIBRARY\n  /*\n    Set max_used_connections to the number of currently open\n    connections.  Do this out of LOCK_status to avoid deadlocks.\n    Status reset becomes not atomic, but status data is not exact anyway.\n  */\n  Connection_handler_manager::reset_max_used_connections();\n#endif\n}\n\n\n/*****************************************************************************\n  Instantiate variables for missing storage engines\n  This section should go away soon\n*****************************************************************************/\n\n#ifdef HAVE_PSI_INTERFACE\nPSI_mutex_key key_LOCK_tc;\n\n#ifdef HAVE_OPENSSL\nPSI_mutex_key key_LOCK_des_key_file;\n#endif /* HAVE_OPENSSL */\n\nPSI_mutex_key key_BINLOG_LOCK_commit;\nPSI_mutex_key key_BINLOG_LOCK_commit_queue;\nPSI_mutex_key key_BINLOG_LOCK_done;\nPSI_mutex_key key_BINLOG_LOCK_flush_queue;\nPSI_mutex_key key_BINLOG_LOCK_index;\nPSI_mutex_key key_BINLOG_LOCK_log;\nPSI_mutex_key key_BINLOG_LOCK_binlog_end_pos;\nPSI_mutex_key key_BINLOG_LOCK_sync;\nPSI_mutex_key key_BINLOG_LOCK_sync_queue;\nPSI_mutex_key key_BINLOG_LOCK_xids;\nPSI_mutex_key\n  key_hash_filo_lock,\n  Gtid_set::key_gtid_executed_free_intervals_mutex,\n  key_LOCK_crypt, key_LOCK_error_log,\n  key_LOCK_gdl, key_LOCK_global_system_variables,\n  key_LOCK_manager,\n  key_LOCK_prepared_stmt_count,\n  key_LOCK_server_started, key_LOCK_status,\n  key_LOCK_sql_slave_skip_counter,\n  key_LOCK_slave_net_timeout,\n  key_LOCK_system_variables_hash, key_LOCK_table_share, key_LOCK_thd_data,\n  key_LOCK_thd_sysvar,\n  key_LOCK_user_conn, key_LOCK_uuid_generator, key_LOG_LOCK_log,\n  key_master_info_data_lock, key_master_info_run_lock,\n  key_master_info_sleep_lock, key_master_info_thd_lock,\n  key_mutex_slave_reporting_capability_err_lock, key_relay_log_info_data_lock,\n  key_relay_log_info_sleep_lock, key_relay_log_info_thd_lock,\n  key_relay_log_info_log_space_lock, key_relay_log_info_run_lock,\n  key_mutex_slave_parallel_pend_jobs, key_mutex_mts_temp_tables_lock,\n  key_mutex_slave_parallel_worker_count,\n  key_mutex_slave_parallel_worker,\n  key_structure_guard_mutex, key_TABLE_SHARE_LOCK_ha_data,\n  key_LOCK_error_messages,\n  key_LOCK_log_throttle_qni, key_LOCK_query_plan, key_LOCK_thd_query,\n  key_LOCK_cost_const, key_LOCK_current_cond,\n  key_LOCK_keyring_operations;\nPSI_mutex_key key_RELAYLOG_LOCK_commit;\nPSI_mutex_key key_RELAYLOG_LOCK_commit_queue;\nPSI_mutex_key key_RELAYLOG_LOCK_done;\nPSI_mutex_key key_RELAYLOG_LOCK_flush_queue;\nPSI_mutex_key key_RELAYLOG_LOCK_index;\nPSI_mutex_key key_RELAYLOG_LOCK_log;\nPSI_mutex_key key_RELAYLOG_LOCK_sync;\nPSI_mutex_key key_RELAYLOG_LOCK_sync_queue;\nPSI_mutex_key key_RELAYLOG_LOCK_xids;\nPSI_mutex_key key_LOCK_sql_rand;\nPSI_mutex_key key_gtid_ensure_index_mutex;\nPSI_mutex_key key_mts_temp_table_LOCK;\nPSI_mutex_key key_LOCK_reset_gtid_table;\nPSI_mutex_key key_LOCK_compress_gtid_table;\nPSI_mutex_key key_mts_gaq_LOCK;\nPSI_mutex_key key_thd_timer_mutex;\nPSI_mutex_key key_LOCK_offline_mode;\nPSI_mutex_key key_LOCK_default_password_lifetime;\nPSI_mutex_key key_LOCK_group_replication_handler;\n\n#ifdef HAVE_REPLICATION\nPSI_mutex_key key_commit_order_manager_mutex;\nPSI_mutex_key key_mutex_slave_worker_hash;\n#endif\n\nstatic PSI_mutex_info all_server_mutexes[]=\n{\n  { &key_LOCK_tc, \"TC_LOG_MMAP::LOCK_tc\", 0},\n\n#ifdef HAVE_OPENSSL\n  { &key_LOCK_des_key_file, \"LOCK_des_key_file\", PSI_FLAG_GLOBAL},\n#endif /* HAVE_OPENSSL */\n\n  { &key_BINLOG_LOCK_commit, \"MYSQL_BIN_LOG::LOCK_commit\", 0 },\n  { &key_BINLOG_LOCK_commit_queue, \"MYSQL_BIN_LOG::LOCK_commit_queue\", 0 },\n  { &key_BINLOG_LOCK_done, \"MYSQL_BIN_LOG::LOCK_done\", 0 },\n  { &key_BINLOG_LOCK_flush_queue, \"MYSQL_BIN_LOG::LOCK_flush_queue\", 0 },\n  { &key_BINLOG_LOCK_index, \"MYSQL_BIN_LOG::LOCK_index\", 0},\n  { &key_BINLOG_LOCK_log, \"MYSQL_BIN_LOG::LOCK_log\", 0},\n  { &key_BINLOG_LOCK_binlog_end_pos, \"MYSQL_BIN_LOG::LOCK_binlog_end_pos\", 0},\n  { &key_BINLOG_LOCK_sync, \"MYSQL_BIN_LOG::LOCK_sync\", 0},\n  { &key_BINLOG_LOCK_sync_queue, \"MYSQL_BIN_LOG::LOCK_sync_queue\", 0 },\n  { &key_BINLOG_LOCK_xids, \"MYSQL_BIN_LOG::LOCK_xids\", 0 },\n  { &key_RELAYLOG_LOCK_commit, \"MYSQL_RELAY_LOG::LOCK_commit\", 0},\n  { &key_RELAYLOG_LOCK_commit_queue, \"MYSQL_RELAY_LOG::LOCK_commit_queue\", 0 },\n  { &key_RELAYLOG_LOCK_done, \"MYSQL_RELAY_LOG::LOCK_done\", 0 },\n  { &key_RELAYLOG_LOCK_flush_queue, \"MYSQL_RELAY_LOG::LOCK_flush_queue\", 0 },\n  { &key_RELAYLOG_LOCK_index, \"MYSQL_RELAY_LOG::LOCK_index\", 0},\n  { &key_RELAYLOG_LOCK_log, \"MYSQL_RELAY_LOG::LOCK_log\", 0},\n  { &key_RELAYLOG_LOCK_sync, \"MYSQL_RELAY_LOG::LOCK_sync\", 0},\n  { &key_RELAYLOG_LOCK_sync_queue, \"MYSQL_RELAY_LOG::LOCK_sync_queue\", 0 },\n  { &key_RELAYLOG_LOCK_xids, \"MYSQL_RELAY_LOG::LOCK_xids\", 0},\n  { &key_hash_filo_lock, \"hash_filo::lock\", 0},\n  { &Gtid_set::key_gtid_executed_free_intervals_mutex, \"Gtid_set::gtid_executed::free_intervals_mutex\", 0 },\n  { &key_LOCK_crypt, \"LOCK_crypt\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_error_log, \"LOCK_error_log\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_gdl, \"LOCK_gdl\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_system_variables, \"LOCK_global_system_variables\", PSI_FLAG_GLOBAL},\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  { &key_LOCK_handler_count, \"LOCK_handler_count\", PSI_FLAG_GLOBAL},\n#endif\n  { &key_LOCK_manager, \"LOCK_manager\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_prepared_stmt_count, \"LOCK_prepared_stmt_count\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_sql_slave_skip_counter, \"LOCK_sql_slave_skip_counter\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_slave_net_timeout, \"LOCK_slave_net_timeout\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_server_started, \"LOCK_server_started\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_keyring_operations, \"LOCK_keyring_operations\", PSI_FLAG_GLOBAL},\n#if !defined(EMBEDDED_LIBRARY) && !defined(_WIN32)\n  { &key_LOCK_socket_listener_active, \"LOCK_socket_listener_active\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_start_signal_handler, \"LOCK_start_signal_handler\", PSI_FLAG_GLOBAL},\n#endif\n  { &key_LOCK_status, \"LOCK_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_table_share, \"LOCK_table_share\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_thd_data, \"THD::LOCK_thd_data\", PSI_FLAG_VOLATILITY_SESSION},\n  { &key_LOCK_thd_query, \"THD::LOCK_thd_query\", PSI_FLAG_VOLATILITY_SESSION},\n  { &key_LOCK_thd_sysvar, \"THD::LOCK_thd_sysvar\", PSI_FLAG_VOLATILITY_SESSION},\n  { &key_LOCK_user_conn, \"LOCK_user_conn\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_uuid_generator, \"LOCK_uuid_generator\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_sql_rand, \"LOCK_sql_rand\", PSI_FLAG_GLOBAL},\n  { &key_LOG_LOCK_log, \"LOG::LOCK_log\", 0},\n  { &key_master_info_data_lock, \"Master_info::data_lock\", 0},\n  { &key_master_info_run_lock, \"Master_info::run_lock\", 0},\n  { &key_master_info_sleep_lock, \"Master_info::sleep_lock\", 0},\n  { &key_master_info_thd_lock, \"Master_info::info_thd_lock\", 0},\n  { &key_mutex_slave_reporting_capability_err_lock, \"Slave_reporting_capability::err_lock\", 0},\n  { &key_relay_log_info_data_lock, \"Relay_log_info::data_lock\", 0},\n  { &key_relay_log_info_sleep_lock, \"Relay_log_info::sleep_lock\", 0},\n  { &key_relay_log_info_thd_lock, \"Relay_log_info::info_thd_lock\", 0},\n  { &key_relay_log_info_log_space_lock, \"Relay_log_info::log_space_lock\", 0},\n  { &key_relay_log_info_run_lock, \"Relay_log_info::run_lock\", 0},\n  { &key_mutex_slave_parallel_pend_jobs, \"Relay_log_info::pending_jobs_lock\", 0},\n  { &key_mutex_slave_parallel_worker_count, \"Relay_log_info::exit_count_lock\", 0},\n  { &key_mutex_mts_temp_tables_lock, \"Relay_log_info::temp_tables_lock\", 0},\n  { &key_mutex_slave_parallel_worker, \"Worker_info::jobs_lock\", 0},\n  { &key_structure_guard_mutex, \"Query_cache::structure_guard_mutex\", 0},\n  { &key_TABLE_SHARE_LOCK_ha_data, \"TABLE_SHARE::LOCK_ha_data\", 0},\n  { &key_LOCK_error_messages, \"LOCK_error_messages\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_log_throttle_qni, \"LOCK_log_throttle_qni\", PSI_FLAG_GLOBAL},\n  { &key_gtid_ensure_index_mutex, \"Gtid_state\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_query_plan, \"THD::LOCK_query_plan\", PSI_FLAG_VOLATILITY_SESSION},\n  { &key_LOCK_cost_const, \"Cost_constant_cache::LOCK_cost_const\",\n    PSI_FLAG_GLOBAL},  \n  { &key_LOCK_current_cond, \"THD::LOCK_current_cond\", PSI_FLAG_VOLATILITY_SESSION},\n  { &key_mts_temp_table_LOCK, \"key_mts_temp_table_LOCK\", 0},\n  { &key_LOCK_reset_gtid_table, \"LOCK_reset_gtid_table\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_compress_gtid_table, \"LOCK_compress_gtid_table\", PSI_FLAG_GLOBAL},\n  { &key_mts_gaq_LOCK, \"key_mts_gaq_LOCK\", 0},\n  { &key_thd_timer_mutex, \"thd_timer_mutex\", 0},\n#ifdef HAVE_REPLICATION\n  { &key_commit_order_manager_mutex, \"Commit_order_manager::m_mutex\", 0},\n  { &key_mutex_slave_worker_hash, \"Relay_log_info::slave_worker_hash_lock\", 0},\n#endif\n  { &key_LOCK_offline_mode, \"LOCK_offline_mode\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_default_password_lifetime, \"LOCK_default_password_lifetime\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_group_replication_handler, \"LOCK_group_replication_handler\", PSI_FLAG_GLOBAL}\n};\n\nPSI_rwlock_key key_rwlock_LOCK_grant, key_rwlock_LOCK_logger,\n  key_rwlock_LOCK_sys_init_connect, key_rwlock_LOCK_sys_init_slave,\n  key_rwlock_LOCK_system_variables_hash, key_rwlock_query_cache_query_lock,\n  key_rwlock_global_sid_lock, key_rwlock_gtid_mode_lock,\n  key_rwlock_channel_map_lock, key_rwlock_channel_lock;\n\nPSI_rwlock_key key_rwlock_Trans_delegate_lock;\nPSI_rwlock_key key_rwlock_Server_state_delegate_lock;\nPSI_rwlock_key key_rwlock_Binlog_storage_delegate_lock;\n#ifdef HAVE_REPLICATION\nPSI_rwlock_key key_rwlock_Binlog_transmit_delegate_lock;\nPSI_rwlock_key key_rwlock_Binlog_relay_IO_delegate_lock;\n#endif\n\nstatic PSI_rwlock_info all_server_rwlocks[]=\n{\n#ifdef HAVE_REPLICATION\n  { &key_rwlock_Binlog_transmit_delegate_lock, \"Binlog_transmit_delegate::lock\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_Binlog_relay_IO_delegate_lock, \"Binlog_relay_IO_delegate::lock\", PSI_FLAG_GLOBAL},\n#endif\n  { &key_rwlock_LOCK_grant, \"LOCK_grant\", 0},\n  { &key_rwlock_LOCK_logger, \"LOGGER::LOCK_logger\", 0},\n  { &key_rwlock_LOCK_sys_init_connect, \"LOCK_sys_init_connect\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_sys_init_slave, \"LOCK_sys_init_slave\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_query_cache_query_lock, \"Query_cache_query::lock\", 0},\n  { &key_rwlock_global_sid_lock, \"gtid_commit_rollback\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_gtid_mode_lock, \"gtid_mode_lock\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_channel_map_lock, \"channel_map_lock\", 0},\n  { &key_rwlock_channel_lock, \"channel_lock\", 0},\n  { &key_rwlock_Trans_delegate_lock, \"Trans_delegate::lock\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_Server_state_delegate_lock, \"Server_state_delegate::lock\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_Binlog_storage_delegate_lock, \"Binlog_storage_delegate::lock\", PSI_FLAG_GLOBAL}\n};\n\nPSI_cond_key key_PAGE_cond, key_COND_active, key_COND_pool;\nPSI_cond_key key_BINLOG_update_cond,\n  key_COND_cache_status_changed, key_COND_manager,\n  key_COND_server_started,\n  key_item_func_sleep_cond, key_master_info_data_cond,\n  key_master_info_start_cond, key_master_info_stop_cond,\n  key_master_info_sleep_cond,\n  key_relay_log_info_data_cond, key_relay_log_info_log_space_cond,\n  key_relay_log_info_start_cond, key_relay_log_info_stop_cond,\n  key_relay_log_info_sleep_cond, key_cond_slave_parallel_pend_jobs,\n  key_cond_slave_parallel_worker, key_cond_mts_gaq,\n  key_cond_mts_submode_logical_clock,\n  key_TABLE_SHARE_cond, key_user_level_lock_cond;\nPSI_cond_key key_RELAYLOG_update_cond;\nPSI_cond_key key_BINLOG_COND_done;\nPSI_cond_key key_RELAYLOG_COND_done;\nPSI_cond_key key_BINLOG_prep_xids_cond;\nPSI_cond_key key_RELAYLOG_prep_xids_cond;\nPSI_cond_key key_gtid_ensure_index_cond;\nPSI_cond_key key_COND_compress_gtid_table;\nPSI_cond_key key_COND_thr_lock;\n#ifdef HAVE_REPLICATION\nPSI_cond_key key_commit_order_manager_cond;\nPSI_cond_key key_cond_slave_worker_hash;\n#endif\n\nstatic PSI_cond_info all_server_conds[]=\n{\n  { &key_PAGE_cond, \"PAGE::cond\", 0},\n  { &key_COND_active, \"TC_LOG_MMAP::COND_active\", 0},\n  { &key_COND_pool, \"TC_LOG_MMAP::COND_pool\", 0},\n  { &key_BINLOG_COND_done, \"MYSQL_BIN_LOG::COND_done\", 0},\n  { &key_BINLOG_update_cond, \"MYSQL_BIN_LOG::update_cond\", 0},\n  { &key_BINLOG_prep_xids_cond, \"MYSQL_BIN_LOG::prep_xids_cond\", 0},\n  { &key_RELAYLOG_COND_done, \"MYSQL_RELAY_LOG::COND_done\", 0},\n  { &key_RELAYLOG_update_cond, \"MYSQL_RELAY_LOG::update_cond\", 0},\n  { &key_RELAYLOG_prep_xids_cond, \"MYSQL_RELAY_LOG::prep_xids_cond\", 0},\n  { &key_COND_cache_status_changed, \"Query_cache::COND_cache_status_changed\", 0},\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  { &key_COND_handler_count, \"COND_handler_count\", PSI_FLAG_GLOBAL},\n#endif\n  { &key_COND_manager, \"COND_manager\", PSI_FLAG_GLOBAL},\n  { &key_COND_server_started, \"COND_server_started\", PSI_FLAG_GLOBAL},\n#if !defined(EMBEDDED_LIBRARY) && !defined(_WIN32)\n  { &key_COND_socket_listener_active, \"COND_socket_listener_active\", PSI_FLAG_GLOBAL},\n  { &key_COND_start_signal_handler, \"COND_start_signal_handler\", PSI_FLAG_GLOBAL},\n#endif\n  { &key_COND_thr_lock, \"COND_thr_lock\", 0 },\n  { &key_item_func_sleep_cond, \"Item_func_sleep::cond\", 0},\n  { &key_master_info_data_cond, \"Master_info::data_cond\", 0},\n  { &key_master_info_start_cond, \"Master_info::start_cond\", 0},\n  { &key_master_info_stop_cond, \"Master_info::stop_cond\", 0},\n  { &key_master_info_sleep_cond, \"Master_info::sleep_cond\", 0},\n  { &key_relay_log_info_data_cond, \"Relay_log_info::data_cond\", 0},\n  { &key_relay_log_info_log_space_cond, \"Relay_log_info::log_space_cond\", 0},\n  { &key_relay_log_info_start_cond, \"Relay_log_info::start_cond\", 0},\n  { &key_relay_log_info_stop_cond, \"Relay_log_info::stop_cond\", 0},\n  { &key_relay_log_info_sleep_cond, \"Relay_log_info::sleep_cond\", 0},\n  { &key_cond_slave_parallel_pend_jobs, \"Relay_log_info::pending_jobs_cond\", 0},\n  { &key_cond_slave_parallel_worker, \"Worker_info::jobs_cond\", 0},\n  { &key_cond_mts_gaq, \"Relay_log_info::mts_gaq_cond\", 0},\n  { &key_TABLE_SHARE_cond, \"TABLE_SHARE::cond\", 0},\n  { &key_user_level_lock_cond, \"User_level_lock::cond\", 0},\n  { &key_gtid_ensure_index_cond, \"Gtid_state\", PSI_FLAG_GLOBAL},\n  { &key_COND_compress_gtid_table, \"COND_compress_gtid_table\", PSI_FLAG_GLOBAL}\n#ifdef HAVE_REPLICATION\n  ,\n  { &key_commit_order_manager_cond, \"Commit_order_manager::m_workers.cond\", 0},\n  { &key_cond_slave_worker_hash, \"Relay_log_info::slave_worker_hash_lock\", 0}\n#endif\n};\n\nPSI_thread_key key_thread_bootstrap, key_thread_handle_manager, key_thread_main,\n  key_thread_one_connection, key_thread_signal_hand,\n  key_thread_compress_gtid_table, key_thread_parser_service;\nPSI_thread_key key_thread_timer_notifier;\n\nstatic PSI_thread_info all_server_threads[]=\n{\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_namedpipes, \"con_named_pipes\", PSI_FLAG_GLOBAL},\n  { &key_thread_handle_con_sharedmem, \"con_shared_mem\", PSI_FLAG_GLOBAL},\n  { &key_thread_handle_con_sockets, \"con_sockets\", PSI_FLAG_GLOBAL},\n  { &key_thread_handle_shutdown, \"shutdown\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 && !EMBEDDED_LIBRARY */\n  { &key_thread_timer_notifier, \"thread_timer_notifier\", PSI_FLAG_GLOBAL},\n  { &key_thread_bootstrap, \"bootstrap\", PSI_FLAG_GLOBAL},\n  { &key_thread_handle_manager, \"manager\", PSI_FLAG_GLOBAL},\n  { &key_thread_main, \"main\", PSI_FLAG_GLOBAL},\n  { &key_thread_one_connection, \"one_connection\", 0},\n  { &key_thread_signal_hand, \"signal_handler\", PSI_FLAG_GLOBAL},\n  { &key_thread_compress_gtid_table, \"compress_gtid_table\", PSI_FLAG_GLOBAL},\n  { &key_thread_parser_service, \"parser_service\", PSI_FLAG_GLOBAL},\n};\n\nPSI_file_key key_file_map;\nPSI_file_key key_file_binlog, key_file_binlog_cache,\n  key_file_binlog_index, key_file_binlog_index_cache, key_file_casetest,\n  key_file_dbopt, key_file_des_key_file, key_file_ERRMSG, key_select_to_file,\n  key_file_fileparser, key_file_frm, key_file_global_ddl_log, key_file_load,\n  key_file_loadfile, key_file_log_event_data, key_file_log_event_info,\n  key_file_master_info, key_file_misc, key_file_partition_ddl_log,\n  key_file_pid, key_file_relay_log_info, key_file_send_file, key_file_tclog,\n  key_file_trg, key_file_trn, key_file_init;\nPSI_file_key key_file_general_log, key_file_slow_log;\nPSI_file_key key_file_relaylog, key_file_relaylog_cache, key_file_relaylog_index, key_file_relaylog_index_cache;\n\nstatic PSI_file_info all_server_files[]=\n{\n  { &key_file_map, \"map\", 0},\n  { &key_file_binlog, \"binlog\", 0},\n  { &key_file_binlog_cache, \"binlog_cache\", 0},\n  { &key_file_binlog_index, \"binlog_index\", 0},\n  { &key_file_binlog_index_cache, \"binlog_index_cache\", 0},\n  { &key_file_relaylog, \"relaylog\", 0},\n  { &key_file_relaylog_cache, \"relaylog_cache\", 0},\n  { &key_file_relaylog_index, \"relaylog_index\", 0},\n  { &key_file_relaylog_index_cache, \"relaylog_index_cache\", 0},\n  { &key_file_io_cache, \"io_cache\", 0},\n  { &key_file_casetest, \"casetest\", 0},\n  { &key_file_dbopt, \"dbopt\", 0},\n  { &key_file_des_key_file, \"des_key_file\", 0},\n  { &key_file_ERRMSG, \"ERRMSG\", 0},\n  { &key_select_to_file, \"select_to_file\", 0},\n  { &key_file_fileparser, \"file_parser\", 0},\n  { &key_file_frm, \"FRM\", 0},\n  { &key_file_global_ddl_log, \"global_ddl_log\", 0},\n  { &key_file_load, \"load\", 0},\n  { &key_file_loadfile, \"LOAD_FILE\", 0},\n  { &key_file_log_event_data, \"log_event_data\", 0},\n  { &key_file_log_event_info, \"log_event_info\", 0},\n  { &key_file_master_info, \"master_info\", 0},\n  { &key_file_misc, \"misc\", 0},\n  { &key_file_partition_ddl_log, \"partition_ddl_log\", 0},\n  { &key_file_pid, \"pid\", 0},\n  { &key_file_general_log, \"query_log\", 0},\n  { &key_file_relay_log_info, \"relay_log_info\", 0},\n  { &key_file_send_file, \"send_file\", 0},\n  { &key_file_slow_log, \"slow_log\", 0},\n  { &key_file_tclog, \"tclog\", 0},\n  { &key_file_trg, \"trigger_name\", 0},\n  { &key_file_trn, \"trigger\", 0},\n  { &key_file_init, \"init\", 0}\n};\n#endif /* HAVE_PSI_INTERFACE */\n\nPSI_stage_info stage_after_create= { 0, \"After create\", 0};\nPSI_stage_info stage_allocating_local_table= { 0, \"allocating local table\", 0};\nPSI_stage_info stage_alter_inplace_prepare= { 0, \"preparing for alter table\", 0};\nPSI_stage_info stage_alter_inplace= { 0, \"altering table\", 0};\nPSI_stage_info stage_alter_inplace_commit= { 0, \"committing alter table to storage engine\", 0};\nPSI_stage_info stage_changing_master= { 0, \"Changing master\", 0};\nPSI_stage_info stage_checking_master_version= { 0, \"Checking master version\", 0};\nPSI_stage_info stage_checking_permissions= { 0, \"checking permissions\", 0};\nPSI_stage_info stage_checking_privileges_on_cached_query= { 0, \"checking privileges on cached query\", 0};\nPSI_stage_info stage_checking_query_cache_for_query= { 0, \"checking query cache for query\", 0};\nPSI_stage_info stage_cleaning_up= { 0, \"cleaning up\", 0};\nPSI_stage_info stage_closing_tables= { 0, \"closing tables\", 0};\nPSI_stage_info stage_compressing_gtid_table= { 0, \"Compressing gtid_executed table\", 0};\nPSI_stage_info stage_connecting_to_master= { 0, \"Connecting to master\", 0};\nPSI_stage_info stage_converting_heap_to_ondisk= { 0, \"converting HEAP to ondisk\", 0};\nPSI_stage_info stage_copying_to_group_table= { 0, \"Copying to group table\", 0};\nPSI_stage_info stage_copying_to_tmp_table= { 0, \"Copying to tmp table\", 0};\nPSI_stage_info stage_copy_to_tmp_table= { 0, \"copy to tmp table\", PSI_FLAG_STAGE_PROGRESS};\nPSI_stage_info stage_creating_sort_index= { 0, \"Creating sort index\", 0};\nPSI_stage_info stage_creating_table= { 0, \"creating table\", 0};\nPSI_stage_info stage_creating_tmp_table= { 0, \"Creating tmp table\", 0};\nPSI_stage_info stage_deleting_from_main_table= { 0, \"deleting from main table\", 0};\nPSI_stage_info stage_deleting_from_reference_tables= { 0, \"deleting from reference tables\", 0};\nPSI_stage_info stage_discard_or_import_tablespace= { 0, \"discard_or_import_tablespace\", 0};\nPSI_stage_info stage_end= { 0, \"end\", 0};\nPSI_stage_info stage_executing= { 0, \"executing\", 0};\nPSI_stage_info stage_execution_of_init_command= { 0, \"Execution of init_command\", 0};\nPSI_stage_info stage_explaining= { 0, \"explaining\", 0};\nPSI_stage_info stage_finished_reading_one_binlog_switching_to_next_binlog= { 0, \"Finished reading one binlog; switching to next binlog\", 0};\nPSI_stage_info stage_flushing_relay_log_and_master_info_repository= { 0, \"Flushing relay log and master info repository.\", 0};\nPSI_stage_info stage_flushing_relay_log_info_file= { 0, \"Flushing relay-log info file.\", 0};\nPSI_stage_info stage_freeing_items= { 0, \"freeing items\", 0};\nPSI_stage_info stage_fulltext_initialization= { 0, \"FULLTEXT initialization\", 0};\nPSI_stage_info stage_got_handler_lock= { 0, \"got handler lock\", 0};\nPSI_stage_info stage_got_old_table= { 0, \"got old table\", 0};\nPSI_stage_info stage_init= { 0, \"init\", 0};\nPSI_stage_info stage_insert= { 0, \"insert\", 0};\nPSI_stage_info stage_invalidating_query_cache_entries_table= { 0, \"invalidating query cache entries (table)\", 0};\nPSI_stage_info stage_invalidating_query_cache_entries_table_list= { 0, \"invalidating query cache entries (table list)\", 0};\nPSI_stage_info stage_killing_slave= { 0, \"Killing slave\", 0};\nPSI_stage_info stage_logging_slow_query= { 0, \"logging slow query\", 0};\nPSI_stage_info stage_making_temp_file_append_before_load_data= { 0, \"Making temporary file (append) before replaying LOAD DATA INFILE\", 0};\nPSI_stage_info stage_making_temp_file_create_before_load_data= { 0, \"Making temporary file (create) before replaying LOAD DATA INFILE\", 0};\nPSI_stage_info stage_manage_keys= { 0, \"manage keys\", 0};\nPSI_stage_info stage_master_has_sent_all_binlog_to_slave= { 0, \"Master has sent all binlog to slave; waiting for more updates\", 0};\nPSI_stage_info stage_opening_tables= { 0, \"Opening tables\", 0};\nPSI_stage_info stage_optimizing= { 0, \"optimizing\", 0};\nPSI_stage_info stage_preparing= { 0, \"preparing\", 0};\nPSI_stage_info stage_purging_old_relay_logs= { 0, \"Purging old relay logs\", 0};\nPSI_stage_info stage_query_end= { 0, \"query end\", 0};\nPSI_stage_info stage_queueing_master_event_to_the_relay_log= { 0, \"Queueing master event to the relay log\", 0};\nPSI_stage_info stage_reading_event_from_the_relay_log= { 0, \"Reading event from the relay log\", 0};\nPSI_stage_info stage_registering_slave_on_master= { 0, \"Registering slave on master\", 0};\nPSI_stage_info stage_removing_duplicates= { 0, \"Removing duplicates\", 0};\nPSI_stage_info stage_removing_tmp_table= { 0, \"removing tmp table\", 0};\nPSI_stage_info stage_rename= { 0, \"rename\", 0};\nPSI_stage_info stage_rename_result_table= { 0, \"rename result table\", 0};\nPSI_stage_info stage_requesting_binlog_dump= { 0, \"Requesting binlog dump\", 0};\nPSI_stage_info stage_reschedule= { 0, \"reschedule\", 0};\nPSI_stage_info stage_searching_rows_for_update= { 0, \"Searching rows for update\", 0};\nPSI_stage_info stage_sending_binlog_event_to_slave= { 0, \"Sending binlog event to slave\", 0};\nPSI_stage_info stage_sending_cached_result_to_client= { 0, \"sending cached result to client\", 0};\nPSI_stage_info stage_sending_data= { 0, \"Sending data\", 0};\nPSI_stage_info stage_setup= { 0, \"setup\", 0};\nPSI_stage_info stage_slave_has_read_all_relay_log= { 0, \"Slave has read all relay log; waiting for more updates\", 0};\nPSI_stage_info stage_slave_waiting_event_from_coordinator= { 0, \"Waiting for an event from Coordinator\", 0};\nPSI_stage_info stage_slave_waiting_for_workers_to_process_queue= { 0, \"Waiting for slave workers to process their queues\", 0};\nPSI_stage_info stage_slave_waiting_worker_queue= { 0, \"Waiting for Slave Worker queue\", 0};\nPSI_stage_info stage_slave_waiting_worker_to_free_events= { 0, \"Waiting for Slave Workers to free pending events\", 0};\nPSI_stage_info stage_slave_waiting_worker_to_release_partition= { 0, \"Waiting for Slave Worker to release partition\", 0};\nPSI_stage_info stage_slave_waiting_workers_to_exit= { 0, \"Waiting for workers to exit\", 0};\nPSI_stage_info stage_sorting_for_group= { 0, \"Sorting for group\", 0};\nPSI_stage_info stage_sorting_for_order= { 0, \"Sorting for order\", 0};\nPSI_stage_info stage_sorting_result= { 0, \"Sorting result\", 0};\nPSI_stage_info stage_statistics= { 0, \"statistics\", 0};\nPSI_stage_info stage_sql_thd_waiting_until_delay= { 0, \"Waiting until MASTER_DELAY seconds after master executed event\", 0 };\nPSI_stage_info stage_storing_result_in_query_cache= { 0, \"storing result in query cache\", 0};\nPSI_stage_info stage_storing_row_into_queue= { 0, \"storing row into queue\", 0};\nPSI_stage_info stage_system_lock= { 0, \"System lock\", 0};\nPSI_stage_info stage_update= { 0, \"update\", 0};\nPSI_stage_info stage_updating= { 0, \"updating\", 0};\nPSI_stage_info stage_updating_main_table= { 0, \"updating main table\", 0};\nPSI_stage_info stage_updating_reference_tables= { 0, \"updating reference tables\", 0};\nPSI_stage_info stage_upgrading_lock= { 0, \"upgrading lock\", 0};\nPSI_stage_info stage_user_sleep= { 0, \"User sleep\", 0};\nPSI_stage_info stage_verifying_table= { 0, \"verifying table\", 0};\nPSI_stage_info stage_waiting_for_gtid_to_be_committed= { 0, \"Waiting for GTID to be committed\", 0};\nPSI_stage_info stage_waiting_for_handler_insert= { 0, \"waiting for handler insert\", 0};\nPSI_stage_info stage_waiting_for_handler_lock= { 0, \"waiting for handler lock\", 0};\nPSI_stage_info stage_waiting_for_handler_open= { 0, \"waiting for handler open\", 0};\nPSI_stage_info stage_waiting_for_insert= { 0, \"Waiting for INSERT\", 0};\nPSI_stage_info stage_waiting_for_master_to_send_event= { 0, \"Waiting for master to send event\", 0};\nPSI_stage_info stage_waiting_for_master_update= { 0, \"Waiting for master update\", 0};\nPSI_stage_info stage_waiting_for_relay_log_space= { 0, \"Waiting for the slave SQL thread to free enough relay log space\", 0};\nPSI_stage_info stage_waiting_for_slave_mutex_on_exit= { 0, \"Waiting for slave mutex on exit\", 0};\nPSI_stage_info stage_waiting_for_slave_thread_to_start= { 0, \"Waiting for slave thread to start\", 0};\nPSI_stage_info stage_waiting_for_table_flush= { 0, \"Waiting for table flush\", 0};\nPSI_stage_info stage_waiting_for_query_cache_lock= { 0, \"Waiting for query cache lock\", 0};\nPSI_stage_info stage_waiting_for_the_next_event_in_relay_log= { 0, \"Waiting for the next event in relay log\", 0};\nPSI_stage_info stage_waiting_for_the_slave_thread_to_advance_position= { 0, \"Waiting for the slave SQL thread to advance position\", 0};\nPSI_stage_info stage_waiting_to_finalize_termination= { 0, \"Waiting to finalize termination\", 0};\nPSI_stage_info stage_worker_waiting_for_its_turn_to_commit= { 0, \"Waiting for preceding transaction to commit\", 0};\nPSI_stage_info stage_worker_waiting_for_commit_parent= { 0, \"Waiting for dependent transaction to commit\", 0};\nPSI_stage_info stage_suspending= { 0, \"Suspending\", 0};\nPSI_stage_info stage_starting= { 0, \"starting\", 0};\nPSI_stage_info stage_waiting_for_no_channel_reference= { 0, \"Waiting for no channel reference.\", 0};\n\n#ifdef HAVE_PSI_INTERFACE\n\nPSI_stage_info *all_server_stages[]=\n{\n  & stage_after_create,\n  & stage_allocating_local_table,\n  & stage_alter_inplace_prepare,\n  & stage_alter_inplace,\n  & stage_alter_inplace_commit,\n  & stage_changing_master,\n  & stage_checking_master_version,\n  & stage_checking_permissions,\n  & stage_checking_privileges_on_cached_query,\n  & stage_checking_query_cache_for_query,\n  & stage_cleaning_up,\n  & stage_closing_tables,\n  & stage_compressing_gtid_table,\n  & stage_connecting_to_master,\n  & stage_converting_heap_to_ondisk,\n  & stage_copying_to_group_table,\n  & stage_copying_to_tmp_table,\n  & stage_copy_to_tmp_table,\n  & stage_creating_sort_index,\n  & stage_creating_table,\n  & stage_creating_tmp_table,\n  & stage_deleting_from_main_table,\n  & stage_deleting_from_reference_tables,\n  & stage_discard_or_import_tablespace,\n  & stage_end,\n  & stage_executing,\n  & stage_execution_of_init_command,\n  & stage_explaining,\n  & stage_finished_reading_one_binlog_switching_to_next_binlog,\n  & stage_flushing_relay_log_and_master_info_repository,\n  & stage_flushing_relay_log_info_file,\n  & stage_freeing_items,\n  & stage_fulltext_initialization,\n  & stage_got_handler_lock,\n  & stage_got_old_table,\n  & stage_init,\n  & stage_insert,\n  & stage_invalidating_query_cache_entries_table,\n  & stage_invalidating_query_cache_entries_table_list,\n  & stage_killing_slave,\n  & stage_logging_slow_query,\n  & stage_making_temp_file_append_before_load_data,\n  & stage_making_temp_file_create_before_load_data,\n  & stage_manage_keys,\n  & stage_master_has_sent_all_binlog_to_slave,\n  & stage_opening_tables,\n  & stage_optimizing,\n  & stage_preparing,\n  & stage_purging_old_relay_logs,\n  & stage_query_end,\n  & stage_queueing_master_event_to_the_relay_log,\n  & stage_reading_event_from_the_relay_log,\n  & stage_registering_slave_on_master,\n  & stage_removing_duplicates,\n  & stage_removing_tmp_table,\n  & stage_rename,\n  & stage_rename_result_table,\n  & stage_requesting_binlog_dump,\n  & stage_reschedule,\n  & stage_searching_rows_for_update,\n  & stage_sending_binlog_event_to_slave,\n  & stage_sending_cached_result_to_client,\n  & stage_sending_data,\n  & stage_setup,\n  & stage_slave_has_read_all_relay_log,\n  & stage_slave_waiting_event_from_coordinator,\n  & stage_slave_waiting_for_workers_to_process_queue,\n  & stage_slave_waiting_worker_queue,\n  & stage_slave_waiting_worker_to_free_events,\n  & stage_slave_waiting_worker_to_release_partition,\n  & stage_slave_waiting_workers_to_exit,\n  & stage_sorting_for_group,\n  & stage_sorting_for_order,\n  & stage_sorting_result,\n  & stage_sql_thd_waiting_until_delay,\n  & stage_statistics,\n  & stage_storing_result_in_query_cache,\n  & stage_storing_row_into_queue,\n  & stage_system_lock,\n  & stage_update,\n  & stage_updating,\n  & stage_updating_main_table,\n  & stage_updating_reference_tables,\n  & stage_upgrading_lock,\n  & stage_user_sleep,\n  & stage_verifying_table,\n  & stage_waiting_for_gtid_to_be_committed,\n  & stage_waiting_for_handler_insert,\n  & stage_waiting_for_handler_lock,\n  & stage_waiting_for_handler_open,\n  & stage_waiting_for_insert,\n  & stage_waiting_for_master_to_send_event,\n  & stage_waiting_for_master_update,\n  & stage_waiting_for_relay_log_space,\n  & stage_waiting_for_slave_mutex_on_exit,\n  & stage_waiting_for_slave_thread_to_start,\n  & stage_waiting_for_table_flush,\n  & stage_waiting_for_query_cache_lock,\n  & stage_waiting_for_the_next_event_in_relay_log,\n  & stage_waiting_for_the_slave_thread_to_advance_position,\n  & stage_waiting_to_finalize_termination,\n  & stage_worker_waiting_for_its_turn_to_commit,\n  & stage_worker_waiting_for_commit_parent,\n  & stage_suspending,\n  & stage_starting,\n  & stage_waiting_for_no_channel_reference\n};\n\nPSI_socket_key key_socket_tcpip, key_socket_unix, key_socket_client_connection;\n\nstatic PSI_socket_info all_server_sockets[]=\n{\n  { &key_socket_tcpip, \"server_tcpip_socket\", PSI_FLAG_GLOBAL},\n  { &key_socket_unix, \"server_unix_socket\", PSI_FLAG_GLOBAL},\n  { &key_socket_client_connection, \"client_connection\", 0}\n};\n#endif /* HAVE_PSI_INTERFACE */\n\nPSI_memory_key key_memory_locked_table_list;\nPSI_memory_key key_memory_locked_thread_list;\nPSI_memory_key key_memory_thd_transactions;\nPSI_memory_key key_memory_delegate;\nPSI_memory_key key_memory_acl_mem;\nPSI_memory_key key_memory_acl_memex;\nPSI_memory_key key_memory_acl_cache;\nPSI_memory_key key_memory_thd_main_mem_root;\nPSI_memory_key key_memory_help;\nPSI_memory_key key_memory_new_frm_mem;\nPSI_memory_key key_memory_table_share;\nPSI_memory_key key_memory_gdl;\nPSI_memory_key key_memory_table_triggers_list;\nPSI_memory_key key_memory_servers;\nPSI_memory_key key_memory_prepared_statement_map;\nPSI_memory_key key_memory_prepared_statement_main_mem_root;\nPSI_memory_key key_memory_protocol_rset_root;\nPSI_memory_key key_memory_warning_info_warn_root;\nPSI_memory_key key_memory_sp_cache;\nPSI_memory_key key_memory_sp_head_main_root;\nPSI_memory_key key_memory_sp_head_execute_root;\nPSI_memory_key key_memory_sp_head_call_root;\nPSI_memory_key key_memory_table_mapping_root;\nPSI_memory_key key_memory_quick_range_select_root;\nPSI_memory_key key_memory_quick_index_merge_root;\nPSI_memory_key key_memory_quick_ror_intersect_select_root;\nPSI_memory_key key_memory_quick_ror_union_select_root;\nPSI_memory_key key_memory_quick_group_min_max_select_root;\nPSI_memory_key key_memory_test_quick_select_exec;\nPSI_memory_key key_memory_prune_partitions_exec;\nPSI_memory_key key_memory_binlog_recover_exec;\nPSI_memory_key key_memory_blob_mem_storage;\nPSI_memory_key key_memory_NAMED_ILINK_name;\nPSI_memory_key key_memory_Sys_var_charptr_value;\nPSI_memory_key key_memory_queue_item;\nPSI_memory_key key_memory_THD_db;\nPSI_memory_key key_memory_user_var_entry;\nPSI_memory_key key_memory_Slave_job_group_group_relay_log_name;\nPSI_memory_key key_memory_Relay_log_info_group_relay_log_name;\nPSI_memory_key key_memory_binlog_cache_mngr;\nPSI_memory_key key_memory_Row_data_memory_memory;\nPSI_memory_key key_memory_Gtid_state_to_string;\nPSI_memory_key key_memory_Owned_gtids_to_string;\nPSI_memory_key key_memory_Sort_param_tmp_buffer;\nPSI_memory_key key_memory_Filesort_info_merge;\nPSI_memory_key key_memory_Filesort_info_record_pointers;\nPSI_memory_key key_memory_handler_errmsgs;\nPSI_memory_key key_memory_handlerton;\nPSI_memory_key key_memory_XID;\nPSI_memory_key key_memory_host_cache_hostname;\nPSI_memory_key key_memory_user_var_entry_value;\nPSI_memory_key key_memory_User_level_lock;\nPSI_memory_key key_memory_MYSQL_LOG_name;\nPSI_memory_key key_memory_TC_LOG_MMAP_pages;\nPSI_memory_key key_memory_my_bitmap_map;\nPSI_memory_key key_memory_QUICK_RANGE_SELECT_mrr_buf_desc;\nPSI_memory_key key_memory_Event_queue_element_for_exec_names;\nPSI_memory_key key_memory_my_str_malloc;\nPSI_memory_key key_memory_MYSQL_BIN_LOG_basename;\nPSI_memory_key key_memory_MYSQL_BIN_LOG_index;\nPSI_memory_key key_memory_MYSQL_RELAY_LOG_basename;\nPSI_memory_key key_memory_MYSQL_RELAY_LOG_index;\nPSI_memory_key key_memory_rpl_filter;\nPSI_memory_key key_memory_errmsgs;\nPSI_memory_key key_memory_Gis_read_stream_err_msg;\nPSI_memory_key key_memory_Geometry_objects_data;\nPSI_memory_key key_memory_MYSQL_LOCK;\nPSI_memory_key key_memory_Event_scheduler_scheduler_param;\nPSI_memory_key key_memory_Owned_gtids_sidno_to_hash;\nPSI_memory_key key_memory_Mutex_cond_array_Mutex_cond;\nPSI_memory_key key_memory_TABLE_RULE_ENT;\nPSI_memory_key key_memory_Rpl_info_table;\nPSI_memory_key key_memory_Rpl_info_file_buffer;\nPSI_memory_key key_memory_db_worker_hash_entry;\nPSI_memory_key key_memory_rpl_slave_check_temp_dir;\nPSI_memory_key key_memory_rpl_slave_command_buffer;\nPSI_memory_key key_memory_binlog_ver_1_event;\nPSI_memory_key key_memory_SLAVE_INFO;\nPSI_memory_key key_memory_binlog_pos;\nPSI_memory_key key_memory_HASH_ROW_ENTRY;\nPSI_memory_key key_memory_binlog_statement_buffer;\nPSI_memory_key key_memory_partition_syntax_buffer;\nPSI_memory_key key_memory_READ_INFO;\nPSI_memory_key key_memory_JOIN_CACHE;\nPSI_memory_key key_memory_TABLE_sort_io_cache;\nPSI_memory_key key_memory_frm;\nPSI_memory_key key_memory_Unique_sort_buffer;\nPSI_memory_key key_memory_Unique_merge_buffer;\nPSI_memory_key key_memory_TABLE;\nPSI_memory_key key_memory_frm_extra_segment_buff;\nPSI_memory_key key_memory_frm_form_pos;\nPSI_memory_key key_memory_frm_string;\nPSI_memory_key key_memory_LOG_name;\nPSI_memory_key key_memory_DATE_TIME_FORMAT;\nPSI_memory_key key_memory_DDL_LOG_MEMORY_ENTRY;\nPSI_memory_key key_memory_ST_SCHEMA_TABLE;\nPSI_memory_key key_memory_ignored_db;\nPSI_memory_key key_memory_PROFILE;\nPSI_memory_key key_memory_st_mysql_plugin_dl;\nPSI_memory_key key_memory_st_mysql_plugin;\nPSI_memory_key key_memory_global_system_variables;\nPSI_memory_key key_memory_THD_variables;\nPSI_memory_key key_memory_Security_context;\nPSI_memory_key key_memory_shared_memory_name;\nPSI_memory_key key_memory_bison_stack;\nPSI_memory_key key_memory_THD_handler_tables_hash;\nPSI_memory_key key_memory_hash_index_key_buffer;\nPSI_memory_key key_memory_dboptions_hash;\nPSI_memory_key key_memory_user_conn;\nPSI_memory_key key_memory_LOG_POS_COORD;\nPSI_memory_key key_memory_XID_STATE;\nPSI_memory_key key_memory_MPVIO_EXT_auth_info;\nPSI_memory_key key_memory_opt_bin_logname;\nPSI_memory_key key_memory_Query_cache;\nPSI_memory_key key_memory_READ_RECORD_cache;\nPSI_memory_key key_memory_Quick_ranges;\nPSI_memory_key key_memory_File_query_log_name;\nPSI_memory_key key_memory_Table_trigger_dispatcher;\nPSI_memory_key key_memory_show_slave_status_io_gtid_set;\nPSI_memory_key key_memory_write_set_extraction;\nPSI_memory_key key_memory_thd_timer;\nPSI_memory_key key_memory_THD_Session_tracker;\nPSI_memory_key key_memory_THD_Session_sysvar_resource_manager;\nPSI_memory_key key_memory_get_all_tables;\nPSI_memory_key key_memory_fill_schema_schemata;\nPSI_memory_key key_memory_native_functions;\nPSI_memory_key key_memory_JSON;\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_memory_info all_server_memory[]=\n{\n  { &key_memory_locked_table_list, \"Locked_tables_list::m_locked_tables_root\", 0},\n  { &key_memory_locked_thread_list, \"display_table_locks\", PSI_FLAG_THREAD},\n  { &key_memory_thd_transactions, \"THD::transactions::mem_root\", PSI_FLAG_THREAD},\n  { &key_memory_delegate, \"Delegate::memroot\", 0},\n  { &key_memory_acl_mem, \"sql_acl_mem\", PSI_FLAG_GLOBAL},\n  { &key_memory_acl_memex, \"sql_acl_memex\", PSI_FLAG_GLOBAL},\n  { &key_memory_acl_cache, \"acl_cache\", PSI_FLAG_GLOBAL},\n  { &key_memory_thd_main_mem_root, \"thd::main_mem_root\", PSI_FLAG_THREAD},\n  { &key_memory_help, \"help\", 0},\n  { &key_memory_new_frm_mem, \"new_frm_mem\", 0},\n  { &key_memory_table_share, \"TABLE_SHARE::mem_root\", PSI_FLAG_GLOBAL}, /* table definition cache */\n  { &key_memory_gdl, \"gdl\", 0},\n  { &key_memory_table_triggers_list, \"Table_triggers_list\", 0},\n  { &key_memory_servers, \"servers\", 0},\n  { &key_memory_prepared_statement_map, \"Prepared_statement_map\", PSI_FLAG_THREAD},\n  { &key_memory_prepared_statement_main_mem_root, \"Prepared_statement::main_mem_root\", PSI_FLAG_THREAD},\n  { &key_memory_protocol_rset_root, \"Protocol_local::m_rset_root\", PSI_FLAG_THREAD},\n  { &key_memory_warning_info_warn_root, \"Warning_info::m_warn_root\", PSI_FLAG_THREAD},\n  { &key_memory_sp_cache, \"THD::sp_cache\", 0},\n  { &key_memory_sp_head_main_root, \"sp_head::main_mem_root\", 0},\n  { &key_memory_sp_head_execute_root, \"sp_head::execute_mem_root\", PSI_FLAG_THREAD},\n  { &key_memory_sp_head_call_root, \"sp_head::call_mem_root\", PSI_FLAG_THREAD},\n  { &key_memory_table_mapping_root, \"table_mapping::m_mem_root\", 0},\n  { &key_memory_quick_range_select_root, \"QUICK_RANGE_SELECT::alloc\", PSI_FLAG_THREAD},\n  { &key_memory_quick_index_merge_root, \"QUICK_INDEX_MERGE_SELECT::alloc\", PSI_FLAG_THREAD},\n  { &key_memory_quick_ror_intersect_select_root, \"QUICK_ROR_INTERSECT_SELECT::alloc\", PSI_FLAG_THREAD},\n  { &key_memory_quick_ror_union_select_root, \"QUICK_ROR_UNION_SELECT::alloc\", PSI_FLAG_THREAD},\n  { &key_memory_quick_group_min_max_select_root, \"QUICK_GROUP_MIN_MAX_SELECT::alloc\", PSI_FLAG_THREAD},\n  { &key_memory_test_quick_select_exec, \"test_quick_select\", PSI_FLAG_THREAD},\n  { &key_memory_prune_partitions_exec, \"prune_partitions::exec\", 0},\n  { &key_memory_binlog_recover_exec, \"MYSQL_BIN_LOG::recover\", 0},\n  { &key_memory_blob_mem_storage, \"Blob_mem_storage::storage\", 0},\n\n  { &key_memory_NAMED_ILINK_name, \"NAMED_ILINK::name\", 0},\n  { &key_memory_String_value, \"String::value\", 0},\n  { &key_memory_Sys_var_charptr_value, \"Sys_var_charptr::value\", 0},\n  { &key_memory_queue_item, \"Queue::queue_item\", 0},\n  { &key_memory_THD_db, \"THD::db\", 0},\n  { &key_memory_user_var_entry, \"user_var_entry\", 0},\n  { &key_memory_Slave_job_group_group_relay_log_name, \"Slave_job_group::group_relay_log_name\", 0},\n  { &key_memory_Relay_log_info_group_relay_log_name, \"Relay_log_info::group_relay_log_name\", 0},\n  { &key_memory_binlog_cache_mngr, \"binlog_cache_mngr\", 0},\n  { &key_memory_Row_data_memory_memory, \"Row_data_memory::memory\", 0},\n\n  { &key_memory_Gtid_set_to_string, \"Gtid_set::to_string\", 0},\n  { &key_memory_Gtid_state_to_string, \"Gtid_state::to_string\", 0},\n  { &key_memory_Owned_gtids_to_string, \"Owned_gtids::to_string\", 0},\n  { &key_memory_log_event, \"Log_event\", 0},\n  { &key_memory_Incident_log_event_message, \"Incident_log_event::message\", 0},\n  { &key_memory_Rows_query_log_event_rows_query, \"Rows_query_log_event::rows_query\", 0},\n\n  { &key_memory_Sort_param_tmp_buffer, \"Sort_param::tmp_buffer\", 0},\n  { &key_memory_Filesort_info_merge, \"Filesort_info::merge\", 0},\n  { &key_memory_Filesort_info_record_pointers, \"Filesort_info::record_pointers\", 0},\n  { &key_memory_Filesort_buffer_sort_keys, \"Filesort_buffer::sort_keys\", 0},\n  { &key_memory_handler_errmsgs, \"handler::errmsgs\", 0},\n  { &key_memory_handlerton, \"handlerton\", 0},\n  { &key_memory_XID, \"XID\", 0},\n  { &key_memory_host_cache_hostname, \"host_cache::hostname\", 0},\n  { &key_memory_user_var_entry_value, \"user_var_entry::value\", 0},\n  { &key_memory_User_level_lock, \"User_level_lock\", 0},\n  { &key_memory_MYSQL_LOG_name, \"MYSQL_LOG::name\", 0},\n  { &key_memory_TC_LOG_MMAP_pages, \"TC_LOG_MMAP::pages\", 0},\n  { &key_memory_my_bitmap_map, \"my_bitmap_map\", 0},\n  { &key_memory_QUICK_RANGE_SELECT_mrr_buf_desc, \"QUICK_RANGE_SELECT::mrr_buf_desc\", 0},\n  { &key_memory_Event_queue_element_for_exec_names, \"Event_queue_element_for_exec::names\", 0},\n  { &key_memory_my_str_malloc, \"my_str_malloc\", 0},\n  { &key_memory_MYSQL_BIN_LOG_basename, \"MYSQL_BIN_LOG::basename\", 0},\n  { &key_memory_MYSQL_BIN_LOG_index, \"MYSQL_BIN_LOG::index\", 0},\n  { &key_memory_MYSQL_RELAY_LOG_basename, \"MYSQL_RELAY_LOG::basename\", 0},\n  { &key_memory_MYSQL_RELAY_LOG_index, \"MYSQL_RELAY_LOG::index\", 0},\n  { &key_memory_rpl_filter, \"rpl_filter memory\", 0},\n  { &key_memory_errmsgs, \"errmsgs\", 0},\n  { &key_memory_Gis_read_stream_err_msg, \"Gis_read_stream::err_msg\", 0},\n  { &key_memory_Geometry_objects_data, \"Geometry::ptr_and_wkb_data\", 0},\n  { &key_memory_MYSQL_LOCK, \"MYSQL_LOCK\", 0},\n  { &key_memory_NET_buff, \"NET::buff\", 0},\n  { &key_memory_NET_compress_packet, \"NET::compress_packet\", 0},\n  { &key_memory_Event_scheduler_scheduler_param, \"Event_scheduler::scheduler_param\", 0},\n  { &key_memory_Gtid_set_Interval_chunk, \"Gtid_set::Interval_chunk\", 0},\n  { &key_memory_Owned_gtids_sidno_to_hash, \"Owned_gtids::sidno_to_hash\", 0},\n  { &key_memory_Sid_map_Node, \"Sid_map::Node\", 0},\n  { &key_memory_Gtid_state_group_commit_sidno, \"Gtid_state::group_commit_sidno_locks\", 0},\n  { &key_memory_Mutex_cond_array_Mutex_cond, \"Mutex_cond_array::Mutex_cond\", 0},\n  { &key_memory_TABLE_RULE_ENT, \"TABLE_RULE_ENT\", 0},\n\n  { &key_memory_Rpl_info_table, \"Rpl_info_table\", 0},\n  { &key_memory_Rpl_info_file_buffer, \"Rpl_info_file::buffer\", 0},\n  { &key_memory_db_worker_hash_entry, \"db_worker_hash_entry\", 0},\n  { &key_memory_rpl_slave_check_temp_dir, \"rpl_slave::check_temp_dir\", 0},\n  { &key_memory_rpl_slave_command_buffer, \"rpl_slave::command_buffer\", 0},\n  { &key_memory_binlog_ver_1_event, \"binlog_ver_1_event\", 0},\n  { &key_memory_SLAVE_INFO, \"SLAVE_INFO\", 0},\n  { &key_memory_binlog_pos, \"binlog_pos\", 0},\n  { &key_memory_HASH_ROW_ENTRY, \"HASH_ROW_ENTRY\", 0},\n  { &key_memory_binlog_statement_buffer, \"binlog_statement_buffer\", 0},\n  { &key_memory_partition_syntax_buffer, \"partition_syntax_buffer\", 0},\n  { &key_memory_READ_INFO, \"READ_INFO\", 0},\n  { &key_memory_JOIN_CACHE, \"JOIN_CACHE\", 0},\n  { &key_memory_TABLE_sort_io_cache, \"TABLE::sort_io_cache\", 0},\n  { &key_memory_frm, \"frm\", 0},\n  { &key_memory_Unique_sort_buffer, \"Unique::sort_buffer\", 0},\n  { &key_memory_Unique_merge_buffer, \"Unique::merge_buffer\", 0},\n  { &key_memory_TABLE, \"TABLE\", PSI_FLAG_GLOBAL}, /* Table cache */\n  { &key_memory_frm_extra_segment_buff, \"frm::extra_segment_buff\", 0},\n  { &key_memory_frm_form_pos, \"frm::form_pos\", 0},\n  { &key_memory_frm_string, \"frm::string\", 0},\n  { &key_memory_LOG_name, \"LOG_name\", 0},\n  { &key_memory_DATE_TIME_FORMAT, \"DATE_TIME_FORMAT\", 0},\n  { &key_memory_DDL_LOG_MEMORY_ENTRY, \"DDL_LOG_MEMORY_ENTRY\", 0},\n  { &key_memory_ST_SCHEMA_TABLE, \"ST_SCHEMA_TABLE\", 0},\n  { &key_memory_ignored_db, \"ignored_db\", 0},\n  { &key_memory_PROFILE, \"PROFILE\", 0},\n  { &key_memory_global_system_variables, \"global_system_variables\", 0},\n  { &key_memory_THD_variables, \"THD::variables\", 0},\n  { &key_memory_Security_context, \"Security_context\", 0},\n  { &key_memory_shared_memory_name, \"Shared_memory_name\", 0},\n  { &key_memory_bison_stack, \"bison_stack\", 0},\n  { &key_memory_THD_handler_tables_hash, \"THD::handler_tables_hash\", 0},\n  { &key_memory_hash_index_key_buffer, \"hash_index_key_buffer\", 0},\n  { &key_memory_dboptions_hash, \"dboptions_hash\", 0},\n  { &key_memory_user_conn, \"user_conn\", 0},\n  { &key_memory_LOG_POS_COORD, \"LOG_POS_COORD\", 0},\n  { &key_memory_XID_STATE, \"XID_STATE\", 0},\n  { &key_memory_MPVIO_EXT_auth_info, \"MPVIO_EXT::auth_info\", 0},\n  { &key_memory_opt_bin_logname, \"opt_bin_logname\", 0},\n  { &key_memory_Query_cache, \"Query_cache\", PSI_FLAG_GLOBAL},\n  { &key_memory_READ_RECORD_cache, \"READ_RECORD_cache\", 0},\n  { &key_memory_Quick_ranges, \"Quick_ranges\", 0},\n  { &key_memory_File_query_log_name, \"File_query_log::name\", 0},\n  { &key_memory_Table_trigger_dispatcher, \"Table_trigger_dispatcher::m_mem_root\", 0},\n  { &key_memory_thd_timer, \"thd_timer\", 0},\n  { &key_memory_THD_Session_tracker, \"THD::Session_tracker\", 0},\n  { &key_memory_THD_Session_sysvar_resource_manager, \"THD::Session_sysvar_resource_manager\", 0},\n  { &key_memory_show_slave_status_io_gtid_set, \"show_slave_status_io_gtid_set\", 0},\n  { &key_memory_write_set_extraction, \"write_set_extraction\", 0},\n  { &key_memory_get_all_tables, \"get_all_tables\", 0},\n  { &key_memory_fill_schema_schemata, \"fill_schema_schemata\", 0},\n  { &key_memory_native_functions, \"native_functions\", PSI_FLAG_GLOBAL},\n  { &key_memory_JSON, \"JSON\", 0 },\n};\n\n/* TODO: find a good header */\nextern \"C\" void init_client_psi_keys(void);\n\n/**\n  Initialise all the performance schema instrumentation points\n  used by the server.\n*/\nvoid init_server_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  count= array_elements(all_server_mutexes);\n  mysql_mutex_register(category, all_server_mutexes, count);\n\n  count= array_elements(all_server_rwlocks);\n  mysql_rwlock_register(category, all_server_rwlocks, count);\n\n  count= array_elements(all_server_conds);\n  mysql_cond_register(category, all_server_conds, count);\n\n  count= array_elements(all_server_threads);\n  mysql_thread_register(category, all_server_threads, count);\n\n  count= array_elements(all_server_files);\n  mysql_file_register(category, all_server_files, count);\n\n  count= array_elements(all_server_stages);\n  mysql_stage_register(category, all_server_stages, count);\n\n  count= array_elements(all_server_sockets);\n  mysql_socket_register(category, all_server_sockets, count);\n\n  count= array_elements(all_server_memory);\n  mysql_memory_register(category, all_server_memory, count);\n\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\n  init_sql_statement_info();\n  count= array_elements(sql_statement_info);\n  mysql_statement_register(category, sql_statement_info, count);\n\n  init_sp_psi_keys();\n\n  init_scheduler_psi_keys();\n\n  category= \"com\";\n  init_com_statement_info();\n\n  /*\n    Register [0 .. COM_QUERY - 1] as \"statement/com/...\"\n  */\n  count= (int) COM_QUERY;\n  mysql_statement_register(category, com_statement_info, count);\n\n  /*\n    Register [COM_QUERY + 1 .. COM_END] as \"statement/com/...\"\n  */\n  count= (int) COM_END - (int) COM_QUERY;\n  mysql_statement_register(category, & com_statement_info[(int) COM_QUERY + 1], count);\n\n  category= \"abstract\";\n  /*\n    Register [COM_QUERY] as \"statement/abstract/com_query\"\n  */\n  mysql_statement_register(category, & com_statement_info[(int) COM_QUERY], 1);\n\n  /*\n    When a new packet is received,\n    it is instrumented as \"statement/abstract/new_packet\".\n    Based on the packet type found, it later mutates to the\n    proper narrow type, for example\n    \"statement/abstract/query\" or \"statement/com/ping\".\n    In cases of \"statement/abstract/query\", SQL queries are given to\n    the parser, which mutates the statement type to an even more\n    narrow classification, for example \"statement/sql/select\".\n  */\n  stmt_info_new_packet.m_key= 0;\n  stmt_info_new_packet.m_name= \"new_packet\";\n  stmt_info_new_packet.m_flags= PSI_FLAG_MUTABLE;\n  mysql_statement_register(category, &stmt_info_new_packet, 1);\n\n  /*\n    Statements processed from the relay log are initially instrumented as\n    \"statement/abstract/relay_log\". The parser will mutate the statement type to\n    a more specific classification, for example \"statement/sql/insert\".\n  */\n  stmt_info_rpl.m_key= 0;\n  stmt_info_rpl.m_name= \"relay_log\";\n  stmt_info_rpl.m_flags= PSI_FLAG_MUTABLE;\n  mysql_statement_register(category, &stmt_info_rpl, 1);\n#endif\n\n  /* Common client and server code. */\n  init_client_psi_keys();\n  /* Vio */\n  init_vio_psi_keys();\n}\n\n#endif /* HAVE_PSI_INTERFACE */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/sql/sys_vars.cc": "/* Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n  Definitions of all server's session or global variables.\n\n  How to add new variables:\n\n  1. copy one of the existing variables, and edit the declaration.\n  2. if you need special behavior on assignment or additional checks\n     use ON_CHECK and ON_UPDATE callbacks.\n  3. *Don't* add new Sys_var classes or uncle Occam will come\n     with his razor to haunt you at nights\n\n  Note - all storage engine variables (for example myisam_whatever)\n  should go into the corresponding storage engine sources\n  (for example in storage/myisam/ha_myisam.cc) !\n*/\n\n#include \"sys_vars.h\"\n\n#include \"my_aes.h\"                      // my_aes_opmode_names\n#include \"myisam.h\"                      // myisam_flush\n#include \"auth_common.h\"                 // validate_user_plugins\n#include \"binlog.h\"                      // mysql_bin_log\n#include \"connection_handler_impl.h\"     // Per_thread_connection_handler\n#include \"connection_handler_manager.h\"  // Connection_handler_manager\n#include \"debug_sync.h\"                  // DEBUG_SYNC\n#include \"derror.h\"                      // read_texts\n#include \"events.h\"                      // Events\n#include \"hostname.h\"                    // host_cache_resize\n#include \"item_timefunc.h\"               // ISO_FORMAT\n#include \"log_event.h\"                   // MAX_MAX_ALLOWED_PACKET\n#include \"rpl_info_factory.h\"            // Rpl_info_factory\n#include \"rpl_info_handler.h\"            // INFO_REPOSITORY_FILE\n#include \"rpl_mi.h\"                      // Master_info\n#include \"rpl_msr.h\"                     // channel_map\n#include \"rpl_mts_submode.h\"             // MTS_PARALLEL_TYPE_DB_NAME\n#include \"rpl_rli.h\"                     // Relay_log_info\n#include \"rpl_slave.h\"                   // SLAVE_THD_TYPE\n#include \"socket_connection.h\"           // MY_BIND_ALL_ADDRESSES\n#include \"sp_head.h\"                     // SP_PSI_STATEMENT_INFO_COUNT\n#include \"sql_parse.h\"                   // killall_non_super_threads\n#include \"sql_show.h\"                    // opt_ignore_db_dirs\n#include \"sql_tmp_table.h\"               // internal_tmp_disk_storage_engine\n#include \"sql_time.h\"                    // global_date_format\n#include \"table_cache.h\"                 // Table_cache_manager\n#include \"transaction.h\"                 // trans_commit_stmt\n#include \"rpl_write_set_handler.h\"       // transaction_write_set_hashing_algorithms\n#include \"rpl_group_replication.h\"       // is_group_replication_running\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"../storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\nTYPELIB bool_typelib={ array_elements(bool_values)-1, \"\", bool_values, 0 };\n\nstatic bool update_buffer_size(THD *thd, KEY_CACHE *key_cache,\n                               ptrdiff_t offset, ulonglong new_value)\n{\n  bool error= false;\n  DBUG_ASSERT(offset == offsetof(KEY_CACHE, param_buff_size));\n\n  if (new_value == 0)\n  {\n    if (key_cache == dflt_key_cache)\n    {\n      my_error(ER_WARN_CANT_DROP_DEFAULT_KEYCACHE, MYF(0));\n      return true;\n    }\n\n    if (key_cache->key_cache_inited)            // If initied\n    {\n      /*\n        Move tables using this key cache to the default key cache\n        and clear the old key cache.\n      */\n      key_cache->in_init= 1;\n      mysql_mutex_unlock(&LOCK_global_system_variables);\n      key_cache->param_buff_size= 0;\n      ha_resize_key_cache(key_cache);\n      ha_change_key_cache(key_cache, dflt_key_cache);\n      /*\n        We don't delete the key cache as some running threads my still be in\n        the key cache code with a pointer to the deleted (empty) key cache\n      */\n      mysql_mutex_lock(&LOCK_global_system_variables);\n      key_cache->in_init= 0;\n    }\n    return error;\n  }\n\n  key_cache->param_buff_size= new_value;\n\n  /* If key cache didn't exist initialize it, else resize it */\n  key_cache->in_init= 1;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (!key_cache->key_cache_inited)\n    error= ha_init_key_cache(0, key_cache);\n  else\n    error= ha_resize_key_cache(key_cache);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  key_cache->in_init= 0;\n\n  return error;\n}\n\nstatic bool update_keycache_param(THD *thd, KEY_CACHE *key_cache,\n                                  ptrdiff_t offset, ulonglong new_value)\n{\n  bool error= false;\n  DBUG_ASSERT(offset != offsetof(KEY_CACHE, param_buff_size));\n\n  keycache_var(key_cache, offset)= new_value;\n\n  key_cache->in_init= 1;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  error= ha_resize_key_cache(key_cache);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  key_cache->in_init= 0;\n\n  return error;\n}\n\n/*\n  The rule for this file: everything should be 'static'. When a sys_var\n  variable or a function from this file is - in very rare cases - needed\n  elsewhere it should be explicitly declared 'export' here to show that it's\n  not a mistakenly forgotten 'static' keyword.\n*/\n#define export /* not static */\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#ifndef EMBEDDED_LIBRARY\n\n#define PFS_TRAILING_PROPERTIES \\\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL), \\\n  NULL, sys_var::PARSE_EARLY\n\nstatic Sys_var_mybool Sys_pfs_enabled(\n       \"performance_schema\",\n       \"Enable the performance schema.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_charptr Sys_pfs_instrument(\n       \"performance_schema_instrument\",\n       \"Default startup value for a performance schema instrument.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_pfs_instrument),\n       CMD_LINE(OPT_ARG, OPT_PFS_INSTRUMENT),\n       IN_FS_CHARSET,\n       DEFAULT(\"\"),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_stages_current(\n       \"performance_schema_consumer_events_stages_current\",\n       \"Default startup value for the events_stages_current consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_stages_current_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_stages_history(\n       \"performance_schema_consumer_events_stages_history\",\n       \"Default startup value for the events_stages_history consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_stages_history_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_stages_history_long(\n       \"performance_schema_consumer_events_stages_history_long\",\n       \"Default startup value for the events_stages_history_long consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_stages_history_long_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_statements_current(\n       \"performance_schema_consumer_events_statements_current\",\n       \"Default startup value for the events_statements_current consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_statements_current_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_statements_history(\n       \"performance_schema_consumer_events_statements_history\",\n       \"Default startup value for the events_statements_history consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_statements_history_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_statements_history_long(\n       \"performance_schema_consumer_events_statements_history_long\",\n       \"Default startup value for the events_statements_history_long consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_statements_history_long_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_transactions_current(\n       \"performance_schema_consumer_events_transactions_current\",\n       \"Default startup value for the events_transactions_current consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_transactions_current_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_transactions_history(\n       \"performance_schema_consumer_events_transactions_history\",\n       \"Default startup value for the events_transactions_history consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_transactions_history_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_transactions_history_long(\n       \"performance_schema_consumer_events_transactions_history_long\",\n       \"Default startup value for the events_transactions_history_long consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_transactions_history_long_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_waits_current(\n       \"performance_schema_consumer_events_waits_current\",\n       \"Default startup value for the events_waits_current consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_waits_current_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_waits_history(\n       \"performance_schema_consumer_events_waits_history\",\n       \"Default startup value for the events_waits_history consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_waits_history_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_events_waits_history_long(\n       \"performance_schema_consumer_events_waits_history_long\",\n       \"Default startup value for the events_waits_history_long consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_events_waits_history_long_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_global_instrumentation(\n       \"performance_schema_consumer_global_instrumentation\",\n       \"Default startup value for the global_instrumentation consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_global_instrumentation_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_thread_instrumentation(\n       \"performance_schema_consumer_thread_instrumentation\",\n       \"Default startup value for the thread_instrumentation consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_thread_instrumentation_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_mybool Sys_pfs_consumer_statement_digest(\n       \"performance_schema_consumer_statements_digest\",\n       \"Default startup value for the statements_digest consumer.\",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_consumer_statement_digest_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_waits_history_long_size(\n       \"performance_schema_events_waits_history_long_size\",\n       \"Number of rows in EVENTS_WAITS_HISTORY_LONG.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_waits_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_waits_history_size(\n       \"performance_schema_events_waits_history_size\",\n       \"Number of rows per thread in EVENTS_WAITS_HISTORY.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_waits_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_cond_classes(\n       \"performance_schema_max_cond_classes\",\n       \"Maximum number of condition instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_cond_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_COND_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_cond_instances(\n       \"performance_schema_max_cond_instances\",\n       \"Maximum number of instrumented condition objects.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_cond_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_program_instances(\n       \"performance_schema_max_program_instances\",\n       \"Maximum number of instrumented programs.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_program_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_prepared_stmt_instances(\n       \"performance_schema_max_prepared_statements_instances\",\n       \"Maximum number of instrumented prepared statements.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_prepared_stmt_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_file_classes(\n       \"performance_schema_max_file_classes\",\n       \"Maximum number of file instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_file_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_FILE_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_file_handles(\n       \"performance_schema_max_file_handles\",\n       \"Maximum number of opened instrumented files.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_file_handle_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_FILE_HANDLE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_file_instances(\n       \"performance_schema_max_file_instances\",\n       \"Maximum number of instrumented files.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_file_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_sockets(\n       \"performance_schema_max_socket_instances\",\n       \"Maximum number of opened instrumented sockets.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_socket_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_socket_classes(\n       \"performance_schema_max_socket_classes\",\n       \"Maximum number of socket instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_socket_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_SOCKET_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_mutex_classes(\n       \"performance_schema_max_mutex_classes\",\n       \"Maximum number of mutex instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_MUTEX_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_mutex_instances(\n       \"performance_schema_max_mutex_instances\",\n       \"Maximum number of instrumented MUTEX objects.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 100*1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_rwlock_classes(\n       \"performance_schema_max_rwlock_classes\",\n       \"Maximum number of rwlock instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_RWLOCK_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_rwlock_instances(\n       \"performance_schema_max_rwlock_instances\",\n       \"Maximum number of instrumented RWLOCK objects.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 100*1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_table_handles(\n       \"performance_schema_max_table_handles\",\n       \"Maximum number of opened instrumented tables.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_table_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_table_instances(\n       \"performance_schema_max_table_instances\",\n       \"Maximum number of instrumented tables.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_table_share_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_table_lock_stat(\n       \"performance_schema_max_table_lock_stat\",\n       \"Maximum number of lock statistics for instrumented tables.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_table_lock_stat_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_index_stat(\n       \"performance_schema_max_index_stat\",\n       \"Maximum number of index statistics for instrumented tables.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_index_stat_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_thread_classes(\n       \"performance_schema_max_thread_classes\",\n       \"Maximum number of thread instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_thread_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_THREAD_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_thread_instances(\n       \"performance_schema_max_thread_instances\",\n       \"Maximum number of instrumented threads.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_thread_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_setup_actors_size(\n       \"performance_schema_setup_actors_size\",\n       \"Maximum number of rows in SETUP_ACTORS.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_setup_actor_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_setup_objects_size(\n       \"performance_schema_setup_objects_size\",\n       \"Maximum number of rows in SETUP_OBJECTS.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_setup_object_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_accounts_size(\n       \"performance_schema_accounts_size\",\n       \"Maximum number of instrumented user@host accounts.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_account_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_hosts_size(\n       \"performance_schema_hosts_size\",\n       \"Maximum number of instrumented hosts.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_host_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_users_size(\n       \"performance_schema_users_size\",\n       \"Maximum number of instrumented users.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_user_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_stage_classes(\n       \"performance_schema_max_stage_classes\",\n       \"Maximum number of stage instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_stage_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_STAGE_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_stages_history_long_size(\n       \"performance_schema_events_stages_history_long_size\",\n       \"Number of rows in EVENTS_STAGES_HISTORY_LONG.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_stages_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_stages_history_size(\n       \"performance_schema_events_stages_history_size\",\n       \"Number of rows per thread in EVENTS_STAGES_HISTORY.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_stages_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\n/**\n  Variable performance_schema_max_statement_classes.\n  The default number of statement classes is the sum of:\n  - COM_END for all regular \"statement/com/...\",\n  - 1 for \"statement/com/new_packet\", for unknown enum_server_command\n  - 1 for \"statement/com/Error\", for invalid enum_server_command\n  - SQLCOM_END for all regular \"statement/sql/...\",\n  - 1 for \"statement/sql/error\", for invalid enum_sql_command.\n  - SP_PSI_STATEMENT_INFO_COUNT for \"statement/sp/...\". \n  - 1 for \"statement/rpl/relay_log\", for replicated statements.\n  - 1 for \"statement/scheduler/event\", for scheduled events.\n*/\nstatic Sys_var_ulong Sys_pfs_max_statement_classes(\n       \"performance_schema_max_statement_classes\",\n       \"Maximum number of statement instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_statement_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT((ulong) SQLCOM_END + (ulong) COM_END + 5 + SP_PSI_STATEMENT_INFO_COUNT),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_statements_history_long_size(\n       \"performance_schema_events_statements_history_long_size\",\n       \"Number of rows in EVENTS_STATEMENTS_HISTORY_LONG.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_statements_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_statements_history_size(\n       \"performance_schema_events_statements_history_size\",\n       \"Number of rows per thread in EVENTS_STATEMENTS_HISTORY.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_statements_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_statement_stack_size(\n       \"performance_schema_max_statement_stack\",\n       \"Number of rows per thread in EVENTS_STATEMENTS_CURRENT.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_statement_stack_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(1, 256),\n       DEFAULT(PFS_STATEMENTS_STACK_SIZE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_memory_classes(\n       \"performance_schema_max_memory_classes\",\n       \"Maximum number of memory pool instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_memory_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024),\n       DEFAULT(PFS_MAX_MEMORY_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_digest_size(\n       \"performance_schema_digests_size\",\n       \"Size of the statement digest.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_digest_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_transactions_history_long_size(\n       \"performance_schema_events_transactions_history_long_size\",\n       \"Number of rows in EVENTS_TRANSACTIONS_HISTORY_LONG.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_transactions_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_transactions_history_size(\n       \"performance_schema_events_transactions_history_size\",\n       \"Number of rows per thread in EVENTS_TRANSACTIONS_HISTORY.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_transactions_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_digest_length(\n       \"performance_schema_max_digest_length\",\n       \"Maximum length considered for digest text, when stored in performance_schema tables.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_max_digest_length),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024 * 1024),\n       DEFAULT(1024),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_connect_attrs_size(\n       \"performance_schema_session_connect_attrs_size\",\n       \"Size of session attribute string buffer per thread.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_session_connect_attrs_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n       DEFAULT(PFS_AUTOSIZE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_metadata_locks(\n       \"performance_schema_max_metadata_locks\",\n       \"Maximum number of metadata locks.\"\n         \" Use 0 to disable, -1 for automated scaling.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_metadata_lock_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 100*1024*1024),\n       DEFAULT(PFS_AUTOSCALE_VALUE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_sql_text_length(\n       \"performance_schema_max_sql_text_length\",\n       \"Maximum length of displayed sql text.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_max_sql_text_length),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024 * 1024),\n       DEFAULT(1024),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\n#endif /* EMBEDDED_LIBRARY */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\nstatic Sys_var_ulong Sys_auto_increment_increment(\n       \"auto_increment_increment\",\n       \"Auto-increment columns are incremented by this\",\n       SESSION_VAR(auto_increment_increment),\n       CMD_LINE(OPT_ARG),\n       VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_ulong Sys_auto_increment_offset(\n       \"auto_increment_offset\",\n       \"Offset added to Auto-increment columns. Used when \"\n       \"auto-increment-increment != 1\",\n       SESSION_VAR(auto_increment_offset),\n       CMD_LINE(OPT_ARG),\n       VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_mybool Sys_automatic_sp_privileges(\n       \"automatic_sp_privileges\",\n       \"Creating and dropping stored procedures alters ACLs\",\n       GLOBAL_VAR(sp_automatic_privileges),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_back_log(\n       \"back_log\", \"The number of outstanding connection requests \"\n       \"MySQL can have. This comes into play when the main MySQL thread \"\n       \"gets very many connection requests in a very short time\",\n       READ_ONLY GLOBAL_VAR(back_log), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 65535), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_basedir(\n       \"basedir\", \"Path to installation directory. All paths are \"\n       \"usually resolved relative to this\",\n       READ_ONLY GLOBAL_VAR(mysql_home_ptr), CMD_LINE(REQUIRED_ARG, 'b'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_default_authentication_plugin(\n       \"default_authentication_plugin\", \"The default authentication plugin \"\n       \"used by the server to hash the password.\",\n       READ_ONLY GLOBAL_VAR(default_auth_plugin), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(\"mysql_native_password\"));\n\nstatic PolyLock_mutex Plock_default_password_lifetime(\n                        &LOCK_default_password_lifetime);\nstatic Sys_var_uint Sys_default_password_lifetime(\n       \"default_password_lifetime\", \"The number of days after which the \"\n       \"password will expire.\",\n       GLOBAL_VAR(default_password_lifetime), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX16), DEFAULT(0), BLOCK_SIZE(1),\n       &Plock_default_password_lifetime);\n\n#ifndef EMBEDDED_LIBRARY\nstatic Sys_var_charptr Sys_my_bind_addr(\n       \"bind_address\", \"IP address to bind to.\",\n       READ_ONLY GLOBAL_VAR(my_bind_addr_str), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(MY_BIND_ALL_ADDRESSES));\n#endif\n\nstatic bool fix_binlog_cache_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  check_binlog_cache_size(thd);\n  return false;\n}\n\nstatic bool fix_binlog_stmt_cache_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  check_binlog_stmt_cache_size(thd);\n  return false;\n}\n\nstatic Sys_var_ulong Sys_binlog_cache_size(\n       \"binlog_cache_size\", \"The size of the transactional cache for \"\n       \"updates to transactional engines for the binary log. \"\n       \"If you often use transactions containing many statements, \"\n       \"you can increase this to get more performance\",\n       GLOBAL_VAR(binlog_cache_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, ULONG_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_binlog_cache_size));\n\nstatic Sys_var_ulong Sys_binlog_stmt_cache_size(\n       \"binlog_stmt_cache_size\", \"The size of the statement cache for \"\n       \"updates to non-transactional engines for the binary log. \"\n       \"If you often use statements updating a great number of rows, \"\n       \"you can increase this to get more performance\",\n       GLOBAL_VAR(binlog_stmt_cache_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, ULONG_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_binlog_stmt_cache_size));\n\nstatic Sys_var_int32 Sys_binlog_max_flush_queue_time(\n       \"binlog_max_flush_queue_time\",\n       \"The maximum time that the binary log group commit will keep reading\"\n       \" transactions before it flush the transactions to the binary log (and\"\n       \" optionally sync, depending on the value of sync_binlog).\",\n       GLOBAL_VAR(opt_binlog_max_flush_queue_time),\n       CMD_LINE(REQUIRED_ARG, OPT_BINLOG_MAX_FLUSH_QUEUE_TIME),\n       VALID_RANGE(0, 100000), DEFAULT(0), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_binlog_group_commit_sync_delay(\n       \"binlog_group_commit_sync_delay\",\n       \"The number of microseconds the server waits for the \"\n       \"binary log group commit sync queue to fill before \"\n       \"continuing. Default: 0. Min: 0. Max: 1000000.\",\n       GLOBAL_VAR(opt_binlog_group_commit_sync_delay),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1000000 /* max 1 sec */), DEFAULT(0), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic Sys_var_ulong Sys_binlog_group_commit_sync_no_delay_count(\n       \"binlog_group_commit_sync_no_delay_count\",\n       \"If there are this many transactions in the commit sync \"\n       \"queue and the server is waiting for more transactions \"\n       \"to be enqueued (as set using --binlog-group-commit-sync-delay), \"\n       \"the commit procedure resumes.\",\n       GLOBAL_VAR(opt_binlog_group_commit_sync_no_delay_count),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 100000 /* max connections */),\n       DEFAULT(0), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic bool check_has_super(sys_var *self, THD *thd, set_var *var)\n{\n  DBUG_ASSERT(self->scope() != sys_var::GLOBAL);// don't abuse check_has_super()\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (!(thd->security_context()->check_access(SUPER_ACL)))\n  {\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), \"SUPER\");\n    return true;\n  }\n#endif\n  return false;\n}\n\nstatic bool check_outside_trx(sys_var *self, THD *thd, set_var *var)\n{\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0), var->var->name.str);\n    return true;\n  }\n  if (!thd->owned_gtid.is_empty())\n  {\n    char buf[Gtid::MAX_TEXT_LENGTH + 1];\n    if (thd->owned_gtid.sidno > 0)\n      thd->owned_gtid.to_string(thd->owned_sid, buf);\n    else\n      strcpy(buf, \"ANONYMOUS\");\n    my_error(ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID, MYF(0), var->var->name.str, buf);\n    return true;\n  }\n  return false;\n}\n\nstatic bool check_super_outside_trx_outside_sf(sys_var *self, THD *thd, set_var *var)\n{\n  if (thd->in_sub_stmt)\n  {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER, MYF(0), var->var->name.str);\n    return true;\n  }\n  if (check_outside_trx(self, thd, var))\n    return true;\n  if (self->scope() != sys_var::GLOBAL)\n    return check_has_super(self, thd, var);\n  return false;\n}\n\nstatic bool check_explicit_defaults_for_timestamp(sys_var *self, THD *thd, set_var *var)\n{\n  if (thd->in_sub_stmt)\n  {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER, MYF(0), var->var->name.str);\n    return true;\n  }\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0), var->var->name.str);\n    return true;\n  }\n  if (self->scope() != sys_var::GLOBAL)\n    return check_has_super(self, thd, var);\n  return false;\n}\n\n#ifdef HAVE_REPLICATION\n/**\n  Check-function to @@GTID_NEXT system variable.\n\n  @param self   a pointer to the sys_var, i.e. gtid_next\n  @param thd    a reference to THD object\n  @param var    a pointer to the set_var created by the parser.\n\n  @return @c false if the change is allowed, otherwise @c true.\n*/\n\nstatic bool check_gtid_next(sys_var *self, THD *thd, set_var *var)\n{\n  bool is_prepared_trx=\n    thd->get_transaction()->xid_state()->has_state(XID_STATE::XA_PREPARED);\n\n  if (thd->in_sub_stmt)\n  {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER, MYF(0), var->var->name.str);\n    return true;\n  }\n  if (!is_prepared_trx && thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0), var->var->name.str);\n    return true;\n  }\n  return check_has_super(self, thd, var);\n}\n#endif\n\nstatic bool check_super_outside_trx_outside_sf_outside_sp(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_super_outside_trx_outside_sf(self, thd, var))\n    return true;\n  if (thd->lex->sphead)\n  {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_SP, MYF(0), var->var->name.str);\n    return true;\n  }\n  return false;\n}\n\nstatic bool binlog_format_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n\n  if (var->type == OPT_GLOBAL)\n    return false;\n\n  /*\n     If RBR and open temporary tables, their CREATE TABLE may not be in the\n     binlog, so we can't toggle to SBR in this connection.\n\n     If binlog_format=MIXED, there are open temporary tables, and an unsafe\n     statement is executed, then subsequent statements are logged in row\n     format and hence changes to temporary tables may be lost. So we forbid\n     switching @@SESSION.binlog_format from MIXED to STATEMENT when there are\n     open temp tables and we are logging in row format.\n  */\n  if (thd->temporary_tables && var->type == OPT_SESSION &&\n      var->save_result.ulonglong_value == BINLOG_FORMAT_STMT &&\n      ((thd->variables.binlog_format == BINLOG_FORMAT_MIXED &&\n        thd->is_current_stmt_binlog_format_row()) ||\n       thd->variables.binlog_format == BINLOG_FORMAT_ROW))\n  {\n    my_error(ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR, MYF(0));\n    return true;\n  }\n\n  /*\n    if in a stored function/trigger, it's too late to change mode\n  */\n  if (thd->in_sub_stmt)\n  {\n    my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT, MYF(0));\n    return true;\n  }\n  /*\n    Make the session variable 'binlog_format' read-only inside a transaction.\n  */\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT, MYF(0));\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool fix_binlog_format_after_update(sys_var *self, THD *thd,\n                                           enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->reset_current_stmt_binlog_format_row();\n  return false;\n}\n\nstatic bool prevent_global_rbr_exec_mode_idempotent(sys_var *self, THD *thd,\n                                                    set_var *var )\n{\n  if (var->type == OPT_GLOBAL)\n  {\n    my_error(ER_LOCAL_VARIABLE, MYF(0), self->name.str);\n    return true;\n  }\n  return false;\n}\n\nstatic Sys_var_test_flag Sys_core_file(\n       \"core_file\", \"write a core-file on crashes\", TEST_CORE_ON_SIGNAL);\n\nstatic Sys_var_enum Sys_binlog_format(\n       \"binlog_format\", \"What form of binary logging the master will \"\n       \"use: either ROW for row-based binary logging, STATEMENT \"\n       \"for statement-based binary logging, or MIXED. MIXED is statement-\"\n       \"based binary logging except for those statements where only row-\"\n       \"based is correct: those which involve user-defined functions (i.e. \"\n       \"UDFs) or the UUID() function; for those, row-based binary logging is \"\n       \"automatically used. If NDBCLUSTER is enabled and binlog-format is \"\n       \"MIXED, the format switches to row-based and back implicitly per each \"\n       \"query accessing an NDBCLUSTER table\",\n       SESSION_VAR(binlog_format), CMD_LINE(REQUIRED_ARG, OPT_BINLOG_FORMAT),\n       binlog_format_names, DEFAULT(BINLOG_FORMAT_ROW),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(binlog_format_check),\n       ON_UPDATE(fix_binlog_format_after_update));\n\nstatic const char *rbr_exec_mode_names[]=\n       {\"STRICT\", \"IDEMPOTENT\", 0};\nstatic Sys_var_enum rbr_exec_mode(\n       \"rbr_exec_mode\",\n       \"Modes for how row events should be executed. Legal values \"\n       \"are STRICT (default) and IDEMPOTENT. In IDEMPOTENT mode, \"\n       \"the server will not throw errors for operations that are idempotent. \"\n       \"In STRICT mode, server will throw errors for the operations that \"\n       \"cause a conflict.\",\n       SESSION_VAR(rbr_exec_mode_options), NO_CMD_LINE,\n       rbr_exec_mode_names, DEFAULT(RBR_EXEC_MODE_STRICT),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(prevent_global_rbr_exec_mode_idempotent),\n       ON_UPDATE(NULL));\n\nstatic const char *binlog_row_image_names[]= {\"MINIMAL\", \"NOBLOB\", \"FULL\", NullS};\nstatic Sys_var_enum Sys_binlog_row_image(\n       \"binlog_row_image\", \n       \"Controls whether rows should be logged in 'FULL', 'NOBLOB' or \"\n       \"'MINIMAL' formats. 'FULL', means that all columns in the before \"\n       \"and after image are logged. 'NOBLOB', means that mysqld avoids logging \"\n       \"blob columns whenever possible (eg, blob column was not changed or \"\n       \"is not part of primary key). 'MINIMAL', means that a PK equivalent (PK \"\n       \"columns or full row if there is no PK in the table) is logged in the \"\n       \"before image, and only changed columns are logged in the after image. \"\n       \"(Default: FULL).\",\n       SESSION_VAR(binlog_row_image), CMD_LINE(REQUIRED_ARG),\n       binlog_row_image_names, DEFAULT(BINLOG_ROW_IMAGE_FULL),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(NULL));\n\nstatic bool on_session_track_gtids_update(sys_var *self, THD *thd,\n                                          enum_var_type type)\n{\n  thd->session_tracker.get_tracker(SESSION_GTIDS_TRACKER)->update(thd);\n  return false;\n}\n\nstatic const char *session_track_gtids_names[]=\n  { \"OFF\", \"OWN_GTID\", \"ALL_GTIDS\", NullS };\nstatic Sys_var_enum Sys_session_track_gtids(\n       \"session_track_gtids\",\n       \"Controls the amount of global transaction ids to be \"\n       \"included in the response packet sent by the server.\"\n       \"(Default: OFF).\",\n       SESSION_VAR(session_track_gtids), CMD_LINE(REQUIRED_ARG),\n       session_track_gtids_names, DEFAULT(OFF),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_outside_trx),\n       ON_UPDATE(on_session_track_gtids_update));\n\nstatic bool binlog_direct_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n\n  if (var->type == OPT_GLOBAL)\n    return false;\n\n   /*\n     Makes the session variable 'binlog_direct_non_transactional_updates'\n     read-only if within a procedure, trigger or function.\n   */\n   if (thd->in_sub_stmt)\n   {\n     my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT, MYF(0));\n     return true;\n   }\n   /*\n     Makes the session variable 'binlog_direct_non_transactional_updates'\n     read-only inside a transaction.\n   */\n   if (thd->in_active_multi_stmt_transaction())\n   {\n     my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT, MYF(0));\n     return true;\n   }\n\n  return false;\n}\n\nstatic Sys_var_mybool Sys_binlog_direct(\n       \"binlog_direct_non_transactional_updates\",\n       \"Causes updates to non-transactional engines using statement format to \"\n       \"be written directly to binary log. Before using this option make sure \"\n       \"that there are no dependencies between transactional and \"\n       \"non-transactional tables such as in the statement INSERT INTO t_myisam \"\n       \"SELECT * FROM t_innodb; otherwise, slaves may diverge from the master.\",\n       SESSION_VAR(binlog_direct_non_trans_update),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(binlog_direct_check));\n\n/**\n  This variable is read only to users. It can be enabled or disabled\n  only at mysqld startup. This variable is used by User thread and\n  as well as by replication slave applier thread to apply relay_log.\n  Slave applier thread enables/disables this option based on\n  relay_log's from replication master versions. There is possibility of\n  slave applier thread and User thread to have different setting for\n  explicit_defaults_for_timestamp, hence this options is defined as\n  SESSION_VAR rather than GLOBAL_VAR.\n*/\nstatic Sys_var_mybool Sys_explicit_defaults_for_timestamp(\n       \"explicit_defaults_for_timestamp\",\n       \"This option causes CREATE TABLE to create all TIMESTAMP columns \"\n       \"as NULL with DEFAULT NULL attribute, Without this option, \"\n       \"TIMESTAMP columns are NOT NULL and have implicit DEFAULT clauses. \"\n       \"The old behavior is deprecated. \"\n       \"The variable can only be set by users having the SUPER privilege.\",\n       SESSION_VAR(explicit_defaults_for_timestamp),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_explicit_defaults_for_timestamp));\n\nstatic bool repository_check(sys_var *self, THD *thd, set_var *var, SLAVE_THD_TYPE thread_mask)\n{\n  bool ret= FALSE;\n  if (check_super_outside_trx_outside_sf(self, thd, var))\n    return TRUE;\n#ifdef HAVE_REPLICATION\n  Master_info *mi;\n  int running= 0;\n  const char *msg= NULL;\n  bool rpl_info_option= static_cast<uint>(var->save_result.ulonglong_value);\n\n  /* don't convert if the repositories are same */\n  if (rpl_info_option == (thread_mask== SLAVE_THD_IO ?\n                          opt_mi_repository_id: opt_rli_repository_id))\n      return FALSE;\n\n  channel_map.wrlock();\n\n  /* Repository conversion not possible, when multiple channels exist */\n  if (channel_map.get_num_instances(true) > 1)\n  {\n      msg= \"Repository conversion is possible when only default channel exists\";\n      my_error(ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE, MYF(0), msg);\n      channel_map.unlock();\n      return TRUE;\n  }\n\n  mi= channel_map.get_default_channel_mi();\n\n  if (mi != NULL)\n  {\n    lock_slave_threads(mi);\n    init_thread_mask(&running, mi, FALSE);\n    if(!running)\n    {\n      switch (thread_mask)\n      {\n        case SLAVE_THD_IO:\n        if (Rpl_info_factory::\n            change_mi_repository(mi,\n                                 static_cast<uint>(var->save_result.\n                                                   ulonglong_value),\n                                 &msg))\n        {\n          ret= TRUE;\n          my_error(ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE, MYF(0), msg);\n        }\n        break;\n        case SLAVE_THD_SQL:\n          mts_recovery_groups(mi->rli);\n          if (!mi->rli->is_mts_recovery())\n          {\n            if (Rpl_info_factory::reset_workers(mi->rli) ||\n                Rpl_info_factory::\n                change_rli_repository(mi->rli,\n                                      static_cast<uint>(var->save_result.\n                                                        ulonglong_value),\n                                      &msg))\n            {\n              ret= TRUE;\n              my_error(ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE, MYF(0), msg);\n            }\n          }\n          else\n            sql_print_warning(\"It is not possible to change the type of the \"\n                              \"relay log's repository because there are workers' \"\n                              \"repositories with gaps. Please, fix the gaps first \"\n                              \"before doing such change.\");\n        break;\n        default:\n          assert(0);\n        break;\n      }\n    }\n    else\n    {\n      ret= TRUE;\n      my_error(ER_SLAVE_CHANNEL_MUST_STOP, MYF(0),mi->get_channel());\n    }\n    unlock_slave_threads(mi);\n  }\n  channel_map.unlock();\n#endif\n  return ret;\n}\n\nstatic bool relay_log_info_repository_check(sys_var *self, THD *thd, set_var *var)\n{\n  return repository_check(self, thd, var, SLAVE_THD_SQL);\n}\n\nstatic bool master_info_repository_check(sys_var *self, THD *thd, set_var *var)\n{\n  return repository_check(self, thd, var, SLAVE_THD_IO);\n}\n\nstatic const char *repository_names[]=\n{\n  \"FILE\", \"TABLE\",\n#ifndef DBUG_OFF\n  \"DUMMY\",\n#endif\n  0\n};\n\nulong opt_mi_repository_id= INFO_REPOSITORY_FILE;\nstatic Sys_var_enum Sys_mi_repository(\n       \"master_info_repository\",\n       \"Defines the type of the repository for the master information.\"\n       ,GLOBAL_VAR(opt_mi_repository_id), CMD_LINE(REQUIRED_ARG),\n       repository_names, DEFAULT(INFO_REPOSITORY_FILE), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(master_info_repository_check),\n       ON_UPDATE(0));\n\nulong opt_rli_repository_id= INFO_REPOSITORY_FILE;\nstatic Sys_var_enum Sys_rli_repository(\n       \"relay_log_info_repository\",\n       \"Defines the type of the repository for the relay log information \"\n       \"and associated workers.\"\n       ,GLOBAL_VAR(opt_rli_repository_id), CMD_LINE(REQUIRED_ARG),\n       repository_names, DEFAULT(INFO_REPOSITORY_FILE), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(relay_log_info_repository_check),\n       ON_UPDATE(0));\n\nstatic Sys_var_mybool Sys_binlog_rows_query(\n       \"binlog_rows_query_log_events\",\n       \"Allow writing of Rows_query_log events into binary log.\",\n       SESSION_VAR(binlog_rows_query_log_events),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_binlog_order_commits(\n       \"binlog_order_commits\",\n       \"Issue internal commit calls in the same order as transactions are\"\n       \" written to the binary log. Default is to order commits.\",\n       GLOBAL_VAR(opt_binlog_order_commits),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_bulk_insert_buff_size(\n       \"bulk_insert_buffer_size\", \"Size of tree cache used in bulk \"\n       \"insert optimisation. Note that this is a limit per thread!\",\n       SESSION_VAR(bulk_insert_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(8192*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_character_sets_dir(\n       \"character_sets_dir\", \"Directory where character sets are\",\n       READ_ONLY GLOBAL_VAR(charsets_dir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool check_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  return var->value && var->value->is_null();\n}\n\n\n/**\n  Check storage engine is not empty and log warning.\n\n  Checks if default_storage_engine or default_tmp_storage_engine is set\n  empty and return true. This method also logs warning if the\n  storage engine set is a disabled storage engine specified in\n  disabled_storage_engines.\n\n  @param self    pointer to system variable object.\n  @param thd     Connection handle.\n  @param var     pointer to set variable object.\n\n  @return  true if the set variable is empty.\n           false if the set variable is not empty.\n*/\nstatic bool check_storage_engine(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_not_null(self,thd,var))\n    return true;\n\n  if (!opt_bootstrap && !opt_noacl)\n  {\n    char buff[STRING_BUFFER_USUAL_SIZE];\n    String str(buff,sizeof(buff), system_charset_info), *res;\n    LEX_STRING se_name;\n\n    if (var->value)\n    {\n      res= var->value->val_str(&str);\n      lex_string_set(&se_name, res->ptr());\n    }\n    else\n    {\n      // Use the default value defined by sys_var.\n      lex_string_set(&se_name,\n        reinterpret_cast<const char*>(\n        dynamic_cast<Sys_var_plugin*>(self)->global_value_ptr(thd, NULL)));\n    }\n\n    plugin_ref plugin;\n    if ((plugin= ha_resolve_by_name(NULL, &se_name, FALSE)))\n    {\n      handlerton *hton= plugin_data<handlerton*>(plugin);\n      if (ha_is_storage_engine_disabled(hton))\n        sql_print_warning(\"%s is set to a disabled storage engine %s.\",\n                          self->name.str, se_name.str);\n      plugin_unlock(NULL, plugin);\n    }\n  }\n  return false;\n}\n\nstatic bool check_charset(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT)\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res= var->value->val_str(&str)))\n      var->save_result.ptr= NULL;\n    else\n    {\n      ErrConvString err(res); /* Get utf8 '\\0' terminated string */\n      if (!(var->save_result.ptr= get_charset_by_csname(err.ptr(),\n                                                         MY_CS_PRIMARY,\n                                                         MYF(0))) &&\n          !(var->save_result.ptr= get_old_charset_by_name(err.ptr())))\n      {\n        my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), err.ptr());\n        return true;\n      }\n    }\n  }\n  else // INT_RESULT\n  {\n    int csno= (int)var->value->val_int();\n    if (!(var->save_result.ptr= get_charset(csno, MYF(0))))\n    {\n      my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), llstr(csno, buff));\n      return true;\n    }\n  }\n  return false;\n}\nstatic bool check_charset_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  return check_charset(self, thd, var) || check_not_null(self, thd, var);\n}\nstatic Sys_var_struct Sys_character_set_system(\n       \"character_set_system\", \"The character set used by the server \"\n       \"for storing identifiers\",\n       READ_ONLY GLOBAL_VAR(system_charset_info), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(0));\n\nstatic Sys_var_struct Sys_character_set_server(\n       \"character_set_server\", \"The default character set\",\n       SESSION_VAR(collation_server), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_not_null));\n\nstatic bool check_charset_db(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_charset_not_null(self, thd, var))\n    return true;\n  if (!var->value) // = DEFAULT\n    var->save_result.ptr= thd->db_charset;\n  return false;\n}\nstatic bool update_deprecated(sys_var *self, THD *thd, enum_var_type type)\n{\n  push_warning_printf(thd, Sql_condition::SL_WARNING,\n                      ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,\n                      ER_THD(thd, ER_WARN_DEPRECATED_SYSVAR_UPDATE),\n                      self->name.str);\n  return false;\n}\nstatic Sys_var_struct Sys_character_set_database(\n       \"character_set_database\",\n       \" The character set used by the default database\",\n       SESSION_VAR(collation_database), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_db),\n       ON_UPDATE(update_deprecated));\n\nstatic bool check_cs_client(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_charset_not_null(self, thd, var))\n    return true;\n\n  // Currently, UCS-2 cannot be used as a client character set\n  if (((CHARSET_INFO *)(var->save_result.ptr))->mbminlen > 1)\n    return true;\n\n  return false;\n}\nstatic bool fix_thd_charset(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->update_charset();\n  return false;\n}\nstatic Sys_var_struct Sys_character_set_client(\n       \"character_set_client\", \"The character set for statements \"\n       \"that arrive from the client\",\n       SESSION_VAR(character_set_client), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_cs_client),\n       ON_UPDATE(fix_thd_charset));\n\nstatic Sys_var_struct Sys_character_set_connection(\n       \"character_set_connection\", \"The character set used for \"\n       \"literals that do not have a character set introducer and for \"\n       \"number-to-string conversion\",\n       SESSION_VAR(collation_connection), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic Sys_var_struct Sys_character_set_results(\n       \"character_set_results\", \"The character set used for returning \"\n       \"query results to the client\",\n       SESSION_VAR(character_set_results), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_charset));\n\nstatic Sys_var_struct Sys_character_set_filesystem(\n       \"character_set_filesystem\", \"The filesystem character set\",\n       SESSION_VAR(character_set_filesystem), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&character_set_filesystem),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_charset_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic const char *completion_type_names[]= {\"NO_CHAIN\", \"CHAIN\", \"RELEASE\", 0};\nstatic Sys_var_enum Sys_completion_type(\n       \"completion_type\", \"The transaction completion type, one of \"\n       \"NO_CHAIN, CHAIN, RELEASE\",\n       SESSION_VAR(completion_type), CMD_LINE(REQUIRED_ARG),\n       completion_type_names, DEFAULT(0));\n\nstatic bool check_collation_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT)\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res= var->value->val_str(&str)))\n      var->save_result.ptr= NULL;\n    else\n    {\n      ErrConvString err(res); /* Get utf8 '\\0'-terminated string */\n      if (!(var->save_result.ptr= get_charset_by_name(err.ptr(), MYF(0))))\n      {\n        my_error(ER_UNKNOWN_COLLATION, MYF(0), err.ptr());\n        return true;\n      }\n    }\n  }\n  else // INT_RESULT\n  {\n    int csno= (int)var->value->val_int();\n    if (!(var->save_result.ptr= get_charset(csno, MYF(0))))\n    {\n      my_error(ER_UNKNOWN_COLLATION, MYF(0), llstr(csno, buff));\n      return true;\n    }\n  }\n  return check_not_null(self, thd, var);\n}\nstatic Sys_var_struct Sys_collation_connection(\n       \"collation_connection\", \"The collation of the connection \"\n       \"character set\",\n       SESSION_VAR(collation_connection), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic bool check_collation_db(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_collation_not_null(self, thd, var))\n    return true;\n  if (!var->value) // = DEFAULT\n    var->save_result.ptr= thd->db_charset;\n  return false;\n}\nstatic Sys_var_struct Sys_collation_database(\n       \"collation_database\", \"The collation of the database \"\n       \"character set\",\n       SESSION_VAR(collation_database), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_db),\n       ON_UPDATE(update_deprecated));\n\nstatic Sys_var_struct Sys_collation_server(\n       \"collation_server\", \"The server default collation\",\n       SESSION_VAR(collation_server), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_not_null));\n\nstatic const char *concurrent_insert_names[]= {\"NEVER\", \"AUTO\", \"ALWAYS\", 0};\nstatic Sys_var_enum Sys_concurrent_insert(\n       \"concurrent_insert\", \"Use concurrent insert with MyISAM. Possible \"\n       \"values are NEVER, AUTO, ALWAYS\",\n       GLOBAL_VAR(myisam_concurrent_insert), CMD_LINE(OPT_ARG),\n       concurrent_insert_names, DEFAULT(1));\n\nstatic Sys_var_ulong Sys_connect_timeout(\n       \"connect_timeout\",\n       \"The number of seconds the mysqld server is waiting for a connect \"\n       \"packet before responding with 'Bad handshake'\",\n       GLOBAL_VAR(connect_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(2, LONG_TIMEOUT), DEFAULT(CONNECT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_datadir(\n       \"datadir\", \"Path to the database root directory\",\n       READ_ONLY GLOBAL_VAR(mysql_real_data_home_ptr),\n       CMD_LINE(REQUIRED_ARG, 'h'), IN_FS_CHARSET, DEFAULT(mysql_real_data_home));\n\n#ifndef DBUG_OFF\nstatic Sys_var_dbug Sys_dbug(\n       \"debug\", \"Debug log\", sys_var::SESSION,\n       CMD_LINE(OPT_ARG, '#'), DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_has_super));\n#endif\n\n/**\n  @todo\n    When updating myisam_delay_key_write, we should do a 'flush tables'\n    of all MyISAM tables to ensure that they are reopen with the\n    new attribute.\n*/\nexport bool fix_delay_key_write(sys_var *self, THD *thd, enum_var_type type)\n{\n  switch (delay_key_write_options) {\n  case DELAY_KEY_WRITE_NONE:\n    myisam_delay_key_write=0;\n    break;\n  case DELAY_KEY_WRITE_ON:\n    myisam_delay_key_write=1;\n    break;\n  case DELAY_KEY_WRITE_ALL:\n    myisam_delay_key_write=1;\n    ha_open_options|= HA_OPEN_DELAY_KEY_WRITE;\n    break;\n  }\n  return false;\n}\nstatic const char *delay_key_write_names[]= { \"OFF\", \"ON\", \"ALL\", NullS };\nstatic Sys_var_enum Sys_delay_key_write(\n       \"delay_key_write\", \"Type of DELAY_KEY_WRITE\",\n       GLOBAL_VAR(delay_key_write_options), CMD_LINE(OPT_ARG),\n       delay_key_write_names, DEFAULT(DELAY_KEY_WRITE_ON),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_delay_key_write));\n\nstatic Sys_var_ulong Sys_delayed_insert_limit(\n       \"delayed_insert_limit\",\n       \"After inserting delayed_insert_limit rows, the INSERT DELAYED \"\n       \"handler will check if there are any SELECT statements pending. \"\n       \"If so, it allows these to execute before continuing. \"\n       \"This variable is deprecated along with INSERT DELAYED.\",\n       GLOBAL_VAR(delayed_insert_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(DELAYED_LIMIT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_delayed_insert_timeout(\n       \"delayed_insert_timeout\",\n       \"How long a INSERT DELAYED thread should wait for INSERT statements \"\n       \"before terminating. \"\n       \"This variable is deprecated along with INSERT DELAYED.\",\n       GLOBAL_VAR(delayed_insert_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(DELAYED_WAIT_TIMEOUT),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_delayed_queue_size(\n       \"delayed_queue_size\",\n       \"What size queue (in rows) should be allocated for handling INSERT \"\n       \"DELAYED. If the queue becomes full, any client that does INSERT \"\n       \"DELAYED will wait until there is room in the queue again. \"\n       \"This variable is deprecated along with INSERT DELAYED.\",\n       GLOBAL_VAR(delayed_queue_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(DELAYED_QUEUE_SIZE), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\n#ifndef EMBEDDED_LIBRARY\nstatic const char *event_scheduler_names[]= { \"OFF\", \"ON\", \"DISABLED\", NullS };\nstatic bool event_scheduler_check(sys_var *self, THD *thd, set_var *var)\n{\n  /* DISABLED is only accepted on the command line */\n  if (var->save_result.ulonglong_value == Events::EVENTS_DISABLED)\n    return true;\n  /*\n    If the scheduler was disabled because there are no/bad\n    system tables, produce a more meaningful error message\n    than ER_OPTION_PREVENTS_STATEMENT\n  */\n  if (Events::check_if_system_tables_error())\n    return true;\n  if (Events::opt_event_scheduler == Events::EVENTS_DISABLED)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0),\n             \"--event-scheduler=DISABLED or --skip-grant-tables\");\n    return true;\n  }\n  return false;\n}\nstatic bool event_scheduler_update(sys_var *self, THD *thd, enum_var_type type)\n{\n  int err_no= 0;\n  ulong opt_event_scheduler_value= Events::opt_event_scheduler;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  /*\n    Events::start() is heavyweight. In particular it creates a new THD,\n    which takes LOCK_global_system_variables internally.\n    Thus we have to release it here.\n    We need to re-take it before returning, though.\n\n    Note that since we release LOCK_global_system_variables before calling\n    start/stop, there is a possibility that the server variable\n    can become out of sync with the real event scheduler state.\n\n    This can happen with two concurrent statments if the first gets\n    interrupted after start/stop but before retaking\n    LOCK_global_system_variables. However, this problem should be quite\n    rare and it's difficult to avoid it without opening up possibilities\n    for deadlocks. See bug#51160.\n  */\n  bool ret= opt_event_scheduler_value == Events::EVENTS_ON\n            ? Events::start(&err_no)\n            : Events::stop();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  if (ret)\n  {\n    Events::opt_event_scheduler= Events::EVENTS_OFF;\n    my_error(ER_EVENT_SET_VAR_ERROR, MYF(0), err_no);\n  }\n  return ret;\n}\n\nstatic Sys_var_enum Sys_event_scheduler(\n       \"event_scheduler\", \"Enable the event scheduler. Possible values are \"\n       \"ON, OFF, and DISABLED (keep the event scheduler completely \"\n       \"deactivated, it cannot be activated run-time)\",\n       GLOBAL_VAR(Events::opt_event_scheduler), CMD_LINE(OPT_ARG),\n       event_scheduler_names, DEFAULT(Events::EVENTS_OFF),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(event_scheduler_check), ON_UPDATE(event_scheduler_update));\n#endif\n\nstatic Sys_var_ulong Sys_expire_logs_days(\n       \"expire_logs_days\",\n       \"If non-zero, binary logs will be purged after expire_logs_days \"\n       \"days; possible purges happen at startup and at binary log rotation\",\n       GLOBAL_VAR(expire_logs_days),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 99), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_flush(\n       \"flush\", \"Flush MyISAM tables to disk between SQL commands\",\n       GLOBAL_VAR(myisam_flush),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_flush_time(\n       \"flush_time\",\n       \"A dedicated thread is created to flush all tables at the \"\n       \"given interval\",\n       GLOBAL_VAR(flush_time),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT),\n       DEFAULT(0), BLOCK_SIZE(1));\n\nstatic bool check_ftb_syntax(sys_var *self, THD *thd, set_var *var)\n{\n  return ft_boolean_check_syntax_string((uchar*)\n                      (var->save_result.string_value.str));\n}\nstatic bool query_cache_flush(sys_var *self, THD *thd, enum_var_type type)\n{\n  query_cache.flush();\n  return false;\n}\n/// @todo make SESSION_VAR (usability enhancement and a fix for a race condition)\nstatic Sys_var_charptr Sys_ft_boolean_syntax(\n       \"ft_boolean_syntax\", \"List of operators for \"\n       \"MATCH ... AGAINST ( ... IN BOOLEAN MODE)\",\n       GLOBAL_VAR(ft_boolean_syntax),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(DEFAULT_FTB_SYNTAX), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_ftb_syntax), ON_UPDATE(query_cache_flush));\n\nstatic Sys_var_ulong Sys_ft_max_word_len(\n       \"ft_max_word_len\",\n       \"The maximum length of the word to be included in a FULLTEXT index. \"\n       \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n       READ_ONLY GLOBAL_VAR(ft_max_word_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(10, HA_FT_MAXCHARLEN), DEFAULT(HA_FT_MAXCHARLEN),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_ft_min_word_len(\n       \"ft_min_word_len\",\n       \"The minimum length of the word to be included in a FULLTEXT index. \"\n       \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n       READ_ONLY GLOBAL_VAR(ft_min_word_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, HA_FT_MAXCHARLEN), DEFAULT(4), BLOCK_SIZE(1));\n\n/// @todo make it an updatable SESSION_VAR\nstatic Sys_var_ulong Sys_ft_query_expansion_limit(\n       \"ft_query_expansion_limit\",\n       \"Number of best matches to use for query expansion\",\n       READ_ONLY GLOBAL_VAR(ft_query_expansion_limit),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1000), DEFAULT(20), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_ft_stopword_file(\n       \"ft_stopword_file\",\n       \"Use stopwords from this file instead of built-in list\",\n       READ_ONLY GLOBAL_VAR(ft_stopword_file), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_ignore_builtin_innodb(\n       \"ignore_builtin_innodb\",\n       \"IGNORED. This option will be removed in future releases. \"\n       \"Disable initialization of builtin InnoDB plugin\",\n       READ_ONLY GLOBAL_VAR(opt_ignore_builtin_innodb),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic bool check_init_string(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->save_result.string_value.str == 0)\n  {\n    var->save_result.string_value.str= const_cast<char*>(\"\");\n    var->save_result.string_value.length= 0;\n  }\n  return false;\n}\nstatic PolyLock_rwlock PLock_sys_init_connect(&LOCK_sys_init_connect);\nstatic Sys_var_lexstring Sys_init_connect(\n       \"init_connect\", \"Command(s) that are executed for each \"\n       \"new connection\", GLOBAL_VAR(opt_init_connect),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), &PLock_sys_init_connect, NOT_IN_BINLOG,\n       ON_CHECK(check_init_string));\n\nstatic Sys_var_charptr Sys_init_file(\n       \"init_file\", \"Read SQL commands from this file at startup\",\n       READ_ONLY GLOBAL_VAR(opt_init_file),\n       CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic PolyLock_rwlock PLock_sys_init_slave(&LOCK_sys_init_slave);\nstatic Sys_var_lexstring Sys_init_slave(\n       \"init_slave\", \"Command(s) that are executed by a slave server \"\n       \"each time the SQL thread starts\", GLOBAL_VAR(opt_init_slave),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), &PLock_sys_init_slave,\n       NOT_IN_BINLOG, ON_CHECK(check_init_string));\n\nstatic Sys_var_ulong Sys_interactive_timeout(\n       \"interactive_timeout\",\n       \"The number of seconds the server waits for activity on an interactive \"\n       \"connection before closing it\",\n       SESSION_VAR(net_interactive_timeout),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_join_buffer_size(\n       \"join_buffer_size\",\n       \"The size of the buffer that is used for full joins\",\n       SESSION_VAR(join_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(128, ULONG_MAX), DEFAULT(256 * 1024), BLOCK_SIZE(128));\n\nstatic Sys_var_keycache Sys_key_buffer_size(\n       \"key_buffer_size\", \"The size of the buffer used for \"\n       \"index blocks for MyISAM tables. Increase this to get better index \"\n       \"handling (for all reads and multiple writes) to as much as you can \"\n       \"afford\",\n       KEYCACHE_VAR(param_buff_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_BUFFER_SIZE),\n       VALID_RANGE(0, SIZE_T_MAX), DEFAULT(KEY_CACHE_SIZE),\n       BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_buffer_size));\n\nstatic Sys_var_keycache Sys_key_cache_block_size(\n       \"key_cache_block_size\", \"The default size of key cache blocks\",\n       KEYCACHE_VAR(param_block_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_BLOCK_SIZE),\n       VALID_RANGE(512, 1024*16), DEFAULT(KEY_CACHE_BLOCK_SIZE),\n       BLOCK_SIZE(512), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_division_limit(\n       \"key_cache_division_limit\",\n       \"The minimum percentage of warm blocks in key cache\",\n       KEYCACHE_VAR(param_division_limit),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_DIVISION_LIMIT),\n       VALID_RANGE(1, 100), DEFAULT(100),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_age_threshold(\n       \"key_cache_age_threshold\", \"This characterizes the number of \"\n       \"hits a hot block has to be untouched until it is considered aged \"\n       \"enough to be downgraded to a warm block. This specifies the \"\n       \"percentage ratio of that number of hits to the total number of \"\n       \"blocks in key cache\",\n       KEYCACHE_VAR(param_age_threshold),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_AGE_THRESHOLD),\n       VALID_RANGE(100, ULONG_MAX), DEFAULT(300),\n       BLOCK_SIZE(100), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_keycache_param));\n\nstatic Sys_var_mybool Sys_large_files_support(\n       \"large_files_support\",\n       \"Whether mysqld was compiled with options for large file support\",\n       READ_ONLY GLOBAL_VAR(opt_large_files),\n       NO_CMD_LINE, DEFAULT(sizeof(my_off_t) > 4));\n\nstatic Sys_var_uint Sys_large_page_size(\n       \"large_page_size\",\n       \"If large page support is enabled, this shows the size of memory pages\",\n       READ_ONLY GLOBAL_VAR(opt_large_page_size), NO_CMD_LINE,\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_large_pages(\n       \"large_pages\", \"Enable support for large pages\",\n       READ_ONLY GLOBAL_VAR(opt_large_pages),\n       IF_WIN(NO_CMD_LINE, CMD_LINE(OPT_ARG)), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_language(\n       \"lc_messages_dir\", \"Directory where error messages are\",\n       READ_ONLY GLOBAL_VAR(lc_messages_dir_ptr), \n       CMD_LINE(REQUIRED_ARG, OPT_LC_MESSAGES_DIRECTORY),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_local_infile(\n       \"local_infile\", \"Enable LOAD DATA LOCAL INFILE\",\n       GLOBAL_VAR(opt_local_infile), CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_lock_wait_timeout(\n       \"lock_wait_timeout\",\n       \"Timeout in seconds to wait for a lock before returning an error.\",\n       SESSION_VAR(lock_wait_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(LONG_TIMEOUT), BLOCK_SIZE(1));\n\n#ifdef HAVE_MLOCKALL\nstatic Sys_var_mybool Sys_locked_in_memory(\n       \"locked_in_memory\",\n       \"Whether mysqld was locked in memory with --memlock\",\n       READ_ONLY GLOBAL_VAR(locked_in_memory), NO_CMD_LINE, DEFAULT(FALSE));\n#endif\n\n/* this says NO_CMD_LINE, as command-line option takes a string, not a bool */\nstatic Sys_var_mybool Sys_log_bin(\n       \"log_bin\", \"Whether the binary log is enabled\",\n       READ_ONLY GLOBAL_VAR(opt_bin_log), NO_CMD_LINE, DEFAULT(FALSE));\n\nstatic bool transaction_write_set_check(sys_var *self, THD *thd, set_var *var)\n{\n#ifdef HAVE_REPLICATION\n  // Can't change the algorithm when group replication is enabled.\n  if (is_group_replication_running())\n  {\n    my_message(ER_GROUP_REPLICATION_RUNNING,\n               \"The write set algorithm cannot be changed when Group replication\"\n               \" is running.\", MYF(0));\n    return true;\n  }\n#endif\n\n  if (var->type == OPT_GLOBAL &&\n      global_system_variables.binlog_format != BINLOG_FORMAT_ROW)\n  {\n    my_error(ER_PREVENTS_VARIABLE_WITHOUT_RBR, MYF(0), var->var->name.str);\n    return true;\n  }\n\n  if (var->type == OPT_SESSION &&\n      thd->variables.binlog_format != BINLOG_FORMAT_ROW)\n  {\n    my_error(ER_PREVENTS_VARIABLE_WITHOUT_RBR, MYF(0), var->var->name.str);\n    return true;\n  }\n  /*\n    if in a stored function/trigger, it's too late to change\n  */\n  if (thd->in_sub_stmt)\n  {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  /*\n    Make the session variable 'transaction_write_set_extraction' read-only inside a transaction.\n  */\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  return false;\n}\n\nstatic Sys_var_enum Sys_extract_write_set(\n       \"transaction_write_set_extraction\",\n       \"This option is used to let the server know when to \"\n       \"extract the write set which will be used for various purposes. \",\n       SESSION_VAR(transaction_write_set_extraction), CMD_LINE(OPT_ARG),\n       transaction_write_set_hashing_algorithms,\n       DEFAULT(HASH_ALGORITHM_OFF), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(transaction_write_set_check),\n       ON_UPDATE(NULL));\n\nstatic Sys_var_ulong Sys_rpl_stop_slave_timeout(\n       \"rpl_stop_slave_timeout\",\n       \"Timeout in seconds to wait for slave to stop before returning a \"\n       \"warning.\",\n       GLOBAL_VAR(rpl_stop_slave_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(2, LONG_TIMEOUT), DEFAULT(LONG_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_enum Sys_binlog_error_action(\n       \"binlog_error_action\",\n       \"When statements cannot be written to the binary log due to a fatal \"\n       \"error, the server can either ignore the error and let the master \"\n       \"continue, or abort.\", GLOBAL_VAR(binlog_error_action),\n       CMD_LINE(REQUIRED_ARG), binlog_error_action_list, DEFAULT(ABORT_SERVER));\n\nstatic Sys_var_mybool Sys_trust_function_creators(\n       \"log_bin_trust_function_creators\",\n       \"If set to FALSE (the default), then when --log-bin is used, creation \"\n       \"of a stored function (or trigger) is allowed only to users having the \"\n       \"SUPER privilege and only if this stored function (trigger) may not \"\n       \"break binary logging. Note that if ALL connections to this server \"\n       \"ALWAYS use row-based binary logging, the security issues do not \"\n       \"exist and the binary logging cannot break, so you can safely set \"\n       \"this to TRUE\",\n       GLOBAL_VAR(trust_function_creators),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_check_proxy_users(\n\t\"check_proxy_users\",\n\t\"If set to FALSE (the default), then proxy user identity will not be \"\n\t\"mapped for authentication plugins which support mapping from grant \"\n\t\"tables.  When set to TRUE, users associated with authentication \"\n\t\"plugins which signal proxy user mapping should be done according to \"\n\t\"GRANT PROXY privilege definition.\",\n\tGLOBAL_VAR(check_proxy_users),\n\tCMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_mysql_native_password_proxy_users(\n\t\"mysql_native_password_proxy_users\",\n\t\"If set to FALSE (the default), then the mysql_native_password \"\n\t\"plugin will not signal for authenticated users to be checked for mapping \"\n\t\"to proxy users.  When set to TRUE, the plugin will flag associated \"\n\t\"authenticated accounts to be mapped to proxy users when the server option \"\n\t\"check_proxy_users is enabled.\",\n\tGLOBAL_VAR(mysql_native_password_proxy_users),\n\tCMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_sha256_password_proxy_users(\n\t\"sha256_password_proxy_users\",\n\t\"If set to FALSE (the default), then the sha256_password authentication \"\n\t\"plugin will not signal for authenticated users to be checked for mapping \"\n\t\"to proxy users.  When set to TRUE, the plugin will flag associated \"\n\t\"authenticated accounts to be mapped to proxy users when the server option \"\n\t\"check_proxy_users is enabled.\",\n\tGLOBAL_VAR(sha256_password_proxy_users),\n\tCMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_use_v1_row_events(\n       \"log_bin_use_v1_row_events\",\n       \"If equal to 1 then version 1 row events are written to a row based \"\n       \"binary log.  If equal to 0, then the latest version of events are \"\n       \"written.  \"\n       \"This option is useful during some upgrades.\",\n       GLOBAL_VAR(log_bin_use_v1_row_events),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_log_error(\n       \"log_error\", \"Error log file\",\n       READ_ONLY GLOBAL_VAR(log_error_dest),\n       CMD_LINE(OPT_ARG, OPT_LOG_ERROR),\n       IN_FS_CHARSET, DEFAULT(disabled_my_option), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL),\n       NULL, sys_var::PARSE_EARLY);\n\nstatic Sys_var_mybool Sys_log_queries_not_using_indexes(\n       \"log_queries_not_using_indexes\",\n       \"Log queries that are executed without benefit of any index to the \"\n       \"slow log if it is open\",\n       GLOBAL_VAR(opt_log_queries_not_using_indexes),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_log_slow_admin_statements(\n       \"log_slow_admin_statements\",\n       \"Log slow OPTIMIZE, ANALYZE, ALTER and other administrative statements to \"\n       \"the slow log if it is open.\",\n       GLOBAL_VAR(opt_log_slow_admin_statements),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_log_slow_slave_statements(\n       \"log_slow_slave_statements\",\n       \"Log slow statements executed by slave thread to the slow log if it is open.\",\n       GLOBAL_VAR(opt_log_slow_slave_statements),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic bool update_log_throttle_queries_not_using_indexes(sys_var *self,\n                                                          THD *thd,\n                                                          enum_var_type type)\n{\n  // Check if we should print a summary of any suppressed lines to the slow log\n  // now since opt_log_throttle_queries_not_using_indexes was changed.\n  log_throttle_qni.flush(thd);\n  return false;\n}\n\nstatic Sys_var_ulong Sys_log_throttle_queries_not_using_indexes(\n       \"log_throttle_queries_not_using_indexes\",\n       \"Log at most this many 'not using index' warnings per minute to the \"\n       \"slow log. Any further warnings will be condensed into a single \"\n       \"summary line. A value of 0 disables throttling. \"\n       \"Option has no effect unless --log_queries_not_using_indexes is set.\",\n       GLOBAL_VAR(opt_log_throttle_queries_not_using_indexes),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0),\n       ON_UPDATE(update_log_throttle_queries_not_using_indexes));\n\nstatic bool update_log_warnings(sys_var *self, THD *thd, enum_var_type type)\n{\n  // log_warnings is deprecated, but for now, we'll set the\n  // new log_error_verbosity from it for backward compatibility.\n  log_error_verbosity= std::min(3UL, 1UL + log_warnings);\n  return false;\n}\n\nstatic Sys_var_ulong Sys_log_warnings(\n       \"log_warnings\",\n       \"Log some not critical warnings to the log file\",\n       GLOBAL_VAR(log_warnings),\n       CMD_LINE(OPT_ARG, 'W'),\n       VALID_RANGE(0, 2), DEFAULT(2), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(update_log_warnings),\n       DEPRECATED(\"log_error_verbosity\"));\n\nstatic bool update_log_error_verbosity(sys_var *self, THD *thd,\n                                       enum_var_type type)\n{\n  // log_warnings is deprecated, but for now, we'll set it from\n  // the new log_error_verbosity for backward compatibility.\n  log_warnings= log_error_verbosity - 1;\n  return false;\n}\n\nstatic Sys_var_ulong Sys_log_error_verbosity(\n       \"log_error_verbosity\",\n       \"How detailed the error log should be. \"\n       \"1, log errors only. \"\n       \"2, log errors and warnings. \"\n       \"3, log errors, warnings, and notes. \"\n       \"Messages sent to the client are unaffected by this setting.\",\n       GLOBAL_VAR(log_error_verbosity),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 3), DEFAULT(3), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(update_log_error_verbosity));\n\nstatic Sys_var_enum Sys_log_timestamps(\n       \"log_timestamps\",\n       \"UTC to timestamp log files in zulu time, for more concise timestamps \"\n       \"and easier correlation of logs from servers from multiple time zones, \"\n       \"or SYSTEM to use the system's local time. \"\n       \"This affects only log files, not log tables, as the timestamp columns \"\n       \"of the latter can be converted at will.\",\n       GLOBAL_VAR(opt_log_timestamps),\n       CMD_LINE(REQUIRED_ARG),\n       timestamp_type_names, DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic Sys_var_mybool Sys_log_statements_unsafe_for_binlog(\n       \"log_statements_unsafe_for_binlog\",\n       \"Log statements considered unsafe when using statement based binary logging.\",\n       GLOBAL_VAR(opt_log_unsafe_statements),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\n/* logging to host OS's syslog */\n\nstatic bool fix_syslog(sys_var *self, THD *thd, enum_var_type type)\n{\n  return log_syslog_update_settings();\n}\n\nstatic bool check_syslog_tag(sys_var *self, THD *THD, set_var *var)\n{\n  return ((var->save_result.string_value.str != NULL) &&\n          (strchr(var->save_result.string_value.str, FN_LIBCHAR) != NULL));\n}\n\nstatic Sys_var_mybool Sys_log_syslog_enable(\n       \"log_syslog\",\n       \"Errors, warnings, and similar issues eligible for MySQL's error log \"\n       \"file may additionally be sent to the host operating system's system \"\n       \"log (\\\"syslog\\\").\",\n       GLOBAL_VAR(opt_log_syslog_enable),\n       CMD_LINE(OPT_ARG),\n       // preserve current defaults for both platforms:\n#ifndef _WIN32\n       DEFAULT(FALSE),\n#else\n       DEFAULT(TRUE),\n#endif\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0), ON_UPDATE(fix_syslog));\n\n\nstatic Sys_var_charptr Sys_log_syslog_tag(\n       \"log_syslog_tag\",\n       \"When logging issues using the host operating system's syslog, \"\n       \"tag the entries from this particular MySQL server with this ident. \"\n       \"This will help distinguish entries from MySQL servers co-existing \"\n       \"on the same host machine. A non-empty tag will be appended to the \"\n       \"default ident of 'mysqld', connected by a hyphen.\",\n       GLOBAL_VAR(opt_log_syslog_tag), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_syslog_tag), ON_UPDATE(fix_syslog));\n\n\n#ifndef _WIN32\n\nstatic bool check_syslog_facility(sys_var *self, THD *THD, set_var *var)\n{\n  SYSLOG_FACILITY rsf;\n\n  if (var->value &&\n      log_syslog_find_facility(var->save_result.string_value.str, &rsf))\n    return true;\n  return false;\n}\n\nstatic bool fix_syslog_facility(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (opt_log_syslog_facility == NULL)\n    return true;\n\n  return log_syslog_update_settings();\n}\n\nstatic Sys_var_charptr Sys_log_syslog_facility(\n       \"log_syslog_facility\",\n       \"When logging issues using the host operating system's syslog, \"\n       \"identify as a facility of the given type (to aid in log filtering).\",\n       GLOBAL_VAR(opt_log_syslog_facility), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"daemon\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_syslog_facility), ON_UPDATE(fix_syslog_facility));\n\nstatic Sys_var_mybool Sys_log_syslog_log_pid(\n       \"log_syslog_include_pid\",\n       \"When logging issues using the host operating system's syslog, \"\n       \"include this MySQL server's process ID (PID). This setting does \"\n       \"not affect MySQL's own error log file.\",\n       GLOBAL_VAR(opt_log_syslog_include_pid),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0), ON_UPDATE(fix_syslog));\n\n#endif\n\nstatic bool update_cached_long_query_time(sys_var *self, THD *thd,\n                                          enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->variables.long_query_time=\n      double2ulonglong(thd->variables.long_query_time_double * 1e6);\n  else\n    global_system_variables.long_query_time=\n      double2ulonglong(global_system_variables.long_query_time_double * 1e6);\n  return false;\n}\n\nstatic Sys_var_double Sys_long_query_time(\n       \"long_query_time\",\n       \"Log all queries that have taken more than long_query_time seconds \"\n       \"to execute to file. The argument will be treated as a decimal value \"\n       \"with microsecond precision\",\n       SESSION_VAR(long_query_time_double),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(10),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_cached_long_query_time));\n\nstatic bool fix_low_prio_updates(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n  {\n    thd->update_lock_default= (thd->variables.low_priority_updates ?\n                               TL_WRITE_LOW_PRIORITY : TL_WRITE);\n    thd->insert_lock_default= (thd->variables.low_priority_updates ?\n                               TL_WRITE_LOW_PRIORITY : TL_WRITE_CONCURRENT_INSERT);\n  }\n  else\n    thr_upgraded_concurrent_insert_lock=\n      (global_system_variables.low_priority_updates ?\n       TL_WRITE_LOW_PRIORITY : TL_WRITE);\n  return false;\n}\nstatic Sys_var_mybool Sys_low_priority_updates(\n       \"low_priority_updates\",\n       \"INSERT/DELETE/UPDATE has lower priority than selects\",\n       SESSION_VAR(low_priority_updates),\n       CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_low_prio_updates));\n\nstatic Sys_var_mybool Sys_lower_case_file_system(\n       \"lower_case_file_system\",\n       \"Case sensitivity of file names on the file system where the \"\n       \"data directory is located\",\n       READ_ONLY GLOBAL_VAR(lower_case_file_system), NO_CMD_LINE,\n       DEFAULT(FALSE));\n\nstatic Sys_var_uint Sys_lower_case_table_names(\n       \"lower_case_table_names\",\n       \"If set to 1 table names are stored in lowercase on disk and table \"\n       \"names will be case-insensitive.  Should be set to 2 if you are using \"\n       \"a case insensitive file system\",\n       READ_ONLY GLOBAL_VAR(lower_case_table_names),\n       CMD_LINE(OPT_ARG, OPT_LOWER_CASE_TABLE_NAMES),\n       VALID_RANGE(0, 2),\n#ifdef FN_NO_CASE_SENSE\n    DEFAULT(1),\n#else\n    DEFAULT(0),\n#endif\n       BLOCK_SIZE(1));\n\nstatic bool session_readonly(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_GLOBAL)\n    return false;\n  my_error(ER_VARIABLE_IS_READONLY, MYF(0), \"SESSION\",\n           self->name.str, \"GLOBAL\");\n  return true;\n}\n\nstatic bool\ncheck_max_allowed_packet(sys_var *self, THD *thd,  set_var *var)\n{\n  longlong val;\n  if (session_readonly(self, thd, var))\n    return true;\n\n  val= var->save_result.ulonglong_value;\n  if (val < (longlong) global_system_variables.net_buffer_length)\n  {\n    push_warning_printf(thd, Sql_condition::SL_WARNING,\n                        WARN_OPTION_BELOW_LIMIT, ER(WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\n\n\nstatic Sys_var_ulong Sys_max_allowed_packet(\n       \"max_allowed_packet\",\n       \"Max packet length to send to or receive from the server\",\n       SESSION_VAR(max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024 * 1024 * 1024), DEFAULT(4096 * 1024),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_allowed_packet));\n\nstatic Sys_var_ulong Sys_slave_max_allowed_packet(\n       \"slave_max_allowed_packet\",\n       \"The maximum packet length to sent successfully from the master to slave.\",\n       GLOBAL_VAR(slave_max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, MAX_MAX_ALLOWED_PACKET),\n       DEFAULT(MAX_MAX_ALLOWED_PACKET),\n       BLOCK_SIZE(1024));\n\nstatic Sys_var_ulonglong Sys_max_binlog_cache_size(\n       \"max_binlog_cache_size\",\n       \"Sets the total size of the transactional cache\",\n       GLOBAL_VAR(max_binlog_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, ULLONG_MAX),\n       DEFAULT((ULLONG_MAX/IO_SIZE)*IO_SIZE),\n       BLOCK_SIZE(IO_SIZE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_binlog_cache_size));\n\nstatic Sys_var_ulonglong Sys_max_binlog_stmt_cache_size(\n       \"max_binlog_stmt_cache_size\",\n       \"Sets the total size of the statement cache\",\n       GLOBAL_VAR(max_binlog_stmt_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, ULLONG_MAX),\n       DEFAULT((ULLONG_MAX/IO_SIZE)*IO_SIZE),\n       BLOCK_SIZE(IO_SIZE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_binlog_stmt_cache_size));\n\nstatic bool fix_max_binlog_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  mysql_bin_log.set_max_size(max_binlog_size);\n#ifdef HAVE_REPLICATION\n  /*\n    For multisource replication, this max size is set to all relay logs\n    per channel. So, run through them\n  */\n  if (!max_relay_log_size)\n  {\n    Master_info *mi =NULL;\n\n    channel_map.wrlock();\n    for (mi_map::iterator it= channel_map.begin(); it!= channel_map.end(); it++)\n    {\n      mi= it->second;\n      if (mi!= NULL)\n        mi->rli->relay_log.set_max_size(max_binlog_size);\n    }\n    channel_map.unlock();\n  }\n#endif\n  return false;\n}\nstatic Sys_var_ulong Sys_max_binlog_size(\n       \"max_binlog_size\",\n       \"Binary log will be rotated automatically when the size exceeds this \"\n       \"value. Will also apply to relay logs if max_relay_log_size is 0\",\n       GLOBAL_VAR(max_binlog_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, 1024*1024L*1024L), DEFAULT(1024*1024L*1024L),\n       BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_binlog_size));\n\nstatic Sys_var_ulong Sys_max_connections(\n       \"max_connections\", \"The number of simultaneous clients allowed\",\n       GLOBAL_VAR(max_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 100000),\n       DEFAULT(MAX_CONNECTIONS_DEFAULT),\n       BLOCK_SIZE(1),\n       NO_MUTEX_GUARD,\n       NOT_IN_BINLOG,\n       ON_CHECK(0),\n       ON_UPDATE(0),\n       NULL,\n       /* max_connections is used as a sizing hint by the performance schema. */\n       sys_var::PARSE_EARLY);\n\nstatic Sys_var_ulong Sys_max_connect_errors(\n       \"max_connect_errors\",\n       \"If there is more than this number of interrupted connections from \"\n       \"a host this host will be blocked from further connections\",\n       GLOBAL_VAR(max_connect_errors), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(100),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_max_digest_length(\n       \"max_digest_length\",\n       \"Maximum length considered for digest text.\",\n       READ_ONLY GLOBAL_VAR(max_digest_length),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024 * 1024),\n       DEFAULT(1024),\n       BLOCK_SIZE(1));\n\nstatic bool check_max_delayed_threads(sys_var *self, THD *thd, set_var *var)\n{\n  return var->type != OPT_GLOBAL &&\n         var->save_result.ulonglong_value != 0 &&\n         var->save_result.ulonglong_value !=\n                           global_system_variables.max_insert_delayed_threads;\n}\n\n// Alias for max_delayed_threads\nstatic Sys_var_ulong Sys_max_insert_delayed_threads(\n       \"max_insert_delayed_threads\",\n       \"Don't start more than this number of threads to handle INSERT \"\n       \"DELAYED statements. If set to zero INSERT DELAYED will be not used. \"\n       \"This variable is deprecated along with INSERT DELAYED.\",\n       SESSION_VAR(max_insert_delayed_threads),\n       NO_CMD_LINE, VALID_RANGE(0, 16384), DEFAULT(20),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_delayed_threads), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_max_delayed_threads(\n       \"max_delayed_threads\",\n       \"Don't start more than this number of threads to handle INSERT \"\n       \"DELAYED statements. If set to zero INSERT DELAYED will be not used. \"\n       \"This variable is deprecated along with INSERT DELAYED.\",\n       SESSION_VAR(max_insert_delayed_threads),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 16384), DEFAULT(20),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_delayed_threads), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_max_error_count(\n       \"max_error_count\",\n       \"Max number of errors/warnings to store for a statement\",\n       SESSION_VAR(max_error_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 65535), DEFAULT(DEFAULT_ERROR_COUNT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_max_heap_table_size(\n       \"max_heap_table_size\",\n       \"Don't allow creation of heap tables bigger than this\",\n       SESSION_VAR(max_heap_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(16384, (ulonglong)~(intptr)0), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1024));\n\nstatic ulong mdl_locks_cache_size_unused;\nstatic Sys_var_ulong Sys_metadata_locks_cache_size(\n       \"metadata_locks_cache_size\", \"Has no effect, deprecated\",\n       READ_ONLY GLOBAL_VAR(mdl_locks_cache_size_unused),\n       CMD_LINE(REQUIRED_ARG, OPT_MDL_CACHE_SIZE),\n       VALID_RANGE(1, 1024*1024), DEFAULT(1024), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic ulong mdl_locks_hash_partitions_unused;\nstatic Sys_var_ulong Sys_metadata_locks_hash_instances(\n       \"metadata_locks_hash_instances\", \"Has no effect, deprecated\",\n       READ_ONLY GLOBAL_VAR(mdl_locks_hash_partitions_unused),\n       CMD_LINE(REQUIRED_ARG, OPT_MDL_HASH_INSTANCES),\n       VALID_RANGE(1, 1024), DEFAULT(8), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\n// relies on DBUG_ASSERT(sizeof(my_thread_id) == 4);\nstatic Sys_var_uint Sys_pseudo_thread_id(\n       \"pseudo_thread_id\",\n       \"This variable is for internal server use\",\n       SESSION_ONLY(pseudo_thread_id),\n       NO_CMD_LINE, VALID_RANGE(0, UINT_MAX32), DEFAULT(0),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG,\n       ON_CHECK(check_has_super));\n\nstatic bool fix_max_join_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  SV *sv= type == OPT_GLOBAL ? &global_system_variables : &thd->variables;\n  if (sv->max_join_size == HA_POS_ERROR)\n    sv->option_bits|= OPTION_BIG_SELECTS;\n  else\n    sv->option_bits&= ~OPTION_BIG_SELECTS;\n  return false;\n}\nstatic Sys_var_harows Sys_max_join_size(\n       \"max_join_size\",\n       \"Joins that are probably going to read more than max_join_size \"\n       \"records return an error\",\n       SESSION_VAR(max_join_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_join_size));\n\nstatic Sys_var_ulong Sys_max_seeks_for_key(\n       \"max_seeks_for_key\",\n       \"Limit assumed max number of seeks when looking up rows based on a key\",\n       SESSION_VAR(max_seeks_for_key), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(ULONG_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_length_for_sort_data(\n       \"max_length_for_sort_data\",\n       \"Max number of bytes in sorted records\",\n       SESSION_VAR(max_length_for_sort_data), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, 8192*1024L), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_points_in_geometry(\n       \"max_points_in_geometry\",\n       \"Maximum number of points in a geometry\",\n       SESSION_VAR(max_points_in_geometry), CMD_LINE(OPT_ARG),\n       VALID_RANGE(3, 1024*1024L), DEFAULT(64*1024), BLOCK_SIZE(1));\n\nstatic PolyLock_mutex PLock_prepared_stmt_count(&LOCK_prepared_stmt_count);\n\nstatic Sys_var_ulong Sys_max_prepared_stmt_count(\n       \"max_prepared_stmt_count\",\n       \"Maximum number of prepared statements in the server\",\n       GLOBAL_VAR(max_prepared_stmt_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1024*1024), DEFAULT(16382), BLOCK_SIZE(1),\n       &PLock_prepared_stmt_count, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(NULL), NULL,\n       /* max_prepared_stmt_count is used as a sizing hint by the performance schema. */\n       sys_var::PARSE_EARLY);\n\nstatic bool fix_max_relay_log_size(sys_var *self, THD *thd, enum_var_type type)\n{\n#ifdef HAVE_REPLICATION\n  Master_info *mi= NULL;\n\n  channel_map.wrlock();\n  for (mi_map::iterator it= channel_map.begin(); it!=channel_map.end(); it++)\n  {\n    mi= it->second;\n\n    if (mi != NULL)\n      mi->rli->relay_log.set_max_size(max_relay_log_size ?\n                                      max_relay_log_size: max_binlog_size);\n  }\n  channel_map.unlock();\n#endif\n  return false;\n}\nstatic Sys_var_ulong Sys_max_relay_log_size(\n       \"max_relay_log_size\",\n       \"If non-zero: relay log will be rotated automatically when the \"\n       \"size exceeds this value; if zero: when the size \"\n       \"exceeds max_binlog_size\",\n       GLOBAL_VAR(max_relay_log_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1024L*1024*1024), DEFAULT(0), BLOCK_SIZE(IO_SIZE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_relay_log_size));\n\nstatic Sys_var_ulong Sys_max_sort_length(\n       \"max_sort_length\",\n       \"The number of bytes to use when sorting BLOB or TEXT values (only \"\n       \"the first max_sort_length bytes of each value are used; the rest \"\n       \"are ignored)\",\n       SESSION_VAR(max_sort_length), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, 8192*1024L), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_sp_recursion_depth(\n       \"max_sp_recursion_depth\",\n       \"Maximum stored procedure recursion depth\",\n       SESSION_VAR(max_sp_recursion_depth), CMD_LINE(OPT_ARG),\n       VALID_RANGE(0, 255), DEFAULT(0), BLOCK_SIZE(1));\n\n// non-standard session_value_ptr() here\nstatic Sys_var_max_user_conn Sys_max_user_connections(\n       \"max_user_connections\",\n       \"The maximum number of active connections for a single user \"\n       \"(0 = no limit)\",\n       SESSION_VAR(max_user_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(session_readonly));\n\nstatic Sys_var_ulong Sys_max_tmp_tables(\n       \"max_tmp_tables\",\n       \"Maximum number of temporary tables a client can keep open at a time\",\n       SESSION_VAR(max_tmp_tables), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(32), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_max_write_lock_count(\n       \"max_write_lock_count\",\n       \"After this many write locks, allow some read locks to run in between\",\n       GLOBAL_VAR(max_write_lock_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(ULONG_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_min_examined_row_limit(\n       \"min_examined_row_limit\",\n       \"Don't write queries to slow log that examine fewer rows \"\n       \"than that\",\n       SESSION_VAR(min_examined_row_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\n#ifdef _WIN32\nstatic Sys_var_mybool Sys_named_pipe(\n       \"named_pipe\", \"Enable the named pipe (NT)\",\n       READ_ONLY GLOBAL_VAR(opt_enable_named_pipe), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n#endif\n\n\nstatic bool \ncheck_net_buffer_length(sys_var *self, THD *thd,  set_var *var)\n{\n  longlong val;\n  if (session_readonly(self, thd, var))\n    return true;\n\n  val= var->save_result.ulonglong_value;\n  if (val > (longlong) global_system_variables.max_allowed_packet)\n  {\n    push_warning_printf(thd, Sql_condition::SL_WARNING,\n                        WARN_OPTION_BELOW_LIMIT, ER(WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_buffer_length(\n       \"net_buffer_length\",\n       \"Buffer length for TCP/IP and socket communication\",\n       SESSION_VAR(net_buffer_length), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024), DEFAULT(16384), BLOCK_SIZE(1024),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_net_buffer_length));\n\nstatic bool fix_net_read_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n  {\n    // net_buffer_length is a specific property for the classic protocols\n    if (!thd->is_classic_protocol())\n    {\n      my_error(ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED, MYF(0));\n      return true;\n    }\n    my_net_set_read_timeout(thd->get_protocol_classic()->get_net(),\n                            thd->variables.net_read_timeout);\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_read_timeout(\n       \"net_read_timeout\",\n       \"Number of seconds to wait for more data from a connection before \"\n       \"aborting the read\",\n       SESSION_VAR(net_read_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_READ_TIMEOUT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_read_timeout));\n\nstatic bool fix_net_write_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n  {\n    // net_read_timeout is a specific property for the classic protocols\n    if (!thd->is_classic_protocol())\n    {\n      my_error(ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED, MYF(0));\n      return true;\n    }\n    my_net_set_write_timeout(thd->get_protocol_classic()->get_net(),\n                             thd->variables.net_write_timeout);\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_write_timeout(\n       \"net_write_timeout\",\n       \"Number of seconds to wait for a block to be written to a connection \"\n       \"before aborting the write\",\n       SESSION_VAR(net_write_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WRITE_TIMEOUT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_write_timeout));\n\nstatic bool fix_net_retry_count(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n  {\n    // net_write_timeout is a specific property for the classic protocols\n    if (!thd->is_classic_protocol())\n    {\n      my_error(ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED, MYF(0));\n      return true;\n    }\n    thd->get_protocol_classic()->get_net()->retry_count=\n      thd->variables.net_retry_count;\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_retry_count(\n       \"net_retry_count\",\n       \"If a read on a communication port is interrupted, retry this \"\n       \"many times before giving up\",\n       SESSION_VAR(net_retry_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(MYSQLD_NET_RETRY_COUNT),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_retry_count));\n\nstatic Sys_var_mybool Sys_new_mode(\n       \"new\", \"Use very new possible \\\"unsafe\\\" functions\",\n       SESSION_VAR(new_mode), CMD_LINE(OPT_ARG, 'n'), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_old_mode(\n       \"old\", \"Use compatible behavior\",\n       READ_ONLY GLOBAL_VAR(old_mode), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\n#ifndef EMBEDDED_LIBRARY\nstatic Sys_var_mybool Sys_show_compatibility_56(\n       \"show_compatibility_56\",\n       \"SHOW commands / INFORMATION_SCHEMA tables compatible with MySQL 5.6\",\n       GLOBAL_VAR(show_compatibility_56), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n#endif /* EMBEDDED_LIBRARY */\n\nstatic Sys_var_mybool Sys_old_alter_table(\n       \"old_alter_table\", \"Use old, non-optimized alter table\",\n       SESSION_VAR(old_alter_table), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic bool old_passwords_check(sys_var *self  MY_ATTRIBUTE((unused)),\n                                THD *thd  MY_ATTRIBUTE((unused)),\n                                set_var *var)\n{\n  push_deprecated_warn_no_replacement(current_thd, \"old_passwords\");\n  /* 1 used to be old passwords */\n  return var->save_result.ulonglong_value == 1;\n}\n\nstatic Sys_var_uint Sys_old_passwords(\n       \"old_passwords\",\n       \"Determine which hash algorithm to use when generating passwords using \"\n       \"the PASSWORD() function\",\n       SESSION_VAR(old_passwords), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 2), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(old_passwords_check));\n\nstatic Sys_var_ulong Sys_open_files_limit(\n       \"open_files_limit\",\n       \"If this is not 0, then mysqld will use this value to reserve file \"\n       \"descriptors to use with setrlimit(). If this value is 0 then mysqld \"\n       \"will reserve max_connections*5 or max_connections + table_open_cache*2 \"\n       \"(whichever is larger) number of file descriptors\",\n       READ_ONLY GLOBAL_VAR(open_files_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, OS_FILE_LIMIT), DEFAULT(0), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL),\n       NULL,\n       /* open_files_limit is used as a sizing hint by the performance schema. */\n       sys_var::PARSE_EARLY);\n\n/// @todo change to enum\nstatic Sys_var_ulong Sys_optimizer_prune_level(\n       \"optimizer_prune_level\",\n       \"Controls the heuristic(s) applied during query optimization to prune \"\n       \"less-promising partial plans from the optimizer search space. \"\n       \"Meaning: 0 - do not apply any heuristic, thus perform exhaustive \"\n       \"search; 1 - prune plans based on number of retrieved rows\",\n       SESSION_VAR(optimizer_prune_level), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_optimizer_search_depth(\n       \"optimizer_search_depth\",\n       \"Maximum depth of search performed by the query optimizer. Values \"\n       \"larger than the number of relations in a query result in better \"\n       \"query plans, but take longer to compile a query. Values smaller \"\n       \"than the number of tables in a relation result in faster \"\n       \"optimization, but may produce very bad query plans. If set to 0, \"\n       \"the system will automatically pick a reasonable value\",\n       SESSION_VAR(optimizer_search_depth), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, MAX_TABLES+1), DEFAULT(MAX_TABLES+1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_range_optimizer_max_mem_size(\n      \"range_optimizer_max_mem_size\",\n      \"Maximum amount of memory used by the range optimizer \"\n      \"to allocate predicates during range analysis. \"\n      \"The larger the number, more memory may be consumed during \"\n      \"range analysis. If the value is too low to completed range \"\n      \"optimization of a query, index range scan will not be \"\n      \"considered for this query. A value of 0 means range optimizer \"\n      \"does not have any cap on memory. \",\n      SESSION_VAR(range_optimizer_max_mem_size),\n      CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, ULONG_MAX),\n      DEFAULT(8388608),\n      BLOCK_SIZE(1));\n\nstatic bool\nlimit_parser_max_mem_size(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_GLOBAL)\n    return false;\n  ulonglong val= var->save_result.ulonglong_value;\n  if (val > global_system_variables.parser_max_mem_size)\n  {\n    if (thd->security_context()->check_access(SUPER_ACL))\n      return false;\n    var->save_result.ulonglong_value=\n      global_system_variables.parser_max_mem_size;\n    return throw_bounds_warning(thd, \"parser_max_mem_size\",\n                                true, // fixed\n                                true, // is_unsigned\n                                val);\n  }\n  return false;\n}\n\n// Similar to what we do for the intptr typedef.\n#if SIZEOF_CHARP == SIZEOF_INT\nstatic unsigned int max_mem_sz = ~0;\n#elif SIZEOF_CHARP == SIZEOF_LONG\nstatic unsigned long max_mem_sz = ~0;\n#elif SIZEOF_CHARP == SIZEOF_LONG_LONG\nstatic unsigned long long max_mem_sz = ~0;\n#endif\n\n/*\n  Need at least 400Kb to get through bootstrap.\n  Need at least 8Mb to get through mtr check testcase, which does\n    SELECT * FROM INFORMATION_SCHEMA.VIEWS\n*/\nstatic Sys_var_ulonglong Sys_parser_max_mem_size(\n      \"parser_max_mem_size\",\n      \"Maximum amount of memory available to the parser\",\n      SESSION_VAR(parser_max_mem_size),\n      CMD_LINE(REQUIRED_ARG),\n      VALID_RANGE(10 * 1000 * 1000, max_mem_sz),\n      DEFAULT(max_mem_sz),\n      BLOCK_SIZE(1),\n      NO_MUTEX_GUARD, NOT_IN_BINLOG,\n      ON_CHECK(limit_parser_max_mem_size),\n      ON_UPDATE(NULL));\n\n/*\n  There is no call on Sys_var_integer::do_check() for 'set xxx=default';\n  The predefined default for parser_max_mem_size is \"infinite\".\n  Update it in case we have seen option maximum-parser-max-mem-size\n  Also update global_system_variables, so 'SELECT parser_max_mem_size'\n  reports correct data.\n*/\nexport void update_parser_max_mem_size()\n{\n  const ulonglong max_max= max_system_variables.parser_max_mem_size;\n  if (max_max == max_mem_sz)\n    return;\n  // In case parser-max-mem-size is also set:\n  const ulonglong new_val=\n    std::min(max_max, global_system_variables.parser_max_mem_size);\n  Sys_parser_max_mem_size.update_default(new_val);\n  global_system_variables.parser_max_mem_size= new_val;\n}\n\nstatic const char *optimizer_switch_names[]=\n{\n  \"index_merge\", \"index_merge_union\", \"index_merge_sort_union\",\n  \"index_merge_intersection\", \"engine_condition_pushdown\",\n  \"index_condition_pushdown\" , \"mrr\", \"mrr_cost_based\",\n  \"block_nested_loop\", \"batched_key_access\",\n  \"materialization\", \"semijoin\", \"loosescan\", \"firstmatch\", \"duplicateweedout\",\n  \"subquery_materialization_cost_based\",\n  \"use_index_extensions\", \"condition_fanout_filter\", \"derived_merge\",\n  \"default\", NullS\n};\nstatic Sys_var_flagset Sys_optimizer_switch(\n       \"optimizer_switch\",\n       \"optimizer_switch=option=val[,option=val...], where option is one of \"\n       \"{index_merge, index_merge_union, index_merge_sort_union, \"\n       \"index_merge_intersection, engine_condition_pushdown, \"\n       \"index_condition_pushdown, mrr, mrr_cost_based\"\n       \", materialization, semijoin, loosescan, firstmatch, duplicateweedout,\"\n       \" subquery_materialization_cost_based\"\n       \", block_nested_loop, batched_key_access, use_index_extensions,\"\n       \" condition_fanout_filter, derived_merge} and val is one of \"\n       \"{on, off, default}\",\n       SESSION_VAR(optimizer_switch), CMD_LINE(REQUIRED_ARG),\n       optimizer_switch_names, DEFAULT(OPTIMIZER_SWITCH_DEFAULT),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL));\n\nstatic Sys_var_mybool Sys_var_end_markers_in_json(\n       \"end_markers_in_json\",\n       \"In JSON output (\\\"EXPLAIN FORMAT=JSON\\\" and optimizer trace), \"\n       \"if variable is set to 1, repeats the structure's key (if it has one) \"\n       \"near the closing bracket\",\n       SESSION_VAR(end_markers_in_json), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\n#ifdef OPTIMIZER_TRACE\n\nstatic Sys_var_flagset Sys_optimizer_trace(\n       \"optimizer_trace\",\n       \"Controls tracing of the Optimizer:\"\n       \" optimizer_trace=option=val[,option=val...], where option is one of\"\n       \" {enabled, one_line}\"\n       \" and val is one of {on, default}\",\n       SESSION_VAR(optimizer_trace), CMD_LINE(REQUIRED_ARG),\n       Opt_trace_context::flag_names,\n       DEFAULT(Opt_trace_context::FLAG_DEFAULT));\n// @see set_var::is_var_optimizer_trace()\nexport sys_var *Sys_optimizer_trace_ptr= &Sys_optimizer_trace;\n\n/**\n  Note how \"misc\" is not here: it is not accessible to the user; disabling\n  \"misc\" would disable the top object, which would make an empty trace.\n*/\nstatic Sys_var_flagset Sys_optimizer_trace_features(\n       \"optimizer_trace_features\",\n       \"Enables/disables tracing of selected features of the Optimizer:\"\n       \" optimizer_trace_features=option=val[,option=val...], where option is one of\"\n       \" {greedy_search, range_optimizer, dynamic_range, repeated_subselect}\"\n       \" and val is one of {on, off, default}\",\n       SESSION_VAR(optimizer_trace_features), CMD_LINE(REQUIRED_ARG),\n       Opt_trace_context::feature_names,\n       DEFAULT(Opt_trace_context::default_features));\n\n/** Delete all old optimizer traces */\nstatic bool optimizer_trace_update(sys_var *self, THD *thd,\n                                   enum_var_type type)\n{\n  thd->opt_trace.reset();\n  return false;\n}\n\nstatic Sys_var_long Sys_optimizer_trace_offset(\n       \"optimizer_trace_offset\",\n       \"Offset of first optimizer trace to show; see manual\",\n       SESSION_VAR(optimizer_trace_offset), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(LONG_MIN, LONG_MAX), DEFAULT(-1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(optimizer_trace_update));\n\nstatic Sys_var_long Sys_optimizer_trace_limit(\n       \"optimizer_trace_limit\",\n       \"Maximum number of shown optimizer traces\",\n       SESSION_VAR(optimizer_trace_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, LONG_MAX), DEFAULT(1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(optimizer_trace_update));\n\nstatic Sys_var_ulong Sys_optimizer_trace_max_mem_size(\n       \"optimizer_trace_max_mem_size\",\n       \"Maximum allowed cumulated size of stored optimizer traces\",\n       SESSION_VAR(optimizer_trace_max_mem_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(1024*16), BLOCK_SIZE(1));\n\n#endif\n\nstatic Sys_var_charptr Sys_pid_file(\n       \"pid_file\", \"Pid file used by safe_mysqld\",\n       READ_ONLY GLOBAL_VAR(pidfile_name_ptr), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_plugin_dir(\n       \"plugin_dir\", \"Directory for plugins\",\n       READ_ONLY GLOBAL_VAR(opt_plugin_dir_ptr), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_port(\n       \"port\",\n       \"Port number to use for connection or 0 to default to, \"\n       \"my.cnf, $MYSQL_TCP_PORT, \"\n#if MYSQL_PORT_DEFAULT == 0\n       \"/etc/services, \"\n#endif\n       \"built-in default (\" STRINGIFY_ARG(MYSQL_PORT) \"), whatever comes first\",\n       READ_ONLY GLOBAL_VAR(mysqld_port), CMD_LINE(REQUIRED_ARG, 'P'),\n       VALID_RANGE(0, 65535), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_preload_buff_size(\n       \"preload_buffer_size\",\n       \"The size of the buffer that is allocated when preloading indexes\",\n       SESSION_VAR(preload_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024*1024), DEFAULT(32768), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_protocol_version(\n       \"protocol_version\",\n       \"The version of the client/server protocol used by the MySQL server\",\n       READ_ONLY GLOBAL_VAR(protocol_version), NO_CMD_LINE,\n       VALID_RANGE(0, ~0), DEFAULT(PROTOCOL_VERSION), BLOCK_SIZE(1));\n\nstatic Sys_var_proxy_user Sys_proxy_user(\n       \"proxy_user\", \"The proxy user account name used when logging in\",\n       IN_SYSTEM_CHARSET);\n\nstatic Sys_var_external_user Sys_external_user(\n       \"external_user\", \"The external user account used when logging in\",\n       IN_SYSTEM_CHARSET);\n\nstatic Sys_var_ulong Sys_read_buff_size(\n       \"read_buffer_size\",\n       \"Each thread that does a sequential scan allocates a buffer of \"\n       \"this size for each table it scans. If you do many sequential scans, \"\n       \"you may want to increase this value\",\n       SESSION_VAR(read_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE*2, INT_MAX32), DEFAULT(128*1024),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic bool check_read_only(sys_var *self, THD *thd, set_var *var)\n{\n  /* Prevent self dead-lock */\n  if (thd->locked_tables_mode || thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));\n    return true;\n  }\n  return false;\n}\n\n#if !defined(EMBEDDED_LIBRARY)\n\nstatic bool check_require_secure_transport(sys_var *self, THD *thd, set_var *var)\n{\n\n#if !defined (_WIN32)\n  /*\n    always allow require_secure_transport to be enabled on\n    Linux, as socket is secure.\n  */\n  return false;\n#else\n  /*\n    check whether SSL or shared memory transports are enabled before\n    turning require_secure_transport ON, otherwise no connections will\n    be allowed on Windows.\n  */\n\n  if (!var->save_result.ulonglong_value)\n    return false;\n  if ((have_ssl == SHOW_OPTION_YES) || opt_enable_shared_memory)\n    return false;\n  /* reject if SSL and shared memory are both disabled: */\n  my_error(ER_NO_SECURE_TRANSPORTS_CONFIGURED, MYF(0));\n  return true;\n\n#endif\n}\n\n#endif\n\nstatic bool fix_read_only(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool result= true;\n  my_bool new_read_only= read_only; // make a copy before releasing a mutex\n  DBUG_ENTER(\"sys_var_opt_readonly::update\");\n\n  if (read_only == FALSE || read_only == opt_readonly)\n  {\n    if (opt_super_readonly && !read_only)\n    {\n      opt_super_readonly= FALSE;\n      super_read_only= FALSE;\n    }\n    opt_readonly= read_only;\n    DBUG_RETURN(false);\n  }\n\n  if (check_read_only(self, thd, 0)) // just in case\n    goto end;\n\n  if (thd->global_read_lock.is_acquired())\n  {\n    /*\n      This connection already holds the global read lock.\n      This can be the case with:\n      - FLUSH TABLES WITH READ LOCK\n      - SET GLOBAL READ_ONLY = 1\n    */\n    if (opt_super_readonly && !read_only)\n    {\n      opt_super_readonly= FALSE;\n      super_read_only= FALSE;\n    }\n    opt_readonly= read_only;\n    DBUG_RETURN(false);\n  }\n\n  /*\n    READ_ONLY=1 prevents write locks from being taken on tables and\n    blocks transactions from committing. We therefore should make sure\n    that no such events occur while setting the read_only variable.\n    This is a 2 step process:\n    [1] lock_global_read_lock()\n      Prevents connections from obtaining new write locks on\n      tables. Note that we can still have active rw transactions.\n    [2] make_global_read_lock_block_commit()\n      Prevents transactions from committing.\n  */\n\n  read_only= opt_readonly;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (thd->global_read_lock.lock_global_read_lock(thd))\n    goto end_with_mutex_unlock;\n\n  if ((result= thd->global_read_lock.make_global_read_lock_block_commit(thd)))\n    goto end_with_read_lock;\n\n  /* Change the opt_readonly system variable, safe because the lock is held */\n  opt_readonly= new_read_only;\n\n  result= false;\n\n end_with_read_lock:\n  /* Release the lock */\n  thd->global_read_lock.unlock_global_read_lock(thd);\n end_with_mutex_unlock:\n  mysql_mutex_lock(&LOCK_global_system_variables);\n end:\n  read_only= opt_readonly;\n  DBUG_RETURN(result);\n}\n\nstatic bool fix_super_read_only(sys_var *self, THD *thd, enum_var_type type)\n{\n  DBUG_ENTER(\"sys_var_opt_super_readonly::update\");\n\n  /* return if no changes: */\n  if (super_read_only == opt_super_readonly)\n    DBUG_RETURN(false);\n\n  /* return immediately if turning super_read_only OFF: */\n  if (super_read_only == FALSE)\n  {\n    opt_super_readonly= FALSE;\n    DBUG_RETURN(false);\n  }\n  bool result= true;\n  my_bool new_super_read_only = super_read_only; /* make a copy before releasing a mutex */\n\n  /* set read_only to ON if it is OFF, letting fix_read_only()\n     handle its own locking needs\n  */\n  if (!opt_readonly)\n  {\n    read_only= TRUE;\n    if ((result = fix_read_only(NULL, thd, type)))\n      goto end;\n  }\n\n  /* if we already have global read lock, set super_read_only\n     and return immediately:\n  */\n  if (thd->global_read_lock.is_acquired())\n  {\n    opt_super_readonly= super_read_only;\n    DBUG_RETURN(false);\n  }\n\n  /* now we're turning ON super_read_only: */\n  super_read_only = opt_super_readonly;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (thd->global_read_lock.lock_global_read_lock(thd))\n    goto end_with_mutex_unlock;\n\n  if ((result = thd->global_read_lock.make_global_read_lock_block_commit(thd)))\n    goto end_with_read_lock;\n  opt_super_readonly= new_super_read_only;\n  result= false;\n\n  end_with_read_lock:\n    /* Release the lock */\n    thd->global_read_lock.unlock_global_read_lock(thd);\n  end_with_mutex_unlock:\n    mysql_mutex_lock(&LOCK_global_system_variables);\n  end:\n    super_read_only= opt_super_readonly;\n    DBUG_RETURN(result);\n}\n\n#if !defined(EMBEDDED_LIBRARY)\n\nstatic Sys_var_mybool Sys_require_secure_transport(\n  \"require_secure_transport\",\n  \"When this option is enabled, connections attempted using insecure \"\n  \"transport will be rejected.  Secure transports are SSL/TLS, \"\n  \"Unix socket or Shared Memory (on Windows).\",\n  GLOBAL_VAR(opt_require_secure_transport),\n  CMD_LINE(OPT_ARG),\n  DEFAULT(FALSE),\n  NO_MUTEX_GUARD, NOT_IN_BINLOG,\n  ON_CHECK(check_require_secure_transport), ON_UPDATE(0));\n\n#endif\n\n/**\n  The read_only boolean is always equal to the opt_readonly boolean except\n  during fix_read_only(); when that function is entered, opt_readonly is\n  the pre-update value and read_only is the post-update value.\n  fix_read_only() compares them and runs needed operations for the\n  transition (especially when transitioning from false to true) and\n  synchronizes both booleans in the end.\n*/\nstatic Sys_var_mybool Sys_readonly(\n       \"read_only\",\n       \"Make all non-temporary tables read-only, with the exception for \"\n       \"replication (slave) threads and users with the SUPER privilege\",\n       GLOBAL_VAR(read_only), CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_read_only), ON_UPDATE(fix_read_only));\n\n/**\nSetting super_read_only to ON triggers read_only to also be set to ON.\n*/\nstatic Sys_var_mybool Sys_super_readonly(\n  \"super_read_only\",\n  \"Make all non-temporary tables read-only, with the exception for \"\n  \"replication (slave) threads.  Users with the SUPER privilege are \"\n  \"affected, unlike read_only.  Setting super_read_only to ON \"\n  \"also sets read_only to ON.\",\n  GLOBAL_VAR(super_read_only), CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n  NO_MUTEX_GUARD, NOT_IN_BINLOG,\n  ON_CHECK(0), ON_UPDATE(fix_super_read_only));\n\n\n\n// Small lower limit to be able to test MRR\nstatic Sys_var_ulong Sys_read_rnd_buff_size(\n       \"read_rnd_buffer_size\",\n       \"When reading rows in sorted order after a sort, the rows are read \"\n       \"through this buffer to avoid a disk seeks\",\n       SESSION_VAR(read_rnd_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, INT_MAX32), DEFAULT(256*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_div_precincrement(\n       \"div_precision_increment\", \"Precision of the result of '/' \"\n       \"operator will be increased on that value\",\n       SESSION_VAR(div_precincrement), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, DECIMAL_MAX_SCALE), DEFAULT(4), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_eq_range_index_dive_limit(\n       \"eq_range_index_dive_limit\",\n       \"The optimizer will use existing index statistics instead of \"\n       \"doing index dives for equality ranges if the number of equality \"\n       \"ranges for the index is larger than or equal to this number. \"\n       \"If set to 0, index dives are always used.\",\n       SESSION_VAR(eq_range_index_dive_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(200), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_range_alloc_block_size(\n       \"range_alloc_block_size\",\n       \"Allocation block size for storing ranges during optimization\",\n       SESSION_VAR(range_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(RANGE_ALLOC_BLOCK_SIZE, UINT32_MAX),\n       DEFAULT(RANGE_ALLOC_BLOCK_SIZE), BLOCK_SIZE(1024));\n\nstatic Sys_var_ulong Sys_multi_range_count(\n       \"multi_range_count\",\n       \"Number of key ranges to request at once. \"\n       \"This variable has no effect, and is deprecated. \"\n       \"It will be removed in a future release.\",\n       SESSION_VAR(multi_range_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(256), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic bool fix_thd_mem_root(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    reset_root_defaults(thd->mem_root,\n                        thd->variables.query_alloc_block_size,\n                        thd->variables.query_prealloc_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_query_alloc_block_size(\n       \"query_alloc_block_size\",\n       \"Allocation block size for query parsing and execution\",\n       SESSION_VAR(query_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, UINT_MAX32), DEFAULT(QUERY_ALLOC_BLOCK_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_thd_mem_root));\n\nstatic Sys_var_ulong Sys_query_prealloc_size(\n       \"query_prealloc_size\",\n       \"Persistent buffer for query parsing and execution\",\n       SESSION_VAR(query_prealloc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(QUERY_ALLOC_PREALLOC_SIZE, ULONG_MAX),\n       DEFAULT(QUERY_ALLOC_PREALLOC_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_thd_mem_root));\n\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\nstatic Sys_var_mybool Sys_shared_memory(\n       \"shared_memory\", \"Enable the shared memory\",\n       READ_ONLY GLOBAL_VAR(opt_enable_shared_memory), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_shared_memory_base_name(\n       \"shared_memory_base_name\", \"Base name of shared memory\",\n       READ_ONLY GLOBAL_VAR(shared_memory_base_name), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n#endif\n\n// this has to be NO_CMD_LINE as the command-line option has a different name\nstatic Sys_var_mybool Sys_skip_external_locking(\n       \"skip_external_locking\", \"Don't use system (external) locking\",\n       READ_ONLY GLOBAL_VAR(my_disable_locking), NO_CMD_LINE, DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_skip_networking(\n       \"skip_networking\", \"Don't allow connection with TCP/IP\",\n       READ_ONLY GLOBAL_VAR(opt_disable_networking), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_skip_name_resolve(\n       \"skip_name_resolve\",\n       \"Don't resolve hostnames. All hostnames are IP's or 'localhost'.\",\n       READ_ONLY GLOBAL_VAR(opt_skip_name_resolve),\n       CMD_LINE(OPT_ARG, OPT_SKIP_RESOLVE),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_skip_show_database(\n       \"skip_show_database\", \"Don't allow 'SHOW DATABASE' commands\",\n       READ_ONLY GLOBAL_VAR(opt_skip_show_db), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_socket(\n       \"socket\", \"Socket file to use for connection\",\n       READ_ONLY GLOBAL_VAR(mysqld_unix_port), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulong Sys_thread_stack(\n       \"thread_stack\", \"The stack size for each thread\",\n       READ_ONLY GLOBAL_VAR(my_thread_stack_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(128*1024, ULONG_MAX), DEFAULT(DEFAULT_THREAD_STACK),\n       BLOCK_SIZE(1024));\n\nstatic Sys_var_charptr Sys_tmpdir(\n       \"tmpdir\", \"Path for temporary files. Several paths may \"\n       \"be specified, separated by a \"\n#if defined(_WIN32)\n       \"semicolon (;)\"\n#else\n       \"colon (:)\"\n#endif\n       \", in this case they are used in a round-robin fashion\",\n       READ_ONLY GLOBAL_VAR(opt_mysql_tmpdir), CMD_LINE(REQUIRED_ARG, 't'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool fix_trans_mem_root(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    thd->get_transaction()->init_mem_root_defaults(\n        thd->variables.trans_alloc_block_size,\n        thd->variables.trans_prealloc_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_trans_alloc_block_size(\n       \"transaction_alloc_block_size\",\n       \"Allocation block size for transactions to be stored in binary log\",\n       SESSION_VAR(trans_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 128 * 1024), DEFAULT(QUERY_ALLOC_BLOCK_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_trans_mem_root));\n\nstatic Sys_var_ulong Sys_trans_prealloc_size(\n       \"transaction_prealloc_size\",\n       \"Persistent buffer for transactions to be stored in binary log\",\n       SESSION_VAR(trans_prealloc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 128 * 1024), DEFAULT(TRANS_ALLOC_PREALLOC_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_trans_mem_root));\n\n#ifndef EMBEDDED_LIBRARY\nstatic const char *thread_handling_names[]=\n{\n  \"one-thread-per-connection\", \"no-threads\", \"loaded-dynamically\",\n  0\n};\nstatic Sys_var_enum Sys_thread_handling(\n       \"thread_handling\",\n       \"Define threads usage for handling queries, one of \"\n       \"one-thread-per-connection, no-threads, loaded-dynamically\"\n       , READ_ONLY GLOBAL_VAR(Connection_handler_manager::thread_handling),\n       CMD_LINE(REQUIRED_ARG), thread_handling_names, DEFAULT(0));\n#endif // !EMBEDDED_LIBRARY\n\nstatic bool fix_query_cache_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  ulong new_cache_size= query_cache.resize(query_cache_size);\n  /*\n     Note: query_cache_size is a global variable reflecting the\n     requested cache size. See also query_cache_size_arg\n  */\n  if (query_cache_size != new_cache_size)\n    push_warning_printf(current_thd, Sql_condition::SL_WARNING,\n                        ER_WARN_QC_RESIZE, ER(ER_WARN_QC_RESIZE),\n                        query_cache_size, new_cache_size);\n\n  query_cache_size= new_cache_size;\n  return false;\n}\nstatic Sys_var_ulong Sys_query_cache_size(\n       \"query_cache_size\",\n       \"The memory allocated to store results from old queries. \"\n       \"This variable is deprecated and will be removed in a future release.\",\n       GLOBAL_VAR(query_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(1024U*1024U), BLOCK_SIZE(1024),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_query_cache_size), DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_query_cache_limit(\n       \"query_cache_limit\",\n       \"Don't cache results that are bigger than this. \"\n       \"This variable is deprecated and will be removed in a future release.\",\n       GLOBAL_VAR(query_cache.query_cache_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(1024*1024), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL),\n       DEPRECATED(\"\"));\n\nstatic bool fix_qcache_min_res_unit(sys_var *self, THD *thd, enum_var_type type)\n{\n  query_cache_min_res_unit=\n    query_cache.set_min_res_unit(query_cache_min_res_unit);\n  return false;\n}\nstatic Sys_var_ulong Sys_query_cache_min_res_unit(\n       \"query_cache_min_res_unit\",\n       \"The minimum size for blocks allocated by the query cache. \"\n       \"This variable is deprecated and will be removed in a future release.\",\n       GLOBAL_VAR(query_cache_min_res_unit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(QUERY_CACHE_MIN_RESULT_DATA_SIZE),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_qcache_min_res_unit), DEPRECATED(\"\"));\n\nstatic const char *query_cache_type_names[]= { \"OFF\", \"ON\", \"DEMAND\", 0 };\nstatic bool check_query_cache_type(sys_var *self, THD *thd, set_var *var)\n{\n  /*\n   Setting it to 0 (or OFF) is always OK, even if the query cache\n   is disabled.\n  */\n  if (var->save_result.ulonglong_value == 0)\n    return false;\n  else if (query_cache.is_disabled())\n  {\n    my_error(ER_QUERY_CACHE_DISABLED, MYF(0));\n    return true;\n  }\n  return false;\n}\nstatic Sys_var_enum Sys_query_cache_type(\n       \"query_cache_type\",\n       \"OFF = Don't cache or retrieve results. ON = Cache all results \"\n       \"except SELECT SQL_NO_CACHE ... queries. DEMAND = Cache only \"\n       \"SELECT SQL_CACHE ... queries. \"\n       \"This variable is deprecated and will be removed in a future release.\",\n       SESSION_VAR(query_cache_type), CMD_LINE(REQUIRED_ARG),\n       query_cache_type_names, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_query_cache_type), ON_UPDATE(NULL), DEPRECATED(\"\"));\n\nstatic Sys_var_mybool Sys_query_cache_wlock_invalidate(\n       \"query_cache_wlock_invalidate\",\n       \"Invalidate queries in query cache on LOCK for write. \"\n       \"This variable is deprecated and will be removed in a future release.\",\n       SESSION_VAR(query_cache_wlock_invalidate), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(NULL), DEPRECATED(\"\"));\n\nstatic bool\non_check_opt_secure_auth(sys_var *self, THD *thd, set_var *var)\n{\n  push_deprecated_warn_no_replacement(thd, \"--secure-auth\");\n  return (!var->save_result.ulonglong_value);\n}\n\nstatic Sys_var_mybool Sys_secure_auth(\n       \"secure_auth\",\n       \"Disallow authentication for accounts that have old (pre-4.1) \"\n       \"passwords. Deprecated. Always TRUE.\",\n       GLOBAL_VAR(opt_secure_auth), CMD_LINE(OPT_ARG, OPT_SECURE_AUTH),\n       DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(on_check_opt_secure_auth)\n       );\n\nstatic Sys_var_charptr Sys_secure_file_priv(\n       \"secure_file_priv\",\n       \"Limit LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE() to files \"\n       \"within specified directory\",\n       READ_ONLY GLOBAL_VAR(opt_secure_file_priv),\n#ifndef EMBEDDED_LIBRARY\n       CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(DEFAULT_SECURE_FILE_PRIV_DIR));\n#else\n       CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(DEFAULT_SECURE_FILE_PRIV_EMBEDDED_DIR));\n#endif\n\nstatic bool fix_server_id(sys_var *self, THD *thd, enum_var_type type)\n{\n  // server_id is 'MYSQL_PLUGIN_IMPORT ulong'\n  // So we cast here, rather than change its type.\n  server_id_supplied = 1;\n  thd->server_id= static_cast<uint32>(server_id);\n  return false;\n}\nstatic Sys_var_ulong Sys_server_id(\n       \"server_id\",\n       \"Uniquely identifies the server instance in the community of \"\n       \"replication partners\",\n       GLOBAL_VAR(server_id), CMD_LINE(REQUIRED_ARG, OPT_SERVER_ID),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_server_id));\n\nstatic Sys_var_charptr Sys_server_uuid(\n       \"server_uuid\",\n       \"Uniquely identifies the server instance in the universe\",\n       READ_ONLY GLOBAL_VAR(server_uuid_ptr),\n       NO_CMD_LINE, IN_FS_CHARSET, DEFAULT(server_uuid));\n\nstatic Sys_var_uint Sys_server_id_bits(\n       \"server_id_bits\",\n       \"Set number of significant bits in server-id\",\n       GLOBAL_VAR(opt_server_id_bits), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 32), DEFAULT(32), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_slave_compressed_protocol(\n       \"slave_compressed_protocol\",\n       \"Use compression on master/slave protocol\",\n       GLOBAL_VAR(opt_slave_compressed_protocol), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\n#ifdef HAVE_REPLICATION\nstatic const char *slave_exec_mode_names[]=\n       {\"STRICT\", \"IDEMPOTENT\", 0};\nstatic Sys_var_enum Slave_exec_mode(\n       \"slave_exec_mode\",\n       \"Modes for how replication events should be executed. Legal values \"\n       \"are STRICT (default) and IDEMPOTENT. In IDEMPOTENT mode, \"\n       \"replication will not stop for operations that are idempotent. \"\n       \"In STRICT mode, replication will stop on any unexpected difference \"\n       \"between the master and the slave\",\n       GLOBAL_VAR(slave_exec_mode_options), CMD_LINE(REQUIRED_ARG),\n       slave_exec_mode_names, DEFAULT(RBR_EXEC_MODE_STRICT));\n\nconst char *slave_type_conversions_name[]=\n       {\"ALL_LOSSY\", \"ALL_NON_LOSSY\", \"ALL_UNSIGNED\", \"ALL_SIGNED\", 0};\nstatic Sys_var_set Slave_type_conversions(\n       \"slave_type_conversions\",\n       \"Set of slave type conversions that are enabled. Legal values are:\"\n       \" ALL_LOSSY to enable lossy conversions,\"\n       \" ALL_NON_LOSSY to enable non-lossy conversions,\"\n       \" ALL_UNSIGNED to treat all integer column type data to be unsigned values, and\"\n       \" ALL_SIGNED to treat all integer column type data to be signed values.\" \n       \" Default treatment is ALL_SIGNED. If ALL_SIGNED and ALL_UNSIGNED both are\"\n       \" specified, ALL_SIGNED will take higher priority than ALL_UNSIGNED.\"\n       \" If the variable is assigned the empty set, no conversions are\"\n       \" allowed and it is expected that the types match exactly.\",\n       GLOBAL_VAR(slave_type_conversions_options), CMD_LINE(REQUIRED_ARG),\n       slave_type_conversions_name,\n       DEFAULT(0));\n\nstatic Sys_var_mybool Sys_slave_sql_verify_checksum(\n       \"slave_sql_verify_checksum\",\n       \"Force checksum verification of replication events after reading them \"\n       \"from relay log. Note: Events are always checksum-verified by slave on \"\n       \"receiving them from the network before writing them to the relay \"\n       \"log. Enabled by default.\",\n       GLOBAL_VAR(opt_slave_sql_verify_checksum), CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic bool check_not_null_not_empty(sys_var *self, THD *thd, set_var *var)\n{\n  String str, *res;\n  /* null value is not allowed */\n  if (check_not_null(self, thd, var))\n    return true;\n\n  /** empty value ('') is not allowed */\n  res= var->value? var->value->val_str(&str) : NULL;\n  if (res && res->is_empty())\n    return true;\n\n  return false;\n}\n\nstatic bool check_slave_stopped(sys_var *self, THD *thd, set_var *var)\n{\n  bool result= false;\n  Master_info *mi= 0;\n\n  if (check_not_null_not_empty(self, thd, var))\n    return true;\n\n  channel_map.wrlock();\n\n  for (mi_map::iterator it= channel_map.begin(); it!= channel_map.end(); it++)\n  {\n    mi= it->second;\n    if (mi)\n    {\n      mysql_mutex_lock(&mi->rli->run_lock);\n      if (mi->rli->slave_running)\n      {\n        my_error(ER_SLAVE_SQL_THREAD_MUST_STOP, MYF(0));\n        result= true;\n      }\n      mysql_mutex_unlock(&mi->rli->run_lock);\n    }\n  }\n  channel_map.unlock();\n  return result;\n}\n\nstatic const char *slave_rows_search_algorithms_names[]= {\"TABLE_SCAN\", \"INDEX_SCAN\", \"HASH_SCAN\", 0};\nstatic Sys_var_set Slave_rows_search_algorithms(\n       \"slave_rows_search_algorithms\", \n       \"Set of searching algorithms that the slave will use while \"\n       \"searching for records from the storage engine to either \"\n       \"updated or deleted them. Possible values are: INDEX_SCAN, \"\n       \"TABLE_SCAN and HASH_SCAN. Any combination is allowed, and \"\n       \"the slave will always pick the most suitable algorithm for \"\n       \"any given scenario. \"\n       \"(Default: INDEX_SCAN, TABLE_SCAN).\",\n       GLOBAL_VAR(slave_rows_search_algorithms_options), CMD_LINE(REQUIRED_ARG),\n       slave_rows_search_algorithms_names,\n       DEFAULT(SLAVE_ROWS_INDEX_SCAN | SLAVE_ROWS_TABLE_SCAN),  NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_not_null_not_empty), ON_UPDATE(NULL));\n\nstatic const char *mts_parallel_type_names[]= {\"DATABASE\", \"LOGICAL_CLOCK\", 0};\nstatic Sys_var_enum Mts_parallel_type(\n       \"slave_parallel_type\",\n       \"Specifies if the slave will use database partitioning \"\n       \"or information from master to parallelize transactions.\"\n       \"(Default: DATABASE).\",\n       GLOBAL_VAR(mts_parallel_option), CMD_LINE(REQUIRED_ARG),\n       mts_parallel_type_names,\n       DEFAULT(MTS_PARALLEL_TYPE_DB_NAME),  NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_slave_stopped),\n       ON_UPDATE(NULL));\n\nstatic Sys_var_mybool Sys_slave_preserve_commit_order(\n       \"slave_preserve_commit_order\",\n       \"Force slave workers to make commits in the same order as on the master. \"\n       \"Disabled by default.\",\n       GLOBAL_VAR(opt_slave_preserve_commit_order), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_slave_stopped),\n       ON_UPDATE(NULL));\n#endif\n\nbool Sys_var_enum_binlog_checksum::global_update(THD *thd, set_var *var)\n{\n  bool check_purge= false;\n\n  mysql_mutex_lock(mysql_bin_log.get_log_lock());\n  if(mysql_bin_log.is_open())\n  {\n    bool alg_changed=\n      (binlog_checksum_options != (uint) var->save_result.ulonglong_value);\n    if (alg_changed)\n      mysql_bin_log.checksum_alg_reset= (uint8) var->save_result.ulonglong_value;\n    mysql_bin_log.rotate(true, &check_purge);\n    if (alg_changed)\n      mysql_bin_log.checksum_alg_reset= binary_log::BINLOG_CHECKSUM_ALG_UNDEF; // done\n  }\n  else\n  {\n    binlog_checksum_options=\n      static_cast<ulong>(var->save_result.ulonglong_value);\n  }\n  DBUG_ASSERT(binlog_checksum_options == var->save_result.ulonglong_value);\n  DBUG_ASSERT(mysql_bin_log.checksum_alg_reset ==\n              binary_log::BINLOG_CHECKSUM_ALG_UNDEF);\n  mysql_mutex_unlock(mysql_bin_log.get_log_lock());\n  \n  if (check_purge)\n    mysql_bin_log.purge();\n\n  return 0;\n}\n\nstatic Sys_var_enum_binlog_checksum Binlog_checksum_enum(\n       \"binlog_checksum\", \"Type of BINLOG_CHECKSUM_ALG. Include checksum for \"\n       \"log events in the binary log. Possible values are NONE and CRC32; \"\n       \"default is CRC32.\",\n       GLOBAL_VAR(binlog_checksum_options), CMD_LINE(REQUIRED_ARG),\n       binlog_checksum_type_names, DEFAULT(binary_log::BINLOG_CHECKSUM_ALG_CRC32),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_outside_trx));\n\nstatic Sys_var_mybool Sys_master_verify_checksum(\n       \"master_verify_checksum\",\n       \"Force checksum verification of logged events in binary log before \"\n       \"sending them to slaves or printing them in output of SHOW BINLOG EVENTS. \"\n       \"Disabled by default.\",\n       GLOBAL_VAR(opt_master_verify_checksum), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_slow_launch_time(\n       \"slow_launch_time\",\n       \"If creating the thread takes longer than this value (in seconds), \"\n       \"the Slow_launch_threads counter will be incremented\",\n       GLOBAL_VAR(slow_launch_time), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(2), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_sort_buffer(\n       \"sort_buffer_size\",\n       \"Each thread that needs to do a sort allocates a buffer of this size\",\n       SESSION_VAR(sortbuff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(MIN_SORT_MEMORY, ULONG_MAX), DEFAULT(DEFAULT_SORT_MEMORY),\n       BLOCK_SIZE(1));\n\n/**\n  Check sql modes strict_mode, 'NO_ZERO_DATE', 'NO_ZERO_IN_DATE' and\n  'ERROR_FOR_DIVISION_BY_ZERO' are used together. If only subset of it\n  is set then warning is reported.\n\n  @param sql_mode sql mode.\n*/\nstatic void check_sub_modes_of_strict_mode(sql_mode_t &sql_mode, THD *thd)\n{\n  const sql_mode_t strict_modes= (MODE_STRICT_TRANS_TABLES |\n                                  MODE_STRICT_ALL_TABLES);\n\n  const sql_mode_t new_strict_submodes= (MODE_NO_ZERO_IN_DATE |\n                                         MODE_NO_ZERO_DATE |\n                                         MODE_ERROR_FOR_DIVISION_BY_ZERO);\n\n  const sql_mode_t strict_modes_set= (sql_mode & strict_modes);\n  const sql_mode_t new_strict_submodes_set= (sql_mode & new_strict_submodes);\n\n  if (((strict_modes_set | new_strict_submodes_set) !=0) &&\n      ((new_strict_submodes_set != new_strict_submodes) ||\n       (strict_modes_set == 0)))\n  {\n    if (thd)\n      push_warning(thd, Sql_condition::SL_WARNING,\n                               ER_SQL_MODE_MERGED,\n                               ER_THD(thd, ER_SQL_MODE_MERGED));\n    else\n      sql_print_warning(\"'NO_ZERO_DATE', 'NO_ZERO_IN_DATE' and \"\n                        \"'ERROR_FOR_DIVISION_BY_ZERO' sql modes should be used \"\n                        \"with strict mode. They will be merged with strict mode \"\n                        \"in a future release.\");\n  }\n}\n\nexport sql_mode_t expand_sql_mode(sql_mode_t sql_mode, THD *thd)\n{\n  if (sql_mode & MODE_ANSI)\n  {\n    /*\n      Note that we dont set\n      MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS | MODE_NO_FIELD_OPTIONS\n      to allow one to get full use of MySQL in this mode.\n    */\n    sql_mode|= (MODE_REAL_AS_FLOAT | MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE | MODE_ONLY_FULL_GROUP_BY);\n  }\n  if (sql_mode & MODE_ORACLE)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS | MODE_NO_AUTO_CREATE_USER);\n  if (sql_mode & MODE_MSSQL)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_POSTGRESQL)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_DB2)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_MAXDB)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS | MODE_NO_AUTO_CREATE_USER);\n  if (sql_mode & MODE_MYSQL40)\n    sql_mode|= MODE_HIGH_NOT_PRECEDENCE;\n  if (sql_mode & MODE_MYSQL323)\n    sql_mode|= MODE_HIGH_NOT_PRECEDENCE;\n  if (sql_mode & MODE_TRADITIONAL)\n    sql_mode|= (MODE_STRICT_TRANS_TABLES | MODE_STRICT_ALL_TABLES |\n                MODE_NO_ZERO_IN_DATE | MODE_NO_ZERO_DATE |\n                MODE_ERROR_FOR_DIVISION_BY_ZERO | MODE_NO_AUTO_CREATE_USER |\n                MODE_NO_ENGINE_SUBSTITUTION);\n\n  check_sub_modes_of_strict_mode(sql_mode, thd);\n  return sql_mode;\n}\nstatic bool check_sql_mode(sys_var *self, THD *thd, set_var *var)\n{\n  var->save_result.ulonglong_value=\n    expand_sql_mode(var->save_result.ulonglong_value, thd);\n\n  /* Warning displayed only if the non default sql_mode is specified. */\n  if (var->value)\n  {\n    /* Check if the NO_AUTO_CREATE_USER flag has been swapped. */\n    if ((thd->variables.sql_mode ^ var->save_result.ulonglong_value) &\n        MODE_NO_AUTO_CREATE_USER)\n    {\n      push_warning_printf(thd, Sql_condition::SL_WARNING,\n                          ER_WARN_DEPRECATED_SQLMODE,\n                          ER_THD(thd, ER_WARN_DEPRECATED_SQLMODE),\n                          \"NO_AUTO_CREATE_USER\");\n    }\n  }\n\n  return false;\n}\nstatic bool fix_sql_mode(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n  {\n    /* Update thd->server_status */\n    if (thd->variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES)\n      thd->server_status|= SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n    else\n      thd->server_status&= ~SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n  }\n  return false;\n}\n/*\n  WARNING: When adding new SQL modes don't forget to update the\n  tables definitions that stores it's value (ie: mysql.event, mysql.proc)\n*/\nstatic const char *sql_mode_names[]=\n{\n  \"REAL_AS_FLOAT\", \"PIPES_AS_CONCAT\", \"ANSI_QUOTES\", \"IGNORE_SPACE\", \",\",\n  \"ONLY_FULL_GROUP_BY\", \"NO_UNSIGNED_SUBTRACTION\", \"NO_DIR_IN_CREATE\",\n  \"POSTGRESQL\", \"ORACLE\", \"MSSQL\", \"DB2\", \"MAXDB\", \"NO_KEY_OPTIONS\",\n  \"NO_TABLE_OPTIONS\", \"NO_FIELD_OPTIONS\", \"MYSQL323\", \"MYSQL40\", \"ANSI\",\n  \"NO_AUTO_VALUE_ON_ZERO\", \"NO_BACKSLASH_ESCAPES\", \"STRICT_TRANS_TABLES\",\n  \"STRICT_ALL_TABLES\", \"NO_ZERO_IN_DATE\", \"NO_ZERO_DATE\",\n  \"ALLOW_INVALID_DATES\", \"ERROR_FOR_DIVISION_BY_ZERO\", \"TRADITIONAL\",\n  \"NO_AUTO_CREATE_USER\", \"HIGH_NOT_PRECEDENCE\", \"NO_ENGINE_SUBSTITUTION\",\n  \"PAD_CHAR_TO_FULL_LENGTH\",\n  0\n};\nexport bool sql_mode_string_representation(THD *thd, sql_mode_t sql_mode,\n                                           LEX_STRING *ls)\n{\n  set_to_string(thd, ls, sql_mode, sql_mode_names);\n  return ls->str == 0;\n}\n/*\n  sql_mode should *not* be IN_BINLOG: even though it is written to the binlog,\n  the slave ignores the MODE_NO_DIR_IN_CREATE variable, so slave's value\n  differs from master's (see log_event.cc: Query_log_event::do_apply_event()).\n*/\nstatic Sys_var_set Sys_sql_mode(\n       \"sql_mode\",\n       \"Syntax: sql-mode=mode[,mode[,mode...]]. See the manual for the \"\n       \"complete list of valid sql modes\",\n       SESSION_VAR(sql_mode), CMD_LINE(REQUIRED_ARG),\n       sql_mode_names,\n       DEFAULT(MODE_NO_ENGINE_SUBSTITUTION |\n               MODE_ONLY_FULL_GROUP_BY |\n               MODE_STRICT_TRANS_TABLES |\n               MODE_NO_ZERO_IN_DATE |\n               MODE_NO_ZERO_DATE |\n               MODE_ERROR_FOR_DIVISION_BY_ZERO |\n               MODE_NO_AUTO_CREATE_USER),\n       NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_sql_mode), ON_UPDATE(fix_sql_mode));\n\nstatic Sys_var_ulong Sys_max_execution_time(\n       \"max_execution_time\",\n       \"Kill SELECT statement that takes over the specified number of milliseconds\",\n       SESSION_VAR(max_execution_time), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n#define SSL_OPT(X) CMD_LINE(REQUIRED_ARG,X)\n#else\n#define SSL_OPT(X) NO_CMD_LINE\n#endif\n\n/*\n  If you are adding new system variable for SSL communication, please take a\n  look at do_auto_cert_generation() function in sql_authentication.cc and\n  add new system variable in checks if required.\n*/\n\nstatic Sys_var_charptr Sys_ssl_ca(\n       \"ssl_ca\",\n       \"CA file in PEM format (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_ca), SSL_OPT(OPT_SSL_CA),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_capath(\n       \"ssl_capath\",\n       \"CA directory (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_capath), SSL_OPT(OPT_SSL_CAPATH),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_tls_version(\n       \"tls_version\",\n       \"TLS version, permitted values are TLSv1, TLSv1.1, TLSv1.2(Only for openssl)\",\n       READ_ONLY GLOBAL_VAR(opt_tls_version), SSL_OPT(OPT_TLS_VERSION),\n#ifdef HAVE_YASSL\n       IN_FS_CHARSET, \"TLSv1,TLSv1.1\");\n#else\n       IN_FS_CHARSET, \"TLSv1,TLSv1.1,TLSv1.2\");\n#endif\n\nstatic Sys_var_charptr Sys_ssl_cert(\n       \"ssl_cert\", \"X509 cert in PEM format (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_cert), SSL_OPT(OPT_SSL_CERT),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_cipher(\n       \"ssl_cipher\", \"SSL cipher to use (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_cipher), SSL_OPT(OPT_SSL_CIPHER),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_key(\n       \"ssl_key\", \"X509 key in PEM format (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_key), SSL_OPT(OPT_SSL_KEY),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_crl(\n       \"ssl_crl\",\n       \"CRL file in PEM format (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_crl), SSL_OPT(OPT_SSL_CRL),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_crlpath(\n       \"ssl_crlpath\",\n       \"CRL directory (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_crlpath), SSL_OPT(OPT_SSL_CRLPATH),\n       IN_FS_CHARSET, DEFAULT(0));\n\n#if defined(HAVE_OPENSSL) && !defined(HAVE_YASSL)\nstatic Sys_var_mybool Sys_auto_generate_certs(\n       \"auto_generate_certs\",\n       \"Auto generate SSL certificates at server startup if --ssl is set to \"\n       \"ON and none of the other SSL system variables are specified and \"\n       \"certificate/key files are not present in data directory.\",\n       READ_ONLY GLOBAL_VAR(opt_auto_generate_certs),\n       CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE),\n       NO_MUTEX_GUARD,\n       NOT_IN_BINLOG,\n       ON_CHECK(NULL),\n       ON_UPDATE(NULL),\n       NULL);\n#endif /* HAVE_OPENSSL && !HAVE_YASSL */\n\n// why ENUM and not BOOL ?\nstatic const char *updatable_views_with_limit_names[]= {\"NO\", \"YES\", 0};\nstatic Sys_var_enum Sys_updatable_views_with_limit(\n       \"updatable_views_with_limit\",\n       \"YES = Don't issue an error message (warning only) if a VIEW without \"\n       \"presence of a key of the underlying table is used in queries with a \"\n       \"LIMIT clause for updating. NO = Prohibit update of a VIEW, which \"\n       \"does not contain a key of the underlying table and the query uses \"\n       \"a LIMIT clause (usually get from GUI tools)\",\n       SESSION_VAR(updatable_views_with_limit), CMD_LINE(REQUIRED_ARG),\n       updatable_views_with_limit_names, DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_sync_frm(\n       \"sync_frm\", \"Sync .frm files to disk on creation\",\n       GLOBAL_VAR(opt_sync_frm), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic char *system_time_zone_ptr;\nstatic Sys_var_charptr Sys_system_time_zone(\n       \"system_time_zone\", \"The server system time zone\",\n       READ_ONLY GLOBAL_VAR(system_time_zone_ptr), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(system_time_zone));\n\nstatic Sys_var_ulong Sys_table_def_size(\n       \"table_definition_cache\",\n       \"The number of cached table definitions\",\n       GLOBAL_VAR(table_def_size),\n       CMD_LINE(REQUIRED_ARG, OPT_TABLE_DEFINITION_CACHE),\n       VALID_RANGE(TABLE_DEF_CACHE_MIN, 512*1024),\n       DEFAULT(TABLE_DEF_CACHE_DEFAULT),\n       BLOCK_SIZE(1),\n       NO_MUTEX_GUARD,\n       NOT_IN_BINLOG,\n       ON_CHECK(NULL),\n       ON_UPDATE(NULL),\n       NULL,\n       /* table_definition_cache is used as a sizing hint by the performance schema. */\n       sys_var::PARSE_EARLY);\n\nstatic bool fix_table_cache_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  /*\n    table_open_cache parameter is a soft limit for total number of objects\n    in all table cache instances. Once this value is updated we need to\n    update value of a per-instance soft limit on table cache size.\n  */\n  table_cache_size_per_instance= table_cache_size / table_cache_instances;\n  return false;\n}\n\nstatic Sys_var_ulong Sys_table_cache_size(\n       \"table_open_cache\", \"The number of cached open tables \"\n       \"(total for all table cache instances)\",\n       GLOBAL_VAR(table_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 512*1024), DEFAULT(TABLE_OPEN_CACHE_DEFAULT),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(fix_table_cache_size),\n       NULL,\n       /* table_open_cache is used as a sizing hint by the performance schema. */\n       sys_var::PARSE_EARLY);\n\nstatic Sys_var_ulong Sys_table_cache_instances(\n       \"table_open_cache_instances\", \"The number of table cache instances\",\n       READ_ONLY GLOBAL_VAR(table_cache_instances), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, Table_cache_manager::MAX_TABLE_CACHES),\n       DEFAULT(Table_cache_manager::DEFAULT_MAX_TABLE_CACHES),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(NULL), NULL,\n       /*\n         table_open_cache is used as a sizing hint by the performance schema,\n         and 'table_open_cache' is a prefix of 'table_open_cache_instances'.\n         Is is better to keep these options together, to avoid confusing\n         handle_options() with partial name matches.\n       */\n       sys_var::PARSE_EARLY);\n\n#ifndef EMBEDDED_LIBRARY\nstatic Sys_var_ulong Sys_thread_cache_size(\n       \"thread_cache_size\",\n       \"How many threads we should keep in a cache for reuse\",\n       GLOBAL_VAR(Per_thread_connection_handler::max_blocked_pthreads),\n       CMD_LINE(REQUIRED_ARG, OPT_THREAD_CACHE_SIZE),\n       VALID_RANGE(0, 16384), DEFAULT(0), BLOCK_SIZE(1));\n#endif // !EMBEDDED_LIBRARY\n\n\n/**\n  Function to check if the 'next' transaction isolation level\n  ('tx_isolation'/ its alternative 'transaction_isolation')\n  can be changed.\n\n  @param[in] self   A pointer to the sys_var.\n  @param[in] thd    Thread handler.\n  @param[in] var    A pointer to set_var holding the specified list of\n                    system variable names.\n\n  @retval   FALSE   Success.\n  @retval   TRUE    Error.\n*/\nstatic bool check_transaction_isolation(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_DEFAULT && (thd->in_active_multi_stmt_transaction() ||\n                                   thd->in_sub_stmt))\n  {\n    DBUG_ASSERT(thd->in_multi_stmt_transaction_mode() || thd->in_sub_stmt);\n    my_error(ER_CANT_CHANGE_TX_CHARACTERISTICS, MYF(0));\n    return true;\n  }\n  return false;\n}\n\n\n/**\n  This function sets the session variable thd->variables.tx_isolation/\n  thd->variables.transaction_isolation to reflect changes\n  to @@session.tx_isolation/@@session.transaction_isolation.\n  'tx_isolation' is deprecated and 'transaction_isolation' is its\n  alternative.\n\n  @param[in] thd    Thread handler.\n  @param[in] var    A pointer to the set_var.\n\n  @retval   FALSE   Success.\n  @retval   TRUE    Error.\n*/\n\nbool Sys_var_tx_isolation::session_update(THD *thd, set_var *var)\n{\n  if (var->type == OPT_SESSION && Sys_var_enum::session_update(thd, var))\n    return TRUE;\n\n  if (var->type == OPT_DEFAULT || !(thd->in_active_multi_stmt_transaction() ||\n                                    thd->in_sub_stmt))\n  {\n    /*\n      Update the isolation level of the next transaction.\n      I.e. if one did:\n      COMMIT;\n      SET SESSION ISOLATION LEVEL ...\n      BEGIN; <-- this transaction has the new isolation\n      Note, that in case of:\n      COMMIT;\n      SET TRANSACTION ISOLATION LEVEL ...\n      SET SESSION ISOLATION LEVEL ...\n      BEGIN; <-- the session isolation level is used, not the\n      result of SET TRANSACTION statement.\n\n      When we are in a trigger/function the transaction is already\n      started. Adhering to above behavior, the SET TRANSACTION would\n      fail when run from within trigger/function. And SET SESSION\n      TRANSACTION would always succeed making the characteristics\n      effective for the next transaction that starts.\n     */\n    enum_tx_isolation tx_isol;\n    tx_isol= (enum_tx_isolation) var->save_result.ulonglong_value;\n    bool one_shot= (var->type == OPT_DEFAULT);\n    return set_tx_isolation(thd, tx_isol, one_shot);\n  }\n  return FALSE;\n}\n\n\n/**\n  This function updates the thd->variables.transaction_isolation\n  to reflect the changes made to @@session.tx_isolation. 'tx_isolation' is\n  deprecated and 'transaction_isolation' is its alternative.\n\n  @param[in] self   A pointer to the sys_var.\n  @param[in] thd    Thread handler.\n  @param[in] type   The type SESSION, GLOBAL or DEFAULT.\n\n  @retval   FALSE   Success.\n  @retval   TRUE    Error.\n*/\nstatic bool update_transaction_isolation(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  SV *sv= type == OPT_GLOBAL ? &global_system_variables : &thd->variables;\n  sv->transaction_isolation= sv->tx_isolation;\n  return false;\n}\n\n\n/**\n  This function updates thd->variables.tx_isolation to reflect the\n  changes to @@session.transaction_isolation. 'tx_isolation' is\n  deprecated and 'transaction_isolation' is its alternative.\n\n  @param[in] self   A pointer to the sys_var.\n  @param[in] thd    Thread handler.\n  @param[in] type   The type SESSION, GLOBAL or DEFAULT.\n\n  @retval   FALSE   Success.\n  @retval   TRUE    Error.\n*/\nstatic bool update_tx_isolation(sys_var *self, THD *thd,\n                                enum_var_type type)\n{\n  SV *sv= type == OPT_GLOBAL ? &global_system_variables : &thd->variables;\n  sv->tx_isolation= sv->transaction_isolation;\n  return false;\n}\n\n\n// NO_CMD_LINE - different name of the option\nstatic Sys_var_tx_isolation Sys_tx_isolation(\n       \"tx_isolation\", \"Default transaction isolation level.\"\n       \"This variable is deprecated and will be removed in a future release.\",\n       UNTRACKED_DEFAULT SESSION_VAR(tx_isolation), NO_CMD_LINE,\n       tx_isolation_names, DEFAULT(ISO_REPEATABLE_READ),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_transaction_isolation),\n       ON_UPDATE(update_transaction_isolation),\n       DEPRECATED(\"'@@transaction_isolation'\"));\n\n\n// NO_CMD_LINE\nstatic Sys_var_tx_isolation Sys_transaction_isolation(\n       \"transaction_isolation\", \"Default transaction isolation level\",\n       UNTRACKED_DEFAULT SESSION_VAR(transaction_isolation), NO_CMD_LINE,\n       tx_isolation_names, DEFAULT(ISO_REPEATABLE_READ),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_transaction_isolation),\n       ON_UPDATE(update_tx_isolation));\n\n\n/**\n  Function to check if the state of deprecated variable 'tx_read_only'/\n  its alternative 'transaction_read_only' can be changed. The state cannot\n  be changed if there is already a transaction in progress.\n\n  @param[in] self   A pointer to the sys_var.\n  @param[in] thd    Thread handler\n  @param[in] var    A pointer to set_var holding the specified list of\n                    system variable names.\n\n  @retval   FALSE   Success.\n  @retval   TRUE    Error.\n*/\n\nstatic bool check_transaction_read_only(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_DEFAULT && (thd->in_active_multi_stmt_transaction() ||\n                                   thd->in_sub_stmt))\n  {\n    DBUG_ASSERT(thd->in_multi_stmt_transaction_mode() || thd->in_sub_stmt);\n    my_error(ER_CANT_CHANGE_TX_CHARACTERISTICS, MYF(0));\n    return true;\n  }\n  return false;\n}\n\n\n/**\n  This function sets the session variable thd->variables.tx_read_only/\n  thd->variables.transaction_read_only to reflect changes to\n  @@session.tx_read_only/@@session.transaction_read_only. 'tx_read_only'\n  is deprecated and 'transaction_read_only' is its alternative.\n\n  @param[in] thd    Thread handler.\n  @param[in] var    A pointer to the set_var.\n\n  @retval   FALSE   Success.\n*/\nbool Sys_var_tx_read_only::session_update(THD *thd, set_var *var)\n{\n  if (var->type == OPT_SESSION && Sys_var_mybool::session_update(thd, var))\n    return true;\n\n  if (var->type == OPT_DEFAULT || !(thd->in_active_multi_stmt_transaction() ||\n                                    thd->in_sub_stmt))\n  {\n    // @see Sys_var_tx_isolation::session_update() above for the rules.\n    thd->tx_read_only= var->save_result.ulonglong_value;\n\n    if (thd->variables.session_track_transaction_info > TX_TRACK_NONE)\n    {\n      Transaction_state_tracker *tst= (Transaction_state_tracker *)\n             thd->session_tracker.get_tracker(TRANSACTION_INFO_TRACKER);\n\n      if (var->type == OPT_DEFAULT)\n        tst->set_read_flags(thd,\n                            thd->tx_read_only ? TX_READ_ONLY : TX_READ_WRITE);\n      else\n        tst->set_read_flags(thd, TX_READ_INHERIT);\n    }\n  }\n  return false;\n}\n\n\n/**\n  This function updates the session variable thd->variables.tx_read_only\n  to reflect changes made to  @@session.transaction_read_only. The variable\n  'tx_read_only' is deprecated and 'transaction_read_only' is its alternative.\n\n  @param[in] self   A pointer to the sys_var.\n  @param[in] thd    Thread handler.\n  @param[in] type   The type SESSION, GLOBAL or DEFAULT.\n\n  @retval   FALSE   Success.\n*/\nstatic bool update_tx_read_only(sys_var *self, THD *thd,\n                                enum_var_type type)\n{\n  SV *sv= type == OPT_GLOBAL ? &global_system_variables : &thd->variables;\n  sv->tx_read_only= sv->transaction_read_only;\n  return false;\n}\n\n\n/**\n  This function updates the session variable\n  thd->variables.transaction_read_only to reflect changes made to\n  @@session.tx_read_only. 'tx_read_only' is deprecated and\n  'transaction_read_only' is its alternative.\n\n  @param[in] self   A pointer to the sys_var.\n  @param[in] thd    Thread handler.\n  @param[in] type   The type SESSION, GLOBAL or DEFAULT.\n\n  @retval   FALSE   Success.\n*/\nstatic bool update_transaction_read_only(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  SV *sv= type == OPT_GLOBAL ? &global_system_variables : &thd->variables;\n  sv->transaction_read_only= sv->tx_read_only;\n  return false;\n}\n\n\nstatic Sys_var_tx_read_only Sys_tx_read_only(\n       \"tx_read_only\", \"Set default transaction access mode to read only.\"\n       \"This variable is deprecated and will be removed in a future release.\",\n       UNTRACKED_DEFAULT SESSION_VAR(tx_read_only), NO_CMD_LINE, DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_transaction_read_only),\n       ON_UPDATE(update_transaction_read_only),\n       DEPRECATED(\"'@@transaction_read_only'\"));\n\n\nstatic Sys_var_tx_read_only Sys_transaction_read_only(\n       \"transaction_read_only\",\n       \"Set default transaction access mode to read only.\",\n       UNTRACKED_DEFAULT SESSION_VAR(transaction_read_only), NO_CMD_LINE,\n       DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_transaction_read_only),\n       ON_UPDATE(update_tx_read_only));\n\n\nstatic Sys_var_ulonglong Sys_tmp_table_size(\n       \"tmp_table_size\",\n       \"If an internal in-memory temporary table exceeds this size, MySQL \"\n       \"will automatically convert it to an on-disk MyISAM table\",\n       SESSION_VAR(tmp_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1));\n\nstatic char *server_version_ptr;\nstatic Sys_var_version Sys_version(\n       \"version\", \"Server version\",\n       READ_ONLY GLOBAL_VAR(server_version_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(server_version));\n\nstatic char *server_version_comment_ptr;\nstatic Sys_var_charptr Sys_version_comment(\n       \"version_comment\", \"version_comment\",\n       READ_ONLY GLOBAL_VAR(server_version_comment_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(MYSQL_COMPILATION_COMMENT));\n\nstatic char *server_version_compile_machine_ptr;\nstatic Sys_var_charptr Sys_version_compile_machine(\n       \"version_compile_machine\", \"version_compile_machine\",\n       READ_ONLY GLOBAL_VAR(server_version_compile_machine_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(MACHINE_TYPE));\n\nstatic char *server_version_compile_os_ptr;\nstatic Sys_var_charptr Sys_version_compile_os(\n       \"version_compile_os\", \"version_compile_os\",\n       READ_ONLY GLOBAL_VAR(server_version_compile_os_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(SYSTEM_TYPE));\n\nstatic Sys_var_ulong Sys_net_wait_timeout(\n       \"wait_timeout\",\n       \"The number of seconds the server waits for activity on a \"\n       \"connection before closing it\",\n       SESSION_VAR(net_wait_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, IF_WIN(INT_MAX32/1000, LONG_TIMEOUT)),\n       DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_plugin Sys_default_storage_engine(\n       \"default_storage_engine\", \"The default storage engine for new tables\",\n       SESSION_VAR(table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_storage_engine),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_storage_engine));\n\nconst char *internal_tmp_disk_storage_engine_names[] = { \"MyISAM\", \"InnoDB\", 0};\nstatic Sys_var_enum Sys_internal_tmp_disk_storage_engine(\n       \"internal_tmp_disk_storage_engine\",\n       \"The default storage engine for on-disk internal tmp table\",\n       GLOBAL_VAR(internal_tmp_disk_storage_engine), CMD_LINE(OPT_ARG),\n       internal_tmp_disk_storage_engine_names, DEFAULT(TMP_TABLE_INNODB));\n\nstatic Sys_var_plugin Sys_default_tmp_storage_engine(\n       \"default_tmp_storage_engine\", \"The default storage engine for new explicit temporary tables\",\n       SESSION_VAR(temp_table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_tmp_storage_engine),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_storage_engine));\n\n#if defined(ENABLED_DEBUG_SYNC)\n/*\n  Variable can be set for the session only.\n\n  This could be changed later. Then we need to have a global array of\n  actions in addition to the thread local ones. SET GLOBAL would\n  manage the global array, SET [SESSION] the local array. A sync point\n  would need to look for a local and a global action. Setting and\n  executing of global actions need to be protected by a mutex.\n\n  The purpose of global actions could be to allow synchronizing with\n  connectionless threads that cannot execute SET statements.\n*/\nstatic Sys_var_debug_sync Sys_debug_sync(\n       \"debug_sync\", \"Debug Sync Facility\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n/**\n \"time_format\" \"date_format\" \"datetime_format\"\n\n  the following three variables are unused, and the source of confusion\n  (bug reports like \"I've changed date_format, but date format hasn't changed.\n  I've made them read-only, to alleviate the situation somewhat.\n\n  @todo make them NO_CMD_LINE ?\n*/\nstatic Sys_var_charptr Sys_date_format(\n       \"date_format\", \"The DATE format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_date_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].date_format),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_charptr Sys_datetime_format(\n       \"datetime_format\", \"The DATETIME format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_datetime_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].datetime_format),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_charptr Sys_time_format(\n       \"time_format\", \"The TIME format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_time_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].time_format),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic bool fix_autocommit(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_GLOBAL)\n  {\n    if (global_system_variables.option_bits & OPTION_AUTOCOMMIT)\n      global_system_variables.option_bits&= ~OPTION_NOT_AUTOCOMMIT;\n    else\n      global_system_variables.option_bits|= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  if (thd->variables.option_bits & OPTION_AUTOCOMMIT &&\n      thd->variables.option_bits & OPTION_NOT_AUTOCOMMIT)\n  { // activating autocommit\n\n    if (trans_commit_stmt(thd) || trans_commit(thd))\n    {\n      thd->variables.option_bits&= ~OPTION_AUTOCOMMIT;\n      return true;\n    }\n    /*\n      Don't close thread tables or release metadata locks: if we do so, we\n      risk releasing locks/closing tables of expressions used to assign\n      other variables, as in:\n      set @var=my_stored_function1(), @@autocommit=1, @var2=(select max(a)\n      from my_table), ...\n      The locks will be released at statement end anyway, as SET\n      statement that assigns autocommit is marked to commit\n      transaction implicitly at the end (@sa stmt_causes_implicitcommit()).\n    */\n    thd->variables.option_bits&=\n                 ~(OPTION_BEGIN | OPTION_NOT_AUTOCOMMIT);\n    thd->get_transaction()->reset_unsafe_rollback_flags(\n        Transaction_ctx::SESSION);\n    thd->server_status|= SERVER_STATUS_AUTOCOMMIT;\n    return false;\n  }\n\n  if (!(thd->variables.option_bits & OPTION_AUTOCOMMIT) &&\n      !(thd->variables.option_bits & OPTION_NOT_AUTOCOMMIT))\n  { // disabling autocommit\n\n    thd->get_transaction()->reset_unsafe_rollback_flags(\n        Transaction_ctx::SESSION);\n    thd->server_status&= ~SERVER_STATUS_AUTOCOMMIT;\n    thd->variables.option_bits|= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  return false; // autocommit value wasn't changed\n}\nstatic Sys_var_bit Sys_autocommit(\n       \"autocommit\", \"autocommit\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_AUTOCOMMIT, DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_autocommit));\nexport sys_var *Sys_autocommit_ptr= &Sys_autocommit; // for sql_yacc.yy\n\nstatic Sys_var_mybool Sys_big_tables(\n       \"big_tables\", \"Allow big result sets by saving all \"\n       \"temporary sets on file (Solves most 'table full' errors)\",\n       SESSION_VAR(big_tables), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_big_selects(\n       \"sql_big_selects\", \"sql_big_selects\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_BIG_SELECTS,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_log_off(\n       \"sql_log_off\", \"sql_log_off\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_LOG_OFF,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n\n/**\n  This function sets the session variable thd->variables.sql_log_bin \n  to reflect changes to @@session.sql_log_bin.\n\n  @param[in] self   A pointer to the sys_var, i.e. Sys_log_binlog.\n  @param[in] type   The type either session or global.\n\n  @return @c FALSE.\n*/\nstatic bool fix_sql_log_bin_after_update(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  DBUG_ASSERT(type == OPT_SESSION);\n\n  if (thd->variables.sql_log_bin)\n    thd->variables.option_bits |= OPTION_BIN_LOG;\n  else\n    thd->variables.option_bits &= ~OPTION_BIN_LOG;\n\n  return FALSE;\n}\n\n/**\n  This function checks if the sql_log_bin can be changed,\n  what is possible if:\n    - the user is a super user;\n    - the set is not called from within a function/trigger;\n    - there is no on-going transaction.\n\n  @param[in] self   A pointer to the sys_var, i.e. Sys_log_binlog.\n  @param[in] var    A pointer to the set_var created by the parser.\n\n  @return @c FALSE if the change is allowed, otherwise @c TRUE.\n*/\nstatic bool check_sql_log_bin(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return TRUE;\n\n  if (var->type == OPT_GLOBAL)\n    return TRUE;\n\n  /* If in a stored function/trigger, it's too late to change sql_log_bin. */\n  if (thd->in_sub_stmt)\n  {\n    my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN, MYF(0));\n    return TRUE;\n  }\n  /* Make the session variable 'sql_log_bin' read-only inside a transaction. */\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN, MYF(0));\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nstatic Sys_var_sql_log_bin Sys_log_binlog(\n       \"sql_log_bin\", \"Controls whether logging to the binary log is done\",\n       SESSION_VAR(sql_log_bin), NO_CMD_LINE, DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_sql_log_bin),\n       ON_UPDATE(fix_sql_log_bin_after_update));\n\nstatic Sys_var_bit Sys_transaction_allow_batching(\n       \"transaction_allow_batching\", \"transaction_allow_batching\",\n       SESSION_ONLY(option_bits), NO_CMD_LINE, OPTION_ALLOW_BATCH,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_sql_warnings(\n       \"sql_warnings\", \"sql_warnings\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_WARNINGS,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_sql_notes(\n       \"sql_notes\", \"sql_notes\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_SQL_NOTES,\n       DEFAULT(TRUE));\n\nstatic Sys_var_bit Sys_auto_is_null(\n       \"sql_auto_is_null\", \"sql_auto_is_null\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_AUTO_IS_NULL,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_safe_updates(\n       \"sql_safe_updates\", \"sql_safe_updates\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_SAFE_UPDATES,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_buffer_results(\n       \"sql_buffer_result\", \"sql_buffer_result\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_BUFFER_RESULT,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_quote_show_create(\n       \"sql_quote_show_create\", \"sql_quote_show_create\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_QUOTE_SHOW_CREATE,\n       DEFAULT(TRUE));\n\nstatic Sys_var_bit Sys_foreign_key_checks(\n       \"foreign_key_checks\", \"foreign_key_checks\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_NO_FOREIGN_KEY_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_unique_checks(\n       \"unique_checks\", \"unique_checks\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_RELAXED_UNIQUE_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\n#ifdef ENABLED_PROFILING\nstatic Sys_var_bit Sys_profiling(\n       \"profiling\", \"profiling\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_PROFILING,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_profiling_history_size(\n       \"profiling_history_size\", \"Limit of query profiling memory\",\n       SESSION_VAR(profiling_history_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 100), DEFAULT(15), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n#endif\n\nstatic Sys_var_harows Sys_select_limit(\n       \"sql_select_limit\",\n       \"The maximum number of rows to return from SELECT statements\",\n       SESSION_VAR(select_limit), NO_CMD_LINE,\n       VALID_RANGE(0, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1));\n\nstatic bool update_timestamp(THD *thd, set_var *var)\n{\n  if (var->value)\n  {\n    double fl= floor(var->save_result.double_value); // Truncate integer part\n    struct timeval tmp;\n    tmp.tv_sec= static_cast<long>(fl);\n    /* Round nanoseconds to nearest microsecond */\n    tmp.tv_usec=\n      static_cast<long>(rint((var->save_result.double_value - fl) * 1000000));\n    thd->set_time(&tmp);\n  }\n  else // SET timestamp=DEFAULT\n  {\n    thd->user_time.tv_sec= 0;\n    thd->user_time.tv_usec= 0;\n  }\n  return false;\n}\nstatic double read_timestamp(THD *thd)\n{\n  return (double) thd->start_time.tv_sec +\n         (double) thd->start_time.tv_usec / 1000000;\n}\n\n\nstatic bool check_timestamp(sys_var *self, THD *thd, set_var *var)\n{\n  double val;\n\n  if (!var->value)\n    return FALSE;\n\n  val= var->save_result.double_value;\n  if (val != 0 &&          // this is how you set the default value\n      (val < TIMESTAMP_MIN_VALUE || val > TIMESTAMP_MAX_VALUE))\n  {\n    ErrConvString prm(val);\n    my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), \"timestamp\", prm.ptr());\n    return TRUE;\n  }\n  return FALSE;\n}\n\n\nstatic Sys_var_session_special_double Sys_timestamp(\n       \"timestamp\", \"Set the time for this client\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, 0), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_timestamp), \n       ON_UPDATE(update_timestamp), ON_READ(read_timestamp));\n\nstatic bool update_last_insert_id(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->first_successful_insert_id_in_prev_stmt=\n    var->save_result.ulonglong_value;\n  thd->substitute_null_with_insert_id= TRUE;\n  return false;\n}\nstatic ulonglong read_last_insert_id(THD *thd)\n{\n  return thd->read_first_successful_insert_id_in_prev_stmt();\n}\nstatic Sys_var_session_special Sys_last_insert_id(\n       \"last_insert_id\", \"The value to be returned from LAST_INSERT_ID()\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n// alias for last_insert_id(), Sybase-style\nstatic Sys_var_session_special Sys_identity(\n       \"identity\", \"Synonym for the last_insert_id variable\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n/*\n  insert_id should *not* be marked as written to the binlog (i.e., it\n  should *not* be IN_BINLOG), because we want any statement that\n  refers to insert_id explicitly to be unsafe.  (By \"explicitly\", we\n  mean using @@session.insert_id, whereas insert_id is used\n  \"implicitly\" when NULL value is inserted into an auto_increment\n  column).\n\n  We want statements referring explicitly to @@session.insert_id to be\n  unsafe, because insert_id is modified internally by the slave sql\n  thread when NULL values are inserted in an AUTO_INCREMENT column.\n  This modification interfers with the value of the\n  @@session.insert_id variable if @@session.insert_id is referred\n  explicitly by an insert statement (as is seen by executing \"SET\n  @@session.insert_id=0; CREATE TABLE t (a INT, b INT KEY\n  AUTO_INCREMENT); INSERT INTO t(a) VALUES (@@session.insert_id);\" in\n  statement-based logging mode: t will be different on master and\n  slave).\n*/\nstatic bool update_insert_id(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->force_one_auto_inc_interval(var->save_result.ulonglong_value);\n  return false;\n}\n\nstatic ulonglong read_insert_id(THD *thd)\n{\n  return thd->auto_inc_intervals_forced.minimum();\n}\nstatic Sys_var_session_special Sys_insert_id(\n       \"insert_id\", \"The value to be used by the following INSERT \"\n       \"or ALTER TABLE statement when inserting an AUTO_INCREMENT value\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_insert_id), ON_READ(read_insert_id));\n\nstatic bool update_rand_seed1(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed1= (ulong) var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_rand_seed(THD *thd)\n{\n  return 0;\n}\nstatic Sys_var_session_special Sys_rand_seed1(\n       \"rand_seed1\", \"Sets the internal state of the RAND() \"\n       \"generator for replication purposes\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_rand_seed1), ON_READ(read_rand_seed));\n\nstatic bool update_rand_seed2(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed2= (ulong) var->save_result.ulonglong_value;\n  return false;\n}\nstatic Sys_var_session_special Sys_rand_seed2(\n       \"rand_seed2\", \"Sets the internal state of the RAND() \"\n       \"generator for replication purposes\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_rand_seed2), ON_READ(read_rand_seed));\n\nstatic ulonglong read_error_count(THD *thd)\n{\n  return thd->get_stmt_da()->error_count(thd);\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_error_count(\n       \"error_count\", \"The number of errors that resulted from the \"\n       \"last statement that generated messages\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULLONG_MAX), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(read_error_count));\n\nstatic ulonglong read_warning_count(THD *thd)\n{\n  return thd->get_stmt_da()->warn_count(thd);\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_warning_count(\n       \"warning_count\", \"The number of errors, warnings, and notes \"\n       \"that resulted from the last statement that generated messages\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULLONG_MAX), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(read_warning_count));\n\nstatic Sys_var_ulong Sys_default_week_format(\n       \"default_week_format\",\n       \"The default week format used by WEEK() functions\",\n       SESSION_VAR(default_week_format), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 7), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_group_concat_max_len(\n       \"group_concat_max_len\",\n       \"The maximum length of the result of function  GROUP_CONCAT()\",\n       SESSION_VAR(group_concat_max_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, ULONG_MAX), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic char *glob_hostname_ptr;\nstatic Sys_var_charptr Sys_hostname(\n       \"hostname\", \"Server host name\",\n       READ_ONLY GLOBAL_VAR(glob_hostname_ptr), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(glob_hostname));\n\n#ifndef EMBEDDED_LIBRARY\nstatic Sys_var_charptr Sys_repl_report_host(\n       \"report_host\",\n       \"Hostname or IP of the slave to be reported to the master during \"\n       \"slave registration. Will appear in the output of SHOW SLAVE HOSTS. \"\n       \"Leave unset if you do not want the slave to register itself with the \"\n       \"master. Note that it is not sufficient for the master to simply read \"\n       \"the IP of the slave off the socket once the slave connects. Due to \"\n       \"NAT and other routing issues, that IP may not be valid for connecting \"\n       \"to the slave from the master or other hosts\",\n       READ_ONLY GLOBAL_VAR(report_host), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_repl_report_user(\n       \"report_user\",\n       \"The account user name of the slave to be reported to the master \"\n       \"during slave registration\",\n       READ_ONLY GLOBAL_VAR(report_user), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_repl_report_password(\n       \"report_password\",\n       \"The account password of the slave to be reported to the master \"\n       \"during slave registration\",\n       READ_ONLY GLOBAL_VAR(report_password), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_repl_report_port(\n       \"report_port\",\n       \"Port for connecting to slave reported to the master during slave \"\n       \"registration. Set it only if the slave is listening on a non-default \"\n       \"port or if you have a special tunnel from the master or other clients \"\n       \"to the slave. If not sure, leave this option unset\",\n       READ_ONLY GLOBAL_VAR(report_port), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 65535), DEFAULT(0), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_mybool Sys_keep_files_on_create(\n       \"keep_files_on_create\",\n       \"Don't overwrite stale .MYD and .MYI even if no directory is specified\",\n       SESSION_VAR(keep_files_on_create), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic char *license;\nstatic Sys_var_charptr Sys_license(\n       \"license\", \"The type of license the server has\",\n       READ_ONLY GLOBAL_VAR(license), NO_CMD_LINE, IN_SYSTEM_CHARSET,\n       DEFAULT(STRINGIFY_ARG(LICENSE)));\n\nstatic bool check_log_path(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false; // DEFAULT is ok\n\n  if (!var->save_result.string_value.str)\n    return true;\n\n  if (!is_valid_log_name(var->save_result.string_value.str,\n                         var->save_result.string_value.length))\n  {\n    my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0),\n             self->name.str, var->save_result.string_value.str);\n    return true;\n  }\n\n  if (var->save_result.string_value.length > FN_REFLEN)\n  { // path is too long\n    my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n    return true;\n  }\n\n  char path[FN_REFLEN];\n  size_t path_length= unpack_filename(path, var->save_result.string_value.str);\n\n  if (!path_length)\n    return true;\n\n  if (!is_filename_allowed(var->save_result.string_value.str, \n                           var->save_result.string_value.length, TRUE))\n  {\n     my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), \n              self->name.str, var->save_result.string_value.str);\n     return true;\n  }\n\n  MY_STAT f_stat;\n\n  if (my_stat(path, &f_stat, MYF(0)))\n  {\n    if (!MY_S_ISREG(f_stat.st_mode) || !(f_stat.st_mode & MY_S_IWRITE))\n      return true; // not a regular writable file\n    return false;\n  }\n\n  (void) dirname_part(path, var->save_result.string_value.str, &path_length);\n\n  if (var->save_result.string_value.length - path_length >= FN_LEN)\n  { // filename is too long\n      my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n      return true;\n  }\n\n  if (!path_length) // no path is good path (remember, relative to datadir)\n    return false;\n\n  if (my_access(path, (F_OK|W_OK)))\n    return true; // directory is not writable\n\n  return false;\n}\nstatic bool fix_general_log_file(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (!opt_general_logname) // SET ... = DEFAULT\n  {\n    char buff[FN_REFLEN];\n    opt_general_logname= my_strdup(key_memory_LOG_name,\n                                   make_query_log_name(buff, QUERY_LOG_GENERAL),\n                                   MYF(MY_FAE+MY_WME));\n    if (!opt_general_logname)\n      return true;\n  }\n  bool res= false;\n  if (opt_general_log)\n  {\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n    res= query_logger.reopen_log_file(QUERY_LOG_GENERAL);\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    if (res)\n      opt_general_log= false;\n  }\n  return res;\n}\nstatic Sys_var_charptr Sys_general_log_path(\n       \"general_log_file\", \"Log connections and queries to given file\",\n       GLOBAL_VAR(opt_general_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_log_path), ON_UPDATE(fix_general_log_file));\n\nstatic bool fix_slow_log_file(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (!opt_slow_logname) // SET ... = DEFAULT\n  {\n    char buff[FN_REFLEN];\n    opt_slow_logname= my_strdup(key_memory_LOG_name,\n                                make_query_log_name(buff, QUERY_LOG_SLOW),\n                                MYF(MY_FAE+MY_WME));\n    if (!opt_slow_logname)\n      return true;\n  }\n  bool res= false;\n  if (opt_slow_log)\n  {\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n    res= query_logger.reopen_log_file(QUERY_LOG_SLOW);\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    if (res)\n      opt_slow_log= false;\n  }\n  return res;\n}\nstatic Sys_var_charptr Sys_slow_log_path(\n       \"slow_query_log_file\", \"Log slow queries to given log file. \"\n       \"Defaults logging to hostname-slow.log. Must be enabled to activate \"\n       \"other slow log options\",\n       GLOBAL_VAR(opt_slow_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_log_path), ON_UPDATE(fix_slow_log_file));\n\nstatic Sys_var_have Sys_have_compress(\n       \"have_compress\", \"have_compress\",\n       READ_ONLY GLOBAL_VAR(have_compress), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_crypt(\n       \"have_crypt\", \"have_crypt\",\n       READ_ONLY GLOBAL_VAR(have_crypt), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_dlopen(\n       \"have_dynamic_loading\", \"have_dynamic_loading\",\n       READ_ONLY GLOBAL_VAR(have_dlopen), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_geometry(\n       \"have_geometry\", \"have_geometry\",\n       READ_ONLY GLOBAL_VAR(have_geometry), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_openssl(\n       \"have_openssl\", \"have_openssl\",\n       READ_ONLY GLOBAL_VAR(have_ssl), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_profiling(\n       \"have_profiling\", \"have_profiling\",\n       READ_ONLY GLOBAL_VAR(have_profiling), NO_CMD_LINE, NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic Sys_var_have Sys_have_query_cache(\n       \"have_query_cache\",\n       \"have_query_cache. \"\n       \"This variable is deprecated and will be removed in a future release.\",\n       READ_ONLY GLOBAL_VAR(have_query_cache), NO_CMD_LINE,\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_have Sys_have_rtree_keys(\n       \"have_rtree_keys\", \"have_rtree_keys\",\n       READ_ONLY GLOBAL_VAR(have_rtree_keys), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_ssl(\n       \"have_ssl\", \"have_ssl\",\n       READ_ONLY GLOBAL_VAR(have_ssl), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_symlink(\n       \"have_symlink\", \"have_symlink\",\n       READ_ONLY GLOBAL_VAR(have_symlink), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_statement_timeout(\n       \"have_statement_timeout\", \"have_statement_timeout\",\n       READ_ONLY GLOBAL_VAR(have_statement_timeout), NO_CMD_LINE);\n\nstatic bool fix_general_log_state(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (query_logger.is_log_file_enabled(QUERY_LOG_GENERAL) == opt_general_log)\n    return false;\n\n  if (!opt_general_log)\n  {\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n    query_logger.deactivate_log_handler(QUERY_LOG_GENERAL);\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    return false;\n  }\n  else\n  {\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n    bool res= query_logger.activate_log_handler(thd, QUERY_LOG_GENERAL);\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    if (res)\n      opt_general_log= false;\n    return res;\n  }\n}\nstatic Sys_var_mybool Sys_general_log(\n       \"general_log\", \"Log connections and queries to a table or log file. \"\n       \"Defaults to logging to a file hostname.log, \"\n       \"or if --log-output=TABLE is used, to a table mysql.general_log.\",\n       GLOBAL_VAR(opt_general_log), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_general_log_state));\n\nstatic bool fix_slow_log_state(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (query_logger.is_log_file_enabled(QUERY_LOG_SLOW) == opt_slow_log)\n    return false;\n\n  if (!opt_slow_log)\n  {\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n    query_logger.deactivate_log_handler(QUERY_LOG_SLOW);\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    return false;\n  }\n  else\n  {\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n    bool res= query_logger.activate_log_handler(thd, QUERY_LOG_SLOW);\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    if (res)\n      opt_slow_log= false;\n    return res;\n  }\n}\nstatic Sys_var_mybool Sys_slow_query_log(\n       \"slow_query_log\",\n       \"Log slow queries to a table or log file. Defaults logging to a file \"\n       \"hostname-slow.log or a table mysql.slow_log if --log-output=TABLE is \"\n       \"used. Must be enabled to activate other slow log options\",\n       GLOBAL_VAR(opt_slow_log), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_slow_log_state));\n\nstatic bool check_not_empty_set(sys_var *self, THD *thd, set_var *var)\n{\n  return var->save_result.ulonglong_value == 0;\n}\nstatic bool fix_log_output(sys_var *self, THD *thd, enum_var_type type)\n{\n  query_logger.set_handlers(static_cast<uint>(log_output_options));\n  return false;\n}\n\nstatic const char *log_output_names[] = { \"NONE\", \"FILE\", \"TABLE\", NULL};\n\nstatic Sys_var_set Sys_log_output(\n       \"log_output\", \"Syntax: log-output=value[,value...], \"\n       \"where \\\"value\\\" could be TABLE, FILE or NONE\",\n       GLOBAL_VAR(log_output_options), CMD_LINE(REQUIRED_ARG),\n       log_output_names, DEFAULT(LOG_FILE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_not_empty_set), ON_UPDATE(fix_log_output));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_mybool Sys_log_slave_updates(\n       \"log_slave_updates\", \"Tells the slave to log the updates from \"\n       \"the slave thread to the binary log. You will need to turn it on if \"\n       \"you plan to daisy-chain the slaves\",\n       READ_ONLY GLOBAL_VAR(opt_log_slave_updates), CMD_LINE(OPT_ARG),\n       DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log(\n       \"relay_log\", \"The location and name to use for relay logs\",\n       READ_ONLY GLOBAL_VAR(opt_relay_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\n/*\n  Uses NO_CMD_LINE since the --relay-log-index option set\n  opt_relaylog_index_name variable and computes a value for the\n  relay_log_index variable.\n*/\nstatic Sys_var_charptr Sys_relay_log_index(\n       \"relay_log_index\", \"The location and name to use for the file \"\n       \"that keeps a list of the last relay logs\",\n       READ_ONLY GLOBAL_VAR(relay_log_index), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\n/*\n  Uses NO_CMD_LINE since the --log-bin-index option set\n  opt_binlog_index_name variable and computes a value for the\n  log_bin_index variable.\n*/\nstatic Sys_var_charptr Sys_binlog_index(\n       \"log_bin_index\", \"File that holds the names for last binary log files.\",\n       READ_ONLY GLOBAL_VAR(log_bin_index), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log_basename(\n       \"relay_log_basename\",\n       \"The full path of the relay log file names, excluding the extension.\",\n       READ_ONLY GLOBAL_VAR(relay_log_basename), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_log_bin_basename(\n       \"log_bin_basename\",\n       \"The full path of the binary log file names, excluding the extension.\",\n       READ_ONLY GLOBAL_VAR(log_bin_basename), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log_info_file(\n       \"relay_log_info_file\", \"The location and name of the file that \"\n       \"remembers where the SQL replication thread is in the relay logs\",\n       READ_ONLY GLOBAL_VAR(relay_log_info_file), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_relay_log_purge(\n       \"relay_log_purge\", \"if disabled - do not purge relay logs. \"\n       \"if enabled - purge them as soon as they are no more needed\",\n       GLOBAL_VAR(relay_log_purge), CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_relay_log_recovery(\n       \"relay_log_recovery\", \"Enables automatic relay log recovery \"\n       \"right after the database startup, which means that the IO Thread \"\n       \"starts re-fetching from the master right after the last transaction \"\n       \"processed\",\n        READ_ONLY GLOBAL_VAR(relay_log_recovery), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_slave_allow_batching(\n       \"slave_allow_batching\", \"Allow slave to batch requests\",\n       GLOBAL_VAR(opt_slave_allow_batching),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_slave_load_tmpdir(\n       \"slave_load_tmpdir\", \"The location where the slave should put \"\n       \"its temporary files when replicating a LOAD DATA INFILE command\",\n       READ_ONLY GLOBAL_VAR(slave_load_tmpdir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool fix_slave_net_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  DEBUG_SYNC(thd, \"fix_slave_net_timeout\");\n  Master_info *mi;\n\n\n  /* @TODO: slave net timeout is for all channels, but does this make\n           sense?\n   */\n\n  /*\n   Here we have lock on LOCK_global_system_variables and we need\n    lock on channel_map lock. In START_SLAVE handler, we take these\n    two locks in different order. This can lead to DEADLOCKs. See\n    BUG#14236151 for more details.\n   So we release lock on LOCK_global_system_variables before acquiring\n    lock on channel_map lock. But this could lead to isolation issues\n    between multiple setters. Hence introducing secondary guard\n    for this global variable and releasing the lock here and acquiring\n    locks back again at the end of this function.\n   */\n  mysql_mutex_unlock(&LOCK_slave_net_timeout);\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  channel_map.wrlock();\n\n  for (mi_map::iterator it=channel_map.begin(); it!=channel_map.end(); it++)\n  {\n    mi= it->second;\n\n    DBUG_PRINT(\"info\", (\"slave_net_timeout=%u mi->heartbeat_period=%.3f\",\n                        slave_net_timeout,\n                        (mi ? mi->heartbeat_period : 0.0)));\n    if (mi != NULL && slave_net_timeout < mi->heartbeat_period)\n      push_warning(thd, Sql_condition::SL_WARNING,\n                   ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX,\n                   ER(ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX));\n  }\n\n  channel_map.unlock();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  mysql_mutex_lock(&LOCK_slave_net_timeout);\n  return false;\n}\nstatic PolyLock_mutex PLock_slave_net_timeout(&LOCK_slave_net_timeout);\nstatic Sys_var_uint Sys_slave_net_timeout(\n       \"slave_net_timeout\", \"Number of seconds to wait for more data \"\n       \"from a master/slave connection before aborting the read\",\n       GLOBAL_VAR(slave_net_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(SLAVE_NET_TIMEOUT), BLOCK_SIZE(1),\n       &PLock_slave_net_timeout, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_slave_net_timeout));\n\nstatic bool check_slave_skip_counter(sys_var *self, THD *thd, set_var *var)\n{\n  /*\n    @todo: move this check into the set function and hold the lock on\n    gtid_mode_lock until the operation has completed, so that we are\n    sure a concurrent connection does not change gtid_mode between\n    check and fix.\n  */\n  if (get_gtid_mode(GTID_MODE_LOCK_NONE) == GTID_MODE_ON)\n  {\n    my_message(ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE,\n               ER(ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE),\n               MYF(0));\n    return true;\n  }\n\n  return false;\n}\n\nstatic PolyLock_mutex PLock_sql_slave_skip_counter(&LOCK_sql_slave_skip_counter);\nstatic Sys_var_uint Sys_slave_skip_counter(\n       \"sql_slave_skip_counter\", \"sql_slave_skip_counter\",\n       GLOBAL_VAR(sql_slave_skip_counter), NO_CMD_LINE,\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1),\n       &PLock_sql_slave_skip_counter, NOT_IN_BINLOG,\n       ON_CHECK(check_slave_skip_counter));\n\nstatic Sys_var_charptr Sys_slave_skip_errors(\n       \"slave_skip_errors\", \"Tells the slave thread to continue \"\n       \"replication when a query event returns an error from the \"\n       \"provided list\",\n       READ_ONLY GLOBAL_VAR(opt_slave_skip_errors), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulonglong Sys_relay_log_space_limit(\n       \"relay_log_space_limit\", \"Maximum space to use for all relay logs\",\n       READ_ONLY GLOBAL_VAR(relay_log_space_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relaylog_period(\n       \"sync_relay_log\", \"Synchronously flush relay log to disk after \"\n       \"every #th event. Use 0 to disable synchronous flushing\",\n       GLOBAL_VAR(sync_relaylog_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relayloginfo_period(\n       \"sync_relay_log_info\", \"Synchronously flush relay log info \"\n       \"to disk after every #th transaction. Use 0 to disable \"\n       \"synchronous flushing\",\n       GLOBAL_VAR(sync_relayloginfo_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_checkpoint_mts_period(\n       \"slave_checkpoint_period\", \"Gather workers' activities to \"\n       \"Update progress status of Multi-threaded slave and flush \"\n       \"the relay log info to disk after every #th milli-seconds.\",\n       GLOBAL_VAR(opt_mts_checkpoint_period), CMD_LINE(REQUIRED_ARG),\n#ifndef DBUG_OFF\n       VALID_RANGE(0, UINT_MAX), DEFAULT(300), BLOCK_SIZE(1));\n#else\n       VALID_RANGE(1, UINT_MAX), DEFAULT(300), BLOCK_SIZE(1));\n#endif /* DBUG_OFF */\n\nstatic Sys_var_uint Sys_checkpoint_mts_group(\n       \"slave_checkpoint_group\",\n       \"Maximum number of processed transactions by Multi-threaded slave \"\n       \"before a checkpoint operation is called to update progress status.\",\n       GLOBAL_VAR(opt_mts_checkpoint_group), CMD_LINE(REQUIRED_ARG),\n#ifndef DBUG_OFF\n       VALID_RANGE(1, MTS_MAX_BITS_IN_GROUP), DEFAULT(512), BLOCK_SIZE(1));\n#else\n       VALID_RANGE(32, MTS_MAX_BITS_IN_GROUP), DEFAULT(512), BLOCK_SIZE(8));\n#endif /* DBUG_OFF */\n#endif /* HAVE_REPLICATION */\n\nstatic Sys_var_uint Sys_sync_binlog_period(\n       \"sync_binlog\", \"Synchronously flush binary log to disk after\"\n       \" every #th write to the file. Use 0 to disable synchronous\"\n       \" flushing\",\n       GLOBAL_VAR(sync_binlog_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_masterinfo_period(\n       \"sync_master_info\", \"Synchronously flush master info to disk \"\n       \"after every #th event. Use 0 to disable synchronous flushing\",\n       GLOBAL_VAR(sync_masterinfo_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_ulong Sys_slave_trans_retries(\n       \"slave_transaction_retries\", \"Number of times the slave SQL \"\n       \"thread will retry a transaction in case it failed with a deadlock \"\n       \"or elapsed lock wait timeout, before giving up and stopping\",\n       GLOBAL_VAR(slave_trans_retries), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(10), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_slave_parallel_workers(\n       \"slave_parallel_workers\",\n       \"Number of worker threads for executing events in parallel \",\n       GLOBAL_VAR(opt_mts_slave_parallel_workers), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, MTS_MAX_WORKERS), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_mts_pending_jobs_size_max(\n       \"slave_pending_jobs_size_max\",\n       \"Max size of Slave Worker queues holding yet not applied events.\"\n       \"The least possible value must be not less than the master side \"\n       \"max_allowed_packet.\",\n       GLOBAL_VAR(opt_mts_pending_jobs_size_max), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0), DEFAULT(16 * 1024*1024),\n       BLOCK_SIZE(1024), ON_CHECK(0));\n#endif\n\nstatic bool check_locale(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  MY_LOCALE *locale;\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == INT_RESULT)\n  {\n    int lcno= (int)var->value->val_int();\n    if (!(locale= my_locale_by_number(lcno)))\n    {\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), llstr(lcno, buff));\n      return true;\n    }\n    if (check_not_null(self, thd, var))\n      return true;\n  }\n  else // STRING_RESULT\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res=var->value->val_str(&str)))\n      return true;\n    else if (!(locale= my_locale_by_name(res->c_ptr_safe())))\n    {\n      ErrConvString err(res);\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), err.ptr());\n      return true;\n    }\n  }\n\n  var->save_result.ptr= locale;\n\n  if (!locale->errmsgs->is_loaded())\n  {\n    mysql_mutex_lock(&LOCK_error_messages);\n    if (!locale->errmsgs->is_loaded() &&\n        locale->errmsgs->read_texts())\n    {\n      push_warning_printf(thd, Sql_condition::SL_WARNING, ER_UNKNOWN_ERROR,\n                          \"Can't process error message file for locale '%s'\",\n                          locale->name);\n      mysql_mutex_unlock(&LOCK_error_messages);\n      return true;\n    }\n    mysql_mutex_unlock(&LOCK_error_messages);\n  }\n  return false;\n}\nstatic Sys_var_struct Sys_lc_messages(\n       \"lc_messages\", \"Set the language used for the error messages\",\n       SESSION_VAR(lc_messages), NO_CMD_LINE,\n       my_offsetof(MY_LOCALE, name), DEFAULT(&my_default_lc_messages),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_locale));\n\nstatic Sys_var_struct Sys_lc_time_names(\n       \"lc_time_names\", \"Set the language used for the month \"\n       \"names and the days of the week\",\n       SESSION_VAR(lc_time_names), NO_CMD_LINE,\n       my_offsetof(MY_LOCALE, name), DEFAULT(&my_default_lc_time_names),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_locale));\n\nstatic Sys_var_tz Sys_time_zone(\n       \"time_zone\", \"time_zone\",\n       SESSION_VAR(time_zone), NO_CMD_LINE,\n       DEFAULT(&default_tz), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic bool fix_host_cache_size(sys_var *, THD *, enum_var_type)\n{\n  hostname_cache_resize(host_cache_size);\n  return false;\n}\n\nstatic Sys_var_uint Sys_host_cache_size(\n       \"host_cache_size\",\n       \"How many host names should be cached to avoid resolving.\",\n       GLOBAL_VAR(host_cache_size),\n       CMD_LINE(REQUIRED_ARG, OPT_HOST_CACHE_SIZE), VALID_RANGE(0, 65536),\n       DEFAULT(HOST_CACHE_SIZE),\n       BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(fix_host_cache_size));\n\nstatic Sys_var_charptr Sys_ignore_db_dirs(\n       \"ignore_db_dirs\",\n       \"The list of directories to ignore when collecting database lists\",\n       READ_ONLY GLOBAL_VAR(opt_ignore_db_dirs), \n       NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nconst Sys_var_multi_enum::ALIAS enforce_gtid_consistency_aliases[]=\n{\n  { \"OFF\", 0 },\n  { \"ON\", 1 },\n  { \"WARN\", 2 },\n  { \"FALSE\", 0 },\n  { \"TRUE\", 1 },\n  { NULL, 0 }\n};\nstatic Sys_var_enforce_gtid_consistency Sys_enforce_gtid_consistency(\n       \"enforce_gtid_consistency\",\n       \"Prevents execution of statements that would be impossible to log \"\n       \"in a transactionally safe manner. Currently, the disallowed \"\n       \"statements include CREATE TEMPORARY TABLE inside transactions, \"\n       \"all updates to non-transactional tables, and CREATE TABLE ... SELECT.\",\n       GLOBAL_VAR(_gtid_consistency_mode),\n       CMD_LINE(OPT_ARG, OPT_ENFORCE_GTID_CONSISTENCY),\n       enforce_gtid_consistency_aliases, 3,\n       DEFAULT(3/*position of \"FALSE\" in enforce_gtid_consistency_aliases*/),\n       DEFAULT(GTID_CONSISTENCY_MODE_ON),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_super_outside_trx_outside_sf_outside_sp));\nconst char *fixup_enforce_gtid_consistency_command_line(char *value_arg)\n{\n  return Sys_enforce_gtid_consistency.fixup_command_line(value_arg);\n}\n\nstatic Sys_var_mybool Sys_binlog_gtid_simple_recovery(\n       \"binlog_gtid_simple_recovery\",\n       \"If this option is enabled, the server does not open more than \"\n       \"two binary logs when initializing GTID_PURGED and \"\n       \"GTID_EXECUTED, either during server restart or when binary \"\n       \"logs are being purged. Enabling this option is useful when \"\n       \"the server has already generated many binary logs without \"\n       \"GTID events (e.g., having GTID_MODE = OFF). Note: If this \"\n       \"option is enabled, GLOBAL.GTID_EXECUTED and \"\n       \"GLOBAL.GTID_PURGED may be initialized wrongly in two cases: \"\n       \"(1) All binary logs were generated by MySQL 5.7.5 or older, \"\n       \"and GTID_MODE was ON for some binary logs but OFF for the \"\n       \"newest binary log. (2) The oldest existing binary log was \"\n       \"generated by MySQL 5.7.5 or older, and SET GTID_PURGED was \"\n       \"issued after the oldest binary log was generated. If a wrong \"\n       \"set is computed in one of case (1) or case (2), it will \"\n       \"remain wrong even if the server is later restarted with this \"\n       \"option disabled.\",\n       READ_ONLY GLOBAL_VAR(binlog_gtid_simple_recovery),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_sp_cache_size(\n       \"stored_program_cache\",\n       \"The soft upper limit for number of cached stored routines for \"\n       \"one connection.\",\n       GLOBAL_VAR(stored_program_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(16, 512 * 1024), DEFAULT(256), BLOCK_SIZE(1));\n\nstatic bool check_pseudo_slave_mode(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_outside_trx(self, thd, var))\n    return true;\n  longlong previous_val= thd->variables.pseudo_slave_mode;\n  longlong val= (longlong) var->save_result.ulonglong_value;\n  bool rli_fake= false;\n\n#ifndef EMBEDDED_LIBRARY\n  rli_fake= thd->rli_fake ? true : false;\n#endif\n\n  if (rli_fake)\n  {\n    if (!val)\n    {\n#ifndef EMBEDDED_LIBRARY\n      thd->rli_fake->end_info();\n      delete thd->rli_fake;\n      thd->rli_fake= NULL;\n#endif\n    }\n    else if (previous_val && val)\n      goto ineffective;\n    else if (!previous_val && val)\n      push_warning(thd, Sql_condition::SL_WARNING,\n                   ER_WRONG_VALUE_FOR_VAR,\n                   \"'pseudo_slave_mode' is already ON.\");\n  }\n  else\n  {\n    if (!previous_val && !val)\n      goto ineffective;\n    else if (previous_val && !val)\n      push_warning(thd, Sql_condition::SL_WARNING,\n                   ER_WRONG_VALUE_FOR_VAR,\n                   \"Slave applier execution mode not active, \"\n                   \"statement ineffective.\");\n  }\n  goto end;\n\nineffective:\n  push_warning(thd, Sql_condition::SL_WARNING,\n               ER_WRONG_VALUE_FOR_VAR,\n               \"'pseudo_slave_mode' change was ineffective.\");\n\nend:\n  return FALSE;\n}\nstatic Sys_var_mybool Sys_pseudo_slave_mode(\n       \"pseudo_slave_mode\",\n       \"SET pseudo_slave_mode= 0,1 are commands that mysqlbinlog \"\n       \"adds to beginning and end of binary log dumps. While zero \"\n       \"value indeed disables, the actual enabling of the slave \"\n       \"applier execution mode is done implicitly when a \"\n       \"Format_description_event is sent through the session.\",\n       SESSION_ONLY(pseudo_slave_mode), NO_CMD_LINE, DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_pseudo_slave_mode));\n\n\n#ifdef HAVE_REPLICATION\n#ifdef HAVE_GTID_NEXT_LIST\nstatic bool check_gtid_next_list(sys_var *self, THD *thd, set_var *var)\n{\n  DBUG_ENTER(\"check_gtid_next_list\");\n  my_error(ER_NOT_SUPPORTED_YET, MYF(0), \"GTID_NEXT_LIST\");\n  if (check_super_outside_trx_outside_sf_outside_sp(self, thd, var))\n    DBUG_RETURN(true);\n  /*\n    @todo: move this check into the set function and hold the lock on\n    gtid_mode_lock until the operation has completed, so that we are\n    sure a concurrent connection does not change gtid_mode between\n    check and fix - if we ever implement this variable.\n  */\n  if (get_gtid_mode(GTID_MODE_LOCK_NONE) == GTID_MODE_OFF &&\n      var->save_result.string_value.str != NULL)\n    my_error(ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF,\n             MYF(0));\n  DBUG_RETURN(false);\n}\n\nstatic bool update_gtid_next_list(sys_var *self, THD *thd, enum_var_type type)\n{\n  DBUG_ASSERT(type == OPT_SESSION);\n  if (thd->get_gtid_next_list() != NULL)\n    return gtid_acquire_ownership_multiple(thd) != 0 ? true : false;\n  return false;\n}\n\nstatic Sys_var_gtid_set Sys_gtid_next_list(\n       \"gtid_next_list\",\n       \"Before re-executing a transaction that contains multiple \"\n       \"Global Transaction Identifiers, this variable must be set \"\n       \"to the set of all re-executed transactions.\",\n       SESSION_ONLY(gtid_next_list), NO_CMD_LINE,\n       DEFAULT(NULL), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_gtid_next_list),\n       ON_UPDATE(update_gtid_next_list)\n);\nexport sys_var *Sys_gtid_next_list_ptr= &Sys_gtid_next_list;\n#endif //HAVE_GTID_NEXT_LIST\n\nstatic Sys_var_gtid_next Sys_gtid_next(\n       \"gtid_next\",\n       \"Specifies the Global Transaction Identifier for the following \"\n       \"transaction.\",\n       SESSION_ONLY(gtid_next), NO_CMD_LINE,\n       DEFAULT(\"AUTOMATIC\"), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_gtid_next));\nexport sys_var *Sys_gtid_next_ptr= &Sys_gtid_next;\n\nstatic Sys_var_gtid_executed Sys_gtid_executed(\n       \"gtid_executed\",\n       \"The global variable contains the set of GTIDs in the \"\n       \"binary log. The session variable contains the set of GTIDs \"\n       \"in the current, ongoing transaction.\");\n\nstatic bool check_gtid_purged(sys_var *self, THD *thd, set_var *var)\n{\n  DBUG_ENTER(\"check_gtid_purged\");\n\n  if (!var->value ||\n      check_super_outside_trx_outside_sf_outside_sp(self, thd, var))\n    DBUG_RETURN(true);\n\n  if (var->value->result_type() != STRING_RESULT ||\n      !var->save_result.string_value.str)\n    DBUG_RETURN(true);\n\n  DBUG_RETURN(false);\n}\n\nbool Sys_var_gtid_purged::global_update(THD *thd, set_var *var)\n{\n  DBUG_ENTER(\"Sys_var_gtid_purged::global_update\");\n#ifdef HAVE_REPLICATION\n  bool error= false;\n\n  global_sid_lock->wrlock();\n\n  /*\n    ensures the commit of the transaction started when saving the\n    purged gtid set in the table\n  */\n  thd->lex->autocommit= true;\n  /*\n    SET GITD_PURGED command should ignore 'read-only' and 'super_read_only'\n    options so that it can update 'mysql.gtid_executed' replication repository\n    table.\n  */\n  thd->set_skip_readonly_check();\n  char *previous_gtid_executed= NULL, *previous_gtid_purged= NULL,\n    *current_gtid_executed= NULL, *current_gtid_purged= NULL;\n  gtid_state->get_executed_gtids()->to_string(&previous_gtid_executed);\n  gtid_state->get_lost_gtids()->to_string(&previous_gtid_purged);\n  enum_return_status ret;\n  Gtid_set gtid_set(global_sid_map, var->save_result.string_value.str,\n                    &ret, global_sid_lock);\n  if (ret != RETURN_STATUS_OK)\n  {\n    global_sid_lock->unlock();\n    error= true;\n    goto end;\n  }\n  ret= gtid_state->add_lost_gtids(&gtid_set);\n  if (ret != RETURN_STATUS_OK)\n  {\n    global_sid_lock->unlock();\n    error= true;\n    goto end;\n  }\n  gtid_state->get_executed_gtids()->to_string(&current_gtid_executed);\n  gtid_state->get_lost_gtids()->to_string(&current_gtid_purged);\n  global_sid_lock->unlock();\n\n  // Log messages saying that GTID_PURGED and GTID_EXECUTED were changed.\n  sql_print_information(ER(ER_GTID_PURGED_WAS_CHANGED),\n                        previous_gtid_purged, current_gtid_purged);\n  sql_print_information(ER(ER_GTID_EXECUTED_WAS_CHANGED),\n                        previous_gtid_executed, current_gtid_executed);\n\nend:\n  my_free(previous_gtid_executed);\n  my_free(previous_gtid_purged);\n  my_free(current_gtid_executed);\n  my_free(current_gtid_purged);\n  DBUG_RETURN(error);\n#else\n  DBUG_RETURN(true);\n#endif /* HAVE_REPLICATION */\n}\n\nGtid_set *gtid_purged;\nstatic Sys_var_gtid_purged Sys_gtid_purged(\n       \"gtid_purged\",\n       \"The set of GTIDs that existed in previous, purged binary logs.\",\n       GLOBAL_VAR(gtid_purged), NO_CMD_LINE,\n       DEFAULT(NULL), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_gtid_purged));\nexport sys_var *Sys_gtid_purged_ptr= &Sys_gtid_purged;\n\nstatic Sys_var_gtid_owned Sys_gtid_owned(\n       \"gtid_owned\",\n       \"The global variable lists all GTIDs owned by all threads. \"\n       \"The session variable lists all GTIDs owned by the current thread.\");\n\nstatic Sys_var_gtid_mode Sys_gtid_mode(\n       \"gtid_mode\",\n       \"Controls whether Global Transaction Identifiers (GTIDs) are \"\n       \"enabled. Can be OFF, OFF_PERMISSIVE, ON_PERMISSIVE, or ON. OFF \"\n       \"means that no transaction has a GTID. OFF_PERMISSIVE means that \"\n       \"new transactions (committed in a client session using \"\n       \"GTID_NEXT='AUTOMATIC') are not assigned any GTID, and \"\n       \"replicated transactions are allowed to have or not have a \"\n       \"GTID. ON_PERMISSIVE means that new transactions are assigned a \"\n       \"GTID, and replicated transactions are allowed to have or not \"\n       \"have a GTID. ON means that all transactions have a GTID. \"\n       \"ON is required on a master before any slave can use \"\n       \"MASTER_AUTO_POSITION=1. To safely switch from OFF to ON, first \"\n       \"set all servers to OFF_PERMISSIVE, then set all servers to \"\n       \"ON_PERMISSIVE, then wait for all transactions without a GTID to \"\n       \"be replicated and executed on all servers, and finally set all \"\n       \"servers to GTID_MODE = ON.\",\n       GLOBAL_VAR(_gtid_mode), CMD_LINE(REQUIRED_ARG), gtid_mode_names,\n       DEFAULT(GTID_MODE_OFF), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_super_outside_trx_outside_sf_outside_sp));\n\n#endif // HAVE_REPLICATION\n\nstatic Sys_var_uint Sys_gtid_executed_compression_period(\n       \"gtid_executed_compression_period\", \"When binlog is disabled, \"\n       \"a background thread wakes up to compress the gtid_executed table \"\n       \"every gtid_executed_compression_period transactions, as a \"\n       \"special case, if variable is 0, the thread never wakes up \"\n       \"to compress the gtid_executed table.\",\n       GLOBAL_VAR(gtid_executed_compression_period),\n       CMD_LINE(OPT_ARG), VALID_RANGE(0, UINT_MAX32), DEFAULT(1000),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_disconnect_on_expired_password(\n       \"disconnect_on_expired_password\",\n       \"Give clients that don't signal password expiration support execution time error(s) instead of connection error\",\n       READ_ONLY GLOBAL_VAR(disconnect_on_expired_password),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\n#ifndef NO_EMBEDDED_ACCESS_CHECKS \nstatic Sys_var_mybool Sys_validate_user_plugins(\n       \"validate_user_plugins\",\n       \"Turns on additional validation of authentication plugins assigned \"\n       \"to user accounts. \",\n       READ_ONLY NOT_VISIBLE GLOBAL_VAR(validate_user_plugins),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG);\n#endif\n\nstatic Sys_var_enum Sys_block_encryption_mode(\n  \"block_encryption_mode\", \"mode for AES_ENCRYPT/AES_DECRYPT\",\n  SESSION_VAR(my_aes_mode), CMD_LINE(REQUIRED_ARG),\n  my_aes_opmode_names, DEFAULT(my_aes_128_ecb));\n\nstatic bool check_track_session_sys_vars(sys_var *self, THD *thd, set_var *var)\n{\n  DBUG_ENTER(\"check_sysvar_change_reporter\");\n  DBUG_RETURN(thd->session_tracker.get_tracker(SESSION_SYSVARS_TRACKER)->check(thd, var));\n  DBUG_RETURN(false);\n}\n\nstatic bool update_track_session_sys_vars(sys_var *self, THD *thd,\n                                          enum_var_type type)\n{\n  DBUG_ENTER(\"check_sysvar_change_reporter\");\n  /* Populate map only for session variable. */\n  if (type == OPT_SESSION)\n    DBUG_RETURN(thd->session_tracker.get_tracker(SESSION_SYSVARS_TRACKER)->update(thd));\n  DBUG_RETURN(false);\n}\n\nstatic Sys_var_charptr Sys_track_session_sys_vars(\n       \"session_track_system_variables\",\n       \"Track changes in registered system variables.\",\n       SESSION_VAR(track_sysvars_ptr),\n       CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET,\n       DEFAULT(\"time_zone,autocommit,character_set_client,character_set_results,\"\n               \"character_set_connection\"),\n       NO_MUTEX_GUARD,\n       NOT_IN_BINLOG,\n       ON_CHECK(check_track_session_sys_vars),\n       ON_UPDATE(update_track_session_sys_vars)\n);\n\nstatic bool update_session_track_schema(sys_var *self, THD *thd,\n                                        enum_var_type type)\n{\n  DBUG_ENTER(\"update_session_track_schema\");\n  DBUG_RETURN(thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)->update(thd));\n}\n\nstatic Sys_var_mybool Sys_session_track_schema(\n       \"session_track_schema\",\n       \"Track changes to the 'default schema'.\",\n       SESSION_VAR(session_track_schema),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0),\n       ON_UPDATE(update_session_track_schema));\n\nstatic bool update_session_track_tx_info(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  DBUG_ENTER(\"update_session_track_tx_info\");\n  DBUG_RETURN(thd->session_tracker.get_tracker(TRANSACTION_INFO_TRACKER)->update(thd));\n}\n\nstatic const char *session_track_transaction_info_names[]=\n  { \"OFF\", \"STATE\", \"CHARACTERISTICS\", NullS };\n\nstatic Sys_var_enum Sys_session_track_transaction_info(\n       \"session_track_transaction_info\",\n       \"Track changes to the transaction attributes. OFF to disable; \"\n       \"STATE to track just transaction state (Is there an active transaction? \"\n       \"Does it have any data? etc.); CHARACTERISTICS to track transaction \"\n       \"state \"\n       \"and report all statements needed to start a transaction with the same \"\n       \"characteristics (isolation level, read only/read write, snapshot - \"\n       \"but not any work done / data modified within the transaction).\",\n       SESSION_VAR(session_track_transaction_info),\n       CMD_LINE(REQUIRED_ARG), session_track_transaction_info_names,\n       DEFAULT(OFF), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_session_track_tx_info));\n\nstatic bool update_session_track_state_change(sys_var *self, THD *thd,\n                                              enum_var_type type)\n{\n  DBUG_ENTER(\"update_session_track_state_change\");\n  DBUG_RETURN(thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)->update(thd));\n}\n\nstatic Sys_var_mybool Sys_session_track_state_change(\n       \"session_track_state_change\",\n       \"Track changes to the 'session state'.\",\n       SESSION_VAR(session_track_state_change),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0),\n       ON_UPDATE(update_session_track_state_change));\n\nstatic bool handle_offline_mode(sys_var *self, THD *thd, enum_var_type type)\n{\n  DBUG_ENTER(\"handle_offline_mode\");\n  if (offline_mode == TRUE)\n    killall_non_super_threads(thd);\n  DBUG_RETURN(false);\n}\n\nstatic PolyLock_mutex PLock_offline_mode(&LOCK_offline_mode);\nstatic Sys_var_mybool Sys_offline_mode(\n       \"offline_mode\",\n       \"Make the server into offline mode\",\n       GLOBAL_VAR(offline_mode), CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       &PLock_offline_mode, NOT_IN_BINLOG,\n       ON_CHECK(0), ON_UPDATE(handle_offline_mode));\n\nstatic Sys_var_mybool Sys_log_builtin_as_identified_by_password(\n       \"log_builtin_as_identified_by_password\",\n       \"Controls logging of CREATE/ALTER/GRANT and SET PASSWORD user statements \"\n       \"in replication binlogs, general query logs and audit logs.\",\n       GLOBAL_VAR(opt_log_builtin_as_identified_by_password),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_avoid_temporal_upgrade(\n       \"avoid_temporal_upgrade\",\n       \"When this option is enabled, the pre-5.6.4 temporal types are \"\n       \"not upgraded to the new format for ALTER TABLE requests ADD/CHANGE/MODIFY\"\n       \" COLUMN, ADD INDEX or FORCE operation. \"\n       \"This variable is deprecated and will be removed in a future release.\",\n        GLOBAL_VAR(avoid_temporal_upgrade),\n        CMD_LINE(OPT_ARG, OPT_AVOID_TEMPORAL_UPGRADE),\n        DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n        ON_CHECK(0), ON_UPDATE(0),\n        DEPRECATED(\"\"));\n\nstatic Sys_var_mybool Sys_show_old_temporals(\n       \"show_old_temporals\",\n       \"When this option is enabled, the pre-5.6.4 temporal types will \"\n       \"be marked in the 'SHOW CREATE TABLE' and 'INFORMATION_SCHEMA.COLUMNS' \"\n       \"table as a comment in COLUMN_TYPE field. \"\n       \"This variable is deprecated and will be removed in a future release.\",\n        SESSION_VAR(show_old_temporals),\n        CMD_LINE(OPT_ARG, OPT_SHOW_OLD_TEMPORALS),\n        DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n        ON_CHECK(0), ON_UPDATE(0),\n        DEPRECATED(\"\"));\n\nstatic Sys_var_charptr Sys_disabled_storage_engines(\n       \"disabled_storage_engines\",\n       \"Limit CREATE TABLE for the storage engines listed\",\n       READ_ONLY GLOBAL_VAR(opt_disabled_storage_engines),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"));\n\nstatic bool check_keyring_access(sys_var*, THD* thd, set_var*)\n{\n  if (!(thd->security_context()->check_access(SUPER_ACL)))\n  {\n    my_error(ER_KEYRING_ACCESS_DENIED_ERROR, MYF(0),\n             \"SUPER\");\n    return true;\n  }\n  return false;\n}\n\n/**\n  This is a mutex used to protect global variable @@keyring_operations.\n*/\nstatic PolyLock_mutex PLock_keyring_operations(&LOCK_keyring_operations);\n/**\n  This variable provides access to keyring service APIs. When this variable\n  is disabled calls to keyring_key_generate(), keyring_key_store() and\n  keyring_key_remove() will report error until this variable is enabled.\n  This variable is protected under a mutex named PLock_keyring_operations.\n  To access this variable you must first set this mutex.\n\n  @sa PLock_keyring_operations\n*/\nstatic Sys_var_mybool Sys_keyring_operations(\n       \"keyring_operations\",\n       \"This variable provides access to keyring service APIs. When this \"\n       \"option is disabled calls to keyring_key_generate(), keyring_key_store() \"\n       \"and keyring_key_remove() will report error until this variable is enabled.\",\n       GLOBAL_VAR(opt_keyring_operations),\n       NO_CMD_LINE, DEFAULT(TRUE),\n       &PLock_keyring_operations,\n       NOT_IN_BINLOG,\n       ON_CHECK(check_keyring_access),\n       ON_UPDATE(0));\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/sql/set_var.h": "#ifndef SET_VAR_INCLUDED\n#define SET_VAR_INCLUDED\n/* Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n  \"public\" interface to sys_var - server configuration variables.\n*/\n#include \"my_global.h\"\n\n#include \"m_string.h\"         // LEX_CSTRING\n#include \"my_getopt.h\"        // get_opt_arg_type\n#include \"mysql_com.h\"        // Item_result\n#include \"typelib.h\"          // TYPELIB\n#include \"mysql/plugin.h\"     // enum_mysql_show_type\n#include \"sql_alloc.h\"        // Sql_alloc\n#include \"sql_const.h\"        // SHOW_COMP_OPTION\n#include \"sql_plugin_ref.h\"   // plugin_ref\n#include \"prealloced_array.h\" // Prealloced_array\n\n#include <vector>\n\nclass sys_var;\nclass set_var;\nclass sys_var_pluginvar;\nclass PolyLock;\nclass Item_func_set_user_var;\nclass String;\nclass Time_zone;\nclass THD;\nstruct st_lex_user;\ntypedef ulonglong sql_mode_t;\ntypedef enum enum_mysql_show_type SHOW_TYPE;\ntypedef enum enum_mysql_show_scope SHOW_SCOPE;\ntypedef struct st_mysql_show_var SHOW_VAR;\ntemplate <class T> class List;\n\nextern TYPELIB bool_typelib;\n\n/* Number of system variable elements to preallocate. */\n#define SHOW_VAR_PREALLOC 200\ntypedef Prealloced_array<SHOW_VAR, SHOW_VAR_PREALLOC, false> Show_var_array;\n\nstruct sys_var_chain\n{\n  sys_var *first;\n  sys_var *last;\n};\n\nint mysql_add_sys_var_chain(sys_var *chain);\nint mysql_del_sys_var_chain(sys_var *chain);\n\nenum enum_var_type\n{\n  OPT_DEFAULT= 0, OPT_SESSION, OPT_GLOBAL\n};\n\n/**\n  A class representing one system variable - that is something\n  that can be accessed as @@global.variable_name or @@session.variable_name,\n  visible in SHOW xxx VARIABLES and in INFORMATION_SCHEMA.xxx_VARIABLES,\n  optionally it can be assigned to, optionally it can have a command-line\n  counterpart with the same name.\n*/\nclass sys_var\n{\npublic:\n  sys_var *next;\n  LEX_CSTRING name;\n  enum flag_enum\n  {\n    GLOBAL=       0x0001,\n    SESSION=      0x0002,\n    ONLY_SESSION= 0x0004,\n    SCOPE_MASK=   0x03FF, // 1023\n    READONLY=     0x0400, // 1024\n    ALLOCATED=    0x0800, // 2048\n    INVISIBLE=    0x1000, // 4096\n    TRI_LEVEL=    0x2000  // 8192 - default is neither GLOBAL nor SESSION\n  };\n  static const int PARSE_EARLY= 1;\n  static const int PARSE_NORMAL= 2;\n  /**\n    Enumeration type to indicate for a system variable whether\n    it will be written to the binlog or not.\n  */    \n  enum binlog_status_enum { VARIABLE_NOT_IN_BINLOG,\n                            SESSION_VARIABLE_IN_BINLOG } binlog_status;\n\nprotected:\n  typedef bool (*on_check_function)(sys_var *self, THD *thd, set_var *var);\n  typedef bool (*on_update_function)(sys_var *self, THD *thd, enum_var_type type);\n\n  int flags;            ///< or'ed flag_enum values\n  int m_parse_flag;     ///< either PARSE_EARLY or PARSE_NORMAL.\n  const SHOW_TYPE show_val_type; ///< what value_ptr() returns for sql_show.cc\n  my_option option;     ///< min, max, default values are stored here\n  PolyLock *guard;      ///< *second* lock that protects the variable\n  ptrdiff_t offset;     ///< offset to the value from global_system_variables\n  on_check_function on_check;\n  on_update_function on_update;\n  const char *const deprecation_substitute;\n  bool is_os_charset; ///< true if the value is in character_set_filesystem\n\npublic:\n  sys_var(sys_var_chain *chain, const char *name_arg, const char *comment,\n          int flag_args, ptrdiff_t off, int getopt_id,\n          enum get_opt_arg_type getopt_arg_type, SHOW_TYPE show_val_type_arg,\n          longlong def_val, PolyLock *lock, enum binlog_status_enum binlog_status_arg,\n          on_check_function on_check_func, on_update_function on_update_func,\n          const char *substitute, int parse_flag);\n\n  virtual ~sys_var() {}\n\n  /**\n    All the cleanup procedures should be performed here\n  */\n  virtual void cleanup() {}\n  /**\n    downcast for sys_var_pluginvar. Returns this if it's an instance\n    of sys_var_pluginvar, and 0 otherwise.\n  */\n  virtual sys_var_pluginvar *cast_pluginvar() { return 0; }\n\n  bool check(THD *thd, set_var *var);\n  uchar *value_ptr(THD *running_thd, THD *target_thd, enum_var_type type, LEX_STRING *base);\n  uchar *value_ptr(THD *thd, enum_var_type type, LEX_STRING *base);\n  virtual void update_default(longlong new_def_value)\n  { option.def_value= new_def_value; }\n\n  /**\n     Update the system variable with the default value from either\n     session or global scope.  The default value is stored in the\n     'var' argument. Return false when successful.\n  */\n  bool set_default(THD *thd, set_var *var);\n  bool update(THD *thd, set_var *var);\n\n  SHOW_TYPE show_type() { return show_val_type; }\n  int scope() const { return flags & SCOPE_MASK; }\n  const CHARSET_INFO *charset(THD *thd);\n  bool is_readonly() const { return flags & READONLY; }\n  bool not_visible() const { return flags & INVISIBLE; }\n  bool is_trilevel() const { return flags & TRI_LEVEL; }\n  /**\n    the following is only true for keycache variables,\n    that support the syntax @@keycache_name.variable_name\n  */\n  bool is_struct() { return option.var_type & GET_ASK_ADDR; }\n  bool is_written_to_binlog(enum_var_type type)\n  { return type != OPT_GLOBAL && binlog_status == SESSION_VARIABLE_IN_BINLOG; }\n  virtual bool check_update_type(Item_result type) = 0;\n  \n  /**\n    Return TRUE for success if:\n      Global query and variable scope is GLOBAL or SESSION, or\n      Session query and variable scope is SESSION or ONLY_SESSION.\n  */\n  bool check_scope(enum_var_type query_type)\n  {\n    switch (query_type)\n    {\n      case OPT_GLOBAL:  return scope() & (GLOBAL | SESSION);\n      case OPT_SESSION: return scope() & (SESSION | ONLY_SESSION);\n      case OPT_DEFAULT: return scope() & (SESSION | ONLY_SESSION);\n    }\n    return false;\n  }\n\n  bool register_option(std::vector<my_option> *array, int parse_flags)\n  {\n    return (option.id != -1) && (m_parse_flag & parse_flags) &&\n      (array->push_back(option), false);\n  }\n  void do_deprecated_warning(THD *thd);\n\nprivate:\n  virtual bool do_check(THD *thd, set_var *var) = 0;\n  /**\n    save the session default value of the variable in var\n  */\n  virtual void session_save_default(THD *thd, set_var *var) = 0;\n  /**\n    save the global default value of the variable in var\n  */\n  virtual void global_save_default(THD *thd, set_var *var) = 0;\n  virtual bool session_update(THD *thd, set_var *var) = 0;\n  virtual bool global_update(THD *thd, set_var *var) = 0;\nprotected:\n  /**\n    A pointer to a value of the variable for SHOW.\n    It must be of show_val_type type (bool for SHOW_BOOL, int for SHOW_INT,\n    longlong for SHOW_LONGLONG, etc).\n  */\n  virtual uchar *session_value_ptr(THD *running_thd, THD *target_thd, LEX_STRING *base);\n  virtual uchar *global_value_ptr(THD *thd, LEX_STRING *base);\n\n  /**\n    A pointer to a storage area of the variable, to the raw data.\n    Typically it's the same as session_value_ptr(), but it's different,\n    for example, for ENUM, that is printed as a string, but stored as a number.\n  */\n  uchar *session_var_ptr(THD *thd);\n\n  uchar *global_var_ptr();\n};\n\n/****************************************************************************\n  Classes for parsing of the SET command\n****************************************************************************/\n\n/**\n  A base class for everything that can be set with SET command.\n  It's similar to Items, an instance of this is created by the parser\n  for every assigmnent in SET (or elsewhere, e.g. in SELECT).\n*/\nclass set_var_base :public Sql_alloc\n{\npublic:\n  set_var_base() {}\n  virtual ~set_var_base() {}\n  virtual int check(THD *thd)=0;           /* To check privileges etc. */\n  virtual int update(THD *thd)=0;                  /* To set the value */\n  virtual int light_check(THD *thd) { return check(thd); }   /* for PS */\n  virtual void print(THD *thd, String *str)=0;\t/* To self-print */\n  /// @returns whether this variable is @@@@optimizer_trace.\n  virtual bool is_var_optimizer_trace() const { return false; }\n};\n\n\n/**\n  set_var_base descendant for assignments to the system variables.\n*/\nclass set_var :public set_var_base\n{\npublic:\n  sys_var *var; ///< system variable to be updated\n  Item *value;  ///< the expression that provides the new value of the variable\n  enum_var_type type;\n  union ///< temp storage to hold a value between sys_var::check and ::update\n  {\n    ulonglong ulonglong_value;          ///< for all integer, set, enum sysvars\n    double double_value;                ///< for Sys_var_double\n    plugin_ref plugin;                  ///< for Sys_var_plugin\n    Time_zone *time_zone;               ///< for Sys_var_tz\n    LEX_STRING string_value;            ///< for Sys_var_charptr and others\n    const void *ptr;                    ///< for Sys_var_struct\n  } save_result;\n  LEX_STRING base; /**< for structured variables, like keycache_name.variable_name */\n\n  set_var(enum_var_type type_arg, sys_var *var_arg,\n          const LEX_STRING *base_name_arg, Item *value_arg);\n\n  int check(THD *thd);\n  int update(THD *thd);\n  int light_check(THD *thd);\n  void print(THD *thd, String *str);\t/* To self-print */\n#ifdef OPTIMIZER_TRACE\n  virtual bool is_var_optimizer_trace() const\n  {\n    extern sys_var *Sys_optimizer_trace_ptr;\n    return var == Sys_optimizer_trace_ptr;\n  }\n#endif\n};\n\n\n/* User variables like @my_own_variable */\nclass set_var_user: public set_var_base\n{\n  Item_func_set_user_var *user_var_item;\npublic:\n  set_var_user(Item_func_set_user_var *item)\n    :user_var_item(item)\n  {}\n  int check(THD *thd);\n  int update(THD *thd);\n  int light_check(THD *thd);\n  void print(THD *thd, String *str);\t/* To self-print */\n};\n\n/* For SET PASSWORD */\n\nclass set_var_password: public set_var_base\n{\n  st_lex_user *user;\n  char *password;\npublic:\n  set_var_password(st_lex_user *user_arg,char *password_arg)\n    :user(user_arg), password(password_arg)\n  {}\n  int check(THD *thd);\n  int update(THD *thd);\n  void print(THD *thd, String *str);\t/* To self-print */\n};\n\n\n/* For SET NAMES and SET CHARACTER SET */\n\nclass set_var_collation_client: public set_var_base\n{\n  int   set_cs_flags;\n  const CHARSET_INFO *character_set_client;\n  const CHARSET_INFO *character_set_results;\n  const CHARSET_INFO *collation_connection;\npublic:\n  enum  set_cs_flags_enum { SET_CS_NAMES=1, SET_CS_DEFAULT=2, SET_CS_COLLATE=4 };\n  set_var_collation_client(int set_cs_flags_arg,\n                           const CHARSET_INFO *client_coll_arg,\n                           const CHARSET_INFO *connection_coll_arg,\n                           const CHARSET_INFO *result_coll_arg)\n    :set_cs_flags(set_cs_flags_arg),\n     character_set_client(client_coll_arg),\n     character_set_results(result_coll_arg),\n     collation_connection(connection_coll_arg)\n  {}\n  int check(THD *thd);\n  int update(THD *thd);\n  void print(THD *thd, String *str);\t/* To self-print */\n};\n\n\n/* optional things, have_* variables */\nextern SHOW_COMP_OPTION have_ndbcluster, have_partitioning;\nextern SHOW_COMP_OPTION have_profiling;\n\nextern SHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen;\nextern SHOW_COMP_OPTION have_query_cache;\nextern SHOW_COMP_OPTION have_geometry, have_rtree_keys;\nextern SHOW_COMP_OPTION have_crypt;\nextern SHOW_COMP_OPTION have_compress;\nextern SHOW_COMP_OPTION have_statement_timeout;\n\n/*\n  Helper functions\n*/\nulong get_system_variable_hash_records(void);\nulonglong get_system_variable_hash_version(void);\n\nbool enumerate_sys_vars(THD *thd, Show_var_array *show_var_array,\n                        bool sort, enum enum_var_type type, bool strict);\nvoid lock_plugin_mutex();\nvoid unlock_plugin_mutex();\nsys_var *find_sys_var(THD *thd, const char *str, size_t length=0);\nsys_var *find_sys_var_ex(THD *thd, const char *str, size_t length=0,\n                         bool throw_error= false, bool locked= false);\nint sql_set_variables(THD *thd, List<set_var_base> *var_list);\n\nbool fix_delay_key_write(sys_var *self, THD *thd, enum_var_type type);\nbool keyring_access_test();\nsql_mode_t expand_sql_mode(sql_mode_t sql_mode, THD *thd);\nbool sql_mode_string_representation(THD *thd, sql_mode_t sql_mode, LEX_STRING *ls);\nvoid update_parser_max_mem_size();\n\nextern sys_var *Sys_autocommit_ptr;\nextern sys_var *Sys_gtid_next_ptr;\nextern sys_var *Sys_gtid_next_list_ptr;\nextern sys_var *Sys_gtid_purged_ptr;\n\nconst CHARSET_INFO *get_old_charset_by_name(const char *old_name);\n\nint sys_var_init();\nint sys_var_add_options(std::vector<my_option> *long_options, int parse_flags);\nvoid sys_var_end(void);\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/sql/sql_udf.cc": "/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software Foundation,\n   51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA */\n\n/* This implements 'user defined functions' */\n\n/*\n   Known bugs:\n  \n   Memory for functions is never freed!\n   Shared libraries are not closed before mysqld exits;\n     - This is because we can't be sure if some threads are using\n       a function.\n  \n   The bugs only affect applications that create and free a lot of\n   dynamic functions, so this shouldn't be a real problem.\n*/\n\n#include \"sql_base.h\"                           // close_mysql_tables\n#include \"sql_parse.h\"                        // check_string_char_length\n#include \"sql_table.h\"                        // write_bin_log\n#include \"records.h\"          // init_read_record, end_read_record\n#include \"lock.h\"                               // MYSQL_LOCK_IGNORE_TIMEOUT\n#include \"log.h\"\n#include \"sql_plugin.h\"                         // check_valid_path\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#ifdef HAVE_DLOPEN\n#include <stdarg.h>\n#include <hash.h>\n\nstatic bool initialized = 0;\nstatic MEM_ROOT mem;\nstatic HASH udf_hash;\nstatic mysql_rwlock_t THR_LOCK_udf;\n\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret,\n                         char *dl, Item_udftype typ);\nstatic void del_udf(udf_func *udf);\nstatic void *find_udf_dl(const char *dl);\n\nstatic char *init_syms(udf_func *tmp, char *nm)\n{\n  char *end;\n\n  if (!((tmp->func= (Udf_func_any) dlsym(tmp->dlhandle, tmp->name.str))))\n    return tmp->name.str;\n\n  end=my_stpcpy(nm,tmp->name.str);\n\n  if (tmp->type == UDFTYPE_AGGREGATE)\n  {\n    (void)my_stpcpy(end, \"_clear\");\n    if (!((tmp->func_clear= (Udf_func_clear) dlsym(tmp->dlhandle, nm))))\n      return nm;\n    (void)my_stpcpy(end, \"_add\");\n    if (!((tmp->func_add= (Udf_func_add) dlsym(tmp->dlhandle, nm))))\n      return nm;\n  }\n\n  (void) my_stpcpy(end,\"_deinit\");\n  tmp->func_deinit= (Udf_func_deinit) dlsym(tmp->dlhandle, nm);\n\n  (void) my_stpcpy(end,\"_init\");\n  tmp->func_init= (Udf_func_init) dlsym(tmp->dlhandle, nm);\n\n  /*\n    to prefent loading \"udf\" from, e.g. libc.so\n    let's ensure that at least one auxiliary symbol is defined\n  */\n  if (!tmp->func_init && !tmp->func_deinit && tmp->type != UDFTYPE_AGGREGATE)\n  {\n    if (!opt_allow_suspicious_udfs)\n      return nm;\n    sql_print_warning(ER(ER_CANT_FIND_DL_ENTRY), nm);\n  }\n  return 0;\n}\n\n\nextern \"C\" uchar* get_hash_key(const uchar *buff, size_t *length,\n\t\t\t      my_bool not_used MY_ATTRIBUTE((unused)))\n{\n  udf_func *udf=(udf_func*) buff;\n  *length=(uint) udf->name.length;\n  return (uchar*) udf->name.str;\n}\n\nstatic PSI_memory_key key_memory_udf_mem;\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_rwlock_key key_rwlock_THR_LOCK_udf;\n\nstatic PSI_rwlock_info all_udf_rwlocks[]=\n{\n  { &key_rwlock_THR_LOCK_udf, \"THR_LOCK_udf\", PSI_FLAG_GLOBAL}\n};\n\nstatic PSI_memory_info all_udf_memory[]=\n{\n  { &key_memory_udf_mem, \"udf_mem\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_udf_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  count= array_elements(all_udf_rwlocks);\n  mysql_rwlock_register(category, all_udf_rwlocks, count);\n\n  count= array_elements(all_udf_memory);\n  mysql_memory_register(category, all_udf_memory, count);\n}\n#endif\n\n/*\n  Read all predeclared functions from mysql.func and accept all that\n  can be used.\n*/\n\nvoid udf_init()\n{\n  udf_func *tmp;\n  TABLE_LIST tables;\n  READ_RECORD read_record_info;\n  TABLE *table;\n  int error;\n  DBUG_ENTER(\"ufd_init\");\n  char db[]= \"mysql\"; /* A subject to casednstr, can't be constant */\n\n  if (initialized)\n    DBUG_VOID_RETURN;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_udf_psi_keys();\n#endif\n\n  mysql_rwlock_init(key_rwlock_THR_LOCK_udf, &THR_LOCK_udf);\n\n  init_sql_alloc(key_memory_udf_mem, &mem, UDF_ALLOC_BLOCK_SIZE, 0);\n  THD *new_thd = new THD;\n  if (!new_thd ||\n      my_hash_init(&udf_hash,system_charset_info,32,0,0,get_hash_key, NULL, 0,\n                   key_memory_udf_mem))\n  {\n    sql_print_error(\"Can't allocate memory for udf structures\");\n    my_hash_free(&udf_hash);\n    free_root(&mem,MYF(0));\n    delete new_thd;\n    DBUG_VOID_RETURN;\n  }\n  initialized = 1;\n  new_thd->thread_stack= (char*) &new_thd;\n  new_thd->store_globals();\n  {\n    LEX_CSTRING db_lex_cstr= { STRING_WITH_LEN(db) };\n    new_thd->set_db(db_lex_cstr);\n  }\n\n  tables.init_one_table(db, sizeof(db)-1, \"func\", 4, \"func\", TL_READ);\n\n  if (open_and_lock_tables(new_thd, &tables, MYSQL_LOCK_IGNORE_TIMEOUT))\n  {\n    DBUG_PRINT(\"error\",(\"Can't open udf table\"));\n    sql_print_error(\"Can't open the mysql.func table. Please \"\n                    \"run mysql_upgrade to create it.\");\n    goto end;\n  }\n\n  table= tables.table;\n  if (init_read_record(&read_record_info, new_thd, table, NULL, 1, 1, FALSE))\n    goto end;\n  table->use_all_columns();\n  while (!(error= read_record_info.read_record(&read_record_info)))\n  {\n    DBUG_PRINT(\"info\",(\"init udf record\"));\n    LEX_STRING name;\n    name.str=get_field(&mem, table->field[0]);\n    name.length = strlen(name.str);\n    char *dl_name= get_field(&mem, table->field[2]);\n    bool new_dl=0;\n    Item_udftype udftype=UDFTYPE_FUNCTION;\n    if (table->s->fields >= 4)\t\t\t// New func table\n      udftype=(Item_udftype) table->field[3]->val_int();\n\n    /*\n      Ensure that the .dll doesn't have a path\n      This is done to ensure that only approved dll from the system\n      directories are used (to make this even remotely secure).\n\n      On windows we must check both FN_LIBCHAR and '/'.\n    */\n\n    LEX_CSTRING name_cstr= {name.str, name.length};\n    if (check_valid_path(dl_name, strlen(dl_name)) ||\n        check_string_char_length(name_cstr, \"\", NAME_CHAR_LEN,\n                                 system_charset_info, 1))\n    {\n      sql_print_error(\"Invalid row in mysql.func table for function '%.64s'\",\n                      name.str);\n      continue;\n    }\n\n    if (!(tmp= add_udf(&name,(Item_result) table->field[1]->val_int(),\n                       dl_name, udftype)))\n    {\n      sql_print_error(\"Can't alloc memory for udf function: '%.64s'\", name.str);\n      continue;\n    }\n\n    void *dl = find_udf_dl(tmp->dl);\n    if (dl == NULL)\n    {\n      char dlpath[FN_REFLEN];\n      strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", tmp->dl,\n               NullS);\n      (void) unpack_filename(dlpath, dlpath);\n      if (!(dl= dlopen(dlpath, RTLD_NOW)))\n      {\n\tconst char *errmsg;\n\tint error_number= dlopen_errno;\n\tDLERROR_GENERATE(errmsg, error_number);\n\n\t/* Print warning to log */\n        sql_print_error(ER(ER_CANT_OPEN_LIBRARY), tmp->dl, error_number, errmsg);\n\t/* Keep the udf in the hash so that we can remove it later */\n\tcontinue;\n      }\n      new_dl=1;\n    }\n    tmp->dlhandle = dl;\n    {\n      char buf[NAME_LEN+16], *missing;\n      if ((missing= init_syms(tmp, buf)))\n      {\n        sql_print_error(ER(ER_CANT_FIND_DL_ENTRY), missing);\n        del_udf(tmp);\n        if (new_dl)\n          dlclose(dl);\n      }\n    }\n  }\n  if (error > 0)\n    sql_print_error(\"Got unknown error: %d\", my_errno());\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n\nend:\n  close_mysql_tables(new_thd);\n  delete new_thd;\n  DBUG_VOID_RETURN;\n}\n\n\nvoid udf_free()\n{\n  /* close all shared libraries */\n  DBUG_ENTER(\"udf_free\");\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (udf->dlhandle)\t\t\t\t// Not closed before\n    {\n      /* Mark all versions using the same handler as closed */\n      for (uint j=idx+1 ;  j < udf_hash.records ; j++)\n      {\n\tudf_func *tmp=(udf_func*) my_hash_element(&udf_hash,j);\n\tif (udf->dlhandle == tmp->dlhandle)\n\t  tmp->dlhandle=0;\t\t\t// Already closed\n      }\n      dlclose(udf->dlhandle);\n    }\n  }\n  my_hash_free(&udf_hash);\n  free_root(&mem,MYF(0));\n  if (initialized)\n  {\n    initialized= 0;\n    mysql_rwlock_destroy(&THR_LOCK_udf);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void del_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"del_udf\");\n  if (!--udf->usage_count)\n  {\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n  }\n  else\n  {\n    /*\n      The functions is in use ; Rename the functions instead of removing it.\n      The functions will be automaticly removed when the least threads\n      doesn't use it anymore\n    */\n    char *name= udf->name.str;\n    size_t name_length=udf->name.length;\n    udf->name.str=(char*) \"*\";\n    udf->name.length=1;\n    my_hash_update(&udf_hash,(uchar*) udf,(uchar*) name,name_length);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nvoid free_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"free_udf\");\n  \n  if (!initialized)\n    DBUG_VOID_RETURN;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!--udf->usage_count)\n  {\n    /*\n      We come here when someone has deleted the udf function\n      while another thread still was using the udf\n    */\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n    if (!find_udf_dl(udf->dl))\n      dlclose(udf->dlhandle);\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_VOID_RETURN;\n}\n\n\n/* This is only called if using_udf_functions != 0 */\n\nudf_func *find_udf(const char *name, size_t length,bool mark_used)\n{\n  udf_func *udf=0;\n  DBUG_ENTER(\"find_udf\");\n\n  if (!initialized)\n    DBUG_RETURN(NULL);\n\n  /* TODO: This should be changed to reader locks someday! */\n  if (mark_used)\n    mysql_rwlock_wrlock(&THR_LOCK_udf);  /* Called during fix_fields */\n  else\n    mysql_rwlock_rdlock(&THR_LOCK_udf);  /* Called during parsing */\n\n  if ((udf=(udf_func*) my_hash_search(&udf_hash,(uchar*) name,\n                                      length ? length : strlen(name))))\n  {\n    if (!udf->dlhandle)\n      udf=0;\t\t\t\t\t// Could not be opened\n    else if (mark_used)\n      udf->usage_count++;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(udf);\n}\n\n\nstatic void *find_udf_dl(const char *dl)\n{\n  DBUG_ENTER(\"find_udf_dl\");\n\n  /*\n    Because only the function name is hashed, we have to search trough\n    all rows to find the dl.\n  */\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (!strcmp(dl, udf->dl) && udf->dlhandle != NULL)\n      DBUG_RETURN(udf->dlhandle);\n  }\n  DBUG_RETURN(0);\n}\n\n\n/* Assume that name && dl is already allocated */\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret, char *dl,\n\t\t\t Item_udftype type)\n{\n  if (!name || !dl || !(uint) type || (uint) type > (uint) UDFTYPE_AGGREGATE)\n    return 0;\n  udf_func *tmp= (udf_func*) alloc_root(&mem, sizeof(udf_func));\n  if (!tmp)\n    return 0;\n  memset(tmp, 0, sizeof(*tmp));\n  tmp->name = *name; //dup !!\n  tmp->dl = dl;\n  tmp->returns = ret;\n  tmp->type = type;\n  tmp->usage_count=1;\n  if (my_hash_insert(&udf_hash,(uchar*)  tmp))\n    return 0;\n  using_udf_functions=1;\n  return tmp;\n}\n\n\n/**\n  Create a user defined function. \n\n  @note Like implementations of other DDL/DML in MySQL, this function\n  relies on the caller to close the thread tables. This is done in the\n  end of dispatch_command().\n*/\n\nint mysql_create_function(THD *thd,udf_func *udf)\n{\n  int error;\n  void *dl=0;\n  bool new_dl=0;\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *u_d;\n  bool save_binlog_row_based;\n  DBUG_ENTER(\"mysql_create_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0),\n               udf->name.str,\n               \"UDFs are unavailable with the --skip-grant-tables option\");\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER(ER_OUT_OF_RESOURCES), MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  /*\n    Ensure that the .dll doesn't have a path\n    This is done to ensure that only approved dll from the system\n    directories are used (to make this even remotely secure).\n  */\n  if (check_valid_path(udf->dl, strlen(udf->dl)))\n  {\n    my_message(ER_UDF_NO_PATHS, ER(ER_UDF_NO_PATHS), MYF(0));\n    DBUG_RETURN(1);\n  }\n  LEX_CSTRING udf_name_cstr= {udf->name.str, udf->name.length};\n  if (check_string_char_length(udf_name_cstr, \"\", NAME_CHAR_LEN,\n                               system_charset_info, 1))\n  {\n    my_error(ER_TOO_LONG_IDENT, MYF(0), udf->name.str);\n    DBUG_RETURN(1);\n  }\n\n  tables.init_one_table(\"mysql\", 5, \"func\", 4, \"func\", TL_WRITE);\n  if (!(table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(1);\n\n  /* \n    Turn off row binlogging of this statement and use statement-based \n    so that all supporting tables are updated for CREATE FUNCTION command.\n  */\n  if ((save_binlog_row_based= thd->is_current_stmt_binlog_format_row()))\n    thd->clear_current_stmt_binlog_format_row();\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if ((my_hash_search(&udf_hash,(uchar*) udf->name.str, udf->name.length)))\n  {\n    my_error(ER_UDF_EXISTS, MYF(0), udf->name.str);\n    goto err;\n  }\n  if (!(dl = find_udf_dl(udf->dl)))\n  {\n    char dlpath[FN_REFLEN];\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", udf->dl, NullS);\n    (void) unpack_filename(dlpath, dlpath);\n\n    if (!(dl = dlopen(dlpath, RTLD_NOW)))\n    {\n      const char *errmsg;\n      int error_number= dlopen_errno;\n      DLERROR_GENERATE(errmsg, error_number);\n\n      DBUG_PRINT(\"error\",(\"dlopen of %s failed, error: %d (%s)\",\n                          udf->dl, error_number, errmsg));\n      my_error(ER_CANT_OPEN_LIBRARY, MYF(0),\n               udf->dl, error_number, errmsg);\n      goto err;\n    }\n    new_dl=1;\n  }\n  udf->dlhandle=dl;\n  {\n    char buf[NAME_LEN+16], *missing;\n    if ((missing= init_syms(udf, buf)))\n    {\n      my_error(ER_CANT_FIND_DL_ENTRY, MYF(0), missing);\n      goto err;\n    }\n  }\n  udf->name.str=strdup_root(&mem,udf->name.str);\n  udf->dl=strdup_root(&mem,udf->dl);\n  if (!(u_d=add_udf(&udf->name,udf->returns,udf->dl,udf->type)))\n    goto err;\n  u_d->dlhandle = dl;\n  u_d->func=udf->func;\n  u_d->func_init=udf->func_init;\n  u_d->func_deinit=udf->func_deinit;\n  u_d->func_clear=udf->func_clear;\n  u_d->func_add=udf->func_add;\n\n  /* create entry in mysql.func table */\n\n  table->use_all_columns();\n  restore_record(table, s->default_values);\t// Default values for fields\n  table->field[0]->store(u_d->name.str, u_d->name.length, system_charset_info);\n  table->field[1]->store((longlong) u_d->returns, TRUE);\n  table->field[2]->store(u_d->dl, strlen(u_d->dl), system_charset_info);\n  if (table->s->fields >= 4)\t\t\t// If not old func format\n    table->field[3]->store((longlong) u_d->type, TRUE);\n  error = table->file->ha_write_row(table->record[0]);\n\n  if (error)\n  {\n    char errbuf[MYSYS_STRERROR_SIZE];\n    my_error(ER_ERROR_ON_WRITE, MYF(0), \"mysql.func\", error,\n             my_strerror(errbuf, sizeof(errbuf), error));\n    del_udf(u_d);\n    goto err;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  /* Binlog the create function. */\n  if (write_bin_log(thd, true, thd->query().str, thd->query().length))\n  {\n    /* Restore the state of binlog format */\n    DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n    if (save_binlog_row_based)\n      thd->set_current_stmt_binlog_format_row();\n    DBUG_RETURN(1);\n  }\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(0);\n\n err:\n  if (new_dl)\n    dlclose(dl);\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(1);\n}\n\n\nint mysql_drop_function(THD *thd,const LEX_STRING *udf_name)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *udf;\n  char *exact_name_str;\n  size_t exact_name_len;\n  bool save_binlog_row_based;\n  int error= 1;\n  DBUG_ENTER(\"mysql_drop_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER(ER_OUT_OF_RESOURCES), MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  tables.init_one_table(\"mysql\", 5, \"func\", 4, \"func\", TL_WRITE);\n  if (!(table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(1);\n\n  /* \n    Turn off row binlogging of this statement and use statement-based\n    so that all supporting tables are updated for DROP FUNCTION command.\n  */\n  if ((save_binlog_row_based= thd->is_current_stmt_binlog_format_row()))\n    thd->clear_current_stmt_binlog_format_row();\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!(udf=(udf_func*) my_hash_search(&udf_hash,(uchar*) udf_name->str,\n                                       (uint) udf_name->length)))\n  {\n    my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    mysql_rwlock_unlock(&THR_LOCK_udf);\n    goto exit;\n  }\n  exact_name_str= udf->name.str;\n  exact_name_len= udf->name.length;\n  del_udf(udf);\n  /*\n    Close the handle if this was function that was found during boot or\n    CREATE FUNCTION and it's not in use by any other udf function\n  */\n  if (udf->dlhandle && !find_udf_dl(udf->dl))\n    dlclose(udf->dlhandle);\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  table->use_all_columns();\n  table->field[0]->store(exact_name_str, exact_name_len, &my_charset_bin);\n  if (!table->file->ha_index_read_idx_map(table->record[0], 0,\n                                          table->field[0]->ptr,\n                                          HA_WHOLE_KEY,\n                                          HA_READ_KEY_EXACT))\n  {\n    int delete_err;\n    if ((delete_err = table->file->ha_delete_row(table->record[0])))\n      table->file->print_error(delete_err, MYF(0));\n  }\n\n  /*\n    Binlog the drop function. Keep the table open and locked\n    while binlogging, to avoid binlog inconsistency.\n  */\n  if (!write_bin_log(thd, true, thd->query().str, thd->query().length))\n    error= 0;\nexit:\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(error);\n}\n\n#endif /* HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/sql/sql_plugin.cc": "/*\n   Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software Foundation,\n   51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA */\n\n#include \"sql_plugin.h\"\n\n#include \"mysql_version.h\"\n#include <mysql/plugin_auth.h>\n#include <mysql/plugin_validate_password.h>\n#include <mysql/plugin_group_replication.h>\n#include <mysql/plugin_keyring.h>\n#include \"auth_common.h\"       // check_table_access\n#include \"debug_sync.h\"        // DEBUG_SYNC\n#include \"handler.h\"           // ha_initalize_handlerton\n#include \"item.h\"              // Item\n#include \"key.h\"               // key_copy\n#include \"log.h\"               // sql_print_error\n#include \"mutex_lock.h\"        // Mutex_lock\n#include \"my_default.h\"        // free_defaults\n#include \"records.h\"           // READ_RECORD\n#include \"sql_audit.h\"         // mysql_audit_acquire_plugins\n#include \"sql_base.h\"          // close_mysql_tables\n#include \"sql_class.h\"         // THD\n#include \"sql_parse.h\"         // check_string_char_length\n#include \"sql_show.h\"          // add_status_vars\n#include \"strfunc.h\"           // find_type\n#include \"sys_vars_shared.h\"   // intern_find_sys_var\n#include \"template_utils.h\"    // pointer_cast\n#include \"transaction.h\"       // trans_rollback_stmt\n\n#ifndef EMBEDDED_LIBRARY\n#include \"srv_session.h\"       // Srv_session::check_for_stale_threads()\n#endif\n\n#include <algorithm>\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\nusing std::min;\nusing std::max;\n\n#define REPORT_TO_LOG  1\n#define REPORT_TO_USER 2\n\n#ifndef DBUG_OFF\nstatic PSI_memory_key key_memory_plugin_ref;\n#endif\n\nstatic PSI_memory_key key_memory_plugin_mem_root;\nstatic PSI_memory_key key_memory_plugin_init_tmp;\nstatic PSI_memory_key key_memory_plugin_int_mem_root;\nstatic PSI_memory_key key_memory_mysql_plugin;\nstatic PSI_memory_key key_memory_mysql_plugin_dl;\nstatic PSI_memory_key key_memory_plugin_bookmark;\n\nextern st_mysql_plugin *mysql_optional_plugins[];\nextern st_mysql_plugin *mysql_mandatory_plugins[];\n\n/**\n  @note The order of the enumeration is critical.\n  @see construct_options\n*/\nconst char *global_plugin_typelib_names[]=\n  { \"OFF\", \"ON\", \"FORCE\", \"FORCE_PLUS_PERMANENT\", NULL };\nstatic TYPELIB global_plugin_typelib=\n  { array_elements(global_plugin_typelib_names)-1,\n    \"\", global_plugin_typelib_names, NULL };\n\nstatic I_List<i_string> opt_plugin_load_list;\nI_List<i_string> *opt_plugin_load_list_ptr= &opt_plugin_load_list;\nstatic I_List<i_string> opt_early_plugin_load_list;\nI_List<i_string> *opt_early_plugin_load_list_ptr= &opt_early_plugin_load_list;\nchar *opt_plugin_dir_ptr;\nchar opt_plugin_dir[FN_REFLEN];\n/*\n  When you ad a new plugin type, add both a string and make sure that the\n  init and deinit array are correctly updated.\n*/\nconst LEX_STRING plugin_type_names[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  { C_STRING_WITH_LEN(\"UDF\") },\n  { C_STRING_WITH_LEN(\"STORAGE ENGINE\") },\n  { C_STRING_WITH_LEN(\"FTPARSER\") },\n  { C_STRING_WITH_LEN(\"DAEMON\") },\n  { C_STRING_WITH_LEN(\"INFORMATION SCHEMA\") },\n  { C_STRING_WITH_LEN(\"AUDIT\") },\n  { C_STRING_WITH_LEN(\"REPLICATION\") },\n  { C_STRING_WITH_LEN(\"AUTHENTICATION\") },\n  { C_STRING_WITH_LEN(\"VALIDATE PASSWORD\") },\n  { C_STRING_WITH_LEN(\"GROUP REPLICATION\") },\n  { C_STRING_WITH_LEN(\"KEYRING\") }\n};\n\nextern int initialize_schema_table(st_plugin_int *plugin);\nextern int finalize_schema_table(st_plugin_int *plugin);\n\n#ifdef EMBEDDED_LIBRARY\n// Dummy implementations for embedded\nint initialize_audit_plugin(st_plugin_int *plugin) { return 1; }\nint finalize_audit_plugin(st_plugin_int *plugin) { return 0; }\n#endif\n\n/*\n  The number of elements in both plugin_type_initialize and\n  plugin_type_deinitialize should equal to the number of plugins\n  defined.\n*/\nplugin_type_init plugin_type_initialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0,ha_initialize_handlerton,0,0,initialize_schema_table,\n  initialize_audit_plugin,0,0,0\n};\n\nplugin_type_init plugin_type_deinitialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0,ha_finalize_handlerton,0,0,finalize_schema_table,\n  finalize_audit_plugin,0,0,0\n};\n\n#ifdef HAVE_DLOPEN\nstatic const char *plugin_interface_version_sym=\n                   \"_mysql_plugin_interface_version_\";\nstatic const char *sizeof_st_plugin_sym=\n                   \"_mysql_sizeof_struct_st_plugin_\";\nstatic const char *plugin_declarations_sym= \"_mysql_plugin_declarations_\";\nstatic int min_plugin_interface_version= MYSQL_PLUGIN_INTERFACE_VERSION & ~0xFF;\n#endif\n\nstatic void*\tinnodb_callback_data;\n\n/* Note that 'int version' must be the first field of every plugin\n   sub-structure (plugin->info).\n*/\nstatic int min_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000,\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n  MYSQL_VALIDATE_PASSWORD_INTERFACE_VERSION,\n  MYSQL_GROUP_REPLICATION_INTERFACE_VERSION,\n  MYSQL_KEYRING_INTERFACE_VERSION\n};\nstatic int cur_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000, /* UDF: not implemented */\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n  MYSQL_VALIDATE_PASSWORD_INTERFACE_VERSION,\n  MYSQL_GROUP_REPLICATION_INTERFACE_VERSION,\n  MYSQL_KEYRING_INTERFACE_VERSION\n};\n\n/* support for Services */\n\n#include \"sql_plugin_services.h\"\n\n/*\n  A mutex LOCK_plugin_delete must be acquired before calling plugin_del\n  function. \n*/\nmysql_mutex_t LOCK_plugin_delete;\n\n/*\n  A mutex LOCK_plugin must be acquired before accessing the\n  following variables/structures.\n  We are always manipulating ref count, so a rwlock here is unneccessary.\n*/\nmysql_mutex_t LOCK_plugin;\nstatic Prealloced_array<st_plugin_dl*, 16> *plugin_dl_array;\nstatic Prealloced_array<st_plugin_int*, 16> *plugin_array;\nstatic HASH plugin_hash[MYSQL_MAX_PLUGIN_TYPE_NUM];\nstatic bool reap_needed= false;\nstatic int plugin_array_version=0;\n\nstatic bool initialized= 0;\n\n/*\n  write-lock on LOCK_system_variables_hash is required before modifying\n  the following variables/structures\n*/\nstatic MEM_ROOT plugin_mem_root;\nstatic uint global_variables_dynamic_size= 0;\nstatic HASH bookmark_hash;\n/** Hash for system variables of string type with MEMALLOC flag. */\nstatic HASH malloced_string_type_sysvars_bookmark_hash;\n\n\n/*\n  hidden part of opaque value passed to variable check functions.\n  Used to provide a object-like structure to non C++ consumers.\n*/\nstruct st_item_value_holder : public st_mysql_value\n{\n  Item *item;\n};\n\n\n/*\n  stored in bookmark_hash, this structure is never removed from the\n  hash and is used to mark a single offset for a thd local variable\n  even if plugins have been uninstalled and reinstalled, repeatedly.\n  This structure is allocated from plugin_mem_root.\n\n  The key format is as follows:\n    1 byte         - variable type code\n    name_len bytes - variable name\n    '\\0'           - end of key\n*/\nstruct st_bookmark\n{\n  size_t name_len;\n  int offset;\n  uint version;\n  char key[1];\n};\n\n\n/*\n  skeleton of a plugin variable - portion of structure common to all.\n*/\nstruct st_mysql_sys_var\n{\n  MYSQL_PLUGIN_VAR_HEADER;\n};\n\nstatic SHOW_TYPE pluginvar_show_type(st_mysql_sys_var *plugin_var);\n\n\n/*\n  sys_var class for access to all plugin variables visible to the user\n*/\nclass sys_var_pluginvar: public sys_var\n{\n  static bool on_check_pluginvar(sys_var *self, THD *thd, set_var *var);\npublic:\n  st_plugin_int *plugin;\n  st_mysql_sys_var *plugin_var;\n  /**\n    variable name from whatever is hard-coded in the plugin source\n    and doesn't have pluginname- prefix is replaced by an allocated name\n    with a plugin prefix. When plugin is uninstalled we need to restore the\n    pointer to point to the hard-coded value, because plugin may be\n    installed/uninstalled many times without reloading the shared object.\n  */\n  const char *orig_pluginvar_name;\n\n  static void *operator new(size_t size, MEM_ROOT *mem_root)\n  { return alloc_root(mem_root, size); }\n  static void operator delete(void *ptr_arg,size_t size)\n  { TRASH(ptr_arg, size); }\n\n  sys_var_pluginvar(sys_var_chain *chain, const char *name_arg,\n                    st_mysql_sys_var *plugin_var_arg)\n    :sys_var(chain, name_arg, plugin_var_arg->comment,\n             (plugin_var_arg->flags & PLUGIN_VAR_THDLOCAL ? SESSION : GLOBAL) |\n             (plugin_var_arg->flags & PLUGIN_VAR_READONLY ? READONLY : 0),\n             0, -1, NO_ARG, pluginvar_show_type(plugin_var_arg), 0, 0,\n             VARIABLE_NOT_IN_BINLOG,\n             (plugin_var_arg->flags & PLUGIN_VAR_NODEFAULT) ?\n               on_check_pluginvar : NULL,\n             NULL, NULL, PARSE_NORMAL),\n    plugin_var(plugin_var_arg), orig_pluginvar_name(plugin_var_arg->name)\n  { plugin_var->name= name_arg; }\n  sys_var_pluginvar *cast_pluginvar() { return this; }\n  bool check_update_type(Item_result type);\n  SHOW_TYPE show_type();\n  uchar* real_value_ptr(THD *thd, enum_var_type type);\n  TYPELIB* plugin_var_typelib(void);\n  uchar* do_value_ptr(THD *running_thd, THD *target_thd, enum_var_type type, LEX_STRING *base);\n  uchar* do_value_ptr(THD *thd, enum_var_type type, LEX_STRING *base)\n  { return do_value_ptr(thd, thd, type, base); }\n  uchar* session_value_ptr(THD *running_thd, THD *target_thd, LEX_STRING *base)\n  { return do_value_ptr(running_thd, target_thd, OPT_SESSION, base); }\n  uchar* global_value_ptr(THD *thd, LEX_STRING *base)\n  { return do_value_ptr(thd, OPT_GLOBAL, base); }\n  bool do_check(THD *thd, set_var *var);\n  virtual void session_save_default(THD *thd, set_var *var) {}\n  virtual void global_save_default(THD *thd, set_var *var) {}\n  bool session_update(THD *thd, set_var *var);\n  bool global_update(THD *thd, set_var *var);\n};\n\n\n/* prototypes */\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv);\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list);\nstatic my_bool check_if_option_is_deprecated(int optid,\n                                             const struct my_option *opt,\n                                             char *argument);\nstatic int test_plugin_options(MEM_ROOT *, st_plugin_int *,\n                               int *, char **);\nstatic bool register_builtin(st_mysql_plugin *, st_plugin_int *,\n                             st_plugin_int **);\nstatic void unlock_variables(THD *thd, struct system_variables *vars);\nstatic void cleanup_variables(THD *thd, struct system_variables *vars);\nstatic void plugin_vars_free_values(sys_var *vars);\nstatic bool plugin_var_memalloc_session_update(THD *thd,\n                                               st_mysql_sys_var *var,\n                                               char **dest, const char *value);\nstatic bool plugin_var_memalloc_global_update(THD *thd,\n                                              st_mysql_sys_var *var,\n                                              char **dest, const char *value);\nstatic void plugin_var_memalloc_free(struct system_variables *vars);\nstatic void restore_pluginvar_names(sys_var *first);\nstatic void plugin_opt_set_limits(struct my_option *,\n                                  const st_mysql_sys_var *);\n#define my_intern_plugin_lock(A,B) intern_plugin_lock(A,B)\n#define my_intern_plugin_lock_ci(A,B) intern_plugin_lock(A,B)\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref plugin);\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin);\nstatic void reap_plugins(void);\n\nstatic void report_error(int where_to, uint error, ...)\n{\n  va_list args;\n  if (where_to & REPORT_TO_USER)\n  {\n    va_start(args, error);\n    my_printv_error(error, ER(error), MYF(0), args);\n    va_end(args);\n  }\n  if (where_to & REPORT_TO_LOG)\n  {\n    va_start(args, error);\n    error_log_print(ERROR_LEVEL, ER_DEFAULT(error), args);\n    va_end(args);\n  }\n}\n\n/**\n   Check if the provided path is valid in the sense that it does cause\n   a relative reference outside the directory.\n\n   @note Currently, this function only check if there are any\n   characters in FN_DIRSEP in the string, but it might change in the\n   future.\n\n   @code\n   check_valid_path(\"../foo.so\") -> true\n   check_valid_path(\"foo.so\") -> false\n   @endcode\n */\nbool check_valid_path(const char *path, size_t len)\n{\n  size_t prefix= my_strcspn(files_charset_info, path, path + len, FN_DIRSEP,\n                            strlen(FN_DIRSEP));\n  return  prefix < len;\n}\n\n\n/****************************************************************************\n  Value type thunks, allows the C world to play in the C++ world\n****************************************************************************/\n\nstatic int item_value_type(st_mysql_value *value)\n{\n  switch (((st_item_value_holder*)value)->item->result_type()) {\n  case INT_RESULT:\n    return MYSQL_VALUE_TYPE_INT;\n  case REAL_RESULT:\n    return MYSQL_VALUE_TYPE_REAL;\n  default:\n    return MYSQL_VALUE_TYPE_STRING;\n  }\n}\n\nstatic const char *item_val_str(st_mysql_value *value,\n                                char *buffer, int *length)\n{\n  String str(buffer, *length, system_charset_info), *res;\n  if (!(res= ((st_item_value_holder*)value)->item->val_str(&str)))\n    return NULL;\n  *length= static_cast<int>(res->length());\n  if (res->c_ptr_quick() == buffer)\n    return buffer;\n\n  /*\n    Lets be nice and create a temporary string since the\n    buffer was too small\n  */\n  return current_thd->strmake(res->c_ptr_quick(), res->length());\n}\n\n\nstatic int item_val_int(st_mysql_value *value, long long *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_int();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\nstatic int item_is_unsigned(st_mysql_value *value)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  return item->unsigned_flag;\n}\n\nstatic int item_val_real(st_mysql_value *value, double *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_real();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\n\n/****************************************************************************\n  Plugin support code\n****************************************************************************/\n\n#ifdef HAVE_DLOPEN\n\nstatic st_plugin_dl *plugin_dl_find(const LEX_STRING *dl)\n{\n  DBUG_ENTER(\"plugin_dl_find\");\n  for (st_plugin_dl **it= plugin_dl_array->begin();\n       it != plugin_dl_array->end(); ++it)\n  {\n    st_plugin_dl *tmp= *it;\n    if (tmp->ref_count &&\n        ! my_strnncoll(files_charset_info,\n                       pointer_cast<uchar*>(dl->str), dl->length,\n                       pointer_cast<uchar*>(tmp->dl.str), tmp->dl.length))\n      DBUG_RETURN(tmp);\n  }\n  DBUG_RETURN(NULL);\n}\n\n\nstatic st_plugin_dl *plugin_dl_insert_or_reuse(st_plugin_dl *plugin_dl)\n{\n  DBUG_ENTER(\"plugin_dl_insert_or_reuse\");\n  st_plugin_dl *tmp;\n  for (st_plugin_dl **it= plugin_dl_array->begin();\n       it != plugin_dl_array->end(); ++it)\n  {\n    tmp= *it;\n    if (! tmp->ref_count)\n    {\n      memcpy(tmp, plugin_dl, sizeof(st_plugin_dl));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (plugin_dl_array->push_back(plugin_dl))\n    DBUG_RETURN(NULL);\n  tmp= plugin_dl_array->back()=\n    static_cast<st_plugin_dl*>(memdup_root(&plugin_mem_root, plugin_dl,\n                                           sizeof(st_plugin_dl)));\n  DBUG_RETURN(tmp);\n}\n#endif /* HAVE_DLOPEN */\n\n\nstatic inline void free_plugin_mem(st_plugin_dl *p)\n{\n#ifdef HAVE_DLOPEN\n  if (p->handle)\n    dlclose(p->handle);\n#endif\n  my_free(p->dl.str);\n  if (p->version != MYSQL_PLUGIN_INTERFACE_VERSION)\n    my_free(p->plugins);\n}\n\n\nstatic st_plugin_dl *plugin_dl_add(const LEX_STRING *dl, int report)\n{\n#ifdef HAVE_DLOPEN\n  char dlpath[FN_REFLEN];\n  uint dummy_errors, i;\n  size_t plugin_dir_len, dlpathlen;\n  st_plugin_dl *tmp, plugin_dl;\n  void *sym;\n  DBUG_ENTER(\"plugin_dl_add\");\n  DBUG_PRINT(\"enter\", (\"dl->str: '%s', dl->length: %d\",\n                       dl->str, (int) dl->length));\n  plugin_dir_len= strlen(opt_plugin_dir);\n  /*\n    Ensure that the dll doesn't have a path.\n    This is done to ensure that only approved libraries from the\n    plugin directory are used (to make this even remotely secure).\n  */\n  LEX_CSTRING dl_cstr= {dl->str, dl->length};\n  if (check_valid_path(dl->str, dl->length) ||\n      check_string_char_length(dl_cstr, \"\", NAME_CHAR_LEN,\n                               system_charset_info, 1) ||\n      plugin_dir_len + dl->length + 1 >= FN_REFLEN)\n  {\n    report_error(report, ER_UDF_NO_PATHS);\n    DBUG_RETURN(NULL);\n  }\n  /* If this dll is already loaded just increase ref_count. */\n  if ((tmp= plugin_dl_find(dl)))\n  {\n    tmp->ref_count++;\n    DBUG_RETURN(tmp);\n  }\n  memset(&plugin_dl, 0, sizeof(plugin_dl));\n  /* Compile dll path */\n  dlpathlen=\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", dl->str, NullS) -\n    dlpath;\n  (void) unpack_filename(dlpath, dlpath);\n  plugin_dl.ref_count= 1;\n  /* Open new dll handle */\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  if (!(plugin_dl.handle= dlopen(dlpath, RTLD_NOW)))\n  {\n    const char *errmsg;\n    int error_number= dlopen_errno;\n    /*\n      Conforming applications should use a critical section to retrieve\n      the error pointer and buffer...\n    */\n    DLERROR_GENERATE(errmsg, error_number);\n\n    if (!strncmp(dlpath, errmsg, dlpathlen))\n    { // if errmsg starts from dlpath, trim this prefix.\n      errmsg+=dlpathlen;\n      if (*errmsg == ':') errmsg++;\n      if (*errmsg == ' ') errmsg++;\n    }\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, error_number, errmsg);\n\n    /*\n      \"The messages returned by dlerror() may reside in a static buffer\n       that is overwritten on each call to dlerror().\"\n\n      Some implementations have a static pointer instead, and the memory it\n      points to may be reported as \"still reachable\" by Valgrind.\n      Calling dlerror() once more will free the memory.\n     */\n#if !defined(_WIN32)\n    errmsg= dlerror();\n    DBUG_ASSERT(errmsg == NULL);\n#endif\n    DBUG_RETURN(NULL);\n  }\n  /* Determine interface version */\n  if (!(sym= dlsym(plugin_dl.handle, plugin_interface_version_sym)))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_interface_version_sym);\n    DBUG_RETURN(NULL);\n  }\n  plugin_dl.version= *(int *)sym;\n  /* Versioning */\n  if (plugin_dl.version < min_plugin_interface_version ||\n      (plugin_dl.version >> 8) > (MYSQL_PLUGIN_INTERFACE_VERSION >> 8))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0,\n                 \"plugin interface version mismatch\");\n    DBUG_RETURN(NULL);\n  }\n\n  /* link the services in */\n  for (i= 0; i < array_elements(list_of_services); i++)\n  {\n    if ((sym= dlsym(plugin_dl.handle, list_of_services[i].name)))\n    {\n      uint ver= (uint)(intptr)*(void**)sym;\n      if ((*(void**)sym) != list_of_services[i].service && /* already replaced */\n          (ver > list_of_services[i].version ||\n           (ver >> 8) < (list_of_services[i].version >> 8)))\n      {\n        char buf[MYSQL_ERRMSG_SIZE];\n        my_snprintf(buf, sizeof(buf),\n                    \"service '%s' interface version mismatch\",\n                    list_of_services[i].name);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0, buf);\n        DBUG_RETURN(NULL);\n      }\n      *(void**)sym= list_of_services[i].service;\n    }\n  }\n\n  /* Find plugin declarations */\n  if (!(sym= dlsym(plugin_dl.handle, plugin_declarations_sym)))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_declarations_sym);\n    DBUG_RETURN(NULL);\n  }\n\n  if (plugin_dl.version != MYSQL_PLUGIN_INTERFACE_VERSION)\n  {\n    uint sizeof_st_plugin;\n    st_mysql_plugin *old, *cur;\n    char *ptr= (char *)sym;\n\n    if ((sym= dlsym(plugin_dl.handle, sizeof_st_plugin_sym)))\n      sizeof_st_plugin= *(int *)sym;\n    else\n    {\n      /*\n        When the following assert starts failing, we'll have to call\n        report_error(report, ER_CANT_FIND_DL_ENTRY, sizeof_st_plugin_sym);\n      */\n      DBUG_ASSERT(min_plugin_interface_version == 0);\n      sizeof_st_plugin= (int)offsetof(st_mysql_plugin, version);\n    }\n\n    /*\n      What's the purpose of this loop? If the goal is to catch a\n      missing 0 record at the end of a list, it will fail miserably\n      since the compiler is likely to optimize this away. /Matz\n     */\n    for (i= 0;\n         ((st_mysql_plugin *)(ptr+i*sizeof_st_plugin))->info;\n         i++)\n      /* no op */;\n\n    cur= (st_mysql_plugin*)\n      my_malloc(key_memory_mysql_plugin,\n                (i+1)*sizeof(st_mysql_plugin), MYF(MY_ZEROFILL|MY_WME));\n    if (!cur)\n    {\n      free_plugin_mem(&plugin_dl);\n      report_error(report, ER_OUTOFMEMORY,\n                   static_cast<int>(plugin_dl.dl.length));\n      DBUG_RETURN(NULL);\n    }\n    /*\n      All st_plugin fields not initialized in the plugin explicitly, are\n      set to 0. It matches C standard behaviour for struct initializers that\n      have less values than the struct definition.\n    */\n    for (i=0;\n         (old=(st_mysql_plugin *)(ptr+i*sizeof_st_plugin))->info;\n         i++)\n      memcpy(cur+i, old, min<size_t>(sizeof(cur[i]), sizeof_st_plugin));\n\n    sym= cur;\n  }\n  plugin_dl.plugins= (st_mysql_plugin *)sym;\n\n  /*\n    If report is REPORT_TO_USER, we were called from\n    mysql_install_plugin. Otherwise, we are called directly or\n    indirectly from plugin_init.\n   */\n  if (report == REPORT_TO_USER)\n  {\n    st_mysql_plugin *plugin= plugin_dl.plugins;\n    for ( ; plugin->info ; ++plugin)\n      if (plugin->flags & PLUGIN_OPT_NO_INSTALL)\n      {\n        report_error(report, ER_PLUGIN_NO_INSTALL, plugin->name);\n        free_plugin_mem(&plugin_dl);\n        DBUG_RETURN(NULL);\n   }\n  }\n\n  /* Duplicate and convert dll name */\n  plugin_dl.dl.length= dl->length * files_charset_info->mbmaxlen + 1;\n  if (! (plugin_dl.dl.str= (char*) my_malloc(key_memory_mysql_plugin_dl,\n                                             plugin_dl.dl.length, MYF(0))))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(plugin_dl.dl.length));\n    DBUG_RETURN(NULL);\n  }\n  plugin_dl.dl.length= copy_and_convert(plugin_dl.dl.str, plugin_dl.dl.length,\n    files_charset_info, dl->str, dl->length, system_charset_info,\n    &dummy_errors);\n  plugin_dl.dl.str[plugin_dl.dl.length]= 0;\n  /* Add this dll to array */\n  if (! (tmp= plugin_dl_insert_or_reuse(&plugin_dl)))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(sizeof(st_plugin_dl)));\n    DBUG_RETURN(NULL);\n  }\n  DBUG_RETURN(tmp);\n#else\n  DBUG_ENTER(\"plugin_dl_add\");\n  report_error(report, ER_FEATURE_DISABLED, \"plugin\", \"HAVE_DLOPEN\");\n  DBUG_RETURN(NULL);\n#endif\n}\n\n\nstatic void plugin_dl_del(const LEX_STRING *dl)\n{\n#ifdef HAVE_DLOPEN\n  DBUG_ENTER(\"plugin_dl_del\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  for (st_plugin_dl **it= plugin_dl_array->begin();\n       it != plugin_dl_array->end(); ++it)\n  {\n    st_plugin_dl *tmp= *it;\n    if (tmp->ref_count &&\n        ! my_strnncoll(files_charset_info,\n                       pointer_cast<uchar*>(dl->str), dl->length,\n                       pointer_cast<uchar*>(tmp->dl.str), tmp->dl.length))\n    {\n      /* Do not remove this element, unless no other plugin uses this dll. */\n      if (! --tmp->ref_count)\n      {\n        free_plugin_mem(tmp);\n        memset(tmp, 0, sizeof(st_plugin_dl));\n      }\n      break;\n    }\n  }\n  DBUG_VOID_RETURN;\n#endif\n}\n\n\nstatic st_plugin_int *plugin_find_internal(const LEX_CSTRING &name,\n                                                  int type)\n{\n  uint i;\n  DBUG_ENTER(\"plugin_find_internal\");\n  if (! initialized)\n    DBUG_RETURN(NULL);\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    {\n      st_plugin_int *plugin= (st_plugin_int *)\n        my_hash_search(&plugin_hash[i],\n                       reinterpret_cast<const uchar*>(name.str), name.length);\n      if (plugin)\n        DBUG_RETURN(plugin);\n    }\n  }\n  else\n    DBUG_RETURN((st_plugin_int *)\n        my_hash_search(&plugin_hash[type],\n                       reinterpret_cast<const uchar*>(name.str),\n                       name.length));\n  DBUG_RETURN(NULL);\n}\n\n\nstatic SHOW_COMP_OPTION plugin_status(const LEX_CSTRING &name, int type)\n{\n  SHOW_COMP_OPTION rc= SHOW_OPTION_NO;\n  st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_is_ready\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n  {\n    rc= SHOW_OPTION_DISABLED;\n    if (plugin->state == PLUGIN_IS_READY)\n      rc= SHOW_OPTION_YES;\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nbool plugin_is_ready(const LEX_CSTRING &name, int type)\n{\n  bool rc= FALSE;\n  if (plugin_status(name, type) == SHOW_OPTION_YES)\n    rc= TRUE;\n  return rc;\n}\n\n\nSHOW_COMP_OPTION plugin_status(const char *name, size_t len, int type)\n{\n  LEX_CSTRING plugin_name= { name, len };\n  return plugin_status(plugin_name, type);\n}\n\n\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref rc)\n{\n  st_plugin_int *pi= plugin_ref_to_int(rc);\n  DBUG_ENTER(\"intern_plugin_lock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (pi->state & (PLUGIN_IS_READY | PLUGIN_IS_UNINITIALIZED))\n  {\n    plugin_ref plugin;\n#ifdef DBUG_OFF\n    /* built-in plugins don't need ref counting */\n    if (!pi->plugin_dl)\n      DBUG_RETURN(pi);\n\n    plugin= pi;\n#else\n    /*\n      For debugging, we do an additional malloc which allows the\n      memory manager and/or valgrind to track locked references and\n      double unlocks to aid resolving reference counting problems.\n    */\n    if (!(plugin= (plugin_ref) my_malloc(key_memory_plugin_ref,\n                                         sizeof(pi), MYF(MY_WME))))\n      DBUG_RETURN(NULL);\n\n    *plugin= pi;\n#endif\n    pi->ref_count++;\n    DBUG_PRINT(\"info\",(\"thd: %p, plugin: \\\"%s\\\", ref_count: %d\",\n                       current_thd, pi->name.str, pi->ref_count));\n    if (lex)\n      lex->plugins.push_back(plugin);\n    DBUG_RETURN(plugin);\n  }\n  DBUG_RETURN(NULL);\n}\n\n\nplugin_ref plugin_lock(THD *thd, plugin_ref *ptr)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc;\n  DBUG_ENTER(\"plugin_lock\");\n  mysql_mutex_lock(&LOCK_plugin);\n  rc= my_intern_plugin_lock_ci(lex, *ptr);\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nplugin_ref plugin_lock_by_name(THD *thd, const LEX_CSTRING &name, int type)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc= NULL;\n  st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_lock_by_name\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n    rc= my_intern_plugin_lock_ci(lex, plugin_int_to_ref(plugin));\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nstatic st_plugin_int *plugin_insert_or_reuse(st_plugin_int *plugin)\n{\n  DBUG_ENTER(\"plugin_insert_or_reuse\");\n  st_plugin_int *tmp;\n  for (st_plugin_int **it= plugin_array->begin();\n       it != plugin_array->end(); ++it)\n  {\n    tmp= *it;\n    if (tmp->state == PLUGIN_IS_FREED)\n    {\n      memcpy(tmp, plugin, sizeof(st_plugin_int));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (plugin_array->push_back(plugin))\n    DBUG_RETURN(NULL);\n  tmp= plugin_array->back()=\n    static_cast<st_plugin_int*>(memdup_root(&plugin_mem_root, plugin,\n                                            sizeof(st_plugin_int)));\n  DBUG_RETURN(tmp);\n}\n\n\n/*\n  NOTE\n    Requires that a write-lock is held on LOCK_system_variables_hash\n*/\nstatic bool plugin_add(MEM_ROOT *tmp_root,\n                       const LEX_STRING *name, const LEX_STRING *dl,\n                       int *argc, char **argv, int report)\n{\n  st_plugin_int tmp;\n  st_mysql_plugin *plugin;\n  DBUG_ENTER(\"plugin_add\");\n  LEX_CSTRING name_cstr= {name->str, name->length};\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  if (plugin_find_internal(name_cstr, MYSQL_ANY_PLUGIN))\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_UDF_EXISTS, name->str);\n    mysql_mutex_lock(&LOCK_plugin);\n    DBUG_RETURN(TRUE);\n  }\n  /* Clear the whole struct to catch future extensions. */\n  memset(&tmp, 0, sizeof(tmp));\n  if (! (tmp.plugin_dl= plugin_dl_add(dl, report)))\n    DBUG_RETURN(TRUE);\n  /* Find plugin by name */\n  for (plugin= tmp.plugin_dl->plugins; plugin->info; plugin++)\n  {\n    size_t name_len= strlen(plugin->name);\n    if (plugin->type >= 0 && plugin->type < MYSQL_MAX_PLUGIN_TYPE_NUM &&\n        ! my_strnncoll(system_charset_info,\n                       pointer_cast<const uchar*>(name->str), name->length,\n                       pointer_cast<const uchar*>(plugin->name),\n                       name_len))\n    {\n      st_plugin_int *tmp_plugin_ptr;\n      if (*(int*)plugin->info <\n          min_plugin_info_interface_version[plugin->type] ||\n          ((*(int*)plugin->info) >> 8) >\n          (cur_plugin_info_interface_version[plugin->type] >> 8))\n      {\n        char buf[256];\n        strxnmov(buf, sizeof(buf) - 1, \"API version for \",\n                 plugin_type_names[plugin->type].str,\n                 \" plugin is too different\", NullS);\n        mysql_mutex_unlock(&LOCK_plugin);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dl->str, 0, buf);\n        mysql_mutex_lock(&LOCK_plugin);\n        goto err;\n      }\n      tmp.plugin= plugin;\n      tmp.name.str= (char *)plugin->name;\n      tmp.name.length= name_len;\n      tmp.ref_count= 0;\n      tmp.state= PLUGIN_IS_UNINITIALIZED;\n      tmp.load_option= PLUGIN_ON;\n      if (test_plugin_options(tmp_root, &tmp, argc, argv))\n        tmp.state= PLUGIN_IS_DISABLED;\n\n      if ((tmp_plugin_ptr= plugin_insert_or_reuse(&tmp)))\n      {\n        plugin_array_version++;\n        if (!my_hash_insert(&plugin_hash[plugin->type], (uchar*)tmp_plugin_ptr))\n        {\n          init_alloc_root(key_memory_plugin_int_mem_root,\n                          &tmp_plugin_ptr->mem_root, 4096, 4096);\n          DBUG_RETURN(FALSE);\n        }\n        tmp_plugin_ptr->state= PLUGIN_IS_FREED;\n      }\n      mysql_del_sys_var_chain(tmp.system_vars);\n      restore_pluginvar_names(tmp.system_vars);\n      goto err;\n\n      /* plugin was disabled */\n      plugin_dl_del(dl);\n      DBUG_RETURN(FALSE);\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  report_error(report, ER_CANT_FIND_DL_ENTRY, name->str);\n  mysql_mutex_lock(&LOCK_plugin);\nerr:\n  plugin_dl_del(dl);\n  DBUG_RETURN(TRUE);\n}\n\n\nstatic void plugin_deinitialize(st_plugin_int *plugin, bool ref_check)\n{\n  /*\n    we don't want to hold the LOCK_plugin mutex as it may cause\n    deinitialization to deadlock if plugins have worker threads\n    with plugin locks\n  */\n  mysql_mutex_assert_not_owner(&LOCK_plugin);\n\n  if (plugin->plugin->status_vars)\n  {\n    remove_status_vars(plugin->plugin->status_vars);\n  }\n\n  if (plugin_type_deinitialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_deinitialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' of type %s failed deinitialization\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n    }\n  }\n  else if (plugin->plugin->deinit)\n  {\n    DBUG_PRINT(\"info\", (\"Deinitializing plugin: '%s'\", plugin->name.str));\n    if (plugin->plugin->deinit(plugin))\n    {\n      DBUG_PRINT(\"warning\", (\"Plugin '%s' deinit function returned error.\",\n                             plugin->name.str));\n    }\n  }\n  plugin->state= PLUGIN_IS_UNINITIALIZED;\n\n#ifndef EMBEDDED_LIBRARY\n  Srv_session::check_for_stale_threads(plugin);\n#endif\n  /*\n    We do the check here because NDB has a worker THD which doesn't\n    exit until NDB is shut down.\n  */\n  if (ref_check && plugin->ref_count)\n    sql_print_error(\"Plugin '%s' has ref_count=%d after deinitialization.\",\n                    plugin->name.str, plugin->ref_count);\n}\n\nstatic void plugin_del(st_plugin_int *plugin)\n{\n  DBUG_ENTER(\"plugin_del(plugin)\");\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  mysql_mutex_assert_owner(&LOCK_plugin_delete);\n  /* Free allocated strings before deleting the plugin. */\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n  mysql_del_sys_var_chain(plugin->system_vars);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  restore_pluginvar_names(plugin->system_vars);\n  plugin_vars_free_values(plugin->system_vars);\n  my_hash_delete(&plugin_hash[plugin->plugin->type], (uchar*)plugin);\n\n  if (plugin->plugin_dl)\n    plugin_dl_del(&plugin->plugin_dl->dl);\n  plugin->state= PLUGIN_IS_FREED;\n  plugin_array_version++;\n  free_root(&plugin->mem_root, MYF(0));\n  DBUG_VOID_RETURN;\n}\n\nstatic void reap_plugins(void)\n{\n  st_plugin_int *plugin, **reap, **list;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!reap_needed)\n    return;\n\n  reap_needed= false;\n  const size_t count= plugin_array->size();\n  reap= (st_plugin_int **)my_alloca(sizeof(plugin)*(count+1));\n  *(reap++)= NULL;\n\n  for (size_t idx= 0; idx < count; idx++)\n  {\n    plugin= plugin_array->at(idx);\n    if (plugin->state == PLUGIN_IS_DELETED && !plugin->ref_count)\n    {\n      /* change the status flag to prevent reaping by another thread */\n      plugin->state= PLUGIN_IS_DYING;\n      *(reap++)= plugin;\n    }\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  list= reap;\n  while ((plugin= *(--list)))\n  {\n    if (!opt_bootstrap)\n      sql_print_information(\"Shutting down plugin '%s'\", plugin->name.str);\n    plugin_deinitialize(plugin, true);\n  }\n\n  mysql_mutex_lock(&LOCK_plugin_delete);\n  mysql_mutex_lock(&LOCK_plugin);\n\n  while ((plugin= *(--reap)))\n    plugin_del(plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin_delete);\n}\n\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin)\n{\n  st_plugin_int *pi;\n  DBUG_ENTER(\"intern_plugin_unlock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!plugin)\n    DBUG_VOID_RETURN;\n\n  pi= plugin_ref_to_int(plugin);\n\n#ifdef DBUG_OFF\n  if (!pi->plugin_dl)\n    DBUG_VOID_RETURN;\n#else\n  my_free(plugin);\n#endif\n\n  DBUG_PRINT(\"info\",(\"unlocking plugin, name= %s, ref_count= %d\",\n                     pi->name.str, pi->ref_count));\n  if (lex)\n  {\n    /*\n      Remove one instance of this plugin from the use list.\n      We are searching backwards so that plugins locked last\n      could be unlocked faster - optimizing for LIFO semantics.\n    */\n    plugin_ref *iter= lex->plugins.end() - 1;\n    bool found_it MY_ATTRIBUTE((unused)) = false;\n    for (; iter >= lex->plugins.begin() - 1; --iter)\n    {\n      if (plugin == *iter)\n      {\n        lex->plugins.erase(iter);\n        found_it= true;\n        break;\n      }\n    }\n    DBUG_ASSERT(found_it);\n  }\n\n  DBUG_ASSERT(pi->ref_count);\n  pi->ref_count--;\n\n  if (pi->state == PLUGIN_IS_DELETED && !pi->ref_count)\n    reap_needed= true;\n\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock(THD *thd, plugin_ref plugin)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock\");\n  if (!plugin)\n    DBUG_VOID_RETURN;\n#ifdef DBUG_OFF\n  /* built-in plugins don't need ref counting */\n  if (!plugin_dlib(plugin))\n    DBUG_VOID_RETURN;\n#endif\n  mysql_mutex_lock(&LOCK_plugin);\n  intern_plugin_unlock(lex, plugin);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock_list(THD *thd, plugin_ref *list, size_t count)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock_list\");\n  DBUG_ASSERT(list);\n\n  /*\n    In unit tests, LOCK_plugin may be uninitialized, so do not lock it.\n    Besides: there's no point in locking it, if there are no plugins to unlock.\n   */\n  if (count == 0)\n    DBUG_VOID_RETURN;\n\n  mysql_mutex_lock(&LOCK_plugin);\n  while (count--)\n    intern_plugin_unlock(lex, *list++);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\nstatic int plugin_initialize(st_plugin_int *plugin)\n{\n  int ret= 1;\n  DBUG_ENTER(\"plugin_initialize\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  uint state= plugin->state;\n  DBUG_ASSERT(state == PLUGIN_IS_UNINITIALIZED);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (plugin_type_initialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_initialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' registration as a %s failed.\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n      goto err;\n    }\n\n    /* FIXME: Need better solution to transfer the callback function\n    array to memcached */\n    if (strcmp(plugin->name.str, \"InnoDB\") == 0) {\n      innodb_callback_data = ((handlerton*)plugin->data)->data;\n    }\n  }\n  else if (plugin->plugin->init)\n  {\n    if (strcmp(plugin->name.str, \"daemon_memcached\") == 0) {\n       plugin->data = innodb_callback_data;\n    }\n\n    if (plugin->plugin->init(plugin))\n    {\n      sql_print_error(\"Plugin '%s' init function returned error.\",\n                      plugin->name.str);\n      goto err;\n    }\n  }\n  state= PLUGIN_IS_READY; // plugin->init() succeeded\n\n  if (plugin->plugin->status_vars)\n  {\n    if (add_status_vars(plugin->plugin->status_vars))\n      goto err;\n  }\n\n  /*\n    set the plugin attribute of plugin's sys vars so they are pointing\n    to the active plugin\n  */\n  if (plugin->system_vars)\n  {\n    sys_var_pluginvar *var= plugin->system_vars->cast_pluginvar();\n    for (;;)\n    {\n      var->plugin= plugin;\n      if (!var->next)\n        break;\n      var= var->next->cast_pluginvar();\n    }\n  }\n\n  ret= 0;\n\nerr:\n  mysql_mutex_lock(&LOCK_plugin);\n  plugin->state= state;\n\n  DBUG_RETURN(ret);\n}\n\n\nextern \"C\" uchar *get_plugin_hash_key(const uchar *, size_t *, my_bool);\nextern \"C\" uchar *get_bookmark_hash_key(const uchar *, size_t *, my_bool);\n\n\nuchar *get_plugin_hash_key(const uchar *buff, size_t *length,\n                           my_bool not_used MY_ATTRIBUTE((unused)))\n{\n  st_plugin_int *plugin= (st_plugin_int *)buff;\n  *length= (uint)plugin->name.length;\n  return((uchar *)plugin->name.str);\n}\n\n\nuchar *get_bookmark_hash_key(const uchar *buff, size_t *length,\n                             my_bool not_used MY_ATTRIBUTE((unused)))\n{\n  st_bookmark *var= (st_bookmark *)buff;\n  *length= var->name_len + 1;\n  return (uchar*) var->key;\n}\n\nstatic inline void convert_dash_to_underscore(char *str, size_t len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '-')\n      *p= '_';\n}\n\nstatic inline void convert_underscore_to_dash(char *str, size_t len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '_')\n      *p= '-';\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_key key_LOCK_plugin;\nstatic PSI_mutex_key key_LOCK_plugin_delete;\n\nstatic PSI_mutex_info all_plugin_mutexes[]=\n{\n  { &key_LOCK_plugin, \"LOCK_plugin\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_plugin_delete, \"LOCK_plugin_delete\", PSI_FLAG_GLOBAL}\n};\n\n\nstatic PSI_memory_info all_plugin_memory[]=\n{\n#ifndef DBUG_OFF\n  { &key_memory_plugin_ref, \"plugin_ref\", PSI_FLAG_GLOBAL},\n#endif\n  { &key_memory_plugin_mem_root, \"plugin_mem_root\", PSI_FLAG_GLOBAL},\n  { &key_memory_plugin_init_tmp, \"plugin_init_tmp\", 0},\n  { &key_memory_plugin_int_mem_root, \"plugin_int_mem_root\", 0},\n  { &key_memory_mysql_plugin_dl, \"mysql_plugin_dl\", 0},\n  { &key_memory_mysql_plugin, \"mysql_plugin\", 0},\n  { &key_memory_plugin_bookmark, \"plugin_bookmark\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_plugin_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  count= array_elements(all_plugin_mutexes);\n  mysql_mutex_register(category, all_plugin_mutexes, count);\n\n  count= array_elements(all_plugin_memory);\n  mysql_memory_register(category, all_plugin_memory, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\n\n/*\n  @brief\n    Initialize the plugins. Reap those that fail to initialize.\n\n  @return Operation outcome, false means no errors\n*/\nstatic bool plugin_init_initialize_and_reap()\n{\n  struct st_plugin_int *plugin_ptr;\n  struct st_plugin_int **reap;\n\n  /* Now we initialize all plugins that are not already initialized */\n  mysql_mutex_lock(&LOCK_plugin);\n  reap= (st_plugin_int **) my_alloca((plugin_array->size()+1) * sizeof(void*));\n  *(reap++)= NULL;\n\n  for (st_plugin_int **it= plugin_array->begin();\n       it != plugin_array->end(); ++it)\n  {\n    plugin_ptr= *it;\n    if (plugin_ptr->state == PLUGIN_IS_UNINITIALIZED)\n    {\n      if (plugin_initialize(plugin_ptr))\n      {\n        plugin_ptr->state= PLUGIN_IS_DYING;\n        *(reap++)= plugin_ptr;\n      }\n    }\n  }\n\n  /* Check if any plugins have to be reaped */\n  bool reaped_mandatory_plugin= false;\n  while ((plugin_ptr= *(--reap)))\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    if (plugin_ptr->load_option == PLUGIN_FORCE ||\n        plugin_ptr->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n      reaped_mandatory_plugin= TRUE;\n    plugin_deinitialize(plugin_ptr, true);\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_del(plugin_ptr);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (reaped_mandatory_plugin)\n    return true;\n\n  return false;\n}\n\n/**\n  Initialize the internals of the plugin system. Allocate required\n  resources, initialize mutex, etc.\n\n  @return Operation outcome, false means no errors\n */\nstatic bool plugin_init_internals()\n{\n#ifdef HAVE_PSI_INTERFACE\n  init_plugin_psi_keys();\n#endif\n\n  init_alloc_root(key_memory_plugin_mem_root, &plugin_mem_root, 4096, 4096);\n\n  if (my_hash_init(&bookmark_hash, &my_charset_bin, 16, 0, 0,\n                   get_bookmark_hash_key, NULL, HASH_UNIQUE,\n                   key_memory_plugin_bookmark))\n      goto err;\n  if (my_hash_init(&malloced_string_type_sysvars_bookmark_hash, &my_charset_bin,\n                   16, 0, 0, get_bookmark_hash_key, NULL, HASH_UNIQUE,\n                   key_memory_plugin_bookmark))\n      goto err;\n\n  mysql_mutex_init(key_LOCK_plugin, &LOCK_plugin, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_plugin_delete, &LOCK_plugin_delete, MY_MUTEX_INIT_FAST);\n\n  plugin_dl_array= new (std::nothrow)\n    Prealloced_array<st_plugin_dl*, 16>(key_memory_mysql_plugin_dl);\n  plugin_array= new (std::nothrow)\n    Prealloced_array<st_plugin_int*, 16>(key_memory_mysql_plugin);\n  if (plugin_dl_array == NULL || plugin_array == NULL)\n    goto err;\n\n  for (uint i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n  {\n    if (my_hash_init(&plugin_hash[i], system_charset_info, 16, 0, 0,\n                     get_plugin_hash_key, NULL, HASH_UNIQUE,\n                     key_memory_plugin_mem_root))\n      goto err;\n  }\n\n  return false;\n\nerr:\n  return true;\n}\n\n/**\n   Register and initialize early plugins.\n\n   @param argc  Command line argument counter\n   @param argv  Command line arguments\n   @param flags Flags to control whether dynamic loading\n                and plugin initialization should be skipped\n\n   @return Operation outcome, false if no errors\n*/\nbool plugin_register_early_plugins(int *argc, char **argv, int flags)\n{\n  bool retval= false;\n  DBUG_ENTER(\"plugin_register_early_plugins\");\n\n  /* Don't allow initializing twice */\n  DBUG_ASSERT(!initialized);\n\n  /* Make sure the internals are initialized */\n  if ((retval= plugin_init_internals()))\n    DBUG_RETURN(retval);\n\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(key_memory_plugin_init_tmp, &tmp_root, 4096, 4096);\n\n  I_List_iterator<i_string> iter(opt_early_plugin_load_list);\n  i_string *item;\n  while (NULL != (item= iter++))\n    plugin_load_list(&tmp_root, argc, argv, item->ptr);\n\n  /* Temporary mem root not needed anymore, can free it here */\n  free_root(&tmp_root, MYF(0));\n\n  if (!(flags & PLUGIN_INIT_SKIP_INITIALIZATION))\n    retval= plugin_init_initialize_and_reap();\n\n  DBUG_RETURN(retval);\n}\n\n/**\n  Register the builtin plugins. Some of the plugins (MyISAM, CSV and InnoDB)\n  are also initialized.\n\n  @param argc number of arguments, propagated to the plugin\n  @param argv actual arguments, propagated to the plugin\n  @return Operation outcome, false means no errors\n */\nbool plugin_register_builtin_and_init_core_se(int *argc, char **argv)\n{\n  bool mandatory= true;\n  DBUG_ENTER(\"plugin_register_builtin_and_init_core_se\");\n\n  /* Don't allow initializing twice */\n  DBUG_ASSERT(!initialized);\n\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(key_memory_plugin_init_tmp, &tmp_root, 4096, 4096);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  initialized= true;\n\n  /* First we register the builtin mandatory and optional plugins */\n  for (struct st_mysql_plugin **builtins= mysql_mandatory_plugins;\n       *builtins || mandatory; builtins++)\n  {\n    /* Switch to optional plugins when done with the mandatory ones */\n    if (!*builtins)\n    {\n      builtins= mysql_optional_plugins;\n      mandatory= false;\n      if (!*builtins)\n        break;\n    }\n    for (struct st_mysql_plugin *plugin= *builtins; plugin->info; plugin++)\n    {\n      struct st_plugin_int tmp;\n      memset(&tmp, 0, sizeof(tmp));\n      tmp.plugin= plugin;\n      tmp.name.str= (char *)plugin->name;\n      tmp.name.length= strlen(plugin->name);\n      tmp.state= 0;\n      tmp.load_option= mandatory ? PLUGIN_FORCE : PLUGIN_ON;\n\n      /*\n        If the performance schema is compiled in,\n        treat the storage engine plugin as 'mandatory',\n        to suppress any plugin-level options such as '--performance-schema'.\n        This is specific to the performance schema, and is done on purpose:\n        the server-level option '--performance-schema' controls the overall\n        performance schema initialization, which consists of much more that\n        the underlying storage engine initialization.\n        See mysqld.cc, set_vars.cc.\n        Suppressing ways to interfere directly with the storage engine alone\n        prevents awkward situations where:\n        - the user wants the performance schema functionality, by using\n          '--enable-performance-schema' (the server option),\n        - yet disable explicitly a component needed for the functionality\n          to work, by using '--skip-performance-schema' (the plugin)\n      */\n      if (!my_strcasecmp(&my_charset_latin1, plugin->name, \"PERFORMANCE_SCHEMA\"))\n      {\n        tmp.load_option= PLUGIN_FORCE;\n      }\n\n      free_root(&tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n      if (test_plugin_options(&tmp_root, &tmp, argc, argv))\n        tmp.state= PLUGIN_IS_DISABLED;\n      else\n        tmp.state= PLUGIN_IS_UNINITIALIZED;\n\n      struct st_plugin_int *plugin_ptr;        // Pointer to registered plugin\n      if (register_builtin(plugin, &tmp, &plugin_ptr))\n        goto err_unlock;\n\n      /*\n        Only initialize MyISAM, InnoDB and CSV at this stage.\n        Note that when the --help option is supplied, InnoDB is not\n        initialized because the plugin table will not be read anyway,\n        as indicated by the flag set when the plugin_init() function\n        is called.\n      */\n      bool is_myisam= !my_strcasecmp(&my_charset_latin1, plugin->name, \"MyISAM\");\n      bool is_innodb= !my_strcasecmp(&my_charset_latin1, plugin->name, \"InnoDB\");\n      if (!is_myisam &&\n          (!is_innodb || opt_help) &&\n          my_strcasecmp(&my_charset_latin1, plugin->name, \"CSV\"))\n        continue;\n\n      if (plugin_ptr->state != PLUGIN_IS_UNINITIALIZED ||\n          plugin_initialize(plugin_ptr))\n        goto err_unlock;\n\n      /*\n        Initialize the global default storage engine so that it may\n        not be null in any child thread.\n      */\n      if (is_myisam)\n      {\n        DBUG_ASSERT(!global_system_variables.table_plugin);\n        DBUG_ASSERT(!global_system_variables.temp_table_plugin);\n        global_system_variables.table_plugin=\n          my_intern_plugin_lock(NULL, plugin_int_to_ref(plugin_ptr));\n        global_system_variables.temp_table_plugin=\n          my_intern_plugin_lock(NULL, plugin_int_to_ref(plugin_ptr));\n        DBUG_ASSERT(plugin_ptr->ref_count == 2);\n      }\n    }\n  }\n\n  /* Should now be set to MyISAM storage engine */\n  DBUG_ASSERT(global_system_variables.table_plugin);\n  DBUG_ASSERT(global_system_variables.temp_table_plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  free_root(&tmp_root, MYF(0));\n  DBUG_RETURN(false);\n\nerr_unlock:\n  mysql_mutex_unlock(&LOCK_plugin);\n  free_root(&tmp_root, MYF(0));\n  DBUG_RETURN(true);\n}\n\n/**\n  Register and initialize the dynamic plugins. Also initialize\n  the remaining builtin plugins that are not initialized\n  already.\n\n  @param argc  Command line argument counter\n  @param argv  Command line arguments\n  @param flags Flags to control whether dynamic loading\n               and plugin initialization should be skipped\n\n  @return Operation outcome, false if no errors\n*/\nbool plugin_register_dynamic_and_init_all(int *argc,\n                                          char **argv, int flags)\n{\n  DBUG_ENTER(\"plugin_register_dynamic_and_init_all\");\n\n  /* Make sure the internals are initialized and builtins registered */\n  if (!initialized)\n    DBUG_RETURN(true);\n\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(key_memory_plugin_init_tmp, &tmp_root, 4096, 4096);\n\n  /* Register all dynamic plugins */\n  if (!(flags & PLUGIN_INIT_SKIP_DYNAMIC_LOADING))\n  {\n    I_List_iterator<i_string> iter(opt_plugin_load_list);\n    i_string *item;\n    while (NULL != (item= iter++))\n      plugin_load_list(&tmp_root, argc, argv, item->ptr);\n\n    if (!(flags & PLUGIN_INIT_SKIP_PLUGIN_TABLE))\n      plugin_load(&tmp_root, argc, argv);\n  }\n  if (flags & PLUGIN_INIT_SKIP_INITIALIZATION)\n    goto end;\n\n  /*\n    Now we initialize all remaining plugins\n  */\n  if(plugin_init_initialize_and_reap())\n    goto err;\n\nend:\n  free_root(&tmp_root, MYF(0));\n\n  DBUG_RETURN(0);\n\nerr:\n  free_root(&tmp_root, MYF(0));\n  DBUG_RETURN(1);\n}\n\nstatic bool register_builtin(st_mysql_plugin *plugin,\n                             st_plugin_int *tmp,\n                             st_plugin_int **ptr)\n{\n  DBUG_ENTER(\"register_builtin\");\n  tmp->ref_count= 0;\n  tmp->plugin_dl= 0;\n\n  if (plugin_array->push_back(tmp))\n    DBUG_RETURN(true);\n\n  *ptr= plugin_array->back()=\n    static_cast<st_plugin_int*>(memdup_root(&plugin_mem_root, tmp,\n                                            sizeof(st_plugin_int)));\n\n  if (my_hash_insert(&plugin_hash[plugin->type],(uchar*) *ptr))\n    DBUG_RETURN(1);\n\n  DBUG_RETURN(0);\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv)\n{\n  THD thd;\n  TABLE_LIST tables;\n  TABLE *table;\n  READ_RECORD read_record_info;\n  int error;\n  THD *new_thd= &thd;\n  bool result;\n#ifdef EMBEDDED_LIBRARY\n  No_such_table_error_handler error_handler;\n#endif /* EMBEDDED_LIBRARY */\n  DBUG_ENTER(\"plugin_load\");\n\n  new_thd->thread_stack= (char*) &tables;\n  new_thd->store_globals();\n  LEX_CSTRING db_lex_cstr= { STRING_WITH_LEN(\"mysql\") };\n  new_thd->set_db(db_lex_cstr);\n  thd.get_protocol_classic()->wipe_net();\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_READ);\n\n#ifdef EMBEDDED_LIBRARY\n  /*\n    When building an embedded library, if the mysql.plugin table\n    does not exist, we silently ignore the missing table\n  */\n  new_thd->push_internal_handler(&error_handler);\n#endif /* EMBEDDED_LIBRARY */\n\n  result= open_trans_system_tables_for_read(new_thd, &tables);\n\n#ifdef EMBEDDED_LIBRARY\n  new_thd->pop_internal_handler();\n  if (error_handler.safely_trapped_errors())\n    DBUG_VOID_RETURN;\n#endif /* EMBEDDED_LIBRARY */\n\n  if (result)\n  {\n    DBUG_PRINT(\"error\",(\"Can't open plugin table\"));\n    sql_print_error(\"Can't open the mysql.plugin table. Please \"\n                    \"run mysql_upgrade to create it.\");\n    DBUG_VOID_RETURN;\n  }\n  table= tables.table;\n  if (init_read_record(&read_record_info, new_thd, table, NULL, 1, 1, FALSE))\n  {\n    close_trans_system_tables(new_thd);\n    DBUG_VOID_RETURN;\n  }\n  table->use_all_columns();\n  /*\n    there're no other threads running yet, so we don't need a mutex.\n    but plugin_add() before is designed to work in multi-threaded\n    environment, and it uses mysql_mutex_assert_owner(), so we lock\n    the mutex here to satisfy the assert\n  */\n  mysql_mutex_lock(&LOCK_plugin);\n  while (!(error= read_record_info.read_record(&read_record_info)))\n  {\n    DBUG_PRINT(\"info\", (\"init plugin record\"));\n    String str_name, str_dl;\n    get_field(tmp_root, table->field[0], &str_name);\n    get_field(tmp_root, table->field[1], &str_dl);\n\n    LEX_STRING name= {(char *)str_name.ptr(), str_name.length()};\n    LEX_STRING dl= {(char *)str_dl.ptr(), str_dl.length()};\n\n    if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n      sql_print_warning(\"Couldn't load plugin named '%s' with soname '%s'.\",\n                        str_name.c_ptr(), str_dl.c_ptr());\n    free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (error > 0)\n    sql_print_error(ER(ER_GET_ERRNO), my_errno);\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n\n  close_trans_system_tables(new_thd);\n\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list)\n{\n  char buffer[FN_REFLEN];\n  LEX_STRING name= {buffer, 0}, dl= {NULL, 0}, *str= &name;\n  st_plugin_dl *plugin_dl;\n  st_mysql_plugin *plugin;\n  char *p= buffer;\n  DBUG_ENTER(\"plugin_load_list\");\n  while (list)\n  {\n    if (p == buffer + sizeof(buffer) - 1)\n    {\n      sql_print_error(\"plugin-load parameter too long\");\n      DBUG_RETURN(TRUE);\n    }\n\n    switch ((*(p++)= *(list++))) {\n    case '\\0':\n      list= NULL; /* terminate the loop */\n      /* fall through */\n    case ';':\n#ifndef _WIN32\n    case ':':     /* can't use this as delimiter as it may be drive letter */\n#endif\n      str->str[str->length]= '\\0';\n      if (str == &name)  // load all plugins in named module\n      {\n        if (!name.length)\n        {\n          p--;    /* reset pointer */\n          continue;\n        }\n\n        dl= name;\n        mysql_mutex_lock(&LOCK_plugin);\n        if ((plugin_dl= plugin_dl_add(&dl, REPORT_TO_LOG)))\n        {\n          for (plugin= plugin_dl->plugins; plugin->info; plugin++)\n          {\n            name.str= (char *) plugin->name;\n            name.length= strlen(name.str);\n\n            free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n            if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n              goto error;\n          }\n          plugin_dl_del(&dl); // reduce ref count\n        }\n      }\n      else\n      {\n        free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n        mysql_mutex_lock(&LOCK_plugin);\n        if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n          goto error;\n      }\n      mysql_mutex_unlock(&LOCK_plugin);\n      name.length= dl.length= 0;\n      dl.str= NULL; name.str= p= buffer;\n      str= &name;\n      continue;\n    case '=':\n    case '#':\n      if (str == &name)\n      {\n        name.str[name.length]= '\\0';\n        str= &dl;\n        str->str= p;\n        continue;\n      }\n      // Fall through.\n    default:\n      str->length++;\n      continue;\n    }\n  }\n  DBUG_RETURN(FALSE);\nerror:\n  mysql_mutex_unlock(&LOCK_plugin);\n  sql_print_error(\"Couldn't load plugin named '%s' with soname '%s'.\",\n                  name.str, dl.str);\n  DBUG_RETURN(TRUE);\n}\n\n/*\n  Shutdown memcached plugin before binlog shuts down\n*/\nvoid memcached_shutdown(void)\n{\n  if (initialized)\n  {\n\n    for (st_plugin_int **it= plugin_array->begin();\n         it != plugin_array->end(); ++it)\n    {\n      st_plugin_int *plugin= *it;\n\n      if (plugin->state == PLUGIN_IS_READY\n\t  && strcmp(plugin->name.str, \"daemon_memcached\") == 0)\n      {\n\tplugin_deinitialize(plugin, true);\n\n        mysql_mutex_lock(&LOCK_plugin);\n\tplugin->state= PLUGIN_IS_DYING;\n\tplugin_del(plugin);\n        mysql_mutex_unlock(&LOCK_plugin);\n      }\n    }\n\n  }\n}\n\nvoid plugin_shutdown(void)\n{\n  size_t i;\n  st_plugin_int **plugins, *plugin;\n  st_plugin_dl **dl;\n  bool skip_binlog = true;\n\n  DBUG_ENTER(\"plugin_shutdown\");\n\n  if (initialized)\n  {\n    size_t count= plugin_array->size();\n    mysql_mutex_lock(&LOCK_plugin);\n\n    reap_needed= true;\n\n    /*\n      We want to shut down plugins in a reasonable order, this will\n      become important when we have plugins which depend upon each other.\n      Circular references cannot be reaped so they are forced afterwards.\n      TODO: Have an additional step here to notify all active plugins that\n      shutdown is requested to allow plugins to deinitialize in parallel.\n    */\n    while (reap_needed && (count= plugin_array->size()))\n    {\n      reap_plugins();\n      for (i= 0; i < count; i++)\n      {\n        plugin= plugin_array->at(i);\n\n\tif (plugin->state == PLUGIN_IS_READY\n\t    && strcmp(plugin->name.str, \"binlog\") == 0 && skip_binlog)\n\t{\n\t\tskip_binlog = false;\n\n\t} else if (plugin->state == PLUGIN_IS_READY)\n        {\n          plugin->state= PLUGIN_IS_DELETED;\n          reap_needed= true;\n        }\n      }\n      if (!reap_needed)\n      {\n        /*\n          release any plugin references held.\n        */\n        unlock_variables(NULL, &global_system_variables);\n        unlock_variables(NULL, &max_system_variables);\n      }\n    }\n\n    plugins= (st_plugin_int **) my_alloca(sizeof(void*) * (count+1));\n\n    /*\n      If we have any plugins which did not die cleanly, we force shutdown\n    */\n    for (i= 0; i < count; i++)\n    {\n      plugins[i]= plugin_array->at(i);\n      /* change the state to ensure no reaping races */\n      if (plugins[i]->state == PLUGIN_IS_DELETED)\n        plugins[i]->state= PLUGIN_IS_DYING;\n    }\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    /*\n      We loop through all plugins and call deinit() if they have one.\n    */\n    for (i= 0; i < count; i++)\n      if (!(plugins[i]->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_FREED |\n                                 PLUGIN_IS_DISABLED)))\n      {\n        sql_print_warning(\"Plugin '%s' will be forced to shutdown\",\n                          plugins[i]->name.str);\n        /*\n          We are forcing deinit on plugins so we don't want to do a ref_count\n          check until we have processed all the plugins.\n        */\n        plugin_deinitialize(plugins[i], false);\n      }\n\n    /*\n      It's perfectly safe not to lock LOCK_plugin, LOCK_plugin_delete, as\n      there're no concurrent threads anymore. But some functions called from\n      here use mysql_mutex_assert_owner(), so we lock the mutex to satisfy it\n    */\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n\n    /*\n      We defer checking ref_counts until after all plugins are deinitialized\n      as some may have worker threads holding on to plugin references.\n    */\n    for (i= 0; i < count; i++)\n    {\n      if (plugins[i]->ref_count)\n        sql_print_error(\"Plugin '%s' has ref_count=%d after shutdown.\",\n                        plugins[i]->name.str, plugins[i]->ref_count);\n      if (plugins[i]->state & PLUGIN_IS_UNINITIALIZED)\n        plugin_del(plugins[i]);\n    }\n\n    /*\n      Now we can deallocate all memory.\n    */\n\n    cleanup_variables(NULL, &global_system_variables);\n    cleanup_variables(NULL, &max_system_variables);\n    mysql_mutex_unlock(&LOCK_plugin);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n\n    initialized= 0;\n    mysql_mutex_destroy(&LOCK_plugin);\n    mysql_mutex_destroy(&LOCK_plugin_delete);\n  }\n\n  /* Dispose of the memory */\n\n  for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    my_hash_free(&plugin_hash[i]);\n  delete plugin_array;\n  plugin_array= NULL;\n\n  if (plugin_dl_array != NULL)\n  {\n    size_t count= plugin_dl_array->size();\n    dl= (st_plugin_dl **)my_alloca(sizeof(void*) * count);\n    for (i= 0; i < count; i++)\n      dl[i]= plugin_dl_array->at(i);\n    for (i= 0; i < plugin_dl_array->size(); i++)\n      free_plugin_mem(dl[i]);\n    delete plugin_dl_array;\n    plugin_dl_array= NULL;\n  }\n\n  my_hash_free(&bookmark_hash);\n  my_hash_free(&malloced_string_type_sysvars_bookmark_hash);\n  free_root(&plugin_mem_root, MYF(0));\n\n  global_variables_dynamic_size= 0;\n\n  DBUG_VOID_RETURN;\n}\n\n/**\n  Initialize one plugin. This function is used to early load one single\n  plugin. This function is used by key migration tool.\n\n   @param[in]   argc  Command line argument counter\n   @param[in]   argv  Command line arguments\n   @param[in]   plugin library file name\n\n   @return Operation status\n     @retval 0 OK\n     @retval 1 ERROR\n*/\nbool plugin_early_load_one(int *argc, char **argv, const char* plugin)\n{\n  bool retval= false;\n  DBUG_ENTER(\"plugin_early_load_one\");\n\n  /* Make sure the internals are initialized */\n  if (!initialized)\n  {\n    if ((retval= plugin_init_internals()))\n      DBUG_RETURN(retval);\n    else\n      initialized= true;\n  }\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(PSI_NOT_INSTRUMENTED, &tmp_root, 4096, 4096);\n\n  plugin_load_list(&tmp_root, argc, argv, plugin);\n\n  /* Temporary mem root not needed anymore, can free it here */\n  free_root(&tmp_root, MYF(0));\n\n  retval= plugin_init_initialize_and_reap();\n\n  DBUG_RETURN(retval);\n}\n\nstatic bool mysql_install_plugin(THD *thd, const LEX_STRING *name,\n                                 const LEX_STRING *dl)\n{\n  TABLE_LIST tables;\n  TABLE *table;\n  bool error= true;\n  int argc= orig_argc;\n  char **argv= orig_argv;\n  st_plugin_int *tmp;\n  LEX_CSTRING name_cstr= {name->str, name->length};\n\n  DBUG_ENTER(\"mysql_install_plugin\");\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n\n  if (!opt_noacl &&\n      check_table_access(thd, INSERT_ACL, &tables, false, 1, false))\n    DBUG_RETURN(true);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table = open_ltable(thd, &tables, TL_WRITE,\n                             MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(true);\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n    */\n#ifndef EMBEDDED_LIBRARY\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,\n                              MYSQL_AUDIT_GENERAL_ALL);\n#endif\n\n  mysql_mutex_lock(&LOCK_plugin);\n  DEBUG_SYNC(thd, \"acquired_LOCK_plugin\");\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n\n  if (my_load_defaults(MYSQL_CONFIG_NAME, load_default_groups,\n                       &argc, &argv, NULL))\n  {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name->str);\n    goto err;\n  }\n  error= plugin_add(thd->mem_root, name, dl, &argc, argv, REPORT_TO_USER);\n  if (argv)\n    free_defaults(argv);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n\n  if (error || !(tmp= plugin_find_internal(name_cstr, MYSQL_ANY_PLUGIN)))\n    goto err;\n\n  if (tmp->state == PLUGIN_IS_DISABLED)\n  {\n    push_warning_printf(thd, Sql_condition::SL_WARNING,\n                        ER_CANT_INITIALIZE_UDF, ER(ER_CANT_INITIALIZE_UDF),\n                        name->str, \"Plugin is disabled\");\n  }\n  else\n  {\n    if (plugin_initialize(tmp))\n    {\n      mysql_mutex_unlock(&LOCK_plugin);\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0), name->str,\n               \"Plugin initialization function failed.\");\n      goto deinit;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  /*\n    We do not replicate the INSTALL PLUGIN statement. Disable binlogging\n    of the insert into the plugin table, so that it is not replicated in\n    row based mode.\n  */\n  tmp_disable_binlog(thd);\n  table->use_all_columns();\n  restore_record(table, s->default_values);\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  table->field[1]->store(dl->str, dl->length, files_charset_info);\n  error= table->file->ha_write_row(table->record[0]);\n  reenable_binlog(thd);\n  if (error)\n  {\n    table->file->print_error(error, MYF(0));\n    trans_rollback_stmt(thd);\n    goto deinit;\n  }\n  else\n    trans_commit_stmt(thd);\n\n  close_mysql_tables(thd);\n  DBUG_RETURN(false);\ndeinit:\n  mysql_mutex_lock(&LOCK_plugin);\n  tmp->state= PLUGIN_IS_DELETED;\n  reap_needed= true;\n  reap_plugins();\nerr:\n  mysql_mutex_unlock(&LOCK_plugin);\n  trans_rollback_stmt(thd);\n  close_mysql_tables(thd);\n\n  DBUG_RETURN(true);\n}\n\n\nstatic bool mysql_uninstall_plugin(THD *thd, const LEX_STRING *name)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  st_plugin_int *plugin;\n  LEX_CSTRING name_cstr={name->str, name->length};\n  bool error= true;\n\n  DBUG_ENTER(\"mysql_uninstall_plugin\");\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n\n  if (!opt_noacl &&\n      check_table_access(thd, DELETE_ACL, &tables, false, 1, false))\n    DBUG_RETURN(true);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(true);\n\n  if (!table->key_info)\n  {\n    my_error(ER_TABLE_CORRUPT, MYF(0), table->s->db.str,\n             table->s->table_name.str);\n    trans_rollback_stmt(thd);\n    close_thread_tables(thd);\n    DBUG_RETURN(true);\n  }\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n  */\n#ifndef EMBEDDED_LIBRARY\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,\n                                   MYSQL_AUDIT_GENERAL_ALL);\n#endif\n\n  mysql_mutex_lock(&LOCK_plugin);\n  if (!(plugin= plugin_find_internal(name_cstr, MYSQL_ANY_PLUGIN)) ||\n      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING))\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), \"PLUGIN\", name->str);\n    goto err;\n  }\n  if (!plugin->plugin_dl)\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_DELETE_BUILTIN, MYF(0));\n    goto err;\n  }\n  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name->str);\n    goto err;\n  }\n  /*\n    Error message for ER_PLUGIN_IS_PERMANENT is not suitable for\n    plugins marked as not dynamically uninstallable, so we have a\n    separate one instead of changing the old one.\n   */\n  if (plugin->plugin->flags & PLUGIN_OPT_NO_UNINSTALL)\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_NO_UNINSTALL, MYF(0), plugin->plugin->name);\n    goto err;\n  }\n\n#ifdef HAVE_REPLICATION\n  /* Block Uninstallation of semi_sync plugins (Master/Slave)\n     when they are busy\n   */\n  char buff[20];\n  size_t buff_length;\n  /*\n    Master: If there are active semi sync slaves for this Master,\n    then that means it is busy and rpl_semi_sync_master plugin\n    cannot be uninstalled. To check whether the master\n    has any semi sync slaves or not, check Rpl_semi_sync_master_cliens\n    status variable value, if it is not 0, that means it is busy.\n  */\n  if (!strcmp(name->str, \"rpl_semi_sync_master\") &&\n      get_status_var(thd,\n                     plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_master_clients\",\n                     buff, OPT_DEFAULT, &buff_length) &&\n      strcmp(buff,\"0\") )\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name->str,\n             \"Stop any active semisynchronous slaves of this master first.\");\n    goto err;\n  }\n  /* Slave: If there is semi sync enabled IO thread active on this Slave,\n    then that means plugin is busy and rpl_semi_sync_slave plugin\n    cannot be uninstalled. To check whether semi sync\n    IO thread is active or not, check Rpl_semi_sync_slave_status status\n    variable value, if it is ON, that means it is busy.\n  */\n  if (!strcmp(name->str, \"rpl_semi_sync_slave\") &&\n      get_status_var(thd, plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_slave_status\",\n                     buff, OPT_DEFAULT, &buff_length) &&\n      !strcmp(buff,\"ON\") )\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name->str,\n             \"Stop any active semisynchronous I/O threads on this slave first.\");\n    goto err;\n  }\n\n  /* If Group Replication is in use, the plugin can't be uninstalled.\n   * The command STOP GROUP_REPLICATION should be used before uninstall.\n  */\n  if (plugin->ref_count && !strcmp(name->str, \"group_replication\"))\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name->str,\n             \"Plugin is busy, it cannot be uninstalled. To force a\"\n             \" stop run STOP GROUP_REPLICATION and then UNINSTALL\"\n             \" PLUGIN group_replication.\");\n    goto err;\n  }\n#endif\n\n  plugin->state= PLUGIN_IS_DELETED;\n  if (plugin->ref_count)\n    push_warning(thd, Sql_condition::SL_WARNING,\n                 WARN_PLUGIN_BUSY, ER(WARN_PLUGIN_BUSY));\n  else\n    reap_needed= true;\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  uchar user_key[MAX_KEY_LENGTH];\n  table->use_all_columns();\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  key_copy(user_key, table->record[0], table->key_info,\n           table->key_info->key_length);\n\n  if (! table->file->ha_index_read_idx_map(table->record[0], 0, user_key,\n                                           HA_WHOLE_KEY, HA_READ_KEY_EXACT))\n  {\n    /*\n      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging\n      of the delete from the plugin table, so that it is not replicated in\n      row based mode.\n    */\n    tmp_disable_binlog(thd);\n    error= table->file->ha_delete_row(table->record[0]);\n    reenable_binlog(thd);\n    if (error)\n      table->file->print_error(error, MYF(0));\n  }\n  else\n  {\n    error= false;\n  }\n\n  if (error)\n    trans_rollback_stmt(thd);\n  else\n    trans_commit_stmt(thd);\n\n  close_mysql_tables(thd);\n\n  DBUG_RETURN(error);\nerr:\n  trans_rollback_stmt(thd);\n  close_mysql_tables(thd);\n\n  DBUG_RETURN(true);\n}\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func **funcs,\n                              int type, uint state_mask, void *arg)\n{\n  size_t idx, total;\n  st_plugin_int *plugin, **plugins;\n  int version=plugin_array_version;\n  DBUG_ENTER(\"plugin_foreach_with_mask\");\n\n  if (!initialized)\n    DBUG_RETURN(FALSE);\n\n  state_mask= ~state_mask; // do it only once\n\n  mysql_mutex_lock(&LOCK_plugin);\n  total= type == MYSQL_ANY_PLUGIN ? plugin_array->size()\n                                  : plugin_hash[type].records;\n  /*\n    Do the alloca out here in case we do have a working alloca:\n        leaving the nested stack frame invalidates alloca allocation.\n  */\n  plugins=(st_plugin_int **)my_alloca(total*sizeof(plugin));\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    for (idx= 0; idx < total; idx++)\n    {\n      plugin= plugin_array->at(idx);\n      plugins[idx]= !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  }\n  else\n  {\n    HASH *hash= plugin_hash + type;\n    for (idx= 0; idx < total; idx++)\n    {\n      plugin= (st_plugin_int *) my_hash_element(hash, idx);\n      plugins[idx]= !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  for (;*funcs != NULL; ++funcs)\n  {\n    for (idx= 0; idx < total; idx++)\n    {\n      if (unlikely(version != plugin_array_version))\n      {\n        mysql_mutex_lock(&LOCK_plugin);\n        for (size_t i=idx; i < total; i++)\n          if (plugins[i] && plugins[i]->state & state_mask)\n            plugins[i]=0;\n        mysql_mutex_unlock(&LOCK_plugin);\n      }\n      plugin= plugins[idx];\n      /* It will stop iterating on first engine error when \"func\" returns TRUE */\n      if (plugin && (*funcs)(thd, plugin_int_to_ref(plugin), arg))\n          goto err;\n    }\n  }\n\n  DBUG_RETURN(FALSE);\nerr:\n  DBUG_RETURN(TRUE);\n}\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func *func,\n                              int type, uint state_mask, void *arg)\n{\n  plugin_foreach_func *funcs[]= { func, NULL };\n\n  return plugin_foreach_with_mask(thd, funcs, type, state_mask, arg);\n}\n\n/****************************************************************************\n  Internal type declarations for variables support\n****************************************************************************/\n\n#undef MYSQL_SYSVAR_NAME\n#define MYSQL_SYSVAR_NAME(name) name\n#define PLUGIN_VAR_TYPEMASK 0x007f\n\n#define EXTRA_OPTIONS 3 /* options for: 'foo', 'plugin-foo' and NULL */\n\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_str_t, char *);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_str_t, char *);\n\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_set_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_set_t, ulonglong);\n\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_int_t, int);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_long_t, long);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_uint_t, uint);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_double_t, double);\n\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_int_t, int);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_long_t, long);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_uint_t, uint);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_double_t, double);\n\n\n/****************************************************************************\n  default variable data check and update functions\n****************************************************************************/\n\nstatic int check_func_bool(THD *thd, st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int result, length;\n  long long tmp;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)) ||\n        (result= find_type(&bool_typelib, str, length, 1)-1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp) < 0)\n      goto err;\n    if (tmp > 1)\n      goto err;\n    result= (int) tmp;\n  }\n  *(my_bool *) save= result ? TRUE : FALSE;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_int(THD *thd, st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(uint *)save= (uint) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LLONG_MAX;\n    *(int *)save= (int) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), orig);\n}\n\n\nstatic int check_func_long(THD *thd, st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulong *)save= (ulong) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LLONG_MAX;\n    *(long *)save= (long) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), orig);\n}\n\n\nstatic int check_func_longlong(THD *thd, st_mysql_sys_var *var,\n                               void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulonglong *)save= getopt_ull_limit_value((ulonglong) val, &options,\n                                               &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LLONG_MAX;\n    *(longlong *)save= getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), orig);\n}\n\nstatic int check_func_str(THD *thd, st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int length;\n\n  length= sizeof(buff);\n  if ((str= value->val_str(value, buff, &length)))\n    str= thd->strmake(str, length);\n  *(const char**)save= str;\n  return 0;\n}\n\n\nstatic int check_func_enum(THD *thd, st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  TYPELIB *typelib;\n  long long tmp;\n  long result;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_enum_t*) var)->typelib;\n  else\n    typelib= ((sysvar_enum_t*) var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    if ((result= (long)find_type(typelib, str, length, 0) - 1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp))\n      goto err;\n    if (tmp < 0 || tmp >= typelib->count)\n      goto err;\n    result= (long) tmp;\n  }\n  *(long*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_set(THD *thd, st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE], *error= 0;\n  const char *str;\n  TYPELIB *typelib;\n  ulonglong result;\n  uint error_len= 0;                            // init as only set on error\n  bool not_used;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_set_t*) var)->typelib;\n  else\n    typelib= ((sysvar_set_t*)var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    result= find_set(typelib, str, length, NULL,\n                     &error, &error_len, &not_used);\n    if (error_len)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, (long long *)&result))\n      goto err;\n    if (unlikely((result >= (1ULL << typelib->count)) &&\n                 (typelib->count < sizeof(long)*8)))\n      goto err;\n  }\n  *(ulonglong*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\nstatic int check_func_double(THD *thd, st_mysql_sys_var *var,\n                             void *save, st_mysql_value *value)\n{\n  double v;\n  my_bool fixed;\n  struct my_option option;\n\n  value->val_real(value, &v);\n  plugin_opt_set_limits(&option, var);\n  *(double *) save= getopt_double_limit_value(v, &option, &fixed);\n\n  return throw_bounds_warning(thd, var->name, fixed, v);\n}\n\n\nstatic void update_func_bool(THD *thd, st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(my_bool *) tgt= *(my_bool *) save ? TRUE : FALSE;\n}\n\n\nstatic void update_func_int(THD *thd, st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(int *)tgt= *(int *) save;\n}\n\n\nstatic void update_func_long(THD *thd, st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(long *)tgt= *(long *) save;\n}\n\n\nstatic void update_func_longlong(THD *thd, st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(longlong *)tgt= *(ulonglong *) save;\n}\n\n\nstatic void update_func_str(THD *thd, st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(char **) tgt= *(char **) save;\n}\n\nstatic void update_func_double(THD *thd, st_mysql_sys_var *var,\n                               void *tgt, const void *save)\n{\n  *(double *) tgt= *(double *) save;\n}\n\n/****************************************************************************\n  System Variables support\n****************************************************************************/\n/*\n  This function is not thread safe as the pointer returned at the end of\n  the function is outside mutex.\n*/\n\nvoid lock_plugin_mutex()\n{\n  mysql_mutex_lock(&LOCK_plugin);\n}\n\nvoid unlock_plugin_mutex()\n{\n  mysql_mutex_unlock(&LOCK_plugin);\n}\n\nsys_var *find_sys_var_ex(THD *thd, const char *str, size_t length,\n                         bool throw_error, bool locked)\n{\n  sys_var *var;\n  sys_var_pluginvar *pi= NULL;\n  plugin_ref plugin;\n  DBUG_ENTER(\"find_sys_var_ex\");\n\n  if (!locked)\n    mysql_mutex_lock(&LOCK_plugin);\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n  if ((var= intern_find_sys_var(str, length)) &&\n      (pi= var->cast_pluginvar()))\n  {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    LEX *lex= thd ? thd->lex : 0;\n    if (!(plugin= my_intern_plugin_lock(lex, plugin_int_to_ref(pi->plugin))))\n      var= NULL; /* failed to lock it, it must be uninstalling */\n    else\n    if (!(plugin_state(plugin) & PLUGIN_IS_READY))\n    {\n      /* initialization not completed */\n      var= NULL;\n      intern_plugin_unlock(lex, plugin);\n    }\n  }\n  else\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  if (!locked)\n    mysql_mutex_unlock(&LOCK_plugin);\n\n  if (!throw_error && !var)\n    my_error(ER_UNKNOWN_SYSTEM_VARIABLE, MYF(0), (char*) str);\n  DBUG_RETURN(var);\n}\n\n\nsys_var *find_sys_var(THD *thd, const char *str, size_t length)\n{\n  return find_sys_var_ex(thd, str, length, false, false);\n}\n\n\n/*\n  called by register_var, construct_options and test_plugin_options.\n  Returns the 'bookmark' for the named variable.\n  LOCK_system_variables_hash should be at least read locked\n*/\nstatic st_bookmark *find_bookmark(const char *plugin, const char *name,\n                                  int flags)\n{\n  st_bookmark *result= NULL;\n  size_t namelen, length, pluginlen= 0;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL))\n    return NULL;\n\n  namelen= strlen(name);\n  if (plugin)\n    pluginlen= strlen(plugin) + 1;\n  length= namelen + pluginlen + 2;\n  varname= (char*) my_alloca(length);\n\n  if (plugin)\n  {\n    strxmov(varname + 1, plugin, \"_\", name, NullS);\n    for (p= varname + 1; *p; p++)\n      if (*p == '-')\n        *p= '_';\n  }\n  else\n    memcpy(varname + 1, name, namelen + 1);\n\n  varname[0]= flags & PLUGIN_VAR_TYPEMASK;\n\n  result= (st_bookmark*) my_hash_search(&bookmark_hash,\n                                        (const uchar*) varname, length - 1);\n\n  return result;\n}\n\n\n/*\n  returns a bookmark for thd-local variables, creating if neccessary.\n  returns null for non thd-local variables.\n  Requires that a write lock is obtained on LOCK_system_variables_hash\n*/\nstatic st_bookmark *register_var(const char *plugin, const char *name,\n                                 int flags)\n{\n  size_t length= strlen(plugin) + strlen(name) + 3, size= 0, offset, new_size;\n  st_bookmark *result;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL))\n    return NULL;\n\n  switch (flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:\n    size= sizeof(my_bool);\n    break;\n  case PLUGIN_VAR_INT:\n    size= sizeof(int);\n    break;\n  case PLUGIN_VAR_LONG:\n  case PLUGIN_VAR_ENUM:\n    size= sizeof(long);\n    break;\n  case PLUGIN_VAR_LONGLONG:\n  case PLUGIN_VAR_SET:\n    size= sizeof(ulonglong);\n    break;\n  case PLUGIN_VAR_STR:\n    size= sizeof(char*);\n    break;\n  case PLUGIN_VAR_DOUBLE:\n    size= sizeof(double);\n    break;\n  default:\n    DBUG_ASSERT(0);\n    return NULL;\n  };\n\n  varname= ((char*) my_alloca(length));\n  strxmov(varname + 1, plugin, \"_\", name, NullS);\n  for (p= varname + 1; *p; p++)\n    if (*p == '-')\n      *p= '_';\n\n  if (!(result= find_bookmark(NULL, varname + 1, flags)))\n  {\n    result= (st_bookmark*) alloc_root(&plugin_mem_root,\n                                      sizeof(st_bookmark) + length-1);\n    varname[0]= flags & PLUGIN_VAR_TYPEMASK;\n    memcpy(result->key, varname, length);\n    result->name_len= length - 2;\n    result->offset= -1;\n\n    DBUG_ASSERT(size && !(size & (size-1))); /* must be power of 2 */\n\n    offset= global_system_variables.dynamic_variables_size;\n    offset= (offset + size - 1) & ~(size - 1);\n    result->offset= (int) offset;\n\n    new_size= (offset + size + 63) & ~63;\n\n    if (new_size > global_variables_dynamic_size)\n    {\n      global_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(key_memory_global_system_variables,\n                   global_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      max_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(key_memory_global_system_variables,\n                   max_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      /*\n        Clear the new variable value space. This is required for string\n        variables. If their value is non-NULL, it must point to a valid\n        string.\n      */\n      memset(global_system_variables.dynamic_variables_ptr +\n             global_variables_dynamic_size, 0, \n             new_size - global_variables_dynamic_size);\n      memset(max_system_variables.dynamic_variables_ptr +\n             global_variables_dynamic_size, 0,\n             new_size - global_variables_dynamic_size);\n      global_variables_dynamic_size= new_size;\n    }\n\n    global_system_variables.dynamic_variables_head= offset;\n    max_system_variables.dynamic_variables_head= offset;\n    global_system_variables.dynamic_variables_size= offset + size;\n    max_system_variables.dynamic_variables_size= offset + size;\n    global_system_variables.dynamic_variables_version++;\n    max_system_variables.dynamic_variables_version++;\n\n    result->version= global_system_variables.dynamic_variables_version;\n\n    /* this should succeed because we have already checked if a dup exists */\n    if (my_hash_insert(&bookmark_hash, (uchar*) result))\n    {\n      fprintf(stderr, \"failed to add placeholder to hash\");\n      DBUG_ASSERT(0);\n    }\n\n    /*\n      Hashing vars of string type with MEMALLOC flag.\n    */\n    if (((flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (flags & PLUGIN_VAR_MEMALLOC) &&\n        (my_hash_insert(&malloced_string_type_sysvars_bookmark_hash,\n                        (uchar *)result)))\n    {\n      fprintf(stderr, \"failed to add placeholder to\"\n                      \" hash of malloced string type sysvars\");\n      DBUG_ASSERT(0);\n    }\n  }\n  return result;\n}\n\nstatic void restore_pluginvar_names(sys_var *first)\n{\n  for (sys_var *var= first; var; var= var->next)\n  {\n    sys_var_pluginvar *pv= var->cast_pluginvar();\n    pv->plugin_var->name= pv->orig_pluginvar_name;\n  }\n}\n\n\n/**\n  Allocate memory and copy dynamic variables from global system variables\n  to per-thread system variables copy.\n\n  @param thd              thread context\n  @param global_lock      If true LOCK_global_system_variables should be\n                          acquired while copying variables from global\n                          variables copy.\n*/\nvoid alloc_and_copy_thd_dynamic_variables(THD *thd, bool global_lock)\n{\n  uint idx;\n\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n\n  if (global_lock)\n    mysql_mutex_lock(&LOCK_global_system_variables);\n\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  /*\n    MAINTAINER:\n    The following assert is wrong on purpose, useful to debug\n    when thd dynamic variables are expanded:\n    DBUG_ASSERT(thd->variables.dynamic_variables_ptr == NULL);\n  */\n\n  thd->variables.dynamic_variables_ptr= (char*)\n    my_realloc(key_memory_THD_variables,\n               thd->variables.dynamic_variables_ptr,\n               global_variables_dynamic_size,\n               MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n\n  /*\n    Debug hook which allows tests to check that this code is not\n    called for InnoDB after connection was created.\n  */\n  DBUG_EXECUTE_IF(\"verify_innodb_thdvars\", DBUG_ASSERT(0););\n\n  memcpy(thd->variables.dynamic_variables_ptr +\n         thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_ptr +\n         thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_size -\n         thd->variables.dynamic_variables_size);\n\n  /*\n    Iterate through newly copied vars of string type with MEMALLOC\n    flag and strdup value.\n  */\n  for (idx= 0; idx < malloced_string_type_sysvars_bookmark_hash.records; idx++)\n  {\n    sys_var_pluginvar *pi;\n    sys_var *var;\n    int varoff;\n    char **thdvar, **sysvar;\n    st_bookmark *v=\n      (st_bookmark*)my_hash_element(&malloced_string_type_sysvars_bookmark_hash,\n                                    idx);\n\n    if (v->version <= thd->variables.dynamic_variables_version ||\n        !(var= intern_find_sys_var(v->key + 1, v->name_len)) ||\n        !(pi= var->cast_pluginvar()) ||\n        v->key[0] != (pi->plugin_var->flags & PLUGIN_VAR_TYPEMASK))\n      continue;\n\n    varoff= *(int *) (pi->plugin_var + 1);\n    thdvar= (char **) (thd->variables.\n                       dynamic_variables_ptr + varoff);\n    sysvar= (char **) (global_system_variables.\n                       dynamic_variables_ptr + varoff);\n    *thdvar= NULL;\n    plugin_var_memalloc_session_update(thd, NULL, thdvar, *sysvar);\n  }\n\n  if (global_lock)\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  thd->variables.dynamic_variables_version=\n    global_system_variables.dynamic_variables_version;\n  thd->variables.dynamic_variables_head=\n    global_system_variables.dynamic_variables_head;\n  thd->variables.dynamic_variables_size=\n    global_system_variables.dynamic_variables_size;\n\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n}\n\n\n/*\n  returns a pointer to the memory which holds the thd-local variable or\n  a pointer to the global variable if thd==null.\n  If required, will sync with global variables if the requested variable\n  has not yet been allocated in the current thread.\n*/\nstatic uchar *intern_sys_var_ptr(THD* thd, int offset, bool global_lock)\n{\n  DBUG_ASSERT(offset >= 0);\n  DBUG_ASSERT((uint)offset <= global_system_variables.dynamic_variables_head);\n\n  if (!thd)\n    return (uchar*) global_system_variables.dynamic_variables_ptr + offset;\n\n  /*\n    dynamic_variables_head points to the largest valid offset\n  */\n  if (!thd->variables.dynamic_variables_ptr ||\n      (uint)offset > thd->variables.dynamic_variables_head)\n  {\n    /* Current THD only. Don't trigger resync on remote THD. */\n    if (current_thd == thd)\n      alloc_and_copy_thd_dynamic_variables(thd, global_lock);\n    else\n      return (uchar*) global_system_variables.dynamic_variables_ptr + offset;\n  }\n\n  return (uchar*)thd->variables.dynamic_variables_ptr + offset;\n}\n\n\n/**\n  For correctness and simplicity's sake, a pointer to a function\n  must be compatible with pointed-to type, that is, the return and\n  parameters types must be the same. Thus, a callback function is\n  defined for each scalar type. The functions are assigned in\n  construct_options to their respective types.\n*/\n\nstatic char *mysql_sys_var_char(THD* thd, int offset)\n{\n  return (char *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic int *mysql_sys_var_int(THD* thd, int offset)\n{\n  return (int *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long *mysql_sys_var_long(THD* thd, int offset)\n{\n  return (long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long *mysql_sys_var_ulong(THD* thd, int offset)\n{\n  return (unsigned long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long long *mysql_sys_var_longlong(THD* thd, int offset)\n{\n  return (long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long long *mysql_sys_var_ulonglong(THD* thd, int offset)\n{\n  return (unsigned long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic char **mysql_sys_var_str(THD* thd, int offset)\n{\n  return (char **) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic double *mysql_sys_var_double(THD* thd, int offset)\n{\n  return (double *) intern_sys_var_ptr(thd, offset, true);\n}\n\nvoid plugin_thdvar_init(THD *thd, bool enable_plugins)\n{\n  plugin_ref old_table_plugin= thd->variables.table_plugin;\n  plugin_ref old_temp_table_plugin= thd->variables.temp_table_plugin;\n  DBUG_ENTER(\"plugin_thdvar_init\");\n  \n  thd->variables.table_plugin= NULL;\n  thd->variables.temp_table_plugin= NULL;\n  cleanup_variables(thd, &thd->variables);\n  \n  thd->variables= global_system_variables;\n  thd->variables.table_plugin= NULL;\n  thd->variables.temp_table_plugin= NULL;\n\n  thd->variables.dynamic_variables_version= 0;\n  thd->variables.dynamic_variables_size= 0;\n  thd->variables.dynamic_variables_ptr= 0;\n\n  if (enable_plugins)\n  {\n    mysql_mutex_lock(&LOCK_plugin);\n    thd->variables.table_plugin=\n      my_intern_plugin_lock(NULL, global_system_variables.table_plugin);\n    intern_plugin_unlock(NULL, old_table_plugin);\n    thd->variables.temp_table_plugin=\n      my_intern_plugin_lock(NULL, global_system_variables.temp_table_plugin);\n    intern_plugin_unlock(NULL, old_temp_table_plugin);\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n\n  /* Initialize all Sys_var_charptr variables here. */\n\n  // @@session.session_track_system_variables\n  thd->session_sysvar_res_mgr.init(&thd->variables.track_sysvars_ptr, thd->charset());\n\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Unlocks all system variables which hold a reference\n*/\nstatic void unlock_variables(THD *thd, struct system_variables *vars)\n{\n  intern_plugin_unlock(NULL, vars->table_plugin);\n  intern_plugin_unlock(NULL, vars->temp_table_plugin);\n  vars->table_plugin= NULL;\n  vars->temp_table_plugin= NULL;\n}\n\n\n/*\n  Frees memory used by system variables\n\n  Unlike plugin_vars_free_values() it frees all variables of all plugins,\n  it's used on shutdown.\n*/\nstatic void cleanup_variables(THD *thd, struct system_variables *vars)\n{\n  if (thd)\n  {\n    /* Block the Performance Schema from accessing THD::variables. */\n    mysql_mutex_lock(&thd->LOCK_thd_data);\n    \n    plugin_var_memalloc_free(&thd->variables);\n    thd->session_sysvar_res_mgr.deinit();\n  }\n  DBUG_ASSERT(vars->table_plugin == NULL);\n  DBUG_ASSERT(vars->temp_table_plugin == NULL);\n\n  my_free(vars->dynamic_variables_ptr);\n  vars->dynamic_variables_ptr= NULL;\n  vars->dynamic_variables_size= 0;\n  vars->dynamic_variables_version= 0;\n\n  if (thd)\n    mysql_mutex_unlock(&thd->LOCK_thd_data);\n}\n\n\nvoid plugin_thdvar_cleanup(THD *thd, bool enable_plugins)\n{\n  DBUG_ENTER(\"plugin_thdvar_cleanup\");\n\n  if (enable_plugins)\n  {\n    Mutex_lock plugin_lock(&LOCK_plugin);\n    unlock_variables(thd, &thd->variables);\n    size_t idx;\n    if ((idx= thd->lex->plugins.size()))\n    {\n      plugin_ref *list= thd->lex->plugins.end() - 1;\n      DBUG_PRINT(\"info\",(\"unlocking %u plugins\", static_cast<uint>(idx)));\n      while (list >= thd->lex->plugins.begin())\n        intern_plugin_unlock(thd->lex, *list--);\n    }\n\n    reap_plugins();\n    thd->lex->plugins.clear();\n  }\n  cleanup_variables(thd, &thd->variables);\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  @brief Free values of thread variables of a plugin.\n\n  This must be called before a plugin is deleted. Otherwise its\n  variables are no longer accessible and the value space is lost. Note\n  that only string values with PLUGIN_VAR_MEMALLOC are allocated and\n  must be freed.\n\n  @param[in]        vars        Chain of system variables of a plugin\n*/\n\nstatic void plugin_vars_free_values(sys_var *vars)\n{\n  DBUG_ENTER(\"plugin_vars_free_values\");\n\n  for (sys_var *var= vars; var; var= var->next)\n  {\n    sys_var_pluginvar *piv= var->cast_pluginvar();\n    if (piv &&\n        ((piv->plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (piv->plugin_var->flags & PLUGIN_VAR_MEMALLOC))\n    {\n      /* Free the string from global_system_variables. */\n      char **valptr= (char**) piv->real_value_ptr(NULL, OPT_GLOBAL);\n      DBUG_PRINT(\"plugin\", (\"freeing value for: '%s'  addr: 0x%lx\",\n                            var->name.str, (long) valptr));\n      my_free(*valptr);\n      *valptr= NULL;\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n\nstatic SHOW_TYPE pluginvar_show_type(st_mysql_sys_var *plugin_var)\n{\n  switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:\n    return SHOW_MY_BOOL;\n  case PLUGIN_VAR_INT:\n    return SHOW_INT;\n  case PLUGIN_VAR_LONG:\n    return SHOW_LONG;\n  case PLUGIN_VAR_LONGLONG:\n    return SHOW_LONGLONG;\n  case PLUGIN_VAR_STR:\n    return SHOW_CHAR_PTR;\n  case PLUGIN_VAR_ENUM:\n  case PLUGIN_VAR_SET:\n    return SHOW_CHAR;\n  case PLUGIN_VAR_DOUBLE:\n    return SHOW_DOUBLE;\n  default:\n    DBUG_ASSERT(0);\n    return SHOW_UNDEF;\n  }\n}\n\n\n/**\n  Set value for thread local variable with PLUGIN_VAR_MEMALLOC flag.\n\n  @param[in]     thd   Thread context.\n  @param[in]     var   Plugin variable.\n  @param[in,out] dest  Destination memory pointer.\n  @param[in]     value '\\0'-terminated new value.\n\n  Most plugin variable values are stored on dynamic_variables_ptr.\n  Releasing memory occupied by these values is as simple as freeing\n  dynamic_variables_ptr.\n\n  An exception to the rule are PLUGIN_VAR_MEMALLOC variables, which\n  are stored on individual memory hunks. All of these hunks has to\n  be freed when it comes to cleanup.\n\n  It may happen that a plugin was uninstalled and descriptors of\n  it's variables are lost. In this case it is impossible to locate\n  corresponding values.\n\n  In addition to allocating and setting variable value, new element\n  is added to dynamic_variables_allocs list. When thread is done, it\n  has to call plugin_var_memalloc_free() to release memory used by\n  PLUGIN_VAR_MEMALLOC variables.\n\n  If var is NULL, variable update function is not called. This is\n  needed when we take snapshot of system variables during thread\n  initialization.\n\n  @note List element and variable value are stored on the same memory\n  hunk. List element is followed by variable value.\n\n  @return Completion status\n  @retval false Success\n  @retval true  Failure\n*/\n\nstatic bool plugin_var_memalloc_session_update(THD *thd,\n                                               st_mysql_sys_var *var,\n                                               char **dest, const char *value)\n\n{\n  LIST *old_element= NULL;\n  struct system_variables *vars= &thd->variables;\n  DBUG_ENTER(\"plugin_var_memalloc_session_update\");\n\n  if (value)\n  {\n    size_t length= strlen(value) + 1;\n    LIST *element;\n    if (!(element= (LIST *) my_malloc(key_memory_THD_variables,\n                                      sizeof(LIST) + length, MYF(MY_WME))))\n      DBUG_RETURN(true);\n    memcpy(element + 1, value, length);\n    value= (const char *) (element + 1);\n    vars->dynamic_variables_allocs= list_add(vars->dynamic_variables_allocs,\n                                             element);\n  }\n\n  if (*dest)\n    old_element= (LIST *) (*dest - sizeof(LIST));\n\n  if (var)\n    var->update(thd, var, (void **) dest, (const void *) &value);\n  else\n    *dest= (char *) value;\n\n  if (old_element)\n  {\n    vars->dynamic_variables_allocs= list_delete(vars->dynamic_variables_allocs,\n                                                old_element);\n    my_free(old_element);\n  }\n  DBUG_RETURN(false);\n}\n\n\n/**\n  Free all elements allocated by plugin_var_memalloc_session_update().\n\n  @param[in]     vars  system variables structure\n\n  @see plugin_var_memalloc_session_update\n*/\n\nstatic void plugin_var_memalloc_free(struct system_variables *vars)\n{\n  LIST *next, *root;\n  DBUG_ENTER(\"plugin_var_memalloc_free\");\n  for (root= vars->dynamic_variables_allocs; root; root= next)\n  {\n    next= root->next;\n    my_free(root);\n  }\n  vars->dynamic_variables_allocs= NULL;\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Set value for global variable with PLUGIN_VAR_MEMALLOC flag.\n\n  @param[in]     thd   Thread context.\n  @param[in]     var   Plugin variable.\n  @param[in,out] dest  Destination memory pointer.\n  @param[in]     value '\\0'-terminated new value.\n\n  @return Completion status\n  @retval false Success\n  @retval true  Failure\n*/\n\nstatic bool plugin_var_memalloc_global_update(THD *thd,\n                                              st_mysql_sys_var *var,\n                                              char **dest, const char *value)\n{\n  char *old_value= *dest;\n  DBUG_EXECUTE_IF(\"simulate_bug_20292712\", my_sleep(1000););\n  DBUG_ENTER(\"plugin_var_memalloc_global_update\");\n\n  if (value && !(value= my_strdup(key_memory_global_system_variables,\n                                  value, MYF(MY_WME))))\n    DBUG_RETURN(true);\n\n  var->update(thd, var, (void **) dest, (const void *) &value);\n\n  if (old_value)\n    my_free(old_value);\n\n  DBUG_RETURN(false);\n}\n\n\nbool sys_var_pluginvar::check_update_type(Item_result type)\n{\n  switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_INT:\n  case PLUGIN_VAR_LONG:\n  case PLUGIN_VAR_LONGLONG:\n    return type != INT_RESULT;\n  case PLUGIN_VAR_STR:\n    return type != STRING_RESULT;\n  case PLUGIN_VAR_ENUM:\n  case PLUGIN_VAR_BOOL:\n  case PLUGIN_VAR_SET:\n    return type != STRING_RESULT && type != INT_RESULT;\n  case PLUGIN_VAR_DOUBLE:\n    return type != INT_RESULT && type != REAL_RESULT && type != DECIMAL_RESULT;\n  default:\n    return true;\n  }\n}\n\n\nuchar* sys_var_pluginvar::real_value_ptr(THD *thd, enum_var_type type)\n{\n  DBUG_ASSERT(thd || (type == OPT_GLOBAL));\n  if (plugin_var->flags & PLUGIN_VAR_THDLOCAL)\n  {\n    if (type == OPT_GLOBAL)\n      thd= NULL;\n\n    return intern_sys_var_ptr(thd, *(int*) (plugin_var+1), false);\n  }\n  return *(uchar**) (plugin_var+1);\n}\n\n\nTYPELIB* sys_var_pluginvar::plugin_var_typelib(void)\n{\n  switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n  case PLUGIN_VAR_ENUM:\n    return ((sysvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET:\n    return ((sysvar_set_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_set_t *)plugin_var)->typelib;\n  default:\n    return NULL;\n  }\n  return NULL;\t/* Keep compiler happy */\n}\n\n\nuchar* sys_var_pluginvar::do_value_ptr(THD *running_thd, THD *target_thd, enum_var_type type,\n                                       LEX_STRING *base)\n{\n  uchar* result;\n\n  result= real_value_ptr(target_thd, type);\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_ENUM)\n    result= (uchar*) get_type(plugin_var_typelib(), *(ulong*)result);\n  else if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_SET)\n    result= (uchar*) set_to_string(running_thd, 0, *(ulonglong*) result,\n                                   plugin_var_typelib()->type_names);\n  return result;\n}\n\nbool sys_var_pluginvar::do_check(THD *thd, set_var *var)\n{\n  st_item_value_holder value;\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->check);\n\n  value.value_type= item_value_type;\n  value.val_str= item_val_str;\n  value.val_int= item_val_int;\n  value.val_real= item_val_real;\n  value.is_unsigned= item_is_unsigned;\n  value.item= var->value;\n\n  return plugin_var->check(thd, plugin_var, &var->save_result, &value);\n}\n\nbool sys_var_pluginvar::session_update(THD *thd, set_var *var)\n{\n  bool rc= false;\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->flags & PLUGIN_VAR_THDLOCAL);\n  DBUG_ASSERT(thd == current_thd);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  void *tgt= real_value_ptr(thd, var->type);\n  const void *src= var->value ? (void*)&var->save_result\n                              : (void*)real_value_ptr(thd, OPT_GLOBAL);\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n      plugin_var->flags & PLUGIN_VAR_MEMALLOC)\n    rc= plugin_var_memalloc_session_update(thd, plugin_var, (char **) tgt,\n                                           *(const char **) src);\n  else \n    plugin_var->update(thd, plugin_var, tgt, src);\n\n  return rc;\n}\n\nbool sys_var_pluginvar::global_update(THD *thd, set_var *var)\n{\n  bool rc= false;\n  DBUG_ASSERT(!is_readonly());\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  void *tgt= real_value_ptr(thd, var->type);\n  const void *src= &var->save_result;\n\n  if (!var->value)\n  {\n    switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n    case PLUGIN_VAR_INT:\n      src= &((sysvar_uint_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONG:\n      src= &((sysvar_ulong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      src= &((sysvar_ulonglong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_ENUM:\n      src= &((sysvar_enum_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_SET:\n      src= &((sysvar_set_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_BOOL:\n      src= &((sysvar_bool_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_STR:\n      src= &((sysvar_str_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      src= &((sysvar_double_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_uint_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_ulong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_ulonglong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_enum_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_set_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_bool_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_str_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_double_t*) plugin_var)->def_val;\n      break;\n    default:\n      DBUG_ASSERT(0);\n    }\n  }\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n      plugin_var->flags & PLUGIN_VAR_MEMALLOC)\n    rc= plugin_var_memalloc_global_update(thd, plugin_var, (char **) tgt,\n                                          *(const char **) src);\n  else \n    plugin_var->update(thd, plugin_var, tgt, src);\n\n  return rc;\n}\n\n\n/**\n  Enforce the NO DEFAULT policy for plugin system variables\n\n  A plugin variable does not explicitly call the plugin supplied check function\n  when setting the default value, e.g. SET <plugin_var> = DEFAULT.\n\n  But when the PLUGIN_VAR_NODEFAULT is set setting the default value is\n  prohibited.\n  This function gets called after the actual check done by\n  sys_var_pluginvar::do_check() so it does not need to check again.\n\n  it only needs to enforce the PLUGIN_VAR_NODEFAULT flag.\n\n  There's no need for special error hence just returning true is enough.\n\n  @sa sys_var::on_check_function, sys_var::check,\n    sys_var_pluginvar::do_check(), PLUGIN_VAR_NODEFAULT\n\n  @param self   the sys_var structure for the variable being set\n  @param THD    the current thread\n  @param var    the data about the value being set\n  @return is the setting valid\n  @retval true not valid\n  @retval false valid\n*/\nbool sys_var_pluginvar::on_check_pluginvar(sys_var *self, THD *thd, set_var *var)\n{\n  /* This handler is installed only if NO_DEFAULT is specified */\n  DBUG_ASSERT(((sys_var_pluginvar *) self)->plugin_var->flags &\n              PLUGIN_VAR_NODEFAULT);\n\n  return (!var->value);\n}\n\n\n\n#define OPTION_SET_LIMITS(type, options, opt) \\\n  options->var_type= type; \\\n  options->def_value= (opt)->def_val; \\\n  options->min_value= (opt)->min_val; \\\n  options->max_value= (opt)->max_val; \\\n  options->block_size= (long) (opt)->blk_sz\n\n#define OPTION_SET_LIMITS_DOUBLE(options, opt) \\\n  options->var_type= GET_DOUBLE; \\\n  options->def_value= (longlong) getopt_double2ulonglong((opt)->def_val); \\\n  options->min_value= (longlong) getopt_double2ulonglong((opt)->min_val); \\\n  options->max_value= getopt_double2ulonglong((opt)->max_val); \\\n  options->block_size= (long) (opt)->blk_sz;\n\n\nstatic void plugin_opt_set_limits(struct my_option *options,\n                                  const st_mysql_sys_var *opt)\n{\n  options->sub_size= 0;\n\n  switch (opt->flags & (PLUGIN_VAR_TYPEMASK |\n                        PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL)) {\n  /* global system variables */\n  case PLUGIN_VAR_INT:\n    OPTION_SET_LIMITS(GET_INT, options, (sysvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_UINT, options, (sysvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG:\n    OPTION_SET_LIMITS(GET_LONG, options, (sysvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULONG, options, (sysvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG:\n    OPTION_SET_LIMITS(GET_LL, options, (sysvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULL, options, (sysvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM:\n    options->var_type= GET_ENUM;\n    options->typelib= ((sysvar_enum_t*) opt)->typelib;\n    options->def_value= ((sysvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET:\n    options->var_type= GET_SET;\n    options->typelib= ((sysvar_set_t*) opt)->typelib;\n    options->def_value= ((sysvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((sysvar_bool_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_STR:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((sysvar_str_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_DOUBLE:\n    OPTION_SET_LIMITS_DOUBLE(options, (sysvar_double_t*) opt);\n    break;\n  /* threadlocal variables */\n  case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_INT, options, (thdvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_UINT, options, (thdvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LONG, options, (thdvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULONG, options, (thdvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LL, options, (thdvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULL, options, (thdvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS_DOUBLE(options, (thdvar_double_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_ENUM;\n    options->typelib= ((thdvar_enum_t*) opt)->typelib;\n    options->def_value= ((thdvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_SET;\n    options->typelib= ((thdvar_set_t*) opt)->typelib;\n    options->def_value= ((thdvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((thdvar_bool_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((thdvar_str_t*) opt)->def_val;\n    break;\n  default:\n    DBUG_ASSERT(0);\n  }\n  options->arg_type= REQUIRED_ARG;\n  if (opt->flags & PLUGIN_VAR_NOCMDARG)\n    options->arg_type= NO_ARG;\n  if (opt->flags & PLUGIN_VAR_OPCMDARG)\n    options->arg_type= OPT_ARG;\n}\n\nextern \"C\" my_bool get_one_plugin_option(int optid, const struct my_option *,\n                                         char *);\n\nmy_bool get_one_plugin_option(int optid MY_ATTRIBUTE((unused)),\n                              const struct my_option *opt,\n                              char *argument)\n{\n  return 0;\n}\n\n\n/**\n  Creates a set of my_option objects associated with a specified plugin-\n  handle.\n\n  @param mem_root Memory allocator to be used.\n  @param tmp A pointer to a plugin handle\n  @param[out] options A pointer to a pre-allocated static array\n\n  The set is stored in the pre-allocated static array supplied to the function.\n  The size of the array is calculated as (number_of_plugin_varaibles*2+3). The\n  reason is that each option can have a prefix '--plugin-' in addtion to the\n  shorter form '--&lt;plugin-name&gt;'. There is also space allocated for\n  terminating NULL pointers.\n\n  @return\n    @retval -1 An error occurred\n    @retval 0 Success\n*/\n\nstatic int construct_options(MEM_ROOT *mem_root, st_plugin_int *tmp,\n                             my_option *options)\n{\n  const char *plugin_name= tmp->plugin->name;\n  const LEX_STRING plugin_dash = { C_STRING_WITH_LEN(\"plugin-\") };\n  size_t plugin_name_len= strlen(plugin_name);\n  size_t optnamelen;\n  const int max_comment_len= 180;\n  char *comment= (char *) alloc_root(mem_root, max_comment_len + 1);\n  char *optname;\n\n  int index= 0, offset= 0;\n  st_mysql_sys_var *opt, **plugin_option;\n  st_bookmark *v;\n\n  /** Used to circumvent the const attribute on my_option::name */\n  char *plugin_name_ptr, *plugin_name_with_prefix_ptr;\n\n  DBUG_ENTER(\"construct_options\");\n\n  plugin_name_ptr= (char*) alloc_root(mem_root, plugin_name_len + 1);\n  strcpy(plugin_name_ptr, plugin_name);\n  my_casedn_str(&my_charset_latin1, plugin_name_ptr);\n  convert_underscore_to_dash(plugin_name_ptr, plugin_name_len);\n  plugin_name_with_prefix_ptr= (char*) alloc_root(mem_root,\n                                                  plugin_name_len +\n                                                  plugin_dash.length + 1);\n  strxmov(plugin_name_with_prefix_ptr, plugin_dash.str, plugin_name_ptr, NullS);\n\n  if (tmp->load_option != PLUGIN_FORCE &&\n      tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n  {\n    /* support --skip-plugin-foo syntax */\n    options[0].name= plugin_name_ptr;\n    options[1].name= plugin_name_with_prefix_ptr;\n    options[0].id= 0;\n    options[1].id= -1;\n    options[0].var_type= options[1].var_type= GET_ENUM;\n    options[0].arg_type= options[1].arg_type= OPT_ARG;\n    options[0].def_value= options[1].def_value= 1; /* ON */\n    options[0].typelib= options[1].typelib= &global_plugin_typelib;\n\n    strxnmov(comment, max_comment_len, \"Enable or disable \", plugin_name,\n            \" plugin. Possible values are ON, OFF, FORCE (don't start \"\n            \"if the plugin fails to load).\", NullS);\n    options[0].comment= comment;\n    /*\n      Allocate temporary space for the value of the tristate.\n      This option will have a limited lifetime and is not used beyond\n      server initialization.\n      GET_ENUM value is an unsigned long integer.\n    */\n    options[0].value= options[1].value=\n                      (uchar **)alloc_root(mem_root, sizeof(ulong));\n    *((ulong*) options[0].value)= (ulong) options[0].def_value;\n\n    options+= 2;\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, plugin_name_ptr, \"NDBCLUSTER\"))\n  {\n    plugin_name_ptr= const_cast<char*>(\"ndb\"); // Use legacy \"ndb\" prefix\n    plugin_name_len= 3;\n  }\n\n  /*\n    Two passes as the 2nd pass will take pointer addresses for use\n    by my_getopt and register_var() in the first pass uses realloc\n  */\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    opt= *plugin_option;\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n      continue;\n    if (!(register_var(plugin_name_ptr, opt->name, opt->flags)))\n      continue;\n    switch (opt->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      ((thdvar_bool_t *) opt)->resolve= mysql_sys_var_char;\n      break;\n    case PLUGIN_VAR_INT:\n      ((thdvar_int_t *) opt)->resolve= mysql_sys_var_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      ((thdvar_long_t *) opt)->resolve= mysql_sys_var_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      ((thdvar_longlong_t *) opt)->resolve= mysql_sys_var_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      ((thdvar_str_t *) opt)->resolve= mysql_sys_var_str;\n      break;\n    case PLUGIN_VAR_ENUM:\n      ((thdvar_enum_t *) opt)->resolve= mysql_sys_var_ulong;\n      break;\n    case PLUGIN_VAR_SET:\n      ((thdvar_set_t *) opt)->resolve= mysql_sys_var_ulonglong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      ((thdvar_double_t *) opt)->resolve= mysql_sys_var_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    };\n  }\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    switch ((opt= *plugin_option)->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      if (!opt->check)\n        opt->check= check_func_bool;\n      if (!opt->update)\n        opt->update= update_func_bool;\n      break;\n    case PLUGIN_VAR_INT:\n      if (!opt->check)\n        opt->check= check_func_int;\n      if (!opt->update)\n        opt->update= update_func_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      if (!opt->check)\n        opt->check= check_func_long;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      if (!opt->check)\n        opt->check= check_func_longlong;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      if (!opt->check)\n        opt->check= check_func_str;\n      if (!opt->update)\n      {\n        opt->update= update_func_str;\n        if (!(opt->flags & (PLUGIN_VAR_MEMALLOC | PLUGIN_VAR_READONLY)))\n        {\n          opt->flags|= PLUGIN_VAR_READONLY;\n          sql_print_warning(\"Server variable %s of plugin %s was forced \"\n                            \"to be read-only: string variable without \"\n                            \"update_func and PLUGIN_VAR_MEMALLOC flag\",\n                            opt->name, plugin_name);\n        }\n      }\n      break;\n    case PLUGIN_VAR_ENUM:\n      if (!opt->check)\n        opt->check= check_func_enum;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_SET:\n      if (!opt->check)\n        opt->check= check_func_set;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      if (!opt->check)\n        opt->check= check_func_double;\n      if (!opt->update)\n        opt->update= update_func_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if ((opt->flags & (PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_THDLOCAL))\n                    == PLUGIN_VAR_NOCMDOPT)\n      continue;\n\n    if (!opt->name)\n    {\n      sql_print_error(\"Missing variable name in plugin '%s'.\",\n                      plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n    {\n      optnamelen= strlen(opt->name);\n      optname= (char*) alloc_root(mem_root, plugin_name_len + optnamelen + 2);\n      strxmov(optname, plugin_name_ptr, \"-\", opt->name, NullS);\n      optnamelen= plugin_name_len + optnamelen + 1;\n    }\n    else\n    {\n      /* this should not fail because register_var should create entry */\n      if (!(v= find_bookmark(plugin_name_ptr, opt->name, opt->flags)))\n      {\n        sql_print_error(\"Thread local variable '%s' not allocated \"\n                        \"in plugin '%s'.\", opt->name, plugin_name);\n        DBUG_RETURN(-1);\n      }\n\n      *(int*)(opt + 1)= offset= v->offset;\n\n      if (opt->flags & PLUGIN_VAR_NOCMDOPT)\n        continue;\n\n      optname= (char*) memdup_root(mem_root, v->key + 1, \n                                   (optnamelen= v->name_len) + 1);\n    }\n\n    convert_underscore_to_dash(optname, optnamelen);\n\n    options->name= optname;\n    options->comment= opt->comment;\n    options->app_type= opt;\n    options->id= 0;\n\n    plugin_opt_set_limits(options, opt);\n\n    if (opt->flags & PLUGIN_VAR_THDLOCAL)\n      options->value= options->u_max_value= (uchar**)\n        (global_system_variables.dynamic_variables_ptr + offset);\n    else\n      options->value= options->u_max_value= *(uchar***) (opt + 1);\n\n    char *option_name_ptr;\n    options[1]= options[0];\n    options[1].id= -1;\n    options[1].name= option_name_ptr= (char*) alloc_root(mem_root,\n                                                        plugin_dash.length +\n                                                        optnamelen + 1);\n    options[1].comment= 0; /* Hidden from the help text */\n    strxmov(option_name_ptr, plugin_dash.str, optname, NullS);\n\n    options+= 2;\n  }\n\n  DBUG_RETURN(0);\n}\n\n\nstatic my_option *construct_help_options(MEM_ROOT *mem_root,\n                                         st_plugin_int *p)\n{\n  st_mysql_sys_var **opt;\n  my_option *opts;\n  uint count= EXTRA_OPTIONS;\n  DBUG_ENTER(\"construct_help_options\");\n\n  for (opt= p->plugin->system_vars; opt && *opt; opt++, count+= 2)\n    ;\n\n  if (!(opts= (my_option*) alloc_root(mem_root, sizeof(my_option) * count)))\n    DBUG_RETURN(NULL);\n\n  memset(opts, 0, sizeof(my_option) * count);\n\n  /**\n    some plugin variables (those that don't have PLUGIN_VAR_NOSYSVAR flag)\n    have their names prefixed with the plugin name. Restore the names here\n    to get the correct (not double-prefixed) help text.\n    We won't need @@sysvars anymore and don't care about their proper names.\n  */\n  restore_pluginvar_names(p->system_vars);\n\n  if (construct_options(mem_root, p, opts))\n    DBUG_RETURN(NULL);\n\n  DBUG_RETURN(opts);\n}\n\n\n/**\n  Check option being used and raise deprecation warning if required.\n\n  @param optid ID of the option that was passed through command line\n  @param opt List of options\n  @argument Status of the option : Enable or Disable\n\n  A deprecation warning will be raised if --plugin-xxx type of option\n  is used.\n\n  @return Always returns success as purpose of the function is to raise\n  warning only.\n  @retval 0 Success\n*/\n\nstatic my_bool check_if_option_is_deprecated(int optid,\n                                             const struct my_option *opt,\n                                             char *argument MY_ATTRIBUTE((unused)))\n{\n  if (optid == -1)\n  {\n    push_deprecated_warn(NULL, opt->name, (opt->name + strlen(\"plugin-\")));\n  }\n  return 0;\n}\n\n\n/**\n  Create and register system variables supplied from the plugin and\n  assigns initial values from corresponding command line arguments.\n\n  @param tmp_root Temporary scratch space\n  @param[out] plugin Internal plugin structure\n  @param argc Number of command line arguments\n  @param argv Command line argument vector\n\n  The plugin will be updated with a policy on how to handle errors during\n  initialization.\n\n  @note Requires that a write-lock is held on LOCK_system_variables_hash\n\n  @return How initialization of the plugin should be handled.\n    @retval  0 Initialization should proceed.\n    @retval  1 Plugin is disabled.\n    @retval -1 An error has occurred.\n*/\n\nstatic int test_plugin_options(MEM_ROOT *tmp_root, st_plugin_int *tmp,\n                               int *argc, char **argv)\n{\n  struct sys_var_chain chain= { NULL, NULL };\n  bool disable_plugin;\n  enum_plugin_load_option plugin_load_option= tmp->load_option;\n\n  MEM_ROOT *mem_root= alloc_root_inited(&tmp->mem_root) ?\n                      &tmp->mem_root : &plugin_mem_root;\n  st_mysql_sys_var **opt;\n  my_option *opts= NULL;\n  LEX_STRING plugin_name;\n  char *varname;\n  int error;\n  sys_var *v MY_ATTRIBUTE((unused));\n  st_bookmark *var;\n  size_t len;\n  uint count= EXTRA_OPTIONS;\n  DBUG_ENTER(\"test_plugin_options\");\n  DBUG_ASSERT(tmp->plugin && tmp->name.str);\n\n  /*\n    The 'federated' and 'ndbcluster' storage engines are always disabled by\n    default.\n  */\n  if (!(my_strcasecmp(&my_charset_latin1, tmp->name.str, \"federated\") &&\n      my_strcasecmp(&my_charset_latin1, tmp->name.str, \"ndbcluster\")))\n    plugin_load_option= PLUGIN_OFF;\n\n  for (opt= tmp->plugin->system_vars; opt && *opt; opt++)\n    count+= 2; /* --{plugin}-{optname} and --plugin-{plugin}-{optname} */\n\n  if (count > EXTRA_OPTIONS || (*argc > 1))\n  {\n    if (!(opts= (my_option*) alloc_root(tmp_root, sizeof(my_option) * count)))\n    {\n      sql_print_error(\"Out of memory for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n    memset(opts, 0, sizeof(my_option) * count);\n\n    if (construct_options(tmp_root, tmp, opts))\n    {\n      sql_print_error(\"Bad options for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n\n    /*\n      We adjust the default value to account for the hardcoded exceptions\n      we have set for the federated and ndbcluster storage engines.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      opts[0].def_value= opts[1].def_value= plugin_load_option;\n\n    error= handle_options(argc, &argv, opts, check_if_option_is_deprecated);\n    (*argc)++; /* add back one for the program name */\n\n    if (error)\n    {\n       sql_print_error(\"Parsing options for plugin '%s' failed.\",\n                       tmp->name.str);\n       goto err;\n    }\n    /*\n     Set plugin loading policy from option value. First element in the option\n     list is always the <plugin name> option value.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      plugin_load_option= (enum_plugin_load_option) *(ulong*) opts[0].value;\n  }\n\n  disable_plugin= (plugin_load_option == PLUGIN_OFF);\n  tmp->load_option= plugin_load_option;\n\n  /*\n    If the plugin is disabled it should not be initialized.\n  */\n  if (disable_plugin)\n  {\n    sql_print_information(\"Plugin '%s' is disabled.\",\n                          tmp->name.str);\n    if (opts)\n      my_cleanup_options(opts);\n    DBUG_RETURN(1);\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, tmp->name.str, \"NDBCLUSTER\"))\n  {\n    plugin_name.str= const_cast<char*>(\"ndb\"); // Use legacy \"ndb\" prefix\n    plugin_name.length= 3;\n  }\n  else\n    plugin_name= tmp->name;\n\n  error= 1;\n  for (opt= tmp->plugin->system_vars; opt && *opt; opt++)\n  {\n    st_mysql_sys_var *o;\n    if (((o= *opt)->flags & PLUGIN_VAR_NOSYSVAR))\n      continue;\n    if ((var= find_bookmark(plugin_name.str, o->name, o->flags)))\n      v= new (mem_root) sys_var_pluginvar(&chain, var->key + 1, o);\n    else\n    {\n      len= plugin_name.length + strlen(o->name) + 2;\n      varname= (char*) alloc_root(mem_root, len);\n      strxmov(varname, plugin_name.str, \"-\", o->name, NullS);\n      my_casedn_str(&my_charset_latin1, varname);\n      convert_dash_to_underscore(varname, len-1);\n      v= new (mem_root) sys_var_pluginvar(&chain, varname, o);\n    }\n    DBUG_ASSERT(v); /* check that an object was actually constructed */\n  } /* end for */\n  if (chain.first)\n  {\n    chain.last->next = NULL;\n    if (mysql_add_sys_var_chain(chain.first))\n    {\n      sql_print_error(\"Plugin '%s' has conflicting system variables\",\n                      tmp->name.str);\n      goto err;\n    }\n    tmp->system_vars= chain.first;\n  }\n  DBUG_RETURN(0);\n  \nerr:\n  if (opts)\n    my_cleanup_options(opts);\n  DBUG_RETURN(error);\n}\n\n\n/****************************************************************************\n  Help Verbose text with Plugin System Variables\n****************************************************************************/\n\n\nvoid add_plugin_options(std::vector<my_option> *options, MEM_ROOT *mem_root)\n{\n  my_option *opt;\n\n  if (!initialized)\n    return;\n\n  for (st_plugin_int **it= plugin_array->begin();\n       it != plugin_array->end(); ++it)\n  {\n    st_plugin_int *p= *it;\n\n    if (!(opt= construct_help_options(mem_root, p)))\n      continue;\n\n    /* Only options with a non-NULL comment are displayed in help text */\n    for (;opt->name; opt++)\n      if (opt->comment)\n        options->push_back(*opt);\n  }\n}\n\n/** \n  Searches for a correctly loaded plugin of a particular type by name\n\n  @param plugin   the name of the plugin we're looking for\n  @param type     type of the plugin (0-MYSQL_MAX_PLUGIN_TYPE_NUM)\n  @return plugin, or NULL if not found\n*/\nst_plugin_int *plugin_find_by_type(const LEX_CSTRING &plugin, int type)\n{\n  st_plugin_int *ret;\n  DBUG_ENTER(\"plugin_find_by_type\");\n\n  ret= plugin_find_internal(plugin, type);\n  DBUG_RETURN(ret && ret->state == PLUGIN_IS_READY ? ret : NULL);\n}\n\n\n/** \n  Locks the plugin strucutres so calls to plugin_find_inner can be issued.\n\n  Must be followed by unlock_plugin_data.\n*/\nint lock_plugin_data()\n{\n  DBUG_ENTER(\"lock_plugin_data\");\n  DBUG_RETURN(mysql_mutex_lock(&LOCK_plugin));\n}\n\n\n/** \n  Unlocks the plugin strucutres as locked by lock_plugin_data()\n*/\nint unlock_plugin_data()\n{\n  DBUG_ENTER(\"unlock_plugin_data\");\n  DBUG_RETURN(mysql_mutex_unlock(&LOCK_plugin));\n}\n\n\nbool Sql_cmd_install_plugin::execute(THD *thd)\n{\n  bool st= mysql_install_plugin(thd, &m_comment, &m_ident);\n  if (!st)\n    my_ok(thd);\n#ifndef EMBEDDED_LIBRARY\n  mysql_audit_release(thd);\n#endif\n  return st;\n}\n\n\nbool Sql_cmd_uninstall_plugin::execute(THD *thd)\n{\n  bool st= mysql_uninstall_plugin(thd, &m_comment);\n  if (!st)\n    my_ok(thd);\n#ifndef EMBEDDED_LIBRARY\n  mysql_audit_release(thd);\n#endif\n  return st;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/cmake/os/SunOS.cmake": "# Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; version 2 of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA \n\nINCLUDE(CheckSymbolExists)\nINCLUDE(CheckCSourceRuns)\nINCLUDE(CheckCSourceCompiles) \nINCLUDE(CheckCXXSourceCompiles)\n\n# We require at least GCC 4.4 or SunStudio 12u2 (CC 5.11)\nIF(NOT FORCE_UNSUPPORTED_COMPILER)\n  IF(CMAKE_COMPILER_IS_GNUCC)\n    EXECUTE_PROCESS(COMMAND ${CMAKE_C_COMPILER} -dumpversion\n                    OUTPUT_VARIABLE GCC_VERSION)\n    IF(GCC_VERSION VERSION_LESS 4.4)\n      MESSAGE(FATAL_ERROR \"GCC 4.4 or newer is required!\")\n    ENDIF()\n  ELSEIF(CMAKE_C_COMPILER_ID MATCHES \"SunPro\")\n    # CC -V yields\n    # CC: Studio 12.6 Sun C++ 5.15 SunOS_sparc Beta 2016/12/19\n    # CC: Studio 12.5 Sun C++ 5.14 SunOS_sparc Dodona 2016/04/04\n    # CC: Sun C++ 5.13 SunOS_sparc Beta 2014/03/11\n    # CC: Sun C++ 5.11 SunOS_sparc 2010/08/13\n    EXECUTE_PROCESS(\n      COMMAND ${CMAKE_CXX_COMPILER} \"-V\"\n      OUTPUT_VARIABLE stdout\n      ERROR_VARIABLE  stderr\n      RESULT_VARIABLE result\n    )\n    STRING(REGEX MATCH \"CC: Sun C\\\\+\\\\+ 5\\\\.([0-9]+)\" VERSION_STRING ${stderr})\n    IF (NOT CMAKE_MATCH_1 OR CMAKE_MATCH_1 STREQUAL \"\")\n      STRING(REGEX MATCH \"CC: Studio 12\\\\.[56] Sun C\\\\+\\\\+ 5\\\\.([0-9]+)\"\n        VERSION_STRING ${stderr})\n    ENDIF()\n    SET(CC_MINOR_VERSION ${CMAKE_MATCH_1})\n    IF(${CC_MINOR_VERSION} LESS 11)\n      MESSAGE(FATAL_ERROR \"SunStudio 12u2 or newer is required!\")\n    ENDIF()\n  ELSE()\n    MESSAGE(FATAL_ERROR \"Unsupported compiler!\")\n  ENDIF()\nENDIF()\n\n# Enable 64 bit file offsets\nADD_DEFINITIONS(-D_FILE_OFFSET_BITS=64)\n\n# Enable general POSIX extensions. See standards(5) man page.\nADD_DEFINITIONS(-D__EXTENSIONS__)\n\n# Solaris threads with POSIX semantics:\n# http://docs.oracle.com/cd/E19455-01/806-5257/6je9h033k/index.html\nADD_DEFINITIONS(-D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_PTHREADS)\n\nIF (NOT \"${CMAKE_C_FLAGS}${CMAKE_CXX_FLAGS}\" MATCHES \"-m32|-m64\")\n  EXECUTE_PROCESS(COMMAND isainfo -b\n    OUTPUT_VARIABLE ISAINFO_B\n    RESULT_VARIABLE ISAINFO_B_RES\n    OUTPUT_STRIP_TRAILING_WHITESPACE)\n  IF(ISAINFO_B_RES)\n    MESSAGE(STATUS \"Failed to run isainfo -b to determine arch bits: \"\n      \"${ISAINFO_B_RES}. Falling back to compiler's default.\")\n  ELSE()\n    MESSAGE(\"Adding -m${ISAINFO_B}\")\n    SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -m${ISAINFO_B}\")\n    SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -m${ISAINFO_B}\")\n    SET(CMAKE_C_LINK_FLAGS \"${CMAKE_C_LINK_FLAGS} -m${ISAINFO_B}\")\n    SET(CMAKE_CXX_LINK_FLAGS \"${CMAKE_CXX_LINK_FLAGS} -m${ISAINFO_B}\")\n  ENDIF()\nELSE()\n  IF(\"${CMAKE_C_FLAGS}\" MATCHES \"-m32\")\n    SET(CMAKE_C_LINK_FLAGS \"${CMAKE_C_LINK_FLAGS} -m32\")\n    SET(CMAKE_CXX_LINK_FLAGS \"${CMAKE_CXX_LINK_FLAGS} -m32\")\n  ELSE()\n    SET(CMAKE_C_LINK_FLAGS \"${CMAKE_C_LINK_FLAGS} -m64\")\n    SET(CMAKE_CXX_LINK_FLAGS \"${CMAKE_CXX_LINK_FLAGS} -m64\")\n  ENDIF()\nENDIF()\n\n# On  Solaris, use of intrinsics will screw the lib search logic\n# Force using -lm, so rint etc are found.\nSET(LIBM m)\n\n# CMake defined -lthread as thread flag. This crashes in dlopen \n# when trying to load plugins workaround with -lpthread\nSET(CMAKE_THREAD_LIBS_INIT -lpthread CACHE INTERNAL \"\" FORCE)\n\n# Solaris specific large page support\nCHECK_SYMBOL_EXISTS(MHA_MAPSIZE_VA sys/mman.h  HAVE_SOLARIS_LARGE_PAGES)\n\n# Solaris atomics\nCHECK_C_SOURCE_RUNS(\n \"\n #include  <atomic.h>\n  int main()\n  {\n    int foo = -10; int bar = 10;\n    int64_t foo64 = -10; int64_t bar64 = 10;\n    if (atomic_add_int_nv((uint_t *)&foo, bar) || foo)\n      return -1;\n    bar = atomic_swap_uint((uint_t *)&foo, (uint_t)bar);\n    if (bar || foo != 10)\n     return -1;\n    bar = atomic_cas_uint((uint_t *)&bar, (uint_t)foo, 15);\n    if (bar)\n      return -1;\n    if (atomic_add_64_nv((volatile uint64_t *)&foo64, bar64) || foo64)\n      return -1;\n    bar64 = atomic_swap_64((volatile uint64_t *)&foo64, (uint64_t)bar64);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64 = atomic_cas_64((volatile uint64_t *)&bar64, (uint_t)foo64, 15);\n    if (bar64)\n      return -1;\n    atomic_or_64((volatile uint64_t *)&bar64, 0);\n    return 0;\n  }\n\"  HAVE_SOLARIS_ATOMIC)\n\nCHECK_CXX_SOURCE_COMPILES(\"\n    #undef inline\n    #if !defined(_REENTRANT)\n    #define _REENTRANT\n    #endif\n    #include <pthread.h>\n    #include <sys/types.h>\n    #include <sys/socket.h>\n    #include <netinet/in.h>\n    #include <arpa/inet.h>\n    #include <netdb.h>\n    int main()\n    {\n\n       struct hostent *foo =\n       gethostbyaddr_r((const char *) 0,\n          0, 0, (struct hostent *) 0, (char *) NULL,  0, (int *)0);\n       return 0;\n    }\n  \"\n  HAVE_SOLARIS_STYLE_GETHOST)\n\n# Check is special processor flag needs to be set on older GCC\n#that defaults to v8 sparc . Code here is taken from my_rdtsc.c \nIF(CMAKE_COMPILER_IS_GNUCC AND CMAKE_SIZEOF_VOID_P EQUAL 4\n  AND CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n  SET(SOURCE\n  \"\n  int main()\n  {\n     long high\\;\n     long low\\;\n    __asm __volatile__ (\\\"rd %%tick,%1\\; srlx %1,32,%0\\\" : \\\"=r\\\" ( high), \\\"=r\\\" (low))\\;\n    return 0\\;\n  } \")\n  CHECK_C_SOURCE_COMPILES(${SOURCE}  HAVE_SPARC32_TICK)\n  IF(NOT HAVE_SPARC32_TICK)\n    SET(CMAKE_REQUIRED_FLAGS \"-mcpu=v9\")\n    CHECK_C_SOURCE_COMPILES(${SOURCE}  HAVE_SPARC32_TICK_WITH_V9)\n    SET(CMAKE_REQUIRED_FLAGS)\n    IF(HAVE_SPARC32_TICK_WITH_V9)\n      SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -mcpu=v9\")\n      SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -mcpu=v9\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n# This is used for the version_compile_machine variable.\nIF(CMAKE_SIZEOF_VOID_P MATCHES 8 AND CMAKE_SYSTEM_PROCESSOR MATCHES \"i386\")\n  SET(MYSQL_MACHINE_TYPE \"x86_64\")\nENDIF()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/src/common/logger/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/src/ndbapi/NdbUtil.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/src/ndbapi/NdbUtil.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/src/kernel/blocks/new-block.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/src/kernel/blocks/dbdih/Dbdih.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/src/kernel/blocks/dbdict/Slave_AddTable.sfl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-header-dropdown-btn.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-left.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/oracle_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/settings.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/box-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/icon-gauge.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-left-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-header-history.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/start.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/icon-network.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/welcome-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/welcome-title.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-header-search-btn.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-right.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/tab-separator.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-right-bottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-right-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/icons.odg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/greenlight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-title-o-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/icon_continue_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/link-item.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/last.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/deploy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-left-bottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-header-enterprise.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/welcome-mysql-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-title.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/redlight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/vertical-separator.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/icon-stopwatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/yellowlight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-bottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/stop.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/anyhost.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/icon_new_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/img/icon-cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/storage/storage_dialog.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/storage/Storage.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/storage/storage_dialog.fla",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/grip_bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/resizeRtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/pixel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/splitterToggleH.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/gridcontainer_grip.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/rotator.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/resize.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/splitterToggleV.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/compatGrid.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/enhanced/resources/images/sprite_icons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/tabEnabled_rotated.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/header.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/header_shadow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/tabHover_rotated.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/row_back.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/grid_sort_up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/grid_sort_down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/td_button_down.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/grid_dx_gradient.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/embed/resources/version.mov",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowTL.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowT.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowTR.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowR.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowBR.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowL.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowB.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowBL.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/rheader.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomouttime.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/parentnode_filled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/save.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/projProgressFilled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/resourceBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/parentnode_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/collapse.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomin.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskProgressFilled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/expand.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/rowHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/resourceHeader.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskArrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/load.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomintime.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/ownerBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/arrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomout.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskProgressBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/progress_filled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/rbg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/menuHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/pm.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/am.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/progress_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/projProgressBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/left.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/buttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/buttons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/right.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/close_dark.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/drawing/resources/CrazyTruck.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/drawing/resources/images/tool_icons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/drawing/resources/images/tool_sprites.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/smiley.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/previewDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/anchor.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/anchorDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/smileyDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/preview.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pasteFromWordDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/editorIconsFindReplaceEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/save.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/showBlockNodesDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/editorIconsFindReplaceDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/breadcrumbDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/insertEntity.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/saveDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pageBreak.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/blockquoteDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/blockquote.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/showBlockNodes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/spellcheck.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pageBreakDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pasteFromWord.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/insertEntityDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/autoSave.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/soria/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/tundra/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/nihilo/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/claro/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tableIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/anchor.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/cellspace.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/uploadImageIcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tableIcons_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/cellpad.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/busy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/fieldset.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/address.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/ul.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/dd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/dt.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/noscript.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/iframe.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/center.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/div.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/ol.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/map.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/blockquote.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/button.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/script.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/p.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/form.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/li.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/hr.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/ins.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/del.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/object.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/table.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/pre.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/soria/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/soria/sidebar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/soria/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tundra/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tundra/sidebar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tundra/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/nihilo/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/nihilo/sidebar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/nihilo/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/claro/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/claro/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonHalf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonCool.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonAngel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonAngry.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonGrin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonTongue.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonShy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonNo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonHappy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonLaughing.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonCrying.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonIdea.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonFrown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonSmile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonOops.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonGoofy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonWink.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonYes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonEyebrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/sketch/resources/images/icons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/compat/spinwheel-bar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/compat/spinwheel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonDarkBlueMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueCircleArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenCirclePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueCirclePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonDarkBlueCheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCirclePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonCheckboxOff.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteUpArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleRedCross.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlackCircleCross.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteSearch.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenCircleArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleGreenPlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteCheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonYellowStar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCircleMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhitePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayStar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBluePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueCircleMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleGreenButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleDownArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonDarkBluePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenCircleMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonOrangeBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCircleArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonCheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedPlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonCheckboxOn.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleGrayButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteDownArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleOrangeButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/dijit/compat/calendar-daylabel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/dijit/compat/calendar-month-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/dijit/compat/calendar-year-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/togglebutton-chk-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-orange-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-default-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-default-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-default-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/gray-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/ui-widget-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-orange-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-default-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-default-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-default-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/gray-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-head.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-default-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-default-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-default-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/blue-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tooltip-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tooltip-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/gray-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/red-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/edge-categ-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/white-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/uploader.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/fileuploader.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/soriaFolderSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/nihiloFolderSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/rating_full.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/tundraFolderSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/loading_wheel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/rating_empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/tristatecheckboxStates.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomin.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomout.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomout.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/resources/audio.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/resources/video.swf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/resources/version.mov",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/progressPositionBk.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/progressLoadedBk.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/player_sprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/sliderHandleSprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/sliderHandleNorm.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/sliderHandleOver.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/dojoPlayerIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/FilePicker/images/soriaFileIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/FilePicker/images/nihiloFileIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/FilePicker/images/tundraFileIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Dialog/images/dialogCloseButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Dialog/images/dialogCloseButton.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/pageInactive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/hPrevious.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/hNext.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/pageActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/vNext.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/vPrevious.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Standby/images/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Portlet/images/icons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Portlet/images/icons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/hue.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/hueHandleA11y.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/pickerPointer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/underlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/hueHandle.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Loader/icons/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsDisabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/loadingAnimation_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActDisabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsEnabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled8bit_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/a11y/colors7x10.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/a11y/indeterminate_progress.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/a11y/colors3x4.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmallBl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabLeftChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteDivIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderEmptyVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteCheckbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomHoverC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerV-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/titleBarActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabStripeRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI_half_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/accordionItemActive.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFullVerticalFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorUp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabStripe.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRadio.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmallBl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/accordionItemActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerH-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabStripeBottom.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabRightChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI_half.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomHoverSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/validationInputBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomEnabledC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomEnabledSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomActiveC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteArrows.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerH.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabStripeLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRadio.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerV.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteCheckbox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteDivIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/validationInputBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFullFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabContainerSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFullVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomActiveSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim.psd",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderEmptyVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dijitProgressBarAnim.psd",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dojoTundraGradientBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabClose.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/comboArrowDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/folderOpened.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dojoTundraGradientBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteRoundedIconsSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabCloseHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/leaf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/smallArrowDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerV-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i_half_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonActiveHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/accordionItemActive.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFullVerticalFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/plusButton.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorUp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/noX.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_mius.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmark.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_leaf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/calendarYearLabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/accordionItemHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_minus_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabClose.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_plus_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-9.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-6.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-5.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/titleBarBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerH-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/circleIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i_half.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/doubleArrowDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/validationInputBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabCloseHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmarkNoBorder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/popupMenuBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/folderClosed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteArrows.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dijitProgressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerH.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/smallArrowUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmark.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/minusButton.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerV.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmarkNoBorder.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/no.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonActiveDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/validationInputBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFullFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/circleIcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteRoundedIconsSmall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-7.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_leaf_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/calendarDayLabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/doubleArrowUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/calendarMonthLabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFullVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabLeftChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteDivIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderEmptyVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteCheckbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomHoverC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRoundedIconsSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerV-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/titleBarActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabStripeRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI_half_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFullVerticalFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorUp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabStripe.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRadio.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/accordionItemActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerH-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabStripeBottom.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabRightChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI_half.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomHoverSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/validationInputBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomEnabledC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomEnabledSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomActiveC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteArrows.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerH.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabStripeLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRadio.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerV.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/no.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteCheckbox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteDivIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/validationInputBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFullFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabContainerSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRoundedIconsSmall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFullVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomActiveSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/accordion.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabClose.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabBottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/splitterVerticalHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabTop.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/splitterHorizontalHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabNested.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/dnd.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/titlebar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/commonHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/tooltip8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/treeExpandImages8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/treeExpandImages.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/dialogCloseIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/calendarArrows8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/checkmarkNoBorder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/tooltip.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/tooltipGradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/calendarArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/loadingAnimation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/checkmarkNoBorder.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/menuHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/calendarContainerImages.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/dialogCloseIcon8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/commonFormArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/sliderVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/button_grad_d.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/checkboxRadioButtonStates.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/button.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/sliderHorizontal.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/buttonArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/textBox_back.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/sliderThumbs.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/checkboxAndRadioButtons_IE6.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/shadow.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/formHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/deploy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/breadcrumb_trail.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/edit_selected_hosts.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/define_parameters.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/mysqld_parameters_overridden.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/define_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/welcome.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/add_process.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/mysqld_parameters.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/help_menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/page_buttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/starting_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/define_hosts.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/define_processes.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/mcc/frontend/hlp/img/settings_menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/include/ndbapi/NdbScanFilter.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/include/transporter/TransporterCallback.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/test/include/getarg.h",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/storage/ndb/test/run-test/atrt-example.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/strings/decimal.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/strings/ctype-latin1.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/strings/ctype-czech.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/packaging/WiX/AdminBackground.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/packaging/WiX/AdminHeader.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/packaging/WiX/MySQLServer.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/packaging/WiX/mysqlcommandlineshell.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/bin/encodings/utf32bebom.json",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/bin/encodings/utf16le.json",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/bin/encodings/utf32be.json",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/bin/encodings/utf16be.json",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/bin/encodings/utf32le.json",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/bin/encodings/utf32lebom.json",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/test/unittest/readertest.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/doc/diagram/normalparsing.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/doc/diagram/move3.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/doc/diagram/insituparsing.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/doc/diagram/move2.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/doc/diagram/iterative-parser-states-diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/doc/diagram/move1.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/doc/diagram/simpledom.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/doc/diagram/tutorial.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/rapidjson/doc/logo/rapidjson.png",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/yassl/taocrypt/benchmark/dsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/yassl/taocrypt/benchmark/rsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/yassl/taocrypt/benchmark/dh1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/yassl/certs/client-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/yassl/certs/dsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/extra/yassl/certs/client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/wl6219_55.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/wl6219_55.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/wl7957_1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/55_temporal.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug37631.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug49823.CSM",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/corrupt-relay-bin.000624",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/wl6219_41.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/binlog_no_fd_event.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/wl6219_41.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/old_table-323.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug49823.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/14897.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/loaddata6.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/41_decimal.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/binlog_truncated_event.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/loaddata7.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/cluster_7022_table.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/55_temporal.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug16266.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug17532932.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug47205.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug17532932.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug21542698.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/mylogin-bad-cipher.cnf",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug48265.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/41_decimal.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug46565.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug48633.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug47012.ARM",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/55_temporal.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug19371.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug20444737.sql",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/wl6219_55_innodb.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/corrupt_t1#P#p1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug48633.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/wl6219_55.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/wl6219_41.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug47012.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/cluster_7022_table.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug48633.ARM",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug33029-slave-relay-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/binlog_savepoint.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/wl7957_1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug36055.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/trunc_binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/binlog_transaction.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/binlog_transaction_with_GTID.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug47012.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug37631.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/corrupt_t1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug36055.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug19371.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug40482-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/41_decimal.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/binlog_truncated_prev_gtid_event.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug36055.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/binlog_transaction_with_anonymous_GTID.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug19371.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/vchar.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/bug46565.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_3.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1TIMESTAMP.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p1_first_1024.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1_blackhole.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p3.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t575.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p4.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/include/ctype_utf8mb4.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/include/subquery_sj.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/include/explain.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/include/func_in.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_undolog_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/bug54613/BACKUP-2.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/packed/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/packed/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/packed/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/hashmap/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/bug17275798/BACKUP-1.21.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/bug17275798/BACKUP-1-0.21.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/backups/bug17275798/BACKUP-1.21.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/r/ndb_grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb/t/ndb_grant.later",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/perfschema/r/misc.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/perfschema/r/statement_digest_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/perfschema/t/statement_digest_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb_fts/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb_fts/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb_fts/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/gcol/r/gcol_supported_sql_funcs_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/gcol/r/gcol_supported_sql_funcs_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/gis/r/geohash_functions.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/gis/r/geojson_functions.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/rpl/r/rpl_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/rpl/r/rpl_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/rpl/r/rpl_set_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/rpl/t/rpl_row_mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/rpl/t/rpl_set_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/rpl/t/rpl_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/ver_trunk_row_v2.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/bug11747887-bin.000003",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_r.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_s.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/std_data/binlog_old_version_4_1.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/r/binlog_stm_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/r/binlog_row_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/r/binlog_gtid_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/r/binlog_gtid_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/r/binlog_gtid_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/binlog/t/binlog_mysqlbinlog-cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/funcs_1/lib/DataGen_local.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/funcs_1/r/memory_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/funcs_1/r/innodb_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/funcs_1/r/myisam_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/opt_trace/r/charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/opt_trace/t/charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0208_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0212_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0201_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0208_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis3.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0201_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0212_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/std_data/jisx0201_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/include/trim_sjis.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_rtrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_join_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_alter_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_join_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_create_db_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_trim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_join_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_ps_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_reverse_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_substring_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_insert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_replace_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_replace_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_trim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_substring_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_charlength_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_subquery_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_reverse_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_select_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_length_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_where_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_subquery_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_create_db_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_convert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_insert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_like_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_union_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_convert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_right_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_trim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_reverse_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_substring_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_subquery_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_update_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_alter_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_enum_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_like_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_replace_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_left_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_update_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_instr_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_alter_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_convert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_length_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_ps_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_like_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_locate_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_charlength_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_rtrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_enum_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_right_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_create_db_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_enum_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_lpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_charlength_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_left_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_charset_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_rpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_left_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_locate_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_charset_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_lpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_ltrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_select_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_rtrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_select_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_where_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_lpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_create_tbl_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_update_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_locate_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_instr_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_where_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_rpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_instr_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_insert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_ltrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_rpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_length_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_right_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/r/jp_ltrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_rpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_ps_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_left_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_alter_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_ps_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_charset_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_create_db_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_insert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_join_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_enum_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_charlength_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_instr_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_update_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_substring_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_subquery_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_reverse_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_locate_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_create_tbl_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_locate_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_where_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_insert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_join_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_union_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_instr_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_substring_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_subquery_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_convert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_replace_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_like_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_left_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_select_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_enum_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_enum_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_join_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_length_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_insert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_select_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_length_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_right_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_reverse_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_instr_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_alter_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_convert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_subquery_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_charlength_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_rtrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_convert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_ltrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_like_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_where_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_lpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_create_db_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_lpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_rpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_like_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_right_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_locate_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_length_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_right_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_select_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_reverse_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_update_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_left_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_rtrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_charset_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_ltrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_rpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_rtrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_ltrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_trim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_where_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_trim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_replace_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_create_db_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_substring_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_lpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_charlength_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_replace_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_alter_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/jp/t/jp_update_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_index.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_column.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_older_compatibility1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_column.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_older_compatibility1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_index.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/iuds/r/strings_charsets_update_delete.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/engines/iuds/r/type_bit_iuds.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/collation_database_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/sql_log_bin_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/sql_quote_show_create_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/character_set_results_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/sql_warnings_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/collation_server_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/pseudo_slave_mode_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/sql_buffer_result_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/sql_big_selects_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/collation_connection_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/innodb_table_locks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/sql_notes_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/character_set_connection_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/character_set_client_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/query_cache_wlock_invalidate_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/character_set_client_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/innodb_support_xa_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/sql_safe_updates_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/sql_log_off_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/r/foreign_key_checks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/sql_log_bin_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/sql_warnings_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/sql_log_off_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/sql_notes_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/character_set_results_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/sql_buffer_result_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/character_set_client_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/sql_safe_updates_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/character_set_connection_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/sql_big_selects_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/collation_database_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/foreign_key_checks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/sql_quote_show_create_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/innodb_table_locks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/collation_server_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/pseudo_slave_mode_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/innodb_support_xa_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/query_cache_wlock_invalidate_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/sys_vars/t/collation_connection_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/r/innodb_bug11789106.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/crc32_endianness.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/log_corruption3.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/log_corruption.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/log_corruption0.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/log_corruption1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/log_corruption2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/log_corruption5.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/log_corruption6.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/portability_wl5980_linux.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/log_corruption4a.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/log_corruption4.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/innodb/t/portability_wl5980_windows.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/memcached/r/memc216_5_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/suite/ndb_rpl/t/ndb_apply_status.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/extra/binlog_tests/ctype_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/extra/rpl_tests/rpl_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_big5.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/alias.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_ucs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_utf8mb4_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/opt_hints.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_utf8mb4_heap.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/mysql_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/type_set.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_in_mrr_cost.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/errors.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/show_check.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_utf8mb4.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/mysqldump.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/mdl_tablespace.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/sp.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/cast.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_latin1_de.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/warnings.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/csv.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_gb18030_binlog.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/query_cache.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/date_formats.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ddl_i18n_koi8r.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/binary.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/mysqltest.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ps.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_many.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_like.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_latin2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/rowid_order_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_in_all.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_in_icp_mrr.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/type_decimal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_latin1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_utf8mb4_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_bitwise_ops.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/log_tables.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_gb18030_encoding_cn.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/union.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_test.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_recoding.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/explain.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/parser.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_tis620.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/outfile_loaddata.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/events_bugs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_in_mrr.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/signal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ddl_i18n_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_in_icp.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_in_none.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/alter_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_des_encrypt.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/type_enum.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/func_gconcat.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/ctype_cp1251.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/events_1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/r/grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/type_set.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_big5.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_latin1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/sp.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/union.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_ucs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/cast.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/warnings.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/parser.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/query_cache.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/func_like.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_gb18030_binlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_gb18030_encoding_cn.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/errors.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/events_bugs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/binary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/mysql_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_recoding.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/func_gconcat.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/alias.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_cp1251.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_latin1_de.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/events_1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/func_test.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/explain.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/opt_hints.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ps.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_utf8mb4.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_tis620.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/mysqldump.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/show_check.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ddl_i18n_koi8r.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/mysqltest.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/alter_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_many.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/type_decimal.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/log_tables.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/grant.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ctype_filesystem-master.opt",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/ddl_i18n_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/mysql-test/t/type_enum.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/sql/item_xmlfunc.cc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/sql/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/libmysqld/libmysqld.rc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/libmysqld/examples/builder-sample/emb_samples.dfm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/libmysqld/examples/builder-sample/snapshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/libmysqld/examples/builder-sample/images/logo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/libmysqld/examples/builder-sample/images/mysql.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/libmysqld/examples/builder-sample/images/db.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/libmysqld/examples/builder-sample/images/net.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.7.21-zeu5e4gzwcomrf47v2xxombxtbmxmlls/spack-src/libmysqld/examples/builder-sample/images/find.ico"
    ],
    "total_files": 26657
}