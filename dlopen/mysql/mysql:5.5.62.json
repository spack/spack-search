{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/configure.cmake": "# Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; version 2 of the License.\n# \n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n#\n\nINCLUDE (CheckCSourceCompiles)\nINCLUDE (CheckCXXSourceCompiles)\nINCLUDE (CheckStructHasMember)\nINCLUDE (CheckLibraryExists)\nINCLUDE (CheckFunctionExists)\nINCLUDE (CheckCCompilerFlag)\nINCLUDE (CheckCSourceRuns)\nINCLUDE (CheckSymbolExists)\n\n\n# WITH_PIC options.Not of much use, PIC is taken care of on platforms\n# where it makes sense anyway.\nIF(UNIX)\n  IF(APPLE)  \n    # OSX  executable are always PIC\n    SET(WITH_PIC ON)\n  ELSE()\n    OPTION(WITH_PIC \"Generate PIC objects\" OFF)\n    IF(WITH_PIC)\n      SET(CMAKE_C_FLAGS \n        \"${CMAKE_C_FLAGS} ${CMAKE_SHARED_LIBRARY_C_FLAGS}\")\n      SET(CMAKE_CXX_FLAGS \n        \"${CMAKE_CXX_FLAGS} ${CMAKE_SHARED_LIBRARY_CXX_FLAGS}\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n\n\n# System type affects version_compile_os variable \nIF(NOT SYSTEM_TYPE)\n  IF(PLATFORM)\n    SET(SYSTEM_TYPE ${PLATFORM})\n  ELSE()\n    SET(SYSTEM_TYPE ${CMAKE_SYSTEM_NAME})\n  ENDIF()\nENDIF()\n\n\nIF(CMAKE_COMPILER_IS_GNUCXX)\n  # MySQL \"canonical\" GCC flags. At least -fno-rtti flag affects\n  # ABI and cannot be simply removed. \n  SET(CMAKE_CXX_FLAGS \n    \"${CMAKE_CXX_FLAGS} -fno-implicit-templates -fno-exceptions -fno-rtti\")\n  IF(CMAKE_CXX_FLAGS)\n    STRING(REGEX MATCH \"fno-implicit-templates\" NO_IMPLICIT_TEMPLATES\n      ${CMAKE_CXX_FLAGS})\n    IF (NO_IMPLICIT_TEMPLATES)\n      SET(HAVE_EXPLICIT_TEMPLATE_INSTANTIATION TRUE)\n    ENDIF()\n  ENDIF()\n\n  IF (CMAKE_EXE_LINKER_FLAGS MATCHES \" -static \" \n     OR CMAKE_EXE_LINKER_FLAGS MATCHES \" -static$\")\n     SET(HAVE_DLOPEN FALSE CACHE \"Disable dlopen due to -static flag\" FORCE)\n     SET(WITHOUT_DYNAMIC_PLUGINS TRUE)\n  ENDIF()\nENDIF()\n\nIF(WITHOUT_DYNAMIC_PLUGINS)\n  MESSAGE(\"Dynamic plugins are disabled.\")\nENDIF(WITHOUT_DYNAMIC_PLUGINS)\n\n# Large files, common flag\nSET(_LARGEFILE_SOURCE  1)\n\n# If finds the size of a type, set SIZEOF_<type> and HAVE_<type>\nFUNCTION(MY_CHECK_TYPE_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# Same for structs, setting HAVE_STRUCT_<name> instead\nFUNCTION(MY_CHECK_STRUCT_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"struct ${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_STRUCT_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# Searches function in libraries\n# if function is found, sets output parameter result to the name of the library\n# if function is found in libc, result will be empty \nFUNCTION(MY_SEARCH_LIBS func libs result)\n  IF(${${result}})\n    # Library is already found or was predefined\n    RETURN()\n  ENDIF()\n  CHECK_FUNCTION_EXISTS(${func} HAVE_${func}_IN_LIBC)\n  IF(HAVE_${func}_IN_LIBC)\n    SET(${result} \"\" PARENT_SCOPE)\n    RETURN()\n  ENDIF()\n  FOREACH(lib  ${libs})\n    CHECK_LIBRARY_EXISTS(${lib} ${func} \"\" HAVE_${func}_IN_${lib}) \n    IF(HAVE_${func}_IN_${lib})\n      SET(${result} ${lib} PARENT_SCOPE)\n      SET(HAVE_${result} 1 PARENT_SCOPE)\n      RETURN()\n    ENDIF()\n  ENDFOREACH()\nENDFUNCTION()\n\n# Find out which libraries to use.\nIF(UNIX)\n  MY_SEARCH_LIBS(floor m LIBM)\n  IF(NOT LIBM)\n    MY_SEARCH_LIBS(__infinity m LIBM)\n  ENDIF()\n  MY_SEARCH_LIBS(gethostbyname_r  \"nsl_r;nsl\" LIBNSL)\n  MY_SEARCH_LIBS(bind \"bind;socket\" LIBBIND)\n  MY_SEARCH_LIBS(crypt crypt LIBCRYPT)\n  MY_SEARCH_LIBS(setsockopt socket LIBSOCKET)\n  MY_SEARCH_LIBS(dlopen dl LIBDL)\n  MY_SEARCH_LIBS(sched_yield rt LIBRT)\n  IF(NOT LIBRT)\n    MY_SEARCH_LIBS(clock_gettime rt LIBRT)\n  ENDIF()\n  FIND_PACKAGE(Threads)\n\n  SET(CMAKE_REQUIRED_LIBRARIES \n    ${LIBM} ${LIBNSL} ${LIBBIND} ${LIBCRYPT} ${LIBSOCKET} ${LIBDL} ${CMAKE_THREAD_LIBS_INIT} ${LIBRT})\n  # Need explicit pthread for gcc -fsanitize=address\n  IF(CMAKE_USE_PTHREADS_INIT AND CMAKE_C_FLAGS MATCHES \"-fsanitize=\")\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} pthread)\n  ENDIF()\n\n  LIST(LENGTH CMAKE_REQUIRED_LIBRARIES required_libs_length)\n  IF(${required_libs_length} GREATER 0)\n    LIST(REMOVE_DUPLICATES CMAKE_REQUIRED_LIBRARIES)\n  ENDIF()  \n  LINK_LIBRARIES(${CMAKE_THREAD_LIBS_INIT})\n  \n  OPTION(WITH_LIBWRAP \"Compile with tcp wrappers support\" OFF)\n  IF(WITH_LIBWRAP)\n    SET(SAVE_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} wrap)\n    CHECK_C_SOURCE_COMPILES(\n    \"\n    #include <tcpd.h>\n    int allow_severity = 0;\n    int deny_severity  = 0;\n    int main()\n    {\n      hosts_access(0);\n    }\"\n    HAVE_LIBWRAP)\n    SET(CMAKE_REQUIRED_LIBRARIES ${SAVE_CMAKE_REQUIRED_LIBRARIES})\n    IF(HAVE_LIBWRAP)\n      SET(MYSYS_LIBWRAP_SOURCE  ${CMAKE_SOURCE_DIR}/mysys/my_libwrap.c)\n      SET(LIBWRAP \"wrap\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n#\n# Tests for header files\n#\nINCLUDE (CheckIncludeFiles)\n\nCHECK_INCLUDE_FILES (\"stdlib.h;stdarg.h;string.h;float.h\" STDC_HEADERS)\nCHECK_INCLUDE_FILES (sys/types.h HAVE_SYS_TYPES_H)\nCHECK_INCLUDE_FILES (alloca.h HAVE_ALLOCA_H)\nCHECK_INCLUDE_FILES (aio.h HAVE_AIO_H)\nCHECK_INCLUDE_FILES (arpa/inet.h HAVE_ARPA_INET_H)\nCHECK_INCLUDE_FILES (crypt.h HAVE_CRYPT_H)\nCHECK_INCLUDE_FILES (cxxabi.h HAVE_CXXABI_H)\nCHECK_INCLUDE_FILES (dirent.h HAVE_DIRENT_H)\nCHECK_INCLUDE_FILES (dlfcn.h HAVE_DLFCN_H)\nCHECK_INCLUDE_FILES (execinfo.h HAVE_EXECINFO_H)\nCHECK_INCLUDE_FILES (fcntl.h HAVE_FCNTL_H)\nCHECK_INCLUDE_FILES (fenv.h HAVE_FENV_H)\nCHECK_INCLUDE_FILES (float.h HAVE_FLOAT_H)\nCHECK_INCLUDE_FILES (floatingpoint.h HAVE_FLOATINGPOINT_H)\nCHECK_INCLUDE_FILES (fpu_control.h HAVE_FPU_CONTROL_H)\nCHECK_INCLUDE_FILES (grp.h HAVE_GRP_H)\nCHECK_INCLUDE_FILES (ieeefp.h HAVE_IEEEFP_H)\nCHECK_INCLUDE_FILES (inttypes.h HAVE_INTTYPES_H)\nCHECK_INCLUDE_FILES (langinfo.h HAVE_LANGINFO_H)\nCHECK_INCLUDE_FILES (limits.h HAVE_LIMITS_H)\nCHECK_INCLUDE_FILES (locale.h HAVE_LOCALE_H)\nCHECK_INCLUDE_FILES (malloc.h HAVE_MALLOC_H)\nCHECK_INCLUDE_FILES (memory.h HAVE_MEMORY_H)\nCHECK_INCLUDE_FILES (ndir.h HAVE_NDIR_H)\nCHECK_INCLUDE_FILES (netinet/in.h HAVE_NETINET_IN_H)\nCHECK_INCLUDE_FILES (paths.h HAVE_PATHS_H)\nCHECK_INCLUDE_FILES (port.h HAVE_PORT_H)\nCHECK_INCLUDE_FILES (poll.h HAVE_POLL_H)\nCHECK_INCLUDE_FILES (pwd.h HAVE_PWD_H)\nCHECK_INCLUDE_FILES (sched.h HAVE_SCHED_H)\nCHECK_INCLUDE_FILES (select.h HAVE_SELECT_H)\nCHECK_INCLUDE_FILES (semaphore.h HAVE_SEMAPHORE_H)\nCHECK_INCLUDE_FILES (\"sys/types.h;sys/dir.h\" HAVE_SYS_DIR_H)\nCHECK_INCLUDE_FILES (sys/ndir.h HAVE_SYS_NDIR_H)\nCHECK_INCLUDE_FILES (sys/pte.h HAVE_SYS_PTE_H)\nCHECK_INCLUDE_FILES (stddef.h HAVE_STDDEF_H)\nCHECK_INCLUDE_FILES (stdint.h HAVE_STDINT_H)\nCHECK_INCLUDE_FILES (stdlib.h HAVE_STDLIB_H)\nCHECK_INCLUDE_FILES (strings.h HAVE_STRINGS_H)\nCHECK_INCLUDE_FILES (string.h HAVE_STRING_H)\nCHECK_INCLUDE_FILES (synch.h HAVE_SYNCH_H)\nCHECK_INCLUDE_FILES (sysent.h HAVE_SYSENT_H)\nCHECK_INCLUDE_FILES (sys/cdefs.h HAVE_SYS_CDEFS_H)\nCHECK_INCLUDE_FILES (sys/file.h HAVE_SYS_FILE_H)\nCHECK_INCLUDE_FILES (sys/fpu.h HAVE_SYS_FPU_H)\nCHECK_INCLUDE_FILES (sys/ioctl.h HAVE_SYS_IOCTL_H)\nCHECK_INCLUDE_FILES (sys/ipc.h HAVE_SYS_IPC_H)\nCHECK_INCLUDE_FILES (sys/malloc.h HAVE_SYS_MALLOC_H)\nCHECK_INCLUDE_FILES (sys/mman.h HAVE_SYS_MMAN_H)\nCHECK_INCLUDE_FILES (sys/prctl.h HAVE_SYS_PRCTL_H)\nCHECK_INCLUDE_FILES (sys/resource.h HAVE_SYS_RESOURCE_H)\nCHECK_INCLUDE_FILES (sys/select.h HAVE_SYS_SELECT_H)\nCHECK_INCLUDE_FILES (sys/shm.h HAVE_SYS_SHM_H)\nCHECK_INCLUDE_FILES (sys/socket.h HAVE_SYS_SOCKET_H)\nCHECK_INCLUDE_FILES (sys/stat.h HAVE_SYS_STAT_H)\nCHECK_INCLUDE_FILES (sys/stream.h HAVE_SYS_STREAM_H)\nCHECK_INCLUDE_FILES (sys/termcap.h HAVE_SYS_TERMCAP_H)\nCHECK_INCLUDE_FILES (\"time.h;sys/timeb.h\" HAVE_SYS_TIMEB_H)\nCHECK_INCLUDE_FILES (\"curses.h;term.h\" HAVE_TERM_H)\nCHECK_INCLUDE_FILES (asm/termbits.h HAVE_ASM_TERMBITS_H)\nCHECK_INCLUDE_FILES (termbits.h HAVE_TERMBITS_H)\nCHECK_INCLUDE_FILES (termios.h HAVE_TERMIOS_H)\nCHECK_INCLUDE_FILES (termio.h HAVE_TERMIO_H)\nCHECK_INCLUDE_FILES (termcap.h HAVE_TERMCAP_H)\nCHECK_INCLUDE_FILES (unistd.h HAVE_UNISTD_H)\nCHECK_INCLUDE_FILES (utime.h HAVE_UTIME_H)\nCHECK_INCLUDE_FILES (varargs.h HAVE_VARARGS_H)\nCHECK_INCLUDE_FILES (sys/time.h HAVE_SYS_TIME_H)\nCHECK_INCLUDE_FILES (sys/utime.h HAVE_SYS_UTIME_H)\nCHECK_INCLUDE_FILES (sys/wait.h HAVE_SYS_WAIT_H)\nCHECK_INCLUDE_FILES (sys/param.h HAVE_SYS_PARAM_H)\nCHECK_INCLUDE_FILES (sys/vadvise.h HAVE_SYS_VADVISE_H)\nCHECK_INCLUDE_FILES (fnmatch.h HAVE_FNMATCH_H)\nCHECK_INCLUDE_FILES (stdarg.h  HAVE_STDARG_H)\nCHECK_INCLUDE_FILES (\"stdlib.h;sys/un.h\" HAVE_SYS_UN_H)\nCHECK_INCLUDE_FILES (vis.h HAVE_VIS_H)\nCHECK_INCLUDE_FILES (wchar.h HAVE_WCHAR_H)\nCHECK_INCLUDE_FILES (wctype.h HAVE_WCTYPE_H)\n\nIF(HAVE_SYS_STREAM_H)\n  # Needs sys/stream.h on Solaris\n  CHECK_INCLUDE_FILES (\"sys/stream.h;sys/ptem.h\" HAVE_SYS_PTEM_H)\nELSE()\n  CHECK_INCLUDE_FILES (sys/ptem.h HAVE_SYS_PTEM_H)\nENDIF()\n\n# Figure out threading library\n#\nFIND_PACKAGE (Threads)\n\nFUNCTION(MY_CHECK_PTHREAD_ONCE_INIT)\n  CHECK_C_COMPILER_FLAG(\"-Werror\" HAVE_WERROR_FLAG)\n  IF(NOT HAVE_WERROR_FLAG)\n    RETURN()\n  ENDIF()\n  SET(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} -Werror\")\n  CHECK_C_SOURCE_COMPILES(\"\n    #include <pthread.h>\n    void foo(void) {}\n    int main()\n    {\n      pthread_once_t once_control = PTHREAD_ONCE_INIT;\n      pthread_once(&once_control, foo);\n      return 0;\n    }\"\n    HAVE_PTHREAD_ONCE_INIT\n  )\n  # http://bugs.opensolaris.org/bugdatabase/printableBug.do?bug_id=6611808\n  IF(NOT HAVE_PTHREAD_ONCE_INIT)\n    CHECK_C_SOURCE_COMPILES(\"\n      #include <pthread.h>\n      void foo(void) {}\n      int main()\n      {\n        pthread_once_t once_control = { PTHREAD_ONCE_INIT };\n        pthread_once(&once_control, foo);\n        return 0;\n      }\"\n      HAVE_ARRAY_PTHREAD_ONCE_INIT\n    )\n  ENDIF()\n  IF(HAVE_PTHREAD_ONCE_INIT)\n    SET(PTHREAD_ONCE_INITIALIZER \"PTHREAD_ONCE_INIT\" PARENT_SCOPE)\n  ENDIF()\n  IF(HAVE_ARRAY_PTHREAD_ONCE_INIT)\n    SET(PTHREAD_ONCE_INITIALIZER \"{ PTHREAD_ONCE_INIT }\" PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\nIF(CMAKE_USE_PTHREADS_INIT)\n  MY_CHECK_PTHREAD_ONCE_INIT()\nENDIF()\n\n#\n# Tests for functions\n#\n#CHECK_FUNCTION_EXISTS (aiowait HAVE_AIOWAIT)\nCHECK_FUNCTION_EXISTS (aio_read HAVE_AIO_READ)\nCHECK_FUNCTION_EXISTS (alarm HAVE_ALARM)\nSET(HAVE_ALLOCA 1)\nCHECK_FUNCTION_EXISTS (backtrace HAVE_BACKTRACE)\nCHECK_FUNCTION_EXISTS (backtrace_symbols HAVE_BACKTRACE_SYMBOLS)\nCHECK_FUNCTION_EXISTS (backtrace_symbols_fd HAVE_BACKTRACE_SYMBOLS_FD)\nCHECK_FUNCTION_EXISTS (printstack HAVE_PRINTSTACK)\nCHECK_FUNCTION_EXISTS (bfill HAVE_BFILL)\nCHECK_FUNCTION_EXISTS (bmove HAVE_BMOVE)\nCHECK_FUNCTION_EXISTS (bsearch HAVE_BSEARCH)\nCHECK_FUNCTION_EXISTS (index HAVE_INDEX)\nCHECK_FUNCTION_EXISTS (bzero HAVE_BZERO)\nCHECK_FUNCTION_EXISTS (clock_gettime HAVE_CLOCK_GETTIME)\nCHECK_FUNCTION_EXISTS (cuserid HAVE_CUSERID)\nCHECK_FUNCTION_EXISTS (directio HAVE_DIRECTIO)\nCHECK_FUNCTION_EXISTS (_doprnt HAVE_DOPRNT)\nCHECK_FUNCTION_EXISTS (flockfile HAVE_FLOCKFILE)\nCHECK_FUNCTION_EXISTS (ftruncate HAVE_FTRUNCATE)\nCHECK_FUNCTION_EXISTS (getline HAVE_GETLINE)\nCHECK_FUNCTION_EXISTS (compress HAVE_COMPRESS)\nCHECK_FUNCTION_EXISTS (crypt HAVE_CRYPT)\nCHECK_FUNCTION_EXISTS (dlerror HAVE_DLERROR)\nCHECK_FUNCTION_EXISTS (dlopen HAVE_DLOPEN)\nCHECK_FUNCTION_EXISTS (fchmod HAVE_FCHMOD)\nCHECK_FUNCTION_EXISTS (fcntl HAVE_FCNTL)\nCHECK_FUNCTION_EXISTS (fconvert HAVE_FCONVERT)\nCHECK_FUNCTION_EXISTS (fdatasync HAVE_FDATASYNC)\nCHECK_SYMBOL_EXISTS(fdatasync \"unistd.h\" HAVE_DECL_FDATASYNC)\nCHECK_FUNCTION_EXISTS (fesetround HAVE_FESETROUND)\nCHECK_FUNCTION_EXISTS (fedisableexcept HAVE_FEDISABLEEXCEPT)\nCHECK_FUNCTION_EXISTS (fpsetmask HAVE_FPSETMASK)\nCHECK_FUNCTION_EXISTS (fseeko HAVE_FSEEKO)\nCHECK_FUNCTION_EXISTS (fsync HAVE_FSYNC)\nCHECK_FUNCTION_EXISTS (getcwd HAVE_GETCWD)\nCHECK_FUNCTION_EXISTS (gethostbyaddr_r HAVE_GETHOSTBYADDR_R)\nCHECK_FUNCTION_EXISTS (gethrtime HAVE_GETHRTIME)\nCHECK_FUNCTION_EXISTS (getnameinfo HAVE_GETNAMEINFO)\nCHECK_FUNCTION_EXISTS (getpass HAVE_GETPASS)\nCHECK_FUNCTION_EXISTS (getpassphrase HAVE_GETPASSPHRASE)\nCHECK_FUNCTION_EXISTS (getpwnam HAVE_GETPWNAM)\nCHECK_FUNCTION_EXISTS (getpwuid HAVE_GETPWUID)\nCHECK_FUNCTION_EXISTS (getrlimit HAVE_GETRLIMIT)\nCHECK_FUNCTION_EXISTS (getrusage HAVE_GETRUSAGE)\nCHECK_FUNCTION_EXISTS (getwd HAVE_GETWD)\nCHECK_FUNCTION_EXISTS (gmtime_r HAVE_GMTIME_R)\nCHECK_FUNCTION_EXISTS (initgroups HAVE_INITGROUPS)\nCHECK_FUNCTION_EXISTS (issetugid HAVE_ISSETUGID)\nCHECK_FUNCTION_EXISTS (getuid HAVE_GETUID)\nCHECK_FUNCTION_EXISTS (geteuid HAVE_GETEUID)\nCHECK_FUNCTION_EXISTS (getgid HAVE_GETGID)\nCHECK_FUNCTION_EXISTS (getegid HAVE_GETEGID)\nCHECK_FUNCTION_EXISTS (ldiv HAVE_LDIV)\nCHECK_FUNCTION_EXISTS (localtime_r HAVE_LOCALTIME_R)\nCHECK_FUNCTION_EXISTS (longjmp HAVE_LONGJMP)\nCHECK_FUNCTION_EXISTS (lstat HAVE_LSTAT)\nCHECK_FUNCTION_EXISTS (madvise HAVE_MADVISE)\nCHECK_FUNCTION_EXISTS (mallinfo HAVE_MALLINFO)\nCHECK_FUNCTION_EXISTS (memcpy HAVE_MEMCPY)\nCHECK_FUNCTION_EXISTS (memmove HAVE_MEMMOVE)\nCHECK_FUNCTION_EXISTS (mkstemp HAVE_MKSTEMP)\nCHECK_FUNCTION_EXISTS (mlock HAVE_MLOCK)\nCHECK_FUNCTION_EXISTS (mlockall HAVE_MLOCKALL)\nCHECK_FUNCTION_EXISTS (mmap HAVE_MMAP)\nCHECK_FUNCTION_EXISTS (mmap64 HAVE_MMAP64)\nCHECK_FUNCTION_EXISTS (perror HAVE_PERROR)\nCHECK_FUNCTION_EXISTS (poll HAVE_POLL)\nCHECK_FUNCTION_EXISTS (port_create HAVE_PORT_CREATE)\nCHECK_FUNCTION_EXISTS (posix_fallocate HAVE_POSIX_FALLOCATE)\nCHECK_FUNCTION_EXISTS (pread HAVE_PREAD)\nCHECK_FUNCTION_EXISTS (pthread_attr_create HAVE_PTHREAD_ATTR_CREATE)\nCHECK_FUNCTION_EXISTS (pthread_attr_getstacksize HAVE_PTHREAD_ATTR_GETSTACKSIZE)\nCHECK_FUNCTION_EXISTS (pthread_attr_setscope HAVE_PTHREAD_ATTR_SETSCOPE)\nCHECK_FUNCTION_EXISTS (pthread_attr_setstacksize HAVE_PTHREAD_ATTR_SETSTACKSIZE)\nCHECK_FUNCTION_EXISTS (pthread_condattr_create HAVE_PTHREAD_CONDATTR_CREATE)\nCHECK_FUNCTION_EXISTS (pthread_condattr_setclock HAVE_PTHREAD_CONDATTR_SETCLOCK)\nCHECK_FUNCTION_EXISTS (pthread_key_delete HAVE_PTHREAD_KEY_DELETE)\nCHECK_FUNCTION_EXISTS (pthread_rwlock_rdlock HAVE_PTHREAD_RWLOCK_RDLOCK)\nCHECK_FUNCTION_EXISTS (pthread_sigmask HAVE_PTHREAD_SIGMASK)\nCHECK_FUNCTION_EXISTS (pthread_threadmask HAVE_PTHREAD_THREADMASK)\nCHECK_FUNCTION_EXISTS (pthread_yield_np HAVE_PTHREAD_YIELD_NP)\nCHECK_FUNCTION_EXISTS (putenv HAVE_PUTENV)\nCHECK_FUNCTION_EXISTS (readdir_r HAVE_READDIR_R)\nCHECK_FUNCTION_EXISTS (readlink HAVE_READLINK)\nCHECK_FUNCTION_EXISTS (re_comp HAVE_RE_COMP)\nCHECK_FUNCTION_EXISTS (regcomp HAVE_REGCOMP)\nCHECK_FUNCTION_EXISTS (realpath HAVE_REALPATH)\nCHECK_FUNCTION_EXISTS (rename HAVE_RENAME)\nCHECK_FUNCTION_EXISTS (rwlock_init HAVE_RWLOCK_INIT)\nCHECK_FUNCTION_EXISTS (sched_yield HAVE_SCHED_YIELD)\nCHECK_FUNCTION_EXISTS (setenv HAVE_SETENV)\nCHECK_FUNCTION_EXISTS (setlocale HAVE_SETLOCALE)\nCHECK_FUNCTION_EXISTS (setfd HAVE_SETFD)\nCHECK_FUNCTION_EXISTS (sigaction HAVE_SIGACTION)\nCHECK_FUNCTION_EXISTS (sigthreadmask HAVE_SIGTHREADMASK)\nCHECK_FUNCTION_EXISTS (sigwait HAVE_SIGWAIT)\nCHECK_FUNCTION_EXISTS (sigaddset HAVE_SIGADDSET)\nCHECK_FUNCTION_EXISTS (sigemptyset HAVE_SIGEMPTYSET)\nCHECK_FUNCTION_EXISTS (sighold HAVE_SIGHOLD) \nCHECK_FUNCTION_EXISTS (sigset HAVE_SIGSET)\nCHECK_FUNCTION_EXISTS (sleep HAVE_SLEEP)\nCHECK_FUNCTION_EXISTS (snprintf HAVE_SNPRINTF)\nCHECK_FUNCTION_EXISTS (stpcpy HAVE_STPCPY)\nCHECK_FUNCTION_EXISTS (strcoll HAVE_STRCOLL)\nCHECK_FUNCTION_EXISTS (strerror HAVE_STRERROR)\nCHECK_FUNCTION_EXISTS (strlcpy HAVE_STRLCPY)\nCHECK_FUNCTION_EXISTS (strnlen HAVE_STRNLEN)\nCHECK_FUNCTION_EXISTS (strlcat HAVE_STRLCAT)\nCHECK_FUNCTION_EXISTS (strsignal HAVE_STRSIGNAL)\nCHECK_FUNCTION_EXISTS (fgetln HAVE_FGETLN)\nCHECK_FUNCTION_EXISTS (strpbrk HAVE_STRPBRK)\nCHECK_FUNCTION_EXISTS (strsep HAVE_STRSEP)\nCHECK_FUNCTION_EXISTS (strstr HAVE_STRSTR)\nCHECK_FUNCTION_EXISTS (strtok_r HAVE_STRTOK_R)\nCHECK_FUNCTION_EXISTS (strtol HAVE_STRTOL)\nCHECK_FUNCTION_EXISTS (strtoll HAVE_STRTOLL)\nCHECK_FUNCTION_EXISTS (strtoul HAVE_STRTOUL)\nCHECK_FUNCTION_EXISTS (strtoull HAVE_STRTOULL)\nCHECK_FUNCTION_EXISTS (strcasecmp HAVE_STRCASECMP)\nCHECK_FUNCTION_EXISTS (strncasecmp HAVE_STRNCASECMP)\nCHECK_FUNCTION_EXISTS (strdup HAVE_STRDUP)\nCHECK_FUNCTION_EXISTS (shmat HAVE_SHMAT) \nCHECK_FUNCTION_EXISTS (shmctl HAVE_SHMCTL)\nCHECK_FUNCTION_EXISTS (shmdt HAVE_SHMDT)\nCHECK_FUNCTION_EXISTS (shmget HAVE_SHMGET)\nCHECK_FUNCTION_EXISTS (tell HAVE_TELL)\nCHECK_FUNCTION_EXISTS (tempnam HAVE_TEMPNAM)\nCHECK_FUNCTION_EXISTS (thr_setconcurrency HAVE_THR_SETCONCURRENCY)\nCHECK_FUNCTION_EXISTS (thr_yield HAVE_THR_YIELD)\nCHECK_FUNCTION_EXISTS (vasprintf HAVE_VASPRINTF)\nCHECK_FUNCTION_EXISTS (vsnprintf HAVE_VSNPRINTF)\nCHECK_FUNCTION_EXISTS (vprintf HAVE_VPRINTF)\nCHECK_FUNCTION_EXISTS (valloc HAVE_VALLOC)\nCHECK_FUNCTION_EXISTS (memalign HAVE_MEMALIGN)\nCHECK_FUNCTION_EXISTS (chown HAVE_CHOWN)\nCHECK_FUNCTION_EXISTS (nl_langinfo HAVE_NL_LANGINFO)\n\n#--------------------------------------------------------------------\n# Support for WL#2373 (Use cycle counter for timing)\n#--------------------------------------------------------------------\n\nCHECK_INCLUDE_FILES(time.h HAVE_TIME_H)\nCHECK_INCLUDE_FILES(sys/time.h HAVE_SYS_TIME_H)\nCHECK_INCLUDE_FILES(sys/times.h HAVE_SYS_TIMES_H)\nCHECK_INCLUDE_FILES(asm/msr.h HAVE_ASM_MSR_H)\n#msr.h has rdtscll()\n\nCHECK_INCLUDE_FILES(ia64intrin.h HAVE_IA64INTRIN_H)\n\nCHECK_FUNCTION_EXISTS(times HAVE_TIMES)\nCHECK_FUNCTION_EXISTS(gettimeofday HAVE_GETTIMEOFDAY)\nCHECK_FUNCTION_EXISTS(read_real_time HAVE_READ_REAL_TIME)\n# This should work on AIX.\n\nCHECK_FUNCTION_EXISTS(ftime HAVE_FTIME)\n# This is still a normal call for milliseconds.\n\nCHECK_FUNCTION_EXISTS(time HAVE_TIME)\n# We can use time() on Macintosh if there is no ftime().\n\nCHECK_FUNCTION_EXISTS(rdtscll HAVE_RDTSCLL)\n# I doubt that we'll ever reach the check for this.\n\n\n#\n# Tests for symbols\n#\n\nCHECK_SYMBOL_EXISTS(sys_errlist \"stdio.h\" HAVE_SYS_ERRLIST)\nCHECK_SYMBOL_EXISTS(madvise \"sys/mman.h\" HAVE_DECL_MADVISE)\nCHECK_SYMBOL_EXISTS(tzname \"time.h\" HAVE_TZNAME)\nCHECK_SYMBOL_EXISTS(lrand48 \"stdlib.h\" HAVE_LRAND48)\nCHECK_SYMBOL_EXISTS(getpagesize \"unistd.h\" HAVE_GETPAGESIZE)\nCHECK_SYMBOL_EXISTS(TIOCGWINSZ \"sys/ioctl.h\" GWINSZ_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/ioctl.h\" FIONREAD_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(TIOCSTAT \"sys/ioctl.h\" TIOCSTAT_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/filio.h\" FIONREAD_IN_SYS_FILIO)\nCHECK_SYMBOL_EXISTS(gettimeofday \"sys/time.h\" HAVE_GETTIMEOFDAY)\n\nCHECK_SYMBOL_EXISTS(finite  \"math.h\" HAVE_FINITE_IN_MATH_H)\nIF(HAVE_FINITE_IN_MATH_H)\n  SET(HAVE_FINITE TRUE CACHE INTERNAL \"\")\nELSE()\n  CHECK_SYMBOL_EXISTS(finite  \"ieeefp.h\" HAVE_FINITE)\nENDIF()\nCHECK_SYMBOL_EXISTS(log2  math.h HAVE_LOG2)\nCHECK_SYMBOL_EXISTS(isnan math.h HAVE_ISNAN)\nCHECK_SYMBOL_EXISTS(rint  math.h HAVE_RINT)\n\n# isinf() prototype not found on Solaris\nCHECK_CXX_SOURCE_COMPILES(\n\"#include  <math.h>\nint main() { \n  isinf(0.0); \n  return 0;\n}\" HAVE_ISINF)\n\n\n\n#\n# Test for endianess\n#\nINCLUDE(TestBigEndian)\nIF(APPLE)\n  # Cannot run endian test on universal PPC/Intel binaries \n  # would return inconsistent result.\n  # config.h.cmake includes a special #ifdef for Darwin\nELSE()\n  TEST_BIG_ENDIAN(WORDS_BIGENDIAN)\nENDIF()\n\n#\n# Tests for type sizes (and presence)\n#\nINCLUDE (CheckTypeSize)\nset(CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS}\n        -D_LARGEFILE_SOURCE -D_LARGE_FILES -D_FILE_OFFSET_BITS=64\n        -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS)\nSET(CMAKE_EXTRA_INCLUDE_FILES signal.h)\nMY_CHECK_TYPE_SIZE(sigset_t SIGSET_T)\nIF(NOT SIZEOF_SIGSET_T)\n SET(sigset_t int)\nENDIF()\nMY_CHECK_TYPE_SIZE(mode_t MODE_T)\nIF(NOT SIZEOF_MODE_T)\n SET(mode_t int)\nENDIF()\n\n\nIF(HAVE_STDINT_H)\n  SET(CMAKE_EXTRA_INCLUDE_FILES stdint.h)\nENDIF(HAVE_STDINT_H)\n\nSET(HAVE_VOIDP 1)\nSET(HAVE_CHARP 1)\nSET(HAVE_LONG 1)\nSET(HAVE_SIZE_T 1)\n\nIF(NOT APPLE)\nMY_CHECK_TYPE_SIZE(\"void *\" VOIDP)\nMY_CHECK_TYPE_SIZE(\"char *\" CHARP)\nMY_CHECK_TYPE_SIZE(long LONG)\nMY_CHECK_TYPE_SIZE(size_t SIZE_T)\nENDIF()\n\nMY_CHECK_TYPE_SIZE(char CHAR)\nMY_CHECK_TYPE_SIZE(short SHORT)\nMY_CHECK_TYPE_SIZE(int INT)\nMY_CHECK_TYPE_SIZE(\"long long\" LONG_LONG)\nSET(CMAKE_EXTRA_INCLUDE_FILES stdio.h sys/types.h time.h)\nMY_CHECK_TYPE_SIZE(off_t OFF_T)\nMY_CHECK_TYPE_SIZE(uchar UCHAR)\nMY_CHECK_TYPE_SIZE(uint UINT)\nMY_CHECK_TYPE_SIZE(ulong ULONG)\nMY_CHECK_TYPE_SIZE(int8 INT8)\nMY_CHECK_TYPE_SIZE(uint8 UINT8)\nMY_CHECK_TYPE_SIZE(int16 INT16)\nMY_CHECK_TYPE_SIZE(uint16 UINT16)\nMY_CHECK_TYPE_SIZE(int32 INT32)\nMY_CHECK_TYPE_SIZE(uint32 UINT32)\nMY_CHECK_TYPE_SIZE(u_int32_t U_INT32_T)\nMY_CHECK_TYPE_SIZE(int64 INT64)\nMY_CHECK_TYPE_SIZE(uint64 UINT64)\nMY_CHECK_TYPE_SIZE(time_t TIME_T)\nMY_CHECK_TYPE_SIZE(\"struct timespec\" STRUCT_TIMESPEC)\nSET (CMAKE_EXTRA_INCLUDE_FILES sys/types.h)\nMY_CHECK_TYPE_SIZE(bool  BOOL)\nSET(CMAKE_EXTRA_INCLUDE_FILES)\nIF(HAVE_SYS_SOCKET_H)\n  SET(CMAKE_EXTRA_INCLUDE_FILES sys/socket.h)\nENDIF(HAVE_SYS_SOCKET_H)\nMY_CHECK_TYPE_SIZE(socklen_t SOCKLEN_T)\nSET(CMAKE_EXTRA_INCLUDE_FILES)\n\nIF(HAVE_IEEEFP_H)\n  SET(CMAKE_EXTRA_INCLUDE_FILES ieeefp.h)\n  MY_CHECK_TYPE_SIZE(fp_except FP_EXCEPT)\nENDIF()\n\n\n#\n# Code tests\n#\n\n# check whether time_t is unsigned\nCHECK_C_SOURCE_COMPILES(\"\n#include <time.h>\nint main()\n{\n  int array[(((time_t)-1) > 0) ? 1 : -1];\n  return 0;\n}\"\nTIME_T_UNSIGNED)\n\n\nCHECK_C_SOURCE_COMPILES(\"\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#endif\nint main()\n{\n  getaddrinfo( 0, 0, 0, 0);\n  return 0;\n}\"\nHAVE_GETADDRINFO)\n\nCHECK_C_SOURCE_COMPILES(\"\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#endif\nint main()\n{\n  select(0,0,0,0,0);\n  return 0;\n}\"\nHAVE_SELECT)\n\n#\n# Check if timespec has ts_sec and ts_nsec fields\n#\n\nCHECK_C_SOURCE_COMPILES(\"\n#include <pthread.h>\n\nint main(int ac, char **av)\n{\n  struct timespec abstime;\n  abstime.ts_sec = time(NULL)+1;\n  abstime.ts_nsec = 0;\n}\n\" HAVE_TIMESPEC_TS_SEC)\n\n\n#\n# Check return type of qsort()\n#\nCHECK_C_SOURCE_COMPILES(\"\n#include <stdlib.h>\n#ifdef __cplusplus\nextern \\\"C\\\"\n#endif\nvoid qsort(void *base, size_t nel, size_t width,\n  int (*compar) (const void *, const void *));\nint main(int ac, char **av) {}\n\" QSORT_TYPE_IS_VOID)\nIF(QSORT_TYPE_IS_VOID)\n  SET(RETQSORTTYPE \"void\")\nELSE(QSORT_TYPE_IS_VOID)\n  SET(RETQSORTTYPE \"int\")\nENDIF(QSORT_TYPE_IS_VOID)\n\nIF(WIN32)\nSET(SOCKET_SIZE_TYPE int)\nELSE()\nCHECK_CXX_SOURCE_COMPILES(\"\n#include <sys/socket.h>\nint main(int argc, char **argv)\n{\n  getsockname(0,0,(socklen_t *) 0);\n  return 0; \n}\"\nHAVE_SOCKET_SIZE_T_AS_socklen_t)\n\nIF(HAVE_SOCKET_SIZE_T_AS_socklen_t)\n  SET(SOCKET_SIZE_TYPE socklen_t)\nELSE()\n  CHECK_CXX_SOURCE_COMPILES(\"\n  #include <sys/socket.h>\n  int main(int argc, char **argv)\n  {\n    getsockname(0,0,(int *) 0);\n    return 0; \n  }\"\n  HAVE_SOCKET_SIZE_T_AS_int)\n  IF(HAVE_SOCKET_SIZE_T_AS_int)\n    SET(SOCKET_SIZE_TYPE int)\n  ELSE()\n    CHECK_CXX_SOURCE_COMPILES(\"\n    #include <sys/socket.h>\n    int main(int argc, char **argv)\n    {\n      getsockname(0,0,(size_t *) 0);\n      return 0; \n    }\"\n    HAVE_SOCKET_SIZE_T_AS_size_t)\n    IF(HAVE_SOCKET_SIZE_T_AS_size_t)\n      SET(SOCKET_SIZE_TYPE size_t)\n    ELSE()\n      SET(SOCKET_SIZE_TYPE int)\n    ENDIF()\n  ENDIF()\nENDIF()\nENDIF()\n\nCHECK_CXX_SOURCE_COMPILES(\"\n#include <pthread.h>\nint main()\n{\n  pthread_yield();\n  return 0;\n}\n\" HAVE_PTHREAD_YIELD_ZERO_ARG)\n\nIF(NOT STACK_DIRECTION)\n  IF(CMAKE_CROSSCOMPILING)\n   MESSAGE(FATAL_ERROR \n   \"STACK_DIRECTION is not defined.  Please specify -DSTACK_DIRECTION=1 \"\n   \"or -DSTACK_DIRECTION=-1 when calling cmake.\")\n  ELSE()\n    TRY_RUN(STACKDIR_RUN_RESULT STACKDIR_COMPILE_RESULT    \n     ${CMAKE_BINARY_DIR} \n     ${CMAKE_SOURCE_DIR}/cmake/stack_direction.c\n     )\n     # Test program returns 0 (down) or 1 (up).\n     # Convert to -1 or 1\n     IF(STACKDIR_RUN_RESULT EQUAL 0)\n       SET(STACK_DIRECTION -1 CACHE INTERNAL \"Stack grows direction\")\n     ELSE()\n       SET(STACK_DIRECTION 1 CACHE INTERNAL \"Stack grows direction\")\n     ENDIF()\n     MESSAGE(STATUS \"Checking stack direction : ${STACK_DIRECTION}\")\n   ENDIF()\nENDIF()\n\n#\n# Check return type of signal handlers\n#\nCHECK_C_SOURCE_COMPILES(\"\n#include <signal.h>\n#ifdef signal\n# undef signal\n#endif\n#ifdef __cplusplus\nextern \\\"C\\\" void (*signal (int, void (*)(int)))(int);\n#else\nvoid (*signal ()) ();\n#endif\nint main(int ac, char **av) {}\n\" SIGNAL_RETURN_TYPE_IS_VOID)\nIF(SIGNAL_RETURN_TYPE_IS_VOID)\n  SET(RETSIGTYPE void)\n  SET(VOID_SIGHANDLER 1)\nELSE(SIGNAL_RETURN_TYPE_IS_VOID)\n  SET(RETSIGTYPE int)\nENDIF(SIGNAL_RETURN_TYPE_IS_VOID)\n\n\nCHECK_INCLUDE_FILES(\"time.h;sys/time.h\" TIME_WITH_SYS_TIME)\nCHECK_SYMBOL_EXISTS(O_NONBLOCK \"unistd.h;fcntl.h\" HAVE_FCNTL_NONBLOCK)\nIF(NOT HAVE_FCNTL_NONBLOCK)\n SET(NO_FCNTL_NONBLOCK 1)\nENDIF()\n\n#\n# Test for how the C compiler does inline, if at all\n#\nCHECK_C_SOURCE_COMPILES(\"\nstatic inline int foo(){return 0;}\nint main(int argc, char *argv[]){return 0;}\"\n                            C_HAS_inline)\nIF(NOT C_HAS_inline)\n  CHECK_C_SOURCE_COMPILES(\"\n  static __inline int foo(){return 0;}\n  int main(int argc, char *argv[]){return 0;}\"\n                            C_HAS___inline)\n  SET(C_INLINE __inline)\nENDIF()\n\nIF(NOT CMAKE_CROSSCOMPILING AND NOT MSVC)\n  STRING(TOLOWER ${CMAKE_SYSTEM_PROCESSOR}  processor)\n  IF(processor MATCHES \"86\" OR processor MATCHES \"amd64\" OR processor MATCHES \"x64\")\n  #Check for x86 PAUSE instruction\n  # We have to actually try running the test program, because of a bug\n  # in Solaris on x86_64, where it wrongly reports that PAUSE is not\n  # supported when trying to run an application.  See\n  # http://bugs.opensolaris.org/bugdatabase/printableBug.do?bug_id=6478684\n  CHECK_C_SOURCE_RUNS(\"\n  int main()\n  { \n    __asm__ __volatile__ (\\\"pause\\\"); \n    return 0;\n  }\"  HAVE_PAUSE_INSTRUCTION)\n  ENDIF()\n  IF (NOT HAVE_PAUSE_INSTRUCTION)\n    CHECK_C_SOURCE_COMPILES(\"\n    int main()\n    {\n     __asm__ __volatile__ (\\\"rep; nop\\\");\n     return 0;\n    }\n   \" HAVE_FAKE_PAUSE_INSTRUCTION)\n  ENDIF()\nENDIF()\n  \nCHECK_SYMBOL_EXISTS(tcgetattr \"termios.h\" HAVE_TCGETATTR 1)\n\n#\n# Check type of signal routines (posix, 4.2bsd, 4.1bsd or v7)\n#\nCHECK_C_SOURCE_COMPILES(\"\n  #include <signal.h>\n  int main(int ac, char **av)\n  {\n    sigset_t ss;\n    struct sigaction sa;\n    sigemptyset(&ss); sigsuspend(&ss);\n    sigaction(SIGINT, &sa, (struct sigaction *) 0);\n    sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);\n  }\"\n  HAVE_POSIX_SIGNALS)\n\nIF(NOT HAVE_POSIX_SIGNALS)\n CHECK_C_SOURCE_COMPILES(\"\n  #include <signal.h>\n  int main(int ac, char **av)\n  {\n    int mask = sigmask(SIGINT);\n    sigsetmask(mask); sigblock(mask); sigpause(mask);\n  }\"\n  HAVE_BSD_SIGNALS)\n  IF (NOT HAVE_BSD_SIGNALS)\n    CHECK_C_SOURCE_COMPILES(\"\n    #include <signal.h>\n    void foo() { }\n    int main(int ac, char **av)\n    {\n      int mask = sigmask(SIGINT);\n      sigset(SIGINT, foo); sigrelse(SIGINT);\n      sighold(SIGINT); sigpause(SIGINT);\n    }\"\n   HAVE_SVR3_SIGNALS)  \n   IF (NOT HAVE_SVR3_SIGNALS)\n    SET(HAVE_V7_SIGNALS 1)\n   ENDIF(NOT HAVE_SVR3_SIGNALS)\n ENDIF(NOT HAVE_BSD_SIGNALS)\nENDIF(NOT HAVE_POSIX_SIGNALS)\n\n# Assume regular sprintf\nSET(SPRINTFS_RETURNS_INT 1)\n\nIF(CMAKE_COMPILER_IS_GNUCXX AND HAVE_CXXABI_H)\nCHECK_CXX_SOURCE_COMPILES(\"\n #include <cxxabi.h>\n int main(int argc, char **argv) \n  {\n    char *foo= 0; int bar= 0;\n    foo= abi::__cxa_demangle(foo, foo, 0, &bar);\n    return 0;\n  }\"\n  HAVE_ABI_CXA_DEMANGLE)\nENDIF()\n\nCHECK_C_SOURCE_COMPILES(\"\n  int main(int argc, char **argv) \n  {\n    extern char *__bss_start;\n    return __bss_start ? 1 : 0;\n  }\"\nHAVE_BSS_START)\n\nCHECK_C_SOURCE_COMPILES(\"\n    int main()\n    {\n      extern void __attribute__((weak)) foo(void);\n      return 0;\n    }\"\n    HAVE_WEAK_SYMBOL\n)\n\n\nCHECK_CXX_SOURCE_COMPILES(\"\n    #include <new>\n    int main()\n    {\n      char *c = new char;\n      return 0;\n    }\"\n    HAVE_CXX_NEW\n)\n\nCHECK_CXX_SOURCE_COMPILES(\"\n    #undef inline\n    #if !defined(SCO) && !defined(__osf__) && !defined(_REENTRANT)\n    #define _REENTRANT\n    #endif\n    #include <pthread.h>\n    #include <sys/types.h>\n    #include <sys/socket.h>\n    #include <netinet/in.h>\n    #include <arpa/inet.h>\n    #include <netdb.h>\n    int main()\n    {\n\n       struct hostent *foo =\n       gethostbyaddr_r((const char *) 0,\n          0, 0, (struct hostent *) 0, (char *) NULL,  0, (int *)0);\n       return 0;\n    }\n  \"\n  HAVE_SOLARIS_STYLE_GETHOST)\n\n# Use of ALARMs to wakeup on timeout on sockets\n#\n# This feature makes use of a mutex and is a scalability hog we\n# try to avoid using. However we need support for SO_SNDTIMEO and\n# SO_RCVTIMEO socket options for this to work. So we will check\n# if this feature is supported by a simple TRY_RUN macro. However\n# on some OS's there is support for setting those variables but\n# they are silently ignored. For those OS's we will not attempt\n# to use SO_SNDTIMEO and SO_RCVTIMEO even if it is said to work.\n# See Bug#29093 for the problem with SO_SND/RCVTIMEO on HP/UX.\n# To use alarm is simple, simply avoid setting anything.\n\nIF(WIN32)\n  SET(HAVE_SOCKET_TIMEOUT 1)\nELSEIF(CMAKE_SYSTEM MATCHES \"HP-UX\")\n  SET(HAVE_SOCKET_TIMEOUT 0)\nELSEIF(CMAKE_CROSSCOMPILING)\n  SET(HAVE_SOCKET_TIMEOUT 0)\nELSE()\nSET(CMAKE_REQUIRED_LIBRARIES ${LIBNSL} ${LIBSOCKET}) \nCHECK_C_SOURCE_RUNS(\n\"\n #include <sys/types.h>\n #include <sys/socket.h>\n #include <sys/time.h>\n \n int main()\n {    \n   int fd = socket(AF_INET, SOCK_STREAM, 0);\n   struct timeval tv;\n   int ret= 0;\n   tv.tv_sec= 2;\n   tv.tv_usec= 0;\n   ret|= setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));\n   ret|= setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));\n   return !!ret;\n }\n\" HAVE_SOCKET_TIMEOUT)\nENDIF()\n\nSET(NO_ALARM \"${HAVE_SOCKET_TIMEOUT}\" CACHE BOOL \n   \"No need to use alarm to implement socket timeout\")\nSET(SIGNAL_WITH_VIO_CLOSE \"${HAVE_SOCKET_TIMEOUT}\")\nMARK_AS_ADVANCED(NO_ALARM)\n\n\nIF(CMAKE_COMPILER_IS_GNUCXX)\nIF(WITH_ATOMIC_OPS STREQUAL \"up\")\n  SET(MY_ATOMIC_MODE_DUMMY 1 CACHE BOOL \"Assume single-CPU mode, no concurrency\")\nELSEIF(WITH_ATOMIC_OPS STREQUAL \"rwlocks\")\n  SET(MY_ATOMIC_MODE_RWLOCK 1 CACHE BOOL \"Use pthread rwlocks for atomic ops\")\nELSEIF(WITH_ATOMIC_OPS STREQUAL \"smp\")\nELSEIF(NOT WITH_ATOMIC_OPS)\n  CHECK_CXX_SOURCE_COMPILES(\"\n  int main()\n  {\n    int foo= -10; int bar= 10;\n    long long int foo64= -10; long long int bar64= 10;\n    if (!__sync_fetch_and_add(&foo, bar) || foo)\n      return -1;\n    bar= __sync_lock_test_and_set(&foo, bar);\n    if (bar || foo != 10)\n      return -1;\n    bar= __sync_val_compare_and_swap(&bar, foo, 15);\n    if (bar)\n      return -1;\n    if (!__sync_fetch_and_add(&foo64, bar64) || foo64)\n      return -1;\n    bar64= __sync_lock_test_and_set(&foo64, bar64);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64= __sync_val_compare_and_swap(&bar64, foo, 15);\n    if (bar64)\n      return -1;\n    return 0;\n  }\"\n  HAVE_GCC_ATOMIC_BUILTINS)\nELSE()\n  MESSAGE(FATAL_ERROR \"${WITH_ATOMIC_OPS} is not a valid value for WITH_ATOMIC_OPS!\")\nENDIF()\nENDIF()\n\nSET(WITH_ATOMIC_LOCKS \"${WITH_ATOMIC_LOCKS}\" CACHE STRING\n\"Implement atomic operations using pthread rwlocks or atomic CPU\ninstructions for multi-processor or uniprocessor\nconfiguration. By default gcc built-in sync functions are used,\nif available and 'smp' configuration otherwise.\")\nMARK_AS_ADVANCED(WITH_ATOMIC_LOCKS MY_ATOMIC_MODE_RWLOCK MY_ATOMIC_MODE_DUMMY)\n\nIF(WITH_VALGRIND)\n  CHECK_INCLUDE_FILES(\"valgrind/memcheck.h;valgrind/valgrind.h\" \n    HAVE_VALGRIND_HEADERS)\n  IF(HAVE_VALGRIND_HEADERS)\n    SET(HAVE_VALGRIND 1)\n  ENDIF()\nENDIF()\n\n#--------------------------------------------------------------------\n# Check for IPv6 support\n#--------------------------------------------------------------------\nCHECK_INCLUDE_FILE(netinet/in6.h HAVE_NETINET_IN6_H)\n\nIF(UNIX)\n  SET(CMAKE_EXTRA_INCLUDE_FILES sys/types.h netinet/in.h sys/socket.h)\n  IF(HAVE_NETINET_IN6_H)\n    SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} netinet/in6.h)\n  ENDIF()\nELSEIF(WIN32)\n  SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} winsock2.h ws2ipdef.h)\nENDIF()\n\nMY_CHECK_STRUCT_SIZE(\"sockaddr_in6\" SOCKADDR_IN6)\nMY_CHECK_STRUCT_SIZE(\"in6_addr\" IN6_ADDR)\n\nIF(HAVE_STRUCT_SOCKADDR_IN6 OR HAVE_STRUCT_IN6_ADDR)\n  SET(HAVE_IPV6 TRUE CACHE INTERNAL \"\")\nENDIF()\n\n\n# Check for sockaddr_storage.ss_family\n# It is called differently under OS400 and older AIX\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_storage\"\n ss_family \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_STORAGE_SS_FAMILY)\nIF(NOT HAVE_SOCKADDR_STORAGE_SS_FAMILY)\n  CHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_storage\"\n  __ss_family \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_STORAGE___SS_FAMILY)\n  IF(HAVE_SOCKADDR_STORAGE___SS_FAMILY)\n    SET(ss_family __ss_family)\n  ENDIF()\nENDIF()\n\n#\n# Check if struct sockaddr_in::sin_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in\" sin_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN_SIN_LEN)\n\n#\n# Check if struct sockaddr_in6::sin6_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in6\" sin6_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN6_SIN6_LEN)\n\nSET(CMAKE_EXTRA_INCLUDE_FILES) \n\nCHECK_STRUCT_HAS_MEMBER(\"struct dirent\" d_ino \"dirent.h\"  STRUCT_DIRENT_HAS_D_INO)\nCHECK_STRUCT_HAS_MEMBER(\"struct dirent\" d_namlen \"dirent.h\"  STRUCT_DIRENT_HAS_D_NAMLEN)\nSET(SPRINTF_RETURNS_INT 1)\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/include/my_global.h": "/*\n   Copyright (c) 2001, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */\n\n/* This is the include file that should be included 'first' in every C file. */\n\n#ifndef _global_h\n#define _global_h\n\n/* Client library users on Windows need this macro defined here. */\n#if !defined(__WIN__) && defined(_WIN32)\n#define __WIN__\n#endif\n\n/*\n  InnoDB depends on some MySQL internals which other plugins should not\n  need.  This is because of InnoDB's foreign key support, \"safe\" binlog\n  truncation, and other similar legacy features.\n\n  We define accessors for these internals unconditionally, but do not\n  expose them in mysql/plugin.h.  They are declared in ha_innodb.h for\n  InnoDB's use.\n*/\n#define INNODB_COMPATIBILITY_HOOKS\n\n#ifdef __CYGWIN__\n/* We use a Unix API, so pretend it's not Windows */\n#undef WIN\n#undef WIN32\n#undef _WIN\n#undef _WIN32\n#undef _WIN64\n#undef __WIN__\n#undef __WIN32__\n#define HAVE_ERRNO_AS_DEFINE\n#endif /* __CYGWIN__ */\n\n/* to make command line shorter we'll define USE_PRAGMA_INTERFACE here */\n#ifdef USE_PRAGMA_IMPLEMENTATION\n#define USE_PRAGMA_INTERFACE\n#endif\n\n#if defined(__OpenBSD__) && (OpenBSD >= 200411)\n#define HAVE_ERRNO_AS_DEFINE\n#endif\n\n#if defined(i386) && !defined(__i386__)\n#define __i386__\n#endif\n\n/* Macros to make switching between C and C++ mode easier */\n#ifdef __cplusplus\n#define C_MODE_START    extern \"C\" {\n#define C_MODE_END\t}\n#else\n#define C_MODE_START\n#define C_MODE_END\n#endif\n\n#ifdef __cplusplus\n#define CPP_UNNAMED_NS_START  namespace {\n#define CPP_UNNAMED_NS_END    }\n#endif\n\n#include <my_config.h>\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#define HAVE_PSI_INTERFACE\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n/* Make it easier to add conditional code in _expressions_ */\n#ifdef __WIN__\n#define IF_WIN(A,B) A\n#else\n#define IF_WIN(A,B) B\n#endif\n\n#ifdef HAVE_purify\n#define IF_PURIFY(A,B) A\n#else\n#define IF_PURIFY(A,B) B\n#endif\n\n#ifndef EMBEDDED_LIBRARY\n#ifdef WITH_NDB_BINLOG\n#define HAVE_NDB_BINLOG 1\n#endif\n#endif /* !EMBEDDED_LIBRARY */\n\n#ifndef EMBEDDED_LIBRARY\n#define HAVE_REPLICATION\n#define HAVE_EXTERNAL_CLIENT\n#endif\n\n#if defined (_WIN32)\n/*\n off_t is 32 bit long. We do not use C runtime functions\n with off_t but native Win32 file IO APIs, that work with\n 64 bit offsets.\n*/\n#undef SIZEOF_OFF_T\n#define SIZEOF_OFF_T 8\n\n/*\n Prevent inclusion of  Windows GDI headers - they define symbol\n ERROR that conflicts with mysql headers.\n*/\n#ifndef NOGDI\n#define NOGDI\n#endif\n\n/* Include common headers.*/\n#include <winsock2.h>\n#include <ws2tcpip.h> /* SOCKET */\n#include <io.h>       /* access(), chmod() */\n#include <process.h>  /* getpid() */\n\n#define sleep(a) Sleep((a)*1000)\n\n/* Define missing access() modes. */\n#define F_OK 0\n#define W_OK 2\n\n/* Define missing file locking constants. */\n#define F_RDLCK 1\n#define F_WRLCK 2\n#define F_UNLCK 3\n#define F_TO_EOF 0x3FFFFFFF\n\n/* Shared memory and named pipe connections are supported. */\n#define HAVE_SMEM 1\n#define HAVE_NAMED_PIPE 1\n#define shared_memory_buffer_length 16000\n#define default_shared_memory_base_name \"MYSQL\"\n#endif /* _WIN32*/\n\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#endif\n\n/*\n  The macros below are used to allow build of Universal/fat binaries of\n  MySQL and MySQL applications under darwin. \n*/\n#if defined(__APPLE__) && defined(__MACH__)\n#  undef SIZEOF_CHARP \n#  undef SIZEOF_SHORT \n#  undef SIZEOF_INT \n#  undef SIZEOF_LONG \n#  undef SIZEOF_LONG_LONG \n#  undef SIZEOF_OFF_T \n#  undef WORDS_BIGENDIAN\n#  define SIZEOF_SHORT 2\n#  define SIZEOF_INT 4\n#  define SIZEOF_LONG_LONG 8\n#  define SIZEOF_OFF_T 8\n#  if defined(__i386__) || defined(__ppc__)\n#    define SIZEOF_CHARP 4\n#    define SIZEOF_LONG 4\n#  elif defined(__x86_64__) || defined(__ppc64__)\n#    define SIZEOF_CHARP 8\n#    define SIZEOF_LONG 8\n#  else\n#    error Building FAT binary for an unknown architecture.\n#  endif\n#  if defined(__ppc__) || defined(__ppc64__)\n#    define WORDS_BIGENDIAN\n#  endif\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n/*\n  The macros below are borrowed from include/linux/compiler.h in the\n  Linux kernel. Use them to indicate the likelyhood of the truthfulness\n  of a condition. This serves two purposes - newer versions of gcc will be\n  able to optimize for branch predication, which could yield siginficant\n  performance gains in frequently executed sections of the code, and the\n  other reason to use them is for documentation\n*/\n\n#if !defined(__GNUC__) || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)\n#define __builtin_expect(x, expected_value) (x)\n#endif\n\n#define likely(x)\t__builtin_expect((x),1)\n#define unlikely(x)\t__builtin_expect((x),0)\n\n/* Fix problem with S_ISLNK() on Linux */\n#if defined(TARGET_OS_LINUX) || defined(__GLIBC__)\n#undef  _GNU_SOURCE\n#define _GNU_SOURCE 1\n#endif\n\n/*\n  Temporary solution to solve bug#7156. Include \"sys/types.h\" before\n  the thread headers, else the function madvise() will not be defined\n*/\n#if defined(HAVE_SYS_TYPES_H) && ( defined(sun) || defined(__sun) )\n#include <sys/types.h>\n#endif\n\n#ifdef HAVE_THREADS_WITHOUT_SOCKETS\n/* MIT pthreads does not work with unix sockets */\n#undef HAVE_SYS_UN_H\n#endif\n\n#define __EXTENSIONS__ 1\t/* We want some extension */\n#ifndef __STDC_EXT__\n#define __STDC_EXT__ 1          /* To get large file support on hpux */\n#endif\n\n/*\n  Solaris 9 include file <sys/feature_tests.h> refers to X/Open document\n\n    System Interfaces and Headers, Issue 5\n\n  saying we should define _XOPEN_SOURCE=500 to get POSIX.1c prototypes,\n  but apparently other systems (namely FreeBSD) don't agree.\n\n  On a newer Solaris 10, the above file recognizes also _XOPEN_SOURCE=600.\n  Furthermore, it tests that if a program requires older standard\n  (_XOPEN_SOURCE<600 or _POSIX_C_SOURCE<200112L) it cannot be\n  run on a new compiler (that defines _STDC_C99) and issues an #error.\n  It's also an #error if a program requires new standard (_XOPEN_SOURCE=600\n  or _POSIX_C_SOURCE=200112L) and a compiler does not define _STDC_C99.\n\n  To add more to this mess, Sun Studio C compiler defines _STDC_C99 while\n  C++ compiler does not!\n\n  So, in a desperate attempt to get correct prototypes for both\n  C and C++ code, we define either _XOPEN_SOURCE=600 or _XOPEN_SOURCE=500\n  depending on the compiler's announced C standard support.\n\n  Cleaner solutions are welcome.\n*/\n#ifdef __sun\n#if __STDC_VERSION__ - 0 >= 199901L\n#define _XOPEN_SOURCE 600\n#else\n#define _XOPEN_SOURCE 500\n#endif\n#endif\n\n#if !defined(__WIN__)\n#ifndef _POSIX_PTHREAD_SEMANTICS\n#define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */\n#endif\n\n#if !defined(SCO)\n#define _REENTRANT\t1\t/* Some thread libraries require this */\n#endif\n#if !defined(_THREAD_SAFE) && !defined(_AIX)\n#define _THREAD_SAFE            /* Required for OSF1 */\n#endif\n#if defined(HPUX10) || defined(HPUX11)\nC_MODE_START\t\t\t/* HPUX needs this, signal.h bug */\n#include <pthread.h>\nC_MODE_END\n#else\n#include <pthread.h>\t\t/* AIX must have this included first */\n#endif\n#if !defined(SCO) && !defined(_REENTRANT)\n#define _REENTRANT\t1\t/* Threads requires reentrant code */\n#endif\n#endif /* !defined(__WIN__) */\n\n/* Go around some bugs in different OS and compilers */\n#ifdef _AIX\t\t\t/* By soren@t.dk */\n#define _H_STRINGS\n#define _SYS_STREAM_H\n/* #define _AIX32_CURSES */\t/* XXX: this breaks AIX 4.3.3 (others?). */\n#define ulonglong2double(A) my_ulonglong2double(A)\n#define my_off_t2double(A)  my_ulonglong2double(A)\nC_MODE_START\ninline double my_ulonglong2double(unsigned long long A) { return (double A); }\nC_MODE_END\n#endif /* _AIX */\n\n#ifdef HAVE_BROKEN_SNPRINTF\t/* HPUX 10.20 don't have this defined */\n#undef HAVE_SNPRINTF\n#endif\n#ifdef HAVE_BROKEN_PREAD\n/*\n  pread()/pwrite() are not 64 bit safe on HP-UX 11.0 without\n  installing the kernel patch PHKL_20349 or greater\n*/\n#undef HAVE_PREAD\n#undef HAVE_PWRITE\n#endif\n\n#ifdef UNDEF_HAVE_INITGROUPS\t\t\t/* For AIX 4.3 */\n#undef HAVE_INITGROUPS\n#endif\n\n/* gcc/egcs issues */\n\n#if defined(__GNUC) && defined(__EXCEPTIONS)\n#error \"Please add -fno-exceptions to CXXFLAGS and reconfigure/recompile\"\n#endif\n\n#if defined(_lint) && !defined(lint)\n#define lint\n#endif\n#if SIZEOF_LONG_LONG > 4 && !defined(_LONG_LONG)\n#define _LONG_LONG 1\t\t/* For AIX string library */\n#endif\n\n#ifndef stdin\n#include <stdio.h>\n#endif\n#include <stdarg.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n\n#include <math.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_FLOAT_H\n#include <float.h>\n#endif\n#ifdef HAVE_FENV_H\n#include <fenv.h> /* For fesetround() */\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_SYS_TIMEB_H\n#include <sys/timeb.h>\t\t\t\t/* Avoid warnings on SCO */\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif /* TIME_WITH_SYS_TIME */\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if defined(__cplusplus) && defined(NO_CPLUSPLUS_ALLOCA)\n#undef HAVE_ALLOCA\n#undef HAVE_ALLOCA_H\n#endif\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n\n#include <errno.h>\t\t\t\t/* Recommended by debian */\n/* We need the following to go around a problem with openssl on solaris */\n#if defined(HAVE_CRYPT_H)\n#include <crypt.h>\n#endif\n\n/*\n  A lot of our programs uses asserts, so better to always include it\n  This also fixes a problem when people uses DBUG_ASSERT without including\n  assert.h\n*/\n#include <assert.h>\n\n/* an assert that works at compile-time. only for constant expression */\n#ifndef __GNUC__\n#define compile_time_assert(X)  do { } while(0)\n#else\n#define compile_time_assert(X)                                  \\\n  do                                                            \\\n  {                                                             \\\n    typedef char compile_time_assert[(X) ? 1 : -1] __attribute__((unused)); \\\n  } while(0)\n#endif\n\n/* Go around some bugs in different OS and compilers */\n#if defined (HPUX11) && defined(_LARGEFILE_SOURCE)\n#ifndef _LARGEFILE64_SOURCE\n#define _LARGEFILE64_SOURCE\n#endif\n#endif\n\n#if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)\n#include <sys/stream.h>\t\t/* HPUX 10.20 defines ulong here. UGLY !!! */\n#define HAVE_ULONG\n#endif\n#if defined(HPUX10) && defined(_LARGEFILE64_SOURCE)\n/* Fix bug in setrlimit */\n#undef setrlimit\n#define setrlimit cma_setrlimit64\n#endif\n/* Declare madvise where it is not declared for C++, like Solaris */\n#if HAVE_MADVISE && !HAVE_DECL_MADVISE && defined(__cplusplus)\nextern \"C\" int madvise(void *addr, size_t len, int behav);\n#endif\n\n#define QUOTE_ARG(x)\t\t#x\t/* Quote argument (before cpp) */\n#define STRINGIFY_ARG(x) QUOTE_ARG(x)\t/* Quote argument, after cpp */\n\n/* Paranoid settings. Define I_AM_PARANOID if you are paranoid */\n#ifdef I_AM_PARANOID\n#define DONT_ALLOW_USER_CHANGE 1\n#define DONT_USE_MYSQL_PWD 1\n#endif\n\n/* Does the system remember a signal handler after a signal ? */\n#if !defined(HAVE_BSD_SIGNALS) && !defined(HAVE_SIGACTION)\n#define SIGNAL_HANDLER_RESET_ON_DELIVERY\n#endif\n\n/*\n  Deprecated workaround for false-positive uninitialized variables\n  warnings. Those should be silenced using tool-specific heuristics.\n\n  Enabled by default for g++ due to the bug referenced below.\n*/\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \\\n    (defined(__GNUC__) && defined(__cplusplus))\n#define LINT_INIT(var) var= 0\n#else\n#define LINT_INIT(var)\n#endif\n\n#ifndef SO_EXT\n#ifdef _WIN32\n#define SO_EXT \".dll\"\n#elif defined(__APPLE__)\n#define SO_EXT \".dylib\"\n#else\n#define SO_EXT \".so\"\n#endif\n#endif\n\n/*\n   Suppress uninitialized variable warning without generating code.\n\n   The _cplusplus is a temporary workaround for C++ code pending a fix\n   for a g++ bug (http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34772).\n*/\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \\\n    defined(__cplusplus) || !defined(__GNUC__)\n#define UNINIT_VAR(x) x= 0\n#else\n/* GCC specific self-initialization which inhibits the warning. */\n#define UNINIT_VAR(x) x= x\n#endif\n\n#if !defined(HAVE_UINT)\n#undef HAVE_UINT\n#define HAVE_UINT\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\n#endif\n\n#define swap_variables(t, a, b) { t dummy; dummy= a; a= b; b= dummy; }\n#define test(a)\t\t((a) ? 1 : 0)\n#define set_if_bigger(a,b)  do { if ((a) < (b)) (a)=(b); } while(0)\n#define set_if_smaller(a,b) do { if ((a) > (b)) (a)=(b); } while(0)\n#define test_all_bits(a,b) (((a) & (b)) == (b))\n#define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))\n\n/* Define some general constants */\n#ifndef TRUE\n#define TRUE\t\t(1)\t/* Logical true */\n#define FALSE\t\t(0)\t/* Logical false */\n#endif\n\n#include <my_compiler.h>\n\n/*\n  Wen using the embedded library, users might run into link problems,\n  duplicate declaration of __cxa_pure_virtual, solved by declaring it a\n  weak symbol.\n*/\n#if defined(USE_MYSYS_NEW) && ! defined(DONT_DECLARE_CXA_PURE_VIRTUAL)\nC_MODE_START\nint __cxa_pure_virtual () __attribute__ ((weak));\nC_MODE_END\n#endif\n\n/* The DBUG_ON flag always takes precedence over default DBUG_OFF */\n#if defined(DBUG_ON) && defined(DBUG_OFF)\n#undef DBUG_OFF\n#endif\n\n/* We might be forced to turn debug off, if not turned off already */\n#if (defined(FORCE_DBUG_OFF) || defined(_lint)) && !defined(DBUG_OFF)\n#  define DBUG_OFF\n#  ifdef DBUG_ON\n#    undef DBUG_ON\n#  endif\n#endif\n\n/* Some types that is different between systems */\n\ntypedef int\tFile;\t\t/* File descriptor */\n#ifdef _WIN32\ntypedef SOCKET my_socket;\n#else\ntypedef int\tmy_socket;\t/* File descriptor for sockets */\n#define INVALID_SOCKET -1\n#endif\n/* Type for fuctions that handles signals */\n#define sig_handler RETSIGTYPE\nC_MODE_START\ntypedef void\t(*sig_return)();/* Returns type from signal */\nC_MODE_END\n#if defined(__GNUC__) && !defined(_lint)\ntypedef char\tpchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpuchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpbool;\t\t/* Mixed prototypes can take char */\ntypedef short\tpshort;\t\t/* Mixed prototypes can take short int */\ntypedef float\tpfloat;\t\t/* Mixed prototypes can take float */\n#else\ntypedef int\tpchar;\t\t/* Mixed prototypes can't take char */\ntypedef uint\tpuchar;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpbool;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpshort;\t\t/* Mixed prototypes can't take short int */\ntypedef double\tpfloat;\t\t/* Mixed prototypes can't take float */\n#endif\nC_MODE_START\ntypedef int\t(*qsort_cmp)(const void *,const void *);\ntypedef int\t(*qsort_cmp2)(void*, const void *,const void *);\nC_MODE_END\n#define qsort_t RETQSORTTYPE\t/* Broken GCC cant handle typedef !!!! */\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\ntypedef SOCKET_SIZE_TYPE size_socket;\n\n#ifndef SOCKOPT_OPTLEN_TYPE\n#define SOCKOPT_OPTLEN_TYPE size_socket\n#endif\n\n/* file create flags */\n\n#ifndef O_SHARE\t\t\t/* Probably not windows */\n#define O_SHARE\t\t0\t/* Flag to my_open for shared files */\n#ifndef O_BINARY\n#define O_BINARY\t0\t/* Flag to my_open for binary files */\n#endif\n#ifndef FILE_BINARY\n#define FILE_BINARY\tO_BINARY /* Flag to my_fopen for binary streams */\n#endif\n#ifdef HAVE_FCNTL\n#define HAVE_FCNTL_LOCK\n#define F_TO_EOF\t0L\t/* Param to lockf() to lock rest of file */\n#endif\n#endif /* O_SHARE */\n\n#ifndef O_TEMPORARY\n#define O_TEMPORARY\t0\n#endif\n#ifndef O_SHORT_LIVED\n#define O_SHORT_LIVED\t0\n#endif\n#ifndef O_NOFOLLOW\n#define O_NOFOLLOW      0\n#endif\n\n/* additional file share flags for win32 */\n#ifdef __WIN__\n#define _SH_DENYRWD     0x110    /* deny read/write mode & delete */\n#define _SH_DENYWRD     0x120    /* deny write mode & delete      */\n#define _SH_DENYRDD     0x130    /* deny read mode & delete       */\n#define _SH_DENYDEL     0x140    /* deny delete only              */\n#endif /* __WIN__ */\n\n\n/* General constants */\n#define FN_LEN\t\t256\t/* Max file name len */\n#define FN_HEADLEN\t253\t/* Max length of filepart of file name */\n#define FN_EXTLEN\t20\t/* Max length of extension (part of FN_LEN) */\n#define FN_REFLEN\t512\t/* Max length of full path-name */\n#define FN_EXTCHAR\t'.'\n#define FN_HOMELIB\t'~'\t/* ~/ is used as abbrev for home dir */\n#define FN_CURLIB\t'.'\t/* ./ is used as abbrev for current dir */\n#define FN_PARENTDIR\t\"..\"\t/* Parent directory; Must be a string */\n\n#ifdef _WIN32\n#define FN_LIBCHAR\t'\\\\'\n#define FN_LIBCHAR2\t'/'\n#define FN_DIRSEP       \"/\\\\\"               /* Valid directory separators */\n#define FN_EXEEXT   \".exe\"\n#define FN_SOEXT    \".dll\"\n#define FN_ROOTDIR\t\"\\\\\"\n#define FN_DEVCHAR\t':'\n#define FN_NETWORK_DRIVES\t/* Uses \\\\ to indicate network drives */\n#define FN_NO_CASE_SENCE\t/* Files are not case-sensitive */\n#else\n#define FN_LIBCHAR\t'/'\n#define FN_LIBCHAR2\t'/'\n#define FN_DIRSEP       \"/\"     /* Valid directory separators */\n#define FN_EXEEXT   \"\"\n#define FN_SOEXT    \".so\"\n#define FN_ROOTDIR\t\"/\"\n#endif\n\n/* \n  MY_FILE_MIN is  Windows speciality and is used to quickly detect\n  the mismatch of CRT and mysys file IO usage on Windows at runtime.\n  CRT file descriptors can be in the range 0-2047, whereas descriptors returned\n  by my_open() will start with 2048. If a file descriptor with value less then\n  MY_FILE_MIN is passed to mysys IO function, chances are it stemms from\n  open()/fileno() and not my_open()/my_fileno.\n\n  For Posix,  mysys functions are light wrappers around libc, and MY_FILE_MIN\n  is logically 0.\n*/\n\n#ifdef _WIN32\n#define MY_FILE_MIN  2048\n#else\n#define MY_FILE_MIN  0\n#endif\n\n/* \n  MY_NFILE is the default size of my_file_info array.\n\n  It is larger on Windows, because it all file handles are stored in my_file_info\n  Default size is 16384 and this should be enough for most cases.If it is not \n  enough, --max-open-files with larger value can be used.\n\n  For Posix , my_file_info array is only used to store filenames for\n  error reporting and its size is not a limitation for number of open files.\n*/ \n#ifdef _WIN32\n#define MY_NFILE (16384 + MY_FILE_MIN)\n#else\n#define MY_NFILE 64\n#endif\n\n#ifndef OS_FILE_LIMIT\n#define OS_FILE_LIMIT\tUINT_MAX\n#endif\n\n/*\n  Io buffer size; Must be a power of 2 and a multiple of 512. May be\n  smaller what the disk page size. This influences the speed of the\n  isam btree library. eg to big to slow.\n*/\n#define IO_SIZE\t\t\t4096\n/*\n  How much overhead does malloc have. The code often allocates\n  something like 1024-MALLOC_OVERHEAD bytes\n*/\n#define MALLOC_OVERHEAD 8\n\n\t/* get memory in huncs */\n#define ONCE_ALLOC_INIT\t\t(uint) (4096-MALLOC_OVERHEAD)\n\t/* Typical record cash */\n#define RECORD_CACHE_SIZE\t(uint) (64*1024-MALLOC_OVERHEAD)\n\t/* Typical key cash */\n#define KEY_CACHE_SIZE\t\t(uint) (8*1024*1024)\n\t/* Default size of a key cache block  */\n#define KEY_CACHE_BLOCK_SIZE\t(uint) 1024\n\n\n\t/* Some things that this system doesn't have */\n\n#ifdef _WIN32\n#define NO_DIR_LIBRARY\t\t/* Not standard dir-library */\n#endif\n\n/* Some defines of functions for portability */\n\n#undef remove\t\t/* Crashes MySQL on SCO 5.0.0 */\n#ifndef __WIN__\n#define closesocket(A)\tclose(A)\n#endif\n\n#if (_MSC_VER)\n#if !defined(_WIN64)\ninline double my_ulonglong2double(unsigned long long value)\n{\n  long long nr=(long long) value;\n  if (nr >= 0)\n    return (double) nr;\n  return (18446744073709551616.0 + (double) nr);\n}\n#define ulonglong2double my_ulonglong2double\n#define my_off_t2double  my_ulonglong2double\n#endif /* _WIN64 */\ninline unsigned long long my_double2ulonglong(double d)\n{\n  double t= d - (double) 0x8000000000000000ULL;\n\n  if (t >= 0)\n    return  ((unsigned long long) t) + 0x8000000000000000ULL;\n  return (unsigned long long) d;\n}\n#define double2ulonglong my_double2ulonglong\n#endif\n\n#ifndef ulonglong2double\n#define ulonglong2double(A) ((double) (ulonglong) (A))\n#define my_off_t2double(A)  ((double) (my_off_t) (A))\n#endif\n#ifndef double2ulonglong\n#define double2ulonglong(A) ((ulonglong) (double) (A))\n#endif\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n#define ulong_to_double(X) ((double) (ulong) (X))\n\n#ifndef STACK_DIRECTION\n#error \"please add -DSTACK_DIRECTION=1 or -1 to your CPPFLAGS\"\n#endif\n\n#if !defined(HAVE_STRTOK_R)\n#define strtok_r(A,B,C) strtok((A),(B))\n#endif\n\n/* This is from the old m-machine.h file */\n\n#if SIZEOF_LONG_LONG > 4\n#define HAVE_LONG_LONG 1\n#endif\n\n/*\n  Some pre-ANSI-C99 systems like AIX 5.1 and Linux/GCC 2.95 define\n  ULONGLONG_MAX, LONGLONG_MIN, LONGLONG_MAX; we use them if they're defined.\n*/\n\n#if defined(HAVE_LONG_LONG) && !defined(LONGLONG_MIN)\n#define LONGLONG_MIN\t((long long) 0x8000000000000000LL)\n#define LONGLONG_MAX\t((long long) 0x7FFFFFFFFFFFFFFFLL)\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)\n/* First check for ANSI C99 definition: */\n#ifdef ULLONG_MAX\n#define ULONGLONG_MAX  ULLONG_MAX\n#else\n#define ULONGLONG_MAX ((unsigned long long)(~0ULL))\n#endif\n#endif /* defined (HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)*/\n\n#define INT_MIN64       (~0x7FFFFFFFFFFFFFFFLL)\n#define INT_MAX64       0x7FFFFFFFFFFFFFFFLL\n#define INT_MIN32       (~0x7FFFFFFFL)\n#define INT_MAX32       0x7FFFFFFFL\n#define UINT_MAX32      0xFFFFFFFFL\n#define INT_MIN24       (~0x007FFFFF)\n#define INT_MAX24       0x007FFFFF\n#define UINT_MAX24      0x00FFFFFF\n#define INT_MIN16       (~0x7FFF)\n#define INT_MAX16       0x7FFF\n#define UINT_MAX16      0xFFFF\n#define INT_MIN8        (~0x7F)\n#define INT_MAX8        0x7F\n#define UINT_MAX8       0xFF\n\n/* From limits.h instead */\n#ifndef DBL_MIN\n#define DBL_MIN\t\t4.94065645841246544e-324\n#define FLT_MIN\t\t((float)1.40129846432481707e-45)\n#endif\n#ifndef DBL_MAX\n#define DBL_MAX\t\t1.79769313486231470e+308\n#define FLT_MAX\t\t((float)3.40282346638528860e+38)\n#endif\n#ifndef SIZE_T_MAX\n#define SIZE_T_MAX      (~((size_t) 0))\n#endif\n\n#ifndef isfinite\n#ifdef HAVE_FINITE\n#define isfinite(x) finite(x)\n#else\n#define finite(x) (1.0 / fabs(x) > 0.0)\n#endif /* HAVE_FINITE */\n#endif /* isfinite */\n\n#ifndef HAVE_ISNAN\n#define isnan(x) ((x) != (x))\n#endif\n\n#ifdef HAVE_ISINF\n/* Check if C compiler is affected by GCC bug #39228 */\n#if !defined(__cplusplus) && defined(HAVE_BROKEN_ISINF)\n/* Force store/reload of the argument to/from a 64-bit double */\nstatic inline double my_isinf(double x)\n{\n  volatile double t= x;\n  return isinf(t);\n}\n#else\n/* System-provided isinf() is available and safe to use */\n#define my_isinf(X) isinf(X)\n#endif\n#else /* !HAVE_ISINF */\n#define my_isinf(X) (!finite(X) && !isnan(X))\n#endif\n\n/* Define missing math constants. */\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.7182818284590452354\n#endif\n#ifndef M_LN2\n#define M_LN2 0.69314718055994530942\n#endif\n\n/*\n  Max size that must be added to a so that we know Size to make\n  adressable obj.\n*/\n#if SIZEOF_CHARP == 4\ntypedef long\t\tmy_ptrdiff_t;\n#else\ntypedef long long\tmy_ptrdiff_t;\n#endif\n\n#define MY_ALIGN(A,L)\t(((A) + (L) - 1) & ~((L) - 1))\n#define ALIGN_SIZE(A)\tMY_ALIGN((A),sizeof(double))\n/* Size to make adressable obj. */\n#define ADD_TO_PTR(ptr,size,type) (type) ((uchar*) (ptr)+size)\n#define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((uchar*) (A) - (uchar*) (B))\n\n/*\n  Custom version of standard offsetof() macro which can be used to get\n  offsets of members in class for non-POD types (according to the current\n  version of C++ standard offsetof() macro can't be used in such cases and\n  attempt to do so causes warnings to be emitted, OTOH in many cases it is\n  still OK to assume that all instances of the class has the same offsets\n  for the same members).\n\n  This is temporary solution which should be removed once File_parser class\n  and related routines are refactored.\n*/\n\n#define my_offsetof(TYPE, MEMBER) \\\n        ((size_t)((char *)&(((TYPE *)0x10)->MEMBER) - (char*)0x10))\n\n#define NullS\t\t(char *) 0\n\n#ifdef STDCALL\n#undef STDCALL\n#endif\n\n#ifdef _WIN32\n#define STDCALL __stdcall\n#else\n#define STDCALL\n#endif\n\n/* Typdefs for easyier portability */\n\n#ifndef HAVE_UCHAR\ntypedef unsigned char\tuchar;\t/* Short for unsigned char */\n#endif\n\n#ifndef HAVE_INT8\ntypedef signed char int8;       /* Signed integer >= 8  bits */\n#endif\n#ifndef HAVE_UINT8\ntypedef unsigned char uint8;    /* Unsigned integer >= 8  bits */\n#endif\n#ifndef HAVE_INT16\ntypedef short int16;\n#endif\n#ifndef HAVE_UINT16\ntypedef unsigned short uint16;\n#endif\n#if SIZEOF_INT == 4\n#ifndef HAVE_INT32\ntypedef int int32;\n#endif\n#ifndef HAVE_UINT32\ntypedef unsigned int uint32;\n#endif\n#elif SIZEOF_LONG == 4\n#ifndef HAVE_INT32\ntypedef long int32;\n#endif\n#ifndef HAVE_UINT32\ntypedef unsigned long uint32;\n#endif\n#else\n#error Neither int or long is of 4 bytes width\n#endif\n\n#if !defined(HAVE_ULONG) && !defined(__USE_MISC)\ntypedef unsigned long\tulong;\t\t  /* Short for unsigned long */\n#endif\n#ifndef longlong_defined\n/* \n  Using [unsigned] long long is preferable as [u]longlong because we use \n  [unsigned] long long unconditionally in many places, \n  for example in constants with [U]LL suffix.\n*/\n#if defined(HAVE_LONG_LONG) && SIZEOF_LONG_LONG == 8\ntypedef unsigned long long int ulonglong; /* ulong or unsigned long long */\ntypedef long long int\tlonglong;\n#else\ntypedef unsigned long\tulonglong;\t  /* ulong or unsigned long long */\ntypedef long\t\tlonglong;\n#endif\n#endif\n#ifndef HAVE_INT64\ntypedef longlong int64;\n#endif\n#ifndef HAVE_UINT64\ntypedef ulonglong uint64;\n#endif\n\n#if defined(NO_CLIENT_LONG_LONG)\ntypedef unsigned long my_ulonglong;\n#elif defined (__WIN__)\ntypedef unsigned __int64 my_ulonglong;\n#else\ntypedef unsigned long long my_ulonglong;\n#endif\n\n#if SIZEOF_CHARP == SIZEOF_INT\ntypedef int intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG\ntypedef long intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG_LONG\ntypedef long long intptr;\n#else\n#error sizeof(void *) is neither sizeof(int) nor sizeof(long) nor sizeof(long long)\n#endif\n\n#define MY_ERRPTR ((void*)(intptr)1)\n\n#if defined(_WIN32)\ntypedef unsigned long long my_off_t;\ntypedef unsigned long long os_off_t;\n#else\ntypedef off_t os_off_t;\n#if SIZEOF_OFF_T > 4\ntypedef ulonglong my_off_t;\n#else\ntypedef unsigned long my_off_t;\n#endif\n#endif /*_WIN32*/\n#define MY_FILEPOS_ERROR\t(~(my_off_t) 0)\n\n/*\n  TODO Convert these to use Bitmap class.\n */\ntypedef ulonglong table_map;          /* Used for table bits in join */\ntypedef ulong nesting_map;  /* Used for flags of nesting constructs */\n\n#if defined(__WIN__)\n#define socket_errno\tWSAGetLastError()\n#define SOCKET_EINTR\tWSAEINTR\n#define SOCKET_EAGAIN\tWSAEINPROGRESS\n#define SOCKET_ETIMEDOUT WSAETIMEDOUT\n#define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK\n#define SOCKET_EADDRINUSE WSAEADDRINUSE\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#else /* Unix */\n#define socket_errno\terrno\n#define closesocket(A)\tclose(A)\n#define SOCKET_EINTR\tEINTR\n#define SOCKET_EAGAIN\tEAGAIN\n#define SOCKET_ETIMEDOUT SOCKET_EINTR\n#define SOCKET_EWOULDBLOCK EWOULDBLOCK\n#define SOCKET_EADDRINUSE EADDRINUSE\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#endif\n\ntypedef int\t\tmyf;\t/* Type of MyFlags in my_funcs */\ntypedef char\t\tmy_bool; /* Small bool */\n\n/* Macros for converting *constants* to the right type */\n#define MYF(v)\t\t(myf) (v)\n\n#ifndef LL\n#ifdef HAVE_LONG_LONG\n#define LL(A) A ## LL\n#else\n#define LL(A) A ## L\n#endif\n#endif\n\n#ifndef ULL\n#ifdef HAVE_LONG_LONG\n#define ULL(A) A ## ULL\n#else\n#define ULL(A) A ## UL\n#endif\n#endif\n\n/*\n  Defines to make it possible to prioritize register assignments. No\n  longer that important with modern compilers.\n*/\n#ifndef USING_X\n#define reg1 register\n#define reg2 register\n#define reg3 register\n#define reg4 register\n#define reg5 register\n#define reg6 register\n#define reg7 register\n#define reg8 register\n#define reg9 register\n#define reg10 register\n#define reg11 register\n#define reg12 register\n#define reg13 register\n#define reg14 register\n#define reg15 register\n#define reg16 register\n#endif\n\n#include <my_dbug.h>\n\n/* Some helper macros */\n#define YESNO(X) ((X) ? \"yes\" : \"no\")\n\n#define MY_HOW_OFTEN_TO_ALARM\t2\t/* How often we want info on screen */\n#define MY_HOW_OFTEN_TO_WRITE\t1000\t/* How often we want info on screen */\n\n\n\n/*\n  Define-funktions for reading and storing in machine independent format\n  (low byte first)\n*/\n\n/* Optimized store functions for Intel x86 */\n#if defined(__i386__) || defined(_WIN32)\n#define sint2korr(A)\t(*((int16 *) (A)))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(*((long *) (A)))\n#define uint2korr(A)\t(*((uint16 *) (A)))\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#define uint4korr(A)\t(*((uint32 *) (A)))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t(*((ulonglong *) (A)))\n#define sint8korr(A)\t(*((longlong *) (A)))\n#define int2store(T,A)\t*((uint16*) (T))= (uint16) (A)\n#define int3store(T,A)  do { *(T)=  (uchar) ((A));\\\n                            *(T+1)=(uchar) (((uint) (A) >> 8));\\\n                            *(T+2)=(uchar) (((A) >> 16)); } while (0)\n#define int4store(T,A)\t*((long *) (T))= (long) (A)\n#define int5store(T,A)  do { *(T)= (uchar)((A));\\\n                             *((T)+1)=(uchar) (((A) >> 8));\\\n                             *((T)+2)=(uchar) (((A) >> 16));\\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); } while(0)\n#define int6store(T,A)  do { *(T)=    (uchar)((A));          \\\n                             *((T)+1)=(uchar) (((A) >> 8));  \\\n                             *((T)+2)=(uchar) (((A) >> 16)); \\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); \\\n                             *((T)+5)=(uchar) (((A) >> 40)); } while(0)\n#define int8store(T,A)\t*((ulonglong *) (T))= (ulonglong) (A)\n\ntypedef union {\n  double v;\n  long m[2];\n} doubleget_union;\n#define doubleget(V,M)\t\\\ndo { doubleget_union _tmp; \\\n     _tmp.m[0] = *((long*)(M)); \\\n     _tmp.m[1] = *(((long*) (M))+1); \\\n     (V) = _tmp.v; } while(0)\n#define doublestore(T,V) do { *((long *) T) = ((doubleget_union *)&V)->m[0]; \\\n\t\t\t     *(((long *) T)+1) = ((doubleget_union *)&V)->m[1]; \\\n                         } while (0)\n#define float4get(V,M)   do { *((float *) &(V)) = *((float*) (M)); } while(0)\n#define float8get(V,M)   doubleget((V),(M))\n#define float4store(V,M) memcpy((uchar*) V,(uchar*) (&M),sizeof(float))\n#define floatstore(T,V)  memcpy((uchar*)(T), (uchar*)(&V),sizeof(float))\n#define floatget(V,M)    memcpy((uchar*) &V,(uchar*) (M),sizeof(float))\n#define float8store(V,M) doublestore((V),(M))\n#else\n\n/*\n  We're here if it's not a IA-32 architecture (Win32 and UNIX IA-32 defines\n  were done before)\n*/\n#define sint2korr(A)\t(int16) (((int16) ((uchar) (A)[0])) +\\\n\t\t\t\t ((int16) ((int16) (A)[1]) << 8))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(int32) (((int32) ((uchar) (A)[0])) +\\\n\t\t\t\t(((int32) ((uchar) (A)[1]) << 8)) +\\\n\t\t\t\t(((int32) ((uchar) (A)[2]) << 16)) +\\\n\t\t\t\t(((int32) ((int16) (A)[3]) << 24)))\n#define sint8korr(A)\t(longlong) uint8korr(A)\n#define uint2korr(A)\t(uint16) (((uint16) ((uchar) (A)[0])) +\\\n\t\t\t\t  ((uint16) ((uchar) (A)[1]) << 8))\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#define uint4korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[3])) << 24))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t(((ulonglong) (((uint32) ((uchar) (A)[4])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[5])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[6])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[7])) << 24))) <<\\\n\t\t\t\t    32))\n#define int2store(T,A)       do { uint def_temp= (uint) (A) ;\\\n                                  *((uchar*) (T))=  (uchar)(def_temp); \\\n                                   *((uchar*) (T)+1)=(uchar)((def_temp >> 8)); \\\n                             } while(0)\n#define int3store(T,A)       do { /*lint -save -e734 */\\\n                                  *((uchar*)(T))=(uchar) ((A));\\\n                                  *((uchar*) (T)+1)=(uchar) (((A) >> 8));\\\n                                  *((uchar*)(T)+2)=(uchar) (((A) >> 16)); \\\n                                  /*lint -restore */} while(0)\n#define int4store(T,A)       do { *((char *)(T))=(char) ((A));\\\n                                  *(((char *)(T))+1)=(char) (((A) >> 8));\\\n                                  *(((char *)(T))+2)=(char) (((A) >> 16));\\\n                                  *(((char *)(T))+3)=(char) (((A) >> 24)); } while(0)\n#define int5store(T,A)       do { *((char *)(T))=     (char)((A));  \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n\t\t                } while(0)\n#define int6store(T,A)       do { *((char *)(T))=     (char)((A)); \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n                                  *(((char *)(T))+5)= (char)(((A) >> 40)); \\\n                                } while(0)\n#define int8store(T,A)       do { uint def_temp= (uint) (A), def_temp2= (uint) ((A) >> 32); \\\n                                  int4store((T),def_temp); \\\n                                  int4store((T+4),def_temp2); } while(0)\n#ifdef WORDS_BIGENDIAN\n#define float4store(T,A) do { *(T)= ((uchar *) &A)[3];\\\n                              *((T)+1)=(char) ((uchar *) &A)[2];\\\n                              *((T)+2)=(char) ((uchar *) &A)[1];\\\n                              *((T)+3)=(char) ((uchar *) &A)[0]; } while(0)\n\n#define float4get(V,M)   do { float def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[3];\\\n                              ((uchar*) &def_temp)[1]=(M)[2];\\\n                              ((uchar*) &def_temp)[2]=(M)[1];\\\n                              ((uchar*) &def_temp)[3]=(M)[0];\\\n                              (V)=def_temp; } while(0)\n#define float8store(T,V) do { *(T)= ((uchar *) &V)[7];\\\n                              *((T)+1)=(char) ((uchar *) &V)[6];\\\n                              *((T)+2)=(char) ((uchar *) &V)[5];\\\n                              *((T)+3)=(char) ((uchar *) &V)[4];\\\n                              *((T)+4)=(char) ((uchar *) &V)[3];\\\n                              *((T)+5)=(char) ((uchar *) &V)[2];\\\n                              *((T)+6)=(char) ((uchar *) &V)[1];\\\n                              *((T)+7)=(char) ((uchar *) &V)[0]; } while(0)\n\n#define float8get(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[7];\\\n                              ((uchar*) &def_temp)[1]=(M)[6];\\\n                              ((uchar*) &def_temp)[2]=(M)[5];\\\n                              ((uchar*) &def_temp)[3]=(M)[4];\\\n                              ((uchar*) &def_temp)[4]=(M)[3];\\\n                              ((uchar*) &def_temp)[5]=(M)[2];\\\n                              ((uchar*) &def_temp)[6]=(M)[1];\\\n                              ((uchar*) &def_temp)[7]=(M)[0];\\\n                              (V) = def_temp; } while(0)\n#else\n#define float4get(V,M)   memcpy(&V, (M), sizeof(float))\n#define float4store(V,M) memcpy(V, (&M), sizeof(float))\n\n#if defined(__FLOAT_WORD_ORDER) && (__FLOAT_WORD_ORDER == __BIG_ENDIAN)\n#define doublestore(T,V) do { *(((char*)T)+0)=(char) ((uchar *) &V)[4];\\\n                              *(((char*)T)+1)=(char) ((uchar *) &V)[5];\\\n                              *(((char*)T)+2)=(char) ((uchar *) &V)[6];\\\n                              *(((char*)T)+3)=(char) ((uchar *) &V)[7];\\\n                              *(((char*)T)+4)=(char) ((uchar *) &V)[0];\\\n                              *(((char*)T)+5)=(char) ((uchar *) &V)[1];\\\n                              *(((char*)T)+6)=(char) ((uchar *) &V)[2];\\\n                              *(((char*)T)+7)=(char) ((uchar *) &V)[3]; }\\\n                         while(0)\n#define doubleget(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[4];\\\n                              ((uchar*) &def_temp)[1]=(M)[5];\\\n                              ((uchar*) &def_temp)[2]=(M)[6];\\\n                              ((uchar*) &def_temp)[3]=(M)[7];\\\n                              ((uchar*) &def_temp)[4]=(M)[0];\\\n                              ((uchar*) &def_temp)[5]=(M)[1];\\\n                              ((uchar*) &def_temp)[6]=(M)[2];\\\n                              ((uchar*) &def_temp)[7]=(M)[3];\\\n                              (V) = def_temp; } while(0)\n#endif /* __FLOAT_WORD_ORDER */\n\n#define float8get(V,M)   doubleget((V),(M))\n#define float8store(V,M) doublestore((V),(M))\n#endif /* WORDS_BIGENDIAN */\n\n#endif /* __i386__ OR _WIN32 */\n\n/*\n  Macro for reading 32-bit integer from network byte order (big-endian)\n  from unaligned memory location.\n*/\n#define int4net(A)        (int32) (((uint32) ((uchar) (A)[3]))        |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 8)  |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 16) |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[0])) << 24))\n/*\n  Define-funktions for reading and storing in machine format from/to\n  short/long to/from some place in memory V should be a (not\n  register) variable, M is a pointer to byte\n*/\n\n#ifdef WORDS_BIGENDIAN\n\n#define ushortget(V,M)  do { V = (uint16) (((uint16) ((uchar) (M)[1]))+\\\n                                 ((uint16) ((uint16) (M)[0]) << 8)); } while(0)\n#define shortget(V,M)   do { V = (short) (((short) ((uchar) (M)[1]))+\\\n                                 ((short) ((short) (M)[0]) << 8)); } while(0)\n#define longget(V,M)    do { int32 def_temp;\\\n                             ((uchar*) &def_temp)[0]=(M)[0];\\\n                             ((uchar*) &def_temp)[1]=(M)[1];\\\n                             ((uchar*) &def_temp)[2]=(M)[2];\\\n                             ((uchar*) &def_temp)[3]=(M)[3];\\\n                             (V)=def_temp; } while(0)\n#define ulongget(V,M)   do { uint32 def_temp;\\\n                            ((uchar*) &def_temp)[0]=(M)[0];\\\n                            ((uchar*) &def_temp)[1]=(M)[1];\\\n                            ((uchar*) &def_temp)[2]=(M)[2];\\\n                            ((uchar*) &def_temp)[3]=(M)[3];\\\n                            (V)=def_temp; } while(0)\n#define shortstore(T,A) do { uint def_temp=(uint) (A) ;\\\n                             *(((char*)T)+1)=(char)(def_temp); \\\n                             *(((char*)T)+0)=(char)(def_temp >> 8); } while(0)\n#define longstore(T,A)  do { *(((char*)T)+3)=((A));\\\n                             *(((char*)T)+2)=(((A) >> 8));\\\n                             *(((char*)T)+1)=(((A) >> 16));\\\n                             *(((char*)T)+0)=(((A) >> 24)); } while(0)\n\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#define floatstore(T,V)  memcpy((T), (void*) (&V), sizeof(float))\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#else\n\n#define ushortget(V,M)\tdo { V = uint2korr(M); } while(0)\n#define shortget(V,M)\tdo { V = sint2korr(M); } while(0)\n#define longget(V,M)\tdo { V = sint4korr(M); } while(0)\n#define ulongget(V,M)   do { V = uint4korr(M); } while(0)\n#define shortstore(T,V) int2store(T,V)\n#define longstore(T,V)\tint4store(T,V)\n#ifndef floatstore\n#define floatstore(T,V)  memcpy((T), (void *) (&V), sizeof(float))\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#endif\n#ifndef doubleget\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#endif /* doubleget */\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#endif /* WORDS_BIGENDIAN */\n\n#ifdef HAVE_CHARSET_utf8\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET \"utf8\"\n#else\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET MYSQL_DEFAULT_CHARSET_NAME\n#endif\n\n#if defined(EMBEDDED_LIBRARY) && !defined(HAVE_EMBEDDED_PRIVILEGE_CONTROL)\n#define NO_EMBEDDED_ACCESS_CHECKS\n#endif\n\n#if defined(_WIN32)\n#define dlsym(lib, name) (void*)GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#ifndef HAVE_DLOPEN\n#define HAVE_DLOPEN\n#endif\n#endif\n\n#ifdef HAVE_DLOPEN\n#if defined(HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n#endif\n\n#ifndef HAVE_DLERROR\n#ifdef _WIN32\n#define DLERROR_GENERATE(errmsg, error_number) \\\n  char win_errormsg[2048]; \\\n  if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, \\\n                   0, error_number, 0, win_errormsg, 2048, NULL)) \\\n  { \\\n    char *ptr; \\\n    for (ptr= &win_errormsg[0] + strlen(win_errormsg) - 1; \\\n         ptr >= &win_errormsg[0] && strchr(\"\\r\\n\\t\\0x20\", *ptr); \\\n         ptr--) \\\n      *ptr= 0; \\\n    errmsg= win_errormsg; \\\n  } \\\n  else \\\n    errmsg= \"\"\n#define dlerror() \"\"\n#define dlopen_errno GetLastError()\n#else /* _WIN32 */\n#define dlerror() \"No support for dynamic loading (static build?)\"\n#define DLERROR_GENERATE(errmsg, error_number) errmsg= dlerror()\n#define dlopen_errno errno\n#endif /* _WIN32 */\n#else /* HAVE_DLERROR */\n#define DLERROR_GENERATE(errmsg, error_number) errmsg= dlerror()\n#define dlopen_errno errno\n#endif /* HAVE_DLERROR */\n\n\n/*\n *  Include standard definitions of operator new and delete.\n */\n#ifdef __cplusplus\n#include <new>\n#endif\n\n/* Length of decimal number represented by INT32. */\n#define MY_INT32_NUM_DECIMAL_DIGITS 11\n\n/* Length of decimal number represented by INT64. */\n#define MY_INT64_NUM_DECIMAL_DIGITS 21\n\n/* Define some useful general macros (should be done after all headers). */\n#if !defined(max)\n#define max(a, b)\t((a) > (b) ? (a) : (b))\n#define min(a, b)\t((a) < (b) ? (a) : (b))\n#endif  \n\n/*\n  Only Linux is known to need an explicit sync of the directory to make sure a\n  file creation/deletion/renaming in(from,to) this directory durable.\n*/\n#ifdef TARGET_OS_LINUX\n#define NEED_EXPLICIT_SYNC_DIR 1\n#endif\n\n#if !defined(__cplusplus) && !defined(bool)\n#define bool In_C_you_should_use_my_bool_instead()\n#endif\n\n/* Provide __func__ macro definition for platforms that miss it. */\n#if __STDC_VERSION__ < 199901L\n#  if __GNUC__ >= 2\n#    define __func__ __FUNCTION__\n#  else\n#    define __func__ \"<unknown>\"\n#  endif\n#elif defined(_MSC_VER)\n#  if _MSC_VER < 1300\n#    define __func__ \"<unknown>\"\n#  else\n#    define __func__ __FUNCTION__\n#  endif\n#elif defined(__BORLANDC__)\n#  define __func__ __FUNC__\n#else\n#  define __func__ \"<unknown>\"\n#endif\n\n#ifndef HAVE_RINT\n/**\n   All integers up to this number can be represented exactly as double precision\n   values (DBL_MANT_DIG == 53 for IEEE 754 hardware).\n*/\n#define MAX_EXACT_INTEGER ((1LL << DBL_MANT_DIG) - 1)\n\n/**\n   rint(3) implementation for platforms that do not have it.\n   Always rounds to the nearest integer with ties being rounded to the nearest\n   even integer to mimic glibc's rint() behavior in the \"round-to-nearest\"\n   FPU mode. Hardware-specific optimizations are possible (frndint on x86).\n   Unlike this implementation, hardware will also honor the FPU rounding mode.\n*/\n\nstatic inline double rint(double x)\n{\n  double f, i;\n  f = modf(x, &i);\n  /*\n    All doubles with absolute values > MAX_EXACT_INTEGER are even anyway,\n    no need to check it.\n  */\n  if (x > 0.0)\n    i += (double) ((f > 0.5) || (f == 0.5 &&\n                                 i <= (double) MAX_EXACT_INTEGER &&\n                                 (longlong) i % 2));\n  else\n    i -= (double) ((f < -0.5) || (f == -0.5 &&\n                                  i >= (double) -MAX_EXACT_INTEGER &&\n                                  (longlong) i % 2));\n  return i;\n}\n#endif /* HAVE_RINT */\n\n/* \n  MYSQL_PLUGIN_IMPORT macro is used to export mysqld data\n  (i.e variables) for usage in storage engine loadable plugins.\n  Outside of Windows, it is dummy.\n*/\n#ifndef MYSQL_PLUGIN_IMPORT\n#if (defined(_WIN32) && defined(MYSQL_DYNAMIC_PLUGIN))\n#define MYSQL_PLUGIN_IMPORT __declspec(dllimport)\n#else\n#define MYSQL_PLUGIN_IMPORT\n#endif\n#endif\n\n/* Defines that are unique to the embedded version of MySQL */\n\n#ifdef EMBEDDED_LIBRARY\n\n/* Things we don't need in the embedded version of MySQL */\n/* TODO HF add #undef HAVE_VIO if we don't want client in embedded library */\n\n#undef HAVE_OPENSSL\n#undef HAVE_SMEM\t\t\t\t/* No shared memory */\n\n#endif /* EMBEDDED_LIBRARY */\n\n#endif /* my_global_h */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql-common/client_plugin.c": "/* Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n  \n  Support code for the client side (libmysql) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n#include <my_global.h>\n#include \"mysql.h\"\n#include <my_sys.h>\n#include <m_string.h>\n#include <my_pthread.h>\n\n#include <sql_common.h>\n#include \"errmsg.h\"\n#include <mysql/client_plugin.h>\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void   *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic my_bool initialized= 0;\nstatic MEM_ROOT mem_root;\n\nstatic const char *plugin_declarations_sym= \"_mysql_client_plugin_declaration_\";\nstatic uint plugin_version[MYSQL_CLIENT_MAX_PLUGINS]=\n{\n  0, /* these two are taken by Connector/C */\n  0, /* these two are taken by Connector/C */\n  MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS];\nstatic pthread_mutex_t LOCK_load_client_plugin;\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name)\n{\n  if (initialized)\n    return 0;\n\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                           unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                           name, \"not initialized\");\n  return 1;\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n  \n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\nfind_plugin(const char *name, int type)\n{\n  struct st_client_plugin_int *p;\n\n  DBUG_ASSERT(initialized);\n  DBUG_ASSERT(type >= 0 && type < MYSQL_CLIENT_MAX_PLUGINS);\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n    return 0;\n\n  for (p= plugin_list[type]; p; p= p->next)\n  {\n    if (strcmp(p->plugin->name, name) == 0)\n      return p->plugin;\n  }\n  return NULL;\n}\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\nadd_plugin(MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n           int argc, va_list args)\n{\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin= plugin;\n  plugin_int.dlhandle= dlhandle;\n\n  if (plugin->type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    errmsg= \"Unknown client plugin type\";\n    goto err1;\n  }\n\n  if (plugin->interface_version < plugin_version[plugin->type] ||\n      (plugin->interface_version >> 8) >\n       (plugin_version[plugin->type] >> 8))\n  {\n    errmsg= \"Incompatible client plugin interface\";\n    goto err1;\n  }\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args))\n  {\n    errmsg= errbuf;\n    goto err1;\n  }\n\n  p= (struct st_client_plugin_int *)\n    memdup_root(&mem_root, &plugin_int, sizeof(plugin_int));\n\n  if (!p)\n  {\n    errmsg= \"Out of memory\";\n    goto err2;\n  }\n\n  safe_mutex_assert_owner(&LOCK_load_client_plugin);\n\n  p->next= plugin_list[plugin->type];\n  plugin_list[plugin->type]= p;\n  net_clear_error(&mysql->net);\n\n  return plugin;\n\nerr2:\n  if (plugin->deinit)\n    plugin->deinit();\nerr1:\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name,\n                           errmsg);\n  if (dlhandle)\n    dlclose(dlhandle);\n  return NULL;\n}\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n  \n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\nstatic void load_env_plugins(MYSQL *mysql)\n{\n  char *plugs, *free_env, *s= getenv(\"LIBMYSQL_PLUGINS\");\n  char *enable_cleartext_plugin= getenv(\"LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN\");\n\n  if (enable_cleartext_plugin && strchr(\"1Yy\", enable_cleartext_plugin[0]))\n    libmysql_cleartext_plugin_enabled= 1;\n\n  /* no plugins to load */\n  if(!s)\n    return;\n\n  free_env= plugs= my_strdup(s, MYF(MY_WME));\n\n  do {\n    if ((s= strchr(plugs, ';')))\n      *s= '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs= s + 1;\n  } while (s);\n\n  my_free(free_env);\n\n}\n\n/********** extern functions to be used by libmysql *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occured\n*/\nint mysql_client_plugin_init()\n{\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n\n  if (initialized)\n    return 0;\n\n  bzero(&mysql, sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n\n  pthread_mutex_init(&LOCK_load_client_plugin, MY_MUTEX_INIT_SLOW);\n  init_alloc_root(&mem_root, 128, 128);\n\n  bzero(&plugin_list, sizeof(plugin_list));\n\n  initialized= 1;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    add_plugin(&mysql, *builtin, 0, 0, 0);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  return 0;\n}\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\nvoid mysql_client_plugin_deinit()\n{\n  int i;\n  struct st_client_plugin_int *p;\n\n  if (!initialized)\n    return;\n\n  for (i=0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p= plugin_list[i]; p; p= p->next)\n    {\n      if (p->plugin->deinit)\n        p->plugin->deinit();\n      if (p->dlhandle)\n        dlclose(p->dlhandle);\n    }\n\n  bzero(&plugin_list, sizeof(plugin_list));\n  initialized= 0;\n  free_root(&mem_root, MYF(0));\n  pthread_mutex_destroy(&LOCK_load_client_plugin);\n}\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_register_plugin(MYSQL *mysql,\n                             struct st_mysql_client_plugin *plugin)\n{\n  if (is_not_initialized(mysql, plugin->name))\n    return NULL;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type))\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                             unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                             plugin->name, \"it is already loaded\");\n    plugin= NULL;\n  }\n  else\n    plugin= add_plugin(mysql, plugin, 0, 0, 0);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  return plugin;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin_v(MYSQL *mysql, const char *name, int type,\n                    int argc, va_list args)\n{\n  const char *errmsg;\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n#ifdef _WIN32\n  char win_errormsg[2048];\n#endif\n\n  DBUG_ENTER (\"mysql_load_plugin_v\");\n  DBUG_PRINT (\"entry\", (\"name=%s type=%d int argc=%d\", name, type, argc));\n  if (is_not_initialized(mysql, name))\n  {\n    DBUG_PRINT (\"leave\", (\"mysql not initialized\"));\n    DBUG_RETURN (NULL);\n  }\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  /* Compile dll path */\n  strxnmov(dlpath, sizeof(dlpath) - 1,\n           mysql->options.extension && mysql->options.extension->plugin_dir ?\n           mysql->options.extension->plugin_dir : PLUGINDIR, \"/\",\n           name, SO_EXT, NullS);\n   \n  DBUG_PRINT (\"info\", (\"dlopeninig %s\", dlpath));\n  /* Open new dll handle */\n  if (!(dlhandle= dlopen(dlpath, RTLD_NOW)))\n  {\n#if defined(__APPLE__)\n    /* Apple supports plugins with .so also, so try this as well */\n    strxnmov(dlpath, sizeof(dlpath) - 1,\n             mysql->options.extension && mysql->options.extension->plugin_dir ?\n             mysql->options.extension->plugin_dir : PLUGINDIR, \"/\",\n             name, \".so\", NullS);\n    if ((dlhandle= dlopen(dlpath, RTLD_NOW)))\n      goto have_plugin;\n#endif\n\n    DBUG_PRINT (\"info\", (\"failed to dlopen\"));\n#ifdef _WIN32\n    if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                  0, GetLastError(), 0, win_errormsg, 2048, NULL))\n      errmsg= win_errormsg;\n    else\n      errmsg= \"\";\n#else\n    errmsg= dlerror();\n#endif\n    goto err;\n  }\n\n#if defined(__APPLE__)\nhave_plugin:  \n#endif\n  if (!(sym= dlsym(dlhandle, plugin_declarations_sym)))\n  {\n    errmsg= \"not a plugin\";\n    dlclose(dlhandle);\n    goto err;\n  }\n\n  plugin= (struct st_mysql_client_plugin*)sym;\n\n  if (type >=0 && type != plugin->type)\n  {\n    errmsg= \"type mismatch\";\n    goto err;\n  }\n\n  if (strcmp(name, plugin->name))\n  {\n    errmsg= \"name mismatch\";\n    goto err;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  plugin= add_plugin(mysql, plugin, dlhandle, argc, args);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  DBUG_PRINT (\"leave\", (\"plugin loaded ok\"));\n  DBUG_RETURN (plugin);\n\nerr:\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  DBUG_PRINT (\"leave\", (\"plugin load error : %s\", errmsg));\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  DBUG_RETURN (NULL);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin(MYSQL *mysql, const char *name, int type, int argc, ...)\n{\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  va_start(args, argc);\n  p= mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  return p;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_find_plugin(MYSQL *mysql, const char *name, int type)\n{\n  struct st_mysql_client_plugin *p;\n\n  DBUG_ENTER (\"mysql_client_find_plugin\");\n  DBUG_PRINT (\"entry\", (\"name=%s, type=%d\", name, type));\n  if (is_not_initialized(mysql, name))\n    DBUG_RETURN (NULL);\n\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                             ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name,\n                             \"invalid type\");\n  }\n\n  if ((p= find_plugin(name, type)))\n  {\n    DBUG_PRINT (\"leave\", (\"found %p\", p));\n    DBUG_RETURN (p);\n  }\n\n  /* not found, load it */\n  p= mysql_load_plugin(mysql, name, type, 0);\n  DBUG_PRINT (\"leave\", (\"loaded %p\", p));\n  DBUG_RETURN (p);\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nint mysql_plugin_options(struct st_mysql_client_plugin *plugin,\n                                 const char *option,\n                                 const void *value)\n{\n  DBUG_ENTER(\"mysql_plugin_options\");\n  /* does the plugin support options call? */\n  if (!plugin || !plugin->options)\n    DBUG_RETURN(1);\n  DBUG_RETURN(plugin->options(option, value));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/valgrind.supp": "# Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Library General Public\n# License as published by the Free Software Foundation; version 2\n# of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Library General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n#\n# Suppress some common (not fatal) errors in system libraries found by valgrind\n#\n\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:allocate_stack\n   fun:pthread_create*\n}\n\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n\n}\n\n{\n   pthead_exit memory loss 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread_exit memory loss 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread allocate_dtv memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread allocate_dtv memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   pthread memalign memory loss\n   Memcheck:Leak\n   fun:memalign\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread pthread_key_create\n   Memcheck:Leak\n   fun:malloc\n   fun:*\n   fun:*\n   fun:pthread_key_create\n   fun:my_thread_global_init\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{  \n   strlen/_dl_init_paths/dl_main/_dl_sysdep_start(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:_dl_init_paths\n   fun:dl_main\n   fun:_dl_sysdep_start\n}\n\n{\n   pthread errno\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlsym\n   fun:__errno_location\n}\n\n\n#\n# Warnings in libz becasue it works with aligned memory(?)\n#\n\n{\n   libz tr_flush_block\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n   fun:gzclose\n}\n\n{\n   libz tr_flush_block2\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n}\n\n{\n   libz longest_match called from btr_store_big_rec_extern_fields\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields\n}\n\n{\n   libz longest_match called from page_zip_compress\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   libz longest_match2\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match 3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:gzclose\n}\n\n{\n   libz longest_match 4 \n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:gzflush\n}\n\n{\n   libz longest_match3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:azflush\n}\n\n{\n   libz longest_match3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:azclose\n}\n\n{\n   libz deflate\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz deflate2\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   obj:*/libz.so.*\n   fun:gzflush\n}\n\n{\n   libz deflate3\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:do_flush\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n\n# Red Hat AS 4 32 bit\n{\n   dl_relocate_object\n   Memcheck:Cond\n   fun:_dl_relocate_object\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n#\n# Leaks reported in _dl_* internal functions on Linux amd64 / glibc2.3.2.\n#\n\n{\n   _dl_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_start\n}\n\n{\n   _dl_start invalid write4\n   Memcheck:Addr4\n   fun:_dl_start\n}\n\n{\n   _dl_start/_dl_setup_hash invalid read8\n   Memcheck:Addr8\n   fun:_dl_setup_hash\n   fun:_dl_start\n}\n\n{\n   _dl_sysdep_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_sysdep_start\n}\n\n{\n   _dl_init invalid write8\n   Memcheck:Addr8\n   fun:_dl_init\n}\n\n{\n   _dl_init invalid write4\n   Memcheck:Addr4\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_init invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_initialize\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_debug_state invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_state\n   fun:_dl_init\n}\n\n{\n   init invalid write8\n   Memcheck:Addr8\n   fun:init\n}\n\n{\n   fixup invalid write8\n   Memcheck:Addr8\n   fun:fixup\n}\n\n{\n   fixup/_dl_lookup_versioned_symbol invalid read8\n   Memcheck:Addr8\n   fun:_dl_lookup_versioned_symbol\n   fun:fixup\n}\n\n{\n   _dl_runtime_resolve invalid read8\n   Memcheck:Addr8\n   fun:_dl_runtime_resolve\n}\n\n{\n   __libc_start_main invalid write8\n   Memcheck:Addr8\n   fun:__libc_start_main\n}\n\n{\n   __libc_start_main/__sigjmp_save invalid write4\n   Memcheck:Addr4\n   fun:__sigjmp_save\n   fun:__libc_start_main\n}\n\n#\n# These seem to be libc threading stuff, not related to MySQL code (allocations\n# during pthread_exit()). Googling shows other projects also using these\n# suppressions.\n#\n# Note that these all stem from pthread_exit() deeper in the call stack, but\n# Valgrind only allows the top four calls in the suppressions.\n#\n\n{\n   libc pthread_exit 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 6\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:openaux\n   fun:_dl_catch_error \n}\n\n{\n   libc pthread_exit 7\n   Memcheck:Leak\n   fun:malloc\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n}\n\n{\n   libc pthread_exit 8\n   Memcheck:Leak\n   fun:malloc\n   fun:local_strdup\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   libc pthread_exit 9\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_close_worker\n   fun:_dl_close\n   fun:_dl_catch_error\n}\n\n#\n# This is seen internally in the system libraries on 64-bit RHAS3.\n#\n\n{\n   __lll_mutex_unlock_wake uninitialized\n   Memcheck:Param\n   futex(utime)\n   fun:__lll_mutex_unlock_wake\n}\n\n#\n# BUG#19940: NDB sends uninitialized parts of field buffers across the wire.\n# This is \"works as designed\"; the uninitialized part is not used at the\n# other end (but Valgrind cannot see this).\n#\n{\n   bug19940\n   Memcheck:Param\n   socketcall.sendto(msg)\n   fun:send\n   fun:_ZN15TCP_Transporter6doSendEv\n   fun:_ZN19TransporterRegistry11performSendEv\n   fun:_ZN19TransporterRegistry14forceSendCheckEi\n}\n# Warning when printing stack trace (to suppress some not needed warnings)\n#\n\n{\n   vprintf on stacktrace\n   Memcheck:Cond\n   fun:vfprintf\n   fun:uffered_vfprintf\n   fun:vfprintf\n   fun:fprintf\n   fun:print_stacktrace\n}\n\n#\n# Safe warnings, that may happen because of thread scheduling\n#\n\n{\n   dbug initialization by kill_server\n   Memcheck:Leak\n   fun:malloc\n   fun:DbugMalloc\n   fun:code_state\n   fun:_db_enter_\n   fun:kill_server\n}\n\n#\n# Warning caused by small memory leak in threaded dlopen\n#\n\n{\n   dlopen threaded memory leak\n   Memcheck:Leak\n   fun:calloc\n   obj:*/libdl-*.so\n   fun:dlopen*\n}\n\n#\n# BUG#45630\n# Suppress valgrind failures within nptl_pthread_exit_hack_handler on Ubuntu 9.04, x86 (but not amd64)\n#\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 1\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 2\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 3\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 4\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 5\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n}\n\n# suppressions for glibc 2.6.1 64 bit\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 6\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 7\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 8\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 8\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss in 2.6.1.\n   Memcheck:Leak \n   fun:calloc\n   obj:*/ld-*.so\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   buf_buddy_relocate peeking (space,page) in potentially free blocks\n   Memcheck:Addr1\n   fun:buf_buddy_relocate\n}\n\n#\n# See related Bug#56666\n# Race condition between the server main thread and the kill server thread.\n#\n# Because of this race condition, the call to shutdown_performance_schema()\n# was commented in sql/mysqld.cc, causing the reported leaks.\n#\n\n{\n   missing shutdown_performance_schema 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_Z10pfs_mallocmi\n}\n\n{\n   missing shutdown_performance_schema 2\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_alloc_new\n   fun:lf_hash_insert\n}\n\n#\n# Note that initialize_bucket() is reccursive,\n# can't provide more stack context.\n#\n{\n   missing shutdown_performance_schema 3\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:initialize_bucket\n}\n\n{\n   missing shutdown_performance_schema 4\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_dynarray_lvalue\n   fun:_lf_pinbox_get_pins\n}\n\n{\n   missing shutdown_performance_schema 5\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_dynarray_lvalue\n   fun:lf_hash_insert\n}\n\n{\n   missing shutdown_performance_schema 6\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_dynarray_lvalue\n   fun:lf_hash_delete\n}\n\n{\n   missing shutdown_performance_schema 7\n   Memcheck:Leak\n   fun:malloc\n   fun:my_malloc\n   fun:_lf_dynarray_lvalue\n   fun:lf_hash_search\n}\n\n{\n   Bug 59874 Valgrind warning in InnoDB compression code\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields_func\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress_deflate\n}\n\n{\n   Bug 59875 Valgrind warning in buf0buddy.c\n   Memcheck:Addr1\n   fun:mach_read_from_4\n   fun:buf_buddy_relocate\n   fun:buf_buddy_free_low\n   fun:buf_buddy_free\n}\n\n# Note the wildcard in the (mangled) function signatures of\n# write_keys() and find_all_keys().\n# They both return ha_rows, which is platform dependent.\n#\n# The '...' wildcards are for 'fun:inline_mysql_file_write' and\n# 'fun:find_all_keys' which *may* be inlined.\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / one\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_my_b_write\n   fun:_Z*10write_keysP13st_sort_paramPPhjP11st_io_cacheS4_\n   ...\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / two\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_Z15merge_many_buffP13st_sort_paramPhP10st_buffpekPjP11st_io_cache\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / three\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/sp-error.test": "#\n# Stored PROCEDURE error tests\n#\n\n--disable_warnings\ndrop table if exists t1, t2;\n--enable_warnings\n\n# Backup the mysql.proc table\n--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR\neval SELECT * FROM mysql.proc INTO OUTFILE '$MYSQLTEST_VARDIR/tmp/proc.txt';\n\n# Make sure we don't have any procedures left.\ndelete from mysql.proc;\n\ndelimiter |;\n\n# This should give three syntax errors (sometimes crashed; bug #643)\n# (Unfortunately, this is not a 100% test, on some platforms this\n#  passed despite the bug.)\n--error 1064\ncreate procedure syntaxerror(t int)|\n--error 1064\ncreate procedure syntaxerror(t int)|\n--error 1064\ncreate procedure syntaxerror(t int)|\n\n# Check that we get the right error, i.e. UDF declaration parses correctly,\n# but foo.so doesn't exist.\n#    This generates an error message containing a misleading errno which\n#    might vary between systems (it usually doesn't have anything to do with\n#    the actual failing dlopen()).\n#--error 1126\n#create function foo returns real soname \"foo.so\"|\n\n\n--disable_warnings\ndrop table if exists t3|\n--enable_warnings\ncreate table t3 ( x int )|\ninsert into t3 values (2), (3)|\n\ncreate procedure bad_into(out param int)\n  select x from t3 into param|\n\n--error 1172\ncall bad_into(@x)|\n\ndrop procedure bad_into|\ndrop table t3|\n\n\ncreate procedure proc1()\n  set @x = 42|\n\ncreate function func1() returns int\n  return 42|\n\n# Can't create recursively\n--error 1303\ncreate procedure foo()\n  create procedure bar() set @x=3|\n--error 1303\ncreate procedure foo()\n  create function bar() returns double return 2.3|\n\n# Already exists\n--error 1304\ncreate procedure proc1()\n  set @x = 42|\n--error 1304\ncreate function func1() returns int\n  return 42|\n\ndrop procedure proc1|\ndrop function func1|\n\n# Does not exist\n--error 1305\nalter procedure foo|\n--error 1305\nalter function foo|\n--error 1305\ndrop procedure foo|\n--error 1305\ndrop function foo|\n--error 1305\ncall foo()|\ndrop procedure if exists foo|\n--error 1305\nshow create procedure foo|\n--error 1305\nshow create function foo|\n\n# LEAVE/ITERATE with no match\n--error 1308\ncreate procedure foo()\nfoo: loop\n  leave bar;\nend loop|\n--error 1308\ncreate procedure foo()\nfoo: loop\n  iterate bar;\nend loop|\n--error 1308\ncreate procedure foo()\nfoo: begin\n  iterate foo;\nend|\n\n# Redefining label\n--error 1309\ncreate procedure foo()\nfoo: loop\n  foo: loop\n    set @x=2;\n  end loop foo;\nend loop foo|\n\n# End label mismatch\n--error 1310\ncreate procedure foo()\nfoo: loop\n  set @x=2;\nend loop bar|\n\n# RETURN in FUNCTION only\n--error 1313\ncreate procedure foo()\n  return 42|\n\n# Wrong number of arguments\ncreate procedure p(x int)\n  set @x = x|\ncreate function f(x int) returns int\n  return x+42|\n\n--error 1318\ncall p()|\n--error 1318\ncall p(1, 2)|\n--error 1318\nselect f()|\n--error 1318\nselect f(1, 2)|\n\ndrop procedure p|\ndrop function f|\n\n--error 1319 \ncreate procedure p(val int, out res int)\nbegin\n  declare x int default 0;\n  declare continue handler for foo set x = 1;\n\n  insert into test.t1 values (val);\n  if (x) then\n    set res = 0;\n  else\n    set res = 1;\n  end if;\nend|\n\n--error 1319 \ncreate procedure p(val int, out res int)\nbegin\n  declare x int default 0;\n  declare foo condition for 1146;\n  declare continue handler for bar set x = 1;\n\n  insert into test.t1 values (val);\n  if (x) then\n    set res = 0;\n  else\n    set res = 1;\n  end if;\nend|\n\n--error 1320\ncreate function f(val int) returns int\nbegin\n  declare x int;\n\n  set x = val+3;\nend|\n\ncreate function f(val int) returns int\nbegin\n  declare x int;\n\n  set x = val+3;\n  if x < 4 then\n    return x;\n  end if;\nend|\n\n--error 1321\nselect f(10)|\n\ndrop function f|\n\n--error ER_PARSE_ERROR\ncreate procedure p()\nbegin\n  declare c cursor for insert into test.t1 values (\"foo\", 42);\n\n  open c;\n  close c;\nend|\n\n--error 1323\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * into x from test.t limit 1;\n\n  open c;\n  close c;\nend|\n\n--error 1324\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t;\n\n  open cc;\n  close c;\nend|\n\n--disable_warnings\ndrop table if exists t1|\n--enable_warnings\ncreate table t1 (val int)|\n\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t1;\n\n  open c;\n  open c;\n  close c;\nend|\n--error 1325\ncall p()|\ndrop procedure p|\n\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t1;\n\n  open c;\n  close c;\n  close c;\nend|\n--error 1326\ncall p()|\ndrop procedure p|\n\n--error 1305\nalter procedure bar3 sql security invoker|\n\ndrop table t1|\n\n--disable_warnings\ndrop table if exists t1|\n--enable_warnings\ncreate table t1 (val int, x float)|\ninsert into t1 values (42, 3.1), (19, 1.2)|\n\n--error 1327\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x, y;\n  close c;\nend|\n\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x;\n  close c;\nend|\n--error 1328\ncall p()|\ndrop procedure p|\n\ncreate procedure p()\nbegin\n  declare x int;\n  declare y float;\n  declare z int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x, y, z;\n  close c;\nend|\n--error 1328\ncall p()|\ndrop procedure p|\n\n--error 1330\ncreate procedure p(in x int, x char(10))\nbegin\nend|\n--error 1330\ncreate function p(x int, x char(10))\nbegin\nend|\n\n--error 1331\ncreate procedure p()\nbegin\n  declare x float;\n  declare x int;\nend|\n\n--error 1332\ncreate procedure p()\nbegin\n  declare c condition for 1064;\n  declare c condition for 1065;\nend|\n\n--error 1333\ncreate procedure p()\nbegin\n  declare c cursor for select * from t1;\n  declare c cursor for select field from t1;\nend|\n\n# USE is not allowed\n--error ER_SP_BADSTATEMENT \ncreate procedure u()\n  use sptmp|\n\n# Enforced standard order of declarations\n--error 1337\ncreate procedure p()\nbegin\n  declare c cursor for select * from t1;\n  declare x int;\nend|\n--error 1337\ncreate procedure p()\nbegin\n  declare x int;\n  declare continue handler for sqlstate '42S99' set x = 1;\n  declare foo condition for sqlstate '42S99';\nend|\n\n--error 1338\ncreate procedure p()\nbegin\n  declare x int;\n  declare continue handler for sqlstate '42S99' set x = 1;\n  declare c cursor for select * from t1;\nend|\n\n# Check in and inout arguments.\n--disable_warnings\ndrop procedure if exists p|\n--enable_warnings\ncreate procedure p(in x int, inout y int, out z int)\nbegin\n  set y = x+y;\n  set z = x+y;\nend|\n\nset @tmp_x = 42|\nset @tmp_y = 3|\nset @tmp_z = 0|\n# For reference: this is ok\ncall p(@tmp_x, @tmp_y, @tmp_z)|\nselect @tmp_x, @tmp_y, @tmp_z|\n\n--error ER_SP_NOT_VAR_ARG\ncall p(42, 43, @tmp_z)|\n--error ER_SP_NOT_VAR_ARG\ncall p(42, @tmp_y, 43)|\n\ndrop procedure p|\n\n\n#\n# Let us test that we can access mysql.proc table for routines\n# definitions lookup without locking it explicitly.\n#\ncreate procedure p() begin end|\nlock table t1 read|\n# This should succeed\ncall p()|\nunlock tables|\ndrop procedure p|\n# Let us check restrictions which this ability puts on mysql.proc locking.\n--error ER_WRONG_LOCK_OF_SYSTEM_TABLE\nlock tables t1 read, mysql.proc write|\n--error ER_WRONG_LOCK_OF_SYSTEM_TABLE\nlock tables mysql.proc write, mysql.user write|\n# Locking for read should be OK\nlock tables t1 read, mysql.proc read|\nunlock tables|\n# You also should be able lock only mysql.proc for write\nlock tables mysql.proc write|\nunlock tables|\n\n\n#\n# Check that in functions we don't allow to update tables which\n# are used by statements which invoke these functions.\n#\n--disable_warnings\ndrop function if exists f1|\n--enable_warnings\ncreate function f1(i int) returns int\nbegin\n  insert into t1 (val) values (i);\n  return 0;\nend|\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nselect val, f1(val) from t1|\n# Table alias should not matter\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nselect val, f1(val) from t1 as tab|\nselect * from t1|\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nupdate t1 set val= f1(val)|\nselect * from t1|\n# But this should be OK\nselect f1(17)|\nselect * from t1|\n# Cleanup\ndelete from t1 where val= 17|\ndrop function f1|\n\n\n#\n# BUG#1965\n#\ncreate procedure bug1965()\nbegin\n  declare c cursor for select val from t1 order by valname;\n  open c;\n  close c;\nend|\n\n--error 1054\ncall bug1965()|\ndrop procedure bug1965|\n\n#\n# BUG#1966\n#\n--error 1327\nselect 1 into a|\n\n#\n# BUG#1653\n#\n--disable_warnings\ndrop table if exists t3|\n--enable_warnings\ncreate table t3 (column_1_0 int)|\n\ncreate procedure bug1653()\n  update t3 set column_1 = 0|\n\n--error 1054\ncall bug1653()|\ndrop table t3|\ncreate table t3 (column_1 int)|\ncall bug1653()|\n\ndrop procedure bug1653|\ndrop table t3|\n\n#\n# BUG#2259\n#\n# Note: When this bug existed, it did not necessarily cause a crash\n#       in all builds, but valgrind did give warnings.\ncreate procedure bug2259()\nbegin\n  declare v1 int;\n  declare c1 cursor for select s1 from t1;\n\n  fetch c1 into v1;\nend|\n\n--error 1326\ncall bug2259()|\ndrop procedure bug2259|\n\n#\n# BUG#2272\n#\ncreate procedure bug2272()\nbegin\n  declare v int;\n\n  update t1 set v = 42;\nend|\n\ninsert into t1 values (666, 51.3)|\n--error 1054\ncall bug2272()|\ntruncate table t1|\ndrop procedure bug2272|\n\n#\n# BUG#2329\n#\ncreate procedure bug2329_1()\nbegin\n  declare v int;\n\n  insert into t1 (v) values (5);\nend|\n\ncreate procedure bug2329_2()\nbegin\n  declare v int;\n\n  replace t1 set v = 5;\nend|\n\n--error 1054\ncall bug2329_1()|\n--error 1054\ncall bug2329_2()|\ndrop procedure bug2329_1|\ndrop procedure bug2329_2|\n\n#\n# BUG#3287\n#\ncreate function bug3287() returns int\nbegin\n  declare v int default null;\n\n  case\n    when v is not null then return 1;\n  end case;\n  return 2;\nend|\n--error 1339\nselect bug3287()|\ndrop function bug3287|\n\ncreate procedure bug3287(x int)\ncase x\nwhen 0 then\n  insert into test.t1 values (x, 0.1);\nwhen 1 then\n  insert into test.t1 values (x, 1.1);\nend case|\n--error 1339\ncall bug3287(2)|\ndrop procedure bug3287|\n\n#\n# BUG#3297\n#\n--disable_warnings\ndrop table if exists t3|\n--enable_warnings\ncreate table t3 (s1 int, primary key (s1))|\ninsert into t3 values (5),(6)|\n\ncreate procedure bug3279(out y int) \nbegin\n  declare x int default 0;\n  begin\n    declare exit handler for sqlexception set x = x+1;\n    insert into t3 values (5);\n  end;\n  if x < 2 then\n    set x = x+1;\n    insert into t3 values (6);\n  end if;\n  set y = x;\nend|\n\nset @x = 0|\n--error ER_DUP_ENTRY\ncall bug3279(@x)|\nselect @x|\ndrop procedure bug3279|\ndrop table t3|\n\n#\n# BUG#3339\n#\n--error 1049\ncreate procedure nodb.bug3339() begin end|\n\n#\n# BUG#2653\n#\ncreate procedure bug2653_1(a int, out b int)\n  set b = aa|\n\ncreate procedure bug2653_2(a int, out b int)\nbegin\n  if aa < 0 then\n    set b = - a;\n  else\n    set b = a;\n  end if;\nend|\n\n--error 1054\ncall bug2653_1(1, @b)|\n--error 1054\ncall bug2653_2(2, @b)|\n\ndrop procedure bug2653_1|\ndrop procedure bug2653_2|\n\n#\n# BUG#4344\n#\n--error 1357\ncreate procedure bug4344() drop procedure bug4344|\n--error 1357\ncreate procedure bug4344() drop function bug4344|\n\n#\n# BUG#3294: Stored procedure crash if table dropped before use\n# (Actually, when an error occurs within an error handler.)\n--disable_warnings\ndrop procedure if exists bug3294|\n--enable_warnings\ncreate procedure bug3294()\nbegin\n  declare continue handler for sqlexception drop table t5;\n  drop table t5;\n  drop table t5;\nend|\n\ncreate table t5 (x int)|\n--error 1051\ncall bug3294()|\ndrop procedure bug3294|\n\n#\n# BUG#876: Stored Procedures: Invalid SQLSTATE is allowed in \n#          a DECLARE ? HANDLER FOR stmt.\n#\n--disable_warnings\ndrop procedure if exists bug8776_1|\ndrop procedure if exists bug8776_2|\ndrop procedure if exists bug8776_3|\ndrop procedure if exists bug8776_4|\n--enable_warnings\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_1()\nbegin\n  declare continue handler for sqlstate '42S0200test' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_2()\nbegin\n  declare continue handler for sqlstate '4200' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_3()\nbegin\n  declare continue handler for sqlstate '420000' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_4()\nbegin\n  declare continue handler for sqlstate '42x00' begin end;\n  begin end;\nend|\n\n\n#\n# BUG#6600: Stored procedure crash after repeated calls with check table\n#\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  check table t1|\n\n# Check these two as well, while we're at it. (Although it isn't really\n# related to the bug report, but to the fix.)\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  lock table t1 read|\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  unlock table t1|\n\n#\n# BUG#9566: explicit LOCK TABLE and store procedures result in illegal state\n#\n# We should not think that mysql.proc table does not exist if we are unable\n# to open it under LOCK TABLE or in prelocked mode.\n#\n--disable_warnings\ndrop procedure if exists bug9566|\n--enable_warnings\ncreate procedure bug9566()\nbegin\n  select * from t1;\nend|\nlock table t1 read|\n# This should fail since we forgot to lock mysql.proc for writing\n# explicitly, and we can't open mysql.proc for _writing_ if there\n# are locked tables.\n--error ER_LOCK_OR_ACTIVE_TRANSACTION\nalter procedure bug9566 comment 'Some comment'|\nunlock tables|\n# This should succeed\ndrop procedure bug9566|\n\n\n#\n# BUG#7299: Stored procedures: exception handler catches not-found conditions\n#\n--disable_warnings\ndrop procedure if exists bug7299|\n--enable_warnings\ncreate procedure bug7299()\nbegin\n  declare v int;\n  declare c cursor for select val from t1;\n  declare exit handler for sqlexception select 'Error!'; \n\n  open c;\n  fetch c into v;\nend|\n\ntruncate table t1|\n--error ER_SP_FETCH_NO_DATA\ncall bug7299()|\ndrop procedure bug7299|\n\n\n#\n# BUG#9073: Able to declare two handlers for same condition in same scope\n#\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare continue handler for sqlexception select 1;\n  declare continue handler for sqlexception select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for 1234;\n  declare continue handler for condname1 select 1;\n  declare exit handler for condname1 select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare condname2 condition for sqlstate '42000';\n  declare exit handler for condname1 select 1;\n  declare continue handler for condname2 select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare exit handler for condname1 select 1;\n  declare exit handler for sqlstate '42000' select 2;\nend|\n\n# This should still work.\n--disable_warnings\ndrop procedure if exists bug9073|\n--enable_warnings\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare continue handler for condname1 select 1;\n  begin\n    declare exit handler for sqlstate '42000' select 2;\n    begin\n      declare continue handler for sqlstate '42000' select 3;\n    end;\n  end;\nend|\ndrop procedure bug9073|\n\n\n#\n# BUG#7047: Stored procedure crash if alter procedure\n#\n--error ER_SP_NO_DROP_SP\ncreate procedure bug7047()\n  alter procedure bug7047|\n--error ER_SP_NO_DROP_SP\ncreate function bug7047() returns int\nbegin\n  alter function bug7047;\n  return 0;\nend|\n\n\n#\n# BUG#8408: Stored procedure crash if function contains SHOW\n# BUG#9058: Stored Procedures: Crash if function included SELECT\n#\n\n# Some things are caught when parsing\n--error ER_SP_NO_RETSET\ncreate function bug8408() returns int\nbegin\n  select * from t1;\n  return 0;\nend|\n--error ER_SP_NO_RETSET\ncreate function bug8408() returns int\nbegin\n  show warnings;\n  return 0;\nend|\n--error ER_SP_NO_RETSET\ncreate function bug8408(a int) returns int\nbegin\n  declare b int;\n  select b;\n  return b;\nend|\n\n--disable_warnings\ndrop function if exists bug8408_f|\ndrop procedure if exists bug8408_p|\n--enable_warnings\n\n# Some things must be caught at invokation time\ncreate function bug8408_f() returns int\nbegin\n  call bug8408_p();\n  return 0;\nend|\ncreate procedure bug8408_p()\n  select * from t1|\n\ncall bug8408_p()|\n--error ER_SP_NO_RETSET\nselect bug8408_f()|\n\ndrop procedure bug8408_p|\ndrop function bug8408_f|\n\n# But this is ok\ncreate function bug8408() returns int\nbegin\n  declare n int default 0;\n  select count(*) into n from t1;\n  return n;\nend|\n\ninsert into t1 value (2, 2.7), (3, 3.14), (7, 7.0)|\nselect *,bug8408() from t1|\n\ndrop function bug8408|\ntruncate table t1|\n\n\n#\n# BUG#10537: Server crashes while loading data file into table through\n#            procedure.\n# Disable load until it's PS and SP safe\n--disable_warnings\ndrop procedure if exists bug10537|\n--enable_warnings\n--error ER_SP_BADSTATEMENT\ncreate procedure bug10537()\n  load data local infile '/tmp/somefile' into table t1|\n\n\n#\n# BUG#8409: Stored procedure crash if function contains FLUSH\n#\n--disable_warnings\ndrop function if exists bug8409|\n--enable_warnings\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409()\n  returns int\nbegin\n  flush tables;\n  return 5;\nend|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset query cache;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset master;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset slave;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush hosts;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush privileges;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush tables with read lock;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush tables;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush logs;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush status;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush slave;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush master;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush des_key_file;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush user_resources;\nreturn 1; end|\n\n\n#\n# BUG#9529: Stored Procedures: No Warning on truncation of procedure name\n#           during creation.\n# BUG#17015: Routine name truncation not an error\n#            When we started using utf8 for mysql.proc, this limit appeared\n#            to be higher, but in reality the names were truncated.\n--error ER_TOO_LONG_IDENT\ncreate procedure bug9529_901234567890123456789012345678901234567890123456789012345()\nbegin\nend|\n\n--disable_warnings\ndrop procedure if exists bug17015_0123456789012345678901234567890123456789012345678901234|\n--enable_warnings\n# Check the upper limit, just to make sure.\ncreate procedure bug17015_0123456789012345678901234567890123456789012345678901234()\nbegin\nend|\n\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status like 'bug17015%'|\ndrop procedure bug17015_0123456789012345678901234567890123456789012345678901234|\n\n\n#\n# BUG#10969: Stored procedures: crash if default() function\n#\n--disable_warnings\ndrop procedure if exists bug10969|\n--enable_warnings\n--error ER_WRONG_COLUMN_NAME\ncreate procedure bug10969()\nbegin\n  declare s1 int default 0;\n  select default(s1) from t30;\nend|\n\n# This should work\ncreate procedure bug10969()\nbegin\n  declare s1 int default 0;\n  select default(t30.s1) from t30;\nend|\n\ndrop procedure bug10969|\n\n\ndrop table t1|\n\ndelimiter ;|\n\n# BUG#9814: Closing a cursor that is not open \ncreate table t1(f1 int);\ncreate table t2(f1 int);\n \ndelimiter |;\nCREATE PROCEDURE SP001()\nP1: BEGIN\n  DECLARE ENDTABLE INT DEFAULT 0;\n  DECLARE TEMP_NUM INT;\n  DECLARE TEMP_SUM INT;\n  DECLARE C1 CURSOR FOR SELECT F1 FROM t1;\n  DECLARE C2 CURSOR FOR SELECT F1 FROM t2;\n  DECLARE CONTINUE HANDLER FOR NOT FOUND SET ENDTABLE = 1;\n\n  SET ENDTABLE=0;\n  SET TEMP_SUM=0;\n  SET TEMP_NUM=0;\n  \n  OPEN C1;\n\n  FETCH C1 INTO TEMP_NUM;\n  WHILE ENDTABLE = 0 DO\n          SET TEMP_SUM=TEMP_NUM+TEMP_SUM;\n          FETCH C1 INTO TEMP_NUM;\n  END WHILE;\n  SELECT TEMP_SUM;\n  CLOSE C1;\n  CLOSE C1;\n  SELECT 'end of proc';\nEND P1|\ndelimiter ;|\n--error 1326\ncall SP001();\ndrop procedure SP001;\ndrop table t1, t2;\n\n# Bug #11394 \"Recursion in SP crash server\" and bug #11600 \"Stored\n# procedures: crash with function calling itself\".\n# We have to disable recursion since in many cases LEX and many\n# Item's can't be used in reentrant way nowdays.\ndelimiter |;\n--disable_warnings\ndrop function if exists bug11394|\ndrop function if exists bug11394_1|\ndrop function if exists bug11394_2|\ndrop procedure if exists bug11394|\n--enable_warnings\ncreate function bug11394(i int) returns int\nbegin\n  if i <= 0 then\n    return 0;\n  else\n    return (i in (100, 200, bug11394(i-1), 400));\n  end if;\nend|\n# If we allow recursive functions without additional modifications\n# this will crash server since Item for \"IN\" is not reenterable.\n--error 1424\nselect bug11394(2)|\ndrop function bug11394|\ncreate function bug11394_1(i int) returns int\nbegin\n  if i <= 0 then\n    return 0;\n  else\n    return (select bug11394_1(i-1));\n  end if;\nend|\n# The following statement will crash because some LEX members responsible\n# for selects cannot be used in reentrant fashion.\n--error 1424\nselect bug11394_1(2)|\ndrop function bug11394_1|\n# Note that the following should be allowed since it does not contains\n# recursion\ncreate function bug11394_2(i int) returns int return i|\nselect bug11394_2(bug11394_2(10))|\ndrop function bug11394_2|\ncreate procedure bug11394(i int, j int)\nbegin\n  if i > 0 then\n    call bug11394(i - 1,(select 1));\n  end if;\nend|\n--error ER_SP_RECURSION_LIMIT\ncall bug11394(2, 1)|\nset @@max_sp_recursion_depth=10|\ncall bug11394(2, 1)|\nset @@max_sp_recursion_depth=default|\ndrop procedure bug11394|\ndelimiter ;|\n\n\n#\n# BUG 12490 (Packets out of order if calling HELP CONTENTS from Stored Procedure)\n#\n--error ER_SP_BADSTATEMENT\nCREATE PROCEDURE BUG_12490() HELP CONTENTS;\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION BUG_12490() RETURNS INT HELP CONTENTS;\nCREATE TABLE t_bug_12490(a int);\n--error ER_SP_BADSTATEMENT\nCREATE TRIGGER BUG_12490 BEFORE UPDATE ON t_bug_12490 FOR EACH ROW HELP CONTENTS;\nDROP TABLE t_bug_12490;\n\n#\n# Bug#11834 \"Re-execution of prepared statement with dropped function\n# crashes server\". Also tests handling of prepared stmts which use\n# stored functions but does not require prelocking.\n#\n--disable_warnings\ndrop function if exists bug11834_1;\ndrop function if exists bug11834_2;\n--enable_warnings\ncreate function bug11834_1() returns int return 10;\ncreate function bug11834_2() returns int return bug11834_1();\nprepare stmt from \"select bug11834_2()\";\nexecute stmt;\n# Re-execution of statement should not crash server.\nexecute stmt;\ndrop function bug11834_1;\n# Attempt to execute statement should return proper error and \n# should not crash server.\n\n# NOTE! The error we get from the below query indicates that the sp bug11834_2\n# does not exist(this is wrong but can be accepted)\n# This behaviour has been reported as bug#21294\n--error ER_SP_DOES_NOT_EXIST\nexecute stmt;\ndeallocate prepare stmt;\ndrop function bug11834_2;\n\n#\n# Bug#12953 \"Stored procedures: crash if OPTIMIZE TABLE in function\"\n#\ndelimiter |;\n--disable_warnings\nDROP FUNCTION IF EXISTS bug12953|\n--enable_warnings\n--error ER_SP_NO_RETSET\nCREATE FUNCTION bug12953() RETURNS INT\nBEGIN\n  OPTIMIZE TABLE t1;\n  RETURN 1;\nEND|\ndelimiter ;|\n\n#\n# Bug##12995 \"Inside function \"Table 't4' was not locked with LOCK TABLES\"\n#\ndelimiter |;\n--disable_warnings\nDROP FUNCTION IF EXISTS bug12995|\n--enable_warnings\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 OPEN;\n  RETURN 1;\nEND|\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 READ FIRST;\n  RETURN 1;\nEND|\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 CLOSE;\n  RETURN 1;\nEND|\n--error 1305\nSELECT bug12995()|\ndelimiter ;|\n\n\n#\n# BUG#12712: SET AUTOCOMMIT should fail within SP/functions/triggers\n#\n--disable_warnings\ndrop procedure if exists bug12712;\ndrop function if exists bug12712;\n--enable_warnings\n# Can...\ncreate procedure bug12712()\n  set session autocommit = 0;\n\nselect @@autocommit;\nset @au = @@autocommit;\ncall bug12712();\nselect @@autocommit;\nset session autocommit = @au;\n\ndelimiter |;\ncreate function bug12712()\n  returns int\nbegin\n  call bug12712();\n  return 0;\nend|\n\n# Can't...\n--error ER_SP_CANT_SET_AUTOCOMMIT\nset @x = bug12712()|\ndrop procedure bug12712|\ndrop function bug12712|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set session autocommit = 0;\n  return 0;\nend|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set @@autocommit = 0;\n  return 0;\nend|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set local autocommit = 0;\n  return 0;\nend|\ndelimiter ;|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate trigger bug12712\n  before insert on t1 for each row set session autocommit = 0;\n\n#\n# BUG#9367: Stored procedures: client hang after \"show warnings\"\n#\n--disable_parsing\n--disable_warnings\ndrop procedure if exists bug9367;\n--enable_warnings\ncreate table t1 (s1 int);\nselect s1 from t1;\ndelimiter |;\ncreate procedure bug9367()\nbegin\n  declare v int;\n  declare c cursor for select s1 from t1;\n  open c;\n  show warnings;\n  fetch c into v;\n  select v;\nend|\ndelimiter ;|\ncall bug9367();\ndrop procedure bug9367;\ndrop table t1;\n--enable_parsing\n\n#\n# BUG#13510: Setting password local variable changes current password\n#\ndelimiter |;\n--disable_warnings\ndrop procedure if exists bug13510_1|\ndrop procedure if exists bug13510_2|\ndrop procedure if exists bug13510_3|\ndrop procedure if exists bug13510_4|\n--enable_warnings\n\n--error ER_SP_BAD_VAR_SHADOW\ncreate procedure bug13510_1()\nbegin\n  declare password varchar(10);\n\n  set password = 'foo1';\n  select password;\nend|\n\n# Check that an error message is sent\n--error ER_PARSE_ERROR\nset names='foo2'|\n\n--error ER_SP_BAD_VAR_SHADOW\ncreate procedure bug13510_2()\nbegin\n  declare names varchar(10);\n\n  set names = 'foo2';\n  select names;\nend|\n\ncreate procedure bug13510_3()\nbegin\n  declare password varchar(10);\n\n  set `password` = 'foo3';\n  select password;\nend|\n\ncreate procedure bug13510_4()\nbegin\n  declare names varchar(10);\n\n  set `names` = 'foo4';\n  select names;\nend|\n\ncall bug13510_3()|\ncall bug13510_4()|\n\ndrop procedure bug13510_3|\ndrop procedure bug13510_4|\n\n\n#\n# Test that statements which implicitly commit transaction are prohibited\n# in stored function and triggers. Attempt to create function or trigger\n# containing such statement should produce error (includes test for\n# bug #13627).\n#\n--disable_warnings\ndrop function if exists bug_13627_f|\n--enable_warnings\n\nCREATE TABLE t1 (a int)|\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DROP TRIGGER test1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN DROP TRIGGER test1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create table t2 (a int); END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create table t2 (a int); return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create index t1_i on t1 (a); END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create index t1_i on t1 (a); return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter table t1 add column  b int; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN alter table t1 add column  b int; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename table t1 to t2; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN rename table t1 to t2; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN truncate table t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN truncate table t1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop table t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop table t1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop index t1_i on t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop index t1_i on t1; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN unlock tables; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN unlock tables; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN LOCK TABLE t1 READ; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN LOCK TABLE t1 READ; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create database mysqltest; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create database mysqltest; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop database mysqltest; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop database mysqltest; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create user 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create user 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN grant select on t1 to 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN grant select on t1 to 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke select on t1 from 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN revoke select on t1 from 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke all privileges on *.* from 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN revoke all privileges on *.* from 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop user 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop user 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create view v1 as select 1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create view v1 as select 1; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter view v1 as select 1; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN alter view v1 as select 1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop view v1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop view v1; return 1; END |\n\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create trigger tr2 before insert on t1 for each row do select 1; END |\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE FUNCTION bug_13627_f() returns int BEGIN create trigger tr2 before insert on t1 for each row do select 1; return 1; END |\n\n-- error ER_SP_NO_DROP_SP\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop function bug_13627_f; END |\n-- error ER_SP_NO_DROP_SP\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop function bug_13627_f; return 1; END |\n\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create function f2 () returns int return 1; END |\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE FUNCTION bug_13627_f() returns int BEGIN create function f2 () returns int return 1; return 1; END |\n\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW\n  BEGIN\n    CREATE TEMPORARY TABLE t2 (a int);\n    DROP TEMPORARY TABLE t2;\n  END |\nCREATE FUNCTION bug_13627_f() returns int\n  BEGIN\n    CREATE TEMPORARY TABLE t2 (a int);\n    DROP TEMPORARY TABLE t2;\n    return 1;\n  END |\n\ndrop table t1|\ndrop function bug_13627_f|\n\ndelimiter ;|\n\n# BUG#12329: \"Bogus error msg when executing PS with stored procedure after\n# SP was re-created\". See also test for related bug#13399 in trigger.test\ndrop function if exists bug12329;\n--enable_warnings\ncreate table t1 as select 1 a;\ncreate table t2 as select 1 a;\ncreate function bug12329() returns int return (select a from t1);\nprepare stmt1 from 'select bug12329()';\nexecute stmt1;\ndrop function bug12329;\ncreate function bug12329() returns int return (select a+100 from t2);\nselect bug12329();\nexecute stmt1;\ndeallocate prepare stmt1;\ndrop function bug12329; \ndrop table t1, t2;\n\n#\n# Bug#13514 \"server crash when create a stored procedure before choose a\n# database\" and\n# Bug#13587 \"Server crash when SP is created without database\n# selected\"\n#\ncreate database mysqltest1;\nuse mysqltest1;\ndrop database mysqltest1;\n--error ER_NO_DB_ERROR \ncreate function f1() returns int return 1;\ndelimiter |;\n--error ER_NO_DB_ERROR \ncreate procedure p1(out param1 int)\nbegin\n  select count(*) into param1 from t3;\nend|\ndelimiter ;|\nuse test;\n\n\n#\n# BUG#13037: undefined variable in IF cause erroneous error-message\n#\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS bug13037_p1;\nDROP PROCEDURE IF EXISTS bug13037_p2;\nDROP PROCEDURE IF EXISTS bug13037_p3;\n--enable_warnings\n\ndelimiter |;\n\nCREATE PROCEDURE bug13037_p1()\nBEGIN\n  IF bug13037_foo THEN\n    SELECT 1;\n  END IF;\nEND|\n\nCREATE PROCEDURE bug13037_p2()\nBEGIN\n  SET @bug13037_foo = bug13037_bar;\nEND|\n\nCREATE PROCEDURE bug13037_p3()\nBEGIN\n  SELECT bug13037_foo;\nEND|\n\ndelimiter ;|\n\n--echo\n\n--error 1054\nCALL bug13037_p1();\n--error 1054\nCALL bug13037_p2();\n--error 1054\nCALL bug13037_p3();\n\n--error 1054\nCALL bug13037_p1();\n--error 1054\nCALL bug13037_p2();\n--error 1054\nCALL bug13037_p3();\n\nDROP PROCEDURE bug13037_p1;\nDROP PROCEDURE bug13037_p2;\nDROP PROCEDURE bug13037_p3;\n\n#\n# Bug#14569 \"editing a stored procedure kills mysqld-nt\"\n#\ncreate database mysqltest1;\ncreate database mysqltest2;\nuse mysqltest1;\ndrop database mysqltest1;\ncreate procedure mysqltest2.p1() select version();\n--error ER_NO_DB_ERROR \ncreate procedure p2() select version();\nuse mysqltest2;\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status;\ndrop database mysqltest2;\nuse test;\n\n#\n# Bug#13012 \"SP: REPAIR/BACKUP/RESTORE TABLE crashes the server\"\n#\ndelimiter |;\n--disable_warnings\nDROP FUNCTION IF EXISTS bug13012|\n--enable_warnings\n--error ER_SP_NO_RETSET\nCREATE FUNCTION bug13012() RETURNS INT\nBEGIN\n  REPAIR TABLE t1;\n  RETURN 1;\nEND|\ncreate table t1 (a int)|\nCREATE PROCEDURE bug13012_1() REPAIR TABLE t1|\nCREATE FUNCTION bug13012_2() RETURNS INT\nBEGIN\n  CALL bug13012_1();\n  RETURN 1;\nEND|\n--error ER_SP_NO_RETSET\nSELECT bug13012_2()|\ndrop table t1|\ndrop procedure bug13012_1|\ndrop function bug13012_2|\ndelimiter ;|\n\n#\n# BUG#11555 \"Stored procedures: current SP tables locking make \n# impossible view security\". We should not expose names of tables\n# which are implicitly used by view (via stored routines/triggers).\n#\n# Note that SQL standard assumes that you simply won't be able drop table\n# and leave some objects (routines/views/triggers) which were depending on\n# it. Such objects should be dropped in advance (by default) or will be\n# dropped simultaneously with table (DROP TABLE with CASCADE clause).\n# So these tests probably should go away once we will implement standard\n# behavior.\n--disable_warnings\ndrop function if exists bug11555_1;\ndrop function if exists bug11555_2;\ndrop view if exists v1, v2, v3, v4;\n--enable_warnings\ncreate function bug11555_1() returns int return (select max(i) from t1);\ncreate function bug11555_2() returns int return bug11555_1();\n# It is OK to report name of implicitly used table which is missing\n# when we create view.\n# For stored functions however, because of exceptions handlers, there is\n# no easy way to find out if a missing table makes the view invalid.\ncreate view v1 as select bug11555_1();\ndrop view v1;\ncreate view v2 as select bug11555_2();\ndrop view v2;\n# But we should hide name of missing implicitly used table when we use view\ncreate table t1 (i int);\ncreate view v1 as select bug11555_1();\ncreate view v2 as select bug11555_2();\ncreate view v3 as select * from v1;\ndrop table t1;\n--error ER_VIEW_INVALID\nselect * from v1;\n--error ER_VIEW_INVALID\nselect * from v2;\n--error ER_VIEW_INVALID\nselect * from v3;\n# Note that creation of view which depends on broken view is yet \n# another form of view usage.\ncreate view v4 as select * from v1;\ndrop view v1, v2, v3, v4;\n# We also should hide details about broken triggers which are\n# invoked for view.\ndrop function bug11555_1;\ndrop function bug11555_2;\ncreate table t1 (i int);\ncreate table t2 (i int);\ncreate trigger t1_ai after insert on t1 for each row insert into t2 values (new.i);\ncreate view v1 as select * from t1;\ndrop table t2;\n# Limitation, the desired error is ER_VIEW_INVALID\n--error ER_NO_SUCH_TABLE\ninsert into v1 values (1);\ndrop trigger t1_ai;\ncreate function bug11555_1() returns int return (select max(i) from t2);\ncreate trigger t1_ai after insert on t1 for each row set @a:=bug11555_1();\n# Limitation, the desired error is ER_VIEW_INVALID\n--error ER_NO_SUCH_TABLE \ninsert into v1 values (2);\ndrop function bug11555_1;\ndrop table t1;\ndrop view v1;\n\n#\n# BUG#15658: Server crashes after creating function as empty string\n#\n--disable_warnings\ndrop procedure if exists ` bug15658`;\n--enable_warnings\n\n--error ER_SP_WRONG_NAME\ncreate procedure ``() select 1;\n--error ER_SP_WRONG_NAME\ncreate procedure ` `() select 1;\n--error ER_SP_WRONG_NAME\ncreate procedure `bug15658 `() select 1;\n--error ER_WRONG_DB_NAME\ncreate procedure ``.bug15658() select 1;\n--error ER_WRONG_DB_NAME\ncreate procedure `x `.bug15658() select 1;\n\n# This should work\ncreate procedure ` bug15658`() select 1;\ncall ` bug15658`();\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status;\ndrop procedure ` bug15658`;\n\n\n#\n# BUG#14270: Stored procedures: crash if load index\n#\n--disable_warnings\ndrop function if exists bug14270;\ndrop table if exists t1;\n--enable_warnings\n\ncreate table t1 (s1 int primary key);\n\ndelimiter |;\n--error ER_SP_NO_RETSET\ncreate function bug14270() returns int\nbegin\n  load index into cache t1;\n  return 1;\nend|\n\n--error ER_SP_NO_RETSET\ncreate function bug14270() returns int\nbegin\n  cache index t1 key (`primary`) in keycache1;\n  return 1;\nend|\ndelimiter ;|\n\ndrop table t1;\n\n\n#\n# BUG#15091: Sp Returns Unknown error in order clause....and \n#            there is no order by clause\n#\n--disable_warnings\ndrop procedure if exists bug15091;\n--enable_warnings\n\ndelimiter |;\ncreate procedure bug15091()\nbegin\n  declare selectstr varchar(6000) default ' ';\n  declare conditionstr varchar(5000)  default '';\n\n  set selectstr = concat(selectstr,\n                         ' and ',\n                         c.operatorid,\n                         'in (',conditionstr, ')');\nend|\ndelimiter ;|\n\n# The error message used to be:\n#   ERROR 1109 (42S02): Unknown table 'c' in order clause\n# but is now rephrased to something less misleading:\n#   ERROR 1109 (42S02): Unknown table 'c' in field list\n--error ER_UNKNOWN_TABLE\ncall bug15091();\n\ndrop procedure bug15091;\n\n\n#\n# BUG#16896: Stored function: unused AGGREGATE-clause in CREATE FUNCTION\n#\n--disable_warnings\ndrop function if exists bug16896;\n--enable_warnings\n\n--error ER_PARSE_ERROR\ncreate aggregate function bug16896() returns int return 1;\n\n#\n#\n# BUG#14702: misleading error message when syntax error in CREATE\n# PROCEDURE\n#\n# Misleading error message was given when IF NOT EXISTS was used in\n# CREATE PROCEDURE.\n#\n--disable_warnings\nDROP PROCEDURE IF EXISTS bug14702;\n--enable_warnings\n\n--error ER_PARSE_ERROR\nCREATE IF NOT EXISTS PROCEDURE bug14702()\nBEGIN\nEND;\n\n--error ER_PARSE_ERROR\nCREATE PROCEDURE IF NOT EXISTS bug14702()\nBEGIN\nEND;\n\n\n#\n# BUG#20953: create proc with a create view that uses local\n# vars/params should fail to create\n#\n# See test case for what syntax is forbidden in a view.\n#\n--disable_warnings\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\nCREATE TABLE t1 (i INT);\n\n# We do not have to drop this procedure and view because they won't be\n# created.\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO @a;\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO DUMPFILE \"file\";\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO OUTFILE \"file\";\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953()\n  CREATE VIEW v AS SELECT i FROM t1 PROCEDURE ANALYSE();\n--error ER_VIEW_SELECT_DERIVED\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 FROM (SELECT 1) AS d1;\n--error ER_VIEW_SELECT_VARIABLE\nCREATE PROCEDURE bug20953(i INT) CREATE VIEW v AS SELECT i;\ndelimiter |;\n--error ER_VIEW_SELECT_VARIABLE\nCREATE PROCEDURE bug20953()\nBEGIN\n  DECLARE i INT;\n  CREATE VIEW v AS SELECT i;\nEND |\ndelimiter ;|\n--error ER_VIEW_SELECT_VARIABLE\nPREPARE stmt FROM \"CREATE VIEW v AS SELECT ?\";\n\nDROP TABLE t1;\n\n\n#\n# BUG#24491 \"using alias from source table in insert ... on duplicate key\"\n#\n--disable_warnings\ndrop tables if exists t1;\ndrop procedure if exists bug24491;\n--enable_warnings\ncreate table t1 (id int primary key auto_increment, value varchar(10));\ninsert into t1 (id, value) values (1, 'FIRST'), (2, 'SECOND'), (3, 'THIRD');\n# Let us create routine with INSERT ... SELECT ... ON DUPLICATE KEY UPDATE \n# statement which in its ON DUPLICATE KEY clause erroneously tries to assign\n# value to a column which is mentioned only in SELECT part.\ncreate procedure bug24491()\n  insert into t1 (id, value) select * from (select 4 as i, 'FOURTH' as v) as y on duplicate key update v = 'DUP';\n# Both first and second calls to it should fail\n--error ER_BAD_FIELD_ERROR \ncall bug24491();\n--error ER_BAD_FIELD_ERROR\ncall bug24491();\ndrop procedure bug24491;\n# And now the same test for more complex case which is more close\n# to the one that was reported originally.\ncreate procedure bug24491()\n  insert into t1 (id, value) select * from (select 4 as id, 'FOURTH' as value) as y on duplicate key update y.value = 'DUP';\n--error ER_BAD_FIELD_ERROR \ncall bug24491();\n--error ER_BAD_FIELD_ERROR\ncall bug24491();\ndrop procedure bug24491;\ndrop tables t1;\n\n#\n# BUG#18914: Calling certain SPs from triggers fail\n#\n# Failing to call a procedure that does implicit commit from a trigger\n# is a correct behaviour, however the error message was misleading.\n#\n# DROP TABLE IF EXISTS is also fixed to give correct error instead of\n# \"Table doesn't exist\". \n#\n--disable_warnings\nDROP FUNCTION IF EXISTS bug18914_f1;\nDROP FUNCTION IF EXISTS bug18914_f2;\nDROP PROCEDURE IF EXISTS bug18914_p1;\nDROP PROCEDURE IF EXISTS bug18914_p2;\nDROP TABLE IF EXISTS t1, t2;\n--enable_warnings\n\nCREATE TABLE t1 (i INT);\n\nCREATE PROCEDURE bug18914_p1() CREATE TABLE t2 (i INT);\nCREATE PROCEDURE bug18914_p2() DROP TABLE IF EXISTS no_such_table;\n\ndelimiter |;\nCREATE FUNCTION bug18914_f1() RETURNS INT\nBEGIN\n  CALL bug18914_p1();\n  RETURN 1;\nEND |\n\nCREATE FUNCTION bug18914_f2() RETURNS INT\nBEGIN\n  CALL bug18914_p2();\n  RETURN 1;\nEND |\ndelimiter ;|\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\n  CALL bug18914_p1();\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nINSERT INTO t1 VALUES (1);\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nSELECT bug18914_f1();\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nSELECT bug18914_f2();\n\n--error ER_NO_SUCH_TABLE\nSELECT * FROM t2;\n\nDROP FUNCTION bug18914_f1;\nDROP FUNCTION bug18914_f2;\nDROP PROCEDURE bug18914_p1;\nDROP PROCEDURE bug18914_p2;\nDROP TABLE t1;\n\n#\n# Bug#20713 (Functions will not not continue for SQLSTATE VALUE '42S02')\n#\n\n--disable_warnings\ndrop table if exists bogus_table_20713;\ndrop function if exists func_20713_a;\ndrop function if exists func_20713_b;\n--enable_warnings\n\ncreate table bogus_table_20713( id int(10) not null primary key);\ninsert into bogus_table_20713 values (1), (2), (3);\n\ndelimiter //;\n\ncreate function func_20713_a() returns int(11)\nbegin\n  declare id int;\n\n  declare continue handler for sqlexception set id=null;\n\n  set @in_func := 1;\n  set id = (select id from bogus_table_20713 where id = 3);\n  set @in_func := 2;\n\n  return id;\nend//\n\ncreate function func_20713_b() returns int(11)\nbegin\n  declare id int;\n\n  declare continue handler for sqlstate value '42S02' set id=null;\n\n  set @in_func := 1;\n  set id = (select id from bogus_table_20713 where id = 3);\n  set @in_func := 2;\n\n  return id;\nend//\n\ndelimiter ;//\n\nset @in_func := 0;\nselect func_20713_a();\nselect @in_func;\n\nset @in_func := 0;\nselect func_20713_b();\nselect @in_func;\n\ndrop table bogus_table_20713;\n\nset @in_func := 0;\nselect func_20713_a();\nselect @in_func;\n\nset @in_func := 0;\nselect func_20713_b();\nselect @in_func;\n\ndrop function if exists func_20713_a;\ndrop function if exists func_20713_b;\n\n#\n# Bug#25345 (Cursors from Functions)\n#\n\n--disable_warnings\ndrop table if exists table_25345_a;\ndrop table if exists table_25345_b;\ndrop procedure if exists proc_25345;\ndrop function if exists func_25345;\ndrop function if exists func_25345_b;\n--enable_warnings\n\ncreate table table_25345_a (a int);\ncreate table table_25345_b (b int);\n\ndelimiter ||;\n\ncreate procedure proc_25345()\nbegin\n  declare c1 cursor for select a from table_25345_a;\n  declare c2 cursor for select b from table_25345_b;\n\n  select 1 as result;\nend ||\n\ncreate function func_25345() returns int(11)\nbegin\n  call proc_25345();\n  return 1;\nend ||\n\ncreate function func_25345_b() returns int(11)\nbegin\n  declare c1 cursor for select a from table_25345_a;\n  declare c2 cursor for select b from table_25345_b;\n\n  return 1;\nend ||\n\ndelimiter ;||\n\ncall proc_25345();\n--error ER_SP_NO_RETSET\nselect func_25345();\nselect func_25345_b();\n\ndrop table table_25345_a;\n\ncall proc_25345();\n--error ER_SP_NO_RETSET\nselect func_25345();\nselect func_25345_b();\n\ndrop table table_25345_b;\ndrop procedure proc_25345;\ndrop function func_25345;\ndrop function func_25345_b;\n\n#\n# End of 5.0 tests\n#\n--echo End of 5.0 tests\n\n#\n# Bug#16164 \"Easter egg\": check that SHOW AUTHORS is disabled in\n# stored functions/triggers\n#\n--disable_warnings\ndrop function if exists bug16164;\n--enable_warnings\ndelimiter |;\n--error ER_SP_NO_RETSET\ncreate function bug16164() returns int\nbegin\n  show authors;\n  return 42;\nend|\ndelimiter ;|\n\n\n#\n# BUG#20701: BINARY keyword should be forbidden in stored routines\n#\n--disable_warnings\ndrop function if exists bug20701;\n--enable_warnings\n#\n# This was disabled in 5.1.12. See bug #20701\n# When collation support in SP is implemented, then this test should\n# be removed.\n#\n--error ER_NOT_SUPPORTED_YET\ncreate function bug20701() returns varchar(25) binary return \"test\";\ncreate function bug20701() returns varchar(25) return \"test\";\ndrop function bug20701;\n\n#\n# Bug#26503 (Illegal SQL exception handler code causes the server to crash)\n#\n\ndelimiter //;\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_1()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n      begin\n        iterate retry;\n      end\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_2()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n        iterate retry;\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_3()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n      begin\n        leave retry;\n      end\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_4()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n        leave retry;\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\ndelimiter ;//\n\n\n#\n# Bug#28360 (RENAME DATABASE destroys routines)\n#\n\n--disable_warnings\ndrop procedure if exists proc_28360;\ndrop function if exists func_28360;\n--enable_warnings\n\ndelimiter //;\n\n--error ER_SP_NO_DROP_SP\nCREATE PROCEDURE proc_28360()\nBEGIN\n  ALTER DATABASE `#mysql50#upgrade-me` UPGRADE DATA DIRECTORY NAME;\nEND//\n\n--error ER_SP_NO_DROP_SP\nCREATE FUNCTION func_28360() RETURNS int\nBEGIN\n  ALTER DATABASE `#mysql50#upgrade-me` UPGRADE DATA DIRECTORY NAME;\n  RETURN 0;\nEND//\n\ndelimiter ;//\n\n\n#\n# Bug#29223 declare cursor c for SHOW .....\n#\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n--delimiter |\n--error ER_PARSE_ERROR\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE c char(100);\n  DECLARE cur1 CURSOR FOR SHOW TABLES;\n\n  OPEN cur1;\n  FETCH cur1 INTO c;\n  select c;\n  CLOSE cur1;\nEND|\n--delimiter ;\n\n#\n# Bug#29816 Syntactically wrong query fails with misleading error message\n#\n\n--disable_warnings\nDROP DATABASE IF EXISTS mysqltest;\n--enable_warnings\nCREATE DATABASE mysqltest;\nUSE mysqltest;\nDROP DATABASE mysqltest;\n# Both ER_SP_DOES_NOT_EXIST and ER_PARSE_ERROR are valid here,\n# the result is implementation dependent:\n# See Bug#29816 for details\n--error ER_SP_DOES_NOT_EXIST\nSELECT inexistent(), 1 + ,;\n--error ER_SP_DOES_NOT_EXIST\nSELECT inexistent();\n--error ER_PARSE_ERROR\nSELECT .inexistent();\n--error ER_PARSE_ERROR\nSELECT ..inexistent();\nUSE test;\n\n#\n# Bug#30904 SET PASSWORD statement is non-transactional\n#\n\ndelimiter |;\n\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function f1() returns int\nbegin\n  set @test = 1, password = password('foo');\n  return 1;\nend|\n\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate trigger t1\n  before insert on t2 for each row set password = password('foo');|\n\ndelimiter ;|\n\n#\n# Bug#30882 Dropping a temporary table inside a stored function may cause a server crash\n#\n\n--disable_warnings\ndrop function if exists f1;\ndrop function if exists f2;\ndrop table if exists t1, t2;\n--enable_warnings\n\ndelimiter |;\ncreate function f1() returns int\nbegin\n drop temporary table t1;\n return 1;\nend|\ndelimiter ;|\n--error ER_CANT_REOPEN_TABLE\ncreate temporary table t1 as select f1();\n\ndelimiter |;\ncreate function f2() returns int\nbegin\n create temporary table t2 as select f1();\n return 1;\nend|\ndelimiter ;|\n--error ER_CANT_REOPEN_TABLE\ncreate temporary table t1 as select f2();\n\ndrop function f1;\ndrop function f2;\n\ndelimiter |;\ncreate function f1() returns int\nbegin\n drop temporary table t2,t1;\n return 1;\nend|\ncreate function f2() returns int\nbegin\n create temporary table t2 as select f1();\n return 1;\nend|\ndelimiter ;|\n--error ER_CANT_REOPEN_TABLE\ncreate temporary table t1 as select f2();\n\ndrop function f1;\ndrop function f2;\n\ncreate temporary table t2(a int);\nselect * from t2;\ndelimiter |;\ncreate function f2() returns int\nbegin\n drop temporary table t2;\n return 1;\nend|\ndelimiter ;|\nselect f2();\n\ndrop function f2;\n--error ER_BAD_TABLE_ERROR\ndrop table t2;\n\n--echo End of 5.1 tests\n\n#\n# Bug#33983 (Stored Procedures: wrong end <label> syntax is accepted)\n#\n\n--disable_warnings\ndrop procedure if exists proc_33983_a;\ndrop procedure if exists proc_33983_b;\ndrop procedure if exists proc_33983_c;\ndrop procedure if exists proc_33983_d;\n--enable_warnings\n\ndelimiter |;\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_a()\nbegin\n  label1:\n    begin\n      label2:\n      begin\n        select 1;\n      end label1;\n    end;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_b()\nbegin\n  label1:\n    repeat\n      label2:\n      repeat\n        select 1;\n      until FALSE end repeat label1;\n    until FALSE end repeat;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_c()\nbegin\n  label1:\n    while TRUE do\n      label2:\n      while TRUE do\n        select 1;\n      end while label1;\n    end while;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_d()\nbegin\n  label1:\n    loop\n      label2:\n      loop\n        select 1;\n      end loop label1;\n    end loop;\nend|\n\nCREATE TABLE t1 (a INT)|\nINSERT INTO t1 VALUES (1),(2)|\nCREATE PROCEDURE p1(a INT) BEGIN END|\n--error ER_SUBQUERY_NO_1_ROW\nCALL p1((SELECT * FROM t1))|\nDROP PROCEDURE IF EXISTS p1|\nDROP TABLE t1|\n\ndelimiter ;|\n\n#\n# Bug#21801: SQL exception handlers and warnings\n#\n\n--disable_warnings\ndrop procedure if exists p1;\n--enable_warnings\ndelimiter |;\ncreate procedure p1()\nbegin\n  create table t1 (a int) engine=MyISAM;\n  drop table t1;\nend|\ndelimiter ;|\ncall p1();\ncall p1();\ndrop procedure p1;\n\n#\n# Bug#8759 (Stored Procedures: SQLSTATE '00000' should be illegal)\n#\n\n--disable_warnings\ndrop procedure if exists proc_8759;\n--enable_warnings\n\ndelimiter $$;\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_8759()\nbegin\n  declare should_be_illegal condition for sqlstate '00000';\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_8759()\nbegin\n  declare continue handler for sqlstate '00000' set @x=0;\nend$$\n\ndelimiter ;$$\n\n#\n# Bug#36510 (Stored Procedures: mysql_error_code 0 should be illegal)\n#\n\n--disable_warnings\ndrop procedure if exists proc_36510;\n--enable_warnings\n\ndelimiter $$;\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_36510()\nbegin\n  declare should_be_illegal condition for sqlstate '00123';\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_36510()\nbegin\n  declare continue handler for sqlstate '00123' set @x=0;\nend$$\n\n--error ER_WRONG_VALUE\ncreate procedure proc_36510()\nbegin\n  declare should_be_illegal condition for 0;\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_WRONG_VALUE\ncreate procedure proc_36510()\nbegin\n  declare continue handler for 0 set @x=0;\nend$$\ndelimiter ;$$\n\n#\n# Bug#15192: \"fatal errors\" are caught by handlers in stored procedures\n#\n\n--disable_warnings\ndrop procedure if exists p1;\n--enable_warnings\nset @old_recursion_depth = @@max_sp_recursion_depth;\nset @@max_sp_recursion_depth = 255;\ndelimiter |;\ncreate procedure p1(a int)\nbegin\n  declare continue handler for 1436 -- ER_STACK_OVERRUN_NEED_MORE\n    select 'exception';\n  call p1(a+1);\nend|\ndelimiter ;|\n--error 0,ER_STACK_OVERRUN_NEED_MORE,ER_SP_RECURSION_LIMIT\ncall p1(1);\nset @@max_sp_recursion_depth = @old_recursion_depth;\ndrop procedure p1;\n\n#\n# BUG#NNNN: New bug synopsis\n#\n#--disable_warnings\n#drop procedure if exists bugNNNN;\n#drop function if exists bugNNNN;\n#--enable_warnings\n#create procedure bugNNNN...\n#create function bugNNNN...\n\n#\n# CLEANUP and RESTORE\n#\nLOAD DATA INFILE '../../tmp/proc.txt' INTO TABLE mysql.proc;\nremove_file $MYSQLTEST_VARDIR/tmp/proc.txt;\n\n#\n# Bug #38159: Function parsing problem generates misleading error message\n#\n\nCREATE TABLE t1 (a INT, b INT);\nINSERT INTO t1 VALUES (1,1), (2,2);\n--error ER_FUNC_INEXISTENT_NAME_COLLISION\nSELECT MAX (a) FROM t1 WHERE b = 999999;\nSELECT AVG (a) FROM t1 WHERE b = 999999;\n--error ER_SP_DOES_NOT_EXIST\nSELECT non_existent (a) FROM t1 WHERE b = 999999;\nDROP TABLE t1;\n\n\n#\n# Bug #46374 crash, INSERT INTO t1 uses function, function modifies t1\n#\nCREATE TABLE t1 ( f2 INTEGER, f3 INTEGER );\nINSERT INTO t1 VALUES  ( 1, 1 );\n\ndelimiter |;\n\nCREATE FUNCTION func_1 () RETURNS INTEGER\nBEGIN\n  INSERT INTO t1 SELECT * FROM t1 ;\n  RETURN 1 ;\nEND|\n\ndelimiter ;|\n\n# The bug caused the following INSERT statement to trigger\n# an assertion.   Error 1442 is the correct response\n#\n--error 1442\nINSERT INTO t1 SELECT * FROM (SELECT 2 AS f1, 2 AS f2) AS A WHERE func_1() = 5;\n\n# Cleanup\nDROP FUNCTION func_1;\nDROP TABLE t1;\n\n\n\n--echo #\n--echo # Bug #47788: Crash in TABLE_LIST::hide_view_error on UPDATE + VIEW + \n--echo #   SP + MERGE + ALTER\n--echo #\n\nCREATE TABLE t1 (pk INT, b INT, KEY (b));\nCREATE ALGORITHM = TEMPTABLE VIEW v1 AS SELECT * FROM t1;\n\nCREATE PROCEDURE p1 (a int) UPDATE IGNORE v1 SET b = a; \n\n--error ER_NON_UPDATABLE_TABLE\nCALL p1(5);\n\nALTER TABLE t1 CHANGE COLUMN b b2 INT;\n\n--error ER_VIEW_INVALID\nCALL p1(7);\n\nDROP PROCEDURE p1;\nDROP VIEW v1;\nDROP TABLE t1;\n\n--echo #\n--echo # Bug#12428824 - PARSER STACK OVERFLOW AND CRASH IN SP_ADD_USED_ROUTINE\n--echo #                WITH OBSCURE QUERY\n--echo #\n\n--error ER_TOO_LONG_IDENT\nSELECT very_long_fn_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();\n\n--error ER_TOO_LONG_IDENT\nCALL very_long_pr_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();\n\n--error ER_WRONG_DB_NAME\nSELECT very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_func();\n\n--error ER_WRONG_DB_NAME\nCALL very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_proc();\n\n--error ER_TOO_LONG_IDENT\nSELECT db_name.very_long_fn_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();\n\n--error ER_TOO_LONG_IDENT\nCALL db_name.very_long_pr_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();\n--echo End of 5.1 tests\n\n--echo #\n--echo # Bug#23032: Handlers declared in a SP do not handle warnings generated in sub-SP\n--echo #\n\n--echo\n--echo # - Case 1\n--echo\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\nDROP PROCEDURE IF EXISTS p3;\nDROP PROCEDURE IF EXISTS p4;\nDROP PROCEDURE IF EXISTS p5;\nDROP PROCEDURE IF EXISTS p6;\n--enable_warnings\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    SELECT 1;\n    CALL p2();\n  END|\n\nCREATE PROCEDURE p2()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n  END|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\n\n--echo\n--echo # - Case 2\n--echo\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\n  BEGIN\n    DECLARE c INT DEFAULT 0;\n    DECLARE CONTINUE HANDLER FOR SQLWARNING SET c = c + 1;\n    CALL p2();\n    CALL p3();\n    CALL p4();\n    SELECT c;\n    SELECT @@warning_count;\n    SHOW WARNINGS;\n  END|\n\nCREATE PROCEDURE p2()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n  END|\n\nCREATE PROCEDURE p3()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    SELECT 1;\n  END|\n\nCREATE PROCEDURE p4()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    CALL p2();\n  END|\n\nCREATE PROCEDURE p5()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    SHOW WARNINGS;\n  END|\n\nCREATE PROCEDURE P6()\n  BEGIN\n    DECLARE c INT DEFAULT 0;\n    DECLARE CONTINUE HANDLER FOR SQLWARNING SET c = c + 1;\n    CALL p5();\n    SELECT c;\n  END|\n\ndelimiter ;|\n\nCALL p1();\nCALL p6();\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\n\n--echo\n--echo # - Case 3: check that \"Exception trumps No Data\".\n--echo\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\nCREATE TABLE t1(a INT);\nINSERT INTO t1 VALUES (1), (2), (3);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE c CURSOR FOR SELECT a FROM t1;\n\n  OPEN c;\n  \n  BEGIN\n    DECLARE v1 INT;\n    DECLARE v2 INT;\n\n    DECLARE EXIT HANDLER FOR SQLEXCEPTION\n      SELECT \"Error caught (expected)\";\n\n    DECLARE EXIT HANDLER FOR NOT FOUND\n      SELECT \"End of Result Set found!\";\n\n    WHILE TRUE DO\n      FETCH c INTO v1, v2;\n    END WHILE;\n  END;\n\n  CLOSE c;\n\n  SELECT a INTO @foo FROM t1 LIMIT 1; # Clear warning stack\nEND|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP PROCEDURE p1;\nDROP TABLE t1;\n\n--echo #\n--echo # Bug#36185: Incorrect precedence for warning and exception handlers\n--echo #\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n\nCREATE TABLE t1 (a INT, b INT NOT NULL);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'warning';\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'exception';\n  INSERT INTO t1 VALUES (CAST('10 ' AS SIGNED), NULL);\nEND|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP TABLE t1;\nDROP PROCEDURE p1;\n\n--echo #\n--echo # Bug#5889: Exit handler for a warning doesn't hide the warning in trigger\n--echo #\n\nCREATE TABLE t1(a INT, b INT);\nINSERT INTO t1 VALUES (1, 2);\n\ndelimiter |;\n\nCREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROW\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING\n    SET NEW.a = 10;\n\n  SET NEW.a = 99999999999;\nEND|\n\ndelimiter ;|\n\nUPDATE t1 SET b = 20;\n\nSHOW WARNINGS;\n\nSELECT * FROM t1;\n\nDROP TRIGGER t1_bu;\nDROP TABLE t1;\n\n--echo #\n--echo # Bug#9857: Stored procedures: handler for sqlwarning ignored\n--echo #\n\nSET @sql_mode_saved = @@sql_mode;\nSET sql_mode = traditional;\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'warning caught (expected)';\n  \n  SELECT 5 / 0;\nEND|\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'error caught (unexpected)';\n  \n  SELECT 5 / 0;\nEND|\n\ndelimiter ;|\n\nCALL p1();\nSHOW WARNINGS;\n\nCALL p2();\nSHOW WARNINGS;\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nSET sql_mode = @sql_mode_saved;\n\n--echo #\n--echo # Bug#55850: Trigger warnings not cleared.\n--echo #\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP TABLE IF EXISTS t2;\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n\nCREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT,\n                d SMALLINT, e SMALLINT, f SMALLINT);\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\n  INSERT INTO t2(a, b, c) VALUES(99999, 99999, 99999);\n\nCREATE TRIGGER t1_ai AFTER INSERT ON t1 FOR EACH ROW\n  INSERT INTO t2(d, e, f) VALUES(99999, 99999, 99999);\n\nCREATE PROCEDURE p1()\n  INSERT INTO t1 VALUES(99999, 99999, 99999);\n\n# What happened before the patch was:\n#  - INSERT INTO t1 added 3 warnings about overflow in 'x', 'y' and 'z' columns;\n#  - t1_bi run and added 3 warnings about overflow in 'a', 'b' and 'c' columns;\n#  - t1_ai run and added 3 warnings about overflow in 'd', 'e' and 'f' columns;\n# => we had 9 warnings.\n#\n# Now what happens is:\n#  - INSERT INTO t1 adds 3 warnings about overflow in 'x', 'y' and 'z' columns;\n#  - t1_bi adds 3 warnings about overflow in 'a', 'b' and 'c' columns;\n#  - The warnings added by triggers are cleared;\n#  - t1_ai run and added 3 warnings about overflow in 'd', 'e' and 'f' columns;\n#  - The warnings added by triggers are cleared;\n# => we have 3 warnings.\n\n--echo\nCALL p1();\n\n--echo\nSHOW WARNINGS;\n\n--echo\nDROP TABLE t1;\nDROP TABLE t2;\nDROP PROCEDURE p1;\n\n--echo # ----------------------------------------------------------------------\n\nCREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT NOT NULL);\n\ndelimiter |;\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\nBEGIN\n  INSERT INTO t2 VALUES(\n    CAST('111111 ' AS SIGNED),\n    CAST('222222 ' AS SIGNED),\n    NULL);\nEND|\n\ndelimiter ;|\n\nCREATE PROCEDURE p1()\n  INSERT INTO t1 VALUES(99999, 99999, 99999);\n\n--echo\n--error ER_BAD_NULL_ERROR\nCALL p1();\n\n--echo\nSHOW WARNINGS;\n\n--echo\nDROP TABLE t1;\nDROP TABLE t2;\nDROP PROCEDURE p1;\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql/mysqld.cc": "/* Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights\n   reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */\n\n#include \"my_global.h\"                          /* NO_EMBEDDED_ACCESS_CHECKS */\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include <signal.h>\n#ifndef __WIN__\n#include <netdb.h>        // getservbyname, servent\n#endif\n#include \"sql_parse.h\"    // test_if_data_home_dir\n#include \"sql_cache.h\"    // query_cache, query_cache_*\n#include \"sql_locale.h\"   // MY_LOCALES, my_locales, my_locale_by_name\n#include \"sql_show.h\"     // free_status_vars, add_status_vars,\n                          // reset_status_vars\n#include \"strfunc.h\"      // find_set_from_flags\n#include \"parse_file.h\"   // File_parser_dummy_hook\n#include \"sql_db.h\"       // my_dboptions_cache_free\n                          // my_dboptions_cache_init\n#include \"sql_table.h\"    // release_ddl_log, execute_ddl_log_recovery\n#include \"sql_connect.h\"  // free_max_user_conn, init_max_user_conn,\n                          // handle_one_connection\n#include \"sql_time.h\"     // known_date_time_formats,\n                          // get_date_time_format_str,\n                          // date_time_format_make\n#include \"tztime.h\"       // my_tz_free, my_tz_init, my_tz_SYSTEM\n#include \"hostname.h\"     // hostname_cache_free, hostname_cache_init\n#include \"sql_acl.h\"      // acl_free, grant_free, acl_init,\n                          // grant_init\n#include \"sql_base.h\"     // table_def_free, table_def_init,\n                          // cached_open_tables,\n                          // cached_table_definitions\n#include \"sql_test.h\"     // mysql_print_status\n#include \"item_create.h\"  // item_create_cleanup, item_create_init\n#include \"sql_servers.h\"  // servers_free, servers_init\n#include \"init.h\"         // unireg_init\n#include \"derror.h\"       // init_errmessage\n#include \"derror.h\"       // init_errmessage\n#include \"des_key_file.h\" // load_des_key_file\n#include \"sql_manager.h\"  // stop_handle_manager, start_handle_manager\n#include <m_ctype.h>\n#include <my_dir.h>\n#include <my_bit.h>\n#include \"slave.h\"\n#include \"rpl_mi.h\"\n#include \"sql_repl.h\"\n#include \"rpl_filter.h\"\n#include \"repl_failsafe.h\"\n#include <sql_common.h>\n#include <my_stacktrace.h>\n#include \"mysqld_suffix.h\"\n#include \"mysys_err.h\"\n#include \"events.h\"\n#include \"sql_audit.h\"\n#include \"probes_mysql.h\"\n#include \"scheduler.h\"\n#include \"debug_sync.h\"\n#include \"sql_callback.h\"\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"../storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#include \"keycaches.h\"\n#include \"../storage/myisam/ha_myisam.h\"\n#include \"set_var.h\"\n\n#include \"rpl_injector.h\"\n\n#include \"rpl_handler.h\"\n\n#ifdef HAVE_SYS_PRCTL_H\n#include <sys/prctl.h>\n#endif\n\n#include <thr_alarm.h>\n#include <ft_global.h>\n#include <errmsg.h>\n#include \"sp_rcontext.h\"\n#include \"sp_cache.h\"\n#include \"sql_reload.h\"  // reload_acl_and_cache\n\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n\n#define mysqld_charset &my_charset_latin1\n\n/* We have HAVE_purify below as this speeds up the shutdown of MySQL */\n\n#if defined(HAVE_DEC_3_2_THREADS) || defined(SIGNALS_DONT_BREAK_READ) || defined(HAVE_purify) && defined(__linux__)\n#define HAVE_CLOSE_SERVER_SOCK 1\n#endif\n\nextern \"C\" {\t\t\t\t\t// Because of SCO 3.2V4.2\n#include <errno.h>\n#include <sys/stat.h>\n#ifndef __GNU_LIBRARY__\n#define __GNU_LIBRARY__\t\t\t\t// Skip warnings in getopt.h\n#endif\n#include <my_getopt.h>\n#ifdef HAVE_SYSENT_H\n#include <sysent.h>\n#endif\n#ifdef HAVE_PWD_H\n#include <pwd.h>\t\t\t\t// For getpwent\n#endif\n#ifdef HAVE_GRP_H\n#include <grp.h>\n#endif\n#include <my_net.h>\n\n#if !defined(__WIN__)\n#include <sys/resource.h>\n#ifdef HAVE_SYS_UN_H\n#include <sys/un.h>\n#endif\n#ifdef HAVE_SELECT_H\n#include <select.h>\n#endif\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <sys/utsname.h>\n#endif /* __WIN__ */\n\n#include <my_libwrap.h>\n\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n\n#ifdef __WIN__ \n#include <crtdbg.h>\n#endif\n\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#include <sys/mman.h>\n#if defined(__sun__) && defined(__GNUC__) && defined(__cplusplus) \\\n    && defined(_XOPEN_SOURCE)\nextern int getpagesizes(size_t *, int);\nextern int getpagesizes2(size_t *, int);\nextern int memcntl(caddr_t, size_t, int, caddr_t, int, int);\n#endif /* __sun__ ... */\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n#ifdef _AIX41\nint initgroups(const char *,unsigned int);\n#endif\n\n#if defined(__FreeBSD__) && defined(HAVE_IEEEFP_H) && !defined(HAVE_FEDISABLEEXCEPT)\n#include <ieeefp.h>\n#ifdef HAVE_FP_EXCEPT\t\t\t\t// Fix type conflict\ntypedef fp_except fp_except_t;\n#endif\n#endif /* __FreeBSD__ && HAVE_IEEEFP_H && !HAVE_FEDISABLEEXCEPT */\n#ifdef HAVE_SYS_FPU_H\n/* for IRIX to use set_fpc_csr() */\n#include <sys/fpu.h>\n#endif\n#ifdef HAVE_FPU_CONTROL_H\n#include <fpu_control.h>\n#endif\n#if defined(__i386__) && !defined(HAVE_FPU_CONTROL_H)\n# define fpu_control_t unsigned int\n# define _FPU_EXTENDED 0x300\n# define _FPU_DOUBLE 0x200\n# if defined(__GNUC__) || (defined(__SUNPRO_CC) && __SUNPRO_CC >= 0x590)\n#  define _FPU_GETCW(cw) asm volatile (\"fnstcw %0\" : \"=m\" (*&cw))\n#  define _FPU_SETCW(cw) asm volatile (\"fldcw %0\" : : \"m\" (*&cw))\n# else\n#  define _FPU_GETCW(cw) (cw= 0)\n#  define _FPU_SETCW(cw)\n# endif\n#endif\n\nextern \"C\" my_bool reopen_fstreams(const char *filename,\n                                   FILE *outstream, FILE *errstream);\n\ninline void setup_fpu()\n{\n#if defined(__FreeBSD__) && defined(HAVE_IEEEFP_H) && !defined(HAVE_FEDISABLEEXCEPT)\n  /* We can't handle floating point exceptions with threads, so disable\n     this on freebsd\n     Don't fall for overflow, underflow,divide-by-zero or loss of precision.\n     fpsetmask() is deprecated in favor of fedisableexcept() in C99.\n  */\n#if defined(FP_X_DNML)\n  fpsetmask(~(FP_X_INV | FP_X_DNML | FP_X_OFL | FP_X_UFL | FP_X_DZ |\n\t      FP_X_IMP));\n#else\n  fpsetmask(~(FP_X_INV |             FP_X_OFL | FP_X_UFL | FP_X_DZ |\n              FP_X_IMP));\n#endif /* FP_X_DNML */\n#endif /* __FreeBSD__ && HAVE_IEEEFP_H && !HAVE_FEDISABLEEXCEPT */\n\n#ifdef HAVE_FEDISABLEEXCEPT\n  fedisableexcept(FE_ALL_EXCEPT);\n#endif\n\n#ifdef HAVE_FESETROUND\n    /* Set FPU rounding mode to \"round-to-nearest\" */\n  fesetround(FE_TONEAREST);\n#endif /* HAVE_FESETROUND */\n\n  /*\n    x86 (32-bit) requires FPU precision to be explicitly set to 64 bit\n    (double precision) for portable results of floating point operations.\n    However, there is no need to do so if compiler is using SSE2 for floating\n    point, double values will be stored and processed in 64 bits anyway.\n  */\n#if defined(__i386__) && !defined(__SSE2_MATH__)\n#if defined(_WIN32)\n#if !defined(_WIN64)\n  _control87(_PC_53, MCW_PC);\n#endif /* !_WIN64 */\n#else /* !_WIN32 */\n  fpu_control_t cw;\n  _FPU_GETCW(cw);\n  cw= (cw & ~_FPU_EXTENDED) | _FPU_DOUBLE;\n  _FPU_SETCW(cw);\n#endif /* _WIN32 && */\n#endif /* __i386__ */\n\n#if defined(__sgi) && defined(HAVE_SYS_FPU_H)\n  /* Enable denormalized DOUBLE values support for IRIX */\n  union fpc_csr n;\n  n.fc_word = get_fpc_csr();\n  n.fc_struct.flush = 0;\n  set_fpc_csr(n.fc_word);\n#endif\n}\n\n} /* cplusplus */\n\n#define MYSQL_KILL_SIGNAL SIGTERM\n\n#include <my_pthread.h>\t\t\t// For thr_setconcurency()\n\n#ifdef SOLARIS\nextern \"C\" int gethostname(char *name, int namelen);\n#endif\n\nextern \"C\" sig_handler handle_fatal_signal(int sig);\n\n#if defined(__linux__)\n#define ENABLE_TEMP_POOL 1\n#else\n#define ENABLE_TEMP_POOL 0\n#endif\n\n/* Constants */\n\n#include <welcome_copyright_notice.h> // ORACLE_WELCOME_COPYRIGHT_NOTICE\n\nconst char *show_comp_option_name[]= {\"YES\", \"NO\", \"DISABLED\"};\n\nstatic const char *tc_heuristic_recover_names[]=\n{\n  \"COMMIT\", \"ROLLBACK\", NullS\n};\nstatic TYPELIB tc_heuristic_recover_typelib=\n{\n  array_elements(tc_heuristic_recover_names)-1,\"\",\n  tc_heuristic_recover_names, NULL\n};\n\nconst char *first_keyword= \"first\", *binary_keyword= \"BINARY\";\nconst char *my_localhost= \"localhost\", *delayed_user= \"DELAYED\";\n\nbool opt_large_files= sizeof(my_off_t) > 4;\nstatic my_bool opt_autocommit; ///< for --autocommit command-line option\n\n/*\n  Used with --help for detailed option\n*/\nstatic my_bool opt_help= 0, opt_verbose= 0;\n\narg_cmp_func Arg_comparator::comparator_matrix[5][2] =\n{{&Arg_comparator::compare_string,     &Arg_comparator::compare_e_string},\n {&Arg_comparator::compare_real,       &Arg_comparator::compare_e_real},\n {&Arg_comparator::compare_int_signed, &Arg_comparator::compare_e_int},\n {&Arg_comparator::compare_row,        &Arg_comparator::compare_e_row},\n {&Arg_comparator::compare_decimal,    &Arg_comparator::compare_e_decimal}};\n\n/* static variables */\n\n#ifdef HAVE_PSI_INTERFACE\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\nstatic PSI_thread_key key_thread_handle_con_namedpipes;\nstatic PSI_cond_key key_COND_handler_count;\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if defined(HAVE_SMEM) && !defined(EMBEDDED_LIBRARY)\nstatic PSI_thread_key key_thread_handle_con_sharedmem;\n#endif /* HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\nstatic PSI_thread_key key_thread_handle_con_sockets;\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#ifdef __WIN__\nstatic PSI_thread_key key_thread_handle_shutdown;\n#endif /* __WIN__ */\n\n#if defined (HAVE_OPENSSL) && !defined(HAVE_YASSL)\nstatic PSI_rwlock_key key_rwlock_openssl;\n#endif\n#endif /* HAVE_PSI_INTERFACE */\n\n#ifdef HAVE_NPTL\nvolatile sig_atomic_t ld_assume_kernel_is_set= 0;\n#endif\n\n/* the default log output is log tables */\nstatic bool lower_case_table_names_used= 0;\nstatic bool max_long_data_size_used= false;\nstatic bool volatile select_thread_in_use, signal_thread_in_use;\n/* See Bug#56666 and Bug#56760 */;\nvolatile bool ready_to_exit;\nstatic my_bool opt_debugging= 0, opt_external_locking= 0, opt_console= 0;\nstatic my_bool opt_short_log_format= 0;\nstatic uint kill_cached_threads, wake_thread;\nstatic ulong killed_threads;\n       ulong max_used_connections;\nstatic volatile ulong cached_thread_count= 0;\nstatic char *mysqld_user, *mysqld_chroot;\nstatic char *default_character_set_name;\nstatic char *character_set_filesystem_name;\nstatic char *lc_messages;\nstatic char *lc_time_names_name;\nstatic char *my_bind_addr_str;\nstatic char *default_collation_name;\nchar *default_storage_engine;\nstatic char compiled_default_collation_name[]= MYSQL_DEFAULT_COLLATION_NAME;\nstatic I_List<THD> thread_cache;\nstatic bool binlog_format_used= false;\n\nLEX_STRING opt_init_connect, opt_init_slave;\n\nstatic mysql_cond_t COND_thread_cache, COND_flush_thread_cache;\n\n/* Global variables */\n\nbool opt_bin_log, opt_ignore_builtin_innodb= 0;\nmy_bool opt_log, opt_slow_log;\nulonglong log_output_options;\nmy_bool opt_log_queries_not_using_indexes= 0;\nbool opt_error_log= IF_WIN(1,0);\nbool opt_disable_networking=0, opt_skip_show_db=0;\nbool opt_skip_name_resolve=0;\nmy_bool opt_character_set_client_handshake= 1;\nbool server_id_supplied = 0;\nbool opt_endinfo, using_udf_functions;\nmy_bool locked_in_memory;\nbool opt_using_transactions;\nbool volatile abort_loop;\nbool volatile shutdown_in_progress;\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\nulong slow_start_timeout;\n#endif\n/*\n  True if the bootstrap thread is running. Protected by LOCK_thread_count,\n  just like thread_count.\n  Used in bootstrap() function to determine if the bootstrap thread\n  has completed. Note, that we can't use 'thread_count' instead,\n  since in 5.1, in presence of the Event Scheduler, there may be\n  event threads running in parallel, so it's impossible to know\n  what value of 'thread_count' is a sign of completion of the\n  bootstrap thread.\n\n  At the same time, we can't start the event scheduler after\n  bootstrap either, since we want to be able to process event-related\n  SQL commands in the init file and in --bootstrap mode.\n*/\nbool in_bootstrap= FALSE;\n/**\n   @brief 'grant_option' is used to indicate if privileges needs\n   to be checked, in which case the lock, LOCK_grant, is used\n   to protect access to the grant table.\n   @note This flag is dropped in 5.1 \n   @see grant_init()\n */\nbool volatile grant_option;\n\nmy_bool opt_skip_slave_start = 0; ///< If set, slave is not autostarted\nmy_bool opt_reckless_slave = 0;\nmy_bool opt_enable_named_pipe= 0;\nmy_bool opt_local_infile, opt_slave_compressed_protocol;\nmy_bool opt_safe_user_create = 0;\nmy_bool opt_show_slave_auth_info;\nmy_bool opt_log_slave_updates= 0;\nchar *opt_slave_skip_errors;\n\n/**\n  compatibility option:\n    - index usage hints (USE INDEX without a FOR clause) behave as in 5.0\n*/\nmy_bool old_mode;\n\n/*\n  Legacy global handlerton. These will be removed (please do not add more).\n*/\nhandlerton *heap_hton;\nhandlerton *myisam_hton;\nhandlerton *partition_hton;\n\nmy_bool read_only= 0, opt_readonly= 0;\nmy_bool use_temp_pool, relay_log_purge;\nmy_bool relay_log_recovery;\nmy_bool opt_sync_frm, opt_allow_suspicious_udfs;\nmy_bool opt_secure_auth= 0;\nchar* opt_secure_file_priv;\nmy_bool opt_log_slow_admin_statements= 0;\nmy_bool opt_log_slow_slave_statements= 0;\nmy_bool lower_case_file_system= 0;\nmy_bool opt_large_pages= 0;\nmy_bool opt_super_large_pages= 0;\nmy_bool opt_myisam_use_mmap= 0;\nuint   opt_large_page_size= 0;\n#if defined(ENABLED_DEBUG_SYNC)\nMYSQL_PLUGIN_IMPORT uint    opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\nmy_bool opt_old_style_user_limits= 0, trust_function_creators= 0;\n/*\n  True if there is at least one per-hour limit for some user, so we should\n  check them before each query (and possibly reset counters when hour is\n  changed). False otherwise.\n*/\nvolatile bool mqh_used = 0;\nmy_bool opt_noacl;\nmy_bool sp_automatic_privileges= 1;\n\nulong opt_binlog_rows_event_max_size;\nconst char *binlog_format_names[]= {\"MIXED\", \"STATEMENT\", \"ROW\", NullS};\n#ifdef HAVE_INITGROUPS\nvolatile sig_atomic_t calling_initgroups= 0; /**< Used in SIGSEGV handler. */\n#endif\nuint mysqld_port, test_flags, select_errors, dropping_tables, ha_open_options;\nuint mysqld_port_timeout;\nulong delay_key_write_options;\nuint protocol_version;\nuint lower_case_table_names;\nulong tc_heuristic_recover= 0;\nuint volatile thread_count;\nint32 thread_running;\nulong thread_created;\nulong back_log, connect_timeout, concurrency, server_id;\nulong table_cache_size, table_def_size;\nulong what_to_log;\nulong slow_launch_time, slave_open_temp_tables;\nulong open_files_limit, max_binlog_size, max_relay_log_size;\nulong slave_trans_retries;\nuint  slave_net_timeout;\nulong slave_exec_mode_options;\nulonglong slave_type_conversions_options;\nulong thread_cache_size=0;\nulong binlog_cache_size=0;\nulonglong  max_binlog_cache_size=0;\nulong slave_max_allowed_packet= 0;\nulong binlog_stmt_cache_size=0;\nulonglong  max_binlog_stmt_cache_size=0;\nulong query_cache_size=0;\nulong refresh_version;  /* Increments on each reload */\nquery_id_t global_query_id;\nmy_atomic_rwlock_t global_query_id_lock;\nmy_atomic_rwlock_t thread_running_lock;\nulong aborted_threads, aborted_connects;\nulong delayed_insert_timeout, delayed_insert_limit, delayed_queue_size;\nulong delayed_insert_threads, delayed_insert_writes, delayed_rows_in_use;\nulong delayed_insert_errors,flush_time;\nulong specialflag=0;\nulong binlog_cache_use= 0, binlog_cache_disk_use= 0;\nulong binlog_stmt_cache_use= 0, binlog_stmt_cache_disk_use= 0;\nulong max_connections, max_connect_errors;\n/*\n  Maximum length of parameter value which can be set through\n  mysql_send_long_data() call.\n*/\nulong max_long_data_size;\n/**\n  Limit of the total number of prepared statements in the server.\n  Is necessary to protect the server against out-of-memory attacks.\n*/\nulong max_prepared_stmt_count;\n/**\n  Current total number of prepared statements in the server. This number\n  is exact, and therefore may not be equal to the difference between\n  `com_stmt_prepare' and `com_stmt_close' (global status variables), as\n  the latter ones account for all registered attempts to prepare\n  a statement (including unsuccessful ones).  Prepared statements are\n  currently connection-local: if the same SQL query text is prepared in\n  two different connections, this counts as two distinct prepared\n  statements.\n*/\nulong prepared_stmt_count=0;\nulong thread_id=1L,current_pid;\nulong slow_launch_threads = 0;\nuint sync_binlog_period= 0, sync_relaylog_period= 0,\n     sync_relayloginfo_period= 0, sync_masterinfo_period= 0;\nulong expire_logs_days = 0;\nulong rpl_recovery_rank=0;\n/**\n  Soft upper limit for number of sp_head objects that can be stored\n  in the sp_cache for one connection.\n*/\nulong stored_program_cache_size= 0;\n\nconst double log_10[] = {\n  1e000, 1e001, 1e002, 1e003, 1e004, 1e005, 1e006, 1e007, 1e008, 1e009,\n  1e010, 1e011, 1e012, 1e013, 1e014, 1e015, 1e016, 1e017, 1e018, 1e019,\n  1e020, 1e021, 1e022, 1e023, 1e024, 1e025, 1e026, 1e027, 1e028, 1e029,\n  1e030, 1e031, 1e032, 1e033, 1e034, 1e035, 1e036, 1e037, 1e038, 1e039,\n  1e040, 1e041, 1e042, 1e043, 1e044, 1e045, 1e046, 1e047, 1e048, 1e049,\n  1e050, 1e051, 1e052, 1e053, 1e054, 1e055, 1e056, 1e057, 1e058, 1e059,\n  1e060, 1e061, 1e062, 1e063, 1e064, 1e065, 1e066, 1e067, 1e068, 1e069,\n  1e070, 1e071, 1e072, 1e073, 1e074, 1e075, 1e076, 1e077, 1e078, 1e079,\n  1e080, 1e081, 1e082, 1e083, 1e084, 1e085, 1e086, 1e087, 1e088, 1e089,\n  1e090, 1e091, 1e092, 1e093, 1e094, 1e095, 1e096, 1e097, 1e098, 1e099,\n  1e100, 1e101, 1e102, 1e103, 1e104, 1e105, 1e106, 1e107, 1e108, 1e109,\n  1e110, 1e111, 1e112, 1e113, 1e114, 1e115, 1e116, 1e117, 1e118, 1e119,\n  1e120, 1e121, 1e122, 1e123, 1e124, 1e125, 1e126, 1e127, 1e128, 1e129,\n  1e130, 1e131, 1e132, 1e133, 1e134, 1e135, 1e136, 1e137, 1e138, 1e139,\n  1e140, 1e141, 1e142, 1e143, 1e144, 1e145, 1e146, 1e147, 1e148, 1e149,\n  1e150, 1e151, 1e152, 1e153, 1e154, 1e155, 1e156, 1e157, 1e158, 1e159,\n  1e160, 1e161, 1e162, 1e163, 1e164, 1e165, 1e166, 1e167, 1e168, 1e169,\n  1e170, 1e171, 1e172, 1e173, 1e174, 1e175, 1e176, 1e177, 1e178, 1e179,\n  1e180, 1e181, 1e182, 1e183, 1e184, 1e185, 1e186, 1e187, 1e188, 1e189,\n  1e190, 1e191, 1e192, 1e193, 1e194, 1e195, 1e196, 1e197, 1e198, 1e199,\n  1e200, 1e201, 1e202, 1e203, 1e204, 1e205, 1e206, 1e207, 1e208, 1e209,\n  1e210, 1e211, 1e212, 1e213, 1e214, 1e215, 1e216, 1e217, 1e218, 1e219,\n  1e220, 1e221, 1e222, 1e223, 1e224, 1e225, 1e226, 1e227, 1e228, 1e229,\n  1e230, 1e231, 1e232, 1e233, 1e234, 1e235, 1e236, 1e237, 1e238, 1e239,\n  1e240, 1e241, 1e242, 1e243, 1e244, 1e245, 1e246, 1e247, 1e248, 1e249,\n  1e250, 1e251, 1e252, 1e253, 1e254, 1e255, 1e256, 1e257, 1e258, 1e259,\n  1e260, 1e261, 1e262, 1e263, 1e264, 1e265, 1e266, 1e267, 1e268, 1e269,\n  1e270, 1e271, 1e272, 1e273, 1e274, 1e275, 1e276, 1e277, 1e278, 1e279,\n  1e280, 1e281, 1e282, 1e283, 1e284, 1e285, 1e286, 1e287, 1e288, 1e289,\n  1e290, 1e291, 1e292, 1e293, 1e294, 1e295, 1e296, 1e297, 1e298, 1e299,\n  1e300, 1e301, 1e302, 1e303, 1e304, 1e305, 1e306, 1e307, 1e308\n};\n\ntime_t server_start_time, flush_status_time;\n\nchar mysql_home[FN_REFLEN], pidfile_name[FN_REFLEN], system_time_zone[30];\nchar default_logfile_name[FN_REFLEN];\nchar *default_tz_name;\nchar log_error_file[FN_REFLEN], glob_hostname[FN_REFLEN];\nchar mysql_real_data_home[FN_REFLEN],\n     lc_messages_dir[FN_REFLEN], reg_ext[FN_EXTLEN],\n     mysql_charsets_dir[FN_REFLEN],\n     *opt_init_file, *opt_tc_log_file;\nchar *lc_messages_dir_ptr, *log_error_file_ptr;\nchar mysql_unpacked_real_data_home[FN_REFLEN];\nint mysql_unpacked_real_data_home_len;\nuint mysql_real_data_home_len, mysql_data_home_len= 1;\nuint reg_ext_length;\nconst key_map key_map_empty(0);\nkey_map key_map_full(0);                        // Will be initialized later\nchar secure_file_real_path[FN_REFLEN];\n\nDATE_TIME_FORMAT global_date_format, global_datetime_format, global_time_format;\nTime_zone *default_tz;\n\nchar *mysql_data_home= const_cast<char*>(\".\");\nconst char *mysql_real_data_home_ptr= mysql_real_data_home;\nchar server_version[SERVER_VERSION_LENGTH];\nchar *mysqld_unix_port, *opt_mysql_tmpdir;\nulong thread_handling;\n\n/** name of reference on left expression in rewritten IN subquery */\nconst char *in_left_expr_name= \"<left expr>\";\n/** name of additional condition */\nconst char *in_additional_cond= \"<IN COND>\";\nconst char *in_having_cond= \"<IN HAVING>\";\n\nmy_decimal decimal_zero;\n/* classes for comparation parsing/processing */\nEq_creator eq_creator;\nNe_creator ne_creator;\nGt_creator gt_creator;\nLt_creator lt_creator;\nGe_creator ge_creator;\nLe_creator le_creator;\n\nMYSQL_FILE *bootstrap_file;\nint bootstrap_error;\n\nI_List<THD> threads;\nRpl_filter* rpl_filter;\nRpl_filter* binlog_filter;\n\nTHD *first_global_thread()\n{\n  if (threads.is_empty())\n    return NULL;\n  return threads.head();\n}\n\nTHD *next_global_thread(THD *thd)\n{\n  if (threads.is_last(thd))\n    return NULL;\n  struct ilink *next= thd->next;\n  return static_cast<THD*>(next);\n}\n\nstruct system_variables global_system_variables;\nstruct system_variables max_system_variables;\nstruct system_status_var global_status_var;\n\nMY_TMPDIR mysql_tmpdir_list;\nMY_BITMAP temp_pool;\n\nCHARSET_INFO *system_charset_info, *files_charset_info ;\nCHARSET_INFO *national_charset_info, *table_alias_charset;\nCHARSET_INFO *character_set_filesystem;\nCHARSET_INFO *error_message_charset_info;\n\nMY_LOCALE *my_default_lc_messages;\nMY_LOCALE *my_default_lc_time_names;\n\nSHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen, have_query_cache;\nSHOW_COMP_OPTION have_geometry, have_rtree_keys;\nSHOW_COMP_OPTION have_crypt, have_compress;\nSHOW_COMP_OPTION have_profiling;\n\n/* Thread specific variables */\n\npthread_key(MEM_ROOT**,THR_MALLOC);\npthread_key(THD*, THR_THD);\nmysql_mutex_t LOCK_thread_created;\nmysql_mutex_t LOCK_thread_count, LOCK_thd_remove;\nmysql_mutex_t\n  LOCK_status, LOCK_error_log, LOCK_uuid_generator,\n  LOCK_delayed_insert, LOCK_delayed_status, LOCK_delayed_create,\n  LOCK_crypt,\n  LOCK_global_system_variables,\n  LOCK_user_conn, LOCK_slave_list, LOCK_active_mi,\n  LOCK_connection_count, LOCK_error_messages;\n/**\n  The below lock protects access to two global server variables:\n  max_prepared_stmt_count and prepared_stmt_count. These variables\n  set the limit and hold the current total number of prepared statements\n  in the server, respectively. As PREPARE/DEALLOCATE rate in a loaded\n  server may be fairly high, we need a dedicated lock.\n*/\nmysql_mutex_t LOCK_prepared_stmt_count;\n#ifdef HAVE_OPENSSL\nmysql_mutex_t LOCK_des_key_file;\n#endif\nmysql_rwlock_t LOCK_grant, LOCK_sys_init_connect, LOCK_sys_init_slave;\nmysql_rwlock_t LOCK_system_variables_hash;\nmysql_cond_t COND_thread_count;\npthread_t signal_thread;\npthread_attr_t connection_attrib;\nmysql_mutex_t LOCK_server_started;\nmysql_cond_t COND_server_started;\n\nint mysqld_server_started= 0;\n\nFile_parser_dummy_hook file_parser_dummy_hook;\n\n/* replication parameters, if master_host is not NULL, we are a slave */\nuint report_port= 0;\nulong master_retry_count=0;\nchar *master_info_file;\nchar *relay_log_info_file, *report_user, *report_password, *report_host;\nchar *opt_relay_logname = 0, *opt_relaylog_index_name=0;\nchar *opt_logname, *opt_slow_logname, *opt_bin_logname;\n\n/* Static variables */\n\nstatic volatile sig_atomic_t kill_in_progress;\n\n\nstatic my_bool opt_bootstrap, opt_myisam_log;\nstatic int cleanup_done;\nstatic ulong opt_specialflag;\nstatic char *opt_update_logname, *opt_binlog_index_name;\nchar *mysql_home_ptr, *pidfile_name_ptr;\n/** Initial command line arguments (count), after load_defaults().*/\nstatic int defaults_argc;\n/**\n  Initial command line arguments (arguments), after load_defaults().\n  This memory is allocated by @c load_defaults() and should be freed\n  using @c free_defaults().\n  Do not modify defaults_argc / defaults_argv,\n  use remaining_argc / remaining_argv instead to parse the command\n  line arguments in multiple steps.\n*/\nstatic char **defaults_argv;\n/** Remaining command line arguments (count), filtered by handle_options().*/\nstatic int remaining_argc;\n/** Remaining command line arguments (arguments), filtered by handle_options().*/\nstatic char **remaining_argv;\n\nint orig_argc;\nchar **orig_argv;\n\n/*\n  Since buffered_option_error_reporter is only used currently\n  for parsing performance schema options, this code is not needed\n  when the performance schema is not compiled in.\n*/\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n/**\n  A log message for the error log, buffered in memory.\n  Log messages are temporarily buffered when generated before the error log\n  is initialized, and then printed once the error log is ready.\n*/\nclass Buffered_log : public Sql_alloc\n{\npublic:\n  Buffered_log(enum loglevel level, const char *message);\n\n  ~Buffered_log()\n  {}\n\n  void print(void);\n\nprivate:\n  /** Log message level. */\n  enum loglevel m_level;\n  /** Log message text. */\n  String m_message;\n};\n\n/**\n  Constructor.\n  @param level          the message log level\n  @param message        the message text\n*/\nBuffered_log::Buffered_log(enum loglevel level, const char *message)\n  : m_level(level), m_message()\n{\n  m_message.copy(message, strlen(message), &my_charset_latin1);\n}\n\n/**\n  Print a buffered log to the real log file.\n*/\nvoid Buffered_log::print()\n{\n  /*\n    Since messages are buffered, they can be printed out\n    of order with other entries in the log.\n    Add \"Buffered xxx\" to the message text to prevent confusion.\n  */\n  switch(m_level)\n  {\n  case ERROR_LEVEL:\n    sql_print_error(\"Buffered error: %s\\n\", m_message.c_ptr_safe());\n    break;\n  case WARNING_LEVEL:\n    sql_print_warning(\"Buffered warning: %s\\n\", m_message.c_ptr_safe());\n    break;\n  case INFORMATION_LEVEL:\n    /*\n      Messages printed as \"information\" still end up in the mysqld *error* log,\n      but with a [Note] tag instead of an [ERROR] tag.\n      While this is probably fine for a human reading the log,\n      it is upsetting existing automated scripts used to parse logs,\n      because such scripts are likely to not already handle [Note] properly.\n      INFORMATION_LEVEL messages are simply silenced, on purpose,\n      to avoid un needed verbosity.\n    */\n    break;\n  }\n}\n\n/**\n  Collection of all the buffered log messages.\n*/\nclass Buffered_logs\n{\npublic:\n  Buffered_logs()\n  {}\n\n  ~Buffered_logs()\n  {}\n\n  void init();\n  void cleanup();\n\n  void buffer(enum loglevel m_level, const char *msg);\n  void print();\nprivate:\n  /**\n    Memory root to use to store buffered logs.\n    This memory root lifespan is between init and cleanup.\n    Once the buffered logs are printed, they are not needed anymore,\n    and all the memory used is reclaimed.\n  */\n  MEM_ROOT m_root;\n  /** List of buffered log messages. */\n  List<Buffered_log> m_list;\n};\n\nvoid Buffered_logs::init()\n{\n  init_alloc_root(&m_root, 1024, 0);\n}\n\nvoid Buffered_logs::cleanup()\n{\n  m_list.delete_elements();\n  free_root(&m_root, MYF(0));\n}\n\n/**\n  Add a log message to the buffer.\n*/\nvoid Buffered_logs::buffer(enum loglevel level, const char *msg)\n{\n  /*\n    Do not let Sql_alloc::operator new(size_t) allocate memory,\n    there is no memory root associated with the main() thread.\n    Give explicitly the proper memory root to use to\n    Sql_alloc::operator new(size_t, MEM_ROOT *) instead.\n  */\n  Buffered_log *log= new (&m_root) Buffered_log(level, msg);\n  if (log)\n    m_list.push_back(log, &m_root);\n}\n\n/**\n  Print buffered log messages.\n*/\nvoid Buffered_logs::print()\n{\n  Buffered_log *log;\n  List_iterator_fast<Buffered_log> it(m_list);\n  while ((log= it++))\n    log->print();\n}\n\n/** Logs reported before a logger is available. */\nstatic Buffered_logs buffered_logs;\n\n#ifndef EMBEDDED_LIBRARY\n/**\n  Error reporter that buffer log messages.\n  @param level          log message level\n  @param format         log message format string\n*/\nC_MODE_START\nstatic void buffered_option_error_reporter(enum loglevel level,\n                                           const char *format, ...)\n{\n  va_list args;\n  char buffer[1024];\n\n  va_start(args, format);\n  my_vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n  buffered_logs.buffer(level, buffer);\n}\nC_MODE_END\n#endif /* !EMBEDDED_LIBRARY */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\nstatic my_socket unix_sock,ip_sock;\nstruct rand_struct sql_rand; ///< used by sql_class.cc:THD::THD()\n\n#ifndef EMBEDDED_LIBRARY\nstruct passwd *user_info;\nstatic pthread_t select_thread;\nstatic uint thr_kill_signal;\n#endif\n\n/* OS specific variables */\n\n#ifdef __WIN__\n#undef\t getpid\n#include <process.h>\n\nstatic mysql_cond_t COND_handler_count;\nstatic uint handler_count;\nstatic bool start_mode=0, use_opt_args;\nstatic int opt_argc;\nstatic char **opt_argv;\n\n#if !defined(EMBEDDED_LIBRARY)\nstatic HANDLE hEventShutdown;\nstatic char shutdown_event_name[40];\n#include \"nt_servc.h\"\nstatic\t NTService  Service;\t      ///< Service object for WinNT\n#endif /* EMBEDDED_LIBRARY */\n#endif /* __WIN__ */\n\n#ifdef _WIN32\nstatic char pipe_name[512];\nstatic SECURITY_ATTRIBUTES saPipeSecurity;\nstatic SECURITY_DESCRIPTOR sdPipeDescriptor;\nstatic HANDLE hPipe = INVALID_HANDLE_VALUE;\n#endif\n\n#ifndef EMBEDDED_LIBRARY\nbool mysqld_embedded=0;\n#else\nbool mysqld_embedded=1;\n#endif\n\nstatic my_bool plugins_are_initialized= FALSE;\n\n#ifndef DBUG_OFF\nstatic const char* default_dbug_option;\n#endif\n#ifdef HAVE_LIBWRAP\nconst char *libwrapName= NULL;\nint allow_severity = LOG_INFO;\nint deny_severity = LOG_WARNING;\n#endif\n#ifdef HAVE_QUERY_CACHE\nulong query_cache_min_res_unit= QUERY_CACHE_MIN_RESULT_DATA_SIZE;\nQuery_cache query_cache;\n#endif\n#ifdef HAVE_SMEM\nchar *shared_memory_base_name= default_shared_memory_base_name;\nmy_bool opt_enable_shared_memory;\nHANDLE smem_event_connect_request= 0;\n#endif\n\nmy_bool opt_use_ssl  = 0;\nchar *opt_ssl_ca= NULL, *opt_ssl_capath= NULL, *opt_ssl_cert= NULL,\n     *opt_ssl_cipher= NULL, *opt_ssl_key= NULL;\n\n#ifdef HAVE_OPENSSL\n#include <openssl/crypto.h>\n#ifndef HAVE_YASSL\ntypedef struct CRYPTO_dynlock_value\n{\n  mysql_rwlock_t lock;\n} openssl_lock_t;\n\nstatic openssl_lock_t *openssl_stdlocks;\nstatic openssl_lock_t *openssl_dynlock_create(const char *, int);\nstatic void openssl_dynlock_destroy(openssl_lock_t *, const char *, int);\nstatic void openssl_lock_function(int, int, const char *, int);\nstatic void openssl_lock(int, openssl_lock_t *, const char *, int);\nstatic unsigned long openssl_id_function();\n#endif\nchar *des_key_file;\n#ifndef EMBEDDED_LIBRARY\nstruct st_VioSSLFd *ssl_acceptor_fd;\n#endif\n#endif /* HAVE_OPENSSL */\n\n/**\n  Number of currently active user connections. The variable is protected by\n  LOCK_connection_count.\n*/\nuint connection_count= 0;\n\n/* Function declarations */\n\npthread_handler_t signal_hand(void *arg);\nstatic int mysql_init_variables(void);\nstatic int get_options(int *argc_ptr, char ***argv_ptr);\nstatic bool add_terminator(DYNAMIC_ARRAY *options);\nextern \"C\" my_bool mysqld_get_one_option(int, const struct my_option *, char *);\nstatic void set_server_version(void);\nstatic int init_thread_environment();\nstatic char *get_relative_path(const char *path);\nstatic int fix_paths(void);\nvoid handle_connections_sockets();\n#ifdef _WIN32\npthread_handler_t handle_connections_sockets_thread(void *arg);\n#endif\npthread_handler_t kill_server_thread(void *arg);\nstatic void bootstrap(MYSQL_FILE *file);\nstatic bool read_init_file(char *file_name);\n#ifdef _WIN32\npthread_handler_t handle_connections_namedpipes(void *arg);\n#endif\n#ifdef HAVE_SMEM\npthread_handler_t handle_connections_shared_memory(void *arg);\n#endif\npthread_handler_t handle_slave(void *arg);\nstatic void clean_up(bool print_message);\nstatic int test_if_case_insensitive(const char *dir_name);\n\n#ifndef EMBEDDED_LIBRARY\nstatic bool pid_file_created= false;\nstatic void usage(void);\nstatic void start_signal_handler(void);\nstatic void close_server_sock();\nstatic void clean_up_mutexes(void);\nstatic void wait_for_signal_thread_to_end(void);\nstatic void create_pid_file();\nstatic void mysqld_exit(int exit_code) __attribute__((noreturn));\n#endif\nstatic void delete_pid_file(myf flags);\nstatic void end_ssl();\n\n\n#ifndef EMBEDDED_LIBRARY\n/****************************************************************************\n** Code to end mysqld\n****************************************************************************/\n\nstatic void close_connections(void)\n{\n#ifdef EXTRA_DEBUG\n  int count=0;\n#endif\n  DBUG_ENTER(\"close_connections\");\n\n  /* Clear thread cache */\n  kill_cached_threads++;\n  flush_thread_cache();\n\n  /* kill connection thread */\n#if !defined(__WIN__)\n  DBUG_PRINT(\"quit\", (\"waiting for select thread: 0x%lx\",\n                      (ulong) select_thread));\n  mysql_mutex_lock(&LOCK_thread_count);\n\n  while (select_thread_in_use)\n  {\n    struct timespec abstime;\n    int error;\n    LINT_INIT(error);\n    DBUG_PRINT(\"info\",(\"Waiting for select thread\"));\n\n#ifndef DONT_USE_THR_ALARM\n    if (pthread_kill(select_thread, thr_client_alarm))\n      break;\t\t\t\t\t// allready dead\n#endif\n    set_timespec(abstime, 2);\n    for (uint tmp=0 ; tmp < 10 && select_thread_in_use; tmp++)\n    {\n      error= mysql_cond_timedwait(&COND_thread_count, &LOCK_thread_count,\n                                  &abstime);\n      if (error != EINTR)\n\tbreak;\n    }\n#ifdef EXTRA_DEBUG\n    if (error != 0 && !count++)\n      sql_print_error(\"Got error %d from mysql_cond_timedwait\", error);\n#endif\n    close_server_sock();\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n#endif /* __WIN__ */\n\n\n  /* Abort listening to new connections */\n  DBUG_PRINT(\"quit\",(\"Closing sockets\"));\n  if (!opt_disable_networking )\n  {\n    if (ip_sock != INVALID_SOCKET)\n    {\n      (void) mysql_socket_shutdown(ip_sock, SHUT_RDWR);\n      (void) closesocket(ip_sock);\n      ip_sock= INVALID_SOCKET;\n    }\n  }\n#ifdef _WIN32\n  if (hPipe != INVALID_HANDLE_VALUE && opt_enable_named_pipe)\n  {\n    HANDLE temp;\n    DBUG_PRINT(\"quit\", (\"Closing named pipes\") );\n\n    /* Create connection to the handle named pipe handler to break the loop */\n    if ((temp = CreateFile(pipe_name,\n\t\t\t   GENERIC_READ | GENERIC_WRITE,\n\t\t\t   0,\n\t\t\t   NULL,\n\t\t\t   OPEN_EXISTING,\n\t\t\t   0,\n\t\t\t   NULL )) != INVALID_HANDLE_VALUE)\n    {\n      WaitNamedPipe(pipe_name, 1000);\n      DWORD dwMode = PIPE_READMODE_BYTE | PIPE_WAIT;\n      SetNamedPipeHandleState(temp, &dwMode, NULL, NULL);\n      CancelIo(temp);\n      DisconnectNamedPipe(temp);\n      CloseHandle(temp);\n    }\n  }\n#endif\n#ifdef HAVE_SYS_UN_H\n  if (unix_sock != INVALID_SOCKET)\n  {\n    (void) mysql_socket_shutdown(unix_sock, SHUT_RDWR);\n    (void) closesocket(unix_sock);\n    (void) unlink(mysqld_unix_port);\n    unix_sock= INVALID_SOCKET;\n  }\n#endif\n  end_thr_alarm(0);\t\t\t // Abort old alarms.\n\n  /*\n    First signal all threads that it's time to die\n    This will give the threads some time to gracefully abort their\n    statements and inform their clients that the server is about to die.\n  */\n\n  THD *tmp;\n  mysql_mutex_lock(&LOCK_thread_count); // For unlink from list\n\n  I_List_iterator<THD> it(threads);\n  while ((tmp=it++))\n  {\n    DBUG_PRINT(\"quit\",(\"Informing thread %ld that it's time to die\",\n\t\t       tmp->thread_id));\n    /* We skip slave threads & scheduler on this first loop through. */\n    if (tmp->slave_thread)\n      continue;\n\n    tmp->killed= THD::KILL_CONNECTION;\n    MYSQL_CALLBACK(thread_scheduler, post_kill_notification, (tmp));\n    mysql_mutex_lock(&tmp->LOCK_thd_data);\n    if (tmp->mysys_var)\n    {\n      tmp->mysys_var->abort=1;\n      mysql_mutex_lock(&tmp->mysys_var->mutex);\n      if (tmp->mysys_var->current_cond)\n      {\n        mysql_mutex_lock(tmp->mysys_var->current_mutex);\n        mysql_cond_broadcast(tmp->mysys_var->current_cond);\n        mysql_mutex_unlock(tmp->mysys_var->current_mutex);\n      }\n      mysql_mutex_unlock(&tmp->mysys_var->mutex);\n    }\n    mysql_mutex_unlock(&tmp->LOCK_thd_data);\n  }\n  mysql_mutex_unlock(&LOCK_thread_count); // For unlink from list\n\n  Events::deinit();\n  end_slave();\n\n  if (thread_count)\n    sleep(2);\t\t\t\t\t// Give threads time to die\n\n  /*\n    Force remaining threads to die by closing the connection to the client\n    This will ensure that threads that are waiting for a command from the\n    client on a blocking read call are aborted.\n  */\n\n  for (;;)\n  {\n    DBUG_PRINT(\"quit\",(\"Locking LOCK_thread_count\"));\n    mysql_mutex_lock(&LOCK_thread_count); // For unlink from list\n    if (!(tmp=threads.get()))\n    {\n      DBUG_PRINT(\"quit\",(\"Unlocking LOCK_thread_count\"));\n      mysql_mutex_unlock(&LOCK_thread_count);\n      break;\n    }\n#ifndef __bsdi__\t\t\t\t// Bug in BSDI kernel\n    if (tmp->vio_ok())\n    {\n      if (global_system_variables.log_warnings)\n        sql_print_warning(ER_DEFAULT(ER_FORCING_CLOSE),my_progname,\n                          tmp->thread_id,\n                          (tmp->main_security_ctx.user ?\n                           tmp->main_security_ctx.user : \"\"));\n      close_connection(tmp);\n    }\n#endif\n    DBUG_PRINT(\"quit\",(\"Unlocking LOCK_thread_count\"));\n    mysql_mutex_unlock(&LOCK_thread_count);\n  }\n  /* All threads has now been aborted */\n  DBUG_PRINT(\"quit\",(\"Waiting for threads to die (count=%u)\",thread_count));\n  mysql_mutex_lock(&LOCK_thread_count);\n  while (thread_count)\n  {\n    mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n    DBUG_PRINT(\"quit\",(\"One thread died (count=%u)\",thread_count));\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  close_active_mi();\n  DBUG_PRINT(\"quit\",(\"close_connections thread\"));\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void close_server_sock()\n{\n#ifdef HAVE_CLOSE_SERVER_SOCK\n  DBUG_ENTER(\"close_server_sock\");\n  my_socket tmp_sock;\n  tmp_sock=ip_sock;\n  if (tmp_sock != INVALID_SOCKET)\n  {\n    ip_sock=INVALID_SOCKET;\n    DBUG_PRINT(\"info\",(\"calling shutdown on TCP/IP socket\"));\n    (void) mysql_socket_shutdown(tmp_sock, SHUT_RDWR);\n  }\n  tmp_sock=unix_sock;\n  if (tmp_sock != INVALID_SOCKET)\n  {\n    unix_sock=INVALID_SOCKET;\n    DBUG_PRINT(\"info\",(\"calling shutdown on unix socket\"));\n    (void) mysql_socket_shutdown(tmp_sock, SHUT_RDWR);\n    (void) unlink(mysqld_unix_port);\n  }\n  DBUG_VOID_RETURN;\n#endif\n}\n\n#endif /*EMBEDDED_LIBRARY*/\n\n\nvoid kill_mysql(void)\n{\n  DBUG_ENTER(\"kill_mysql\");\n\n#if defined(SIGNALS_DONT_BREAK_READ) && !defined(EMBEDDED_LIBRARY)\n  abort_loop=1;\t\t\t\t\t// Break connection loops\n  close_server_sock();\t\t\t\t// Force accept to wake up\n#endif\n\n#if defined(__WIN__)\n#if !defined(EMBEDDED_LIBRARY)\n  {\n    if (!SetEvent(hEventShutdown))\n    {\n      DBUG_PRINT(\"error\",(\"Got error: %ld from SetEvent\",GetLastError()));\n    }\n    /*\n      or:\n      HANDLE hEvent=OpenEvent(0, FALSE, \"MySqlShutdown\");\n      SetEvent(hEventShutdown);\n      CloseHandle(hEvent);\n    */\n  }\n#endif\n#elif defined(HAVE_PTHREAD_KILL)\n  if (pthread_kill(signal_thread, MYSQL_KILL_SIGNAL))\n  {\n    DBUG_PRINT(\"error\",(\"Got error %d from pthread_kill\",errno)); /* purecov: inspected */\n  }\n#elif !defined(SIGNALS_DONT_BREAK_READ)\n  kill(current_pid, MYSQL_KILL_SIGNAL);\n#endif\n  DBUG_PRINT(\"quit\",(\"After pthread_kill\"));\n  shutdown_in_progress=1;\t\t\t// Safety if kill didn't work\n#ifdef SIGNALS_DONT_BREAK_READ\n  if (!kill_in_progress)\n  {\n    pthread_t tmp;\n    int error;\n    abort_loop=1;\n    if ((error= mysql_thread_create(0, /* Not instrumented */\n                                    &tmp, &connection_attrib,\n                                    kill_server_thread, (void*) 0)))\n      sql_print_error(\"Can't create thread to kill server (errno= %d).\", error);\n  }\n#endif\n  DBUG_VOID_RETURN;\n}\n\n/**\n  Force server down. Kill all connections and threads and exit.\n\n  @param  sig_ptr       Signal number that caused kill_server to be called.\n\n  @note\n    A signal number of 0 mean that the function was not called\n    from a signal handler and there is thus no signal to block\n    or stop, we just want to kill the server.\n*/\n\n#if !defined(__WIN__)\nstatic void *kill_server(void *sig_ptr)\n#define RETURN_FROM_KILL_SERVER return 0\n#else\nstatic void __cdecl kill_server(int sig_ptr)\n#define RETURN_FROM_KILL_SERVER return\n#endif\n{\n  DBUG_ENTER(\"kill_server\");\n#ifndef EMBEDDED_LIBRARY\n  int sig=(int) (long) sig_ptr;\t\t\t// This is passed a int\n  // if there is a signal during the kill in progress, ignore the other\n  if (kill_in_progress)\t\t\t\t// Safety\n  {\n    DBUG_LEAVE;\n    RETURN_FROM_KILL_SERVER;\n  }\n  kill_in_progress=TRUE;\n  abort_loop=1;\t\t\t\t\t// This should be set\n  if (sig != 0) // 0 is not a valid signal number\n    my_sigset(sig, SIG_IGN);                    /* purify inspected */\n  if (sig == MYSQL_KILL_SIGNAL || sig == 0)\n    sql_print_information(ER_DEFAULT(ER_NORMAL_SHUTDOWN),my_progname);\n  else\n    sql_print_error(ER_DEFAULT(ER_GOT_SIGNAL),my_progname,sig); /* purecov: inspected */\n\n#if defined(HAVE_SMEM) && defined(__WIN__)    \n  /*    \n   Send event to smem_event_connect_request for aborting    \n   */    \n  if (opt_enable_shared_memory)\n  {\n    if (!SetEvent(smem_event_connect_request))    \n    {      \n      DBUG_PRINT(\"error\",\n                 (\"Got error: %ld from SetEvent of smem_event_connect_request\",\n                  GetLastError()));    \n    }\n  }\n#endif  \n  \n  close_connections();\n  if (sig != MYSQL_KILL_SIGNAL &&\n      sig != 0)\n    unireg_abort(1);\t\t\t\t/* purecov: inspected */\n  else\n    unireg_end();\n\n  /* purecov: begin deadcode */\n  DBUG_LEAVE;                                   // Must match DBUG_ENTER()\n  my_thread_end();\n  pthread_exit(0);\n  /* purecov: end */\n\n  RETURN_FROM_KILL_SERVER;                      // Avoid compiler warnings\n\n#else /* EMBEDDED_LIBRARY*/\n\n  DBUG_LEAVE;\n  RETURN_FROM_KILL_SERVER;\n\n#endif /* EMBEDDED_LIBRARY */\n}\n\n\n#if defined(USE_ONE_SIGNAL_HAND)\npthread_handler_t kill_server_thread(void *arg __attribute__((unused)))\n{\n  my_thread_init();\t\t\t\t// Initialize new thread\n  kill_server(0);\n  /* purecov: begin deadcode */\n  my_thread_end();\n  pthread_exit(0);\n  return 0;\n  /* purecov: end */\n}\n#endif\n\n\nextern \"C\" sig_handler print_signal_warning(int sig)\n{\n  if (global_system_variables.log_warnings)\n    sql_print_warning(\"Got signal %d from thread %ld\", sig,my_thread_id());\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  my_sigset(sig,print_signal_warning);\t\t/* int. thread system calls */\n#endif\n#if !defined(__WIN__)\n  if (sig == SIGALRM)\n    alarm(2);\t\t\t\t\t/* reschedule alarm */\n#endif\n}\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void init_error_log_mutex()\n{\n  mysql_mutex_init(key_LOCK_error_log, &LOCK_error_log, MY_MUTEX_INIT_FAST);\n}\n\n\nstatic void clean_up_error_log_mutex()\n{\n  mysql_mutex_destroy(&LOCK_error_log);\n}\n\n\n/**\n  cleanup all memory and end program nicely.\n\n    If SIGNALS_DONT_BREAK_READ is defined, this function is called\n    by the main thread. To get MySQL to shut down nicely in this case\n    (Mac OS X) we have to call exit() instead if pthread_exit().\n\n  @note\n    This function never returns.\n*/\nvoid unireg_end(void)\n{\n  clean_up(1);\n  my_thread_end();\n#if defined(SIGNALS_DONT_BREAK_READ)\n  exit(0);\n#else\n  pthread_exit(0);\t\t\t\t// Exit is in main thread\n#endif\n}\n\n\nextern \"C\" void unireg_abort(int exit_code)\n{\n  DBUG_ENTER(\"unireg_abort\");\n\n  if (opt_help)\n    usage();\n  if (exit_code)\n    sql_print_error(\"Aborting\\n\");\n  clean_up(!opt_help && (exit_code || !opt_bootstrap)); /* purecov: inspected */\n  DBUG_PRINT(\"quit\",(\"done with cleanup in unireg_abort\"));\n  mysqld_exit(exit_code);\n}\n\nstatic void mysqld_exit(int exit_code)\n{\n  /*\n    Important note: we wait for the signal thread to end,\n    but if a kill -15 signal was sent, the signal thread did\n    spawn the kill_server_thread thread, which is running concurrently.\n  */\n  wait_for_signal_thread_to_end();\n  mysql_audit_finalize();\n  clean_up_mutexes();\n  clean_up_error_log_mutex();\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    Bug#56666 needs to be fixed before calling:\n    shutdown_performance_schema();\n  */\n#endif\n  my_end(opt_endinfo ? MY_CHECK_ERROR | MY_GIVE_INFO : 0);\n  exit(exit_code); /* purecov: inspected */\n}\n\n#endif /* !EMBEDDED_LIBRARY */\n\nvoid clean_up(bool print_message)\n{\n  DBUG_PRINT(\"exit\",(\"clean_up\"));\n  if (cleanup_done++)\n    return; /* purecov: inspected */\n\n  stop_handle_manager();\n  release_ddl_log();\n\n  /*\n    make sure that handlers finish up\n    what they have that is dependent on the binlog\n  */\n  ha_binlog_end(current_thd);\n\n  logger.cleanup_base();\n\n  injector::free_instance();\n  mysql_bin_log.cleanup();\n\n#ifdef HAVE_REPLICATION\n  if (use_slave_mask)\n    bitmap_free(&slave_error_mask);\n#endif\n  my_tz_free();\n  my_dboptions_cache_free();\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  servers_free(1);\n  acl_free(1);\n  grant_free();\n#endif\n  query_cache_destroy();\n  hostname_cache_free();\n  item_user_lock_free();\n  lex_free();\t\t\t\t/* Free some memory */\n  item_create_cleanup();\n  if (!opt_noacl)\n  {\n#ifdef HAVE_DLOPEN\n    udf_free();\n#endif\n  }\n  table_def_start_shutdown();\n  plugin_shutdown();\n  ha_end();\n  if (tc_log)\n    tc_log->close();\n  delegates_destroy();\n  xid_cache_free();\n  table_def_free();\n  mdl_destroy();\n  key_caches.delete_elements((void (*)(const char*, uchar*)) free_key_cache);\n  multi_keycache_free();\n  free_status_vars();\n  end_thr_alarm(1);\t\t\t/* Free allocated memory */\n  my_free_open_file_info();\n  if (defaults_argv)\n    free_defaults(defaults_argv);\n  free_tmpdir(&mysql_tmpdir_list);\n  my_free(opt_bin_logname);\n  bitmap_free(&temp_pool);\n  free_max_user_conn();\n#ifdef HAVE_REPLICATION\n  end_slave_list();\n#endif\n  delete binlog_filter;\n  delete rpl_filter;\n  end_ssl();\n  vio_end();\n  my_regex_end();\n#if defined(ENABLED_DEBUG_SYNC)\n  /* End the debug sync facility. See debug_sync.cc. */\n  debug_sync_end();\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n  delete_pid_file(MYF(0));\n\n  if (print_message && my_default_lc_messages && server_start_time)\n    sql_print_information(ER_DEFAULT(ER_SHUTDOWN_COMPLETE),my_progname);\n  cleanup_errmsgs();\n  MYSQL_CALLBACK(thread_scheduler, end, ());\n  mysql_client_plugin_deinit();\n  finish_client_errs();\n  (void) my_error_unregister(ER_ERROR_FIRST, ER_ERROR_LAST); // finish server errs\n  DBUG_PRINT(\"quit\", (\"Error messages freed\"));\n  /* Tell main we are ready */\n  logger.cleanup_end();\n  my_atomic_rwlock_destroy(&global_query_id_lock);\n  my_atomic_rwlock_destroy(&thread_running_lock);\n  free_charsets();\n  mysql_mutex_lock(&LOCK_thread_count);\n  DBUG_PRINT(\"quit\", (\"got thread count lock\"));\n  ready_to_exit=1;\n  /* do the broadcast inside the lock to ensure that my_end() is not called */\n  mysql_cond_broadcast(&COND_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  sys_var_end();\n\n  /*\n    The following lines may never be executed as the main thread may have\n    killed us\n  */\n  DBUG_PRINT(\"quit\", (\"done with cleanup\"));\n} /* clean_up */\n\n\n#ifndef EMBEDDED_LIBRARY\n\n/**\n  This is mainly needed when running with purify, but it's still nice to\n  know that all child threads have died when mysqld exits.\n*/\nstatic void wait_for_signal_thread_to_end()\n{\n  uint i;\n  /*\n    Wait up to 10 seconds for signal thread to die. We use this mainly to\n    avoid getting warnings that my_thread_end has not been called\n  */\n  for (i= 0 ; i < 100 && signal_thread_in_use; i++)\n  {\n    if (pthread_kill(signal_thread, MYSQL_KILL_SIGNAL) != ESRCH)\n      break;\n    my_sleep(100);\t\t\t\t// Give it time to die\n  }\n}\n\n\nstatic void clean_up_mutexes()\n{\n  mysql_rwlock_destroy(&LOCK_grant);\n  mysql_mutex_destroy(&LOCK_thread_count);\n  mysql_mutex_destroy(&LOCK_thread_created);\n  mysql_mutex_destroy(&LOCK_status);\n  mysql_mutex_destroy(&LOCK_delayed_insert);\n  mysql_mutex_destroy(&LOCK_delayed_status);\n  mysql_mutex_destroy(&LOCK_delayed_create);\n  mysql_mutex_destroy(&LOCK_manager);\n  mysql_mutex_destroy(&LOCK_crypt);\n  mysql_mutex_destroy(&LOCK_user_conn);\n  mysql_mutex_destroy(&LOCK_connection_count);\n#ifdef HAVE_OPENSSL\n  mysql_mutex_destroy(&LOCK_des_key_file);\n#ifndef HAVE_YASSL\n  for (int i= 0; i < CRYPTO_num_locks(); ++i)\n    mysql_rwlock_destroy(&openssl_stdlocks[i].lock);\n  OPENSSL_free(openssl_stdlocks);\n#endif\n#endif\n#ifdef HAVE_REPLICATION\n  mysql_mutex_destroy(&LOCK_rpl_status);\n  mysql_cond_destroy(&COND_rpl_status);\n#endif\n  mysql_mutex_destroy(&LOCK_active_mi);\n  mysql_rwlock_destroy(&LOCK_sys_init_connect);\n  mysql_rwlock_destroy(&LOCK_sys_init_slave);\n  mysql_mutex_destroy(&LOCK_global_system_variables);\n  mysql_rwlock_destroy(&LOCK_system_variables_hash);\n  mysql_mutex_destroy(&LOCK_uuid_generator);\n  mysql_mutex_destroy(&LOCK_prepared_stmt_count);\n  mysql_mutex_destroy(&LOCK_error_messages);\n  mysql_cond_destroy(&COND_thread_count);\n  mysql_mutex_destroy(&LOCK_thd_remove);\n  mysql_cond_destroy(&COND_thread_cache);\n  mysql_cond_destroy(&COND_flush_thread_cache);\n  mysql_cond_destroy(&COND_manager);\n}\n#endif /*EMBEDDED_LIBRARY*/\n\n\n/****************************************************************************\n** Init IP and UNIX socket\n****************************************************************************/\n\n#ifndef EMBEDDED_LIBRARY\nstatic void set_ports()\n{\n  char\t*env;\n  if (!mysqld_port && !opt_disable_networking)\n  {\t\t\t\t\t// Get port if not from commandline\n    mysqld_port= MYSQL_PORT;\n\n    /*\n      if builder specifically requested a default port, use that\n      (even if it coincides with our factory default).\n      only if they didn't do we check /etc/services (and, failing\n      on that, fall back to the factory default of 3306).\n      either default can be overridden by the environment variable\n      MYSQL_TCP_PORT, which in turn can be overridden with command\n      line options.\n    */\n\n#if MYSQL_PORT_DEFAULT == 0\n    struct  servent *serv_ptr;\n    if ((serv_ptr= getservbyname(\"mysql\", \"tcp\")))\n      mysqld_port= ntohs((u_short) serv_ptr->s_port); /* purecov: inspected */\n#endif\n    if ((env = getenv(\"MYSQL_TCP_PORT\")))\n      mysqld_port= (uint) atoi(env);\t\t/* purecov: inspected */\n  }\n  if (!mysqld_unix_port)\n  {\n#ifdef __WIN__\n    mysqld_unix_port= (char*) MYSQL_NAMEDPIPE;\n#else\n    mysqld_unix_port= (char*) MYSQL_UNIX_ADDR;\n#endif\n    if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n      mysqld_unix_port= env;\t\t\t/* purecov: inspected */\n  }\n}\n\n/* Change to run as another user if started with --user */\n\nstatic struct passwd *check_user(const char *user)\n{\n#if !defined(__WIN__)\n  struct passwd *tmp_user_info;\n  uid_t user_id= geteuid();\n\n  // Don't bother if we aren't superuser\n  if (user_id)\n  {\n    if (user)\n    {\n      /* Don't give a warning, if real user is same as given with --user */\n      /* purecov: begin tested */\n      tmp_user_info= getpwnam(user);\n      if ((!tmp_user_info || user_id != tmp_user_info->pw_uid) &&\n\t  global_system_variables.log_warnings)\n        sql_print_warning(\n                    \"One can only use the --user switch if running as root\\n\");\n      /* purecov: end */\n    }\n    return NULL;\n  }\n  if (!user)\n  {\n    if (!opt_bootstrap && !opt_help)\n    {\n      sql_print_error(\"Fatal error: Please read \\\"Security\\\" section of the manual to find out how to run mysqld as root!\\n\");\n      unireg_abort(1);\n    }\n    return NULL;\n  }\n  /* purecov: begin tested */\n  if (!strcmp(user,\"root\"))\n    return NULL;                        // Avoid problem with dynamic libraries\n\n  if (!(tmp_user_info= getpwnam(user)))\n  {\n    // Allow a numeric uid to be used\n    const char *pos;\n    for (pos= user; my_isdigit(mysqld_charset,*pos); pos++) ;\n    if (*pos)                                   // Not numeric id\n      goto err;\n    if (!(tmp_user_info= getpwuid(atoi(user))))\n      goto err;\n  }\n  return tmp_user_info;\n  /* purecov: end */\n\nerr:\n  sql_print_error(\"Fatal error: Can't change to run as user '%s' ;  Please check that the user exists!\\n\",user);\n  unireg_abort(1);\n\n#ifdef PR_SET_DUMPABLE\n  if (test_flags & TEST_CORE_ON_SIGNAL)\n  {\n    /* inform kernel that process is dumpable */\n    (void) prctl(PR_SET_DUMPABLE, 1);\n  }\n#endif\n\n#endif\n  return NULL;\n}\n\nstatic void set_user(const char *user, struct passwd *user_info_arg)\n{\n  /* purecov: begin tested */\n#if !defined(__WIN__)\n  DBUG_ASSERT(user_info_arg != 0);\n#ifdef HAVE_INITGROUPS\n  /*\n    We can get a SIGSEGV when calling initgroups() on some systems when NSS\n    is configured to use LDAP and the server is statically linked.  We set\n    calling_initgroups as a flag to the SIGSEGV handler that is then used to\n    output a specific message to help the user resolve this problem.\n  */\n  calling_initgroups= 1;\n  initgroups((char*) user, user_info_arg->pw_gid);\n  calling_initgroups= 0;\n#endif\n  if (setgid(user_info_arg->pw_gid) == -1)\n  {\n    sql_perror(\"setgid\");\n    unireg_abort(1);\n  }\n  if (setuid(user_info_arg->pw_uid) == -1)\n  {\n    sql_perror(\"setuid\");\n    unireg_abort(1);\n  }\n#endif\n  /* purecov: end */\n}\n\n\nstatic void set_effective_user(struct passwd *user_info_arg)\n{\n#if !defined(__WIN__)\n  DBUG_ASSERT(user_info_arg != 0);\n  if (setregid((gid_t)-1, user_info_arg->pw_gid) == -1)\n  {\n    sql_perror(\"setregid\");\n    unireg_abort(1);\n  }\n  if (setreuid((uid_t)-1, user_info_arg->pw_uid) == -1)\n  {\n    sql_perror(\"setreuid\");\n    unireg_abort(1);\n  }\n#endif\n}\n\n\n/** Change root user if started with @c --chroot . */\nstatic void set_root(const char *path)\n{\n#if !defined(__WIN__)\n  if (chroot(path) == -1)\n  {\n    sql_perror(\"chroot\");\n    unireg_abort(1);\n  }\n  my_setwd(\"/\", MYF(0));\n#endif\n}\n\n\nstatic my_socket create_socket(const struct addrinfo *addrinfo_list,\n                               int addr_family,\n                               struct addrinfo **use_addrinfo)\n{\n  my_socket sock= INVALID_SOCKET;\n\n  for (const struct addrinfo *cur_ai= addrinfo_list; cur_ai != NULL;\n       cur_ai= cur_ai->ai_next)\n  {\n    if (cur_ai->ai_family != addr_family)\n      continue;\n\n    sock= socket(cur_ai->ai_family, cur_ai->ai_socktype, cur_ai->ai_protocol);\n\n    char ip_addr[INET6_ADDRSTRLEN];\n\n    if (vio_get_normalized_ip_string(cur_ai->ai_addr, cur_ai->ai_addrlen,\n                                     ip_addr, sizeof (ip_addr)))\n    {\n      ip_addr[0]= 0;\n    }\n\n    if (sock == INVALID_SOCKET)\n    {\n      sql_print_error(\"Failed to create a socket for %s '%s': errno: %d.\",\n                      (addr_family == AF_INET) ? \"IPv4\" : \"IPv6\",\n                      (const char *) ip_addr,\n                      (int) socket_errno);\n      continue;\n    }\n\n    sql_print_information(\"Server socket created on IP: '%s'.\",\n                          (const char *) ip_addr);\n\n    *use_addrinfo= (struct addrinfo *)cur_ai;\n    return sock;\n  }\n\n  return INVALID_SOCKET;\n}\n\n\nstatic void network_init(void)\n{\n#ifdef HAVE_SYS_UN_H\n  struct sockaddr_un\tUNIXaddr;\n#endif\n  int\targ;\n  int   ret;\n  uint  waited;\n  uint  this_wait;\n  uint  retry;\n  char port_buf[NI_MAXSERV];\n  DBUG_ENTER(\"network_init\");\n  LINT_INIT(ret);\n\n  if (MYSQL_CALLBACK_ELSE(thread_scheduler, init, (), 0))\n    unireg_abort(1);\t\t\t/* purecov: inspected */\n\n  set_ports();\n\n  if (report_port == 0)\n  {\n    report_port= mysqld_port;\n  }\n\n#ifndef DBUG_OFF\n  if (!opt_disable_networking)\n    DBUG_ASSERT(report_port != 0);\n#endif\n\n  if (mysqld_port != 0 && !opt_disable_networking && !opt_bootstrap)\n  {\n    struct addrinfo *ai, *a;\n    struct addrinfo hints;\n    const char *bind_address= my_bind_addr_str;\n\n    if (!bind_address)\n      bind_address= \"0.0.0.0\";\n\n    sql_print_information(\"Server hostname (bind-address): '%s'; port: %d\",\n                          bind_address, mysqld_port);\n\n    // Get list of IP-addresses associated with the server hostname.\n    bzero(&hints, sizeof (hints));\n    hints.ai_flags= AI_PASSIVE;\n    hints.ai_socktype= SOCK_STREAM;\n    hints.ai_family= AF_UNSPEC;\n\n    my_snprintf(port_buf, NI_MAXSERV, \"%d\", mysqld_port);\n    if (getaddrinfo(bind_address, port_buf, &hints, &ai))\n    {\n      sql_perror(ER_DEFAULT(ER_IPSOCK_ERROR));  /* purecov: tested */\n      sql_print_error(\"Can't start server: cannot resolve hostname!\");\n      unireg_abort(1);\t\t\t\t/* purecov: tested */\n    }\n\n    // Log all the IP-addresses.\n    for (struct addrinfo *cur_ai= ai; cur_ai != NULL; cur_ai= cur_ai->ai_next)\n    {\n      char ip_addr[INET6_ADDRSTRLEN];\n\n      if (vio_get_normalized_ip_string(cur_ai->ai_addr, cur_ai->ai_addrlen,\n                                       ip_addr, sizeof (ip_addr)))\n      {\n        sql_print_error(\"Fails to print out IP-address.\");\n        continue;\n      }\n\n      sql_print_information(\"  - '%s' resolves to '%s';\",\n                            bind_address, ip_addr);\n    }\n\n    /*\n      If the 'bind-address' option specifies the hostname, which resolves to\n      multiple IP-address, use the following rule:\n      - if there are IPv4-addresses, use the first IPv4-address\n      returned by getaddrinfo();\n      - if there are IPv6-addresses, use the first IPv6-address\n      returned by getaddrinfo();\n    */\n\n    ip_sock= create_socket(ai, AF_INET, &a);\n\n    if (ip_sock == INVALID_SOCKET)\n      ip_sock= create_socket(ai, AF_INET6, &a);\n\n    // Report user-error if we failed to create a socket.\n    if (ip_sock == INVALID_SOCKET)\n    {\n      sql_perror(ER_DEFAULT(ER_IPSOCK_ERROR));  /* purecov: tested */\n      unireg_abort(1);                          /* purecov: tested */\n    }\n#ifndef __WIN__\n    /*\n      We should not use SO_REUSEADDR on windows as this would enable a\n      user to open two mysqld servers with the same TCP/IP port.\n    */\n    arg= 1;\n    (void) setsockopt(ip_sock,SOL_SOCKET,SO_REUSEADDR,(char*)&arg,sizeof(arg));\n#endif /* __WIN__ */\n\n#ifdef IPV6_V6ONLY\n     /*\n       For interoperability with older clients, IPv6 socket should\n       listen on both IPv6 and IPv4 wildcard addresses.\n       Turn off IPV6_V6ONLY option.\n\n       NOTE: this will work starting from Windows Vista only.\n       On Windows XP dual stack is not available, so it will not\n       listen on the corresponding IPv4-address.\n     */\n    if (a->ai_family == AF_INET6)\n    {\n      arg= 0;\n      (void) setsockopt(ip_sock, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,\n                sizeof(arg));\n    }\n#endif\n    /*\n      Sometimes the port is not released fast enough when stopping and\n      restarting the server. This happens quite often with the test suite\n      on busy Linux systems. Retry to bind the address at these intervals:\n      Sleep intervals: 1, 2, 4,  6,  9, 13, 17, 22, ...\n      Retry at second: 1, 3, 7, 13, 22, 35, 52, 74, ...\n      Limit the sequence by mysqld_port_timeout (set --port-open-timeout=#).\n    */\n    for (waited= 0, retry= 1; ; retry++, waited+= this_wait)\n    {\n      if (((ret= bind(ip_sock, a->ai_addr, a->ai_addrlen)) >= 0 ) ||\n          (socket_errno != SOCKET_EADDRINUSE) ||\n          (waited >= mysqld_port_timeout))\n        break;\n      sql_print_information(\"Retrying bind on TCP/IP port %u\", mysqld_port);\n      this_wait= retry * retry / 3 + 1;\n      sleep(this_wait);\n    }\n    freeaddrinfo(ai);\n    if (ret < 0)\n    {\n      DBUG_PRINT(\"error\",(\"Got error: %d from bind\",socket_errno));\n      sql_perror(\"Can't start server: Bind on TCP/IP port\");\n      sql_print_error(\"Do you already have another mysqld server running on port: %d ?\",mysqld_port);\n      unireg_abort(1);\n    }\n    if (listen(ip_sock,(int) back_log) < 0)\n    {\n      sql_perror(\"Can't start server: listen() on TCP/IP port\");\n      sql_print_error(\"listen() on TCP/IP failed with error %d\",\n\t\t      socket_errno);\n      unireg_abort(1);\n    }\n  }\n\n#ifdef _WIN32\n  /* create named pipe */\n  if (Service.IsNT() && mysqld_unix_port[0] && !opt_bootstrap &&\n      opt_enable_named_pipe)\n  {\n    strxnmov(pipe_name, sizeof(pipe_name)-1, \"\\\\\\\\.\\\\pipe\\\\\",\n\t     mysqld_unix_port, NullS);\n    bzero((char*) &saPipeSecurity, sizeof(saPipeSecurity));\n    bzero((char*) &sdPipeDescriptor, sizeof(sdPipeDescriptor));\n    if (!InitializeSecurityDescriptor(&sdPipeDescriptor,\n\t\t\t\t      SECURITY_DESCRIPTOR_REVISION))\n    {\n      sql_perror(\"Can't start server : Initialize security descriptor\");\n      unireg_abort(1);\n    }\n    if (!SetSecurityDescriptorDacl(&sdPipeDescriptor, TRUE, NULL, FALSE))\n    {\n      sql_perror(\"Can't start server : Set security descriptor\");\n      unireg_abort(1);\n    }\n    saPipeSecurity.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saPipeSecurity.lpSecurityDescriptor = &sdPipeDescriptor;\n    saPipeSecurity.bInheritHandle = FALSE;\n    if ((hPipe= CreateNamedPipe(pipe_name,\n\t\t\t\tPIPE_ACCESS_DUPLEX|FILE_FLAG_OVERLAPPED,\n\t\t\t\tPIPE_TYPE_BYTE |\n\t\t\t\tPIPE_READMODE_BYTE |\n\t\t\t\tPIPE_WAIT,\n\t\t\t\tPIPE_UNLIMITED_INSTANCES,\n\t\t\t\t(int) global_system_variables.net_buffer_length,\n\t\t\t\t(int) global_system_variables.net_buffer_length,\n\t\t\t\tNMPWAIT_USE_DEFAULT_WAIT,\n\t\t\t\t&saPipeSecurity)) == INVALID_HANDLE_VALUE)\n      {\n\tLPVOID lpMsgBuf;\n\tint error=GetLastError();\n\tFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\t\t      FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t      NULL, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t      (LPTSTR) &lpMsgBuf, 0, NULL );\n\tsql_perror((char *)lpMsgBuf);\n\tLocalFree(lpMsgBuf);\n\tunireg_abort(1);\n      }\n  }\n#endif\n\n#if defined(HAVE_SYS_UN_H)\n  /*\n  ** Create the UNIX socket\n  */\n  if (mysqld_unix_port[0] && !opt_bootstrap)\n  {\n    DBUG_PRINT(\"general\",(\"UNIX Socket is %s\",mysqld_unix_port));\n\n    if (strlen(mysqld_unix_port) > (sizeof(UNIXaddr.sun_path) - 1))\n    {\n      sql_print_error(\"The socket file path is too long (> %u): %s\",\n                      (uint) sizeof(UNIXaddr.sun_path) - 1, mysqld_unix_port);\n      unireg_abort(1);\n    }\n    if ((unix_sock= socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n    {\n      sql_perror(\"Can't start server : UNIX Socket \"); /* purecov: inspected */\n      unireg_abort(1);\t\t\t\t/* purecov: inspected */\n    }\n    bzero((char*) &UNIXaddr, sizeof(UNIXaddr));\n    UNIXaddr.sun_family = AF_UNIX;\n    strmov(UNIXaddr.sun_path, mysqld_unix_port);\n    (void) unlink(mysqld_unix_port);\n    arg= 1;\n    (void) setsockopt(unix_sock,SOL_SOCKET,SO_REUSEADDR,(char*)&arg,\n\t\t      sizeof(arg));\n    umask(0);\n    if (bind(unix_sock, reinterpret_cast<struct sockaddr *>(&UNIXaddr),\n\t     sizeof(UNIXaddr)) < 0)\n    {\n      sql_perror(\"Can't start server : Bind on unix socket\"); /* purecov: tested */\n      sql_print_error(\"Do you already have another mysqld server running on socket: %s ?\",mysqld_unix_port);\n      unireg_abort(1);\t\t\t\t\t/* purecov: tested */\n    }\n    umask(((~my_umask) & 0666));\n#if defined(S_IFSOCK) && defined(SECURE_SOCKETS)\n    (void) chmod(mysqld_unix_port,S_IFSOCK);\t/* Fix solaris 2.6 bug */\n#endif\n    if (listen(unix_sock,(int) back_log) < 0)\n      sql_print_warning(\"listen() on Unix socket failed with error %d\",\n\t\t      socket_errno);\n  }\n#endif\n  DBUG_PRINT(\"info\",(\"server started\"));\n  DBUG_VOID_RETURN;\n}\n\n#endif /*!EMBEDDED_LIBRARY*/\n\n\n#ifndef EMBEDDED_LIBRARY\n/**\n  Close a connection.\n\n  @param thd        Thread handle.\n  @param sql_errno  The error code to send before disconnect.\n\n  @note\n    For the connection that is doing shutdown, this is called twice\n*/\nvoid close_connection(THD *thd, uint sql_errno)\n{\n  DBUG_ENTER(\"close_connection\");\n\n  if (sql_errno)\n    net_send_error(thd, sql_errno, ER_DEFAULT(sql_errno), NULL);\n\n  thd->disconnect();\n\n  MYSQL_CONNECTION_DONE((int) sql_errno, thd->thread_id);\n\n  if (MYSQL_CONNECTION_DONE_ENABLED())\n  {\n    sleep(0); /* Workaround to avoid tailcall optimisation */\n  }\n  MYSQL_AUDIT_NOTIFY_CONNECTION_DISCONNECT(thd, sql_errno);\n  DBUG_VOID_RETURN;\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n/** Called when a thread is aborted. */\n/* ARGSUSED */\nextern \"C\" sig_handler end_thread_signal(int sig __attribute__((unused)))\n{\n  THD *thd=current_thd;\n  DBUG_ENTER(\"end_thread_signal\");\n  if (thd && ! thd->bootstrap)\n  {\n    statistic_increment(killed_threads, &LOCK_status);\n    MYSQL_CALLBACK(thread_scheduler, end_thread, (thd,0)); /* purecov: inspected */\n  }\n  DBUG_VOID_RETURN;\t\t\t\t/* purecov: deadcode */\n}\n\n\n/*\n  Cleanup THD object\n\n  SYNOPSIS\n    thd_cleanup()\n    thd\t\t Thread handler\n*/\n\nvoid thd_cleanup(THD *thd)\n{\n  thd->cleanup();\n}\n\n/*\n  Decrease number of connections\n\n  SYNOPSIS\n    dec_connection_count()\n*/\n\nvoid dec_connection_count()\n{\n  mysql_mutex_lock(&LOCK_connection_count);\n  --connection_count;\n  mysql_mutex_unlock(&LOCK_connection_count);\n}\n\n\n/*\n  Delete the THD object and decrease number of threads\n\n  SYNOPSIS\n    delete_thd()\n    thd\t\t Thread handler\n*/\n\nvoid delete_thd(THD *thd)\n{\n  mysql_mutex_assert_owner(&LOCK_thread_count);\n  mysql_mutex_assert_owner(&LOCK_thd_remove);\n  thread_count--;\n  delete thd;\n}\n\n\n/*\n  Unlink thd from global list of available connections and free thd\n\n  SYNOPSIS\n    unlink_thd()\n    thd\t\t Thread handler\n\n  NOTES\n    LOCK_thread_count, LOCK_thd_remove are locked and left locked\n*/\n\nvoid unlink_thd(THD *thd)\n{\n  DBUG_ENTER(\"unlink_thd\");\n  DBUG_PRINT(\"enter\", (\"thd: 0x%lx\", (long) thd));\n\n  thd_cleanup(thd);\n  dec_connection_count();\n  mysql_mutex_lock(&LOCK_thd_remove);\n  mysql_mutex_lock(&LOCK_thread_count);\n  /*\n    Used by binlog_reset_master.  It would be cleaner to use\n    DEBUG_SYNC here, but that's not possible because the THD's debug\n    sync feature has been shut down at this point.\n  */\n  DBUG_EXECUTE_IF(\"sleep_after_lock_thread_count_before_delete_thd\", sleep(5););\n  delete_thd(thd);\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Store thread in cache for reuse by new connections\n\n  SYNOPSIS\n    cache_thread()\n\n  NOTES\n    LOCK_thread_count has to be locked\n\n  RETURN\n    0  Thread was not put in cache\n    1  Thread is to be reused by new connection.\n       (ie, caller should return, not abort with pthread_exit())\n*/\n\n\nstatic bool cache_thread()\n{\n  mysql_mutex_assert_owner(&LOCK_thread_count);\n  if (cached_thread_count < thread_cache_size &&\n      ! abort_loop && !kill_cached_threads)\n  {\n    /* Don't kill the thread, just put it in cache for reuse */\n    DBUG_PRINT(\"info\", (\"Adding thread to cache\"));\n    cached_thread_count++;\n\n#ifdef HAVE_PSI_INTERFACE\n    /*\n      Delete the instrumentation for the job that just completed,\n      before parking this pthread in the cache (blocked on COND_thread_cache).\n    */\n    if (likely(PSI_server != NULL))\n      PSI_server->delete_current_thread();\n#endif\n\n    while (!abort_loop && ! wake_thread && ! kill_cached_threads)\n      mysql_cond_wait(&COND_thread_cache, &LOCK_thread_count);\n    cached_thread_count--;\n    if (kill_cached_threads)\n      mysql_cond_signal(&COND_flush_thread_cache);\n    if (wake_thread)\n    {\n      THD *thd;\n      wake_thread--;\n      thd= thread_cache.get();\n      thd->thread_stack= (char*) &thd;          // For store_globals\n      (void) thd->store_globals();\n\n#ifdef HAVE_PSI_INTERFACE\n      /*\n        Create new instrumentation for the new THD job,\n        and attach it to this running pthread.\n      */\n      if (likely(PSI_server != NULL))\n      {\n        PSI_thread *psi= PSI_server->new_thread(key_thread_one_connection,\n                                                thd, thd->thread_id);\n        if (likely(psi != NULL))\n          PSI_server->set_thread(psi);\n      }\n#endif\n\n      /*\n        THD::mysys_var::abort is associated with physical thread rather\n        than with THD object. So we need to reset this flag before using\n        this thread for handling of new THD object/connection.\n      */\n      thd->mysys_var->abort= 0;\n      thd->thr_create_utime= thd->start_utime= my_micro_time();\n      threads.append(thd);\n      return(1);\n    }\n  }\n  return(0);\n}\n\n\n/*\n  End thread for the current connection\n\n  SYNOPSIS\n    one_thread_per_connection_end()\n    thd\t\t  Thread handler\n    put_in_cache  Store thread in cache, if there is room in it\n                  Normally this is true in all cases except when we got\n                  out of resources initializing the current thread\n\n  NOTES\n    If thread is cached, we will wait until thread is scheduled to be\n    reused and then we will return.\n    If thread is not cached, we end the thread.\n\n  RETURN\n    0    Signal to handle_one_connection to reuse connection\n*/\n\nbool one_thread_per_connection_end(THD *thd, bool put_in_cache)\n{\n  DBUG_ENTER(\"one_thread_per_connection_end\");\n  unlink_thd(thd);\n  mysql_mutex_unlock(&LOCK_thd_remove);\n  if (put_in_cache)\n    put_in_cache= cache_thread();\n  mysql_mutex_unlock(&LOCK_thread_count);\n  if (put_in_cache)\n    DBUG_RETURN(0);                             // Thread is reused\n\n  /* It's safe to broadcast outside a lock (COND... is not deleted here) */\n  DBUG_PRINT(\"signal\", (\"Broadcasting COND_thread_count\"));\n  DBUG_LEAVE;                                   // Must match DBUG_ENTER()\n  my_thread_end();\n  mysql_cond_broadcast(&COND_thread_count);\n\n  pthread_exit(0);\n  return 0;                                     // Avoid compiler warnings\n}\n\n\nvoid flush_thread_cache()\n{\n  mysql_mutex_lock(&LOCK_thread_count);\n  kill_cached_threads++;\n  while (cached_thread_count)\n  {\n    mysql_cond_broadcast(&COND_thread_cache);\n    mysql_cond_wait(&COND_flush_thread_cache, &LOCK_thread_count);\n  }\n  kill_cached_threads--;\n  mysql_mutex_unlock(&LOCK_thread_count);\n}\n\n\n#ifdef THREAD_SPECIFIC_SIGPIPE\n/**\n  Aborts a thread nicely. Comes here on SIGPIPE.\n\n  @todo\n    One should have to fix that thr_alarm know about this thread too.\n*/\nextern \"C\" sig_handler abort_thread(int sig __attribute__((unused)))\n{\n  THD *thd=current_thd;\n  DBUG_ENTER(\"abort_thread\");\n  if (thd)\n    thd->killed= THD::KILL_CONNECTION;\n  DBUG_VOID_RETURN;\n}\n#endif\n\n\n/******************************************************************************\n  Setup a signal thread with handles all signals.\n  Because Linux doesn't support schemas use a mutex to check that\n  the signal thread is ready before continuing\n******************************************************************************/\n\n#if defined(__WIN__)\n\n\n/*\n  On Windows, we use native SetConsoleCtrlHandler for handle events like Ctrl-C\n  with graceful shutdown.\n  Also, we do not use signal(), but SetUnhandledExceptionFilter instead - as it\n  provides possibility to pass the exception to just-in-time debugger, collect\n  dumps and potentially also the exception and thread context used to output\n  callstack.\n*/\n\nstatic BOOL WINAPI console_event_handler( DWORD type ) \n{\n  DBUG_ENTER(\"console_event_handler\");\n#ifndef EMBEDDED_LIBRARY\n  if(type == CTRL_C_EVENT)\n  {\n     /*\n       Do not shutdown before startup is finished and shutdown\n       thread is initialized. Otherwise there is a race condition \n       between main thread doing initialization and CTRL-C thread doing\n       cleanup, which can result into crash.\n     */\n#ifndef EMBEDDED_LIBRARY\n     if(hEventShutdown)\n       kill_mysql();\n     else\n#endif\n       sql_print_warning(\"CTRL-C ignored during startup\");\n     DBUG_RETURN(TRUE);\n  }\n#endif\n  DBUG_RETURN(FALSE);\n}\n\n\n\n\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n#define DEBUGGER_ATTACH_TIMEOUT 120\n/*\n  Wait for debugger to attach and break into debugger. If debugger is not attached,\n  resume after timeout.\n*/\nstatic void wait_for_debugger(int timeout_sec)\n{\n   if(!IsDebuggerPresent())\n   {\n     int i;\n     printf(\"Waiting for debugger to attach, pid=%u\\n\",GetCurrentProcessId());\n     fflush(stdout);\n     for(i= 0; i < timeout_sec; i++)\n     {\n       Sleep(1000);\n       if(IsDebuggerPresent())\n       {\n         /* Break into debugger */\n         __debugbreak();\n         return;\n       }\n     }\n     printf(\"pid=%u, debugger not attached after %d seconds, resuming\\n\",GetCurrentProcessId(),\n       timeout_sec);\n     fflush(stdout);\n   }\n}\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n\nLONG WINAPI my_unhandler_exception_filter(EXCEPTION_POINTERS *ex_pointers)\n{\n   static BOOL first_time= TRUE;\n   if(!first_time)\n   {\n     /*\n       This routine can be called twice, typically\n       when detaching in JIT debugger.\n       Return EXCEPTION_EXECUTE_HANDLER to terminate process.\n     */\n     return EXCEPTION_EXECUTE_HANDLER;\n   }\n   first_time= FALSE;\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n   /*\n    Unfortunately there is no clean way to debug unhandled exception filters,\n    as debugger does not stop there(also documented in MSDN) \n    To overcome, one could put a MessageBox, but this will not work in service.\n    Better solution is to print error message and sleep some minutes \n    until debugger is attached\n  */\n  wait_for_debugger(DEBUGGER_ATTACH_TIMEOUT);\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n  __try\n  {\n    my_set_exception_pointers(ex_pointers);\n    handle_fatal_signal(ex_pointers->ExceptionRecord->ExceptionCode);\n  }\n  __except(EXCEPTION_EXECUTE_HANDLER)\n  {\n    DWORD written;\n    const char msg[] = \"Got exception in exception handler!\\n\";\n    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),msg, sizeof(msg)-1, \n      &written,NULL);\n  }\n  /*\n    Return EXCEPTION_CONTINUE_SEARCH to give JIT debugger\n    (drwtsn32 or vsjitdebugger) possibility to attach,\n    if JIT debugger is configured.\n    Windows Error reporting might generate a dump here.\n  */\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n\n\nstatic void init_signals(void)\n{\n  if(opt_console)\n    SetConsoleCtrlHandler(console_event_handler,TRUE);\n\n    /* Avoid MessageBox()es*/\n  _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\n   /*\n     Do not use SEM_NOGPFAULTERRORBOX in the following SetErrorMode (),\n     because it would prevent JIT debugger and Windows error reporting\n     from working. We need WER or JIT-debugging, since our own unhandled\n     exception filter is not guaranteed to work in all situation\n     (like heap corruption or stack overflow)\n   */\n  SetErrorMode(SetErrorMode(0) | SEM_FAILCRITICALERRORS\n                               | SEM_NOOPENFILEERRORBOX);\n  SetUnhandledExceptionFilter(my_unhandler_exception_filter);\n}\n\n\nstatic void start_signal_handler(void)\n{\n#ifndef EMBEDDED_LIBRARY\n  // Save vm id of this process\n  if (!opt_bootstrap)\n    create_pid_file();\n#endif /* EMBEDDED_LIBRARY */\n}\n\n\nstatic void check_data_home(const char *path)\n{}\n\n#endif /* __WIN__ */\n\n\n#if BACKTRACE_DEMANGLE\n#include <cxxabi.h>\nextern \"C\" char *my_demangle(const char *mangled_name, int *status)\n{\n  return abi::__cxa_demangle(mangled_name, NULL, NULL, status);\n}\n#endif\n\n\n\n#if !defined(__WIN__)\n#ifndef SA_RESETHAND\n#define SA_RESETHAND 0\n#endif\n#ifndef SA_NODEFER\n#define SA_NODEFER 0\n#endif\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void init_signals(void)\n{\n  sigset_t set;\n  struct sigaction sa;\n  DBUG_ENTER(\"init_signals\");\n\n  my_sigset(THR_SERVER_ALARM,print_signal_warning); // Should never be called!\n\n  if (!(test_flags & TEST_NO_STACKTRACE) || (test_flags & TEST_CORE_ON_SIGNAL))\n  {\n    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n    sigemptyset(&sa.sa_mask);\n    sigprocmask(SIG_SETMASK,&sa.sa_mask,NULL);\n\n#ifdef HAVE_STACKTRACE\n    my_init_stacktrace();\n#endif\n#if defined(__amiga__)\n    sa.sa_handler=(void(*)())handle_fatal_signal;\n#else\n    sa.sa_handler=handle_fatal_signal;\n#endif\n    sigaction(SIGSEGV, &sa, NULL);\n    sigaction(SIGABRT, &sa, NULL);\n#ifdef SIGBUS\n    sigaction(SIGBUS, &sa, NULL);\n#endif\n    sigaction(SIGILL, &sa, NULL);\n    sigaction(SIGFPE, &sa, NULL);\n  }\n\n#ifdef HAVE_GETRLIMIT\n  if (test_flags & TEST_CORE_ON_SIGNAL)\n  {\n    /* Change limits so that we will get a core file */\n    STRUCT_RLIMIT rl;\n    rl.rlim_cur = rl.rlim_max = RLIM_INFINITY;\n    if (setrlimit(RLIMIT_CORE, &rl) && global_system_variables.log_warnings)\n      sql_print_warning(\"setrlimit could not change the size of core files to 'infinity';  We may not be able to generate a core file on signals\");\n  }\n#endif\n  (void) sigemptyset(&set);\n  my_sigset(SIGPIPE,SIG_IGN);\n  sigaddset(&set,SIGPIPE);\n#ifndef IGNORE_SIGHUP_SIGQUIT\n  sigaddset(&set,SIGQUIT);\n  sigaddset(&set,SIGHUP);\n#endif\n  sigaddset(&set,SIGTERM);\n\n  /* Fix signals if blocked by parents (can happen on Mac OS X) */\n  sigemptyset(&sa.sa_mask);\n  sa.sa_flags = 0;\n  sa.sa_handler = print_signal_warning;\n  sigaction(SIGTERM, &sa, (struct sigaction*) 0);\n  sa.sa_flags = 0;\n  sa.sa_handler = print_signal_warning;\n  sigaction(SIGHUP, &sa, (struct sigaction*) 0);\n#ifdef SIGTSTP\n  sigaddset(&set,SIGTSTP);\n#endif\n  if (thd_lib_detected != THD_LIB_LT)\n    sigaddset(&set,THR_SERVER_ALARM);\n  if (test_flags & TEST_SIGINT)\n  {\n    my_sigset(thr_kill_signal, end_thread_signal);\n    // May be SIGINT\n    sigdelset(&set, thr_kill_signal);\n  }\n  else\n    sigaddset(&set,SIGINT);\n  sigprocmask(SIG_SETMASK,&set,NULL);\n  pthread_sigmask(SIG_SETMASK,&set,NULL);\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void start_signal_handler(void)\n{\n  int error;\n  pthread_attr_t thr_attr;\n  DBUG_ENTER(\"start_signal_handler\");\n\n  (void) pthread_attr_init(&thr_attr);\n#if !defined(HAVE_DEC_3_2_THREADS)\n  pthread_attr_setscope(&thr_attr,PTHREAD_SCOPE_SYSTEM);\n  (void) pthread_attr_setdetachstate(&thr_attr,PTHREAD_CREATE_DETACHED);\n#if defined(__ia64__) || defined(__ia64)\n  /*\n    Peculiar things with ia64 platforms - it seems we only have half the\n    stack size in reality, so we have to double it here\n  */\n  pthread_attr_setstacksize(&thr_attr,my_thread_stack_size*2);\n#else\n  pthread_attr_setstacksize(&thr_attr,my_thread_stack_size);\n#endif\n#endif\n\n  mysql_mutex_lock(&LOCK_thread_count);\n  if ((error= mysql_thread_create(key_thread_signal_hand,\n                                  &signal_thread, &thr_attr, signal_hand, 0)))\n  {\n    sql_print_error(\"Can't create interrupt-thread (error %d, errno: %d)\",\n\t\t    error,errno);\n    exit(1);\n  }\n  mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n  (void) pthread_attr_destroy(&thr_attr);\n  DBUG_VOID_RETURN;\n}\n\n\n/** This threads handles all signals and alarms. */\n/* ARGSUSED */\npthread_handler_t signal_hand(void *arg __attribute__((unused)))\n{\n  sigset_t set;\n  int sig;\n  my_thread_init();\t\t\t\t// Init new thread\n  DBUG_ENTER(\"signal_hand\");\n  signal_thread_in_use= 1;\n\n  /*\n    Setup alarm handler\n    This should actually be '+ max_number_of_slaves' instead of +10,\n    but the +10 should be quite safe.\n  */\n  init_thr_alarm(thread_scheduler->max_threads +\n\t\t global_system_variables.max_insert_delayed_threads + 10);\n  if (thd_lib_detected != THD_LIB_LT && (test_flags & TEST_SIGINT))\n  {\n    (void) sigemptyset(&set);\t\t\t// Setup up SIGINT for debug\n    (void) sigaddset(&set,SIGINT);\t\t// For debugging\n    (void) pthread_sigmask(SIG_UNBLOCK,&set,NULL);\n  }\n  (void) sigemptyset(&set);\t\t\t// Setup up SIGINT for debug\n#ifdef USE_ONE_SIGNAL_HAND\n  (void) sigaddset(&set,THR_SERVER_ALARM);\t// For alarms\n#endif\n#ifndef IGNORE_SIGHUP_SIGQUIT\n  (void) sigaddset(&set,SIGQUIT);\n  (void) sigaddset(&set,SIGHUP);\n#endif\n  (void) sigaddset(&set,SIGTERM);\n  (void) sigaddset(&set,SIGTSTP);\n\n  /* Save pid to this process (or thread on Linux) */\n  if (!opt_bootstrap)\n    create_pid_file();\n\n  /*\n    signal to start_signal_handler that we are ready\n    This works by waiting for start_signal_handler to free mutex,\n    after which we signal it that we are ready.\n    At this pointer there is no other threads running, so there\n    should not be any other mysql_cond_signal() calls.\n  */\n  mysql_mutex_lock(&LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  mysql_cond_broadcast(&COND_thread_count);\n\n  (void) pthread_sigmask(SIG_BLOCK,&set,NULL);\n  for (;;)\n  {\n    int error;\t\t\t\t\t// Used when debugging\n    if (shutdown_in_progress && !abort_loop)\n    {\n      sig= SIGTERM;\n      error=0;\n    }\n    else\n      while ((error=my_sigwait(&set,&sig)) == EINTR) ;\n    if (cleanup_done)\n    {\n      DBUG_PRINT(\"quit\",(\"signal_handler: calling my_thread_end()\"));\n      my_thread_end();\n      signal_thread_in_use= 0;\n      DBUG_LEAVE;                               // Must match DBUG_ENTER()\n      pthread_exit(0);\t\t\t\t// Safety\n      return 0;                                 // Avoid compiler warnings\n    }\n    switch (sig) {\n    case SIGTERM:\n    case SIGQUIT:\n    case SIGKILL:\n#ifdef EXTRA_DEBUG\n      sql_print_information(\"Got signal %d to shutdown mysqld\",sig);\n#endif\n      /* switch to the old log message processing */\n      logger.set_handlers(LOG_FILE, opt_slow_log ? LOG_FILE:LOG_NONE,\n                          opt_log ? LOG_FILE:LOG_NONE);\n      DBUG_PRINT(\"info\",(\"Got signal: %d  abort_loop: %d\",sig,abort_loop));\n      if (!abort_loop)\n      {\n\tabort_loop=1;\t\t\t\t// mark abort for threads\n#ifdef HAVE_PSI_INTERFACE\n        /* Delete the instrumentation for the signal thread */\n        if (likely(PSI_server != NULL))\n          PSI_server->delete_current_thread();\n#endif\n#ifdef USE_ONE_SIGNAL_HAND\n\tpthread_t tmp;\n        if ((error= mysql_thread_create(0, /* Not instrumented */\n                                        &tmp, &connection_attrib,\n                                        kill_server_thread,\n                                        (void*) &sig)))\n          sql_print_error(\"Can't create thread to kill server (errno= %d)\",\n                          error);\n#else\n\tkill_server((void*) sig);\t// MIT THREAD has a alarm thread\n#endif\n      }\n      break;\n    case SIGHUP:\n      if (!abort_loop)\n      {\n        int not_used;\n\tmysql_print_status();\t\t// Print some debug info\n\treload_acl_and_cache((THD*) 0,\n\t\t\t     (REFRESH_LOG | REFRESH_TABLES | REFRESH_FAST |\n\t\t\t      REFRESH_GRANT |\n\t\t\t      REFRESH_THREADS | REFRESH_HOSTS),\n\t\t\t     (TABLE_LIST*) 0, &not_used); // Flush logs\n      }\n      /* reenable logs after the options were reloaded */\n      if (log_output_options & LOG_NONE)\n      {\n        logger.set_handlers(LOG_FILE,\n                            opt_slow_log ? LOG_TABLE : LOG_NONE,\n                            opt_log ? LOG_TABLE : LOG_NONE);\n      }\n      else\n      {\n        logger.set_handlers(LOG_FILE,\n                            opt_slow_log ? log_output_options : LOG_NONE,\n                            opt_log ? log_output_options : LOG_NONE);\n      }\n      break;\n#ifdef USE_ONE_SIGNAL_HAND\n    case THR_SERVER_ALARM:\n      process_alarm(sig);\t\t\t// Trigger alarms.\n      break;\n#endif\n    default:\n#ifdef EXTRA_DEBUG\n      sql_print_warning(\"Got signal: %d  error: %d\",sig,error); /* purecov: tested */\n#endif\n      break;\t\t\t\t\t/* purecov: tested */\n    }\n  }\n  return(0);\t\t\t\t\t/* purecov: deadcode */\n}\n\nstatic void check_data_home(const char *path)\n{}\n\n#endif /*!EMBEDDED_LIBRARY*/\n#endif\t/* __WIN__*/\n\n\n/**\n  All global error messages are sent here where the first one is stored\n  for the client.\n*/\n/* ARGSUSED */\nextern \"C\" void my_message_sql(uint error, const char *str, myf MyFlags);\n\nvoid my_message_sql(uint error, const char *str, myf MyFlags)\n{\n  THD *thd= current_thd;\n  DBUG_ENTER(\"my_message_sql\");\n  DBUG_PRINT(\"error\", (\"error: %u  message: '%s'\", error, str));\n\n  DBUG_ASSERT(str != NULL);\n  /*\n    An error should have a valid error number (!= 0), so it can be caught\n    in stored procedures by SQL exception handlers.\n    Calling my_error() with error == 0 is a bug.\n    Remaining known places to fix:\n    - storage/myisam/mi_create.c, my_printf_error()\n    TODO:\n    DBUG_ASSERT(error != 0);\n  */\n\n  if (error == 0)\n  {\n    /* At least, prevent new abuse ... */\n    DBUG_ASSERT(strncmp(str, \"MyISAM table\", 12) == 0);\n    error= ER_UNKNOWN_ERROR;\n  }\n\n  mysql_audit_general(thd, MYSQL_AUDIT_GENERAL_ERROR, error, str);\n\n  if (thd)\n  {\n    if (MyFlags & ME_FATALERROR)\n      thd->is_fatal_error= 1;\n    (void) thd->raise_condition(error,\n                                NULL,\n                                MYSQL_ERROR::WARN_LEVEL_ERROR,\n                                str);\n  }\n\n  /* When simulating OOM, skip writing to error log to avoid mtr errors */\n  DBUG_EXECUTE_IF(\"simulate_out_of_memory\", DBUG_VOID_RETURN;);\n\n  if (!thd || MyFlags & ME_NOREFRESH)\n    sql_print_error(\"%s: %s\",my_progname,str); /* purecov: inspected */\n  DBUG_VOID_RETURN;\n}\n\n\n#ifndef EMBEDDED_LIBRARY\nextern \"C\" void *my_str_malloc_mysqld(size_t size);\nextern \"C\" void my_str_free_mysqld(void *ptr);\n\nvoid *my_str_malloc_mysqld(size_t size)\n{\n  return my_malloc(size, MYF(MY_FAE));\n}\n\n\nvoid my_str_free_mysqld(void *ptr)\n{\n  my_free(ptr);\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n#ifdef __WIN__\n\npthread_handler_t handle_shutdown(void *arg)\n{\n  MSG msg;\n  my_thread_init();\n\n  /* this call should create the message queue for this thread */\n  PeekMessage(&msg, NULL, 1, 65534,PM_NOREMOVE);\n#if !defined(EMBEDDED_LIBRARY)\n  if (WaitForSingleObject(hEventShutdown,INFINITE)==WAIT_OBJECT_0)\n#endif /* EMBEDDED_LIBRARY */\n     kill_server(MYSQL_KILL_SIGNAL);\n  return 0;\n}\n#endif\n\nconst char *load_default_groups[]= {\n#ifdef WITH_NDBCLUSTER_STORAGE_ENGINE\n\"mysql_cluster\",\n#endif\n\"mysqld\",\"server\", MYSQL_BASE_VERSION, 0, 0};\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\nstatic const int load_default_groups_sz=\nsizeof(load_default_groups)/sizeof(load_default_groups[0]);\n#endif\n\n\n#ifndef EMBEDDED_LIBRARY\n/**\n  This function is used to check for stack overrun for pathological\n  cases of  regular expressions and 'like' expressions.\n  The call to current_thd is  quite expensive, so we try to avoid it\n  for the normal cases.\n  The size of  each stack frame for the wildcmp() routines is ~128 bytes,\n  so checking  *every* recursive call is not necessary.\n */\nextern \"C\" int\ncheck_enough_stack_size(int recurse_level)\n{\n  uchar stack_top;\n  if (recurse_level % 16 != 0)\n    return 0;\n\n  THD *my_thd= current_thd;\n  if (my_thd != NULL)\n    return check_stack_overrun(my_thd, STACK_MIN_SIZE * 2, &stack_top);\n  return 0;\n}\n#endif\n\n\n/**\n  Initialize one of the global date/time format variables.\n\n  @param format_type\t\tWhat kind of format should be supported\n  @param var_ptr\t\tPointer to variable that should be updated\n\n  @retval\n    0 ok\n  @retval\n    1 error\n*/\n\nstatic bool init_global_datetime_format(timestamp_type format_type,\n                                        DATE_TIME_FORMAT *format)\n{\n  /*\n    Get command line option\n    format->format.str is already set by my_getopt\n  */\n  format->format.length= strlen(format->format.str);\n\n  if (parse_date_time_format(format_type, format))\n  {\n    fprintf(stderr, \"Wrong date/time format specifier: %s\\n\",\n            format->format.str);\n    return true;\n  }\n  return false;\n}\n\nSHOW_VAR com_status_vars[]= {\n  {\"admin_commands\",       (char*) offsetof(STATUS_VAR, com_other), SHOW_LONG_STATUS},\n  {\"assign_to_keycache\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ASSIGN_TO_KEYCACHE]), SHOW_LONG_STATUS},\n  {\"alter_db\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_DB]), SHOW_LONG_STATUS},\n  {\"alter_db_upgrade\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_DB_UPGRADE]), SHOW_LONG_STATUS},\n  {\"alter_event\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_EVENT]), SHOW_LONG_STATUS},\n  {\"alter_function\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_FUNCTION]), SHOW_LONG_STATUS},\n  {\"alter_procedure\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_PROCEDURE]), SHOW_LONG_STATUS},\n  {\"alter_server\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_SERVER]), SHOW_LONG_STATUS},\n  {\"alter_table\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_TABLE]), SHOW_LONG_STATUS},\n  {\"alter_tablespace\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ALTER_TABLESPACE]), SHOW_LONG_STATUS},\n  {\"analyze\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ANALYZE]), SHOW_LONG_STATUS},\n  {\"begin\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_BEGIN]), SHOW_LONG_STATUS},\n  {\"binlog\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_BINLOG_BASE64_EVENT]), SHOW_LONG_STATUS},\n  {\"call_procedure\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CALL]), SHOW_LONG_STATUS},\n  {\"change_db\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHANGE_DB]), SHOW_LONG_STATUS},\n  {\"change_master\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHANGE_MASTER]), SHOW_LONG_STATUS},\n  {\"check\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHECK]), SHOW_LONG_STATUS},\n  {\"checksum\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CHECKSUM]), SHOW_LONG_STATUS},\n  {\"commit\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_COMMIT]), SHOW_LONG_STATUS},\n  {\"create_db\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_DB]), SHOW_LONG_STATUS},\n  {\"create_event\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_EVENT]), SHOW_LONG_STATUS},\n  {\"create_function\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_SPFUNCTION]), SHOW_LONG_STATUS},\n  {\"create_index\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_INDEX]), SHOW_LONG_STATUS},\n  {\"create_procedure\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_PROCEDURE]), SHOW_LONG_STATUS},\n  {\"create_server\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_SERVER]), SHOW_LONG_STATUS},\n  {\"create_table\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_TABLE]), SHOW_LONG_STATUS},\n  {\"create_trigger\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_TRIGGER]), SHOW_LONG_STATUS},\n  {\"create_udf\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_FUNCTION]), SHOW_LONG_STATUS},\n  {\"create_user\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_USER]), SHOW_LONG_STATUS},\n  {\"create_view\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_CREATE_VIEW]), SHOW_LONG_STATUS},\n  {\"dealloc_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DEALLOCATE_PREPARE]), SHOW_LONG_STATUS},\n  {\"delete\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DELETE]), SHOW_LONG_STATUS},\n  {\"delete_multi\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DELETE_MULTI]), SHOW_LONG_STATUS},\n  {\"do\",                   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DO]), SHOW_LONG_STATUS},\n  {\"drop_db\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_DB]), SHOW_LONG_STATUS},\n  {\"drop_event\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_EVENT]), SHOW_LONG_STATUS},\n  {\"drop_function\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_FUNCTION]), SHOW_LONG_STATUS},\n  {\"drop_index\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_INDEX]), SHOW_LONG_STATUS},\n  {\"drop_procedure\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_PROCEDURE]), SHOW_LONG_STATUS},\n  {\"drop_server\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_SERVER]), SHOW_LONG_STATUS},\n  {\"drop_table\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_TABLE]), SHOW_LONG_STATUS},\n  {\"drop_trigger\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_TRIGGER]), SHOW_LONG_STATUS},\n  {\"drop_user\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_USER]), SHOW_LONG_STATUS},\n  {\"drop_view\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_VIEW]), SHOW_LONG_STATUS},\n  {\"empty_query\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EMPTY_QUERY]), SHOW_LONG_STATUS},\n  {\"execute_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EXECUTE]), SHOW_LONG_STATUS},\n  {\"flush\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_FLUSH]), SHOW_LONG_STATUS},\n  {\"grant\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_GRANT]), SHOW_LONG_STATUS},\n  {\"ha_close\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_CLOSE]), SHOW_LONG_STATUS},\n  {\"ha_open\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_OPEN]), SHOW_LONG_STATUS},\n  {\"ha_read\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HA_READ]), SHOW_LONG_STATUS},\n  {\"help\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_HELP]), SHOW_LONG_STATUS},\n  {\"insert\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSERT]), SHOW_LONG_STATUS},\n  {\"insert_select\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSERT_SELECT]), SHOW_LONG_STATUS},\n  {\"install_plugin\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_INSTALL_PLUGIN]), SHOW_LONG_STATUS},\n  {\"kill\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_KILL]), SHOW_LONG_STATUS},\n  {\"load\",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOAD]), SHOW_LONG_STATUS},\n  {\"lock_tables\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOCK_TABLES]), SHOW_LONG_STATUS},\n  {\"optimize\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_OPTIMIZE]), SHOW_LONG_STATUS},\n  {\"preload_keys\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PRELOAD_KEYS]), SHOW_LONG_STATUS},\n  {\"prepare_sql\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PREPARE]), SHOW_LONG_STATUS},\n  {\"purge\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PURGE]), SHOW_LONG_STATUS},\n  {\"purge_before_date\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PURGE_BEFORE]), SHOW_LONG_STATUS},\n  {\"release_savepoint\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RELEASE_SAVEPOINT]), SHOW_LONG_STATUS},\n  {\"rename_table\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RENAME_TABLE]), SHOW_LONG_STATUS},\n  {\"rename_user\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RENAME_USER]), SHOW_LONG_STATUS},\n  {\"repair\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPAIR]), SHOW_LONG_STATUS},\n  {\"replace\",              (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPLACE]), SHOW_LONG_STATUS},\n  {\"replace_select\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REPLACE_SELECT]), SHOW_LONG_STATUS},\n  {\"reset\",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RESET]), SHOW_LONG_STATUS},\n  {\"resignal\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_RESIGNAL]), SHOW_LONG_STATUS},\n  {\"revoke\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REVOKE]), SHOW_LONG_STATUS},\n  {\"revoke_all\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_REVOKE_ALL]), SHOW_LONG_STATUS},\n  {\"rollback\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ROLLBACK]), SHOW_LONG_STATUS},\n  {\"rollback_to_savepoint\",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ROLLBACK_TO_SAVEPOINT]), SHOW_LONG_STATUS},\n  {\"savepoint\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SAVEPOINT]), SHOW_LONG_STATUS},\n  {\"select\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SELECT]), SHOW_LONG_STATUS},\n  {\"set_option\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SET_OPTION]), SHOW_LONG_STATUS},\n  {\"signal\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SIGNAL]), SHOW_LONG_STATUS},\n  {\"show_authors\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_AUTHORS]), SHOW_LONG_STATUS},\n  {\"show_binlog_events\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOG_EVENTS]), SHOW_LONG_STATUS},\n  {\"show_binlogs\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOGS]), SHOW_LONG_STATUS},\n  {\"show_charsets\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CHARSETS]), SHOW_LONG_STATUS},\n  {\"show_collations\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_COLLATIONS]), SHOW_LONG_STATUS},\n  {\"show_contributors\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CONTRIBUTORS]), SHOW_LONG_STATUS},\n  {\"show_create_db\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_DB]), SHOW_LONG_STATUS},\n  {\"show_create_event\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_EVENT]), SHOW_LONG_STATUS},\n  {\"show_create_func\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_FUNC]), SHOW_LONG_STATUS},\n  {\"show_create_proc\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_PROC]), SHOW_LONG_STATUS},\n  {\"show_create_table\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE]), SHOW_LONG_STATUS},\n  {\"show_create_trigger\",  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CREATE_TRIGGER]), SHOW_LONG_STATUS},\n  {\"show_databases\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_DATABASES]), SHOW_LONG_STATUS},\n  {\"show_engine_logs\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_LOGS]), SHOW_LONG_STATUS},\n  {\"show_engine_mutex\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_MUTEX]), SHOW_LONG_STATUS},\n  {\"show_engine_status\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ENGINE_STATUS]), SHOW_LONG_STATUS},\n  {\"show_events\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_EVENTS]), SHOW_LONG_STATUS},\n  {\"show_errors\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_ERRORS]), SHOW_LONG_STATUS},\n  {\"show_fields\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_FIELDS]), SHOW_LONG_STATUS},\n#ifndef DBUG_OFF\n  {\"show_function_code\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_FUNC_CODE]), SHOW_LONG_STATUS},\n#endif\n  {\"show_function_status\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS_FUNC]), SHOW_LONG_STATUS},\n  {\"show_grants\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_GRANTS]), SHOW_LONG_STATUS},\n  {\"show_keys\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_KEYS]), SHOW_LONG_STATUS},\n  {\"show_master_status\",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_MASTER_STAT]), SHOW_LONG_STATUS},\n  {\"show_open_tables\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_OPEN_TABLES]), SHOW_LONG_STATUS},\n  {\"show_plugins\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PLUGINS]), SHOW_LONG_STATUS},\n  {\"show_privileges\",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PRIVILEGES]), SHOW_LONG_STATUS},\n#ifndef DBUG_OFF\n  {\"show_procedure_code\",  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROC_CODE]), SHOW_LONG_STATUS},\n#endif\n  {\"show_procedure_status\",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS_PROC]), SHOW_LONG_STATUS},\n  {\"show_processlist\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROCESSLIST]), SHOW_LONG_STATUS},\n  {\"show_profile\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROFILE]), SHOW_LONG_STATUS},\n  {\"show_profiles\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROFILES]), SHOW_LONG_STATUS},\n  {\"show_relaylog_events\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_RELAYLOG_EVENTS]), SHOW_LONG_STATUS},\n  {\"show_slave_hosts\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_HOSTS]), SHOW_LONG_STATUS},\n  {\"show_slave_status\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_STAT]), SHOW_LONG_STATUS},\n  {\"show_status\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS]), SHOW_LONG_STATUS},\n  {\"show_storage_engines\", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STORAGE_ENGINES]), SHOW_LONG_STATUS},\n  {\"show_table_status\",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATUS]), SHOW_LONG_STATUS},\n  {\"show_tables\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLES]), SHOW_LONG_STATUS},\n  {\"show_triggers\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TRIGGERS]), SHOW_LONG_STATUS},\n  {\"show_variables\",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_VARIABLES]), SHOW_LONG_STATUS},\n  {\"show_warnings\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_WARNS]), SHOW_LONG_STATUS},\n  {\"slave_start\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SLAVE_START]), SHOW_LONG_STATUS},\n  {\"slave_stop\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SLAVE_STOP]), SHOW_LONG_STATUS},\n  {\"stmt_close\",           (char*) offsetof(STATUS_VAR, com_stmt_close), SHOW_LONG_STATUS},\n  {\"stmt_execute\",         (char*) offsetof(STATUS_VAR, com_stmt_execute), SHOW_LONG_STATUS},\n  {\"stmt_fetch\",           (char*) offsetof(STATUS_VAR, com_stmt_fetch), SHOW_LONG_STATUS},\n  {\"stmt_prepare\",         (char*) offsetof(STATUS_VAR, com_stmt_prepare), SHOW_LONG_STATUS},\n  {\"stmt_reprepare\",       (char*) offsetof(STATUS_VAR, com_stmt_reprepare), SHOW_LONG_STATUS},\n  {\"stmt_reset\",           (char*) offsetof(STATUS_VAR, com_stmt_reset), SHOW_LONG_STATUS},\n  {\"stmt_send_long_data\",  (char*) offsetof(STATUS_VAR, com_stmt_send_long_data), SHOW_LONG_STATUS},\n  {\"truncate\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_TRUNCATE]), SHOW_LONG_STATUS},\n  {\"uninstall_plugin\",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UNINSTALL_PLUGIN]), SHOW_LONG_STATUS},\n  {\"unlock_tables\",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UNLOCK_TABLES]), SHOW_LONG_STATUS},\n  {\"update\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UPDATE]), SHOW_LONG_STATUS},\n  {\"update_multi\",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_UPDATE_MULTI]), SHOW_LONG_STATUS},\n  {\"xa_commit\",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_COMMIT]),SHOW_LONG_STATUS},\n  {\"xa_end\",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_END]),SHOW_LONG_STATUS},\n  {\"xa_prepare\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_PREPARE]),SHOW_LONG_STATUS},\n  {\"xa_recover\",           (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_RECOVER]),SHOW_LONG_STATUS},\n  {\"xa_rollback\",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_ROLLBACK]),SHOW_LONG_STATUS},\n  {\"xa_start\",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_XA_START]),SHOW_LONG_STATUS},\n  {NullS, NullS, SHOW_LONG}\n};\n\nLEX_CSTRING sql_statement_names[(uint) SQLCOM_END + 1];\n\nvoid init_sql_statement_names()\n{\n  static LEX_CSTRING empty= { C_STRING_WITH_LEN(\"\") };\n\n  char *first_com= (char*) offsetof(STATUS_VAR, com_stat[0]);\n  char *last_com= (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_END]);\n  int record_size= (char*) offsetof(STATUS_VAR, com_stat[1])\n                   - (char*) offsetof(STATUS_VAR, com_stat[0]);\n  char *ptr;\n  uint i;\n  uint com_index;\n\n  for (i= 0; i < ((uint) SQLCOM_END + 1); i++)\n    sql_statement_names[i]= empty;\n\n  SHOW_VAR *var= &com_status_vars[0];\n  while (var->name != NULL)\n  {\n    ptr= var->value;\n    if ((first_com <= ptr) && (ptr <= last_com))\n    {\n      com_index= ((int)(ptr - first_com))/record_size;\n      DBUG_ASSERT(com_index < (uint) SQLCOM_END);\n      sql_statement_names[com_index].str= var->name;\n      /* TODO: Change SHOW_VAR::name to a LEX_STRING, to avoid strlen() */\n      sql_statement_names[com_index].length= strlen(var->name);\n    }\n    var++;\n  }\n\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint) SQLCOM_SELECT].str, \"select\") == 0);\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint) SQLCOM_SIGNAL].str, \"signal\") == 0);\n\n  sql_statement_names[(uint) SQLCOM_END].str= \"error\";\n}\n\n/**\n  Create the name of the default general log file\n  \n  @param[IN] buff    Location for building new string.\n  @param[IN] log_ext The extension for the file (e.g .log)\n  @returns Pointer to a new string containing the name\n*/\nstatic inline char *make_default_log_name(char *buff,const char* log_ext)\n{\n  return make_log_name(buff, default_logfile_name, log_ext);\n}\n\nstatic int init_common_variables()\n{\n  char buff[FN_REFLEN];\n  umask(((~my_umask) & 0666));\n  my_decimal_set_zero(&decimal_zero); // set decimal_zero constant;\n  tzset();\t\t\t// Set tzname\n\n  max_system_variables.pseudo_thread_id= (ulong)~0;\n  server_start_time= flush_status_time= my_time(0);\n\n  rpl_filter= new Rpl_filter;\n  binlog_filter= new Rpl_filter;\n  if (!rpl_filter || !binlog_filter)\n  {\n    sql_perror(\"Could not allocate replication and binlog filters\");\n    return 1;\n  }\n\n  if (init_thread_environment() ||\n      mysql_init_variables())\n    return 1;\n\n#ifdef HAVE_TZNAME\n  {\n    struct tm tm_tmp;\n    localtime_r(&server_start_time,&tm_tmp);\n    strmake(system_time_zone, tzname[tm_tmp.tm_isdst != 0 ? 1 : 0],\n            sizeof(system_time_zone)-1);\n\n }\n#endif\n  /*\n    We set SYSTEM time zone as reasonable default and\n    also for failure of my_tz_init() and bootstrap mode.\n    If user explicitly set time zone with --default-time-zone\n    option we will change this value in my_tz_init().\n  */\n  global_system_variables.time_zone= my_tz_SYSTEM;\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Complete the mysql_bin_log initialization.\n    Instrumentation keys are known only after the performance schema initialization,\n    and can not be set in the MYSQL_BIN_LOG constructor (called before main()).\n  */\n  mysql_bin_log.set_psi_keys(key_BINLOG_LOCK_index,\n                             key_BINLOG_update_cond,\n                             key_file_binlog,\n                             key_file_binlog_index);\n#endif\n\n  /*\n    Init mutexes for the global MYSQL_BIN_LOG objects.\n    As safe_mutex depends on what MY_INIT() does, we can't init the mutexes of\n    global MYSQL_BIN_LOGs in their constructors, because then they would be\n    inited before MY_INIT(). So we do it here.\n  */\n  mysql_bin_log.init_pthread_objects();\n\n  /* TODO: remove this when my_time_t is 64 bit compatible */\n  if (!IS_TIME_T_VALID_FOR_TIMESTAMP(server_start_time))\n  {\n    sql_print_error(\"This MySQL server doesn't support dates later then 2038\");\n    return 1;\n  }\n\n  if (gethostname(glob_hostname,sizeof(glob_hostname)) < 0)\n  {\n    strmake(glob_hostname, STRING_WITH_LEN(\"localhost\"));\n    sql_print_warning(\"gethostname failed, using '%s' as hostname\",\n                      glob_hostname);\n    strmake(default_logfile_name, STRING_WITH_LEN(\"mysql\"));\n  }\n  else\n    strmake(default_logfile_name, glob_hostname, \n\t    sizeof(default_logfile_name)-5);\n\n  strmake(pidfile_name, default_logfile_name, sizeof(pidfile_name)-5);\n  strmov(fn_ext(pidfile_name),\".pid\");\t\t// Add proper extension\n\n  /*\n    The default-storage-engine entry in my_long_options should have a\n    non-null default value. It was earlier intialized as\n    (longlong)\"MyISAM\" in my_long_options but this triggered a\n    compiler error in the Sun Studio 12 compiler. As a work-around we\n    set the def_value member to 0 in my_long_options and initialize it\n    to the correct value here.\n\n    From MySQL 5.5 onwards, the default storage engine is InnoDB\n    (except in the embedded server, where the default continues to\n    be MyISAM)\n  */\n#ifdef EMBEDDED_LIBRARY\n  default_storage_engine= const_cast<char *>(\"MyISAM\");\n#else\n  default_storage_engine= const_cast<char *>(\"InnoDB\");\n#endif\n\n  /*\n    Add server status variables to the dynamic list of\n    status variables that is shown by SHOW STATUS.\n    Later, in plugin_init, and mysql_install_plugin\n    new entries could be added to that list.\n  */\n  if (add_status_vars(status_vars))\n    return 1; // an error was already reported\n\n#ifndef DBUG_OFF\n  /*\n    We have few debug-only commands in com_status_vars, only visible in debug\n    builds. for simplicity we enable the assert only in debug builds\n\n    There are 8 Com_ variables which don't have corresponding SQLCOM_ values:\n    (TODO strictly speaking they shouldn't be here, should not have Com_ prefix\n    that is. Perhaps Stmt_ ? Comstmt_ ? Prepstmt_ ?)\n\n      Com_admin_commands       => com_other\n      Com_stmt_close           => com_stmt_close\n      Com_stmt_execute         => com_stmt_execute\n      Com_stmt_fetch           => com_stmt_fetch\n      Com_stmt_prepare         => com_stmt_prepare\n      Com_stmt_reprepare       => com_stmt_reprepare\n      Com_stmt_reset           => com_stmt_reset\n      Com_stmt_send_long_data  => com_stmt_send_long_data\n\n    With this correction the number of Com_ variables (number of elements in\n    the array, excluding the last element - terminator) must match the number\n    of SQLCOM_ constants.\n  */\n  compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==\n                     SQLCOM_END + 8);\n#endif\n\n  if (get_options(&remaining_argc, &remaining_argv))\n    return 1;\n  set_server_version();\n\n  sql_print_information(\"%s (mysqld %s) starting as process %lu ...\",\n                        my_progname, server_version, (ulong) getpid());\n\n#ifndef EMBEDDED_LIBRARY\n  if (opt_help && !opt_verbose)\n    unireg_abort(0);\n#endif /*!EMBEDDED_LIBRARY*/\n\n  DBUG_PRINT(\"info\",(\"%s  Ver %s for %s on %s\\n\",my_progname,\n\t\t     server_version, SYSTEM_TYPE,MACHINE_TYPE));\n\n#ifdef HAVE_LARGE_PAGES\n  /* Initialize large page size */\n  if (opt_large_pages && (opt_large_page_size= my_get_large_page_size()))\n  {\n      DBUG_PRINT(\"info\", (\"Large page set, large_page_size = %d\",\n                 opt_large_page_size));\n      my_use_large_pages= 1;\n      my_large_page_size= opt_large_page_size;\n  }\n  else\n  {\n    opt_large_pages= 0;\n    /* \n       Either not configured to use large pages or Linux haven't\n       been compiled with large page support\n    */\n  }\n#endif /* HAVE_LARGE_PAGES */\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#define LARGE_PAGESIZE (4*1024*1024)  /* 4MB */\n#define SUPER_LARGE_PAGESIZE (256*1024*1024)  /* 256MB */\n  if (opt_large_pages)\n  {\n  /*\n    tell the kernel that we want to use 4/256MB page for heap storage\n    and also for the stack. We use 4 MByte as default and if the\n    super-large-page is set we increase it to 256 MByte. 256 MByte\n    is for server installations with GBytes of RAM memory where\n    the MySQL Server will have page caches and other memory regions\n    measured in a number of GBytes.\n    We use as big pages as possible which isn't bigger than the above\n    desired page sizes.\n  */\n   int nelem;\n   size_t max_desired_page_size;\n   if (opt_super_large_pages)\n     max_desired_page_size= SUPER_LARGE_PAGESIZE;\n   else\n     max_desired_page_size= LARGE_PAGESIZE;\n   nelem = getpagesizes(NULL, 0);\n   if (nelem > 0)\n   {\n     size_t *pagesize = (size_t *) malloc(sizeof(size_t) * nelem);\n     if (pagesize != NULL && getpagesizes(pagesize, nelem) > 0)\n     {\n       size_t max_page_size= 0;\n       for (int i= 0; i < nelem; i++)\n       {\n         if (pagesize[i] > max_page_size &&\n             pagesize[i] <= max_desired_page_size)\n            max_page_size= pagesize[i];\n       }\n       free(pagesize);\n       if (max_page_size > 0)\n       {\n         struct memcntl_mha mpss;\n\n         mpss.mha_cmd= MHA_MAPSIZE_BSSBRK;\n         mpss.mha_pagesize= max_page_size;\n         mpss.mha_flags= 0;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n         mpss.mha_cmd= MHA_MAPSIZE_STACK;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n       }\n     }\n   }\n  }\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n  /* connections and databases needs lots of files */\n  {\n    uint files, wanted_files, max_open_files;\n\n    /* MyISAM requires two file handles per table. */\n    wanted_files= 10+max_connections+table_cache_size*2;\n    /*\n      We are trying to allocate no less than max_connections*5 file\n      handles (i.e. we are trying to set the limit so that they will\n      be available).  In addition, we allocate no less than how much\n      was already allocated.  However below we report a warning and\n      recompute values only if we got less file handles than were\n      explicitly requested.  No warning and re-computation occur if we\n      can't get max_connections*5 but still got no less than was\n      requested (value of wanted_files).\n    */\n    max_open_files= max(max(wanted_files, max_connections*5),\n                        open_files_limit);\n    files= my_set_max_open_files(max_open_files);\n\n    if (files < wanted_files)\n    {\n      if (!open_files_limit)\n      {\n        /*\n          If we have requested too much file handles than we bring\n          max_connections in supported bounds.\n        */\n        max_connections= (ulong) min(files-10-TABLE_OPEN_CACHE_MIN*2,\n                                     max_connections);\n        /*\n          Decrease table_cache_size according to max_connections, but\n          not below TABLE_OPEN_CACHE_MIN.  Outer min() ensures that we\n          never increase table_cache_size automatically (that could\n          happen if max_connections is decreased above).\n        */\n        table_cache_size= (ulong) min(max((files-10-max_connections)/2,\n                                          TABLE_OPEN_CACHE_MIN),\n                                      table_cache_size);\n\tDBUG_PRINT(\"warning\",\n\t\t   (\"Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld\",\n\t\t    files, max_connections, table_cache_size));\n\tif (global_system_variables.log_warnings)\n\t  sql_print_warning(\"Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld\",\n\t\t\tfiles, max_connections, table_cache_size);\n      }\n      else if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Could not increase number of max_open_files to more than %u (request: %u)\", files, wanted_files);\n    }\n    open_files_limit= files;\n  }\n  unireg_init(opt_specialflag); /* Set up extern variabels */\n  if (!(my_default_lc_messages=\n        my_locale_by_name(lc_messages)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_messages);\n    return 1;\n  }\n  global_system_variables.lc_messages= my_default_lc_messages;\n  if (init_errmessage())\t/* Read error messages from file */\n    return 1;\n  init_client_errs();\n  mysql_client_plugin_init();\n  lex_init();\n  if (item_create_init())\n    return 1;\n  item_init();\n#ifndef EMBEDDED_LIBRARY\n  my_regex_init(&my_charset_latin1, check_enough_stack_size);\n  my_string_stack_guard= check_enough_stack_size;\n#else\n  my_regex_init(&my_charset_latin1, NULL);\n#endif\n  /*\n    Process a comma-separated character set list and choose\n    the first available character set. This is mostly for\n    test purposes, to be able to start \"mysqld\" even if\n    the requested character set is not available (see bug#18743).\n  */\n  for (;;)\n  {\n    char *next_character_set_name= strchr(default_character_set_name, ',');\n    if (next_character_set_name)\n      *next_character_set_name++= '\\0';\n    if (!(default_charset_info=\n          get_charset_by_csname(default_character_set_name,\n                                MY_CS_PRIMARY, MYF(MY_WME))))\n    {\n      if (next_character_set_name)\n      {\n        default_character_set_name= next_character_set_name;\n        default_collation_name= 0;          // Ignore collation\n      }\n      else\n        return 1;                           // Eof of the list\n    }\n    else\n      break;\n  }\n\n  if (default_collation_name)\n  {\n    CHARSET_INFO *default_collation;\n    default_collation= get_charset_by_name(default_collation_name, MYF(0));\n    if (!default_collation)\n    {\n      sql_print_error(ER_DEFAULT(ER_UNKNOWN_COLLATION), default_collation_name);\n      return 1;\n    }\n    if (!my_charset_same(default_charset_info, default_collation))\n    {\n      sql_print_error(ER_DEFAULT(ER_COLLATION_CHARSET_MISMATCH),\n\t\t      default_collation_name,\n\t\t      default_charset_info->csname);\n      return 1;\n    }\n    default_charset_info= default_collation;\n  }\n  /* Set collactions that depends on the default collation */\n  global_system_variables.collation_server=\t default_charset_info;\n  global_system_variables.collation_database=\t default_charset_info;\n\n  if (is_supported_parser_charset(default_charset_info))\n  {\n    global_system_variables.collation_connection= default_charset_info;\n    global_system_variables.character_set_results= default_charset_info;\n    global_system_variables.character_set_client= default_charset_info;\n  }\n  else\n  {\n    sql_print_information(\"'%s' can not be used as client character set. \"\n                          \"'%s' will be used as default client character set.\",\n                          default_charset_info->csname,\n                          my_charset_latin1.csname);\n    global_system_variables.collation_connection= &my_charset_latin1;\n    global_system_variables.character_set_results= &my_charset_latin1;\n    global_system_variables.character_set_client= &my_charset_latin1;\n  }\n\n  if (!(character_set_filesystem= \n        get_charset_by_csname(character_set_filesystem_name,\n                              MY_CS_PRIMARY, MYF(MY_WME))))\n    return 1;\n  global_system_variables.character_set_filesystem= character_set_filesystem;\n\n  if (!(my_default_lc_time_names=\n        my_locale_by_name(lc_time_names_name)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_time_names_name);\n    return 1;\n  }\n  global_system_variables.lc_time_names= my_default_lc_time_names;\n\n  /* check log options and issue warnings if needed */\n  if (opt_log && opt_logname && !(log_output_options & LOG_FILE) &&\n      !(log_output_options & LOG_NONE))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--log option, log tables are used. \"\n                      \"To enable logging to files use the --log-output option.\");\n\n  if (opt_slow_log && opt_slow_logname && !(log_output_options & LOG_FILE)\n      && !(log_output_options & LOG_NONE))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--log-slow-queries option, log tables are used. \"\n                      \"To enable logging to files use the --log-output=file option.\");\n\n  if (opt_logname &&\n      !is_valid_log_name(opt_logname, strlen(opt_logname)))\n  {\n    sql_print_error(\"Invalid value for --general_log_file: %s\",\n                    opt_logname);\n    return 1;\n  }\n\n  if (opt_slow_logname &&\n      !is_valid_log_name(opt_slow_logname, strlen(opt_slow_logname)))\n  {\n    sql_print_error(\"Invalid value for --slow_query_log_file: %s\",\n                    opt_slow_logname);\n    return 1;\n  }\n\n#define FIX_LOG_VAR(VAR, ALT)                                   \\\n  if (!VAR || !*VAR)                                            \\\n  {                                                             \\\n    my_free(VAR); /* it could be an allocated empty string \"\" */ \\\n    VAR= my_strdup(ALT, MYF(0));                                \\\n  }\n\n  FIX_LOG_VAR(opt_logname,\n              make_default_log_name(buff, \".log\"));\n  FIX_LOG_VAR(opt_slow_logname,\n              make_default_log_name(buff, \"-slow.log\"));\n\n#if defined(ENABLED_DEBUG_SYNC)\n  /* Initialize the debug sync facility. See debug_sync.cc. */\n  if (debug_sync_init())\n    return 1; /* purecov: tested */\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n#if (ENABLE_TEMP_POOL)\n  if (use_temp_pool && bitmap_init(&temp_pool,0,1024,1))\n    return 1;\n#else\n  use_temp_pool= 0;\n#endif\n\n  if (my_dboptions_cache_init())\n    return 1;\n\n  /*\n    Ensure that lower_case_table_names is set on system where we have case\n    insensitive names.  If this is not done the users MyISAM tables will\n    get corrupted if accesses with names of different case.\n  */\n  DBUG_PRINT(\"info\", (\"lower_case_table_names: %d\", lower_case_table_names));\n  lower_case_file_system= test_if_case_insensitive(mysql_real_data_home);\n  if (!lower_case_table_names && lower_case_file_system == 1)\n  {\n    if (lower_case_table_names_used)\n    {\n      sql_print_error(\"The server option 'lower_case_table_names' is \"\n                      \"configured to use case sensitive table names but the \"\n                      \"data directory is on a case-insensitive file system \"\n                      \"which is an unsupported combination. Please consider \"\n                      \"either using a case sensitive file system for your data \"\n                      \"directory or switching to a case-insensitive table name \"\n                      \"mode.\");\n      return 1;\n    }\n    else\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Setting lower_case_table_names=2 because file system for %s is case insensitive\", mysql_real_data_home);\n      lower_case_table_names= 2;\n    }\n  }\n  else if (lower_case_table_names == 2 &&\n           !(lower_case_file_system=\n             (test_if_case_insensitive(mysql_real_data_home) == 1)))\n  {\n    if (global_system_variables.log_warnings)\n      sql_print_warning(\"lower_case_table_names was set to 2, even though your \"\n                        \"the file system '%s' is case sensitive.  Now setting \"\n                        \"lower_case_table_names to 0 to avoid future problems.\",\n\t\t\tmysql_real_data_home);\n    lower_case_table_names= 0;\n  }\n  else\n  {\n    lower_case_file_system=\n      (test_if_case_insensitive(mysql_real_data_home) == 1);\n  }\n\n  /* Reset table_alias_charset, now that lower_case_table_names is set. */\n  table_alias_charset= (lower_case_table_names ?\n\t\t\tfiles_charset_info :\n\t\t\t&my_charset_bin);\n\n  return 0;\n}\n\n\nstatic int init_thread_environment()\n{\n  mysql_mutex_init(key_LOCK_thread_created, &LOCK_thread_created, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_thread_count, &LOCK_thread_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_status, &LOCK_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_thd_remove,\n                   &LOCK_thd_remove, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_insert,\n                   &LOCK_delayed_insert, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_status,\n                   &LOCK_delayed_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_create,\n                   &LOCK_delayed_create, MY_MUTEX_INIT_SLOW);\n  mysql_mutex_init(key_LOCK_manager,\n                   &LOCK_manager, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_crypt, &LOCK_crypt, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_user_conn, &LOCK_user_conn, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_active_mi, &LOCK_active_mi, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_system_variables,\n                   &LOCK_global_system_variables, MY_MUTEX_INIT_FAST);\n  mysql_rwlock_init(key_rwlock_LOCK_system_variables_hash,\n                    &LOCK_system_variables_hash);\n  mysql_mutex_init(key_LOCK_prepared_stmt_count,\n                   &LOCK_prepared_stmt_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_error_messages,\n                   &LOCK_error_messages, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_uuid_generator,\n                   &LOCK_uuid_generator, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_connection_count,\n                   &LOCK_connection_count, MY_MUTEX_INIT_FAST);\n#ifdef HAVE_OPENSSL\n  mysql_mutex_init(key_LOCK_des_key_file,\n                   &LOCK_des_key_file, MY_MUTEX_INIT_FAST);\n#ifndef HAVE_YASSL\n  openssl_stdlocks= (openssl_lock_t*) OPENSSL_malloc(CRYPTO_num_locks() *\n                                                     sizeof(openssl_lock_t));\n  for (int i= 0; i < CRYPTO_num_locks(); ++i)\n    mysql_rwlock_init(key_rwlock_openssl, &openssl_stdlocks[i].lock);\n  CRYPTO_set_dynlock_create_callback(openssl_dynlock_create);\n  CRYPTO_set_dynlock_destroy_callback(openssl_dynlock_destroy);\n  CRYPTO_set_dynlock_lock_callback(openssl_lock);\n  CRYPTO_set_locking_callback(openssl_lock_function);\n  CRYPTO_set_id_callback(openssl_id_function);\n#endif\n#endif\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_connect, &LOCK_sys_init_connect);\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_slave, &LOCK_sys_init_slave);\n  mysql_rwlock_init(key_rwlock_LOCK_grant, &LOCK_grant);\n  mysql_cond_init(key_COND_thread_count, &COND_thread_count, NULL);\n  mysql_cond_init(key_COND_thread_cache, &COND_thread_cache, NULL);\n  mysql_cond_init(key_COND_flush_thread_cache, &COND_flush_thread_cache, NULL);\n  mysql_cond_init(key_COND_manager, &COND_manager, NULL);\n#ifdef HAVE_REPLICATION\n  mysql_mutex_init(key_LOCK_rpl_status, &LOCK_rpl_status, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_rpl_status, &COND_rpl_status, NULL);\n#endif\n  mysql_mutex_init(key_LOCK_server_started,\n                   &LOCK_server_started, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_server_started, &COND_server_started, NULL);\n  sp_cache_init();\n#ifdef HAVE_EVENT_SCHEDULER\n  Events::init_mutexes();\n#endif\n  /* Parameter for threads created for connections */\n  (void) pthread_attr_init(&connection_attrib);\n  (void) pthread_attr_setdetachstate(&connection_attrib,\n\t\t\t\t     PTHREAD_CREATE_DETACHED);\n  pthread_attr_setscope(&connection_attrib, PTHREAD_SCOPE_SYSTEM);\n\n  if (pthread_key_create(&THR_THD,NULL) ||\n      pthread_key_create(&THR_MALLOC,NULL))\n  {\n    sql_print_error(\"Can't create thread-keys\");\n    return 1;\n  }\n  return 0;\n}\n\n\n#if defined(HAVE_OPENSSL) && !defined(HAVE_YASSL)\nstatic unsigned long openssl_id_function()\n{ \n  return (unsigned long) pthread_self();\n} \n\n\nstatic openssl_lock_t *openssl_dynlock_create(const char *file, int line)\n{ \n  openssl_lock_t *lock= new openssl_lock_t;\n  mysql_rwlock_init(key_rwlock_openssl, &lock->lock);\n  return lock;\n}\n\n\nstatic void openssl_dynlock_destroy(openssl_lock_t *lock, const char *file, \n\t\t\t\t    int line)\n{\n  mysql_rwlock_destroy(&lock->lock);\n  delete lock;\n}\n\n\nstatic void openssl_lock_function(int mode, int n, const char *file, int line)\n{\n  if (n < 0 || n > CRYPTO_num_locks())\n  {\n    /* Lock number out of bounds. */\n    sql_print_error(\"Fatal: OpenSSL interface problem (n = %d)\", n);\n    abort();\n  }\n  openssl_lock(mode, &openssl_stdlocks[n], file, line);\n}\n\n\nstatic void openssl_lock(int mode, openssl_lock_t *lock, const char *file, \n\t\t\t int line)\n{\n  int err;\n  char const *what;\n\n  switch (mode) {\n  case CRYPTO_LOCK|CRYPTO_READ:\n    what = \"read lock\";\n    err= mysql_rwlock_rdlock(&lock->lock);\n    break;\n  case CRYPTO_LOCK|CRYPTO_WRITE:\n    what = \"write lock\";\n    err= mysql_rwlock_wrlock(&lock->lock);\n    break;\n  case CRYPTO_UNLOCK|CRYPTO_READ:\n  case CRYPTO_UNLOCK|CRYPTO_WRITE:\n    what = \"unlock\";\n    err= mysql_rwlock_unlock(&lock->lock);\n    break;\n  default:\n    /* Unknown locking mode. */\n    sql_print_error(\"Fatal: OpenSSL interface problem (mode=0x%x)\", mode);\n    abort();\n  }\n  if (err) \n  {\n    sql_print_error(\"Fatal: can't %s OpenSSL lock\", what);\n    abort();\n  }\n}\n#endif /* HAVE_OPENSSL */\n\n\nstatic void init_ssl()\n{\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  if (opt_use_ssl)\n  {\n    enum enum_ssl_init_error error= SSL_INITERR_NOERROR;\n\n    /* having ssl_acceptor_fd != 0 signals the use of SSL */\n    ssl_acceptor_fd= new_VioSSLAcceptorFd(opt_ssl_key, opt_ssl_cert,\n\t\t\t\t\t  opt_ssl_ca, opt_ssl_capath,\n\t\t\t\t\t  opt_ssl_cipher, &error);\n    DBUG_PRINT(\"info\",(\"ssl_acceptor_fd: 0x%lx\", (long) ssl_acceptor_fd));\n    if (!ssl_acceptor_fd)\n    {\n      sql_print_warning(\"Failed to setup SSL\");\n      sql_print_warning(\"SSL error: %s\", sslGetErrString(error));\n      opt_use_ssl = 0;\n      have_ssl= SHOW_OPTION_DISABLED;\n    }\n  }\n  else\n  {\n    have_ssl= SHOW_OPTION_DISABLED;\n  }\n#else\n  have_ssl= SHOW_OPTION_DISABLED;\n#endif /* ! EMBEDDED_LIBRARY */\n  if (des_key_file)\n    load_des_key_file(des_key_file);\n#endif /* HAVE_OPENSSL */\n}\n\n\nstatic void end_ssl()\n{\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  if (ssl_acceptor_fd)\n  {\n    free_vio_ssl_acceptor_fd(ssl_acceptor_fd);\n    ssl_acceptor_fd= 0;\n  }\n#endif /* ! EMBEDDED_LIBRARY */\n#endif /* HAVE_OPENSSL */\n}\n\n\nstatic int init_server_components()\n{\n  DBUG_ENTER(\"init_server_components\");\n  /*\n    We need to call each of these following functions to ensure that\n    all things are initialized so that unireg_abort() doesn't fail\n  */\n  mdl_init();\n  if (table_def_init() | hostname_cache_init())\n    unireg_abort(1);\n\n  query_cache_set_min_res_unit(query_cache_min_res_unit);\n  query_cache_init();\n  query_cache_resize(query_cache_size);\n  randominit(&sql_rand,(ulong) server_start_time,(ulong) server_start_time/2);\n  setup_fpu();\n  init_thr_lock();\n#ifdef HAVE_REPLICATION\n  init_slave_list();\n#endif\n\n  /* Setup logs */\n\n  /*\n    Enable old-fashioned error log, except when the user has requested\n    help information. Since the implementation of plugin server\n    variables the help output is now written much later.\n  */\n  if (opt_error_log && !opt_help)\n  {\n    if (!log_error_file_ptr[0])\n      fn_format(log_error_file, pidfile_name, mysql_data_home, \".err\",\n                MY_REPLACE_EXT); /* replace '.<domain>' by '.err', bug#4997 */\n    else\n      fn_format(log_error_file, log_error_file_ptr, mysql_data_home, \".err\",\n                MY_UNPACK_FILENAME | MY_SAFE_PATH);\n    /*\n      _ptr may have been set to my_disabled_option or \"\" if no argument was\n      passed, but we need to show the real name in SHOW VARIABLES:\n    */\n    log_error_file_ptr= log_error_file;\n    if (!log_error_file[0])\n      opt_error_log= 0;                         // Too long file name\n    else\n    {\n      my_bool res;\n#ifndef EMBEDDED_LIBRARY\n      res= reopen_fstreams(log_error_file, stdout, stderr);\n#else\n      res= reopen_fstreams(log_error_file, NULL, stderr);\n#endif\n\n      if (!res)\n        setbuf(stderr, NULL);\n    }\n  }\n\n  proc_info_hook= set_thd_proc_info;\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    Parsing the performance schema command line option may have reported\n    warnings/information messages.\n    Now that the logger is finally available, and redirected\n    to the proper file when the --log--error option is used,\n    print the buffered messages to the log.\n  */\n  buffered_logs.print();\n  buffered_logs.cleanup();\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n  if (xid_cache_init())\n  {\n    sql_print_error(\"Out of memory\");\n    unireg_abort(1);\n  }\n\n  /*\n    initialize delegates for extension observers, errors have already\n    been reported in the function\n  */\n  if (delegates_init())\n    unireg_abort(1);\n\n  /* need to configure logging before initializing storage engines */\n  if (opt_log_slave_updates && !opt_bin_log)\n  {\n    sql_print_warning(\"You need to use --log-bin to make \"\n                    \"--log-slave-updates work.\");\n  }\n  if (!opt_bin_log && binlog_format_used)\n    sql_print_warning(\"You need to use --log-bin to make \"\n                      \"--binlog-format work.\");\n\n  /* Check that we have not let the format to unspecified at this point */\n  DBUG_ASSERT((uint)global_system_variables.binlog_format <=\n              array_elements(binlog_format_names)-1);\n\n#ifdef HAVE_REPLICATION\n  if (opt_log_slave_updates && replicate_same_server_id)\n  {\n    if (opt_bin_log)\n    {\n      sql_print_error(\"using --replicate-same-server-id in conjunction with \\\n--log-slave-updates is impossible, it would lead to infinite loops in this \\\nserver.\");\n      unireg_abort(1);\n    }\n    else\n      sql_print_warning(\"using --replicate-same-server-id in conjunction with \\\n--log-slave-updates would lead to infinite loops in this server. However this \\\nwill be ignored as the --log-bin option is not defined.\");\n  }\n#endif\n\n  if (opt_bin_log)\n  {\n    /* Reports an error and aborts, if the --log-bin's path \n       is a directory.*/\n    if (opt_bin_logname && \n        opt_bin_logname[strlen(opt_bin_logname) - 1] == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \\\na file name for --log-bin option\", opt_bin_logname);\n      unireg_abort(1);\n    }\n\n    /* Reports an error and aborts, if the --log-bin-index's path \n       is a directory.*/\n    if (opt_binlog_index_name && \n        opt_binlog_index_name[strlen(opt_binlog_index_name) - 1] \n        == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \\\na file name for --log-bin-index option\", opt_binlog_index_name);\n      unireg_abort(1);\n    }\n\n    char buf[FN_REFLEN];\n    const char *ln;\n    ln= mysql_bin_log.generate_name(opt_bin_logname, \"-bin\", 1, buf);\n    if (!opt_bin_logname && !opt_binlog_index_name)\n    {\n      /*\n        User didn't give us info to name the binlog index file.\n        Picking `hostname`-bin.index like did in 4.x, causes replication to\n        fail if the hostname is changed later. So, we would like to instead\n        require a name. But as we don't want to break many existing setups, we\n        only give warning, not error.\n      */\n      sql_print_warning(\"No argument was provided to --log-bin, and \"\n                        \"--log-bin-index was not used; so replication \"\n                        \"may break when this MySQL server acts as a \"\n                        \"master and has his hostname changed!! Please \"\n                        \"use '--log-bin=%s' to avoid this problem.\", ln);\n    }\n    if (ln == buf)\n    {\n      my_free(opt_bin_logname);\n      opt_bin_logname=my_strdup(buf, MYF(0));\n    }\n    if (mysql_bin_log.open_index_file(opt_binlog_index_name, ln, TRUE))\n    {\n      unireg_abort(1);\n    }\n  }\n\n  /* call ha_init_key_cache() on all key caches to init them */\n  process_key_caches(&ha_init_key_cache);\n\n  /* Allow storage engine to give real error messages */\n  if (ha_init_errors())\n    DBUG_RETURN(1);\n\n  if (opt_ignore_builtin_innodb)\n    sql_print_warning(\"ignore-builtin-innodb is deprecated \"\n                      \"and will be removed in future releases.\");\n    \n  if (plugin_init(&remaining_argc, remaining_argv,\n                  (opt_noacl ? PLUGIN_INIT_SKIP_PLUGIN_TABLE : 0) |\n                  (opt_help ? PLUGIN_INIT_SKIP_INITIALIZATION : 0)))\n  {\n    sql_print_error(\"Failed to initialize plugins.\");\n    unireg_abort(1);\n  }\n  plugins_are_initialized= TRUE;  /* Don't separate from init function */\n\n  have_csv= plugin_status(STRING_WITH_LEN(\"csv\"),\n                          MYSQL_STORAGE_ENGINE_PLUGIN);\n  have_ndbcluster= plugin_status(STRING_WITH_LEN(\"ndbcluster\"),\n                                 MYSQL_STORAGE_ENGINE_PLUGIN);\n  have_partitioning= plugin_status(STRING_WITH_LEN(\"partition\"),\n                                   MYSQL_STORAGE_ENGINE_PLUGIN);\n\n  /* we do want to exit if there are any other unknown options */\n  if (remaining_argc > 1)\n  {\n    int ho_error;\n    struct my_option no_opts[]=\n    {\n      {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n    };\n    /*\n      We need to eat any 'loose' arguments first before we conclude\n      that there are unprocessed options.\n    */\n    my_getopt_skip_unknown= 0;\n\n    if ((ho_error= handle_options(&remaining_argc, &remaining_argv, no_opts,\n                                  mysqld_get_one_option)))\n      unireg_abort(ho_error);\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n    my_getopt_skip_unknown= TRUE;\n\n    if (remaining_argc > 1)\n    {\n      fprintf(stderr, \"%s: Too many arguments (first extra is '%s').\\n\"\n              \"Use --verbose --help to get a list of available options\\n\",\n              my_progname, remaining_argv[1]);\n      unireg_abort(1);\n    }\n  }\n\n  if (opt_help)\n    unireg_abort(0);\n\n  /* if the errmsg.sys is not loaded, terminate to maintain behaviour */\n  if (!DEFAULT_ERRMSGS[0][0])\n    unireg_abort(1);  \n\n  /* We have to initialize the storage engines before CSV logging */\n  if (ha_init())\n  {\n    sql_print_error(\"Can't init databases\");\n    unireg_abort(1);\n  }\n\n#ifdef WITH_CSV_STORAGE_ENGINE\n  if (opt_bootstrap)\n    log_output_options= LOG_FILE;\n  else\n    logger.init_log_tables();\n\n  if (log_output_options & LOG_NONE)\n  {\n    /*\n      Issue a warining if there were specified additional options to the\n      log-output along with NONE. Probably this wasn't what user wanted.\n    */\n    if ((log_output_options & LOG_NONE) && (log_output_options & ~LOG_NONE))\n      sql_print_warning(\"There were other values specified to \"\n                        \"log-output besides NONE. Disabling slow \"\n                        \"and general logs anyway.\");\n    logger.set_handlers(LOG_FILE, LOG_NONE, LOG_NONE);\n  }\n  else\n  {\n    /* fall back to the log files if tables are not present */\n    LEX_STRING csv_name={C_STRING_WITH_LEN(\"csv\")};\n    if (!plugin_is_ready(&csv_name, MYSQL_STORAGE_ENGINE_PLUGIN))\n    {\n      /* purecov: begin inspected */\n      sql_print_error(\"CSV engine is not present, falling back to the \"\n                      \"log files\");\n      log_output_options= (log_output_options & ~LOG_TABLE) | LOG_FILE;\n      /* purecov: end */\n    }\n\n    logger.set_handlers(LOG_FILE, opt_slow_log ? log_output_options:LOG_NONE,\n                        opt_log ? log_output_options:LOG_NONE);\n  }\n#else\n  logger.set_handlers(LOG_FILE, opt_slow_log ? LOG_FILE:LOG_NONE,\n                      opt_log ? LOG_FILE:LOG_NONE);\n#endif\n\n  /*\n    Set the default storage engine\n  */\n  LEX_STRING name= { default_storage_engine, strlen(default_storage_engine) };\n  plugin_ref plugin;\n  handlerton *hton;\n  if ((plugin= ha_resolve_by_name(0, &name)))\n    hton= plugin_data(plugin, handlerton*);\n  else\n  {\n    sql_print_error(\"Unknown/unsupported storage engine: %s\",\n                    default_storage_engine);\n    unireg_abort(1);\n  }\n  if (!ha_storage_engine_is_enabled(hton))\n  {\n    if (!opt_bootstrap)\n    {\n      sql_print_error(\"Default storage engine (%s) is not available\",\n                      default_storage_engine);\n      unireg_abort(1);\n    }\n    DBUG_ASSERT(global_system_variables.table_plugin);\n  }\n  else\n  {\n    /*\n      Need to unlock as global_system_variables.table_plugin\n      was acquired during plugin_init()\n    */\n    plugin_unlock(0, global_system_variables.table_plugin);\n    global_system_variables.table_plugin= plugin;\n  }\n\n  tc_log= (total_ha_2pc > 1 ? (opt_bin_log  ?\n                               (TC_LOG *) &mysql_bin_log :\n                               (TC_LOG *) &tc_log_mmap) :\n           (TC_LOG *) &tc_log_dummy);\n\n  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file))\n  {\n    sql_print_error(\"Can't init tc log\");\n    unireg_abort(1);\n  }\n\n  if (ha_recover(0))\n  {\n    unireg_abort(1);\n  }\n\n  if (opt_bin_log && mysql_bin_log.open(opt_bin_logname, LOG_BIN, 0,\n                                        WRITE_CACHE, 0, max_binlog_size, 0, TRUE))\n    unireg_abort(1);\n\n#ifdef HAVE_REPLICATION\n  if (opt_bin_log && expire_logs_days)\n  {\n    time_t purge_time= server_start_time - expire_logs_days*24*60*60;\n    if (purge_time >= 0)\n      mysql_bin_log.purge_logs_before_date(purge_time);\n  }\n#endif\n\n  if (opt_myisam_log)\n    (void) mi_log(1);\n\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT) && !defined(EMBEDDED_LIBRARY)\n  if (locked_in_memory && !getuid())\n  {\n    if (setreuid((uid_t)-1, 0) == -1)\n    {                        // this should never happen\n      sql_perror(\"setreuid\");\n      unireg_abort(1);\n    }\n    if (mlockall(MCL_CURRENT))\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Failed to lock memory. Errno: %d\\n\",errno);\n      locked_in_memory= 0;\n    }\n    if (user_info)\n      set_user(mysqld_user, user_info);\n  }\n  else\n#endif\n    locked_in_memory=0;\n\n  ft_init_stopwords();\n\n  init_max_user_conn();\n  init_update_queries();\n  DBUG_RETURN(0);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic void create_shutdown_thread()\n{\n#ifdef __WIN__\n  hEventShutdown=CreateEvent(0, FALSE, FALSE, shutdown_event_name);\n  pthread_t hThread;\n  int error;\n  if ((error= mysql_thread_create(key_thread_handle_shutdown,\n                                  &hThread, &connection_attrib,\n                                  handle_shutdown, 0)))\n    sql_print_warning(\"Can't create thread to handle shutdown requests\"\n                      \" (errno= %d)\", error);\n\n  // On \"Stop Service\" we have to do regular shutdown\n  Service.SetShutdownEvent(hEventShutdown);\n#endif /* __WIN__ */\n}\n\n#endif /* EMBEDDED_LIBRARY */\n\n\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\nstatic void handle_connections_methods()\n{\n  pthread_t hThread;\n  int error;\n  DBUG_ENTER(\"handle_connections_methods\");\n  if (hPipe == INVALID_HANDLE_VALUE &&\n      (!have_tcpip || opt_disable_networking) &&\n      !opt_enable_shared_memory)\n  {\n    sql_print_error(\"TCP/IP, --shared-memory, or --named-pipe should be configured on NT OS\");\n    unireg_abort(1);\t\t\t\t// Will not return\n  }\n\n  mysql_mutex_lock(&LOCK_thread_count);\n  mysql_cond_init(key_COND_handler_count, &COND_handler_count, NULL);\n  handler_count=0;\n  if (hPipe != INVALID_HANDLE_VALUE)\n  {\n    handler_count++;\n    if ((error= mysql_thread_create(key_thread_handle_con_namedpipes,\n                                    &hThread, &connection_attrib,\n                                    handle_connections_namedpipes, 0)))\n    {\n      sql_print_warning(\"Can't create thread to handle named pipes\"\n                        \" (errno= %d)\", error);\n      handler_count--;\n    }\n  }\n  if (have_tcpip && !opt_disable_networking)\n  {\n    handler_count++;\n    if ((error= mysql_thread_create(key_thread_handle_con_sockets,\n                                    &hThread, &connection_attrib,\n                                    handle_connections_sockets_thread, 0)))\n    {\n      sql_print_warning(\"Can't create thread to handle TCP/IP\",\n                        \" (errno= %d)\", error);\n      handler_count--;\n    }\n  }\n#ifdef HAVE_SMEM\n  if (opt_enable_shared_memory)\n  {\n    handler_count++;\n    if ((error= mysql_thread_create(key_thread_handle_con_sharedmem,\n                                    &hThread, &connection_attrib,\n                                    handle_connections_shared_memory, 0)))\n    {\n      sql_print_warning(\"Can't create thread to handle shared memory\",\n                        \" (errno= %d)\", error);\n      handler_count--;\n    }\n  }\n#endif \n\n  while (handler_count > 0)\n    mysql_cond_wait(&COND_handler_count, &LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  DBUG_VOID_RETURN;\n}\n\nvoid decrement_handler_count()\n{\n  mysql_mutex_lock(&LOCK_thread_count);\n  handler_count--;\n  mysql_cond_signal(&COND_handler_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  my_thread_end();\n}\n#else\n#define decrement_handler_count()\n#endif /* defined(_WIN32) || defined(HAVE_SMEM) */\n\n\n#ifndef EMBEDDED_LIBRARY\n#ifndef DBUG_OFF\n/*\n  Debugging helper function to keep the locale database\n  (see sql_locale.cc) and max_month_name_length and\n  max_day_name_length variable values in consistent state.\n*/\nstatic void test_lc_time_sz()\n{\n  DBUG_ENTER(\"test_lc_time_sz\");\n  for (MY_LOCALE **loc= my_locales; *loc; loc++)\n  {\n    uint max_month_len= 0;\n    uint max_day_len = 0;\n    for (const char **month= (*loc)->month_names->type_names; *month; month++)\n    {\n      set_if_bigger(max_month_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *month, *month + strlen(*month)));\n    }\n    for (const char **day= (*loc)->day_names->type_names; *day; day++)\n    {\n      set_if_bigger(max_day_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *day, *day + strlen(*day)));\n    }\n    if ((*loc)->max_month_name_length != max_month_len ||\n        (*loc)->max_day_name_length != max_day_len)\n    {\n      DBUG_PRINT(\"Wrong max day name(or month name) length for locale:\",\n                 (\"%s\", (*loc)->name));\n      DBUG_ASSERT(0);\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n#endif//DBUG_OFF\n\n#ifdef __WIN__\nint win_main(int argc, char **argv)\n#else\nint mysqld_main(int argc, char **argv)\n#endif\n{\n  /*\n    Perform basic thread library and malloc initialization,\n    to be able to read defaults files and parse options.\n  */\n  my_progname= argv[0];\n#ifdef HAVE_NPTL\n  ld_assume_kernel_is_set= (getenv(\"LD_ASSUME_KERNEL\") != 0);\n#endif\n#ifndef _WIN32\n  // For windows, my_init() is called from the win specific mysqld_main\n  if (my_init())                 // init my_sys library & pthreads\n  {\n    fprintf(stderr, \"my_init() failed.\");\n    return 1;\n  }\n#endif\n\n  orig_argc= argc;\n  orig_argv= argv;\n  my_getopt_use_args_separator= TRUE;\n  if (load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv))\n    return 1;\n  my_getopt_use_args_separator= FALSE;\n  defaults_argc= argc;\n  defaults_argv= argv;\n  remaining_argc= argc;\n  remaining_argv= argv;\n\n  /* Must be initialized early for comparison of options name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n  init_sql_statement_names();\n  sys_var_init();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    The performance schema needs to be initialized as early as possible,\n    before to-be-instrumented objects of the server are initialized.\n  */\n  int ho_error;\n  DYNAMIC_ARRAY all_early_options;\n\n  my_getopt_register_get_addr(NULL);\n  /* Skip unknown options so that they may be processed later */\n  my_getopt_skip_unknown= TRUE;\n\n  /* prepare all_early_options array */\n  my_init_dynamic_array(&all_early_options, sizeof(my_option), 100, 25);\n  sys_var_add_options(&all_early_options, sys_var::PARSE_EARLY);\n  add_terminator(&all_early_options);\n\n  /*\n    Logs generated while parsing the command line\n    options are buffered and printed later.\n  */\n  buffered_logs.init();\n  my_getopt_error_reporter= buffered_option_error_reporter;\n\n  ho_error= handle_options(&remaining_argc, &remaining_argv,\n                           (my_option*)(all_early_options.buffer), NULL);\n  delete_dynamic(&all_early_options);\n  if (ho_error == 0)\n  {\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n    if (pfs_param.m_enabled)\n    {\n      PSI_hook= initialize_performance_schema(&pfs_param);\n      if (PSI_hook == NULL)\n      {\n        pfs_param.m_enabled= false;\n        buffered_logs.buffer(WARNING_LEVEL,\n                             \"Performance schema disabled (reason: init failed).\");\n      }\n    }\n  }\n#else\n  /*\n    Other provider of the instrumentation interface should\n    initialize PSI_hook here:\n    - HAVE_PSI_INTERFACE is for the instrumentation interface\n    - WITH_PERFSCHEMA_STORAGE_ENGINE is for one implementation\n      of the interface,\n    but there could be alternate implementations, which is why\n    these two defines are kept separate.\n  */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Obtain the current performance schema instrumentation interface,\n    if available.\n  */\n  if (PSI_hook)\n    PSI_server= (PSI*) PSI_hook->get_interface(PSI_CURRENT_VERSION);\n\n  if (PSI_server)\n  {\n    /*\n      Now that we have parsed the command line arguments, and have initialized\n      the performance schema itself, the next step is to register all the\n      server instruments.\n    */\n    init_server_psi_keys();\n    /* Instrument the main thread */\n    PSI_thread *psi= PSI_server->new_thread(key_thread_main, NULL, 0);\n    if (psi)\n      PSI_server->set_thread(psi);\n\n    /*\n      Now that some instrumentation is in place,\n      recreate objects which were initialised early,\n      so that they are instrumented as well.\n    */\n    my_thread_global_reinit();\n  }\n#endif /* HAVE_PSI_INTERFACE */\n\n  init_error_log_mutex();\n\n  /* Set signal used to kill MySQL */\n#if defined(SIGUSR2)\n  thr_kill_signal= thd_lib_detected == THD_LIB_LT ? SIGINT : SIGUSR2;\n#else\n  thr_kill_signal= SIGINT;\n#endif\n\n  /* Initialize audit interface globals. Audit plugins are inited later. */\n  mysql_audit_initialize();\n\n  /*\n    Perform basic logger initialization logger. Should be called after\n    MY_INIT, as it initializes mutexes. Log tables are inited later.\n  */\n  logger.init_base();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  if (ho_error)\n  {\n    /*\n      Parsing command line option failed,\n      Since we don't have a workable remaining_argc/remaining_argv\n      to continue the server initialization, this is as far as this\n      code can go.\n      This is the best effort to log meaningful messages:\n      - messages will be printed to stderr, which is not redirected yet,\n      - messages will be printed in the NT event log, for windows.\n    */\n    buffered_logs.print();\n    buffered_logs.cleanup();\n    /*\n      Not enough initializations for unireg_abort()\n      Using exit() for windows.\n    */\n    exit (ho_error);\n  }\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef _CUSTOMSTARTUPCONFIG_\n  if (_cust_check_startup())\n  {\n    / * _cust_check_startup will report startup failure error * /\n    exit(1);\n  }\n#endif\n\n  if (init_common_variables())\n    unireg_abort(1);\t\t\t\t// Will do exit\n\n  init_signals();\n#if defined(__ia64__) || defined(__ia64)\n  /*\n    Peculiar things with ia64 platforms - it seems we only have half the\n    stack size in reality, so we have to double it here\n  */\n  pthread_attr_setstacksize(&connection_attrib,my_thread_stack_size*2);\n#else\n  pthread_attr_setstacksize(&connection_attrib,my_thread_stack_size);\n#endif\n#ifdef HAVE_PTHREAD_ATTR_GETSTACKSIZE\n  {\n    /* Retrieve used stack size;  Needed for checking stack overflows */\n    size_t stack_size= 0;\n    pthread_attr_getstacksize(&connection_attrib, &stack_size);\n#if defined(__ia64__) || defined(__ia64)\n    stack_size/= 2;\n#endif\n    /* We must check if stack_size = 0 as Solaris 2.9 can return 0 here */\n    if (stack_size && stack_size < my_thread_stack_size)\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Asked for %lu thread stack, but got %ld\",\n\t\t\t  my_thread_stack_size, (long) stack_size);\n#if defined(__ia64__) || defined(__ia64)\n      my_thread_stack_size= stack_size*2;\n#else\n      my_thread_stack_size= stack_size;\n#endif\n    }\n  }\n#endif\n\n  (void) thr_setconcurrency(concurrency);\t// 10 by default\n\n  select_thread=pthread_self();\n  select_thread_in_use=1;\n\n#ifdef HAVE_LIBWRAP\n  libwrapName= my_progname+dirname_length(my_progname);\n  openlog(libwrapName, LOG_PID, LOG_AUTH);\n#endif\n\n#ifndef DBUG_OFF\n  test_lc_time_sz();\n#endif\n\n  /*\n    We have enough space for fiddling with the argv, continue\n  */\n  check_data_home(mysql_real_data_home);\n  if (my_setwd(mysql_real_data_home,MYF(MY_WME)) && !opt_help)\n    unireg_abort(1);\t\t\t\t/* purecov: inspected */\n\n  if ((user_info= check_user(mysqld_user)))\n  {\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT)\n    if (locked_in_memory) // getuid() == 0 here\n      set_effective_user(user_info);\n    else\n#endif\n      set_user(mysqld_user, user_info);\n  }\n\n  if (opt_bin_log && !server_id)\n  {\n    server_id= 1;\n#ifdef EXTRA_DEBUG\n    sql_print_warning(\"You have enabled the binary log, but you haven't set \"\n                      \"server-id to a non-zero value: we force server id to 1; \"\n                      \"updates will be logged to the binary log, but \"\n                      \"connections from slaves will not be accepted.\");\n#endif\n  }\n\n  /* \n   The subsequent calls may take a long time : e.g. innodb log read.\n   Thus set the long running service control manager timeout\n  */\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  Service.SetSlowStarting(slow_start_timeout);\n#endif\n\n  if (init_server_components())\n    unireg_abort(1);\n\n  init_ssl();\n  network_init();\n\n#ifdef __WIN__\n  if (!opt_console)\n  {\n    if (reopen_fstreams(log_error_file, stdout, stderr))\n      unireg_abort(1);\n    setbuf(stderr, NULL);\n    FreeConsole();\t\t\t\t// Remove window\n  }\n#endif\n\n  /*\n   Initialize my_str_malloc() and my_str_free()\n  */\n  my_str_malloc= &my_str_malloc_mysqld;\n  my_str_free= &my_str_free_mysqld;\n\n  /*\n    init signals & alarm\n    After this we can't quit by a simple unireg_abort\n  */\n  error_handler_hook= my_message_sql;\n  sql_print_warning_hook = sql_print_warning;\n  start_signal_handler();\t\t\t\t// Creates pidfile\n\n  if (mysql_rm_tmp_tables() || acl_init(opt_noacl) ||\n      my_tz_init((THD *)0, default_tz_name, opt_bootstrap))\n  {\n    abort_loop=1;\n    select_thread_in_use=0;\n\n    (void) pthread_kill(signal_thread, MYSQL_KILL_SIGNAL);\n\n    delete_pid_file(MYF(MY_WME));\n\n    if (unix_sock != INVALID_SOCKET)\n      unlink(mysqld_unix_port);\n    exit(1);\n  }\n\n  if (!opt_noacl)\n    (void) grant_init();\n\n  if (!opt_bootstrap)\n    servers_init(0);\n\n  if (!opt_noacl)\n  {\n#ifdef HAVE_DLOPEN\n    udf_init();\n#endif\n  }\n\n  init_status_vars();\n  if (opt_bootstrap) /* If running with bootstrap, do not start replication. */\n    opt_skip_slave_start= 1;\n\n  binlog_unsafe_map_init();\n  /*\n    init_slave() must be called after the thread keys are created.\n    Some parts of the code (e.g. SHOW STATUS LIKE 'slave_running' and other\n    places) assume that active_mi != 0, so let's fail if it's 0 (out of\n    memory); a message has already been printed.\n  */\n  if (init_slave() && !active_mi)\n  {\n    unireg_abort(1);\n  }\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  initialize_performance_schema_acl(opt_bootstrap);\n  /*\n    Do not check the structure of the performance schema tables\n    during bootstrap:\n    - the tables are not supposed to exist yet, bootstrap will create them\n    - a check would print spurious error messages\n  */\n  if (! opt_bootstrap)\n    check_performance_schema();\n#endif\n\n  initialize_information_schema_acl();\n\n  execute_ddl_log_recovery();\n\n  if (Events::init(opt_noacl || opt_bootstrap))\n    unireg_abort(1);\n\n  if (opt_bootstrap)\n  {\n    select_thread_in_use= 0;                    // Allow 'kill' to work\n    bootstrap(mysql_stdin);\n    unireg_abort(bootstrap_error ? 1 : 0);\n  }\n  if (opt_init_file && *opt_init_file)\n  {\n    if (read_init_file(opt_init_file))\n      unireg_abort(1);\n  }\n\n  create_shutdown_thread();\n  start_handle_manager();\n\n  sql_print_information(ER_DEFAULT(ER_STARTUP),my_progname,server_version,\n                        ((unix_sock == INVALID_SOCKET) ? (char*) \"\"\n                                                       : mysqld_unix_port),\n                         mysqld_port,\n                         MYSQL_COMPILATION_COMMENT);\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  Service.SetRunning();\n#endif\n\n\n  /* Signal threads waiting for server to be started */\n  mysql_mutex_lock(&LOCK_server_started);\n  mysqld_server_started= 1;\n  mysql_cond_signal(&COND_server_started);\n  mysql_mutex_unlock(&LOCK_server_started);\n\n#if defined(_WIN32) || defined(HAVE_SMEM)\n  handle_connections_methods();\n#else\n  handle_connections_sockets();\n#endif /* _WIN32 || HAVE_SMEM */\n\n  /* (void) pthread_attr_destroy(&connection_attrib); */\n  \n  DBUG_PRINT(\"quit\",(\"Exiting main thread\"));\n\n#ifndef __WIN__\n#ifdef EXTRA_DEBUG2\n  sql_print_error(\"Before Lock_thread_count\");\n#endif\n  mysql_mutex_lock(&LOCK_thread_count);\n  DBUG_PRINT(\"quit\", (\"Got thread_count mutex\"));\n  select_thread_in_use=0;\t\t\t// For close_connections\n  mysql_mutex_unlock(&LOCK_thread_count);\n  mysql_cond_broadcast(&COND_thread_count);\n#ifdef EXTRA_DEBUG2\n  sql_print_error(\"After lock_thread_count\");\n#endif\n#endif /* __WIN__ */\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Disable the main thread instrumentation,\n    to avoid recording events during the shutdown.\n  */\n  if (PSI_server)\n    PSI_server->delete_current_thread();\n#endif\n\n  /* Wait until cleanup is done */\n  mysql_mutex_lock(&LOCK_thread_count);\n  while (!ready_to_exit)\n    mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n  mysql_mutex_unlock(&LOCK_thread_count);\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\n  if (Service.IsNT() && start_mode)\n    Service.Stop();\n  else\n  {\n    Service.SetShutdownEvent(0);\n    if (hEventShutdown)\n      CloseHandle(hEventShutdown);\n  }\n#endif\n  clean_up(1);\n  mysqld_exit(0);\n}\n\n#endif /* !EMBEDDED_LIBRARY */\n\n\n/****************************************************************************\n  Main and thread entry function for Win32\n  (all this is needed only to run mysqld as a service on WinNT)\n****************************************************************************/\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\nint mysql_service(void *p)\n{\n  if (my_thread_init())\n    return 1;\n  \n  if (use_opt_args)\n    win_main(opt_argc, opt_argv);\n  else\n    win_main(Service.my_argc, Service.my_argv);\n\n  my_thread_end();\n  return 0;\n}\n\n\n/* Quote string if it contains space, else copy */\n\nstatic char *add_quoted_string(char *to, const char *from, char *to_end)\n{\n  uint length= (uint) (to_end-to);\n\n  if (!strchr(from, ' '))\n    return strmake(to, from, length-1);\n  return strxnmov(to, length-1, \"\\\"\", from, \"\\\"\", NullS);\n}\n\n\n/**\n  Handle basic handling of services, like installation and removal.\n\n  @param argv\t   \t        Pointer to argument list\n  @param servicename\t\tInternal name of service\n  @param displayname\t\tDisplay name of service (in taskbar ?)\n  @param file_path\t\tPath to this program\n  @param startup_option\tStartup option to mysqld\n\n  @retval\n    0\t\toption handled\n  @retval\n    1\t\tCould not handle option\n*/\n\nstatic bool\ndefault_service_handling(char **argv,\n\t\t\t const char *servicename,\n\t\t\t const char *displayname,\n\t\t\t const char *file_path,\n\t\t\t const char *extra_opt,\n\t\t\t const char *account_name)\n{\n  char path_and_service[FN_REFLEN+FN_REFLEN+32], *pos, *end;\n  const char *opt_delim;\n  end= path_and_service + sizeof(path_and_service)-3;\n\n  /* We have to quote filename if it contains spaces */\n  pos= add_quoted_string(path_and_service, file_path, end);\n  if (extra_opt && *extra_opt)\n  {\n    /* \n     Add option after file_path. There will be zero or one extra option.  It's \n     assumed to be --defaults-file=file but isn't checked.  The variable (not\n     the option name) should be quoted if it contains a string.  \n    */\n    *pos++= ' ';\n    if (opt_delim= strchr(extra_opt, '='))\n    {\n      size_t length= ++opt_delim - extra_opt;\n      pos= strnmov(pos, extra_opt, length);\n    }\n    else\n      opt_delim= extra_opt;\n    \n    pos= add_quoted_string(pos, opt_delim, end);\n  }\n  /* We must have servicename last */\n  *pos++= ' ';\n  (void) add_quoted_string(pos, servicename, end);\n\n  if (Service.got_service_option(argv, \"install\"))\n  {\n    Service.Install(1, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"install-manual\"))\n  {\n    Service.Install(0, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"remove\"))\n  {\n    Service.Remove(servicename);\n    return 0;\n  }\n  return 1;\n}\n\n\nint mysqld_main(int argc, char **argv)\n{\n  /*\n    When several instances are running on the same machine, we\n    need to have an  unique  named  hEventShudown  through the\n    application PID e.g.: MySQLShutdown1890; MySQLShutdown2342\n  */\n  int10_to_str((int) GetCurrentProcessId(),strmov(shutdown_event_name,\n                                                  \"MySQLShutdown\"), 10);\n\n  /* Must be initialized early for comparison of service name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n  if (my_init())\n  {\n    fprintf(stderr, \"my_init() failed.\");\n    return 1;\n  }\n\n  if (Service.GetOS())\t/* true NT family */\n  {\n    char file_path[FN_REFLEN];\n    my_path(file_path, argv[0], \"\");\t\t      /* Find name in path */\n    fn_format(file_path,argv[0],file_path,\"\",\n\t      MY_REPLACE_DIR | MY_UNPACK_FILENAME | MY_RESOLVE_SYMLINKS);\n\n    if (argc == 2)\n    {\n      if (!default_service_handling(argv, MYSQL_SERVICENAME, MYSQL_SERVICENAME,\n\t\t\t\t   file_path, \"\", NULL))\n\treturn 0;\n      if (Service.IsService(argv[1]))        /* Start an optional service */\n      {\n\t/*\n\t  Only add the service name to the groups read from the config file\n\t  if it's not \"MySQL\". (The default service name should be 'mysqld'\n\t  but we started a bad tradition by calling it MySQL from the start\n\t  and we are now stuck with it.\n\t*/\n\tif (my_strcasecmp(system_charset_info, argv[1],\"mysql\"))\n\t  load_default_groups[load_default_groups_sz-2]= argv[1];\n        start_mode= 1;\n        Service.Init(argv[1], mysql_service);\n        return 0;\n      }\n    }\n    else if (argc == 3) /* install or remove any optional service */\n    {\n      if (!default_service_handling(argv, argv[2], argv[2], file_path, \"\",\n                                    NULL))\n\treturn 0;\n      if (Service.IsService(argv[2]))\n      {\n\t/*\n\t  mysqld was started as\n\t  mysqld --defaults-file=my_path\\my.ini service-name\n\t*/\n\tuse_opt_args=1;\n\topt_argc= 2;\t\t\t\t// Skip service-name\n\topt_argv=argv;\n\tstart_mode= 1;\n\tif (my_strcasecmp(system_charset_info, argv[2],\"mysql\"))\n\t  load_default_groups[load_default_groups_sz-2]= argv[2];\n\tService.Init(argv[2], mysql_service);\n\treturn 0;\n      }\n    }\n    else if (argc == 4 || argc == 5)\n    {\n      /*\n        This may seem strange, because we handle --local-service while\n        preserving 4.1's behavior of allowing any one other argument that is\n        passed to the service on startup. (The assumption is that this is\n        --defaults-file=file, but that was not enforced in 4.1, so we don't\n        enforce it here.)\n      */\n      const char *extra_opt= NullS;\n      const char *account_name = NullS;\n      int index;\n      for (index = 3; index < argc; index++)\n      {\n        if (!strcmp(argv[index], \"--local-service\"))\n          account_name= \"NT AUTHORITY\\\\LocalService\";\n        else\n          extra_opt= argv[index];\n      }\n\n      if (argc == 4 || account_name)\n        if (!default_service_handling(argv, argv[2], argv[2], file_path,\n                                      extra_opt, account_name))\n          return 0;\n    }\n    else if (argc == 1 && Service.IsService(MYSQL_SERVICENAME))\n    {\n      /* start the default service */\n      start_mode= 1;\n      Service.Init(MYSQL_SERVICENAME, mysql_service);\n      return 0;\n    }\n  }\n  /* Start as standalone server */\n  Service.my_argc=argc;\n  Service.my_argv=argv;\n  mysql_service(NULL);\n  return 0;\n}\n#endif\n\n\n/**\n  Execute all commands from a file. Used by the mysql_install_db script to\n  create MySQL privilege tables without having to start a full MySQL server.\n*/\n\nstatic void bootstrap(MYSQL_FILE *file)\n{\n  DBUG_ENTER(\"bootstrap\");\n\n  THD *thd= new THD;\n  thd->bootstrap=1;\n  my_net_init(&thd->net,(st_vio*) 0);\n  thd->max_client_packet_length= thd->net.max_packet;\n  thd->security_ctx->master_access= ~(ulong)0;\n  thd->thread_id= thd->variables.pseudo_thread_id= thread_id++;\n  thread_count++;\n  in_bootstrap= TRUE;\n\n  bootstrap_file=file;\n#ifndef EMBEDDED_LIBRARY\t\t\t// TODO:  Enable this\n  int error;\n  if ((error= mysql_thread_create(key_thread_bootstrap,\n                                  &thd->real_id, &connection_attrib,\n                                  handle_bootstrap,\n                                  (void*) thd)))\n  {\n    sql_print_warning(\"Can't create thread to handle bootstrap (errno= %d)\",\n                      error);\n    bootstrap_error=-1;\n    DBUG_VOID_RETURN;\n  }\n  /* Wait for thread to die */\n  mysql_mutex_lock(&LOCK_thread_count);\n  while (in_bootstrap)\n  {\n    mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);\n    DBUG_PRINT(\"quit\",(\"One thread died (count=%u)\",thread_count));\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n#else\n  thd->mysql= 0;\n  do_handle_bootstrap(thd);\n#endif\n\n  DBUG_VOID_RETURN;\n}\n\n\nstatic bool read_init_file(char *file_name)\n{\n  MYSQL_FILE *file;\n  DBUG_ENTER(\"read_init_file\");\n  DBUG_PRINT(\"enter\",(\"name: %s\",file_name));\n  if (!(file= mysql_file_fopen(key_file_init, file_name,\n                               O_RDONLY, MYF(MY_WME))))\n    DBUG_RETURN(TRUE);\n  bootstrap(file);\n  mysql_file_fclose(file, MYF(MY_WME));\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Increment number of created threads\n*/\nvoid inc_thread_created(void)\n{\n  mysql_mutex_lock(&LOCK_thread_created);\n  thread_created++;\n  mysql_mutex_unlock(&LOCK_thread_created);\n}\n\n#ifndef EMBEDDED_LIBRARY\n\n/*\n   Simple scheduler that use the main thread to handle the request\n\n   NOTES\n     This is only used for debugging, when starting mysqld with\n     --thread-handling=no-threads or --one-thread\n\n     When we enter this function, LOCK_thread_count is hold!\n*/\n\nvoid handle_connection_in_main_thread(THD *thd)\n{\n  mysql_mutex_assert_owner(&LOCK_thread_count);\n  thread_cache_size=0;\t\t\t// Safety\n  threads.append(thd);\n  mysql_mutex_unlock(&LOCK_thread_count);\n  thd->start_utime= my_micro_time();\n  do_handle_one_connection(thd);\n}\n\n\n/*\n  Scheduler that uses one thread per connection\n*/\n\nvoid create_thread_to_handle_connection(THD *thd)\n{\n  if (cached_thread_count > wake_thread)\n  {\n    /* Get thread from cache */\n    thread_cache.push_back(thd);\n    wake_thread++;\n    mysql_cond_signal(&COND_thread_cache);\n  }\n  else\n  {\n    char error_message_buff[MYSQL_ERRMSG_SIZE];\n    /* Create new thread to handle connection */\n    int error;\n    thread_created++;\n    threads.append(thd);\n    DBUG_PRINT(\"info\",((\"creating thread %lu\"), thd->thread_id));\n    thd->prior_thr_create_utime= thd->start_utime= my_micro_time();\n    if ((error= mysql_thread_create(key_thread_one_connection,\n                                    &thd->real_id, &connection_attrib,\n                                    handle_one_connection,\n                                    (void*) thd)))\n    {\n      /* purecov: begin inspected */\n      DBUG_PRINT(\"error\",\n                 (\"Can't create thread to handle request (error %d)\",\n                  error));\n\n      thread_count--;\n      thd->killed= THD::KILL_CONNECTION;\t\t\t// Safety\n      mysql_mutex_unlock(&LOCK_thread_count);\n\n      mysql_mutex_lock(&LOCK_connection_count);\n      --connection_count;\n      mysql_mutex_unlock(&LOCK_connection_count);\n\n      statistic_increment(aborted_connects,&LOCK_status);\n      /* Can't use my_error() since store_globals has not been called. */\n      my_snprintf(error_message_buff, sizeof(error_message_buff),\n                  ER_THD(thd, ER_CANT_CREATE_THREAD), error);\n      net_send_error(thd, ER_CANT_CREATE_THREAD, error_message_buff, NULL);\n      close_connection(thd);\n      mysql_mutex_lock(&LOCK_thd_remove);\n      mysql_mutex_lock(&LOCK_thread_count);\n      delete thd;\n      mysql_mutex_unlock(&LOCK_thread_count);\n      mysql_mutex_unlock(&LOCK_thd_remove);\n      return;\n      /* purecov: end */\n    }\n  }\n  mysql_mutex_unlock(&LOCK_thread_count);\n  DBUG_PRINT(\"info\",(\"Thread created\"));\n}\n\n\n/**\n  Create new thread to handle incoming connection.\n\n    This function will create new thread to handle the incoming\n    connection.  If there are idle cached threads one will be used.\n    'thd' will be pushed into 'threads'.\n\n    In single-threaded mode (\\#define ONE_THREAD) connection will be\n    handled inside this function.\n\n  @param[in,out] thd    Thread handle of future thread.\n*/\n\nstatic void create_new_thread(THD *thd)\n{\n  DBUG_ENTER(\"create_new_thread\");\n\n  /*\n    Don't allow too many connections. We roughly check here that we allow\n    only (max_connections + 1) connections.\n  */\n\n  mysql_mutex_lock(&LOCK_connection_count);\n\n  if (connection_count >= max_connections + 1 || abort_loop)\n  {\n    mysql_mutex_unlock(&LOCK_connection_count);\n\n    DBUG_PRINT(\"error\",(\"Too many connections\"));\n    close_connection(thd, ER_CON_COUNT_ERROR);\n    delete thd;\n    DBUG_VOID_RETURN;\n  }\n\n  ++connection_count;\n\n  if (connection_count > max_used_connections)\n    max_used_connections= connection_count;\n\n  mysql_mutex_unlock(&LOCK_connection_count);\n\n  /* Start a new thread to handle connection. */\n\n  mysql_mutex_lock(&LOCK_thread_count);\n\n  /*\n    The initialization of thread_id is done in create_embedded_thd() for\n    the embedded library.\n    TODO: refactor this to avoid code duplication there\n  */\n  thd->thread_id= thd->variables.pseudo_thread_id= thread_id++;\n\n  thread_count++;\n\n  MYSQL_CALLBACK(thread_scheduler, add_connection, (thd));\n\n  DBUG_VOID_RETURN;\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n#ifdef SIGNALS_DONT_BREAK_READ\ninline void kill_broken_server()\n{\n  /* hack to get around signals ignored in syscalls for problem OS's */\n  if (unix_sock == INVALID_SOCKET ||\n      (!opt_disable_networking && ip_sock == INVALID_SOCKET))\n  {\n    select_thread_in_use = 0;\n    /* The following call will never return */\n    kill_server((void*) MYSQL_KILL_SIGNAL);\n  }\n}\n#define MAYBE_BROKEN_SYSCALL kill_broken_server();\n#else\n#define MAYBE_BROKEN_SYSCALL\n#endif\n\n\t/* Handle new connections and spawn new process to handle them */\n\n#ifndef EMBEDDED_LIBRARY\n\nvoid handle_connections_sockets()\n{\n  my_socket UNINIT_VAR(sock), UNINIT_VAR(new_sock);\n  uint error_count=0;\n  THD *thd;\n  struct sockaddr_storage cAddr;\n  int ip_flags=0,socket_flags=0,flags=0,retval;\n  st_vio *vio_tmp;\n#ifdef HAVE_POLL\n  int socket_count= 0;\n  struct pollfd fds[2]; // for ip_sock and unix_sock\n#else\n  fd_set readFDs,clientFDs;\n  uint max_used_connection= (uint) (max(ip_sock,unix_sock)+1);\n#endif\n\n  DBUG_ENTER(\"handle_connections_sockets\");\n\n  (void) ip_flags;\n  (void) socket_flags;\n\n#ifndef HAVE_POLL\n  FD_ZERO(&clientFDs);\n#endif\n\n  if (ip_sock != INVALID_SOCKET)\n  {\n#ifdef HAVE_POLL\n    fds[socket_count].fd= ip_sock;\n    fds[socket_count].events= POLLIN;\n    socket_count++;\n#else\n    FD_SET(ip_sock,&clientFDs);\n#endif    \n#ifdef HAVE_FCNTL\n    ip_flags = fcntl(ip_sock, F_GETFL, 0);\n#endif\n  }\n#ifdef HAVE_SYS_UN_H\n#ifdef HAVE_POLL\n  fds[socket_count].fd= unix_sock;\n  fds[socket_count].events= POLLIN;\n  socket_count++;\n#else\n  FD_SET(unix_sock,&clientFDs);\n#endif\n#ifdef HAVE_FCNTL\n  socket_flags=fcntl(unix_sock, F_GETFL, 0);\n#endif\n#endif\n\n  DBUG_PRINT(\"general\",(\"Waiting for connections.\"));\n  MAYBE_BROKEN_SYSCALL;\n  while (!abort_loop)\n  {\n#ifdef HAVE_POLL\n    retval= poll(fds, socket_count, -1);\n#else\n    readFDs=clientFDs;\n\n    retval= select((int) max_used_connection,&readFDs,0,0,0);\n#endif\n\n    if (retval < 0)\n    {\n      if (socket_errno != SOCKET_EINTR)\n      {\n\tif (!select_errors++ && !abort_loop)\t/* purecov: inspected */\n\t  sql_print_error(\"mysqld: Got error %d from select\",socket_errno); /* purecov: inspected */\n      }\n      MAYBE_BROKEN_SYSCALL\n      continue;\n    }\n\n    if (abort_loop)\n    {\n      MAYBE_BROKEN_SYSCALL;\n      break;\n    }\n\n    /* Is this a new connection request ? */\n#ifdef HAVE_POLL\n    for (int i= 0; i < socket_count; ++i) \n    {\n      if (fds[i].revents & POLLIN)\n      {\n        sock= fds[i].fd;\n#ifdef HAVE_FCNTL\n        flags= fcntl(sock, F_GETFL, 0);\n#else\n        flags= 0;\n#endif // HAVE_FCNTL\n        break;\n      }\n    }\n#else  // HAVE_POLL\n#ifdef HAVE_SYS_UN_H\n    if (FD_ISSET(unix_sock,&readFDs))\n    {\n      sock = unix_sock;\n      flags= socket_flags;\n    }\n    else\n#endif // HAVE_SYS_UN_H\n    {\n      sock = ip_sock;\n      flags= ip_flags;\n    }\n#endif // HAVE_POLL\n\n#if !defined(NO_FCNTL_NONBLOCK)\n    if (!(test_flags & TEST_BLOCKING))\n    {\n#if defined(O_NONBLOCK)\n      fcntl(sock, F_SETFL, flags | O_NONBLOCK);\n#elif defined(O_NDELAY)\n      fcntl(sock, F_SETFL, flags | O_NDELAY);\n#endif\n    }\n#endif /* NO_FCNTL_NONBLOCK */\n    for (uint retry=0; retry < MAX_ACCEPT_RETRY; retry++)\n    {\n      size_socket length= sizeof(struct sockaddr_storage);\n      new_sock= accept(sock, (struct sockaddr *)(&cAddr),\n                       &length);\n      if (new_sock != INVALID_SOCKET ||\n\t  (socket_errno != SOCKET_EINTR && socket_errno != SOCKET_EAGAIN))\n\tbreak;\n      MAYBE_BROKEN_SYSCALL;\n#if !defined(NO_FCNTL_NONBLOCK)\n      if (!(test_flags & TEST_BLOCKING))\n      {\n\tif (retry == MAX_ACCEPT_RETRY - 1)\n\t  fcntl(sock, F_SETFL, flags);\t\t// Try without O_NONBLOCK\n      }\n#endif\n    }\n#if !defined(NO_FCNTL_NONBLOCK)\n    if (!(test_flags & TEST_BLOCKING))\n      fcntl(sock, F_SETFL, flags);\n#endif\n    if (new_sock == INVALID_SOCKET)\n    {\n      if ((error_count++ & 255) == 0)\t\t// This can happen often\n\tsql_perror(\"Error in accept\");\n      MAYBE_BROKEN_SYSCALL;\n      if (socket_errno == SOCKET_ENFILE || socket_errno == SOCKET_EMFILE)\n\tsleep(1);\t\t\t\t// Give other threads some time\n      continue;\n    }\n\n#ifdef HAVE_LIBWRAP\n    {\n      if (sock == ip_sock)\n      {\n\tstruct request_info req;\n\tsignal(SIGCHLD, SIG_DFL);\n\trequest_init(&req, RQ_DAEMON, libwrapName, RQ_FILE, new_sock, NULL);\n\tmy_fromhost(&req);\n\tif (!my_hosts_access(&req))\n\t{\n\t  /*\n\t    This may be stupid but refuse() includes an exit(0)\n\t    which we surely don't want...\n\t    clean_exit() - same stupid thing ...\n\t  */\n\t  syslog(deny_severity, \"refused connect from %s\",\n\t\t my_eval_client(&req));\n\n\t  /*\n\t    C++ sucks (the gibberish in front just translates the supplied\n\t    sink function pointer in the req structure from a void (*sink)();\n\t    to a void(*sink)(int) if you omit the cast, the C++ compiler\n\t    will cry...\n\t  */\n\t  if (req.sink)\n\t    ((void (*)(int))req.sink)(req.fd);\n\n\t  (void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n\t  (void) closesocket(new_sock);\n\t  continue;\n\t}\n      }\n    }\n#endif /* HAVE_LIBWRAP */\n\n    {\n      size_socket dummyLen;\n      struct sockaddr_storage dummy;\n      dummyLen = sizeof(dummy);\n      if (  getsockname(new_sock,(struct sockaddr *)&dummy, \n                  (SOCKET_SIZE_TYPE *)&dummyLen) < 0  )\n      {\n\tsql_perror(\"Error on new connection socket\");\n\t(void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n\t(void) closesocket(new_sock);\n\tcontinue;\n      }\n    }\n\n    /*\n    ** Don't allow too many connections\n    */\n\n    if (!(thd= new THD))\n    {\n      (void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n      (void) closesocket(new_sock);\n      continue;\n    }\n    if (!(vio_tmp=vio_new(new_sock,\n\t\t\t  sock == unix_sock ? VIO_TYPE_SOCKET :\n\t\t\t  VIO_TYPE_TCPIP,\n\t\t\t  sock == unix_sock ? VIO_LOCALHOST: 0)) ||\n\tmy_net_init(&thd->net,vio_tmp))\n    {\n      /*\n        Only delete the temporary vio if we didn't already attach it to the\n        NET object. The destructor in THD will delete any initialized net\n        structure.\n      */\n      if (vio_tmp && thd->net.vio != vio_tmp)\n        vio_delete(vio_tmp);\n      else\n      {\n\t(void) mysql_socket_shutdown(new_sock, SHUT_RDWR);\n\t(void) closesocket(new_sock);\n      }\n      delete thd;\n      continue;\n    }\n    if (sock == unix_sock)\n      thd->security_ctx->set_host((char*) my_localhost);\n\n    create_new_thread(thd);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\n#ifdef _WIN32\npthread_handler_t handle_connections_sockets_thread(void *arg)\n{\n  my_thread_init();\n  handle_connections_sockets();\n  decrement_handler_count();\n  return 0;\n}\n\npthread_handler_t handle_connections_namedpipes(void *arg)\n{\n  HANDLE hConnectedPipe;\n  OVERLAPPED connectOverlapped= {0};\n  THD *thd;\n  my_thread_init();\n  DBUG_ENTER(\"handle_connections_namedpipes\");\n  connectOverlapped.hEvent= CreateEvent(NULL, TRUE, FALSE, NULL);\n  if (!connectOverlapped.hEvent)\n  {\n    sql_print_error(\"Can't create event, last error=%u\", GetLastError());\n    unireg_abort(1);\n  }\n  DBUG_PRINT(\"general\",(\"Waiting for named pipe connections.\"));\n  while (!abort_loop)\n  {\n    /* wait for named pipe connection */\n    BOOL fConnected= ConnectNamedPipe(hPipe, &connectOverlapped);\n    if (!fConnected && (GetLastError() == ERROR_IO_PENDING))\n    {\n        /*\n          ERROR_IO_PENDING says async IO has started but not yet finished.\n          GetOverlappedResult will wait for completion.\n        */\n        DWORD bytes;\n        fConnected= GetOverlappedResult(hPipe, &connectOverlapped,&bytes, TRUE);\n    }\n    if (abort_loop)\n      break;\n    if (!fConnected)\n      fConnected = GetLastError() == ERROR_PIPE_CONNECTED;\n    if (!fConnected)\n    {\n      CloseHandle(hPipe);\n      if ((hPipe= CreateNamedPipe(pipe_name,\n                                  PIPE_ACCESS_DUPLEX |\n                                  FILE_FLAG_OVERLAPPED,\n                                  PIPE_TYPE_BYTE |\n                                  PIPE_READMODE_BYTE |\n                                  PIPE_WAIT,\n                                  PIPE_UNLIMITED_INSTANCES,\n                                  (int) global_system_variables.\n                                  net_buffer_length,\n                                  (int) global_system_variables.\n                                  net_buffer_length,\n                                  NMPWAIT_USE_DEFAULT_WAIT,\n                                  &saPipeSecurity)) ==\n\t  INVALID_HANDLE_VALUE)\n      {\n\tsql_perror(\"Can't create new named pipe!\");\n\tbreak;\t\t\t\t\t// Abort\n      }\n    }\n    hConnectedPipe = hPipe;\n    /* create new pipe for new connection */\n    if ((hPipe = CreateNamedPipe(pipe_name,\n                 PIPE_ACCESS_DUPLEX |\n                 FILE_FLAG_OVERLAPPED,\n\t\t\t\t PIPE_TYPE_BYTE |\n\t\t\t\t PIPE_READMODE_BYTE |\n\t\t\t\t PIPE_WAIT,\n\t\t\t\t PIPE_UNLIMITED_INSTANCES,\n\t\t\t\t (int) global_system_variables.net_buffer_length,\n\t\t\t\t (int) global_system_variables.net_buffer_length,\n\t\t\t\t NMPWAIT_USE_DEFAULT_WAIT,\n\t\t\t\t &saPipeSecurity)) ==\n\tINVALID_HANDLE_VALUE)\n    {\n      sql_perror(\"Can't create new named pipe!\");\n      hPipe=hConnectedPipe;\n      continue;\t\t\t\t\t// We have to try again\n    }\n\n    if (!(thd = new THD))\n    {\n      DisconnectNamedPipe(hConnectedPipe);\n      CloseHandle(hConnectedPipe);\n      continue;\n    }\n    if (!(thd->net.vio= vio_new_win32pipe(hConnectedPipe)) ||\n\tmy_net_init(&thd->net, thd->net.vio))\n    {\n      close_connection(thd, ER_OUT_OF_RESOURCES);\n      delete thd;\n      continue;\n    }\n    /* Host is unknown */\n    thd->security_ctx->set_host(my_strdup(my_localhost, MYF(0)));\n    create_new_thread(thd);\n  }\n  CloseHandle(connectOverlapped.hEvent);\n  DBUG_LEAVE;\n  decrement_handler_count();\n  return 0;\n}\n#endif /* _WIN32 */\n\n\n#ifdef HAVE_SMEM\n\n/**\n  Thread of shared memory's service.\n\n  @param arg                              Arguments of thread\n*/\npthread_handler_t handle_connections_shared_memory(void *arg)\n{\n  /* file-mapping object, use for create shared memory */\n  HANDLE handle_connect_file_map= 0;\n  char  *handle_connect_map= 0;                 // pointer on shared memory\n  HANDLE event_connect_answer= 0;\n  ulong smem_buffer_length= shared_memory_buffer_length + 4;\n  ulong connect_number= 1;\n  char *tmp= NULL;\n  char *suffix_pos;\n  char connect_number_char[22], *p;\n  const char *errmsg= 0;\n  SECURITY_ATTRIBUTES *sa_event= 0, *sa_mapping= 0;\n  my_thread_init();\n  DBUG_ENTER(\"handle_connections_shared_memorys\");\n  DBUG_PRINT(\"general\",(\"Waiting for allocated shared memory.\"));\n\n  /*\n     get enough space base-name + '_' + longest suffix we might ever send\n   */\n  if (!(tmp= (char *)my_malloc(strlen(shared_memory_base_name) + 32L, MYF(MY_FAE))))\n    goto error;\n\n  if (my_security_attr_create(&sa_event, &errmsg,\n                              GENERIC_ALL, SYNCHRONIZE | EVENT_MODIFY_STATE))\n    goto error;\n\n  if (my_security_attr_create(&sa_mapping, &errmsg,\n                             GENERIC_ALL, FILE_MAP_READ | FILE_MAP_WRITE))\n    goto error;\n\n  /*\n    The name of event and file-mapping events create agree next rule:\n      shared_memory_base_name+unique_part\n    Where:\n      shared_memory_base_name is unique value for each server\n      unique_part is unique value for each object (events and file-mapping)\n  */\n  suffix_pos= strxmov(tmp,shared_memory_base_name,\"_\",NullS);\n  strmov(suffix_pos, \"CONNECT_REQUEST\");\n  if ((smem_event_connect_request= CreateEvent(sa_event,\n                                               FALSE, FALSE, tmp)) == 0)\n  {\n    errmsg= \"Could not create request event\";\n    goto error;\n  }\n  strmov(suffix_pos, \"CONNECT_ANSWER\");\n  if ((event_connect_answer= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n  {\n    errmsg=\"Could not create answer event\";\n    goto error;\n  }\n  strmov(suffix_pos, \"CONNECT_DATA\");\n  if ((handle_connect_file_map=\n       CreateFileMapping(INVALID_HANDLE_VALUE, sa_mapping,\n                         PAGE_READWRITE, 0, sizeof(connect_number), tmp)) == 0)\n  {\n    errmsg= \"Could not create file mapping\";\n    goto error;\n  }\n  if ((handle_connect_map= (char *)MapViewOfFile(handle_connect_file_map,\n\t\t\t\t\t\t  FILE_MAP_WRITE,0,0,\n\t\t\t\t\t\t  sizeof(DWORD))) == 0)\n  {\n    errmsg= \"Could not create shared memory service\";\n    goto error;\n  }\n\n  while (!abort_loop)\n  {\n    /* Wait a request from client */\n    WaitForSingleObject(smem_event_connect_request,INFINITE);\n\n    /*\n       it can be after shutdown command\n    */\n    if (abort_loop)\n      goto error;\n\n    HANDLE handle_client_file_map= 0;\n    char  *handle_client_map= 0;\n    HANDLE event_client_wrote= 0;\n    HANDLE event_client_read= 0;    // for transfer data server <-> client\n    HANDLE event_server_wrote= 0;\n    HANDLE event_server_read= 0;\n    HANDLE event_conn_closed= 0;\n    THD *thd= 0;\n\n    p= int10_to_str(connect_number, connect_number_char, 10);\n    /*\n      The name of event and file-mapping events create agree next rule:\n        shared_memory_base_name+unique_part+number_of_connection\n        Where:\n\t  shared_memory_base_name is uniquel value for each server\n\t  unique_part is unique value for each object (events and file-mapping)\n\t  number_of_connection is connection-number between server and client\n    */\n    suffix_pos= strxmov(tmp,shared_memory_base_name,\"_\",connect_number_char,\n\t\t\t \"_\",NullS);\n    strmov(suffix_pos, \"DATA\");\n    if ((handle_client_file_map=\n         CreateFileMapping(INVALID_HANDLE_VALUE, sa_mapping,\n                           PAGE_READWRITE, 0, smem_buffer_length, tmp)) == 0)\n    {\n      errmsg= \"Could not create file mapping\";\n      goto errorconn;\n    }\n    if ((handle_client_map= (char*)MapViewOfFile(handle_client_file_map,\n\t\t\t\t\t\t  FILE_MAP_WRITE,0,0,\n\t\t\t\t\t\t  smem_buffer_length)) == 0)\n    {\n      errmsg= \"Could not create memory map\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"CLIENT_WROTE\");\n    if ((event_client_wrote= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create client write event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"CLIENT_READ\");\n    if ((event_client_read= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create client read event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"SERVER_READ\");\n    if ((event_server_read= CreateEvent(sa_event, FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create server read event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"SERVER_WROTE\");\n    if ((event_server_wrote= CreateEvent(sa_event,\n                                         FALSE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create server write event\";\n      goto errorconn;\n    }\n    strmov(suffix_pos, \"CONNECTION_CLOSED\");\n    if ((event_conn_closed= CreateEvent(sa_event,\n                                        TRUE, FALSE, tmp)) == 0)\n    {\n      errmsg= \"Could not create closed connection event\";\n      goto errorconn;\n    }\n    if (abort_loop)\n      goto errorconn;\n    if (!(thd= new THD))\n      goto errorconn;\n    /* Send number of connection to client */\n    int4store(handle_connect_map, connect_number);\n    if (!SetEvent(event_connect_answer))\n    {\n      errmsg= \"Could not send answer event\";\n      goto errorconn;\n    }\n    /* Set event that client should receive data */\n    if (!SetEvent(event_client_read))\n    {\n      errmsg= \"Could not set client to read mode\";\n      goto errorconn;\n    }\n    if (!(thd->net.vio= vio_new_win32shared_memory(handle_client_file_map,\n                                                   handle_client_map,\n                                                   event_client_wrote,\n                                                   event_client_read,\n                                                   event_server_wrote,\n                                                   event_server_read,\n                                                   event_conn_closed)) ||\n                        my_net_init(&thd->net, thd->net.vio))\n    {\n      close_connection(thd, ER_OUT_OF_RESOURCES);\n      errmsg= 0;\n      goto errorconn;\n    }\n    thd->security_ctx->set_host(my_strdup(my_localhost, MYF(0))); /* Host is unknown */\n    create_new_thread(thd);\n    connect_number++;\n    continue;\n\nerrorconn:\n    /* Could not form connection;  Free used handlers/memort and retry */\n    if (errmsg)\n    {\n      char buff[180];\n      strxmov(buff, \"Can't create shared memory connection: \", errmsg, \".\",\n\t      NullS);\n      sql_perror(buff);\n    }\n    if (handle_client_file_map)\n      CloseHandle(handle_client_file_map);\n    if (handle_client_map)\n      UnmapViewOfFile(handle_client_map);\n    if (event_server_wrote)\n      CloseHandle(event_server_wrote);\n    if (event_server_read)\n      CloseHandle(event_server_read);\n    if (event_client_wrote)\n      CloseHandle(event_client_wrote);\n    if (event_client_read)\n      CloseHandle(event_client_read);\n    if (event_conn_closed)\n      CloseHandle(event_conn_closed);\n    delete thd;\n  }\n\n  /* End shared memory handling */\nerror:\n  if (tmp)\n    my_free(tmp);\n\n  if (errmsg)\n  {\n    char buff[180];\n    strxmov(buff, \"Can't create shared memory service: \", errmsg, \".\", NullS);\n    sql_perror(buff);\n  }\n  my_security_attr_free(sa_event);\n  my_security_attr_free(sa_mapping);\n  if (handle_connect_map)\tUnmapViewOfFile(handle_connect_map);\n  if (handle_connect_file_map)\tCloseHandle(handle_connect_file_map);\n  if (event_connect_answer)\tCloseHandle(event_connect_answer);\n  if (smem_event_connect_request) CloseHandle(smem_event_connect_request);\n  DBUG_LEAVE;\n  decrement_handler_count();\n  return 0;\n}\n#endif /* HAVE_SMEM */\n#endif /* EMBEDDED_LIBRARY */\n\n\n/****************************************************************************\n  Handle start options\n******************************************************************************/\n\nDYNAMIC_ARRAY all_options;\n\n/**\n  System variables are automatically command-line options (few\n  exceptions are documented in sys_var.h), so don't need\n  to be listed here.\n*/\n\nstruct my_option my_long_options[]=\n{\n  {\"help\", '?', \"Display this help and exit.\", \n   &opt_help, &opt_help, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0,\n   0, 0},\n#ifdef HAVE_REPLICATION\n  {\"abort-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &abort_slave_event_count,  &abort_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"allow-suspicious-udfs\", 0,\n   \"Allows use of UDFs consisting of only one symbol xxx() \"\n   \"without corresponding xxx_init() or xxx_deinit(). That also means \"\n   \"that one can load any function from any library, for example exit() \"\n   \"from libc.so\",\n   &opt_allow_suspicious_udfs, &opt_allow_suspicious_udfs,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"ansi\", 'a', \"Use ANSI SQL syntax instead of MySQL syntax. This mode \"\n   \"will also set transaction isolation level 'serializable'.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /*\n    Because Sys_var_bit does not support command-line options, we need to\n    explicitely add one for --autocommit\n  */\n  {\"autocommit\", 0, \"Set default value for autocommit (0 or 1)\",\n   &opt_autocommit, &opt_autocommit, 0,\n   GET_BOOL, OPT_ARG, 1, 0, 0, 0, 0, NULL},\n  {\"bind-address\", OPT_BIND_ADDRESS, \"IP address to bind to.\",\n   &my_bind_addr_str, &my_bind_addr_str, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-do-db\", OPT_BINLOG_DO_DB,\n   \"Tells the master it should log updates for the specified database, \"\n   \"and exclude all others not explicitly mentioned.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-ignore-db\", OPT_BINLOG_IGNORE_DB,\n   \"Tells the master that updates to the given database should not be logged to the binary log.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-row-event-max-size\", 0,\n   \"The maximum size of a row-based binary log event in bytes. Rows will be \"\n   \"grouped into events smaller than this size if possible. \"\n   \"The value has to be a multiple of 256.\",\n   &opt_binlog_rows_event_max_size, &opt_binlog_rows_event_max_size,\n   0, GET_ULONG, REQUIRED_ARG,\n   /* def_value */ 1024, /* min_value */  256, /* max_value */ ULONG_MAX, \n   /* sub_size */     0, /* block_size */ 256, \n   /* app_type */ 0\n  },\n#ifndef DISABLE_GRANT_OPTIONS\n  {\"bootstrap\", OPT_BOOTSTRAP, \"Used by mysql installation scripts.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"character-set-client-handshake\", 0,\n   \"Don't ignore client side character set value sent during handshake.\",\n   &opt_character_set_client_handshake,\n   &opt_character_set_client_handshake,\n    0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n  {\"character-set-filesystem\", 0,\n   \"Set the filesystem character set.\",\n   &character_set_filesystem_name,\n   &character_set_filesystem_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"character-set-server\", 'C', \"Set the default character set.\",\n   &default_character_set_name, &default_character_set_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"chroot\", 'r', \"Chroot mysqld daemon during startup.\",\n   &mysqld_chroot, &mysqld_chroot, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"collation-server\", 0, \"Set the default collation.\",\n   &default_collation_name, &default_collation_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"console\", OPT_CONSOLE, \"Write error output on screen; don't remove the console window on windows.\",\n   &opt_console, &opt_console, 0, GET_BOOL, NO_ARG, 0, 0, 0,\n   0, 0, 0},\n  {\"core-file\", OPT_WANT_CORE, \"Write core on errors.\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  /* default-storage-engine should have \"MyISAM\" as def_value. Instead\n     of initializing it here it is done in init_common_variables() due\n     to a compiler bug in Sun Studio compiler. */\n  {\"default-storage-engine\", 0, \"The default storage engine for new tables\",\n   &default_storage_engine, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"default-time-zone\", 0, \"Set the default time zone.\",\n   &default_tz_name, &default_tz_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n#ifdef HAVE_OPENSSL\n  {\"des-key-file\", 0,\n   \"Load keys for des_encrypt() and des_encrypt from given file.\",\n   &des_key_file, &des_key_file, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_REPLICATION\n  {\"disconnect-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &disconnect_slave_event_count, &disconnect_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"exit-info\", 'T', \"Used for debugging. Use at your own risk.\", 0, 0, 0,\n   GET_LONG, OPT_ARG, 0, 0, 0, 0, 0, 0},\n\n  {\"external-locking\", 0, \"Use system (external) locking (disabled by \"\n   \"default).  With this option enabled you can run myisamchk to test \"\n   \"(not repair) tables while the MySQL server is running. Disable with \"\n   \"--skip-external-locking.\", &opt_external_locking, &opt_external_locking,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /* We must always support the next option to make scripts like mysqltest\n     easier to do */\n  {\"gdb\", 0,\n   \"Set up signals usable for debugging.\",\n   &opt_debugging, &opt_debugging,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_LARGE_PAGE_OPTION\n  {\"super-large-pages\", 0, \"Enable support for super large pages.\",\n   &opt_super_large_pages, &opt_super_large_pages, 0,\n   GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},\n#endif\n  {\"language\", 'L',\n   \"Client error messages in given language. May be given as a full path. \"\n   \"Deprecated. Use --lc-messages-dir instead.\",\n   &lc_messages_dir_ptr, &lc_messages_dir_ptr, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"lc-messages\", 0,\n   \"Set the language used for the error messages.\",\n   &lc_messages, &lc_messages, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"lc-time-names\", 0,\n   \"Set the language used for the month names and the days of the week.\",\n   &lc_time_names_name, &lc_time_names_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"log\", 'l', \"Log connections and queries to file (deprecated option, use \"\n   \"--general-log/--general-log-file instead).\", &opt_logname, &opt_logname,\n   0, GET_STR_ALLOC, OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-bin\", OPT_BIN_LOG,\n   \"Log update queries in binary format. Optional (but strongly recommended \"\n   \"to avoid replication problems if server's hostname changes) argument \"\n   \"should be the chosen location for the binary log files.\",\n   &opt_bin_logname, &opt_bin_logname, 0, GET_STR_ALLOC,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-bin-index\", 0,\n   \"File that holds the names for last binary log files.\",\n   &opt_binlog_index_name, &opt_binlog_index_name, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-isam\", OPT_ISAM_LOG, \"Log all MyISAM changes to file.\",\n   &myisam_log_filename, &myisam_log_filename, 0, GET_STR,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-short-format\", 0,\n   \"Don't log extra information to update and slow-query logs.\",\n   &opt_short_log_format, &opt_short_log_format,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-slow-admin-statements\", 0,\n   \"Log slow OPTIMIZE, ANALYZE, ALTER and other administrative statements to \"\n   \"the slow log if it is open.\", &opt_log_slow_admin_statements,\n   &opt_log_slow_admin_statements, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n {\"log-slow-slave-statements\", 0,\n  \"Log slow statements executed by slave thread to the slow log if it is open.\",\n  &opt_log_slow_slave_statements, &opt_log_slow_slave_statements,\n  0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-slow-queries\", OPT_SLOW_QUERY_LOG,\n   \"Log slow queries to a table or log file. Defaults logging to table \"\n   \"mysql.slow_log or hostname-slow.log if --log-output=file is used. \"\n   \"Must be enabled to activate other slow log options. \"\n   \"Deprecated option, use --slow-query-log/--slow-query-log-file instead.\",\n   &opt_slow_logname, &opt_slow_logname, 0, GET_STR_ALLOC, OPT_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"log-tc\", 0,\n   \"Path to transaction coordinator log (used for transactions that affect \"\n   \"more than one storage engine, when binary log is disabled).\",\n   &opt_tc_log_file, &opt_tc_log_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_MMAP\n  {\"log-tc-size\", 0, \"Size of transaction coordinator log.\",\n   &opt_tc_log_size, &opt_tc_log_size, 0, GET_ULONG,\n   REQUIRED_ARG, TC_LOG_MIN_SIZE, TC_LOG_MIN_SIZE, ULONG_MAX, 0,\n   TC_LOG_PAGE_SIZE, 0},\n#endif\n  {\"master-info-file\", 0,\n   \"The location and name of the file that remembers the master and where \"\n   \"the I/O replication thread is in the master's binlogs.\",\n   &master_info_file, &master_info_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"master-retry-count\", 0,\n   \"The number of tries the slave will make to connect to the master before giving up.\",\n   &master_retry_count, &master_retry_count, 0, GET_ULONG,\n   REQUIRED_ARG, 3600*24, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"init-rpl-role\", 0, \"Set the replication role.\",\n   &rpl_status, &rpl_status, &rpl_role_typelib,\n   GET_ENUM, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"max-binlog-dump-events\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &max_binlog_dump_events, &max_binlog_dump_events, 0,\n   GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"memlock\", 0, \"Lock mysqld in memory.\", &locked_in_memory,\n   &locked_in_memory, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"one-thread\", OPT_ONE_THREAD,\n   \"(Deprecated): Only use one thread (for debugging under Linux). Use \"\n   \"thread-handling=no-threads instead.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"old-style-user-limits\", 0,\n   \"Enable old-style user limits (before 5.0.3, user resources were counted \"\n   \"per each user+host vs. per account).\",\n   &opt_old_style_user_limits, &opt_old_style_user_limits,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"port-open-timeout\", 0,\n   \"Maximum time in seconds to wait for the port to become free. \"\n   \"(Default: No wait).\", &mysqld_port_timeout, &mysqld_port_timeout, 0,\n   GET_UINT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-db\", OPT_REPLICATE_DO_DB,\n   \"Tells the slave thread to restrict replication to the specified database. \"\n   \"To specify more than one database, use the directive multiple times, \"\n   \"once for each database. Note that this will only work if you do not use \"\n   \"cross-database queries such as UPDATE some_db.some_table SET foo='bar' \"\n   \"while having selected a different or no database. If you need cross \"\n   \"database updates to work, make sure you have 3.23.28 or later, and use \"\n   \"replicate-wild-do-table=db_name.%.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-table\", OPT_REPLICATE_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the specified table. \"\n   \"To specify more than one table, use the directive multiple times, once \"\n   \"for each table. This will work for cross-database updates, in contrast \"\n   \"to replicate-do-db.\", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-db\", OPT_REPLICATE_IGNORE_DB,\n   \"Tells the slave thread to not replicate to the specified database. To \"\n   \"specify more than one database to ignore, use the directive multiple \"\n   \"times, once for each database. This option will not work if you use \"\n   \"cross database updates. If you need cross database updates to work, \"\n   \"make sure you have 3.23.28 or later, and use replicate-wild-ignore-\"\n   \"table=db_name.%. \", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-table\", OPT_REPLICATE_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the specified table. To specify \"\n   \"more than one table to ignore, use the directive multiple times, once for \"\n   \"each table. This will work for cross-database updates, in contrast to \"\n   \"replicate-ignore-db.\", 0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-rewrite-db\", OPT_REPLICATE_REWRITE_DB,\n   \"Updates to a database with a different name than the original. Example: \"\n   \"replicate-rewrite-db=master_db_name->slave_db_name.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"replicate-same-server-id\", 0,\n   \"In replication, if set to 1, do not skip events having our server id. \"\n   \"Default value is 0 (to break infinite loops in circular replication). \"\n   \"Can't be set to 1 if --log-slave-updates is used.\",\n   &replicate_same_server_id, &replicate_same_server_id,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"replicate-wild-do-table\", OPT_REPLICATE_WILD_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the tables that match \"\n   \"the specified wildcard pattern. To specify more than one table, use the \"\n   \"directive multiple times, once for each table. This will work for cross-\"\n   \"database updates. Example: replicate-wild-do-table=foo%.bar% will \"\n   \"replicate only updates to tables in all databases that start with foo \"\n   \"and whose table names start with bar.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-wild-ignore-table\", OPT_REPLICATE_WILD_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the tables that match the \"\n   \"given wildcard pattern. To specify more than one table to ignore, use \"\n   \"the directive multiple times, once for each table. This will work for \"\n   \"cross-database updates. Example: replicate-wild-ignore-table=foo%.bar% \"\n   \"will not do updates to tables in databases that start with foo and whose \"\n   \"table names start with bar.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"safe-mode\", OPT_SAFE, \"Skip some optimize stages (for testing). Deprecated.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"safe-user-create\", 0,\n   \"Don't allow new user creation by the user who has no write privileges to the mysql.user table.\",\n   &opt_safe_user_create, &opt_safe_user_create, 0, GET_BOOL,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"show-slave-auth-info\", 0,\n   \"Show user and password in SHOW SLAVE HOSTS on this master.\",\n   &opt_show_slave_auth_info, &opt_show_slave_auth_info, 0,\n   GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifndef DISABLE_GRANT_OPTIONS\n  {\"skip-grant-tables\", 0,\n   \"Start without grant tables. This gives all users FULL ACCESS to all tables.\",\n   &opt_noacl, &opt_noacl, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n#endif\n  {\"skip-host-cache\", OPT_SKIP_HOST_CACHE, \"Don't cache host names.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-new\", OPT_SKIP_NEW, \"Don't use new, possibly wrong routines.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-slave-start\", 0,\n   \"If set, slave is not autostarted.\", &opt_skip_slave_start,\n   &opt_skip_slave_start, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-stack-trace\", OPT_SKIP_STACK_TRACE,\n   \"Don't print a stack trace on failure.\", 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0,\n   0, 0, 0, 0},\n  {\"skip-thread-priority\", OPT_SKIP_PRIOR,\n   \"Don't give threads different priorities. This option is deprecated \"\n   \"because it has no effect; the implied behavior is already the default.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  {\"slow-start-timeout\", 0,\n   \"Maximum number of milliseconds that the service control manager should wait \"\n   \"before trying to kill the windows service during startup\"\n   \"(Default: 15000).\", &slow_start_timeout, &slow_start_timeout, 0,\n   GET_ULONG, REQUIRED_ARG, 15000, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_REPLICATION\n  {\"sporadic-binlog-dump-fail\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &opt_sporadic_binlog_dump_fail,\n   &opt_sporadic_binlog_dump_fail, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n#endif /* HAVE_REPLICATION */\n#ifdef HAVE_OPENSSL\n  {\"ssl\", 0,\n   \"Enable SSL for connection (automatically enabled with other flags).\",\n   &opt_use_ssl, &opt_use_ssl, 0, GET_BOOL, OPT_ARG, 0, 0, 0,\n   0, 0, 0},\n#endif\n#ifdef __WIN__\n  {\"standalone\", 0,\n  \"Dummy option to start as a standalone program (NT).\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"symbolic-links\", 's', \"Enable symbolic link support.\",\n   &my_use_symdir, &my_use_symdir, 0, GET_BOOL, NO_ARG,\n   /*\n     The system call realpath() produces warnings under valgrind and\n     purify. These are not suppressed: instead we disable symlinks\n     option if compiled with valgrind support.\n   */\n   IF_PURIFY(0,1), 0, 0, 0, 0, 0},\n  {\"sysdate-is-now\", 0,\n   \"Non-default option to alias SYSDATE() to NOW() to make it safe-replicable. \"\n   \"Since 5.0, SYSDATE() returns a `dynamic' value different for different \"\n   \"invocations, even within the same statement.\",\n   &global_system_variables.sysdate_is_now,\n   0, 0, GET_BOOL, NO_ARG, 0, 0, 1, 0, 1, 0},\n  {\"tc-heuristic-recover\", 0,\n   \"Decision to use in heuristic recover process. Possible values are COMMIT \"\n   \"or ROLLBACK.\", &tc_heuristic_recover, &tc_heuristic_recover,\n   &tc_heuristic_recover_typelib, GET_ENUM, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#if defined(ENABLED_DEBUG_SYNC)\n  {\"debug-sync-timeout\", OPT_DEBUG_SYNC_TIMEOUT,\n   \"Enable the debug sync facility \"\n   \"and optionally specify a default wait timeout in seconds. \"\n   \"A zero value keeps the facility disabled.\",\n   &opt_debug_sync_timeout, 0,\n   0, GET_UINT, OPT_ARG, 0, 0, UINT_MAX, 0, 0, 0},\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  {\"temp-pool\", 0,\n#if (ENABLE_TEMP_POOL)\n   \"Using this option will cause most temporary files created to use a small \"\n   \"set of names, rather than a unique name for each new file.\",\n#else\n   \"This option is ignored on this OS.\",\n#endif\n   &use_temp_pool, &use_temp_pool, 0, GET_BOOL, NO_ARG, 1,\n   0, 0, 0, 0, 0},\n  {\"transaction-isolation\", 0,\n   \"Default transaction isolation level.\",\n   &global_system_variables.tx_isolation,\n   &global_system_variables.tx_isolation, &tx_isolation_typelib,\n   GET_ENUM, REQUIRED_ARG, ISO_REPEATABLE_READ, 0, 0, 0, 0, 0},\n  {\"user\", 'u', \"Run mysqld daemon as user.\", 0, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"verbose\", 'v', \"Used with --help option for detailed help.\",\n   &opt_verbose, &opt_verbose, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"version\", 'V', \"Output version information and exit.\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"plugin-load\", 0,\n   \"Optional semicolon-separated list of plugins to load, where each plugin is \"\n   \"identified as name=library, where name is the plugin name and library \"\n   \"is the plugin library in plugin_dir.\",\n   &opt_plugin_load, &opt_plugin_load, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"table_cache\", 0, \"Deprecated; use --table-open-cache instead.\",\n   &table_cache_size, &table_cache_size, 0, GET_ULONG,\n   REQUIRED_ARG, TABLE_OPEN_CACHE_DEFAULT, 1, 512*1024L, 0, 1, 0},\n  {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n};\n\n\nstatic int show_queries(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= (char *)&thd->query_id;\n  return 0;\n}\n\n\nstatic int show_net_compression(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_MY_BOOL;\n  var->value= (char *)&thd->net.compress;\n  return 0;\n}\n\nstatic int show_starttime(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long) (thd->query_start() - server_start_time);\n  return 0;\n}\n\n#ifdef ENABLED_PROFILING\nstatic int show_flushstatustime(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long) (thd->query_start() - flush_status_time);\n  return 0;\n}\n#endif\n\n#ifdef HAVE_REPLICATION\nstatic int show_rpl_status(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  var->value= const_cast<char*>(rpl_status_type[(int)rpl_status]);\n  return 0;\n}\n\nstatic int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_MY_BOOL;\n  mysql_mutex_lock(&LOCK_active_mi);\n  var->value= buff;\n  *((my_bool *)buff)= (my_bool) (active_mi && \n                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&\n                                 active_mi->rli.slave_running);\n  mysql_mutex_unlock(&LOCK_active_mi);\n  return 0;\n}\n\nstatic int show_slave_retried_trans(THD *thd, SHOW_VAR *var, char *buff)\n{\n  /*\n    TODO: with multimaster, have one such counter per line in\n    SHOW SLAVE STATUS, and have the sum over all lines here.\n  */\n  mysql_mutex_lock(&LOCK_active_mi);\n  if (active_mi)\n  {\n    var->type= SHOW_LONG;\n    var->value= buff;\n    mysql_mutex_lock(&active_mi->rli.data_lock);\n    *((long *)buff)= (long)active_mi->rli.retried_trans;\n    mysql_mutex_unlock(&active_mi->rli.data_lock);\n  }\n  else\n    var->type= SHOW_UNDEF;\n  mysql_mutex_unlock(&LOCK_active_mi);\n  return 0;\n}\n\nstatic int show_slave_received_heartbeats(THD *thd, SHOW_VAR *var, char *buff)\n{\n  mysql_mutex_lock(&LOCK_active_mi);\n  if (active_mi)\n  {\n    var->type= SHOW_LONGLONG;\n    var->value= buff;\n    mysql_mutex_lock(&active_mi->rli.data_lock);\n    *((longlong *)buff)= active_mi->received_heartbeats;\n    mysql_mutex_unlock(&active_mi->rli.data_lock);\n  }\n  else\n    var->type= SHOW_UNDEF;\n  mysql_mutex_unlock(&LOCK_active_mi);\n  return 0;\n}\n\nstatic int show_heartbeat_period(THD *thd, SHOW_VAR *var, char *buff)\n{\n  mysql_mutex_lock(&LOCK_active_mi);\n  if (active_mi)\n  {\n    var->type= SHOW_CHAR;\n    var->value= buff;\n    sprintf(buff, \"%.3f\", active_mi->heartbeat_period);\n  }\n  else\n    var->type= SHOW_UNDEF;\n  mysql_mutex_unlock(&LOCK_active_mi);\n  return 0;\n}\n\n\n#endif /* HAVE_REPLICATION */\n\nstatic int show_open_tables(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long)cached_open_tables();\n  return 0;\n}\n\nstatic int show_prepared_stmt_count(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  mysql_mutex_lock(&LOCK_prepared_stmt_count);\n  *((long *)buff)= (long)prepared_stmt_count;\n  mysql_mutex_unlock(&LOCK_prepared_stmt_count);\n  return 0;\n}\n\nstatic int show_table_definitions(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long)cached_table_definitions();\n  return 0;\n}\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n/* Functions relying on CTX */\nstatic int show_ssl_ctx_sess_accept(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_accept_good(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept_good(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect_good(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect_good(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_accept_renegotiate(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_accept_renegotiate(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect_renegotiate(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect_renegotiate(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_cb_hits(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_cb_hits(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_hits(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_hits(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_cache_full(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_cache_full(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_misses(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_misses(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_timeouts(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_timeouts(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_number(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_number(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_connect(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_connect(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_sess_get_cache_size(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_sess_get_cache_size(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_get_verify_mode(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (!ssl_acceptor_fd ? 0 :\n                     SSL_CTX_get_verify_depth(ssl_acceptor_fd->ssl_context));\n  return 0;\n}\n\nstatic int show_ssl_ctx_get_session_cache_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if (!ssl_acceptor_fd)\n    var->value= const_cast<char*>(\"NONE\");\n  else\n    switch (SSL_CTX_get_session_cache_mode(ssl_acceptor_fd->ssl_context))\n    {\n    case SSL_SESS_CACHE_OFF:\n      var->value= const_cast<char*>(\"OFF\"); break;\n    case SSL_SESS_CACHE_CLIENT:\n      var->value= const_cast<char*>(\"CLIENT\"); break;\n    case SSL_SESS_CACHE_SERVER:\n      var->value= const_cast<char*>(\"SERVER\"); break;\n    case SSL_SESS_CACHE_BOTH:\n      var->value= const_cast<char*>(\"BOTH\"); break;\n    case SSL_SESS_CACHE_NO_AUTO_CLEAR:\n      var->value= const_cast<char*>(\"NO_AUTO_CLEAR\"); break;\n    case SSL_SESS_CACHE_NO_INTERNAL_LOOKUP:\n      var->value= const_cast<char*>(\"NO_INTERNAL_LOOKUP\"); break;\n    default:\n      var->value= const_cast<char*>(\"Unknown\"); break;\n    }\n  return 0;\n}\n\n/*\n   Functions relying on SSL \n   Note: In the show_ssl_* functions, we need to check if we have a\n         valid vio-object since this isn't always true, specifically\n         when session_status or global_status is requested from\n         inside an Event.\n */\nstatic int show_ssl_get_version(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    var->value= const_cast<char*>(SSL_get_version((SSL*) thd->net.vio->ssl_arg));\n  else\n    var->value= (char *)\"\";\n  return 0;\n}\n\nstatic int show_ssl_session_reused(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_session_reused((SSL*) thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_default_timeout(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_default_timeout((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->net.vio && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_verify_mode((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_verify_depth((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_cipher(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    var->value= const_cast<char*>(SSL_get_cipher((SSL*) thd->net.vio->ssl_arg));\n  else\n    var->value= (char *)\"\";\n  return 0;\n}\n\nstatic int show_ssl_get_cipher_list(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_CHAR;\n  var->value= buff;\n  if (thd->vio_ok() && thd->net.vio->ssl_arg)\n  {\n    int i;\n    const char *p;\n    char *end= buff + SHOW_VAR_FUNC_BUFF_SIZE;\n    for (i=0; (p= SSL_get_cipher_list((SSL*) thd->net.vio->ssl_arg,i)) &&\n               buff < end; i++)\n    {\n      buff= strnmov(buff, p, end-buff-1);\n      *buff++= ':';\n    }\n    if (i)\n      buff--;\n  }\n  *buff=0;\n  return 0;\n}\n\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY */\n\n\n/*\n  Variables shown by SHOW STATUS in alphabetical order\n*/\n\nSHOW_VAR status_vars[]= {\n  {\"Aborted_clients\",          (char*) &aborted_threads,        SHOW_LONG},\n  {\"Aborted_connects\",         (char*) &aborted_connects,       SHOW_LONG},\n  {\"Binlog_cache_disk_use\",    (char*) &binlog_cache_disk_use,  SHOW_LONG},\n  {\"Binlog_cache_use\",         (char*) &binlog_cache_use,       SHOW_LONG},\n  {\"Binlog_stmt_cache_disk_use\",(char*) &binlog_stmt_cache_disk_use,  SHOW_LONG},\n  {\"Binlog_stmt_cache_use\",    (char*) &binlog_stmt_cache_use,       SHOW_LONG},\n  {\"Bytes_received\",           (char*) offsetof(STATUS_VAR, bytes_received), SHOW_LONGLONG_STATUS},\n  {\"Bytes_sent\",               (char*) offsetof(STATUS_VAR, bytes_sent), SHOW_LONGLONG_STATUS},\n  {\"Com\",                      (char*) com_status_vars, SHOW_ARRAY},\n  {\"Compression\",              (char*) &show_net_compression, SHOW_FUNC},\n  {\"Connections\",              (char*) &thread_id,              SHOW_LONG_NOFLUSH},\n  {\"Created_tmp_disk_tables\",  (char*) offsetof(STATUS_VAR, created_tmp_disk_tables), SHOW_LONG_STATUS},\n  {\"Created_tmp_files\",\t       (char*) &my_tmp_file_created,\tSHOW_LONG},\n  {\"Created_tmp_tables\",       (char*) offsetof(STATUS_VAR, created_tmp_tables), SHOW_LONG_STATUS},\n  {\"Delayed_errors\",           (char*) &delayed_insert_errors,  SHOW_LONG},\n  {\"Delayed_insert_threads\",   (char*) &delayed_insert_threads, SHOW_LONG_NOFLUSH},\n  {\"Delayed_writes\",           (char*) &delayed_insert_writes,  SHOW_LONG},\n  {\"Flush_commands\",           (char*) &refresh_version,        SHOW_LONG_NOFLUSH},\n  {\"Handler_commit\",           (char*) offsetof(STATUS_VAR, ha_commit_count), SHOW_LONG_STATUS},\n  {\"Handler_delete\",           (char*) offsetof(STATUS_VAR, ha_delete_count), SHOW_LONG_STATUS},\n  {\"Handler_discover\",         (char*) offsetof(STATUS_VAR, ha_discover_count), SHOW_LONG_STATUS},\n  {\"Handler_prepare\",          (char*) offsetof(STATUS_VAR, ha_prepare_count),  SHOW_LONG_STATUS},\n  {\"Handler_read_first\",       (char*) offsetof(STATUS_VAR, ha_read_first_count), SHOW_LONG_STATUS},\n  {\"Handler_read_key\",         (char*) offsetof(STATUS_VAR, ha_read_key_count), SHOW_LONG_STATUS},\n  {\"Handler_read_last\",        (char*) offsetof(STATUS_VAR, ha_read_last_count), SHOW_LONG_STATUS},\n  {\"Handler_read_next\",        (char*) offsetof(STATUS_VAR, ha_read_next_count), SHOW_LONG_STATUS},\n  {\"Handler_read_prev\",        (char*) offsetof(STATUS_VAR, ha_read_prev_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd\",         (char*) offsetof(STATUS_VAR, ha_read_rnd_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd_next\",    (char*) offsetof(STATUS_VAR, ha_read_rnd_next_count), SHOW_LONG_STATUS},\n  {\"Handler_rollback\",         (char*) offsetof(STATUS_VAR, ha_rollback_count), SHOW_LONG_STATUS},\n  {\"Handler_savepoint\",        (char*) offsetof(STATUS_VAR, ha_savepoint_count), SHOW_LONG_STATUS},\n  {\"Handler_savepoint_rollback\",(char*) offsetof(STATUS_VAR, ha_savepoint_rollback_count), SHOW_LONG_STATUS},\n  {\"Handler_update\",           (char*) offsetof(STATUS_VAR, ha_update_count), SHOW_LONG_STATUS},\n  {\"Handler_write\",            (char*) offsetof(STATUS_VAR, ha_write_count), SHOW_LONG_STATUS},\n  {\"Key_blocks_not_flushed\",   (char*) offsetof(KEY_CACHE, global_blocks_changed), SHOW_KEY_CACHE_LONG},\n  {\"Key_blocks_unused\",        (char*) offsetof(KEY_CACHE, blocks_unused), SHOW_KEY_CACHE_LONG},\n  {\"Key_blocks_used\",          (char*) offsetof(KEY_CACHE, blocks_used), SHOW_KEY_CACHE_LONG},\n  {\"Key_read_requests\",        (char*) offsetof(KEY_CACHE, global_cache_r_requests), SHOW_KEY_CACHE_LONGLONG},\n  {\"Key_reads\",                (char*) offsetof(KEY_CACHE, global_cache_read), SHOW_KEY_CACHE_LONGLONG},\n  {\"Key_write_requests\",       (char*) offsetof(KEY_CACHE, global_cache_w_requests), SHOW_KEY_CACHE_LONGLONG},\n  {\"Key_writes\",               (char*) offsetof(KEY_CACHE, global_cache_write), SHOW_KEY_CACHE_LONGLONG},\n  {\"Last_query_cost\",          (char*) offsetof(STATUS_VAR, last_query_cost), SHOW_DOUBLE_STATUS},\n  {\"Max_used_connections\",     (char*) &max_used_connections,  SHOW_LONG},\n  {\"Not_flushed_delayed_rows\", (char*) &delayed_rows_in_use,    SHOW_LONG_NOFLUSH},\n  {\"Open_files\",               (char*) &my_file_opened,         SHOW_LONG_NOFLUSH},\n  {\"Open_streams\",             (char*) &my_stream_opened,       SHOW_LONG_NOFLUSH},\n  {\"Open_table_definitions\",   (char*) &show_table_definitions, SHOW_FUNC},\n  {\"Open_tables\",              (char*) &show_open_tables,       SHOW_FUNC},\n  {\"Opened_files\",             (char*) &my_file_total_opened, SHOW_LONG_NOFLUSH},\n  {\"Opened_tables\",            (char*) offsetof(STATUS_VAR, opened_tables), SHOW_LONG_STATUS},\n  {\"Opened_table_definitions\", (char*) offsetof(STATUS_VAR, opened_shares), SHOW_LONG_STATUS},\n  {\"Prepared_stmt_count\",      (char*) &show_prepared_stmt_count, SHOW_FUNC},\n#ifdef HAVE_QUERY_CACHE\n  {\"Qcache_free_blocks\",       (char*) &query_cache.free_memory_blocks, SHOW_LONG_NOFLUSH},\n  {\"Qcache_free_memory\",       (char*) &query_cache.free_memory, SHOW_LONG_NOFLUSH},\n  {\"Qcache_hits\",              (char*) &query_cache.hits,       SHOW_LONG},\n  {\"Qcache_inserts\",           (char*) &query_cache.inserts,    SHOW_LONG},\n  {\"Qcache_lowmem_prunes\",     (char*) &query_cache.lowmem_prunes, SHOW_LONG},\n  {\"Qcache_not_cached\",        (char*) &query_cache.refused,    SHOW_LONG},\n  {\"Qcache_queries_in_cache\",  (char*) &query_cache.queries_in_cache, SHOW_LONG_NOFLUSH},\n  {\"Qcache_total_blocks\",      (char*) &query_cache.total_blocks, SHOW_LONG_NOFLUSH},\n#endif /*HAVE_QUERY_CACHE*/\n  {\"Queries\",                  (char*) &show_queries,            SHOW_FUNC},\n  {\"Questions\",                (char*) offsetof(STATUS_VAR, questions), SHOW_LONG_STATUS},\n#ifdef HAVE_REPLICATION\n  {\"Rpl_status\",               (char*) &show_rpl_status,          SHOW_FUNC},\n#endif\n  {\"Select_full_join\",         (char*) offsetof(STATUS_VAR, select_full_join_count), SHOW_LONG_STATUS},\n  {\"Select_full_range_join\",   (char*) offsetof(STATUS_VAR, select_full_range_join_count), SHOW_LONG_STATUS},\n  {\"Select_range\",             (char*) offsetof(STATUS_VAR, select_range_count), SHOW_LONG_STATUS},\n  {\"Select_range_check\",       (char*) offsetof(STATUS_VAR, select_range_check_count), SHOW_LONG_STATUS},\n  {\"Select_scan\",\t       (char*) offsetof(STATUS_VAR, select_scan_count), SHOW_LONG_STATUS},\n  {\"Slave_open_temp_tables\",   (char*) &slave_open_temp_tables, SHOW_LONG},\n#ifdef HAVE_REPLICATION\n  {\"Slave_retried_transactions\",(char*) &show_slave_retried_trans, SHOW_FUNC},\n  {\"Slave_heartbeat_period\",   (char*) &show_heartbeat_period, SHOW_FUNC},\n  {\"Slave_received_heartbeats\",(char*) &show_slave_received_heartbeats, SHOW_FUNC},\n  {\"Slave_running\",            (char*) &show_slave_running,     SHOW_FUNC},\n#endif\n  {\"Slow_launch_threads\",      (char*) &slow_launch_threads,    SHOW_LONG},\n  {\"Slow_queries\",             (char*) offsetof(STATUS_VAR, long_query_count), SHOW_LONG_STATUS},\n  {\"Sort_merge_passes\",\t       (char*) offsetof(STATUS_VAR, filesort_merge_passes), SHOW_LONG_STATUS},\n  {\"Sort_range\",\t       (char*) offsetof(STATUS_VAR, filesort_range_count), SHOW_LONG_STATUS},\n  {\"Sort_rows\",\t\t       (char*) offsetof(STATUS_VAR, filesort_rows), SHOW_LONG_STATUS},\n  {\"Sort_scan\",\t\t       (char*) offsetof(STATUS_VAR, filesort_scan_count), SHOW_LONG_STATUS},\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  {\"Ssl_accept_renegotiates\",  (char*) &show_ssl_ctx_sess_accept_renegotiate, SHOW_FUNC},\n  {\"Ssl_accepts\",              (char*) &show_ssl_ctx_sess_accept, SHOW_FUNC},\n  {\"Ssl_callback_cache_hits\",  (char*) &show_ssl_ctx_sess_cb_hits, SHOW_FUNC},\n  {\"Ssl_cipher\",               (char*) &show_ssl_get_cipher, SHOW_FUNC},\n  {\"Ssl_cipher_list\",          (char*) &show_ssl_get_cipher_list, SHOW_FUNC},\n  {\"Ssl_client_connects\",      (char*) &show_ssl_ctx_sess_connect, SHOW_FUNC},\n  {\"Ssl_connect_renegotiates\", (char*) &show_ssl_ctx_sess_connect_renegotiate, SHOW_FUNC},\n  {\"Ssl_ctx_verify_depth\",     (char*) &show_ssl_ctx_get_verify_depth, SHOW_FUNC},\n  {\"Ssl_ctx_verify_mode\",      (char*) &show_ssl_ctx_get_verify_mode, SHOW_FUNC},\n  {\"Ssl_default_timeout\",      (char*) &show_ssl_get_default_timeout, SHOW_FUNC},\n  {\"Ssl_finished_accepts\",     (char*) &show_ssl_ctx_sess_accept_good, SHOW_FUNC},\n  {\"Ssl_finished_connects\",    (char*) &show_ssl_ctx_sess_connect_good, SHOW_FUNC},\n  {\"Ssl_session_cache_hits\",   (char*) &show_ssl_ctx_sess_hits, SHOW_FUNC},\n  {\"Ssl_session_cache_misses\", (char*) &show_ssl_ctx_sess_misses, SHOW_FUNC},\n  {\"Ssl_session_cache_mode\",   (char*) &show_ssl_ctx_get_session_cache_mode, SHOW_FUNC},\n  {\"Ssl_session_cache_overflows\", (char*) &show_ssl_ctx_sess_cache_full, SHOW_FUNC},\n  {\"Ssl_session_cache_size\",   (char*) &show_ssl_ctx_sess_get_cache_size, SHOW_FUNC},\n  {\"Ssl_session_cache_timeouts\", (char*) &show_ssl_ctx_sess_timeouts, SHOW_FUNC},\n  {\"Ssl_sessions_reused\",      (char*) &show_ssl_session_reused, SHOW_FUNC},\n  {\"Ssl_used_session_cache_entries\",(char*) &show_ssl_ctx_sess_number, SHOW_FUNC},\n  {\"Ssl_verify_depth\",         (char*) &show_ssl_get_verify_depth, SHOW_FUNC},\n  {\"Ssl_verify_mode\",          (char*) &show_ssl_get_verify_mode, SHOW_FUNC},\n  {\"Ssl_version\",              (char*) &show_ssl_get_version, SHOW_FUNC},\n#endif\n#endif /* HAVE_OPENSSL */\n  {\"Table_locks_immediate\",    (char*) &locks_immediate,        SHOW_LONG},\n  {\"Table_locks_waited\",       (char*) &locks_waited,           SHOW_LONG},\n#ifdef HAVE_MMAP\n  {\"Tc_log_max_pages_used\",    (char*) &tc_log_max_pages_used,  SHOW_LONG},\n  {\"Tc_log_page_size\",         (char*) &tc_log_page_size,       SHOW_LONG},\n  {\"Tc_log_page_waits\",        (char*) &tc_log_page_waits,      SHOW_LONG},\n#endif\n  {\"Threads_cached\",           (char*) &cached_thread_count,    SHOW_LONG_NOFLUSH},\n  {\"Threads_connected\",        (char*) &connection_count,       SHOW_INT},\n  {\"Threads_created\",\t       (char*) &thread_created,\t\tSHOW_LONG_NOFLUSH},\n  {\"Threads_running\",          (char*) &thread_running,         SHOW_INT},\n  {\"Uptime\",                   (char*) &show_starttime,         SHOW_FUNC},\n#ifdef ENABLED_PROFILING\n  {\"Uptime_since_flush_status\",(char*) &show_flushstatustime,   SHOW_FUNC},\n#endif\n  {NullS, NullS, SHOW_LONG}\n};\n\nbool add_terminator(DYNAMIC_ARRAY *options)\n{\n  my_option empty_element= {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0};\n  return insert_dynamic(options, (uchar *)&empty_element);\n}\n\n#ifndef EMBEDDED_LIBRARY\nstatic void print_version(void)\n{\n  set_server_version();\n\n  printf(\"%s  Ver %s for %s on %s (%s)\\n\",my_progname,\n\t server_version,SYSTEM_TYPE,MACHINE_TYPE, MYSQL_COMPILATION_COMMENT);\n}\n\n/** Compares two options' names, treats - and _ the same */\nstatic int option_cmp(my_option *a, my_option *b)\n{\n  const char *sa= a->name;\n  const char *sb= b->name;\n  for (; *sa || *sb; sa++, sb++)\n  {\n    if (*sa < *sb)\n    {\n      if (*sa == '-' && *sb == '_')\n        continue;\n      else\n        return -1;\n    }\n    if (*sa > *sb)\n    {\n      if (*sa == '_' && *sb == '-')\n        continue;\n      else\n        return 1;\n    }\n  }\n  DBUG_ASSERT(a->name == b->name);\n  return 0;\n}\n\nstatic void print_help()\n{\n  MEM_ROOT mem_root;\n  init_alloc_root(&mem_root, 4096, 4096);\n\n  pop_dynamic(&all_options);\n  sys_var_add_options(&all_options, sys_var::PARSE_EARLY);\n  add_plugin_options(&all_options, &mem_root);\n  sort_dynamic(&all_options, (qsort_cmp) option_cmp);\n  add_terminator(&all_options);\n\n  my_print_help((my_option*) all_options.buffer);\n  my_print_variables((my_option*) all_options.buffer);\n\n  free_root(&mem_root, MYF(0));\n  delete_dynamic(&all_options);\n}\n\nstatic void usage(void)\n{\n  DBUG_ENTER(\"usage\");\n  if (!(default_charset_info= get_charset_by_csname(default_character_set_name,\n\t\t\t\t\t           MY_CS_PRIMARY,\n\t\t\t\t\t\t   MYF(MY_WME))))\n    exit(1);\n  if (!default_collation_name)\n    default_collation_name= (char*) default_charset_info->name;\n  print_version();\n  puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n  puts(\"Starts the MySQL database server.\\n\");\n  printf(\"Usage: %s [OPTIONS]\\n\", my_progname);\n  if (!opt_verbose)\n    puts(\"\\nFor more help options (several pages), use mysqld --verbose --help.\");\n  else\n  {\n#ifdef __WIN__\n  puts(\"NT and Win32 specific options:\\n\\\n  --install                     Install the default service (NT).\\n\\\n  --install-manual              Install the default service started manually (NT).\\n\\\n  --install service_name        Install an optional service (NT).\\n\\\n  --install-manual service_name Install an optional service started manually (NT).\\n\\\n  --remove                      Remove the default service from the service list (NT).\\n\\\n  --remove service_name         Remove the service_name from the service list (NT).\\n\\\n  --enable-named-pipe           Only to be used for the default server (NT).\\n\\\n  --standalone                  Dummy option to start as a standalone server (NT).\\\n\");\n  puts(\"\");\n#endif\n  print_defaults(MYSQL_CONFIG_NAME,load_default_groups);\n  puts(\"\");\n  set_ports();\n\n  /* Print out all the options including plugin supplied options */\n  print_help();\n\n  if (! plugins_are_initialized)\n  {\n    puts(\"\\n\\\nPlugins have parameters that are not reflected in this list\\n\\\nbecause execution stopped before plugins were initialized.\");\n  }\n\n  puts(\"\\n\\\nTo see what values a running MySQL server is using, type\\n\\\n'mysqladmin variables' instead of 'mysqld --verbose --help'.\");\n  }\n  DBUG_VOID_RETURN;\n}\n#endif /*!EMBEDDED_LIBRARY*/\n\n/**\n  Initialize MySQL global variables to default values.\n\n  @note\n    The reason to set a lot of global variables to zero is to allow one to\n    restart the embedded server with a clean environment\n    It's also needed on some exotic platforms where global variables are\n    not set to 0 when a program starts.\n\n    We don't need to set variables refered to in my_long_options\n    as these are initialized by my_getopt.\n*/\n\nstatic int mysql_init_variables(void)\n{\n  /* Things reset to zero */\n  opt_skip_slave_start= opt_reckless_slave = 0;\n  mysql_home[0]= pidfile_name[0]= log_error_file[0]= 0;\n  myisam_test_invalid_symlink= test_if_data_home_dir;\n  opt_log= opt_slow_log= 0;\n  opt_bin_log= 0;\n  opt_disable_networking= opt_skip_show_db=0;\n  opt_skip_name_resolve= 0;\n  opt_ignore_builtin_innodb= 0;\n  opt_logname= opt_update_logname= opt_binlog_index_name= opt_slow_logname= 0;\n  opt_tc_log_file= (char *)\"tc.log\";      // no hostname in tc_log file name !\n  opt_secure_auth= 0;\n  opt_bootstrap= opt_myisam_log= 0;\n  mqh_used= 0;\n  kill_in_progress= 0;\n  cleanup_done= 0;\n  server_id_supplied= 0;\n  test_flags= select_errors= dropping_tables= ha_open_options=0;\n  thread_count= thread_running= kill_cached_threads= wake_thread=0;\n  slave_open_temp_tables= 0;\n  cached_thread_count= 0;\n  opt_endinfo= using_udf_functions= 0;\n  opt_using_transactions= 0;\n  abort_loop= select_thread_in_use= signal_thread_in_use= 0;\n  ready_to_exit= shutdown_in_progress= grant_option= 0;\n  aborted_threads= aborted_connects= 0;\n  delayed_insert_threads= delayed_insert_writes= delayed_rows_in_use= 0;\n  delayed_insert_errors= thread_created= 0;\n  specialflag= 0;\n  binlog_cache_use=  binlog_cache_disk_use= 0;\n  max_used_connections= slow_launch_threads = 0;\n  mysqld_user= mysqld_chroot= opt_init_file= opt_bin_logname = 0;\n  prepared_stmt_count= 0;\n  mysqld_unix_port= opt_mysql_tmpdir= my_bind_addr_str= NullS;\n  bzero((uchar*) &mysql_tmpdir_list, sizeof(mysql_tmpdir_list));\n  bzero((char *) &global_status_var, sizeof(global_status_var));\n  opt_large_pages= 0;\n  opt_super_large_pages= 0;\n#if defined(ENABLED_DEBUG_SYNC)\n  opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  key_map_full.set_all();\n\n  /* Character sets */\n  system_charset_info= &my_charset_utf8_general_ci;\n  files_charset_info= &my_charset_utf8_general_ci;\n  national_charset_info= &my_charset_utf8_general_ci;\n  table_alias_charset= &my_charset_bin;\n  character_set_filesystem= &my_charset_bin;\n\n  opt_specialflag= SPECIAL_ENGLISH;\n  unix_sock= ip_sock= INVALID_SOCKET;\n  mysql_home_ptr= mysql_home;\n  pidfile_name_ptr= pidfile_name;\n  log_error_file_ptr= log_error_file;\n  lc_messages_dir_ptr= lc_messages_dir;\n  protocol_version= PROTOCOL_VERSION;\n  what_to_log= ~ (1L << (uint) COM_TIME);\n  refresh_version= 1L;\t/* Increments on each reload */\n  global_query_id= thread_id= 1L;\n  my_atomic_rwlock_init(&global_query_id_lock);\n  my_atomic_rwlock_init(&thread_running_lock);\n  strmov(server_version, MYSQL_SERVER_VERSION);\n  threads.empty();\n  thread_cache.empty();\n  key_caches.empty();\n  if (!(dflt_key_cache= get_or_create_key_cache(default_key_cache_base.str,\n                                                default_key_cache_base.length)))\n  {\n    sql_print_error(\"Cannot allocate the keycache\");\n    return 1;\n  }\n  /* set key_cache_hash.default_value = dflt_key_cache */\n  multi_keycache_init();\n\n  /* Set directory paths */\n  mysql_real_data_home_len=\n    strmake(mysql_real_data_home, get_relative_path(MYSQL_DATADIR),\n            sizeof(mysql_real_data_home)-1) - mysql_real_data_home;\n  /* Replication parameters */\n  master_info_file= (char*) \"master.info\",\n    relay_log_info_file= (char*) \"relay-log.info\";\n  report_user= report_password = report_host= 0;\t/* TO BE DELETED */\n  opt_relay_logname= opt_relaylog_index_name= 0;\n\n  /* Variables in libraries */\n  charsets_dir= 0;\n  default_character_set_name= (char*) MYSQL_DEFAULT_CHARSET_NAME;\n  default_collation_name= compiled_default_collation_name;\n  character_set_filesystem_name= (char*) \"binary\";\n  lc_messages= (char*) \"en_US\";\n  lc_time_names_name= (char*) \"en_US\";\n  \n  /* Variables that depends on compile options */\n#ifndef DBUG_OFF\n  default_dbug_option=IF_WIN(\"d:t:i:O,\\\\mysqld.trace\",\n\t\t\t     \"d:t:i:o,/tmp/mysqld.trace\");\n#endif\n  opt_error_log= IF_WIN(1,0);\n#ifdef ENABLED_PROFILING\n    have_profiling = SHOW_OPTION_YES;\n#else\n    have_profiling = SHOW_OPTION_NO;\n#endif\n\n#ifdef HAVE_OPENSSL\n  have_ssl=SHOW_OPTION_YES;\n#else\n  have_ssl=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_BROKEN_REALPATH\n  have_symlink=SHOW_OPTION_NO;\n#else\n  have_symlink=SHOW_OPTION_YES;\n#endif\n#ifdef HAVE_DLOPEN\n  have_dlopen=SHOW_OPTION_YES;\n#else\n  have_dlopen=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_QUERY_CACHE\n  have_query_cache=SHOW_OPTION_YES;\n#else\n  have_query_cache=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_SPATIAL\n  have_geometry=SHOW_OPTION_YES;\n#else\n  have_geometry=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_RTREE_KEYS\n  have_rtree_keys=SHOW_OPTION_YES;\n#else\n  have_rtree_keys=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_CRYPT\n  have_crypt=SHOW_OPTION_YES;\n#else\n  have_crypt=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_COMPRESS\n  have_compress= SHOW_OPTION_YES;\n#else\n  have_compress= SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_LIBWRAP\n  libwrapName= NullS;\n#endif\n#ifdef HAVE_OPENSSL\n  des_key_file = 0;\n#ifndef EMBEDDED_LIBRARY\n  ssl_acceptor_fd= 0;\n#endif /* ! EMBEDDED_LIBRARY */\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_SMEM\n  shared_memory_base_name= default_shared_memory_base_name;\n#endif\n\n#if defined(__WIN__)\n  /* Allow Win32 users to move MySQL anywhere */\n  {\n    char prg_dev[LIBLEN];\n    char executing_path_name[LIBLEN];\n    if (!test_if_hard_path(my_progname))\n    {\n      // we don't want to use GetModuleFileName inside of my_path since\n      // my_path is a generic path dereferencing function and here we care\n      // only about the executing binary.\n      GetModuleFileName(NULL, executing_path_name, sizeof(executing_path_name));\n      my_path(prg_dev, executing_path_name, NULL);\n    }\n    else\n      my_path(prg_dev, my_progname, \"mysql/bin\");\n    strcat(prg_dev,\"/../\");\t\t\t// Remove 'bin' to get base dir\n    cleanup_dirname(mysql_home,prg_dev);\n  }\n#else\n  const char *tmpenv;\n  if (!(tmpenv = getenv(\"MY_BASEDIR_VERSION\")))\n    tmpenv = DEFAULT_MYSQL_HOME;\n  (void) strmake(mysql_home, tmpenv, sizeof(mysql_home)-1);\n#endif\n  return 0;\n}\n\nmy_bool\nmysqld_get_one_option(int optid,\n                      const struct my_option *opt __attribute__((unused)),\n                      char *argument)\n{\n  switch(optid) {\n  case '#':\n#ifndef DBUG_OFF\n    DBUG_SET_INITIAL(argument ? argument : default_dbug_option);\n#endif\n    opt_endinfo=1;\t\t\t\t/* unireg: memory allocation */\n    break;\n  case 'a':\n    global_system_variables.sql_mode= MODE_ANSI;\n    global_system_variables.tx_isolation= ISO_SERIALIZABLE;\n    break;\n  case 'b':\n    strmake(mysql_home,argument,sizeof(mysql_home)-1);\n    break;\n  case 'C':\n    if (default_collation_name == compiled_default_collation_name)\n      default_collation_name= 0;\n    break;\n  case 'l':\n    WARN_DEPRECATED(NULL, 7, 0, \"--log\", \"'--general-log'/'--general-log-file'\");\n    opt_log=1;\n    break;\n  case 'h':\n    strmake(mysql_real_data_home,argument, sizeof(mysql_real_data_home)-1);\n    /* Correct pointer set by my_getopt (for embedded library) */\n    mysql_real_data_home_ptr= mysql_real_data_home;\n    break;\n  case 'u':\n    if (!mysqld_user || !strcmp(mysqld_user, argument))\n      mysqld_user= argument;\n    else\n      sql_print_warning(\"Ignoring user change to '%s' because the user was set to '%s' earlier on the command line\\n\", argument, mysqld_user);\n    break;\n  case 'L':\n    strmake(lc_messages_dir, argument, sizeof(lc_messages_dir)-1);\n    lc_messages_dir_ptr= lc_messages_dir;\n    break;\n  case OPT_BINLOG_FORMAT:\n    binlog_format_used= true;\n    break;\n#include <sslopt-case.h>\n#ifndef EMBEDDED_LIBRARY\n  case 'V':\n    print_version();\n    exit(0);\n#endif /*EMBEDDED_LIBRARY*/\n  case 'W':\n    if (!argument)\n      global_system_variables.log_warnings++;\n    else if (argument == disabled_my_option)\n      global_system_variables.log_warnings= 0L;\n    else\n      global_system_variables.log_warnings= atoi(argument);\n    break;\n  case 'T':\n    test_flags= argument ? (uint) atoi(argument) : 0;\n    opt_endinfo=1;\n    break;\n  case OPT_THREAD_CONCURRENCY:\n    WARN_DEPRECATED_NO_REPLACEMENT(NULL, \"THREAD_CONCURRENCY\");\n    break;\n  case (int) OPT_ISAM_LOG:\n    opt_myisam_log=1;\n    break;\n  case (int) OPT_BIN_LOG:\n    opt_bin_log= test(argument != disabled_my_option);\n    break;\n#ifdef HAVE_REPLICATION\n  case (int)OPT_REPLICATE_IGNORE_DB:\n  {\n    rpl_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_DB:\n  {\n    rpl_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_REWRITE_DB:\n  {\n    char* key = argument,*p, *val;\n\n    if (!(p= strstr(argument, \"->\")))\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - missing '->'!\\n\");\n      return 1;\n    }\n    val= p--;\n    while (my_isspace(mysqld_charset, *p) && p > argument)\n      *p-- = 0;\n    if (p == argument)\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty FROM db!\\n\");\n      return 1;\n    }\n    *val= 0;\n    val+= 2;\n    while (*val && my_isspace(mysqld_charset, *val))\n      val++;\n    if (!*val)\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty TO db!\\n\");\n      return 1;\n    }\n\n    rpl_filter->add_db_rewrite(key, val);\n    break;\n  }\n\n  case (int)OPT_BINLOG_IGNORE_DB:\n  {\n    binlog_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_BINLOG_DO_DB:\n  {\n    binlog_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_TABLE:\n  {\n    if (rpl_filter->add_do_table(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_DO_TABLE:\n  {\n    if (rpl_filter->add_wild_do_table(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_IGNORE_TABLE:\n  {\n    if (rpl_filter->add_wild_ignore_table(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_IGNORE_TABLE:\n  {\n    if (rpl_filter->add_ignore_table(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\\n\", argument);\n      return 1;\n    }\n    break;\n  }\n#endif /* HAVE_REPLICATION */\n  case (int) OPT_SLOW_QUERY_LOG:\n    WARN_DEPRECATED(NULL, 7, 0, \"--log-slow-queries\", \"'--slow-query-log'/'--slow-query-log-file'\");\n    opt_slow_log= 1;\n    break;\n  case (int) OPT_SKIP_NEW:\n    opt_specialflag|= SPECIAL_NO_NEW_FUNC;\n    delay_key_write_options= DELAY_KEY_WRITE_NONE;\n    myisam_concurrent_insert=0;\n    myisam_recover_options= HA_RECOVER_OFF;\n    sp_automatic_privileges=0;\n    my_use_symdir=0;\n    ha_open_options&= ~(HA_OPEN_ABORT_IF_CRASHED | HA_OPEN_DELAY_KEY_WRITE);\n#ifdef HAVE_QUERY_CACHE\n    query_cache_size=0;\n#endif\n    break;\n  case (int) OPT_SAFE:\n    opt_specialflag|= SPECIAL_SAFE_MODE;\n    delay_key_write_options= DELAY_KEY_WRITE_NONE;\n    myisam_recover_options= HA_RECOVER_DEFAULT;\n    ha_open_options&= ~(HA_OPEN_DELAY_KEY_WRITE);\n    sql_print_warning(\"The syntax '--safe-mode' is deprecated and will be \"\n                      \"removed in a future release.\");\n    break;\n  case (int) OPT_SKIP_PRIOR:\n    opt_specialflag|= SPECIAL_NO_PRIOR;\n    sql_print_warning(\"The --skip-thread-priority startup option is deprecated \"\n                      \"and will be removed in MySQL 7.0. This option has no effect \"\n                      \"as the implied behavior is already the default.\");\n    break;\n  case (int) OPT_SKIP_HOST_CACHE:\n    opt_specialflag|= SPECIAL_NO_HOST_CACHE;\n    break;\n  case (int) OPT_SKIP_RESOLVE:\n    opt_skip_name_resolve= 1;\n    opt_specialflag|=SPECIAL_NO_RESOLVE;\n    break;\n  case (int) OPT_WANT_CORE:\n    test_flags |= TEST_CORE_ON_SIGNAL;\n    break;\n  case (int) OPT_SKIP_STACK_TRACE:\n    test_flags|=TEST_NO_STACKTRACE;\n    break;\n  case OPT_CONSOLE:\n    if (opt_console)\n      opt_error_log= 0;\t\t\t// Force logs to stdout\n    break;\n  case OPT_BOOTSTRAP:\n    opt_noacl=opt_bootstrap=1;\n    break;\n  case OPT_SERVER_ID:\n    server_id_supplied = 1;\n    break;\n  case OPT_ONE_THREAD:\n    thread_handling= SCHEDULER_ONE_THREAD_PER_CONNECTION;\n    break;\n  case OPT_LOWER_CASE_TABLE_NAMES:\n    lower_case_table_names_used= 1;\n    break;\n#if defined(ENABLED_DEBUG_SYNC)\n  case OPT_DEBUG_SYNC_TIMEOUT:\n    /*\n      Debug Sync Facility. See debug_sync.cc.\n      Default timeout for WAIT_FOR action.\n      Default value is zero (facility disabled).\n      If option is given without an argument, supply a non-zero value.\n    */\n    if (!argument)\n    {\n      /* purecov: begin tested */\n      opt_debug_sync_timeout= DEBUG_SYNC_DEFAULT_WAIT_TIMEOUT;\n      /* purecov: end */\n    }\n    break;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  case OPT_ENGINE_CONDITION_PUSHDOWN:\n    /*\n      The last of --engine-condition-pushdown and --optimizer_switch on\n      command line wins (see get_options().\n    */\n    if (global_system_variables.engine_condition_pushdown)\n      global_system_variables.optimizer_switch|=\n        OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN;\n    else\n      global_system_variables.optimizer_switch&=\n        ~OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN;\n    break;\n  case OPT_LOG_ERROR:\n    /*\n      \"No --log-error\" == \"write errors to stderr\",\n      \"--log-error without argument\" == \"write errors to a file\".\n    */\n    if (argument == NULL) /* no argument */\n      log_error_file_ptr= const_cast<char*>(\"\");\n    break;\n  case OPT_MAX_LONG_DATA_SIZE:\n    max_long_data_size_used= true;\n    WARN_DEPRECATED(NULL, 5, 6, \"--max_long_data_size\", \"'--max_allowed_packet'\");\n    break;\n  }\n  return 0;\n}\n\n\n/** Handle arguments for multiple key caches. */\n\nC_MODE_START\n\nstatic void*\nmysql_getopt_value(const char *keyname, uint key_length,\n\t\t   const struct my_option *option, int *error)\n{\n  if (error)\n    *error= 0;\n  switch (option->id) {\n  case OPT_KEY_BUFFER_SIZE:\n  case OPT_KEY_CACHE_BLOCK_SIZE:\n  case OPT_KEY_CACHE_DIVISION_LIMIT:\n  case OPT_KEY_CACHE_AGE_THRESHOLD:\n  {\n    KEY_CACHE *key_cache;\n    if (!(key_cache= get_or_create_key_cache(keyname, key_length)))\n    {\n      if (error)\n        *error= EXIT_OUT_OF_MEMORY;\n      return 0;\n    }\n    switch (option->id) {\n    case OPT_KEY_BUFFER_SIZE:\n      return &key_cache->param_buff_size;\n    case OPT_KEY_CACHE_BLOCK_SIZE:\n      return &key_cache->param_block_size;\n    case OPT_KEY_CACHE_DIVISION_LIMIT:\n      return &key_cache->param_division_limit;\n    case OPT_KEY_CACHE_AGE_THRESHOLD:\n      return &key_cache->param_age_threshold;\n    }\n  }\n  }\n  return option->value;\n}\n\nstatic void option_error_reporter(enum loglevel level, const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n\n  /* Don't print warnings for --loose options during bootstrap */\n  if (level == ERROR_LEVEL || !opt_bootstrap ||\n      global_system_variables.log_warnings)\n  {\n    vprint_msg_to_log(level, format, args);\n  }\n  va_end(args);\n}\n\nC_MODE_END\n\n/**\n  Get server options from the command line,\n  and perform related server initializations.\n  @param [in, out] argc_ptr       command line options (count)\n  @param [in, out] argv_ptr       command line options (values)\n  @return 0 on success\n\n  @todo\n  - FIXME add EXIT_TOO_MANY_ARGUMENTS to \"mysys_err.h\" and return that code?\n*/\nstatic int get_options(int *argc_ptr, char ***argv_ptr)\n{\n  int ho_error;\n\n  my_getopt_register_get_addr(mysql_getopt_value);\n  my_getopt_error_reporter= option_error_reporter;\n\n  /* prepare all_options array */\n  my_init_dynamic_array(&all_options, sizeof(my_option),\n                        array_elements(my_long_options),\n                        array_elements(my_long_options)/4);\n  for (my_option *opt= my_long_options;\n       opt < my_long_options + array_elements(my_long_options) - 1;\n       opt++)\n    insert_dynamic(&all_options, (uchar*) opt);\n  sys_var_add_options(&all_options, sys_var::PARSE_NORMAL);\n  add_terminator(&all_options);\n\n  /* Skip unknown options so that they may be processed later by plugins */\n  my_getopt_skip_unknown= TRUE;\n\n  if ((ho_error= handle_options(argc_ptr, argv_ptr, (my_option*)(all_options.buffer),\n                                mysqld_get_one_option)))\n    return ho_error;\n\n  if (!opt_help)\n    delete_dynamic(&all_options);\n\n  /* Add back the program name handle_options removes */\n  (*argc_ptr)++;\n  (*argv_ptr)--;\n\n  /*\n    Options have been parsed. Now some of them need additional special\n    handling, like custom value checking, checking of incompatibilites\n    between options, setting of multiple variables, etc.\n    Do them here.\n  */\n\n  if ((opt_log_slow_admin_statements || opt_log_queries_not_using_indexes ||\n       opt_log_slow_slave_statements) &&\n      !opt_slow_log)\n    sql_print_warning(\"options --log-slow-admin-statements, --log-queries-not-using-indexes and --log-slow-slave-statements have no effect if --log_slow_queries is not set\");\n  if (global_system_variables.net_buffer_length > \n      global_system_variables.max_allowed_packet)\n  {\n    sql_print_warning(\"net_buffer_length (%lu) is set to be larger \"\n                      \"than max_allowed_packet (%lu). Please rectify.\",\n                      global_system_variables.net_buffer_length, \n                      global_system_variables.max_allowed_packet);\n  }\n\n  if (log_error_file_ptr != disabled_my_option)\n    opt_error_log= 1;\n  else\n    log_error_file_ptr= const_cast<char*>(\"\");\n\n  opt_init_connect.length=strlen(opt_init_connect.str);\n  opt_init_slave.length=strlen(opt_init_slave.str);\n\n  if (global_system_variables.low_priority_updates)\n    thr_upgraded_concurrent_insert_lock= TL_WRITE_LOW_PRIORITY;\n\n  if (ft_boolean_check_syntax_string((uchar*) ft_boolean_syntax))\n  {\n    sql_print_error(\"Invalid ft-boolean-syntax string: %s\\n\",\n                    ft_boolean_syntax);\n    return 1;\n  }\n\n  if (opt_disable_networking)\n    mysqld_port= 0;\n\n  if (opt_skip_show_db)\n    opt_specialflag|= SPECIAL_SKIP_SHOW_DB;\n\n  if (myisam_flush)\n    flush_time= 0;\n\n#ifdef HAVE_REPLICATION\n  if (opt_slave_skip_errors)\n    init_slave_skip_errors(opt_slave_skip_errors);\n#endif\n\n  if (global_system_variables.max_join_size == HA_POS_ERROR)\n    global_system_variables.option_bits|= OPTION_BIG_SELECTS;\n  else\n    global_system_variables.option_bits&= ~OPTION_BIG_SELECTS;\n\n  // Synchronize @@global.autocommit on --autocommit\n  const ulonglong turn_bit_on= opt_autocommit ?\n    OPTION_AUTOCOMMIT : OPTION_NOT_AUTOCOMMIT;\n  global_system_variables.option_bits=\n    (global_system_variables.option_bits &\n     ~(OPTION_NOT_AUTOCOMMIT | OPTION_AUTOCOMMIT)) | turn_bit_on;\n\n  global_system_variables.sql_mode=\n    expand_sql_mode(global_system_variables.sql_mode);\n#if defined(HAVE_BROKEN_REALPATH)\n  my_use_symdir=0;\n  my_disable_symlinks=1;\n  have_symlink=SHOW_OPTION_NO;\n#else\n  if (!my_use_symdir)\n  {\n    my_disable_symlinks=1;\n    have_symlink=SHOW_OPTION_DISABLED;\n  }\n#endif\n  if (opt_debugging)\n  {\n    /* Allow break with SIGINT, no core or stack trace */\n    test_flags|= TEST_SIGINT | TEST_NO_STACKTRACE;\n    test_flags&= ~TEST_CORE_ON_SIGNAL;\n  }\n  /* Set global MyISAM variables from delay_key_write_options */\n  fix_delay_key_write(0, 0, OPT_GLOBAL);\n\n#ifndef EMBEDDED_LIBRARY\n  if (mysqld_chroot)\n    set_root(mysqld_chroot);\n#else\n  thread_handling = SCHEDULER_NO_THREADS;\n  max_allowed_packet= global_system_variables.max_allowed_packet;\n  net_buffer_length= global_system_variables.net_buffer_length;\n#endif\n  if (fix_paths())\n    return 1;\n\n  /*\n    Set some global variables from the global_system_variables\n    In most cases the global variables will not be used\n  */\n  my_disable_locking= myisam_single_user= test(opt_external_locking == 0);\n  my_default_record_cache_size=global_system_variables.read_buff_size;\n\n  global_system_variables.long_query_time= (ulonglong)\n    (global_system_variables.long_query_time_double * 1e6);\n\n  if (opt_short_log_format)\n    opt_specialflag|= SPECIAL_SHORT_LOG_FORMAT;\n\n  if (init_global_datetime_format(MYSQL_TIMESTAMP_DATE,\n                                  &global_date_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_TIME,\n                                  &global_time_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_DATETIME,\n                                  &global_datetime_format))\n    return 1;\n\n#ifdef EMBEDDED_LIBRARY\n  one_thread_scheduler();\n#else\n  if (thread_handling <= SCHEDULER_ONE_THREAD_PER_CONNECTION)\n    one_thread_per_connection_scheduler();\n  else                  /* thread_handling == SCHEDULER_NO_THREADS) */\n    one_thread_scheduler();\n#endif\n\n  global_system_variables.engine_condition_pushdown=\n    test(global_system_variables.optimizer_switch &\n         OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN);\n\n  opt_readonly= read_only;\n\n  /*\n    If max_long_data_size is not specified explicitly use\n    value of max_allowed_packet.\n  */\n  if (!max_long_data_size_used)\n    max_long_data_size= global_system_variables.max_allowed_packet;\n\n  return 0;\n}\n\n\n/*\n  Create version name for running mysqld version\n  We automaticly add suffixes -debug, -embedded and -log to the version\n  name to make the version more descriptive.\n  (MYSQL_SERVER_SUFFIX is set by the compilation environment)\n*/\n\nstatic void set_server_version(void)\n{\n  char *end= strxmov(server_version, MYSQL_SERVER_VERSION,\n                     MYSQL_SERVER_SUFFIX_STR, NullS);\n#ifdef EMBEDDED_LIBRARY\n  end= strmov(end, \"-embedded\");\n#endif\n#ifndef DBUG_OFF\n  if (!strstr(MYSQL_SERVER_SUFFIX_STR, \"-debug\"))\n    end= strmov(end, \"-debug\");\n#endif\n  if (opt_log || opt_slow_log || opt_bin_log)\n    strmov(end, \"-log\");                        // This may slow down system\n}\n\n\nstatic char *get_relative_path(const char *path)\n{\n  if (test_if_hard_path(path) &&\n      is_prefix(path,DEFAULT_MYSQL_HOME) &&\n      strcmp(DEFAULT_MYSQL_HOME,FN_ROOTDIR))\n  {\n    path+=(uint) strlen(DEFAULT_MYSQL_HOME);\n    while (*path == FN_LIBCHAR || *path == FN_LIBCHAR2)\n      path++;\n  }\n  return (char*) path;\n}\n\n\n/**\n  Fix filename and replace extension where 'dir' is relative to\n  mysql_real_data_home.\n  @return\n    1 if len(path) > FN_REFLEN\n*/\n\nbool\nfn_format_relative_to_data_home(char * to, const char *name,\n\t\t\t\tconst char *dir, const char *extension)\n{\n  char tmp_path[FN_REFLEN];\n  if (!test_if_hard_path(dir))\n  {\n    strxnmov(tmp_path,sizeof(tmp_path)-1, mysql_real_data_home,\n\t     dir, NullS);\n    dir=tmp_path;\n  }\n  return !fn_format(to, name, dir, extension,\n\t\t    MY_APPEND_EXT | MY_UNPACK_FILENAME | MY_SAFE_PATH);\n}\n\n\n/**\n  Test a file path to determine if the path is compatible with the secure file\n  path restriction.\n \n  @param path null terminated character string\n\n  @return\n    @retval TRUE The path is secure\n    @retval FALSE The path isn't secure\n*/\n\nbool is_secure_file_path(char *path)\n{\n  char buff1[FN_REFLEN], buff2[FN_REFLEN];\n  size_t opt_secure_file_priv_len;\n  /*\n    All paths are secure if opt_secure_file_priv is 0\n  */\n  if (!opt_secure_file_priv[0])\n    return TRUE;\n\n  opt_secure_file_priv_len= strlen(opt_secure_file_priv);\n\n  if (strlen(path) >= FN_REFLEN)\n    return FALSE;\n\n  if (!my_strcasecmp(system_charset_info, opt_secure_file_priv, \"NULL\"))\n    return FALSE;\n\n  if (my_realpath(buff1, path, 0))\n  {\n    /*\n      The supplied file path might have been a file and not a directory.\n    */\n    int length= (int)dirname_length(path);\n    if (length >= FN_REFLEN)\n      return FALSE;\n    memcpy(buff2, path, length);\n    buff2[length]= '\\0';\n    if (length == 0 || my_realpath(buff1, buff2, 0))\n      return FALSE;\n  }\n  convert_dirname(buff2, buff1, NullS);\n  if (!lower_case_file_system)\n  {\n    if (strncmp(opt_secure_file_priv, buff2, opt_secure_file_priv_len))\n      return FALSE;\n  }\n  else\n  {\n    if (files_charset_info->coll->strnncoll(files_charset_info,\n                                            (uchar *) buff2, strlen(buff2),\n                                            (uchar *) opt_secure_file_priv,\n                                            opt_secure_file_priv_len,\n                                            TRUE))\n      return FALSE;\n  }\n  return TRUE;\n}\n\n\n/**\n  check_secure_file_priv_path : Checks path specified through\n  --secure-file-priv and raises warning in following cases:\n  1. If path is empty string or NULL and mysqld is not running\n     with --bootstrap mode.\n  2. If path can access data directory\n  3. If path points to a directory which is accessible by\n     all OS users (non-Windows build only)\n\n  It throws error in following cases:\n\n  1. If path normalization fails\n  2. If it can not get stats of the directory\n\n  @params NONE\n\n  Assumptions :\n  1. Data directory path has been normalized\n  2. opt_secure_file_priv has been normalized unless it is set\n     to \"NULL\".\n\n  @returns Status of validation\n    @retval true : Validation is successful with/without warnings\n    @retval false : Validation failed. Error is raised.\n*/\n\nbool check_secure_file_priv_path()\n{\n  char datadir_buffer[FN_REFLEN+1]={0};\n  char plugindir_buffer[FN_REFLEN+1]={0};\n  char whichdir[20]= {0};\n  size_t opt_plugindir_len= 0;\n  size_t opt_datadir_len= 0;\n  size_t opt_secure_file_priv_len= 0;\n  bool warn= false;\n  bool case_insensitive_fs;\n#ifndef _WIN32\n  MY_STAT dir_stat;\n#endif\n\n  if (!opt_secure_file_priv[0])\n  {\n    if (opt_bootstrap)\n    {\n      /*\n        Do not impose --secure-file-priv restriction\n        in --bootstrap mode\n      */\n      sql_print_information(\"Ignoring --secure-file-priv value as server is \"\n                            \"running with --bootstrap.\");\n    }\n    else\n    {\n      sql_print_warning(\"Insecure configuration for --secure-file-priv: \"\n                        \"Current value does not restrict location of generated \"\n                        \"files. Consider setting it to a valid, \"\n                        \"non-empty path.\");\n    }\n    return true;\n  }\n\n  /*\n    Setting --secure-file-priv to NULL would disable\n    reading/writing from/to file\n  */\n  if(!my_strcasecmp(system_charset_info, opt_secure_file_priv, \"NULL\"))\n  {\n    sql_print_information(\"--secure-file-priv is set to NULL. \"\n                          \"Operations related to importing and exporting \"\n                          \"data are disabled\");\n    return true;\n  }\n\n  /*\n    Check if --secure-file-priv can access data directory\n  */\n  opt_secure_file_priv_len= strlen(opt_secure_file_priv);\n\n  /*\n    Adds dir seperator at the end.\n    This is required in subsequent comparison\n  */\n  convert_dirname(datadir_buffer, mysql_unpacked_real_data_home, NullS);\n  opt_datadir_len= strlen(datadir_buffer);\n\n  case_insensitive_fs=\n    (test_if_case_insensitive(datadir_buffer) == 1);\n\n  if (!case_insensitive_fs)\n  {\n    if (!strncmp(datadir_buffer, opt_secure_file_priv,\n          opt_datadir_len < opt_secure_file_priv_len ?\n          opt_datadir_len : opt_secure_file_priv_len))\n    {\n      warn= true;\n      strcpy(whichdir, \"Data directory\");\n    }\n  }\n  else\n  {\n    if (!files_charset_info->coll->strnncoll(files_charset_info,\n          (uchar *) datadir_buffer,\n          opt_datadir_len,\n          (uchar *) opt_secure_file_priv,\n          opt_secure_file_priv_len,\n          TRUE))\n    {\n      warn= true;\n      strcpy(whichdir, \"Data directory\");\n    }\n  }\n\n  /*\n    Don't bother comparing --secure-file-priv with --plugin-dir\n    if we already have a match against --datadir or\n    --plugin-dir is not pointing to a valid directory.\n  */\n  if (!warn && !my_realpath(plugindir_buffer, opt_plugin_dir, 0))\n  {\n    convert_dirname(plugindir_buffer, plugindir_buffer, NullS);\n    opt_plugindir_len= strlen(plugindir_buffer);\n\n    if (!case_insensitive_fs)\n    {\n      if (!strncmp(plugindir_buffer, opt_secure_file_priv,\n          opt_plugindir_len < opt_secure_file_priv_len ?\n          opt_plugindir_len : opt_secure_file_priv_len))\n      {\n        warn= true;\n        strcpy(whichdir, \"Plugin directory\");\n      }\n    }\n    else\n    {\n      if (!files_charset_info->coll->strnncoll(files_charset_info,\n          (uchar *) plugindir_buffer,\n          opt_plugindir_len,\n          (uchar *) opt_secure_file_priv,\n          opt_secure_file_priv_len,\n          TRUE))\n      {\n        warn= true;\n        strcpy(whichdir, \"Plugin directory\");\n      }\n    }\n  }\n\n\n  if (warn)\n    sql_print_warning(\"Insecure configuration for --secure-file-priv: \"\n                      \"%s is accessible through \"\n                      \"--secure-file-priv. Consider choosing a different \"\n                      \"directory.\", whichdir);\n\n#ifndef _WIN32\n  /*\n     Check for --secure-file-priv directory's permission\n  */\n  if (!(my_stat(opt_secure_file_priv, &dir_stat, MYF(0))))\n  {\n    sql_print_error(\"Failed to get stat for directory pointed out \"\n                    \"by --secure-file-priv\");\n    return false;\n  }\n\n  if (dir_stat.st_mode & S_IRWXO)\n    sql_print_warning(\"Insecure configuration for --secure-file-priv: \"\n                      \"Location is accessible to all OS users. \"\n                      \"Consider choosing a different directory.\");\n#endif\n  return true;\n}\n\n\nstatic int fix_paths(void)\n{\n  char buff[FN_REFLEN],*pos;\n  bool secure_file_priv_nonempty= false;\n  convert_dirname(mysql_home,mysql_home,NullS);\n  /* Resolve symlinks to allow 'mysql_home' to be a relative symlink */\n  my_realpath(mysql_home,mysql_home,MYF(0));\n  /* Ensure that mysql_home ends in FN_LIBCHAR */\n  pos=strend(mysql_home);\n  if (pos[-1] != FN_LIBCHAR)\n  {\n    pos[0]= FN_LIBCHAR;\n    pos[1]= 0;\n  }\n  convert_dirname(lc_messages_dir, lc_messages_dir, NullS);\n  convert_dirname(mysql_real_data_home,mysql_real_data_home,NullS);\n  (void) my_load_path(mysql_home,mysql_home,\"\"); // Resolve current dir\n  (void) my_load_path(mysql_real_data_home,mysql_real_data_home,mysql_home);\n  (void) my_load_path(pidfile_name, pidfile_name_ptr, mysql_real_data_home);\n\n  convert_dirname(opt_plugin_dir, opt_plugin_dir_ptr ? opt_plugin_dir_ptr : \n                                  get_relative_path(PLUGINDIR), NullS);\n  (void) my_load_path(opt_plugin_dir, opt_plugin_dir, mysql_home);\n  opt_plugin_dir_ptr= opt_plugin_dir;\n\n  my_realpath(mysql_unpacked_real_data_home, mysql_real_data_home, MYF(0));\n  mysql_unpacked_real_data_home_len= \n    (int) strlen(mysql_unpacked_real_data_home);\n  if (mysql_unpacked_real_data_home[mysql_unpacked_real_data_home_len-1] == FN_LIBCHAR)\n    --mysql_unpacked_real_data_home_len;\n\n  char *sharedir=get_relative_path(SHAREDIR);\n  if (test_if_hard_path(sharedir))\n    strmake(buff,sharedir,sizeof(buff)-1);\t\t/* purecov: tested */\n  else\n    strxnmov(buff,sizeof(buff)-1,mysql_home,sharedir,NullS);\n  convert_dirname(buff,buff,NullS);\n  (void) my_load_path(lc_messages_dir, lc_messages_dir, buff);\n\n  /* If --character-sets-dir isn't given, use shared library dir */\n  if (charsets_dir)\n    strmake(mysql_charsets_dir, charsets_dir, sizeof(mysql_charsets_dir)-1);\n  else\n    strxnmov(mysql_charsets_dir, sizeof(mysql_charsets_dir)-1, buff,\n\t     CHARSET_DIR, NullS);\n  (void) my_load_path(mysql_charsets_dir, mysql_charsets_dir, buff);\n  convert_dirname(mysql_charsets_dir, mysql_charsets_dir, NullS);\n  charsets_dir=mysql_charsets_dir;\n\n  if (init_tmpdir(&mysql_tmpdir_list, opt_mysql_tmpdir))\n    return 1;\n  if (!opt_mysql_tmpdir)\n    opt_mysql_tmpdir= mysql_tmpdir;\n#ifdef HAVE_REPLICATION\n  if (!slave_load_tmpdir)\n    slave_load_tmpdir= mysql_tmpdir;\n#endif /* HAVE_REPLICATION */\n  /*\n    Convert the secure-file-priv option to system format, allowing\n    a quick strcmp to check if read or write is in an allowed dir\n   */\n  if (opt_bootstrap)\n    opt_secure_file_priv= EMPTY_STR.str;\n  secure_file_priv_nonempty= opt_secure_file_priv[0] ? true : false;\n\n  if (secure_file_priv_nonempty && strlen(opt_secure_file_priv) > FN_REFLEN)\n  {\n    sql_print_warning(\"Value for --secure-file-priv is longer than maximum \"\n                      \"limit of %d\", FN_REFLEN-1);\n    return 1;\n  }\n\n  memset(buff, 0, sizeof(buff));\n  if (secure_file_priv_nonempty &&\n      my_strcasecmp(system_charset_info, opt_secure_file_priv, \"NULL\"))\n  {\n    int retval= my_realpath(buff, opt_secure_file_priv, MYF(MY_WME));\n    if (!retval)\n    {\n      convert_dirname(secure_file_real_path, buff, NullS);\n#ifdef WIN32\n      MY_DIR *dir= my_dir(secure_file_real_path, MYF(MY_DONT_SORT+MY_WME));\n      if (!dir)\n      {\n        retval= 1;\n      }\n      else\n      {\n        my_dirend(dir);\n      }\n#endif\n    }\n\n    if (retval)\n    {\n      char err_buffer[FN_REFLEN];\n      my_snprintf(err_buffer, FN_REFLEN-1,\n                  \"Failed to access directory for --secure-file-priv.\"\n                  \" Please make sure that directory exists and is \"\n                  \"accessible by MySQL Server. Supplied value : %s\",\n                  opt_secure_file_priv);\n      err_buffer[FN_REFLEN-1]='\\0';\n      sql_print_error(\"%s\", err_buffer);\n      return 1;\n    }\n    opt_secure_file_priv= secure_file_real_path;\n  }\n\n  if (!check_secure_file_priv_path())\n    return 1;\n\n  return 0;\n}\n\n/**\n  Check if file system used for databases is case insensitive.\n\n  @param dir_name\t\t\tDirectory to test\n\n  @retval\n    -1  Don't know (Test failed)\n  @retval\n    0   File system is case sensitive\n  @retval\n    1   File system is case insensitive\n*/\n\nstatic int test_if_case_insensitive(const char *dir_name)\n{\n  int result= 0;\n  File file;\n  char buff[FN_REFLEN], buff2[FN_REFLEN];\n  MY_STAT stat_info;\n  DBUG_ENTER(\"test_if_case_insensitive\");\n\n  fn_format(buff, glob_hostname, dir_name, \".lower-test\",\n\t    MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  fn_format(buff2, glob_hostname, dir_name, \".LOWER-TEST\",\n\t    MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  mysql_file_delete(key_file_casetest, buff2, MYF(0));\n  if ((file= mysql_file_create(key_file_casetest,\n                               buff, 0666, O_RDWR, MYF(0))) < 0)\n  {\n    sql_print_warning(\"Can't create test file %s\", buff);\n    DBUG_RETURN(-1);\n  }\n  mysql_file_close(file, MYF(0));\n  if (mysql_file_stat(key_file_casetest, buff2, &stat_info, MYF(0)))\n    result= 1;\t\t\t\t\t// Can access file\n  mysql_file_delete(key_file_casetest, buff, MYF(MY_WME));\n  DBUG_PRINT(\"exit\", (\"result: %d\", result));\n  DBUG_RETURN(result);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n\n/**\n  Create file to store pid number.\n*/\nstatic void create_pid_file()\n{\n  File file;\n  bool check_parent_path= 1, is_path_accessible= 1;\n  char pid_filepath[FN_REFLEN], *pos= NULL;\n  /* Copy pid file name to get pid file path */\n  strcpy(pid_filepath, pidfile_name);\n\n  /* Iterate through the entire path to check if even one of the sub-dirs\n     is world-writable */\n  while (check_parent_path && (pos= strrchr(pid_filepath, FN_LIBCHAR))\n         && (pos != pid_filepath)) /* shouldn't check root */\n  {\n    *pos= '\\0';  /* Trim the inner-most dir */\n    switch (is_file_or_dir_world_writable(pid_filepath))\n    {\n      case -2:\n        is_path_accessible= 0;\n        break;\n      case -1:\n        sql_perror(\"Can't start server: can't check PID filepath\");\n        exit(1);\n      case 1:\n        sql_print_warning(\"Insecure configuration for --pid-file: Location \"\n                          \"'%s' in the path is accessible to all OS users. \"\n                          \"Consider choosing a different directory.\",\n                          pid_filepath);\n        check_parent_path= 0;\n        break;\n      case 0:\n        continue; /* Keep checking the parent dir */\n    }\n  }\n  if (!is_path_accessible)\n  {\n    sql_print_warning(\"Few location(s) are inaccessible while checking PID filepath.\");\n  }\n  if ((file= mysql_file_create(key_file_pid, pidfile_name, 0664,\n                               O_WRONLY | O_TRUNC, MYF(MY_WME))) >= 0)\n  {\n    char buff[MAX_BIGINT_WIDTH + 1], *end;\n    end= int10_to_str((long) getpid(), buff, 10);\n    *end++= '\\n';\n    if (!mysql_file_write(file, (uchar*) buff, (uint) (end-buff),\n                          MYF(MY_WME | MY_NABP)))\n    {\n      mysql_file_close(file, MYF(0));\n      pid_file_created= true;\n      return;\n    }\n    mysql_file_close(file, MYF(0));\n  }\n  sql_perror(\"Can't start server: can't create PID file\");\n  exit(1);\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n/**\n  Remove the process' pid file.\n  \n  @param  flags  file operation flags\n*/\n\nstatic void delete_pid_file(myf flags)\n{\n#ifndef EMBEDDED_LIBRARY\n  File file;\n  if (opt_bootstrap ||\n      !pid_file_created ||\n      !(file= mysql_file_open(key_file_pid, pidfile_name,\n                              O_RDONLY, flags)))\n    return;\n\n  /* Make sure that the pid file was created by the same process. */    \n  uchar buff[MAX_BIGINT_WIDTH + 1];\n  size_t error= mysql_file_read(file, buff, sizeof(buff), flags);\n  mysql_file_close(file, flags);\n  buff[sizeof(buff) - 1]= '\\0'; \n  if (error != MY_FILE_ERROR &&\n      atol((char *) buff) == (long) getpid())\n  {\n    mysql_file_delete(key_file_pid, pidfile_name, flags);\n    pid_file_created= false;\n  }\n#endif /* EMBEDDED_LIBRARY */\n  return;\n}\n\n\n/** Clear most status variables. */\nvoid refresh_status(THD *thd)\n{\n  mysql_mutex_lock(&LOCK_status);\n\n  /* Add thread's status variabes to global status */\n  add_to_status(&global_status_var, &thd->status_var);\n\n  /* Reset thread's status variables */\n  bzero((uchar*) &thd->status_var, sizeof(thd->status_var));\n\n  /* Reset some global variables */\n  reset_status_vars();\n\n  /* Reset the counters of all key caches (default and named). */\n  process_key_caches(reset_key_cache_counters);\n  flush_status_time= time((time_t*) 0);\n  mysql_mutex_unlock(&LOCK_status);\n\n  /*\n    Set max_used_connections to the number of currently open\n    connections.  Lock LOCK_thread_count out of LOCK_status to avoid\n    deadlocks.  Status reset becomes not atomic, but status data is\n    not exact anyway.\n  */\n  mysql_mutex_lock(&LOCK_thread_count);\n  max_used_connections= thread_count-delayed_insert_threads;\n  mysql_mutex_unlock(&LOCK_thread_count);\n}\n\n\n/*****************************************************************************\n  Instantiate variables for missing storage engines\n  This section should go away soon\n*****************************************************************************/\n\n/*****************************************************************************\n  Instantiate templates\n*****************************************************************************/\n\n#ifdef HAVE_EXPLICIT_TEMPLATE_INSTANTIATION\n/* Used templates */\ntemplate class I_List<THD>;\ntemplate class I_List_iterator<THD>;\ntemplate class I_List<i_string>;\ntemplate class I_List<i_string_pair>;\ntemplate class I_List<Statement>;\ntemplate class I_List_iterator<Statement>;\n#endif\n\n#ifdef HAVE_PSI_INTERFACE\n#ifdef HAVE_MMAP\nPSI_mutex_key key_PAGE_lock, key_LOCK_sync, key_LOCK_active, key_LOCK_pool;\n#endif /* HAVE_MMAP */\n\n#ifdef HAVE_OPENSSL\nPSI_mutex_key key_LOCK_des_key_file;\n#endif /* HAVE_OPENSSL */\n\nPSI_mutex_key key_BINLOG_LOCK_index, key_BINLOG_LOCK_prep_xids,\n  key_delayed_insert_mutex, key_hash_filo_lock, key_LOCK_active_mi,\n  key_LOCK_connection_count, key_LOCK_crypt, key_LOCK_delayed_create,\n  key_LOCK_delayed_insert, key_LOCK_delayed_status, key_LOCK_error_log,\n  key_LOCK_gdl, key_LOCK_global_system_variables,\n  key_LOCK_manager,\n  key_LOCK_prepared_stmt_count,\n  key_LOCK_rpl_status, key_LOCK_server_started, key_LOCK_status,\n  key_LOCK_system_variables_hash, key_LOCK_table_share, key_LOCK_thd_data,\n  key_LOCK_user_conn, key_LOCK_uuid_generator, key_LOG_LOCK_log,\n  key_master_info_data_lock, key_master_info_run_lock,\n  key_master_info_sleep_lock,\n  key_mutex_slave_reporting_capability_err_lock, key_relay_log_info_data_lock,\n  key_relay_log_info_log_space_lock, key_relay_log_info_run_lock,\n  key_relay_log_info_sleep_lock,\n  key_structure_guard_mutex, key_TABLE_SHARE_LOCK_ha_data,\n  key_LOCK_error_messages, key_LOG_INFO_lock, key_LOCK_thread_count,\n  key_PARTITION_LOCK_auto_inc;\nPSI_mutex_key key_LOCK_thd_remove;\nPSI_mutex_key key_RELAYLOG_LOCK_index;\nPSI_mutex_key key_LOCK_thread_created;\n\nstatic PSI_mutex_info all_server_mutexes[]=\n{\n#ifdef HAVE_MMAP\n  { &key_PAGE_lock, \"PAGE::lock\", 0},\n  { &key_LOCK_sync, \"TC_LOG_MMAP::LOCK_sync\", 0},\n  { &key_LOCK_active, \"TC_LOG_MMAP::LOCK_active\", 0},\n  { &key_LOCK_pool, \"TC_LOG_MMAP::LOCK_pool\", 0},\n#endif /* HAVE_MMAP */\n\n#ifdef HAVE_OPENSSL\n  { &key_LOCK_des_key_file, \"LOCK_des_key_file\", PSI_FLAG_GLOBAL},\n#endif /* HAVE_OPENSSL */\n\n  { &key_BINLOG_LOCK_index, \"MYSQL_BIN_LOG::LOCK_index\", 0},\n  { &key_BINLOG_LOCK_prep_xids, \"MYSQL_BIN_LOG::LOCK_prep_xids\", 0},\n  { &key_RELAYLOG_LOCK_index, \"MYSQL_RELAY_LOG::LOCK_index\", 0},\n  { &key_delayed_insert_mutex, \"Delayed_insert::mutex\", 0},\n  { &key_hash_filo_lock, \"hash_filo::lock\", 0},\n  { &key_LOCK_active_mi, \"LOCK_active_mi\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_connection_count, \"LOCK_connection_count\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_crypt, \"LOCK_crypt\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_create, \"LOCK_delayed_create\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_insert, \"LOCK_delayed_insert\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_status, \"LOCK_delayed_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_error_log, \"LOCK_error_log\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_gdl, \"LOCK_gdl\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_system_variables, \"LOCK_global_system_variables\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_manager, \"LOCK_manager\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_prepared_stmt_count, \"LOCK_prepared_stmt_count\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_rpl_status, \"LOCK_rpl_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_server_started, \"LOCK_server_started\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_status, \"LOCK_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_table_share, \"LOCK_table_share\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_thd_data, \"THD::LOCK_thd_data\", 0},\n  { &key_LOCK_user_conn, \"LOCK_user_conn\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_uuid_generator, \"LOCK_uuid_generator\", PSI_FLAG_GLOBAL},\n  { &key_LOG_LOCK_log, \"LOG::LOCK_log\", 0},\n  { &key_master_info_data_lock, \"Master_info::data_lock\", 0},\n  { &key_master_info_run_lock, \"Master_info::run_lock\", 0},\n  { &key_master_info_sleep_lock, \"Master_info::sleep_lock\", 0},\n  { &key_mutex_slave_reporting_capability_err_lock, \"Slave_reporting_capability::err_lock\", 0},\n  { &key_relay_log_info_data_lock, \"Relay_log_info::data_lock\", 0},\n  { &key_relay_log_info_log_space_lock, \"Relay_log_info::log_space_lock\", 0},\n  { &key_relay_log_info_run_lock, \"Relay_log_info::run_lock\", 0},\n  { &key_relay_log_info_sleep_lock, \"Relay_log_info::sleep_lock\", 0},\n  { &key_structure_guard_mutex, \"Query_cache::structure_guard_mutex\", 0},\n  { &key_TABLE_SHARE_LOCK_ha_data, \"TABLE_SHARE::LOCK_ha_data\", 0},\n  { &key_LOCK_error_messages, \"LOCK_error_messages\", PSI_FLAG_GLOBAL},\n  { &key_LOG_INFO_lock, \"LOG_INFO::lock\", 0},\n  { &key_LOCK_thread_count, \"LOCK_thread_count\", PSI_FLAG_GLOBAL},\n  { &key_PARTITION_LOCK_auto_inc, \"HA_DATA_PARTITION::LOCK_auto_inc\", 0},\n  { &key_LOCK_thread_created, \"LOCK_thread_created\", PSI_FLAG_GLOBAL },\n  { &key_LOCK_thd_remove, \"LOCK_thd_remove\", PSI_FLAG_GLOBAL}\n};\n\nPSI_rwlock_key key_rwlock_LOCK_grant, key_rwlock_LOCK_logger,\n  key_rwlock_LOCK_sys_init_connect, key_rwlock_LOCK_sys_init_slave,\n  key_rwlock_LOCK_system_variables_hash, key_rwlock_query_cache_query_lock;\n\nstatic PSI_rwlock_info all_server_rwlocks[]=\n{\n#if defined (HAVE_OPENSSL) && !defined(HAVE_YASSL)\n  { &key_rwlock_openssl, \"CRYPTO_dynlock_value::lock\", 0},\n#endif\n  { &key_rwlock_LOCK_grant, \"LOCK_grant\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_logger, \"LOGGER::LOCK_logger\", 0},\n  { &key_rwlock_LOCK_sys_init_connect, \"LOCK_sys_init_connect\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_sys_init_slave, \"LOCK_sys_init_slave\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_query_cache_query_lock, \"Query_cache_query::lock\", 0}\n};\n\n#ifdef HAVE_MMAP\nPSI_cond_key key_PAGE_cond, key_COND_active, key_COND_pool;\n#endif /* HAVE_MMAP */\n\nPSI_cond_key key_BINLOG_COND_prep_xids, key_BINLOG_update_cond,\n  key_COND_cache_status_changed, key_COND_manager,\n  key_COND_rpl_status, key_COND_server_started,\n  key_delayed_insert_cond, key_delayed_insert_cond_client,\n  key_item_func_sleep_cond, key_master_info_data_cond,\n  key_master_info_start_cond, key_master_info_stop_cond,\n  key_master_info_sleep_cond,\n  key_relay_log_info_data_cond, key_relay_log_info_log_space_cond,\n  key_relay_log_info_start_cond, key_relay_log_info_stop_cond,\n  key_relay_log_info_sleep_cond,\n  key_TABLE_SHARE_cond, key_user_level_lock_cond,\n  key_COND_thread_count, key_COND_thread_cache, key_COND_flush_thread_cache;\nPSI_cond_key key_RELAYLOG_update_cond;\n\nstatic PSI_cond_info all_server_conds[]=\n{\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\n  { &key_COND_handler_count, \"COND_handler_count\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n#ifdef HAVE_MMAP\n  { &key_PAGE_cond, \"PAGE::cond\", 0},\n  { &key_COND_active, \"TC_LOG_MMAP::COND_active\", 0},\n  { &key_COND_pool, \"TC_LOG_MMAP::COND_pool\", 0},\n#endif /* HAVE_MMAP */\n  { &key_BINLOG_COND_prep_xids, \"MYSQL_BIN_LOG::COND_prep_xids\", 0},\n  { &key_BINLOG_update_cond, \"MYSQL_BIN_LOG::update_cond\", 0},\n  { &key_RELAYLOG_update_cond, \"MYSQL_RELAY_LOG::update_cond\", 0},\n  { &key_COND_cache_status_changed, \"Query_cache::COND_cache_status_changed\", 0},\n  { &key_COND_manager, \"COND_manager\", PSI_FLAG_GLOBAL},\n  { &key_COND_rpl_status, \"COND_rpl_status\", PSI_FLAG_GLOBAL},\n  { &key_COND_server_started, \"COND_server_started\", PSI_FLAG_GLOBAL},\n  { &key_delayed_insert_cond, \"Delayed_insert::cond\", 0},\n  { &key_delayed_insert_cond_client, \"Delayed_insert::cond_client\", 0},\n  { &key_item_func_sleep_cond, \"Item_func_sleep::cond\", 0},\n  { &key_master_info_data_cond, \"Master_info::data_cond\", 0},\n  { &key_master_info_start_cond, \"Master_info::start_cond\", 0},\n  { &key_master_info_stop_cond, \"Master_info::stop_cond\", 0},\n  { &key_master_info_sleep_cond, \"Master_info::sleep_cond\", 0},\n  { &key_relay_log_info_data_cond, \"Relay_log_info::data_cond\", 0},\n  { &key_relay_log_info_log_space_cond, \"Relay_log_info::log_space_cond\", 0},\n  { &key_relay_log_info_start_cond, \"Relay_log_info::start_cond\", 0},\n  { &key_relay_log_info_stop_cond, \"Relay_log_info::stop_cond\", 0},\n  { &key_relay_log_info_sleep_cond, \"Relay_log_info::sleep_cond\", 0},\n  { &key_TABLE_SHARE_cond, \"TABLE_SHARE::cond\", 0},\n  { &key_user_level_lock_cond, \"User_level_lock::cond\", 0},\n  { &key_COND_thread_count, \"COND_thread_count\", PSI_FLAG_GLOBAL},\n  { &key_COND_thread_cache, \"COND_thread_cache\", PSI_FLAG_GLOBAL},\n  { &key_COND_flush_thread_cache, \"COND_flush_thread_cache\", PSI_FLAG_GLOBAL}\n};\n\nPSI_thread_key key_thread_bootstrap, key_thread_delayed_insert,\n  key_thread_handle_manager, key_thread_main,\n  key_thread_one_connection, key_thread_signal_hand;\n\nstatic PSI_thread_info all_server_threads[]=\n{\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_namedpipes, \"con_named_pipes\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if defined(HAVE_SMEM) && !defined(EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_sharedmem, \"con_shared_mem\", PSI_FLAG_GLOBAL},\n#endif /* HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#if (defined(_WIN32) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)\n  { &key_thread_handle_con_sockets, \"con_sockets\", PSI_FLAG_GLOBAL},\n#endif /* _WIN32 || HAVE_SMEM && !EMBEDDED_LIBRARY */\n\n#ifdef __WIN__\n  { &key_thread_handle_shutdown, \"shutdown\", PSI_FLAG_GLOBAL},\n#endif /* __WIN__ */\n\n  { &key_thread_bootstrap, \"bootstrap\", PSI_FLAG_GLOBAL},\n  { &key_thread_delayed_insert, \"delayed_insert\", 0},\n  { &key_thread_handle_manager, \"manager\", PSI_FLAG_GLOBAL},\n  { &key_thread_main, \"main\", PSI_FLAG_GLOBAL},\n  { &key_thread_one_connection, \"one_connection\", 0},\n  { &key_thread_signal_hand, \"signal_handler\", PSI_FLAG_GLOBAL}\n};\n\n#ifdef HAVE_MMAP\nPSI_file_key key_file_map;\n#endif /* HAVE_MMAP */\n\nPSI_file_key key_file_binlog, key_file_binlog_index, key_file_casetest,\n  key_file_dbopt, key_file_des_key_file, key_file_ERRMSG, key_select_to_file,\n  key_file_fileparser, key_file_frm, key_file_global_ddl_log, key_file_load,\n  key_file_loadfile, key_file_log_event_data, key_file_log_event_info,\n  key_file_master_info, key_file_misc, key_file_partition,\n  key_file_pid, key_file_relay_log_info, key_file_send_file, key_file_tclog,\n  key_file_trg, key_file_trn, key_file_init;\nPSI_file_key key_file_query_log, key_file_slow_log;\nPSI_file_key key_file_relaylog, key_file_relaylog_index;\n\nstatic PSI_file_info all_server_files[]=\n{\n#ifdef HAVE_MMAP\n  { &key_file_map, \"map\", 0},\n#endif /* HAVE_MMAP */\n  { &key_file_binlog, \"binlog\", 0},\n  { &key_file_binlog_index, \"binlog_index\", 0},\n  { &key_file_relaylog, \"relaylog\", 0},\n  { &key_file_relaylog_index, \"relaylog_index\", 0},\n  { &key_file_casetest, \"casetest\", 0},\n  { &key_file_dbopt, \"dbopt\", 0},\n  { &key_file_des_key_file, \"des_key_file\", 0},\n  { &key_file_ERRMSG, \"ERRMSG\", 0},\n  { &key_select_to_file, \"select_to_file\", 0},\n  { &key_file_fileparser, \"file_parser\", 0},\n  { &key_file_frm, \"FRM\", 0},\n  { &key_file_global_ddl_log, \"global_ddl_log\", 0},\n  { &key_file_load, \"load\", 0},\n  { &key_file_loadfile, \"LOAD_FILE\", 0},\n  { &key_file_log_event_data, \"log_event_data\", 0},\n  { &key_file_log_event_info, \"log_event_info\", 0},\n  { &key_file_master_info, \"master_info\", 0},\n  { &key_file_misc, \"misc\", 0},\n  { &key_file_partition, \"partition\", 0},\n  { &key_file_pid, \"pid\", 0},\n  { &key_file_query_log, \"query_log\", 0},\n  { &key_file_relay_log_info, \"relay_log_info\", 0},\n  { &key_file_send_file, \"send_file\", 0},\n  { &key_file_slow_log, \"slow_log\", 0},\n  { &key_file_tclog, \"tclog\", 0},\n  { &key_file_trg, \"trigger_name\", 0},\n  { &key_file_trn, \"trigger\", 0},\n  { &key_file_init, \"init\", 0}\n};\n\n/**\n  Initialise all the performance schema instrumentation points\n  used by the server.\n*/\nvoid init_server_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_server_mutexes);\n  PSI_server->register_mutex(category, all_server_mutexes, count);\n\n  count= array_elements(all_server_rwlocks);\n  PSI_server->register_rwlock(category, all_server_rwlocks, count);\n\n  count= array_elements(all_server_conds);\n  PSI_server->register_cond(category, all_server_conds, count);\n\n  count= array_elements(all_server_threads);\n  PSI_server->register_thread(category, all_server_threads, count);\n\n  count= array_elements(all_server_files);\n  PSI_server->register_file(category, all_server_files, count);\n}\n\n#endif /* HAVE_PSI_INTERFACE */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql/sys_vars.cc": "/* Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/*\n  How to add new variables:\n\n  1. copy one of the existing variables, and edit the declaration.\n  2. if you need special behavior on assignment or additional checks\n     use ON_CHECK and ON_UPDATE callbacks.\n  3. *Don't* add new Sys_var classes or uncle Occam will come\n     with his razor to haunt you at nights\n\n  Note - all storage engine variables (for example myisam_whatever)\n  should go into the corresponding storage engine sources\n  (for example in storage/myisam/ha_myisam.cc) !\n*/\n\n#include \"my_global.h\"                          /* NO_EMBEDDED_ACCESS_CHECKS */\n#include \"sql_priv.h\"\n#include \"sql_class.h\"                          // set_var.h: THD\n#include \"sys_vars.h\"\n\n#include \"events.h\"\n#include <thr_alarm.h>\n#include \"slave.h\"\n#include \"rpl_mi.h\"\n#include \"transaction.h\"\n#include \"mysqld.h\"\n#include \"lock.h\"\n#include \"sql_time.h\"                       // known_date_time_formats\n#include \"sql_acl.h\" // SUPER_ACL,\n                     // mysql_user_table_is_in_short_password_format\n#include \"derror.h\"  // read_texts\n#include \"sql_base.h\"                           // close_cached_tables\n\n#include \"log_event.h\"\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"../storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\nTYPELIB bool_typelib={ array_elements(bool_values)-1, \"\", bool_values, 0 };\n\n/*\n  This forward declaration is needed because including sql_base.h\n  causes further includes.  [TODO] Eliminate this forward declaration\n  and include a file with the prototype instead.\n*/\nextern void close_thread_tables(THD *thd);\n\n\nstatic bool update_buffer_size(THD *thd, KEY_CACHE *key_cache,\n                               ptrdiff_t offset, ulonglong new_value)\n{\n  bool error= false;\n  DBUG_ASSERT(offset == offsetof(KEY_CACHE, param_buff_size));\n\n  if (new_value == 0)\n  {\n    if (key_cache == dflt_key_cache)\n    {\n      my_error(ER_WARN_CANT_DROP_DEFAULT_KEYCACHE, MYF(0));\n      return true;\n    }\n\n    if (key_cache->key_cache_inited)            // If initied\n    {\n      /*\n        Move tables using this key cache to the default key cache\n        and clear the old key cache.\n      */\n      key_cache->in_init= 1;\n      mysql_mutex_unlock(&LOCK_global_system_variables);\n      key_cache->param_buff_size= 0;\n      ha_resize_key_cache(key_cache);\n      ha_change_key_cache(key_cache, dflt_key_cache);\n      /*\n        We don't delete the key cache as some running threads my still be in\n        the key cache code with a pointer to the deleted (empty) key cache\n      */\n      mysql_mutex_lock(&LOCK_global_system_variables);\n      key_cache->in_init= 0;\n    }\n    return error;\n  }\n\n  key_cache->param_buff_size= new_value;\n\n  /* If key cache didn't exist initialize it, else resize it */\n  key_cache->in_init= 1;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (!key_cache->key_cache_inited)\n    error= ha_init_key_cache(0, key_cache);\n  else\n    error= ha_resize_key_cache(key_cache);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  key_cache->in_init= 0;\n\n  return error;\n}\n\nstatic bool update_keycache_param(THD *thd, KEY_CACHE *key_cache,\n                                  ptrdiff_t offset, ulonglong new_value)\n{\n  bool error= false;\n  DBUG_ASSERT(offset != offsetof(KEY_CACHE, param_buff_size));\n\n  keycache_var(key_cache, offset)= new_value;\n\n  key_cache->in_init= 1;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  error= ha_resize_key_cache(key_cache);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  key_cache->in_init= 0;\n\n  return error;\n}\n\n/*\n  The rule for this file: everything should be 'static'. When a sys_var\n  variable or a function from this file is - in very rare cases - needed\n  elsewhere it should be explicitly declared 'export' here to show that it's\n  not a mistakenly forgotten 'static' keyword.\n*/\n#define export /* not static */\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n\n#define PFS_TRAILING_PROPERTIES \\\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL), \\\n  NULL, sys_var::PARSE_EARLY\n\nstatic Sys_var_mybool Sys_pfs_enabled(\n       \"performance_schema\",\n       \"Enable the performance schema.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_events_waits_history_long_size(\n       \"performance_schema_events_waits_history_long_size\",\n       \"Number of rows in EVENTS_WAITS_HISTORY_LONG.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_waits_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_WAITS_HISTORY_LONG_SIZE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_events_waits_history_size(\n       \"performance_schema_events_waits_history_size\",\n       \"Number of rows per thread in EVENTS_WAITS_HISTORY.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_events_waits_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024),\n       DEFAULT(PFS_WAITS_HISTORY_SIZE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_cond_classes(\n       \"performance_schema_max_cond_classes\",\n       \"Maximum number of condition instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_cond_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_COND_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_cond_instances(\n       \"performance_schema_max_cond_instances\",\n       \"Maximum number of instrumented condition objects.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_cond_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_COND),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_file_classes(\n       \"performance_schema_max_file_classes\",\n       \"Maximum number of file instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_file_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_FILE_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_file_handles(\n       \"performance_schema_max_file_handles\",\n       \"Maximum number of opened instrumented files.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_file_handle_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_FILE_HANDLE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_file_instances(\n       \"performance_schema_max_file_instances\",\n       \"Maximum number of instrumented files.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_file_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_FILE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_mutex_classes(\n       \"performance_schema_max_mutex_classes\",\n       \"Maximum number of mutex instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_MUTEX_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_mutex_instances(\n       \"performance_schema_max_mutex_instances\",\n       \"Maximum number of instrumented MUTEX objects.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 100*1024*1024),\n       DEFAULT(PFS_MAX_MUTEX),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_rwlock_classes(\n       \"performance_schema_max_rwlock_classes\",\n       \"Maximum number of rwlock instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_RWLOCK_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_rwlock_instances(\n       \"performance_schema_max_rwlock_instances\",\n       \"Maximum number of instrumented RWLOCK objects.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 100*1024*1024),\n       DEFAULT(PFS_MAX_RWLOCK),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_table_handles(\n       \"performance_schema_max_table_handles\",\n       \"Maximum number of opened instrumented tables.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_table_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_TABLE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_table_instances(\n       \"performance_schema_max_table_instances\",\n       \"Maximum number of instrumented tables.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_table_share_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_TABLE_SHARE),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_thread_classes(\n       \"performance_schema_max_thread_classes\",\n       \"Maximum number of thread instruments.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_thread_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_THREAD_CLASS),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_thread_instances(\n       \"performance_schema_max_thread_instances\",\n       \"Maximum number of instrumented threads.\",\n       READ_ONLY GLOBAL_VAR(pfs_param.m_thread_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_THREAD),\n       BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\nstatic Sys_var_ulong Sys_auto_increment_increment(\n       \"auto_increment_increment\",\n       \"Auto-increment columns are incremented by this\",\n       SESSION_VAR(auto_increment_increment),\n       CMD_LINE(OPT_ARG),\n       VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_ulong Sys_auto_increment_offset(\n       \"auto_increment_offset\",\n       \"Offset added to Auto-increment columns. Used when \"\n       \"auto-increment-increment != 1\",\n       SESSION_VAR(auto_increment_offset),\n       CMD_LINE(OPT_ARG),\n       VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_mybool Sys_automatic_sp_privileges(\n       \"automatic_sp_privileges\",\n       \"Creating and dropping stored procedures alters ACLs\",\n       GLOBAL_VAR(sp_automatic_privileges),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_back_log(\n       \"back_log\", \"The number of outstanding connection requests \"\n       \"MySQL can have. This comes into play when the main MySQL thread \"\n       \"gets very many connection requests in a very short time\",\n       READ_ONLY GLOBAL_VAR(back_log), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 65535), DEFAULT(50), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_basedir(\n       \"basedir\", \"Path to installation directory. All paths are \"\n       \"usually resolved relative to this\",\n       READ_ONLY GLOBAL_VAR(mysql_home_ptr), CMD_LINE(REQUIRED_ARG, 'b'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulong Sys_binlog_cache_size(\n       \"binlog_cache_size\", \"The size of the transactional cache for \"\n       \"updates to transactional engines for the binary log. \"\n       \"If you often use transactions containing many statements, \"\n       \"you can increase this to get more performance\",\n       GLOBAL_VAR(binlog_cache_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, ULONG_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE));\n\nstatic Sys_var_ulong Sys_binlog_stmt_cache_size(\n       \"binlog_stmt_cache_size\", \"The size of the statement cache for \"\n       \"updates to non-transactional engines for the binary log. \"\n       \"If you often use statements updating a great number of rows, \"\n       \"you can increase this to get more performance\",\n       GLOBAL_VAR(binlog_stmt_cache_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, ULONG_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE));\n\nstatic bool check_has_super(sys_var *self, THD *thd, set_var *var)\n{\n  DBUG_ASSERT(self->scope() != sys_var::GLOBAL);// don't abuse check_has_super()\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (!(thd->security_ctx->master_access & SUPER_ACL))\n  {\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), \"SUPER\");\n    return true;\n  }\n#endif\n  return false;\n}\nstatic bool binlog_format_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n\n  if (var->type == OPT_GLOBAL)\n    return false;\n\n  /*\n     If RBR and open temporary tables, their CREATE TABLE may not be in the\n     binlog, so we can't toggle to SBR in this connection.\n\n     If binlog_format=MIXED, there are open temporary tables, and an unsafe\n     statement is executed, then subsequent statements are logged in row\n     format and hence changes to temporary tables may be lost. So we forbid\n     switching @@SESSION.binlog_format from MIXED to STATEMENT when there are\n     open temp tables and we are logging in row format.\n  */\n  if (thd->temporary_tables && var->type == OPT_SESSION &&\n      var->save_result.ulonglong_value == BINLOG_FORMAT_STMT &&\n      ((thd->variables.binlog_format == BINLOG_FORMAT_MIXED &&\n        thd->is_current_stmt_binlog_format_row()) ||\n       thd->variables.binlog_format == BINLOG_FORMAT_ROW))\n  {\n    my_error(ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR, MYF(0));\n    return true;\n  }\n\n  /*\n    if in a stored function/trigger, it's too late to change mode\n  */\n  if (thd->in_sub_stmt)\n  {\n    my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT, MYF(0));\n    return true;\n  }\n  /*\n    Make the session variable 'binlog_format' read-only inside a transaction.\n  */\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT, MYF(0));\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool fix_binlog_format_after_update(sys_var *self, THD *thd,\n                                           enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->reset_current_stmt_binlog_format_row();\n  return false;\n}\n\nstatic Sys_var_enum Sys_binlog_format(\n       \"binlog_format\", \"What form of binary logging the master will \"\n       \"use: either ROW for row-based binary logging, STATEMENT \"\n       \"for statement-based binary logging, or MIXED. MIXED is statement-\"\n       \"based binary logging except for those statements where only row-\"\n       \"based is correct: those which involve user-defined functions (i.e. \"\n       \"UDFs) or the UUID() function; for those, row-based binary logging is \"\n       \"automatically used. If NDBCLUSTER is enabled and binlog-format is \"\n       \"MIXED, the format switches to row-based and back implicitly per each \"\n       \"query accessing an NDBCLUSTER table\",\n       SESSION_VAR(binlog_format), CMD_LINE(REQUIRED_ARG, OPT_BINLOG_FORMAT),\n       binlog_format_names, DEFAULT(BINLOG_FORMAT_STMT),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(binlog_format_check),\n       ON_UPDATE(fix_binlog_format_after_update));\n\nstatic bool binlog_direct_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n\n  if (var->type == OPT_GLOBAL)\n    return false;\n\n   /*\n     Makes the session variable 'binlog_direct_non_transactional_updates'\n     read-only if within a procedure, trigger or function.\n   */\n   if (thd->in_sub_stmt)\n   {\n     my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT, MYF(0));\n     return true;\n   }\n   /*\n     Makes the session variable 'binlog_direct_non_transactional_updates'\n     read-only inside a transaction.\n   */\n   if (thd->in_active_multi_stmt_transaction())\n   {\n     my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT, MYF(0));\n     return true;\n   }\n\n  return false;\n}\n\nstatic Sys_var_mybool Sys_binlog_direct(\n       \"binlog_direct_non_transactional_updates\",\n       \"Causes updates to non-transactional engines using statement format to \"\n       \"be written directly to binary log. Before using this option make sure \"\n       \"that there are no dependencies between transactional and \"\n       \"non-transactional tables such as in the statement INSERT INTO t_myisam \"\n       \"SELECT * FROM t_innodb; otherwise, slaves may diverge from the master.\",\n       SESSION_VAR(binlog_direct_non_trans_update),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(binlog_direct_check));\n\nstatic Sys_var_ulong Sys_bulk_insert_buff_size(\n       \"bulk_insert_buffer_size\", \"Size of tree cache used in bulk \"\n       \"insert optimisation. Note that this is a limit per thread!\",\n       SESSION_VAR(bulk_insert_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(8192*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_character_sets_dir(\n       \"character_sets_dir\", \"Directory where character sets are\",\n       READ_ONLY GLOBAL_VAR(charsets_dir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool check_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  return var->value && var->value->is_null();\n}\nstatic bool check_charset(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT)\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res=var->value->val_str(&str)))\n      var->save_result.ptr= NULL;\n    else if (!(var->save_result.ptr= get_charset_by_csname(res->c_ptr(),\n                                                           MY_CS_PRIMARY,\n                                                           MYF(0))) &&\n             !(var->save_result.ptr= get_old_charset_by_name(res->c_ptr())))\n    {\n      ErrConvString err(res);\n      my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), err.ptr());\n      return true;\n    }\n  }\n  else // INT_RESULT\n  {\n    int csno= (int)var->value->val_int();\n    if (!(var->save_result.ptr= get_charset(csno, MYF(0))))\n    {\n      my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), llstr(csno, buff));\n      return true;\n    }\n  }\n  return false;\n}\nstatic bool check_charset_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  return check_charset(self, thd, var) || check_not_null(self, thd, var);\n}\nstatic Sys_var_struct Sys_character_set_system(\n       \"character_set_system\", \"The character set used by the server \"\n       \"for storing identifiers\",\n       READ_ONLY GLOBAL_VAR(system_charset_info), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(0));\n\nstatic Sys_var_struct Sys_character_set_server(\n       \"character_set_server\", \"The default character set\",\n       SESSION_VAR(collation_server), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_not_null));\n\nstatic bool check_charset_db(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_charset_not_null(self, thd, var))\n    return true;\n  if (!var->value) // = DEFAULT\n    var->save_result.ptr= thd->db_charset;\n  return false;\n}\nstatic Sys_var_struct Sys_character_set_database(\n       \"character_set_database\",\n       \" The character set used by the default database\",\n       SESSION_VAR(collation_database), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_db));\n\nstatic bool check_cs_client(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_charset_not_null(self, thd, var))\n    return true;\n\n  // Currently, UCS-2 cannot be used as a client character set\n  if (((CHARSET_INFO *)(var->save_result.ptr))->mbminlen > 1)\n    return true;\n\n  return false;\n}\nstatic bool fix_thd_charset(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->update_charset();\n  return false;\n}\nstatic Sys_var_struct Sys_character_set_client(\n       \"character_set_client\", \"The character set for statements \"\n       \"that arrive from the client\",\n       SESSION_VAR(character_set_client), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_cs_client),\n       ON_UPDATE(fix_thd_charset));\n\nstatic Sys_var_struct Sys_character_set_connection(\n       \"character_set_connection\", \"The character set used for \"\n       \"literals that do not have a character set introducer and for \"\n       \"number-to-string conversion\",\n       SESSION_VAR(collation_connection), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic Sys_var_struct Sys_character_set_results(\n       \"character_set_results\", \"The character set used for returning \"\n       \"query results to the client\",\n       SESSION_VAR(character_set_results), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_charset));\n\nstatic Sys_var_struct Sys_character_set_filesystem(\n       \"character_set_filesystem\", \"The filesystem character set\",\n       SESSION_VAR(character_set_filesystem), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&character_set_filesystem),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_charset_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic const char *completion_type_names[]= {\"NO_CHAIN\", \"CHAIN\", \"RELEASE\", 0};\nstatic Sys_var_enum Sys_completion_type(\n       \"completion_type\", \"The transaction completion type, one of \"\n       \"NO_CHAIN, CHAIN, RELEASE\",\n       SESSION_VAR(completion_type), CMD_LINE(REQUIRED_ARG),\n       completion_type_names, DEFAULT(0));\n\nstatic bool check_collation_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT)\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res= var->value->val_str(&str)))\n      var->save_result.ptr= NULL;\n    else if (!(var->save_result.ptr= get_charset_by_name(res->c_ptr(), MYF(0))))\n    {\n      ErrConvString err(res);\n      my_error(ER_UNKNOWN_COLLATION, MYF(0), err.ptr());\n      return true;\n    }\n  }\n  else // INT_RESULT\n  {\n    int csno= (int)var->value->val_int();\n    if (!(var->save_result.ptr= get_charset(csno, MYF(0))))\n    {\n      my_error(ER_UNKNOWN_COLLATION, MYF(0), llstr(csno, buff));\n      return true;\n    }\n  }\n  return check_not_null(self, thd, var);\n}\nstatic Sys_var_struct Sys_collation_connection(\n       \"collation_connection\", \"The collation of the connection \"\n       \"character set\",\n       SESSION_VAR(collation_connection), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic bool check_collation_db(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_collation_not_null(self, thd, var))\n    return true;\n  if (!var->value) // = DEFAULT\n    var->save_result.ptr= thd->db_charset;\n  return false;\n}\nstatic Sys_var_struct Sys_collation_database(\n       \"collation_database\", \"The collation of the database \"\n       \"character set\",\n       SESSION_VAR(collation_database), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_db));\n\nstatic Sys_var_struct Sys_collation_server(\n       \"collation_server\", \"The server default collation\",\n       SESSION_VAR(collation_server), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_not_null));\n\nstatic const char *concurrent_insert_names[]= {\"NEVER\", \"AUTO\", \"ALWAYS\", 0};\nstatic Sys_var_enum Sys_concurrent_insert(\n       \"concurrent_insert\", \"Use concurrent insert with MyISAM. Possible \"\n       \"values are NEVER, AUTO, ALWAYS\",\n       GLOBAL_VAR(myisam_concurrent_insert), CMD_LINE(OPT_ARG),\n       concurrent_insert_names, DEFAULT(1));\n\nstatic Sys_var_ulong Sys_connect_timeout(\n       \"connect_timeout\",\n       \"The number of seconds the mysqld server is waiting for a connect \"\n       \"packet before responding with 'Bad handshake'\",\n       GLOBAL_VAR(connect_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(2, LONG_TIMEOUT), DEFAULT(CONNECT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_datadir(\n       \"datadir\", \"Path to the database root directory\",\n       READ_ONLY GLOBAL_VAR(mysql_real_data_home_ptr),\n       CMD_LINE(REQUIRED_ARG, 'h'), IN_FS_CHARSET, DEFAULT(mysql_real_data_home));\n\n#ifndef DBUG_OFF\nstatic Sys_var_dbug Sys_dbug(\n       \"debug\", \"Debug log\", sys_var::SESSION,\n       CMD_LINE(OPT_ARG, '#'), DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_has_super));\n#endif\n\n/**\n  @todo\n    When updating myisam_delay_key_write, we should do a 'flush tables'\n    of all MyISAM tables to ensure that they are reopen with the\n    new attribute.\n*/\nexport bool fix_delay_key_write(sys_var *self, THD *thd, enum_var_type type)\n{\n  switch (delay_key_write_options) {\n  case DELAY_KEY_WRITE_NONE:\n    myisam_delay_key_write=0;\n    break;\n  case DELAY_KEY_WRITE_ON:\n    myisam_delay_key_write=1;\n    break;\n  case DELAY_KEY_WRITE_ALL:\n    myisam_delay_key_write=1;\n    ha_open_options|= HA_OPEN_DELAY_KEY_WRITE;\n    break;\n  }\n  return false;\n}\nstatic const char *delay_key_write_names[]= { \"OFF\", \"ON\", \"ALL\", NullS };\nstatic Sys_var_enum Sys_delay_key_write(\n       \"delay_key_write\", \"Type of DELAY_KEY_WRITE\",\n       GLOBAL_VAR(delay_key_write_options), CMD_LINE(OPT_ARG),\n       delay_key_write_names, DEFAULT(DELAY_KEY_WRITE_ON),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_delay_key_write));\n\nstatic Sys_var_ulong Sys_delayed_insert_limit(\n       \"delayed_insert_limit\",\n       \"After inserting delayed_insert_limit rows, the INSERT DELAYED \"\n       \"handler will check if there are any SELECT statements pending. \"\n       \"If so, it allows these to execute before continuing\",\n       GLOBAL_VAR(delayed_insert_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(DELAYED_LIMIT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_delayed_insert_timeout(\n       \"delayed_insert_timeout\",\n       \"How long a INSERT DELAYED thread should wait for INSERT statements \"\n       \"before terminating\",\n       GLOBAL_VAR(delayed_insert_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(DELAYED_WAIT_TIMEOUT),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_delayed_queue_size(\n       \"delayed_queue_size\",\n       \"What size queue (in rows) should be allocated for handling INSERT \"\n       \"DELAYED. If the queue becomes full, any client that does INSERT \"\n       \"DELAYED will wait until there is room in the queue again\",\n       GLOBAL_VAR(delayed_queue_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(DELAYED_QUEUE_SIZE), BLOCK_SIZE(1));\n\n#ifdef HAVE_EVENT_SCHEDULER\nstatic const char *event_scheduler_names[]= { \"OFF\", \"ON\", \"DISABLED\", NullS };\nstatic bool event_scheduler_check(sys_var *self, THD *thd, set_var *var)\n{\n  /* DISABLED is only accepted on the command line */\n  if (var->save_result.ulonglong_value == Events::EVENTS_DISABLED)\n    return true;\n  /*\n    If the scheduler was disabled because there are no/bad\n    system tables, produce a more meaningful error message\n    than ER_OPTION_PREVENTS_STATEMENT\n  */\n  if (Events::check_if_system_tables_error())\n    return true;\n  if (Events::opt_event_scheduler == Events::EVENTS_DISABLED)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0),\n             \"--event-scheduler=DISABLED or --skip-grant-tables\");\n    return true;\n  }\n  return false;\n}\nstatic bool event_scheduler_update(sys_var *self, THD *thd, enum_var_type type)\n{\n  int err_no= 0;\n  uint opt_event_scheduler_value= Events::opt_event_scheduler;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  /*\n    Events::start() is heavyweight. In particular it creates a new THD,\n    which takes LOCK_global_system_variables internally.\n    Thus we have to release it here.\n    We need to re-take it before returning, though.\n\n    Note that since we release LOCK_global_system_variables before calling\n    start/stop, there is a possibility that the server variable\n    can become out of sync with the real event scheduler state.\n\n    This can happen with two concurrent statments if the first gets\n    interrupted after start/stop but before retaking\n    LOCK_global_system_variables. However, this problem should be quite\n    rare and it's difficult to avoid it without opening up possibilities\n    for deadlocks. See bug#51160.\n  */\n  bool ret= opt_event_scheduler_value == Events::EVENTS_ON\n            ? Events::start(&err_no)\n            : Events::stop();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  if (ret)\n  {\n    Events::opt_event_scheduler= Events::EVENTS_OFF;\n    my_error(ER_EVENT_SET_VAR_ERROR, MYF(0), err_no);\n  }\n  return ret;\n}\n\nstatic Sys_var_enum Sys_event_scheduler(\n       \"event_scheduler\", \"Enable the event scheduler. Possible values are \"\n       \"ON, OFF, and DISABLED (keep the event scheduler completely \"\n       \"deactivated, it cannot be activated run-time)\",\n       GLOBAL_VAR(Events::opt_event_scheduler), CMD_LINE(OPT_ARG),\n       event_scheduler_names, DEFAULT(Events::EVENTS_OFF),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(event_scheduler_check), ON_UPDATE(event_scheduler_update));\n#endif\n\nstatic Sys_var_ulong Sys_expire_logs_days(\n       \"expire_logs_days\",\n       \"If non-zero, binary logs will be purged after expire_logs_days \"\n       \"days; possible purges happen at startup and at binary log rotation\",\n       GLOBAL_VAR(expire_logs_days),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 99), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_flush(\n       \"flush\", \"Flush MyISAM tables to disk between SQL commands\",\n       GLOBAL_VAR(myisam_flush),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_flush_time(\n       \"flush_time\",\n       \"A dedicated thread is created to flush all tables at the \"\n       \"given interval\",\n       GLOBAL_VAR(flush_time),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT),\n       DEFAULT(FLUSH_TIME), BLOCK_SIZE(1));\n\nstatic bool check_ftb_syntax(sys_var *self, THD *thd, set_var *var)\n{\n  return ft_boolean_check_syntax_string((uchar*)\n                      (var->save_result.string_value.str));\n}\nstatic bool query_cache_flush(sys_var *self, THD *thd, enum_var_type type)\n{\n#ifdef HAVE_QUERY_CACHE\n  query_cache.flush();\n#endif /* HAVE_QUERY_CACHE */\n  return false;\n}\n/// @todo make SESSION_VAR (usability enhancement and a fix for a race condition)\nstatic Sys_var_charptr Sys_ft_boolean_syntax(\n       \"ft_boolean_syntax\", \"List of operators for \"\n       \"MATCH ... AGAINST ( ... IN BOOLEAN MODE)\",\n       GLOBAL_VAR(ft_boolean_syntax),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(DEFAULT_FTB_SYNTAX), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_ftb_syntax), ON_UPDATE(query_cache_flush));\n\nstatic Sys_var_ulong Sys_ft_max_word_len(\n       \"ft_max_word_len\",\n       \"The maximum length of the word to be included in a FULLTEXT index. \"\n       \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n       READ_ONLY GLOBAL_VAR(ft_max_word_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(10, HA_FT_MAXCHARLEN), DEFAULT(HA_FT_MAXCHARLEN),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_ft_min_word_len(\n       \"ft_min_word_len\",\n       \"The minimum length of the word to be included in a FULLTEXT index. \"\n       \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n       READ_ONLY GLOBAL_VAR(ft_min_word_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, HA_FT_MAXCHARLEN), DEFAULT(4), BLOCK_SIZE(1));\n\n/// @todo make it an updatable SESSION_VAR\nstatic Sys_var_ulong Sys_ft_query_expansion_limit(\n       \"ft_query_expansion_limit\",\n       \"Number of best matches to use for query expansion\",\n       READ_ONLY GLOBAL_VAR(ft_query_expansion_limit),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1000), DEFAULT(20), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_ft_stopword_file(\n       \"ft_stopword_file\",\n       \"Use stopwords from this file instead of built-in list\",\n       READ_ONLY GLOBAL_VAR(ft_stopword_file), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_ignore_builtin_innodb(\n       \"ignore_builtin_innodb\",\n       \"DEPRECATED. This option will be removed in future releases. \"\n       \"Disable initialization of builtin InnoDB plugin\",\n       READ_ONLY GLOBAL_VAR(opt_ignore_builtin_innodb),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic bool check_init_string(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->save_result.string_value.str == 0)\n  {\n    var->save_result.string_value.str= const_cast<char*>(\"\");\n    var->save_result.string_value.length= 0;\n  }\n  return false;\n}\nstatic PolyLock_rwlock PLock_sys_init_connect(&LOCK_sys_init_connect);\nstatic Sys_var_lexstring Sys_init_connect(\n       \"init_connect\", \"Command(s) that are executed for each \"\n       \"new connection\", GLOBAL_VAR(opt_init_connect),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), &PLock_sys_init_connect, NOT_IN_BINLOG,\n       ON_CHECK(check_init_string));\n\nstatic Sys_var_charptr Sys_init_file(\n       \"init_file\", \"Read SQL commands from this file at startup\",\n       READ_ONLY GLOBAL_VAR(opt_init_file),\n#ifdef DISABLE_GRANT_OPTIONS\n       NO_CMD_LINE,\n#else\n       CMD_LINE(REQUIRED_ARG),\n#endif\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic PolyLock_rwlock PLock_sys_init_slave(&LOCK_sys_init_slave);\nstatic Sys_var_lexstring Sys_init_slave(\n       \"init_slave\", \"Command(s) that are executed by a slave server \"\n       \"each time the SQL thread starts\", GLOBAL_VAR(opt_init_slave),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), &PLock_sys_init_slave,\n       NOT_IN_BINLOG, ON_CHECK(check_init_string));\n\nstatic Sys_var_ulong Sys_interactive_timeout(\n       \"interactive_timeout\",\n       \"The number of seconds the server waits for activity on an interactive \"\n       \"connection before closing it\",\n       SESSION_VAR(net_interactive_timeout),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_join_buffer_size(\n       \"join_buffer_size\",\n       \"The size of the buffer that is used for full joins\",\n       SESSION_VAR(join_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(128, ULONG_MAX), DEFAULT(128*1024), BLOCK_SIZE(128));\n\nstatic Sys_var_keycache Sys_key_buffer_size(\n       \"key_buffer_size\", \"The size of the buffer used for \"\n       \"index blocks for MyISAM tables. Increase this to get better index \"\n       \"handling (for all reads and multiple writes) to as much as you can \"\n       \"afford\",\n       KEYCACHE_VAR(param_buff_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_BUFFER_SIZE),\n       VALID_RANGE(0, SIZE_T_MAX), DEFAULT(KEY_CACHE_SIZE),\n       BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_buffer_size));\n\nstatic Sys_var_keycache Sys_key_cache_block_size(\n       \"key_cache_block_size\", \"The default size of key cache blocks\",\n       KEYCACHE_VAR(param_block_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_BLOCK_SIZE),\n       VALID_RANGE(512, 1024*16), DEFAULT(KEY_CACHE_BLOCK_SIZE),\n       BLOCK_SIZE(512), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_division_limit(\n       \"key_cache_division_limit\",\n       \"The minimum percentage of warm blocks in key cache\",\n       KEYCACHE_VAR(param_division_limit),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_DIVISION_LIMIT),\n       VALID_RANGE(1, 100), DEFAULT(100),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_age_threshold(\n       \"key_cache_age_threshold\", \"This characterizes the number of \"\n       \"hits a hot block has to be untouched until it is considered aged \"\n       \"enough to be downgraded to a warm block. This specifies the \"\n       \"percentage ratio of that number of hits to the total number of \"\n       \"blocks in key cache\",\n       KEYCACHE_VAR(param_age_threshold),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_AGE_THRESHOLD),\n       VALID_RANGE(100, ULONG_MAX), DEFAULT(300),\n       BLOCK_SIZE(100), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_keycache_param));\n\nstatic Sys_var_mybool Sys_large_files_support(\n       \"large_files_support\",\n       \"Whether mysqld was compiled with options for large file support\",\n       READ_ONLY GLOBAL_VAR(opt_large_files),\n       NO_CMD_LINE, DEFAULT(sizeof(my_off_t) > 4));\n\nstatic Sys_var_uint Sys_large_page_size(\n       \"large_page_size\",\n       \"If large page support is enabled, this shows the size of memory pages\",\n       READ_ONLY GLOBAL_VAR(opt_large_page_size), NO_CMD_LINE,\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_large_pages(\n       \"large_pages\", \"Enable support for large pages\",\n       READ_ONLY GLOBAL_VAR(opt_large_pages),\n       IF_WIN(NO_CMD_LINE, CMD_LINE(OPT_ARG)), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_language(\n       \"lc_messages_dir\", \"Directory where error messages are\",\n       READ_ONLY GLOBAL_VAR(lc_messages_dir_ptr), CMD_LINE(REQUIRED_ARG, 'L'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_local_infile(\n       \"local_infile\", \"Enable LOAD DATA LOCAL INFILE\",\n       GLOBAL_VAR(opt_local_infile), CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_lock_wait_timeout(\n       \"lock_wait_timeout\",\n       \"Timeout in seconds to wait for a lock before returning an error.\",\n       SESSION_VAR(lock_wait_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(LONG_TIMEOUT), BLOCK_SIZE(1));\n\n#ifdef HAVE_MLOCKALL\nstatic Sys_var_mybool Sys_locked_in_memory(\n       \"locked_in_memory\",\n       \"Whether mysqld was locked in memory with --memlock\",\n       READ_ONLY GLOBAL_VAR(locked_in_memory), NO_CMD_LINE, DEFAULT(FALSE));\n#endif\n\n/* this says NO_CMD_LINE, as command-line option takes a string, not a bool */\nstatic Sys_var_mybool Sys_log_bin(\n       \"log_bin\", \"Whether the binary log is enabled\",\n       READ_ONLY GLOBAL_VAR(opt_bin_log), NO_CMD_LINE, DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_trust_function_creators(\n       \"log_bin_trust_function_creators\",\n       \"If set to FALSE (the default), then when --log-bin is used, creation \"\n       \"of a stored function (or trigger) is allowed only to users having the \"\n       \"SUPER privilege and only if this stored function (trigger) may not \"\n       \"break binary logging. Note that if ALL connections to this server \"\n       \"ALWAYS use row-based binary logging, the security issues do not \"\n       \"exist and the binary logging cannot break, so you can safely set \"\n       \"this to TRUE\",\n       GLOBAL_VAR(trust_function_creators),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_log_error(\n       \"log_error\", \"Error log file\",\n       READ_ONLY GLOBAL_VAR(log_error_file_ptr),\n       CMD_LINE(OPT_ARG, OPT_LOG_ERROR),\n       IN_FS_CHARSET, DEFAULT(disabled_my_option));\n\nstatic Sys_var_mybool Sys_log_queries_not_using_indexes(\n       \"log_queries_not_using_indexes\",\n       \"Log queries that are executed without benefit of any index to the \"\n       \"slow log if it is open\",\n       GLOBAL_VAR(opt_log_queries_not_using_indexes),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_log_warnings(\n       \"log_warnings\",\n       \"Log some not critical warnings to the log file\",\n       SESSION_VAR(log_warnings),\n       CMD_LINE(OPT_ARG, 'W'),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic bool update_cached_long_query_time(sys_var *self, THD *thd,\n                                          enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->variables.long_query_time=\n      double2ulonglong(thd->variables.long_query_time_double * 1e6);\n  else\n    global_system_variables.long_query_time=\n      double2ulonglong(global_system_variables.long_query_time_double * 1e6);\n  return false;\n}\n\nstatic Sys_var_double Sys_long_query_time(\n       \"long_query_time\",\n       \"Log all queries that have taken more than long_query_time seconds \"\n       \"to execute to file. The argument will be treated as a decimal value \"\n       \"with microsecond precision\",\n       SESSION_VAR(long_query_time_double),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(10),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_cached_long_query_time));\n\nstatic bool fix_low_prio_updates(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->update_lock_default= (thd->variables.low_priority_updates ?\n                               TL_WRITE_LOW_PRIORITY : TL_WRITE);\n  else\n    thr_upgraded_concurrent_insert_lock=\n      (global_system_variables.low_priority_updates ?\n       TL_WRITE_LOW_PRIORITY : TL_WRITE);\n  return false;\n}\nstatic Sys_var_mybool Sys_low_priority_updates(\n       \"low_priority_updates\",\n       \"INSERT/DELETE/UPDATE has lower priority than selects\",\n       SESSION_VAR(low_priority_updates),\n       CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_low_prio_updates));\n\n#ifndef TO_BE_DELETED   /* Alias for the low_priority_updates */\nstatic Sys_var_mybool Sys_sql_low_priority_updates(\n       \"sql_low_priority_updates\",\n       \"INSERT/DELETE/UPDATE has lower priority than selects\",\n       SESSION_VAR(low_priority_updates), NO_CMD_LINE,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_low_prio_updates));\n#endif\n\nstatic Sys_var_mybool Sys_lower_case_file_system(\n       \"lower_case_file_system\",\n       \"Case sensitivity of file names on the file system where the \"\n       \"data directory is located\",\n       READ_ONLY GLOBAL_VAR(lower_case_file_system), NO_CMD_LINE,\n       DEFAULT(FALSE));\n\nstatic Sys_var_uint Sys_lower_case_table_names(\n       \"lower_case_table_names\",\n       \"If set to 1 table names are stored in lowercase on disk and table \"\n       \"names will be case-insensitive.  Should be set to 2 if you are using \"\n       \"a case insensitive file system\",\n       READ_ONLY GLOBAL_VAR(lower_case_table_names),\n       CMD_LINE(OPT_ARG, OPT_LOWER_CASE_TABLE_NAMES),\n       VALID_RANGE(0, 2),\n#ifdef FN_NO_CASE_SENSE\n    DEFAULT(1),\n#else\n    DEFAULT(0),\n#endif\n       BLOCK_SIZE(1));\n\nstatic bool session_readonly(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_GLOBAL)\n    return false;\n  my_error(ER_VARIABLE_IS_READONLY, MYF(0), \"SESSION\",\n           self->name.str, \"GLOBAL\");\n  return true;\n}\n\nstatic bool\ncheck_max_allowed_packet(sys_var *self, THD *thd,  set_var *var)\n{\n  longlong val;\n  if (session_readonly(self, thd, var))\n    return true;\n\n  val= var->save_result.ulonglong_value;\n  if (val < (longlong) global_system_variables.net_buffer_length)\n  {\n    push_warning_printf(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                        WARN_OPTION_BELOW_LIMIT, ER(WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\n\n\nstatic Sys_var_ulong Sys_max_allowed_packet(\n       \"max_allowed_packet\",\n       \"Max packet length to send to or receive from the server\",\n       SESSION_VAR(max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024*1024), DEFAULT(1024*1024),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_allowed_packet));\n\nstatic Sys_var_ulong Sys_slave_max_allowed_packet(\n       \"slave_max_allowed_packet\",\n       \"The maximum packet length to sent successfully from the master to slave.\",\n       GLOBAL_VAR(slave_max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, MAX_MAX_ALLOWED_PACKET),\n       DEFAULT(MAX_MAX_ALLOWED_PACKET),\n       BLOCK_SIZE(1024));\n\nstatic Sys_var_ulonglong Sys_max_binlog_cache_size(\n       \"max_binlog_cache_size\",\n       \"Sets the total size of the transactional cache\",\n       GLOBAL_VAR(max_binlog_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, ULONGLONG_MAX),\n       DEFAULT((ULONGLONG_MAX/IO_SIZE)*IO_SIZE),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic Sys_var_ulonglong Sys_max_binlog_stmt_cache_size(\n       \"max_binlog_stmt_cache_size\",\n       \"Sets the total size of the statement cache\",\n       GLOBAL_VAR(max_binlog_stmt_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, ULONGLONG_MAX),\n       DEFAULT((ULONGLONG_MAX/IO_SIZE)*IO_SIZE),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic bool fix_max_binlog_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  mysql_bin_log.set_max_size(max_binlog_size);\n#ifdef HAVE_REPLICATION\n  if (!max_relay_log_size)\n    active_mi->rli.relay_log.set_max_size(max_binlog_size);\n#endif\n  return false;\n}\nstatic Sys_var_ulong Sys_max_binlog_size(\n       \"max_binlog_size\",\n       \"Binary log will be rotated automatically when the size exceeds this \"\n       \"value. Will also apply to relay logs if max_relay_log_size is 0\",\n       GLOBAL_VAR(max_binlog_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, 1024*1024L*1024L), DEFAULT(1024*1024L*1024L),\n       BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_binlog_size));\n\nstatic bool fix_max_connections(sys_var *self, THD *thd, enum_var_type type)\n{\n#ifndef EMBEDDED_LIBRARY\n  resize_thr_alarm(max_connections +\n                   global_system_variables.max_insert_delayed_threads + 10);\n#endif\n  return false;\n}\n\n// Default max_connections of 151 is larger than Apache's default max\n// children, to avoid \"too many connections\" error in a common setup\nstatic Sys_var_ulong Sys_max_connections(\n       \"max_connections\", \"The number of simultaneous clients allowed\",\n       GLOBAL_VAR(max_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 100000), DEFAULT(151), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_max_connections));\n\nstatic Sys_var_ulong Sys_max_connect_errors(\n       \"max_connect_errors\",\n       \"If there is more than this number of interrupted connections from \"\n       \"a host this host will be blocked from further connections\",\n       GLOBAL_VAR(max_connect_errors), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(MAX_CONNECT_ERRORS),\n       BLOCK_SIZE(1));\n\nstatic bool check_max_delayed_threads(sys_var *self, THD *thd, set_var *var)\n{\n  return var->type != OPT_GLOBAL &&\n         var->save_result.ulonglong_value != 0 &&\n         var->save_result.ulonglong_value !=\n                           global_system_variables.max_insert_delayed_threads;\n}\n\n// Alias for max_delayed_threads\nstatic Sys_var_ulong Sys_max_insert_delayed_threads(\n       \"max_insert_delayed_threads\",\n       \"Don't start more than this number of threads to handle INSERT \"\n       \"DELAYED statements. If set to zero INSERT DELAYED will be not used\",\n       SESSION_VAR(max_insert_delayed_threads),\n       NO_CMD_LINE, VALID_RANGE(0, 16384), DEFAULT(20),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_delayed_threads), ON_UPDATE(fix_max_connections));\n\nstatic Sys_var_ulong Sys_max_delayed_threads(\n       \"max_delayed_threads\",\n       \"Don't start more than this number of threads to handle INSERT \"\n       \"DELAYED statements. If set to zero INSERT DELAYED will be not used\",\n       SESSION_VAR(max_insert_delayed_threads),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 16384), DEFAULT(20),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_delayed_threads), ON_UPDATE(fix_max_connections));\n\nstatic Sys_var_ulong Sys_max_error_count(\n       \"max_error_count\",\n       \"Max number of errors/warnings to store for a statement\",\n       SESSION_VAR(max_error_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 65535), DEFAULT(DEFAULT_ERROR_COUNT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_max_heap_table_size(\n       \"max_heap_table_size\",\n       \"Don't allow creation of heap tables bigger than this\",\n       SESSION_VAR(max_heap_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(16384, (ulonglong)~(intptr)0), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1024));\n\nstatic Sys_var_ulong Sys_metadata_locks_cache_size(\n       \"metadata_locks_cache_size\", \"Size of unused metadata locks cache\",\n       READ_ONLY GLOBAL_VAR(mdl_locks_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 1024*1024), DEFAULT(MDL_LOCKS_CACHE_SIZE_DEFAULT),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pseudo_thread_id(\n       \"pseudo_thread_id\",\n       \"This variable is for internal server use\",\n       SESSION_ONLY(pseudo_thread_id),\n       NO_CMD_LINE, VALID_RANGE(0, ULONG_MAX), DEFAULT(0),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG,\n       ON_CHECK(check_has_super));\n\nstatic bool fix_max_join_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  SV *sv= type == OPT_GLOBAL ? &global_system_variables : &thd->variables;\n  if (sv->max_join_size == HA_POS_ERROR)\n    sv->option_bits|= OPTION_BIG_SELECTS;\n  else\n    sv->option_bits&= ~OPTION_BIG_SELECTS;\n  return false;\n}\nstatic Sys_var_harows Sys_max_join_size(\n       \"max_join_size\",\n       \"Joins that are probably going to read more than max_join_size \"\n       \"records return an error\",\n       SESSION_VAR(max_join_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_join_size));\n\nstatic Sys_var_ulong Sys_max_seeks_for_key(\n       \"max_seeks_for_key\",\n       \"Limit assumed max number of seeks when looking up rows based on a key\",\n       SESSION_VAR(max_seeks_for_key), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(ULONG_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_length_for_sort_data(\n       \"max_length_for_sort_data\",\n       \"Max number of bytes in sorted records\",\n       SESSION_VAR(max_length_for_sort_data), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, 8192*1024L), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic Sys_var_harows Sys_sql_max_join_size(\n       \"sql_max_join_size\", \"Alias for max_join_size\",\n       SESSION_VAR(max_join_size), NO_CMD_LINE,\n       VALID_RANGE(1, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_join_size), DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_max_long_data_size(\n       \"max_long_data_size\",\n       \"The maximum BLOB length to send to server from \"\n       \"mysql_send_long_data API. Deprecated option; \"\n       \"use max_allowed_packet instead.\",\n       READ_ONLY GLOBAL_VAR(max_long_data_size),\n       CMD_LINE(REQUIRED_ARG, OPT_MAX_LONG_DATA_SIZE),\n       VALID_RANGE(1024, UINT_MAX32), DEFAULT(1024*1024),\n       BLOCK_SIZE(1));\n\nstatic PolyLock_mutex PLock_prepared_stmt_count(&LOCK_prepared_stmt_count);\nstatic Sys_var_ulong Sys_max_prepared_stmt_count(\n       \"max_prepared_stmt_count\",\n       \"Maximum number of prepared statements in the server\",\n       GLOBAL_VAR(max_prepared_stmt_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1024*1024), DEFAULT(16382), BLOCK_SIZE(1),\n       &PLock_prepared_stmt_count);\n\nstatic bool fix_max_relay_log_size(sys_var *self, THD *thd, enum_var_type type)\n{\n#ifdef HAVE_REPLICATION\n  active_mi->rli.relay_log.set_max_size(max_relay_log_size ?\n                                        max_relay_log_size: max_binlog_size);\n#endif\n  return false;\n}\nstatic Sys_var_ulong Sys_max_relay_log_size(\n       \"max_relay_log_size\",\n       \"If non-zero: relay log will be rotated automatically when the \"\n       \"size exceeds this value; if zero: when the size \"\n       \"exceeds max_binlog_size\",\n       GLOBAL_VAR(max_relay_log_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1024L*1024*1024), DEFAULT(0), BLOCK_SIZE(IO_SIZE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_relay_log_size));\n\nstatic Sys_var_ulong Sys_max_sort_length(\n       \"max_sort_length\",\n       \"The number of bytes to use when sorting BLOB or TEXT values (only \"\n       \"the first max_sort_length bytes of each value are used; the rest \"\n       \"are ignored)\",\n       SESSION_VAR(max_sort_length), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, 8192*1024L), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_sp_recursion_depth(\n       \"max_sp_recursion_depth\",\n       \"Maximum stored procedure recursion depth\",\n       SESSION_VAR(max_sp_recursion_depth), CMD_LINE(OPT_ARG),\n       VALID_RANGE(0, 255), DEFAULT(0), BLOCK_SIZE(1));\n\n// non-standard session_value_ptr() here\nstatic Sys_var_max_user_conn Sys_max_user_connections(\n       \"max_user_connections\",\n       \"The maximum number of active connections for a single user \"\n       \"(0 = no limit)\",\n       SESSION_VAR(max_user_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(session_readonly));\n\nstatic Sys_var_ulong Sys_max_tmp_tables(\n       \"max_tmp_tables\",\n       \"Maximum number of temporary tables a client can keep open at a time\",\n       SESSION_VAR(max_tmp_tables), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(32), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_write_lock_count(\n       \"max_write_lock_count\",\n       \"After this many write locks, allow some read locks to run in between\",\n       GLOBAL_VAR(max_write_lock_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(ULONG_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_min_examined_row_limit(\n       \"min_examined_row_limit\",\n       \"Don't write queries to slow log that examine fewer rows \"\n       \"than that\",\n       SESSION_VAR(min_examined_row_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\n#ifdef _WIN32\nstatic Sys_var_mybool Sys_named_pipe(\n       \"named_pipe\", \"Enable the named pipe (NT)\",\n       READ_ONLY GLOBAL_VAR(opt_enable_named_pipe), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n#endif\n\n\nstatic bool \ncheck_net_buffer_length(sys_var *self, THD *thd,  set_var *var)\n{\n  longlong val;\n  if (session_readonly(self, thd, var))\n    return true;\n\n  val= var->save_result.ulonglong_value;\n  if (val > (longlong) global_system_variables.max_allowed_packet)\n  {\n    push_warning_printf(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                        WARN_OPTION_BELOW_LIMIT, ER(WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_buffer_length(\n       \"net_buffer_length\",\n       \"Buffer length for TCP/IP and socket communication\",\n       SESSION_VAR(net_buffer_length), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024), DEFAULT(16384), BLOCK_SIZE(1024),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_net_buffer_length));\n\nstatic bool fix_net_read_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    my_net_set_read_timeout(&thd->net, thd->variables.net_read_timeout);\n  return false;\n}\nstatic Sys_var_ulong Sys_net_read_timeout(\n       \"net_read_timeout\",\n       \"Number of seconds to wait for more data from a connection before \"\n       \"aborting the read\",\n       SESSION_VAR(net_read_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_READ_TIMEOUT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_read_timeout));\n\nstatic bool fix_net_write_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    my_net_set_write_timeout(&thd->net, thd->variables.net_write_timeout);\n  return false;\n}\nstatic Sys_var_ulong Sys_net_write_timeout(\n       \"net_write_timeout\",\n       \"Number of seconds to wait for a block to be written to a connection \"\n       \"before aborting the write\",\n       SESSION_VAR(net_write_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WRITE_TIMEOUT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_write_timeout));\n\nstatic bool fix_net_retry_count(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    thd->net.retry_count=thd->variables.net_retry_count;\n  return false;\n}\nstatic Sys_var_ulong Sys_net_retry_count(\n       \"net_retry_count\",\n       \"If a read on a communication port is interrupted, retry this \"\n       \"many times before giving up\",\n       SESSION_VAR(net_retry_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(MYSQLD_NET_RETRY_COUNT),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_retry_count));\n\nstatic Sys_var_mybool Sys_new_mode(\n       \"new\", \"Use very new possible \\\"unsafe\\\" functions\",\n       SESSION_VAR(new_mode), CMD_LINE(OPT_ARG, 'n'), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_old_mode(\n       \"old\", \"Use compatible behavior\",\n       READ_ONLY GLOBAL_VAR(old_mode), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_old_alter_table(\n       \"old_alter_table\", \"Use old, non-optimized alter table\",\n       SESSION_VAR(old_alter_table), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic bool check_old_passwords(sys_var *self, THD *thd, set_var *var)\n{\n  return mysql_user_table_is_in_short_password_format;\n}\nstatic Sys_var_mybool Sys_old_passwords(\n       \"old_passwords\",\n       \"Use old password encryption method (needed for 4.0 and older clients)\",\n       SESSION_VAR(old_passwords), CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_old_passwords));\n\nstatic Sys_var_ulong Sys_open_files_limit(\n       \"open_files_limit\",\n       \"If this is not 0, then mysqld will use this value to reserve file \"\n       \"descriptors to use with setrlimit(). If this value is 0 then mysqld \"\n       \"will reserve max_connections*5 or max_connections + table_cache*2 \"\n       \"(whichever is larger) number of file descriptors\",\n       READ_ONLY GLOBAL_VAR(open_files_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, OS_FILE_LIMIT), DEFAULT(0), BLOCK_SIZE(1));\n\n/// @todo change to enum\nstatic Sys_var_ulong Sys_optimizer_prune_level(\n       \"optimizer_prune_level\",\n       \"Controls the heuristic(s) applied during query optimization to prune \"\n       \"less-promising partial plans from the optimizer search space. \"\n       \"Meaning: 0 - do not apply any heuristic, thus perform exhaustive \"\n       \"search; 1 - prune plans based on number of retrieved rows\",\n       SESSION_VAR(optimizer_prune_level), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1), DEFAULT(1), BLOCK_SIZE(1));\n\n/** Warns about deprecated value 63 */\nstatic bool fix_optimizer_search_depth(sys_var *self, THD *thd,\n                                       enum_var_type type)\n{\n  SV *sv= type == OPT_GLOBAL ? &global_system_variables : &thd->variables;\n  if (sv->optimizer_search_depth == MAX_TABLES+2)\n    WARN_DEPRECATED(thd, 6, 0, \"optimizer-search-depth=63\",\n                    \"a search depth less than 63\");\n  return false;\n}\n\nstatic Sys_var_ulong Sys_optimizer_search_depth(\n       \"optimizer_search_depth\",\n       \"Maximum depth of search performed by the query optimizer. Values \"\n       \"larger than the number of relations in a query result in better \"\n       \"query plans, but take longer to compile a query. Values smaller \"\n       \"than the number of tables in a relation result in faster \"\n       \"optimization, but may produce very bad query plans. If set to 0, \"\n       \"the system will automatically pick a reasonable value; if set to \"\n       \"63, the optimizer will switch to the original find_best search. \"\n       \"NOTE: The value 63 and its associated behaviour is deprecated\",\n       SESSION_VAR(optimizer_search_depth), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, MAX_TABLES+2), DEFAULT(MAX_TABLES+1), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_optimizer_search_depth));\n\nstatic const char *optimizer_switch_names[]=\n{\n  \"index_merge\", \"index_merge_union\", \"index_merge_sort_union\",\n  \"index_merge_intersection\", \"engine_condition_pushdown\",\n  \"default\", NullS\n};\n/** propagates changes to @@engine_condition_pushdown */\nstatic bool fix_optimizer_switch(sys_var *self, THD *thd,\n                                 enum_var_type type)\n{\n  SV *sv= (type == OPT_GLOBAL) ? &global_system_variables : &thd->variables;\n  sv->engine_condition_pushdown= \n    test(sv->optimizer_switch & OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN);\n  return false;\n}\nstatic Sys_var_flagset Sys_optimizer_switch(\n       \"optimizer_switch\",\n       \"optimizer_switch=option=val[,option=val...], where option is one of \"\n       \"{index_merge, index_merge_union, index_merge_sort_union, \"\n       \"index_merge_intersection, engine_condition_pushdown}\"\n       \" and val is one of {on, off, default}\",\n       SESSION_VAR(optimizer_switch), CMD_LINE(REQUIRED_ARG),\n       optimizer_switch_names, DEFAULT(OPTIMIZER_SWITCH_DEFAULT),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(fix_optimizer_switch));\n\nstatic Sys_var_charptr Sys_pid_file(\n       \"pid_file\", \"Pid file used by safe_mysqld\",\n       READ_ONLY GLOBAL_VAR(pidfile_name_ptr), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_plugin_dir(\n       \"plugin_dir\", \"Directory for plugins\",\n       READ_ONLY GLOBAL_VAR(opt_plugin_dir_ptr), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_port(\n       \"port\",\n       \"Port number to use for connection or 0 to default to, \"\n       \"my.cnf, $MYSQL_TCP_PORT, \"\n#if MYSQL_PORT_DEFAULT == 0\n       \"/etc/services, \"\n#endif\n       \"built-in default (\" STRINGIFY_ARG(MYSQL_PORT) \"), whatever comes first\",\n       READ_ONLY GLOBAL_VAR(mysqld_port), CMD_LINE(REQUIRED_ARG, 'P'),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_preload_buff_size(\n       \"preload_buffer_size\",\n       \"The size of the buffer that is allocated when preloading indexes\",\n       SESSION_VAR(preload_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024*1024), DEFAULT(32768), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_protocol_version(\n       \"protocol_version\",\n       \"The version of the client/server protocol used by the MySQL server\",\n       READ_ONLY GLOBAL_VAR(protocol_version), NO_CMD_LINE,\n       VALID_RANGE(0, ~0), DEFAULT(PROTOCOL_VERSION), BLOCK_SIZE(1));\n\nstatic Sys_var_proxy_user Sys_proxy_user(\n       \"proxy_user\", \"The proxy user account name used when logging in\",\n       IN_SYSTEM_CHARSET);\n\nstatic Sys_var_external_user Sys_exterenal_user(\n       \"external_user\", \"The external user account used when logging in\",\n       IN_SYSTEM_CHARSET);\n\nstatic Sys_var_ulong Sys_read_buff_size(\n       \"read_buffer_size\",\n       \"Each thread that does a sequential scan allocates a buffer of \"\n       \"this size for each table it scans. If you do many sequential scans, \"\n       \"you may want to increase this value\",\n       SESSION_VAR(read_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE*2, INT_MAX32), DEFAULT(128*1024),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic bool check_read_only(sys_var *self, THD *thd, set_var *var)\n{\n  /* Prevent self dead-lock */\n  if (thd->locked_tables_mode || thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));\n    return true;\n  }\n  return false;\n}\nstatic bool fix_read_only(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool result= true;\n  my_bool new_read_only= read_only; // make a copy before releasing a mutex\n  DBUG_ENTER(\"sys_var_opt_readonly::update\");\n\n  if (read_only == FALSE || read_only == opt_readonly)\n  {\n    opt_readonly= read_only;\n    DBUG_RETURN(false);\n  }\n\n  if (check_read_only(self, thd, 0)) // just in case\n    goto end;\n\n  if (thd->global_read_lock.is_acquired())\n  {\n    /*\n      This connection already holds the global read lock.\n      This can be the case with:\n      - FLUSH TABLES WITH READ LOCK\n      - SET GLOBAL READ_ONLY = 1\n    */\n    opt_readonly= read_only;\n    DBUG_RETURN(false);\n  }\n\n  /*\n    Perform a 'FLUSH TABLES WITH READ LOCK'.\n    This is a 3 step process:\n    - [1] lock_global_read_lock()\n    - [2] close_cached_tables()\n    - [3] make_global_read_lock_block_commit()\n    [1] prevents new connections from obtaining tables locked for write.\n    [2] waits until all existing connections close their tables.\n    [3] prevents transactions from being committed.\n  */\n\n  read_only= opt_readonly;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (thd->global_read_lock.lock_global_read_lock(thd))\n    goto end_with_mutex_unlock;\n\n  /*\n    This call will be blocked by any connection holding a READ or WRITE lock.\n    Ideally, we want to wait only for pending WRITE locks, but since:\n    con 1> LOCK TABLE T FOR READ;\n    con 2> LOCK TABLE T FOR WRITE; (blocked by con 1)\n    con 3> SET GLOBAL READ ONLY=1; (blocked by con 2)\n    can cause to wait on a read lock, it's required for the client application\n    to unlock everything, and acceptable for the server to wait on all locks.\n  */\n  if ((result= close_cached_tables(thd, NULL, TRUE,\n                                   thd->variables.lock_wait_timeout)))\n    goto end_with_read_lock;\n\n  if ((result= thd->global_read_lock.make_global_read_lock_block_commit(thd)))\n    goto end_with_read_lock;\n\n  /* Change the opt_readonly system variable, safe because the lock is held */\n  opt_readonly= new_read_only;\n  result= false;\n\n end_with_read_lock:\n  /* Release the lock */\n  thd->global_read_lock.unlock_global_read_lock(thd);\n end_with_mutex_unlock:\n  mysql_mutex_lock(&LOCK_global_system_variables);\n end:\n  read_only= opt_readonly;\n  DBUG_RETURN(result);\n}\n\n\n/**\n  The read_only boolean is always equal to the opt_readonly boolean except\n  during fix_read_only(); when that function is entered, opt_readonly is\n  the pre-update value and read_only is the post-update value.\n  fix_read_only() compares them and runs needed operations for the\n  transition (especially when transitioning from false to true) and\n  synchronizes both booleans in the end.\n*/\nstatic Sys_var_mybool Sys_readonly(\n       \"read_only\",\n       \"Make all non-temporary tables read-only, with the exception for \"\n       \"replication (slave) threads and users with the SUPER privilege\",\n       GLOBAL_VAR(read_only), CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_read_only), ON_UPDATE(fix_read_only));\n\n// Small lower limit to be able to test MRR\nstatic Sys_var_ulong Sys_read_rnd_buff_size(\n       \"read_rnd_buffer_size\",\n       \"When reading rows in sorted order after a sort, the rows are read \"\n       \"through this buffer to avoid a disk seeks\",\n       SESSION_VAR(read_rnd_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, INT_MAX32), DEFAULT(256*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_div_precincrement(\n       \"div_precision_increment\", \"Precision of the result of '/' \"\n       \"operator will be increased on that value\",\n       SESSION_VAR(div_precincrement), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, DECIMAL_MAX_SCALE), DEFAULT(4), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_rpl_recovery_rank(\n       \"rpl_recovery_rank\", \"Unused, will be removed\",\n       GLOBAL_VAR(rpl_recovery_rank), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_range_alloc_block_size(\n       \"range_alloc_block_size\",\n       \"Allocation block size for storing ranges during optimization\",\n       SESSION_VAR(range_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(RANGE_ALLOC_BLOCK_SIZE, ULONG_MAX),\n       DEFAULT(RANGE_ALLOC_BLOCK_SIZE), BLOCK_SIZE(1024));\n\nstatic Sys_var_ulong Sys_multi_range_count(\n       \"multi_range_count\", \"Number of key ranges to request at once\",\n       SESSION_VAR(multi_range_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(256), BLOCK_SIZE(1));\n\nstatic bool fix_thd_mem_root(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    reset_root_defaults(thd->mem_root,\n                        thd->variables.query_alloc_block_size,\n                        thd->variables.query_prealloc_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_query_alloc_block_size(\n       \"query_alloc_block_size\",\n       \"Allocation block size for query parsing and execution\",\n       SESSION_VAR(query_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, ULONG_MAX), DEFAULT(QUERY_ALLOC_BLOCK_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_thd_mem_root));\n\nstatic Sys_var_ulong Sys_query_prealloc_size(\n       \"query_prealloc_size\",\n       \"Persistent buffer for query parsing and execution\",\n       SESSION_VAR(query_prealloc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(QUERY_ALLOC_PREALLOC_SIZE, ULONG_MAX),\n       DEFAULT(QUERY_ALLOC_PREALLOC_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_thd_mem_root));\n\n#ifdef HAVE_SMEM\nstatic Sys_var_mybool Sys_shared_memory(\n       \"shared_memory\", \"Enable the shared memory\",\n       READ_ONLY GLOBAL_VAR(opt_enable_shared_memory), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_shared_memory_base_name(\n       \"shared_memory_base_name\", \"Base name of shared memory\",\n       READ_ONLY GLOBAL_VAR(shared_memory_base_name), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n#endif\n\n// this has to be NO_CMD_LINE as the command-line option has a different name\nstatic Sys_var_mybool Sys_skip_external_locking(\n       \"skip_external_locking\", \"Don't use system (external) locking\",\n       READ_ONLY GLOBAL_VAR(my_disable_locking), NO_CMD_LINE, DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_skip_networking(\n       \"skip_networking\", \"Don't allow connection with TCP/IP\",\n       READ_ONLY GLOBAL_VAR(opt_disable_networking), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_skip_name_resolve(\n       \"skip_name_resolve\",\n       \"Don't resolve hostnames. All hostnames are IP's or 'localhost'.\",\n       READ_ONLY GLOBAL_VAR(opt_skip_name_resolve),\n       CMD_LINE(OPT_ARG, OPT_SKIP_RESOLVE),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_skip_show_database(\n       \"skip_show_database\", \"Don't allow 'SHOW DATABASE' commands\",\n       READ_ONLY GLOBAL_VAR(opt_skip_show_db), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_socket(\n       \"socket\", \"Socket file to use for connection\",\n       READ_ONLY GLOBAL_VAR(mysqld_unix_port), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\n/* \n  thread_concurrency is a no-op on all platforms since\n  MySQL 5.1.  It will be removed in the context of\n  WL#5265\n*/\nstatic Sys_var_ulong Sys_thread_concurrency(\n       \"thread_concurrency\",\n       \"Permits the application to give the threads system a hint for \"\n       \"the desired number of threads that should be run at the same time.\"\n       \"This variable has no effect, and is deprecated. \"\n       \"It will be removed in a future release.\",\n       READ_ONLY GLOBAL_VAR(concurrency),\n       CMD_LINE(REQUIRED_ARG, OPT_THREAD_CONCURRENCY),\n       VALID_RANGE(1, 512), DEFAULT(DEFAULT_CONCURRENCY), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_thread_stack(\n       \"thread_stack\", \"The stack size for each thread\",\n       READ_ONLY GLOBAL_VAR(my_thread_stack_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(128*1024, ULONG_MAX), DEFAULT(DEFAULT_THREAD_STACK),\n       BLOCK_SIZE(1024));\n\nstatic Sys_var_charptr Sys_tmpdir(\n       \"tmpdir\", \"Path for temporary files. Several paths may \"\n       \"be specified, separated by a \"\n#if defined(__WIN__)\n       \"semicolon (;)\"\n#else\n       \"colon (:)\"\n#endif\n       \", in this case they are used in a round-robin fashion\",\n       READ_ONLY GLOBAL_VAR(opt_mysql_tmpdir), CMD_LINE(REQUIRED_ARG, 't'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool fix_trans_mem_root(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    reset_root_defaults(&thd->transaction.mem_root,\n                        thd->variables.trans_alloc_block_size,\n                        thd->variables.trans_prealloc_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_trans_alloc_block_size(\n       \"transaction_alloc_block_size\",\n       \"Allocation block size for transactions to be stored in binary log\",\n       SESSION_VAR(trans_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 128 * 1024), DEFAULT(QUERY_ALLOC_BLOCK_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_trans_mem_root));\n\nstatic Sys_var_ulong Sys_trans_prealloc_size(\n       \"transaction_prealloc_size\",\n       \"Persistent buffer for transactions to be stored in binary log\",\n       SESSION_VAR(trans_prealloc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 128 * 1024), DEFAULT(TRANS_ALLOC_PREALLOC_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_trans_mem_root));\n\nstatic const char *thread_handling_names[]=\n{\n  \"one-thread-per-connection\", \"no-threads\", \"loaded-dynamically\",\n  0\n};\nstatic Sys_var_enum Sys_thread_handling(\n       \"thread_handling\",\n       \"Define threads usage for handling queries, one of \"\n       \"one-thread-per-connection, no-threads, loaded-dynamically\"\n       , READ_ONLY GLOBAL_VAR(thread_handling), CMD_LINE(REQUIRED_ARG),\n       thread_handling_names, DEFAULT(0));\n\n#ifdef HAVE_QUERY_CACHE\nstatic bool fix_query_cache_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  ulong new_cache_size= query_cache.resize(query_cache_size);\n  /*\n     Note: query_cache_size is a global variable reflecting the\n     requested cache size. See also query_cache_size_arg\n  */\n  if (query_cache_size != new_cache_size)\n    push_warning_printf(current_thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                        ER_WARN_QC_RESIZE, ER(ER_WARN_QC_RESIZE),\n                        query_cache_size, new_cache_size);\n\n  query_cache_size= new_cache_size;\n  return false;\n}\nstatic Sys_var_ulong Sys_query_cache_size(\n       \"query_cache_size\",\n       \"The memory allocated to store results from old queries\",\n       GLOBAL_VAR(query_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1024),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_query_cache_size));\n\nstatic Sys_var_ulong Sys_query_cache_limit(\n       \"query_cache_limit\",\n       \"Don't cache results that are bigger than this\",\n       GLOBAL_VAR(query_cache.query_cache_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(1024*1024), BLOCK_SIZE(1));\n\nstatic bool fix_qcache_min_res_unit(sys_var *self, THD *thd, enum_var_type type)\n{\n  query_cache_min_res_unit=\n    query_cache.set_min_res_unit(query_cache_min_res_unit);\n  return false;\n}\nstatic Sys_var_ulong Sys_query_cache_min_res_unit(\n       \"query_cache_min_res_unit\",\n       \"The minimum size for blocks allocated by the query cache\",\n       GLOBAL_VAR(query_cache_min_res_unit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(QUERY_CACHE_MIN_RESULT_DATA_SIZE),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_qcache_min_res_unit));\n\nstatic const char *query_cache_type_names[]= { \"OFF\", \"ON\", \"DEMAND\", 0 };\nstatic bool check_query_cache_type(sys_var *self, THD *thd, set_var *var)\n{\n  if (query_cache.is_disabled())\n  {\n    my_error(ER_QUERY_CACHE_DISABLED, MYF(0));\n    return true;\n  }\n  return false;\n}\nstatic Sys_var_enum Sys_query_cache_type(\n       \"query_cache_type\",\n       \"OFF = Don't cache or retrieve results. ON = Cache all results \"\n       \"except SELECT SQL_NO_CACHE ... queries. DEMAND = Cache only \"\n       \"SELECT SQL_CACHE ... queries\",\n       SESSION_VAR(query_cache_type), CMD_LINE(REQUIRED_ARG),\n       query_cache_type_names, DEFAULT(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_query_cache_type));\n\nstatic Sys_var_mybool Sys_query_cache_wlock_invalidate(\n       \"query_cache_wlock_invalidate\",\n       \"Invalidate queries in query cache on LOCK for write\",\n       SESSION_VAR(query_cache_wlock_invalidate), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n#endif /* HAVE_QUERY_CACHE */\n\nstatic Sys_var_mybool Sys_secure_auth(\n       \"secure_auth\",\n       \"Disallow authentication for accounts that have old (pre-4.1) \"\n       \"passwords\",\n       GLOBAL_VAR(opt_secure_auth), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_secure_file_priv(\n       \"secure_file_priv\",\n       \"Limit LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE() to files \"\n       \"within specified directory\",\n       READ_ONLY GLOBAL_VAR(opt_secure_file_priv),\n#ifndef EMBEDDED_LIBRARY\n       CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(DEFAULT_SECURE_FILE_PRIV_DIR));\n#else\n       CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(DEFAULT_SECURE_FILE_PRIV_EMBEDDED_DIR));\n#endif\n\nstatic bool fix_server_id(sys_var *self, THD *thd, enum_var_type type)\n{\n  server_id_supplied = 1;\n  thd->server_id= server_id;\n  return false;\n}\nstatic Sys_var_ulong Sys_server_id(\n       \"server_id\",\n       \"Uniquely identifies the server instance in the community of \"\n       \"replication partners\",\n       GLOBAL_VAR(server_id), CMD_LINE(REQUIRED_ARG, OPT_SERVER_ID),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_server_id));\n\nstatic Sys_var_mybool Sys_slave_compressed_protocol(\n       \"slave_compressed_protocol\",\n       \"Use compression on master/slave protocol\",\n       GLOBAL_VAR(opt_slave_compressed_protocol), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\n#ifdef HAVE_REPLICATION\nstatic const char *slave_exec_mode_names[]= {\"STRICT\", \"IDEMPOTENT\", 0};\nstatic Sys_var_enum Slave_exec_mode(\n       \"slave_exec_mode\",\n       \"Modes for how replication events should be executed. Legal values \"\n       \"are STRICT (default) and IDEMPOTENT. In IDEMPOTENT mode, \"\n       \"replication will not stop for operations that are idempotent. \"\n       \"In STRICT mode, replication will stop on any unexpected difference \"\n       \"between the master and the slave\",\n       GLOBAL_VAR(slave_exec_mode_options), CMD_LINE(REQUIRED_ARG),\n       slave_exec_mode_names, DEFAULT(SLAVE_EXEC_MODE_STRICT));\nconst char *slave_type_conversions_name[]= {\"ALL_LOSSY\", \"ALL_NON_LOSSY\", 0};\nstatic Sys_var_set Slave_type_conversions(\n       \"slave_type_conversions\",\n       \"Set of slave type conversions that are enabled. Legal values are:\"\n       \" ALL_LOSSY to enable lossy conversions and\"\n       \" ALL_NON_LOSSY to enable non-lossy conversions.\"\n       \" If the variable is assigned the empty set, no conversions are\"\n       \" allowed and it is expected that the types match exactly.\",\n       GLOBAL_VAR(slave_type_conversions_options), CMD_LINE(REQUIRED_ARG),\n       slave_type_conversions_name,\n       DEFAULT(0));\n#endif\n\n\nstatic Sys_var_ulong Sys_slow_launch_time(\n       \"slow_launch_time\",\n       \"If creating the thread takes longer than this value (in seconds), \"\n       \"the Slow_launch_threads counter will be incremented\",\n       GLOBAL_VAR(slow_launch_time), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(2), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_sort_buffer(\n       \"sort_buffer_size\",\n       \"Each thread that needs to do a sort allocates a buffer of this size\",\n       SESSION_VAR(sortbuff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(MIN_SORT_MEMORY, ULONG_MAX), DEFAULT(MAX_SORT_MEMORY),\n       BLOCK_SIZE(1));\n\nexport ulong expand_sql_mode(ulonglong sql_mode)\n{\n  if (sql_mode & MODE_ANSI)\n  {\n    /*\n      Note that we dont set\n      MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS | MODE_NO_FIELD_OPTIONS\n      to allow one to get full use of MySQL in this mode.\n\n      MODE_ONLY_FULL_GROUP_BY was removed from ANSI mode because it is\n      currently overly restrictive (see BUG#8510).\n    */\n    sql_mode|= (MODE_REAL_AS_FLOAT | MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE);\n  }\n  if (sql_mode & MODE_ORACLE)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS | MODE_NO_AUTO_CREATE_USER);\n  if (sql_mode & MODE_MSSQL)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_POSTGRESQL)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_DB2)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_MAXDB)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS | MODE_NO_AUTO_CREATE_USER);\n  if (sql_mode & MODE_MYSQL40)\n    sql_mode|= MODE_HIGH_NOT_PRECEDENCE;\n  if (sql_mode & MODE_MYSQL323)\n    sql_mode|= MODE_HIGH_NOT_PRECEDENCE;\n  if (sql_mode & MODE_TRADITIONAL)\n    sql_mode|= (MODE_STRICT_TRANS_TABLES | MODE_STRICT_ALL_TABLES |\n                MODE_NO_ZERO_IN_DATE | MODE_NO_ZERO_DATE |\n                MODE_ERROR_FOR_DIVISION_BY_ZERO | MODE_NO_AUTO_CREATE_USER |\n                MODE_NO_ENGINE_SUBSTITUTION);\n  return sql_mode;\n}\nstatic bool check_sql_mode(sys_var *self, THD *thd, set_var *var)\n{\n  var->save_result.ulonglong_value=\n    expand_sql_mode(var->save_result.ulonglong_value);\n  return false;\n}\nstatic bool fix_sql_mode(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n  {\n    /* Update thd->server_status */\n    if (thd->variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES)\n      thd->server_status|= SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n    else\n      thd->server_status&= ~SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n  }\n  return false;\n}\n/*\n  WARNING: When adding new SQL modes don't forget to update the\n  tables definitions that stores it's value (ie: mysql.event, mysql.proc)\n*/\nstatic const char *sql_mode_names[]=\n{\n  \"REAL_AS_FLOAT\", \"PIPES_AS_CONCAT\", \"ANSI_QUOTES\", \"IGNORE_SPACE\", \",\",\n  \"ONLY_FULL_GROUP_BY\", \"NO_UNSIGNED_SUBTRACTION\", \"NO_DIR_IN_CREATE\",\n  \"POSTGRESQL\", \"ORACLE\", \"MSSQL\", \"DB2\", \"MAXDB\", \"NO_KEY_OPTIONS\",\n  \"NO_TABLE_OPTIONS\", \"NO_FIELD_OPTIONS\", \"MYSQL323\", \"MYSQL40\", \"ANSI\",\n  \"NO_AUTO_VALUE_ON_ZERO\", \"NO_BACKSLASH_ESCAPES\", \"STRICT_TRANS_TABLES\",\n  \"STRICT_ALL_TABLES\", \"NO_ZERO_IN_DATE\", \"NO_ZERO_DATE\",\n  \"ALLOW_INVALID_DATES\", \"ERROR_FOR_DIVISION_BY_ZERO\", \"TRADITIONAL\",\n  \"NO_AUTO_CREATE_USER\", \"HIGH_NOT_PRECEDENCE\", \"NO_ENGINE_SUBSTITUTION\",\n  \"PAD_CHAR_TO_FULL_LENGTH\",\n  0\n};\nexport bool sql_mode_string_representation(THD *thd, ulong sql_mode,\n                                           LEX_STRING *ls)\n{\n  set_to_string(thd, ls, sql_mode, sql_mode_names);\n  return ls->str == 0;\n}\n/*\n  sql_mode should *not* be IN_BINLOG: even though it is written to the binlog,\n  the slave ignores the MODE_NO_DIR_IN_CREATE variable, so slave's value\n  differs from master's (see log_event.cc: Query_log_event::do_apply_event()).\n*/\nstatic Sys_var_set Sys_sql_mode(\n       \"sql_mode\",\n       \"Syntax: sql-mode=mode[,mode[,mode...]]. See the manual for the \"\n       \"complete list of valid sql modes\",\n       SESSION_VAR(sql_mode), CMD_LINE(REQUIRED_ARG),\n       sql_mode_names, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_sql_mode), ON_UPDATE(fix_sql_mode));\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n#define SSL_OPT(X) CMD_LINE(REQUIRED_ARG,X)\n#else\n#define SSL_OPT(X) NO_CMD_LINE\n#endif\n\nstatic Sys_var_charptr Sys_ssl_ca(\n       \"ssl_ca\",\n       \"CA file in PEM format (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_ca), SSL_OPT(OPT_SSL_CA),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_capath(\n       \"ssl_capath\",\n       \"CA directory (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_capath), SSL_OPT(OPT_SSL_CAPATH),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_cert(\n       \"ssl_cert\", \"X509 cert in PEM format (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_cert), SSL_OPT(OPT_SSL_CERT),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_cipher(\n       \"ssl_cipher\", \"SSL cipher to use (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_cipher), SSL_OPT(OPT_SSL_CIPHER),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_key(\n       \"ssl_key\", \"X509 key in PEM format (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_key), SSL_OPT(OPT_SSL_KEY),\n       IN_FS_CHARSET, DEFAULT(0));\n\n// why ENUM and not BOOL ?\nstatic const char *updatable_views_with_limit_names[]= {\"NO\", \"YES\", 0};\nstatic Sys_var_enum Sys_updatable_views_with_limit(\n       \"updatable_views_with_limit\",\n       \"YES = Don't issue an error message (warning only) if a VIEW without \"\n       \"presence of a key of the underlying table is used in queries with a \"\n       \"LIMIT clause for updating. NO = Prohibit update of a VIEW, which \"\n       \"does not contain a key of the underlying table and the query uses \"\n       \"a LIMIT clause (usually get from GUI tools)\",\n       SESSION_VAR(updatable_views_with_limit), CMD_LINE(REQUIRED_ARG),\n       updatable_views_with_limit_names, DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_sync_frm(\n       \"sync_frm\", \"Sync .frm files to disk on creation\",\n       GLOBAL_VAR(opt_sync_frm), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\nstatic char *system_time_zone_ptr;\nstatic Sys_var_charptr Sys_system_time_zone(\n       \"system_time_zone\", \"The server system time zone\",\n       READ_ONLY GLOBAL_VAR(system_time_zone_ptr), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(system_time_zone));\n\nstatic Sys_var_ulong Sys_table_def_size(\n       \"table_definition_cache\",\n       \"The number of cached table definitions\",\n       GLOBAL_VAR(table_def_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(TABLE_DEF_CACHE_MIN, 512*1024),\n       DEFAULT(TABLE_DEF_CACHE_DEFAULT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_table_cache_size(\n       \"table_open_cache\", \"The number of cached open tables\",\n       GLOBAL_VAR(table_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 512*1024), DEFAULT(TABLE_OPEN_CACHE_DEFAULT),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_thread_cache_size(\n       \"thread_cache_size\",\n       \"How many threads we should keep in a cache for reuse\",\n       GLOBAL_VAR(thread_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 16384), DEFAULT(0), BLOCK_SIZE(1));\n\n/**\n  Can't change the 'next' tx_isolation if we are already in a\n  transaction.\n*/\n\nstatic bool check_tx_isolation(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_DEFAULT && thd->in_active_multi_stmt_transaction())\n  {\n    DBUG_ASSERT(thd->in_multi_stmt_transaction_mode());\n    my_error(ER_CANT_CHANGE_TX_ISOLATION, MYF(0));\n    return TRUE;\n  }\n  return FALSE;\n}\n\n\nbool Sys_var_tx_isolation::session_update(THD *thd, set_var *var)\n{\n  if (var->type == OPT_SESSION && Sys_var_enum::session_update(thd, var))\n    return TRUE;\n  if (var->type == OPT_DEFAULT || !thd->in_active_multi_stmt_transaction())\n  {\n    /*\n      Update the isolation level of the next transaction.\n      I.e. if one did:\n      COMMIT;\n      SET SESSION ISOLATION LEVEL ...\n      BEGIN; <-- this transaction has the new isolation\n      Note, that in case of:\n      COMMIT;\n      SET TRANSACTION ISOLATION LEVEL ...\n      SET SESSION ISOLATION LEVEL ...\n      BEGIN; <-- the session isolation level is used, not the\n      result of SET TRANSACTION statement.\n     */\n    thd->tx_isolation= (enum_tx_isolation) var->save_result.ulonglong_value;\n  }\n  return FALSE;\n}\n\n\n// NO_CMD_LINE - different name of the option\nstatic Sys_var_tx_isolation Sys_tx_isolation(\n       \"tx_isolation\", \"Default transaction isolation level\",\n       SESSION_VAR(tx_isolation), NO_CMD_LINE,\n       tx_isolation_names, DEFAULT(ISO_REPEATABLE_READ),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_tx_isolation));\n\nstatic Sys_var_ulonglong Sys_tmp_table_size(\n       \"tmp_table_size\",\n       \"If an internal in-memory temporary table exceeds this size, MySQL \"\n       \"will automatically convert it to an on-disk MyISAM table\",\n       SESSION_VAR(tmp_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_timed_mutexes(\n       \"timed_mutexes\",\n       \"Specify whether to time mutexes. Deprecated, has no effect.\",\n       GLOBAL_VAR(timed_mutexes), CMD_LINE(OPT_ARG), DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL),\n       DEPRECATED(\"\"));\n\nstatic char *server_version_ptr;\nstatic Sys_var_charptr Sys_version(\n       \"version\", \"Server version\",\n       READ_ONLY GLOBAL_VAR(server_version_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(server_version));\n\nstatic char *server_version_comment_ptr;\nstatic Sys_var_charptr Sys_version_comment(\n       \"version_comment\", \"version_comment\",\n       READ_ONLY GLOBAL_VAR(server_version_comment_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(MYSQL_COMPILATION_COMMENT));\n\nstatic char *server_version_compile_machine_ptr;\nstatic Sys_var_charptr Sys_version_compile_machine(\n       \"version_compile_machine\", \"version_compile_machine\",\n       READ_ONLY GLOBAL_VAR(server_version_compile_machine_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(MACHINE_TYPE));\n\nstatic char *server_version_compile_os_ptr;\nstatic Sys_var_charptr Sys_version_compile_os(\n       \"version_compile_os\", \"version_compile_os\",\n       READ_ONLY GLOBAL_VAR(server_version_compile_os_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(SYSTEM_TYPE));\n\nstatic Sys_var_ulong Sys_net_wait_timeout(\n       \"wait_timeout\",\n       \"The number of seconds the server waits for activity on a \"\n       \"connection before closing it\",\n       SESSION_VAR(net_wait_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, IF_WIN(INT_MAX32/1000, LONG_TIMEOUT)),\n       DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\n/** propagates changes to the relevant flag of @@optimizer_switch */\nstatic bool fix_engine_condition_pushdown(sys_var *self, THD *thd,\n                                          enum_var_type type)\n{\n  SV *sv= (type == OPT_GLOBAL) ? &global_system_variables : &thd->variables;\n  if (sv->engine_condition_pushdown)\n    sv->optimizer_switch|= OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN;\n  else\n    sv->optimizer_switch&= ~OPTIMIZER_SWITCH_ENGINE_CONDITION_PUSHDOWN;\n  return false;\n}\nstatic Sys_var_mybool Sys_engine_condition_pushdown(\n       \"engine_condition_pushdown\",\n       \"Push supported query conditions to the storage engine.\"\n       \" Deprecated, use --optimizer-switch instead.\",\n       SESSION_VAR(engine_condition_pushdown),\n       CMD_LINE(OPT_ARG, OPT_ENGINE_CONDITION_PUSHDOWN),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL),\n       ON_UPDATE(fix_engine_condition_pushdown),\n       DEPRECATED(\"'@@optimizer_switch'\"));\n\nstatic Sys_var_plugin Sys_default_storage_engine(\n       \"default_storage_engine\", \"The default storage engine for new tables\",\n       SESSION_VAR(table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_storage_engine),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_not_null));\n\n//  Alias for @@default_storage_engine\nstatic Sys_var_plugin Sys_storage_engine(\n       \"storage_engine\", \"Alias for @@default_storage_engine. Deprecated\",\n       SESSION_VAR(table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_storage_engine),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_not_null));\n\n#if defined(ENABLED_DEBUG_SYNC)\n/*\n  Variable can be set for the session only.\n\n  This could be changed later. Then we need to have a global array of\n  actions in addition to the thread local ones. SET GLOBAL would\n  manage the global array, SET [SESSION] the local array. A sync point\n  would need to look for a local and a global action. Setting and\n  executing of global actions need to be protected by a mutex.\n\n  The purpose of global actions could be to allow synchronizing with\n  connectionless threads that cannot execute SET statements.\n*/\nstatic Sys_var_debug_sync Sys_debug_sync(\n       \"debug_sync\", \"Debug Sync Facility\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n/**\n \"time_format\" \"date_format\" \"datetime_format\"\n\n  the following three variables are unused, and the source of confusion\n  (bug reports like \"I've changed date_format, but date format hasn't changed.\n  I've made them read-only, to alleviate the situation somewhat.\n\n  @todo make them NO_CMD_LINE ?\n*/\nstatic Sys_var_charptr Sys_date_format(\n       \"date_format\", \"The DATE format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_date_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].date_format));\n\nstatic Sys_var_charptr Sys_datetime_format(\n       \"datetime_format\", \"The DATETIME format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_datetime_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].datetime_format));\n\nstatic Sys_var_charptr Sys_time_format(\n       \"time_format\", \"The TIME format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_time_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].time_format));\n\nstatic bool fix_autocommit(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_GLOBAL)\n  {\n    if (global_system_variables.option_bits & OPTION_AUTOCOMMIT)\n      global_system_variables.option_bits&= ~OPTION_NOT_AUTOCOMMIT;\n    else\n      global_system_variables.option_bits|= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  if (thd->variables.option_bits & OPTION_AUTOCOMMIT &&\n      thd->variables.option_bits & OPTION_NOT_AUTOCOMMIT)\n  { // activating autocommit\n\n    if (trans_commit_stmt(thd) || trans_commit(thd))\n    {\n      thd->variables.option_bits&= ~OPTION_AUTOCOMMIT;\n      return true;\n    }\n    /*\n      Don't close thread tables or release metadata locks: if we do so, we\n      risk releasing locks/closing tables of expressions used to assign\n      other variables, as in:\n      set @var=my_stored_function1(), @@autocommit=1, @var2=(select max(a)\n      from my_table), ...\n      The locks will be released at statement end anyway, as SET\n      statement that assigns autocommit is marked to commit\n      transaction implicitly at the end (@sa stmt_causes_implicitcommit()).\n    */\n    thd->variables.option_bits&=\n                 ~(OPTION_BEGIN | OPTION_KEEP_LOG | OPTION_NOT_AUTOCOMMIT);\n    thd->transaction.all.modified_non_trans_table= false;\n    thd->server_status|= SERVER_STATUS_AUTOCOMMIT;\n    return false;\n  }\n\n  if (!(thd->variables.option_bits & OPTION_AUTOCOMMIT) &&\n      !(thd->variables.option_bits & OPTION_NOT_AUTOCOMMIT))\n  { // disabling autocommit\n\n    thd->transaction.all.modified_non_trans_table= false;\n    thd->server_status&= ~SERVER_STATUS_AUTOCOMMIT;\n    thd->variables.option_bits|= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  return false; // autocommit value wasn't changed\n}\nstatic Sys_var_bit Sys_autocommit(\n       \"autocommit\", \"autocommit\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_AUTOCOMMIT, DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_autocommit));\nexport sys_var *Sys_autocommit_ptr= &Sys_autocommit; // for sql_yacc.yy\n\nstatic Sys_var_mybool Sys_big_tables(\n       \"big_tables\", \"Allow big result sets by saving all \"\n       \"temporary sets on file (Solves most 'table full' errors)\",\n       SESSION_VAR(big_tables), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\n#ifndef TO_BE_DELETED   /* Alias for big_tables */\nstatic Sys_var_mybool Sys_sql_big_tables(\n       \"sql_big_tables\", \"alias for big_tables\",\n       SESSION_VAR(big_tables), NO_CMD_LINE, DEFAULT(FALSE));\n#endif\n\nstatic Sys_var_bit Sys_big_selects(\n       \"sql_big_selects\", \"sql_big_selects\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_BIG_SELECTS,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_log_off(\n       \"sql_log_off\", \"sql_log_off\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_LOG_OFF,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n\n/**\n  This function sets the session variable thd->variables.sql_log_bin \n  to reflect changes to @@session.sql_log_bin.\n\n  @param[IN] self   A pointer to the sys_var, i.e. Sys_log_binlog.\n  @param[IN] type   The type either session or global.\n\n  @return @c FALSE.\n*/\nstatic bool fix_sql_log_bin_after_update(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  DBUG_ASSERT(type == OPT_SESSION);\n\n  if (thd->variables.sql_log_bin)\n    thd->variables.option_bits |= OPTION_BIN_LOG;\n  else\n    thd->variables.option_bits &= ~OPTION_BIN_LOG;\n\n  return FALSE;\n}\n\n/**\n  This function checks if the sql_log_bin can be changed,\n  what is possible if:\n    - the user is a super user;\n    - the set is not called from within a function/trigger;\n    - there is no on-going transaction.\n\n  @param[IN] self   A pointer to the sys_var, i.e. Sys_log_binlog.\n  @param[IN] var    A pointer to the set_var created by the parser.\n\n  @return @c FALSE if the change is allowed, otherwise @c TRUE.\n*/\nstatic bool check_sql_log_bin(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return TRUE;\n\n  if (var->type == OPT_GLOBAL)\n    return TRUE;\n\n  /* If in a stored function/trigger, it's too late to change sql_log_bin. */\n  if (thd->in_sub_stmt)\n  {\n    my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN, MYF(0));\n    return TRUE;\n  }\n  /* Make the session variable 'sql_log_bin' read-only inside a transaction. */\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN, MYF(0));\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nstatic Sys_var_mybool Sys_log_binlog(\n       \"sql_log_bin\", \"Controls whether logging to the binary log is done\",\n       SESSION_VAR(sql_log_bin), NO_CMD_LINE, DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_sql_log_bin),\n       ON_UPDATE(fix_sql_log_bin_after_update));\n\nstatic Sys_var_bit Sys_sql_warnings(\n       \"sql_warnings\", \"sql_warnings\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_WARNINGS,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_sql_notes(\n       \"sql_notes\", \"sql_notes\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_SQL_NOTES,\n       DEFAULT(TRUE));\n\nstatic Sys_var_bit Sys_auto_is_null(\n       \"sql_auto_is_null\", \"sql_auto_is_null\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_AUTO_IS_NULL,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_safe_updates(\n       \"sql_safe_updates\", \"sql_safe_updates\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_SAFE_UPDATES,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_buffer_results(\n       \"sql_buffer_result\", \"sql_buffer_result\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_BUFFER_RESULT,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_quote_show_create(\n       \"sql_quote_show_create\", \"sql_quote_show_create\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_QUOTE_SHOW_CREATE,\n       DEFAULT(TRUE));\n\nstatic Sys_var_bit Sys_foreign_key_checks(\n       \"foreign_key_checks\", \"foreign_key_checks\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_NO_FOREIGN_KEY_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_unique_checks(\n       \"unique_checks\", \"unique_checks\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_RELAXED_UNIQUE_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\n#ifdef ENABLED_PROFILING\nstatic Sys_var_bit Sys_profiling(\n       \"profiling\", \"profiling\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_PROFILING,\n       DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_profiling_history_size(\n       \"profiling_history_size\", \"Limit of query profiling memory\",\n       SESSION_VAR(profiling_history_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 100), DEFAULT(15), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_harows Sys_select_limit(\n       \"sql_select_limit\",\n       \"The maximum number of rows to return from SELECT statements\",\n       SESSION_VAR(select_limit), NO_CMD_LINE,\n       VALID_RANGE(0, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1));\n\nstatic bool update_timestamp(THD *thd, set_var *var)\n{\n  if (var->value)\n    thd->set_time((time_t) var->save_result.ulonglong_value);\n  else // SET timestamp=DEFAULT\n    thd->user_time= 0;\n  return false;\n}\nstatic ulonglong read_timestamp(THD *thd)\n{\n  return (ulonglong) thd->start_time;\n}\n\n\nstatic bool check_timestamp(sys_var *self, THD *thd, set_var *var)\n{\n  longlong val;\n\n  if (!var->value)\n    return FALSE;\n\n  val= (longlong) var->save_result.ulonglong_value;\n  if (val != 0 &&          // this is how you set the default value\n      (val < TIMESTAMP_MIN_VALUE || val > TIMESTAMP_MAX_VALUE))\n  {\n    char buf[64];\n    my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), \"timestamp\", llstr(val, buf));\n    return TRUE;\n  }\n  return FALSE;\n}\n\n\nstatic Sys_var_session_special Sys_timestamp(\n       \"timestamp\", \"Set the time for this client\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ~(time_t)0), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_timestamp), \n       ON_UPDATE(update_timestamp), ON_READ(read_timestamp));\n\nstatic bool update_last_insert_id(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->first_successful_insert_id_in_prev_stmt=\n    var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_last_insert_id(THD *thd)\n{\n  return (ulonglong) thd->read_first_successful_insert_id_in_prev_stmt();\n}\nstatic Sys_var_session_special Sys_last_insert_id(\n       \"last_insert_id\", \"The value to be returned from LAST_INSERT_ID()\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n// alias for last_insert_id(), Sybase-style\nstatic Sys_var_session_special Sys_identity(\n       \"identity\", \"Synonym for the last_insert_id variable\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n/*\n  insert_id should *not* be marked as written to the binlog (i.e., it\n  should *not* be IN_BINLOG), because we want any statement that\n  refers to insert_id explicitly to be unsafe.  (By \"explicitly\", we\n  mean using @@session.insert_id, whereas insert_id is used\n  \"implicitly\" when NULL value is inserted into an auto_increment\n  column).\n\n  We want statements referring explicitly to @@session.insert_id to be\n  unsafe, because insert_id is modified internally by the slave sql\n  thread when NULL values are inserted in an AUTO_INCREMENT column.\n  This modification interfers with the value of the\n  @@session.insert_id variable if @@session.insert_id is referred\n  explicitly by an insert statement (as is seen by executing \"SET\n  @@session.insert_id=0; CREATE TABLE t (a INT, b INT KEY\n  AUTO_INCREMENT); INSERT INTO t(a) VALUES (@@session.insert_id);\" in\n  statement-based logging mode: t will be different on master and\n  slave).\n*/\nstatic bool update_insert_id(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->force_one_auto_inc_interval(var->save_result.ulonglong_value);\n  return false;\n}\n\nstatic ulonglong read_insert_id(THD *thd)\n{\n  return thd->auto_inc_intervals_forced.minimum();\n}\nstatic Sys_var_session_special Sys_insert_id(\n       \"insert_id\", \"The value to be used by the following INSERT \"\n       \"or ALTER TABLE statement when inserting an AUTO_INCREMENT value\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_insert_id), ON_READ(read_insert_id));\n\nstatic bool update_rand_seed1(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed1= (ulong) var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_rand_seed(THD *thd)\n{\n  return 0;\n}\nstatic Sys_var_session_special Sys_rand_seed1(\n       \"rand_seed1\", \"Sets the internal state of the RAND() \"\n       \"generator for replication purposes\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_rand_seed1), ON_READ(read_rand_seed));\n\nstatic bool update_rand_seed2(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed2= (ulong) var->save_result.ulonglong_value;\n  return false;\n}\nstatic Sys_var_session_special Sys_rand_seed2(\n       \"rand_seed2\", \"Sets the internal state of the RAND() \"\n       \"generator for replication purposes\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_rand_seed2), ON_READ(read_rand_seed));\n\nstatic ulonglong read_error_count(THD *thd)\n{\n  return thd->warning_info->error_count();\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_error_count(\n       \"error_count\", \"The number of errors that resulted from the \"\n       \"last statement that generated messages\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(read_error_count));\n\nstatic ulonglong read_warning_count(THD *thd)\n{\n  return thd->warning_info->warn_count();\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_warning_count(\n       \"warning_count\", \"The number of errors, warnings, and notes \"\n       \"that resulted from the last statement that generated messages\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(read_warning_count));\n\nstatic Sys_var_ulong Sys_default_week_format(\n       \"default_week_format\",\n       \"The default week format used by WEEK() functions\",\n       SESSION_VAR(default_week_format), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 7), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_group_concat_max_len(\n       \"group_concat_max_len\",\n       \"The maximum length of the result of function  GROUP_CONCAT()\",\n       SESSION_VAR(group_concat_max_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, ULONG_MAX), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic char *glob_hostname_ptr;\nstatic Sys_var_charptr Sys_hostname(\n       \"hostname\", \"Server host name\",\n       READ_ONLY GLOBAL_VAR(glob_hostname_ptr), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(glob_hostname));\n\n#ifndef EMBEDDED_LIBRARY\nstatic Sys_var_charptr Sys_repl_report_host(\n       \"report_host\",\n       \"Hostname or IP of the slave to be reported to the master during \"\n       \"slave registration. Will appear in the output of SHOW SLAVE HOSTS. \"\n       \"Leave unset if you do not want the slave to register itself with the \"\n       \"master. Note that it is not sufficient for the master to simply read \"\n       \"the IP of the slave off the socket once the slave connects. Due to \"\n       \"NAT and other routing issues, that IP may not be valid for connecting \"\n       \"to the slave from the master or other hosts\",\n       READ_ONLY GLOBAL_VAR(report_host), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_repl_report_user(\n       \"report_user\",\n       \"The account user name of the slave to be reported to the master \"\n       \"during slave registration\",\n       READ_ONLY GLOBAL_VAR(report_user), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_repl_report_password(\n       \"report_password\",\n       \"The account password of the slave to be reported to the master \"\n       \"during slave registration\",\n       READ_ONLY GLOBAL_VAR(report_password), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_repl_report_port(\n       \"report_port\",\n       \"Port for connecting to slave reported to the master during slave \"\n       \"registration. Set it only if the slave is listening on a non-default \"\n       \"port or if you have a special tunnel from the master or other clients \"\n       \"to the slave. If not sure, leave this option unset\",\n       READ_ONLY GLOBAL_VAR(report_port), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_mybool Sys_keep_files_on_create(\n       \"keep_files_on_create\",\n       \"Don't overwrite stale .MYD and .MYI even if no directory is specified\",\n       SESSION_VAR(keep_files_on_create), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic char *license;\nstatic Sys_var_charptr Sys_license(\n       \"license\", \"The type of license the server has\",\n       READ_ONLY GLOBAL_VAR(license), NO_CMD_LINE, IN_SYSTEM_CHARSET,\n       DEFAULT(STRINGIFY_ARG(LICENSE)));\n\nstatic bool check_log_path(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false; // DEFAULT is ok\n\n  if (!var->save_result.string_value.str)\n    return true;\n\n  if (!is_valid_log_name(var->save_result.string_value.str,\n                         var->save_result.string_value.length))\n  {\n    my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0),\n             self->name.str, var->save_result.string_value.str);\n    return true;\n  }\n\n  if (var->save_result.string_value.length > FN_REFLEN)\n  { // path is too long\n    my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n    return true;\n  }\n\n  char path[FN_REFLEN];\n  size_t path_length= unpack_filename(path, var->save_result.string_value.str);\n\n  if (!path_length)\n    return true;\n\n  if (!is_filename_allowed(var->save_result.string_value.str, \n                           var->save_result.string_value.length))\n  {\n     my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), \n              self->name.str, var->save_result.string_value.str);\n     return true;\n  }\n\n  MY_STAT f_stat;\n\n  if (my_stat(path, &f_stat, MYF(0)))\n  {\n    if (!MY_S_ISREG(f_stat.st_mode) || !(f_stat.st_mode & MY_S_IWRITE))\n      return true; // not a regular writable file\n    return false;\n  }\n\n  (void) dirname_part(path, var->save_result.string_value.str, &path_length);\n\n  if (var->save_result.string_value.length - path_length >= FN_LEN)\n  { // filename is too long\n      my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n      return true;\n  }\n\n  if (!path_length) // no path is good path (remember, relative to datadir)\n    return false;\n\n  if (my_access(path, (F_OK|W_OK)))\n    return true; // directory is not writable\n\n  return false;\n}\nstatic bool fix_log(char** logname, const char* default_logname,\n                    const char*ext, bool enabled, bool (*reopen)(char*))\n{\n  if (!*logname) // SET ... = DEFAULT\n  {\n    char buff[FN_REFLEN];\n    *logname= my_strdup(make_log_name(buff, default_logname, ext),\n                        MYF(MY_FAE+MY_WME));\n    if (!*logname)\n      return true;\n  }\n  logger.lock_exclusive();\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  bool error= false;\n  if (enabled)\n    error= reopen(*logname);\n  logger.unlock();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return error;\n}\nstatic bool reopen_general_log(char* name)\n{\n  logger.get_log_file_handler()->close(0);\n  return logger.get_log_file_handler()->open_query_log(name);\n}\nstatic bool fix_general_log_file(sys_var *self, THD *thd, enum_var_type type)\n{\n  return fix_log(&opt_logname, default_logfile_name, \".log\", opt_log,\n                 reopen_general_log);\n}\nstatic Sys_var_charptr Sys_general_log_path(\n       \"general_log_file\", \"Log connections and queries to given file\",\n       PREALLOCATED GLOBAL_VAR(opt_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_log_path), ON_UPDATE(fix_general_log_file));\n\nstatic bool reopen_slow_log(char* name)\n{\n  logger.get_slow_log_file_handler()->close(0);\n  return logger.get_slow_log_file_handler()->open_slow_log(name);\n}\nstatic bool fix_slow_log_file(sys_var *self, THD *thd, enum_var_type type)\n{\n  return fix_log(&opt_slow_logname, default_logfile_name, \"-slow.log\",\n                 opt_slow_log, reopen_slow_log);\n}\nstatic Sys_var_charptr Sys_slow_log_path(\n       \"slow_query_log_file\", \"Log slow queries to given log file. \"\n       \"Defaults logging to hostname-slow.log. Must be enabled to activate \"\n       \"other slow log options\",\n       PREALLOCATED GLOBAL_VAR(opt_slow_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_log_path), ON_UPDATE(fix_slow_log_file));\n\n/// @todo deprecate these four legacy have_PLUGIN variables and use I_S instead\nexport SHOW_COMP_OPTION have_csv, have_innodb= SHOW_OPTION_DISABLED;\nexport SHOW_COMP_OPTION have_ndbcluster, have_partitioning;\nstatic Sys_var_have Sys_have_csv(\n       \"have_csv\", \"have_csv\",\n       READ_ONLY GLOBAL_VAR(have_csv), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_innodb(\n       \"have_innodb\", \"have_innodb\",\n       READ_ONLY GLOBAL_VAR(have_innodb), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_ndbcluster(\n       \"have_ndbcluster\", \"have_ndbcluster\",\n       READ_ONLY GLOBAL_VAR(have_ndbcluster), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_partition_db(\n       \"have_partitioning\", \"have_partitioning\",\n       READ_ONLY GLOBAL_VAR(have_partitioning), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_compress(\n       \"have_compress\", \"have_compress\",\n       READ_ONLY GLOBAL_VAR(have_compress), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_crypt(\n       \"have_crypt\", \"have_crypt\",\n       READ_ONLY GLOBAL_VAR(have_crypt), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_dlopen(\n       \"have_dynamic_loading\", \"have_dynamic_loading\",\n       READ_ONLY GLOBAL_VAR(have_dlopen), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_geometry(\n       \"have_geometry\", \"have_geometry\",\n       READ_ONLY GLOBAL_VAR(have_geometry), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_openssl(\n       \"have_openssl\", \"have_openssl\",\n       READ_ONLY GLOBAL_VAR(have_ssl), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_profiling(\n       \"have_profiling\", \"have_profiling\",\n       READ_ONLY GLOBAL_VAR(have_profiling), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_query_cache(\n       \"have_query_cache\", \"have_query_cache\",\n       READ_ONLY GLOBAL_VAR(have_query_cache), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_rtree_keys(\n       \"have_rtree_keys\", \"have_rtree_keys\",\n       READ_ONLY GLOBAL_VAR(have_rtree_keys), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_ssl(\n       \"have_ssl\", \"have_ssl\",\n       READ_ONLY GLOBAL_VAR(have_ssl), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_symlink(\n       \"have_symlink\", \"have_symlink\",\n       READ_ONLY GLOBAL_VAR(have_symlink), NO_CMD_LINE);\n\nstatic bool fix_log_state(sys_var *self, THD *thd, enum_var_type type);\nstatic Sys_var_mybool Sys_general_log(\n       \"general_log\", \"Log connections and queries to a table or log file. \"\n       \"Defaults logging to a file hostname.log or a table mysql.general_log\"\n       \"if --log-output=TABLE is used\",\n       GLOBAL_VAR(opt_log), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_log_state));\n\n// Synonym of \"general_log\" for consistency with SHOW VARIABLES output\nstatic Sys_var_mybool Sys_log(\n       \"log\", \"Alias for --general-log. Deprecated\",\n       GLOBAL_VAR(opt_log), NO_CMD_LINE,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_log_state), DEPRECATED(\"'@@general_log'\"));\n\nstatic Sys_var_mybool Sys_slow_query_log(\n       \"slow_query_log\",\n       \"Log slow queries to a table or log file. Defaults logging to a file \"\n       \"hostname-slow.log or a table mysql.slow_log if --log-output=TABLE is \"\n       \"used. Must be enabled to activate other slow log options\",\n       GLOBAL_VAR(opt_slow_log), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_log_state));\n\n/* Synonym of \"slow_query_log\" for consistency with SHOW VARIABLES output */\nstatic Sys_var_mybool Sys_log_slow(\n       \"log_slow_queries\",\n       \"Alias for --slow-query-log. Deprecated\",\n       GLOBAL_VAR(opt_slow_log), NO_CMD_LINE,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_log_state), DEPRECATED(\"'@@slow_query_log'\"));\n\nstatic bool fix_log_state(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool res;\n  my_bool *UNINIT_VAR(newvalptr), newval, UNINIT_VAR(oldval);\n  uint UNINIT_VAR(log_type);\n\n  if (self == &Sys_general_log || self == &Sys_log)\n  {\n    newvalptr= &opt_log;\n    oldval=    logger.get_log_file_handler()->is_open();\n    log_type=  QUERY_LOG_GENERAL;\n  }\n  else if (self == &Sys_slow_query_log || self == &Sys_log_slow)\n  {\n    newvalptr= &opt_slow_log;\n    oldval=    logger.get_slow_log_file_handler()->is_open();\n    log_type=  QUERY_LOG_SLOW;\n  }\n  else\n    DBUG_ASSERT(FALSE);\n\n  newval= *newvalptr;\n  if (oldval == newval)\n    return false;\n\n  *newvalptr= oldval; // [de]activate_log_handler works that way (sigh)\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  if (!newval)\n  {\n    logger.deactivate_log_handler(thd, log_type);\n    res= false;\n  }\n  else\n    res= logger.activate_log_handler(thd, log_type);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return res;\n}\n\nstatic bool check_not_empty_set(sys_var *self, THD *thd, set_var *var)\n{\n  return var->save_result.ulonglong_value == 0;\n}\nstatic bool fix_log_output(sys_var *self, THD *thd, enum_var_type type)\n{\n  logger.lock_exclusive();\n  logger.init_slow_log(log_output_options);\n  logger.init_general_log(log_output_options);\n  logger.unlock();\n  return false;\n}\n\nstatic const char *log_output_names[] = { \"NONE\", \"FILE\", \"TABLE\", NULL};\n\nstatic Sys_var_set Sys_log_output(\n       \"log_output\", \"Syntax: log-output=value[,value...], \"\n       \"where \\\"value\\\" could be TABLE, FILE or NONE\",\n       GLOBAL_VAR(log_output_options), CMD_LINE(REQUIRED_ARG),\n       log_output_names, DEFAULT(LOG_FILE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_not_empty_set), ON_UPDATE(fix_log_output));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_mybool Sys_log_slave_updates(\n       \"log_slave_updates\", \"Tells the slave to log the updates from \"\n       \"the slave thread to the binary log. You will need to turn it on if \"\n       \"you plan to daisy-chain the slaves\",\n       READ_ONLY GLOBAL_VAR(opt_log_slave_updates), CMD_LINE(OPT_ARG),\n       DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log(\n       \"relay_log\", \"The location and name to use for relay logs\",\n       READ_ONLY GLOBAL_VAR(opt_relay_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log_index(\n       \"relay_log_index\", \"The location and name to use for the file \"\n       \"that keeps a list of the last relay logs\",\n       READ_ONLY GLOBAL_VAR(opt_relaylog_index_name), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log_info_file(\n       \"relay_log_info_file\", \"The location and name of the file that \"\n       \"remembers where the SQL replication thread is in the relay logs\",\n       READ_ONLY GLOBAL_VAR(relay_log_info_file), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_relay_log_purge(\n       \"relay_log_purge\", \"if disabled - do not purge relay logs. \"\n       \"if enabled - purge them as soon as they are no more needed\",\n       GLOBAL_VAR(relay_log_purge), CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_relay_log_recovery(\n       \"relay_log_recovery\", \"Enables automatic relay log recovery \"\n       \"right after the database startup, which means that the IO Thread \"\n       \"starts re-fetching from the master right after the last transaction \"\n       \"processed\",\n       GLOBAL_VAR(relay_log_recovery), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_slave_load_tmpdir(\n       \"slave_load_tmpdir\", \"The location where the slave should put \"\n       \"its temporary files when replicating a LOAD DATA INFILE command\",\n       READ_ONLY GLOBAL_VAR(slave_load_tmpdir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool fix_slave_net_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  mysql_mutex_lock(&LOCK_active_mi);\n  DBUG_PRINT(\"info\", (\"slave_net_timeout=%u mi->heartbeat_period=%.3f\",\n                     slave_net_timeout,\n                     (active_mi? active_mi->heartbeat_period : 0.0)));\n  if (active_mi && slave_net_timeout < active_mi->heartbeat_period)\n    push_warning_printf(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                        ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX,\n                        ER(ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX));\n  mysql_mutex_unlock(&LOCK_active_mi);\n  return false;\n}\nstatic Sys_var_uint Sys_slave_net_timeout(\n       \"slave_net_timeout\", \"Number of seconds to wait for more data \"\n       \"from a master/slave connection before aborting the read\",\n       GLOBAL_VAR(slave_net_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(SLAVE_NET_TIMEOUT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_slave_net_timeout));\n\nstatic bool check_slave_skip_counter(sys_var *self, THD *thd, set_var *var)\n{\n  bool result= false;\n  mysql_mutex_lock(&LOCK_active_mi);\n  mysql_mutex_lock(&active_mi->rli.run_lock);\n  if (active_mi->rli.slave_running)\n  {\n    my_message(ER_SLAVE_MUST_STOP, ER(ER_SLAVE_MUST_STOP), MYF(0));\n    result= true;\n  }\n  mysql_mutex_unlock(&active_mi->rli.run_lock);\n  mysql_mutex_unlock(&LOCK_active_mi);\n  return result;\n}\nstatic bool fix_slave_skip_counter(sys_var *self, THD *thd, enum_var_type type)\n{\n  mysql_mutex_lock(&LOCK_active_mi);\n  mysql_mutex_lock(&active_mi->rli.run_lock);\n  /*\n    The following test should normally never be true as we test this\n    in the check function;  To be safe against multiple\n    SQL_SLAVE_SKIP_COUNTER request, we do the check anyway\n  */\n  if (!active_mi->rli.slave_running)\n  {\n    mysql_mutex_lock(&active_mi->rli.data_lock);\n    active_mi->rli.slave_skip_counter= sql_slave_skip_counter;\n    mysql_mutex_unlock(&active_mi->rli.data_lock);\n  }\n  mysql_mutex_unlock(&active_mi->rli.run_lock);\n  mysql_mutex_unlock(&LOCK_active_mi);\n  return 0;\n}\nstatic Sys_var_uint Sys_slave_skip_counter(\n       \"sql_slave_skip_counter\", \"sql_slave_skip_counter\",\n       GLOBAL_VAR(sql_slave_skip_counter), NO_CMD_LINE,\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_slave_skip_counter),\n       ON_UPDATE(fix_slave_skip_counter));\n\nstatic Sys_var_charptr Sys_slave_skip_errors(\n       \"slave_skip_errors\", \"Tells the slave thread to continue \"\n       \"replication when a query event returns an error from the \"\n       \"provided list\",\n       READ_ONLY GLOBAL_VAR(opt_slave_skip_errors), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulonglong Sys_relay_log_space_limit(\n       \"relay_log_space_limit\", \"Maximum space to use for all relay logs\",\n       READ_ONLY GLOBAL_VAR(relay_log_space_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relaylog_period(\n       \"sync_relay_log\", \"Synchronously flush relay log to disk after \"\n       \"every #th event. Use 0 (default) to disable synchronous flushing\",\n       GLOBAL_VAR(sync_relaylog_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relayloginfo_period(\n       \"sync_relay_log_info\", \"Synchronously flush relay log info \"\n       \"to disk after every #th transaction. Use 0 (default) to disable \"\n       \"synchronous flushing\",\n       GLOBAL_VAR(sync_relayloginfo_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_uint Sys_sync_binlog_period(\n       \"sync_binlog\", \"Synchronously flush binary log to disk after \"\n       \"every #th event. Use 0 (default) to disable synchronous flushing\",\n       GLOBAL_VAR(sync_binlog_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_masterinfo_period(\n       \"sync_master_info\", \"Synchronously flush master info to disk \"\n       \"after every #th event. Use 0 (default) to disable synchronous flushing\",\n       GLOBAL_VAR(sync_masterinfo_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_ulong Sys_slave_trans_retries(\n       \"slave_transaction_retries\", \"Number of times the slave SQL \"\n       \"thread will retry a transaction in case it failed with a deadlock \"\n       \"or elapsed lock wait timeout, before giving up and stopping\",\n       GLOBAL_VAR(slave_trans_retries), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(10), BLOCK_SIZE(1));\n#endif\n\nstatic bool check_locale(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  MY_LOCALE *locale;\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == INT_RESULT)\n  {\n    int lcno= (int)var->value->val_int();\n    if (!(locale= my_locale_by_number(lcno)))\n    {\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), llstr(lcno, buff));\n      return true;\n    }\n    if (check_not_null(self, thd, var))\n      return true;\n  }\n  else // STRING_RESULT\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res=var->value->val_str(&str)))\n      return true;\n    else if (!(locale= my_locale_by_name(res->c_ptr_safe())))\n    {\n      ErrConvString err(res);\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), err.ptr());\n      return true;\n    }\n  }\n\n  var->save_result.ptr= locale;\n\n  if (!locale->errmsgs->errmsgs)\n  {\n    mysql_mutex_lock(&LOCK_error_messages);\n    if (!locale->errmsgs->errmsgs &&\n        read_texts(ERRMSG_FILE, locale->errmsgs->language,\n                   &locale->errmsgs->errmsgs,\n                   ER_ERROR_LAST - ER_ERROR_FIRST + 1))\n    {\n      push_warning_printf(thd, MYSQL_ERROR::WARN_LEVEL_WARN, ER_UNKNOWN_ERROR,\n                          \"Can't process error message file for locale '%s'\",\n                          locale->name);\n      mysql_mutex_unlock(&LOCK_error_messages);\n      return true;\n    }\n    mysql_mutex_unlock(&LOCK_error_messages);\n  }\n  return false;\n}\nstatic Sys_var_struct Sys_lc_messages(\n       \"lc_messages\", \"Set the language used for the error messages\",\n       SESSION_VAR(lc_messages), NO_CMD_LINE,\n       my_offsetof(MY_LOCALE, name), DEFAULT(&my_default_lc_messages),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_locale));\n\nstatic Sys_var_struct Sys_lc_time_names(\n       \"lc_time_names\", \"Set the language used for the month \"\n       \"names and the days of the week\",\n       SESSION_VAR(lc_time_names), NO_CMD_LINE,\n       my_offsetof(MY_LOCALE, name), DEFAULT(&my_default_lc_time_names),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_locale));\n\nstatic Sys_var_tz Sys_time_zone(\n       \"time_zone\", \"time_zone\",\n       SESSION_VAR(time_zone), NO_CMD_LINE,\n       DEFAULT(&default_tz), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_ulong Sys_sp_cache_size(\n       \"stored_program_cache\",\n       \"The soft upper limit for number of cached stored routines for \"\n       \"one connection.\",\n       GLOBAL_VAR(stored_program_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(256, 512 * 1024), DEFAULT(256), BLOCK_SIZE(1));\n\nstatic bool check_pseudo_slave_mode(sys_var *self, THD *thd, set_var *var)\n{\n  longlong previous_val= thd->variables.pseudo_slave_mode;\n  longlong val= (longlong) var->save_result.ulonglong_value;\n  bool rli_fake= false;\n\n#ifndef EMBEDDED_LIBRARY\n  rli_fake= thd->rli_fake ? true : false;\n#endif\n\n  if (rli_fake)\n  {\n    if (!val)\n    {\n#ifndef EMBEDDED_LIBRARY\n      delete thd->rli_fake;\n      thd->rli_fake= NULL;\n#endif\n    }\n    else if (previous_val && val)\n      goto ineffective;\n    else if (!previous_val && val)\n      push_warning(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                   ER_WRONG_VALUE_FOR_VAR,\n                   \"'pseudo_slave_mode' is already ON.\");\n  }\n  else\n  {\n    if (!previous_val && !val)\n      goto ineffective;\n    else if (previous_val && !val)\n      push_warning(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                   ER_WRONG_VALUE_FOR_VAR,\n                   \"Slave applier execution mode not active, \"\n                   \"statement ineffective.\");\n  }\n  goto end;\n\nineffective:\n  push_warning(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n               ER_WRONG_VALUE_FOR_VAR,\n               \"'pseudo_slave_mode' change was ineffective.\");\n\nend:\n  return FALSE;\n}\nstatic Sys_var_mybool Sys_pseudo_slave_mode(\n       \"pseudo_slave_mode\",\n       \"SET pseudo_slave_mode= 0,1 are commands that mysqlbinlog \"\n       \"adds to beginning and end of binary log dumps. While zero \"\n       \"value indeed disables, the actual enabling of the slave \"\n       \"applier execution mode is done implicitly when a \"\n       \"Format_description_event is sent through the session.\",\n       SESSION_ONLY(pseudo_slave_mode), NO_CMD_LINE, DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_pseudo_slave_mode));\n\n\n/****************************************************************************\n  Used templates\n****************************************************************************/\n\n#ifdef HAVE_EXPLICIT_TEMPLATE_INSTANTIATION\ntemplate class List<set_var_base>;\ntemplate class List_iterator_fast<set_var_base>;\ntemplate class Sys_var_unsigned<uint, GET_UINT, SHOW_INT>;\ntemplate class Sys_var_unsigned<ulong, GET_ULONG, SHOW_LONG>;\ntemplate class Sys_var_unsigned<ha_rows, GET_HA_ROWS, SHOW_HA_ROWS>;\ntemplate class Sys_var_unsigned<ulonglong, GET_ULL, SHOW_LONGLONG>;\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql/set_var.h": "#ifndef SET_VAR_INCLUDED\n#define SET_VAR_INCLUDED\n/* Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */\n\n/**\n  @file\n  \"public\" interface to sys_var - server configuration variables.\n*/\n\n#ifdef USE_PRAGMA_INTERFACE\n#pragma interface                       /* gcc class implementation */\n#endif\n\n#include <my_getopt.h>\n\nclass sys_var;\nclass set_var;\nclass sys_var_pluginvar;\nclass PolyLock;\nclass Item_func_set_user_var;\n\n// This include needs to be here since item.h requires enum_var_type :-P\n#include \"item.h\"                          /* Item */\n#include \"sql_class.h\"                     /* THD  */\n\nextern TYPELIB bool_typelib;\n\nstruct sys_var_chain\n{\n  sys_var *first;\n  sys_var *last;\n};\n\nint mysql_add_sys_var_chain(sys_var *chain);\nint mysql_del_sys_var_chain(sys_var *chain);\n\n/**\n  A class representing one system variable - that is something\n  that can be accessed as @@global.variable_name or @@session.variable_name,\n  visible in SHOW xxx VARIABLES and in INFORMATION_SCHEMA.xxx_VARIABLES,\n  optionally it can be assigned to, optionally it can have a command-line\n  counterpart with the same name.\n*/\nclass sys_var\n{\npublic:\n  sys_var *next;\n  LEX_CSTRING name;\n  enum flag_enum { GLOBAL, SESSION, ONLY_SESSION, SCOPE_MASK=1023,\n                   READONLY=1024, ALLOCATED=2048 };\n  static const int PARSE_EARLY= 1;\n  static const int PARSE_NORMAL= 2;\n  /**\n    Enumeration type to indicate for a system variable whether\n    it will be written to the binlog or not.\n  */    \n  enum binlog_status_enum { VARIABLE_NOT_IN_BINLOG,\n                            SESSION_VARIABLE_IN_BINLOG } binlog_status;\n\nprotected:\n  typedef bool (*on_check_function)(sys_var *self, THD *thd, set_var *var);\n  typedef bool (*on_update_function)(sys_var *self, THD *thd, enum_var_type type);\n\n  int flags;            ///< or'ed flag_enum values\n  int m_parse_flag;     ///< either PARSE_EARLY or PARSE_NORMAL.\n  const SHOW_TYPE show_val_type; ///< what value_ptr() returns for sql_show.cc\n  my_option option;     ///< min, max, default values are stored here\n  PolyLock *guard;      ///< *second* lock that protects the variable\n  ptrdiff_t offset;     ///< offset to the value from global_system_variables\n  on_check_function on_check;\n  on_update_function on_update;\n  const char *const deprecation_substitute;\n  bool is_os_charset; ///< true if the value is in character_set_filesystem\n\npublic:\n  sys_var(sys_var_chain *chain, const char *name_arg, const char *comment,\n          int flag_args, ptrdiff_t off, int getopt_id,\n          enum get_opt_arg_type getopt_arg_type, SHOW_TYPE show_val_type_arg,\n          longlong def_val, PolyLock *lock, enum binlog_status_enum binlog_status_arg,\n          on_check_function on_check_func, on_update_function on_update_func,\n          const char *substitute, int parse_flag);\n\n  virtual ~sys_var() {}\n\n  /**\n    All the cleanup procedures should be performed here\n  */\n  virtual void cleanup() {}\n  /**\n    downcast for sys_var_pluginvar. Returns this if it's an instance\n    of sys_var_pluginvar, and 0 otherwise.\n  */\n  virtual sys_var_pluginvar *cast_pluginvar() { return 0; }\n\n  bool check(THD *thd, set_var *var);\n  uchar *value_ptr(THD *thd, enum_var_type type, LEX_STRING *base);\n\n  /**\n     Update the system variable with the default value from either\n     session or global scope.  The default value is stored in the\n     'var' argument. Return false when successful.\n  */\n  bool set_default(THD *thd, set_var *var);\n  bool update(THD *thd, set_var *var);\n\n  SHOW_TYPE show_type() { return show_val_type; }\n  int scope() const { return flags & SCOPE_MASK; }\n  CHARSET_INFO *charset(THD *thd);\n  bool is_readonly() const { return flags & READONLY; }\n  /**\n    the following is only true for keycache variables,\n    that support the syntax @@keycache_name.variable_name\n  */\n  bool is_struct() { return option.var_type & GET_ASK_ADDR; }\n  bool is_written_to_binlog(enum_var_type type)\n  { return type != OPT_GLOBAL && binlog_status == SESSION_VARIABLE_IN_BINLOG; }\n  virtual bool check_update_type(Item_result type) = 0;\n  bool check_type(enum_var_type type)\n  {\n    switch (scope())\n    {\n    case GLOBAL:       return type != OPT_GLOBAL;\n    case SESSION:      return false; // always ok\n    case ONLY_SESSION: return type == OPT_GLOBAL;\n    }\n    return true; // keep gcc happy\n  }\n  bool register_option(DYNAMIC_ARRAY *array, int parse_flags)\n  {\n    return (option.id != -1) && (m_parse_flag & parse_flags) &&\n           insert_dynamic(array, (uchar*)&option);\n  }\n  void do_deprecated_warning(THD *thd);\n\nprivate:\n  virtual bool do_check(THD *thd, set_var *var) = 0;\n  /**\n    save the session default value of the variable in var\n  */\n  virtual void session_save_default(THD *thd, set_var *var) = 0;\n  /**\n    save the global default value of the variable in var\n  */\n  virtual void global_save_default(THD *thd, set_var *var) = 0;\n  virtual bool session_update(THD *thd, set_var *var) = 0;\n  virtual bool global_update(THD *thd, set_var *var) = 0;\n\nprotected:\n  /**\n    A pointer to a value of the variable for SHOW.\n    It must be of show_val_type type (bool for SHOW_BOOL, int for SHOW_INT,\n    longlong for SHOW_LONGLONG, etc).\n  */\n  virtual uchar *session_value_ptr(THD *thd, LEX_STRING *base);\n  virtual uchar *global_value_ptr(THD *thd, LEX_STRING *base);\n\n  /**\n    A pointer to a storage area of the variable, to the raw data.\n    Typically it's the same as session_value_ptr(), but it's different,\n    for example, for ENUM, that is printed as a string, but stored as a number.\n  */\n  uchar *session_var_ptr(THD *thd)\n  { return ((uchar*)&(thd->variables)) + offset; }\n\n  uchar *global_var_ptr()\n  { return ((uchar*)&global_system_variables) + offset; }\n};\n\n#include \"sql_plugin.h\"                    /* SHOW_HA_ROWS, SHOW_MY_BOOL */\n\n/****************************************************************************\n  Classes for parsing of the SET command\n****************************************************************************/\n\n/**\n  A base class for everything that can be set with SET command.\n  It's similar to Items, an instance of this is created by the parser\n  for every assigmnent in SET (or elsewhere, e.g. in SELECT).\n*/\nclass set_var_base :public Sql_alloc\n{\npublic:\n  set_var_base() {}\n  virtual ~set_var_base() {}\n  virtual int check(THD *thd)=0;           /* To check privileges etc. */\n  virtual int update(THD *thd)=0;                  /* To set the value */\n  virtual int light_check(THD *thd) { return check(thd); }   /* for PS */\n};\n\n\n/**\n  set_var_base descendant for assignments to the system variables.\n*/\nclass set_var :public set_var_base\n{\npublic:\n  sys_var *var; ///< system variable to be updated\n  Item *value;  ///< the expression that provides the new value of the variable\n  enum_var_type type;\n  union ///< temp storage to hold a value between sys_var::check and ::update\n  {\n    ulonglong ulonglong_value;          ///< for all integer, set, enum sysvars\n    double double_value;                ///< for Sys_var_double\n    plugin_ref plugin;                  ///< for Sys_var_plugin\n    Time_zone *time_zone;               ///< for Sys_var_tz\n    LEX_STRING string_value;            ///< for Sys_var_charptr and others\n    void *ptr;                          ///< for Sys_var_struct\n  } save_result;\n  LEX_STRING base; /**< for structured variables, like keycache_name.variable_name */\n\n  set_var(enum_var_type type_arg, sys_var *var_arg,\n          const LEX_STRING *base_name_arg, Item *value_arg)\n    :var(var_arg), type(type_arg), base(*base_name_arg)\n  {\n    /*\n      If the set value is a field, change it to a string to allow things like\n      SET table_type=MYISAM;\n    */\n    if (value_arg && value_arg->type() == Item::FIELD_ITEM)\n    {\n      Item_field *item= (Item_field*) value_arg;\n      if (item->field_name)\n      {\n        if (!(value= new Item_string(item->field_name,\n                                     (uint) strlen(item->field_name),\n                                     system_charset_info))) // names are utf8\n\t  value= value_arg;\t\t\t/* Give error message later */\n      }\n      else\n      {\n        /* Both Item_field and Item_insert_value will return the type as\n        Item::FIELD_ITEM. If the item->field_name is NULL, we assume the\n        object to be Item_insert_value. */\n        value= value_arg;\n      }\n    }\n    else\n      value= value_arg;\n  }\n  int check(THD *thd);\n  int update(THD *thd);\n  int light_check(THD *thd);\n};\n\n\n/* User variables like @my_own_variable */\nclass set_var_user: public set_var_base\n{\n  Item_func_set_user_var *user_var_item;\npublic:\n  set_var_user(Item_func_set_user_var *item)\n    :user_var_item(item)\n  {}\n  int check(THD *thd);\n  int update(THD *thd);\n  int light_check(THD *thd);\n};\n\n/* For SET PASSWORD */\n\nclass set_var_password: public set_var_base\n{\n  LEX_USER *user;\n  char *password;\npublic:\n  set_var_password(LEX_USER *user_arg,char *password_arg)\n    :user(user_arg), password(password_arg)\n  {}\n  int check(THD *thd);\n  int update(THD *thd);\n};\n\n\n/* For SET NAMES and SET CHARACTER SET */\n\nclass set_var_collation_client: public set_var_base\n{\n  CHARSET_INFO *character_set_client;\n  CHARSET_INFO *character_set_results;\n  CHARSET_INFO *collation_connection;\npublic:\n  set_var_collation_client(CHARSET_INFO *client_coll_arg,\n                           CHARSET_INFO *connection_coll_arg,\n                           CHARSET_INFO *result_coll_arg)\n    :character_set_client(client_coll_arg),\n     character_set_results(result_coll_arg),\n     collation_connection(connection_coll_arg)\n  {}\n  int check(THD *thd);\n  int update(THD *thd);\n};\n\n\n/* optional things, have_* variables */\nextern SHOW_COMP_OPTION have_csv, have_innodb;\nextern SHOW_COMP_OPTION have_ndbcluster, have_partitioning;\nextern SHOW_COMP_OPTION have_profiling;\n\nextern SHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen;\nextern SHOW_COMP_OPTION have_query_cache;\nextern SHOW_COMP_OPTION have_geometry, have_rtree_keys;\nextern SHOW_COMP_OPTION have_crypt;\nextern SHOW_COMP_OPTION have_compress;\n\n/*\n  Prototypes for helper functions\n*/\n\nSHOW_VAR* enumerate_sys_vars(THD *thd, bool sorted, enum enum_var_type type);\n\nsys_var *find_sys_var(THD *thd, const char *str, uint length=0);\nint sql_set_variables(THD *thd, List<set_var_base> *var_list);\n\nbool fix_delay_key_write(sys_var *self, THD *thd, enum_var_type type);\n\nulong expand_sql_mode(ulonglong sql_mode);\nbool sql_mode_string_representation(THD *thd, ulong sql_mode, LEX_STRING *ls);\n\nextern sys_var *Sys_autocommit_ptr;\n\nCHARSET_INFO *get_old_charset_by_name(const char *old_name);\n\nint sys_var_init();\nint sys_var_add_options(DYNAMIC_ARRAY *long_options, int parse_flags);\nvoid sys_var_end(void);\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql/sql_udf.cc": "/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/* This implements 'user defined functions' */\n\n/*\n   Known bugs:\n  \n   Memory for functions is never freed!\n   Shared libraries are not closed before mysqld exits;\n     - This is because we can't be sure if some threads are using\n       a function.\n  \n   The bugs only affect applications that create and free a lot of\n   dynamic functions, so this shouldn't be a real problem.\n*/\n\n#ifdef USE_PRAGMA_IMPLEMENTATION\n#pragma implementation\t\t\t\t// gcc: Class implementation\n#endif\n\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include \"sql_base.h\"                           // close_mysql_tables\n#include \"sql_parse.h\"                        // check_identifier_name\n#include \"sql_table.h\"                        // write_bin_log\n#include \"records.h\"          // init_read_record, end_read_record\n#include <my_pthread.h>\n#include \"lock.h\"                               // MYSQL_LOCK_IGNORE_TIMEOUT\n\n#ifdef HAVE_DLOPEN\nextern \"C\"\n{\n#include <stdarg.h>\n#include <hash.h>\n}\n\nstatic bool initialized = 0;\nstatic MEM_ROOT mem;\nstatic HASH udf_hash;\nstatic mysql_rwlock_t THR_LOCK_udf;\n\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret,\n                         char *dl, Item_udftype typ);\nstatic void del_udf(udf_func *udf);\nstatic void *find_udf_dl(const char *dl);\n\nstatic char *init_syms(udf_func *tmp, char *nm)\n{\n  char *end;\n\n  if (!((tmp->func= (Udf_func_any) dlsym(tmp->dlhandle, tmp->name.str))))\n    return tmp->name.str;\n\n  end=strmov(nm,tmp->name.str);\n\n  if (tmp->type == UDFTYPE_AGGREGATE)\n  {\n    (void)strmov(end, \"_clear\");\n    if (!((tmp->func_clear= (Udf_func_clear) dlsym(tmp->dlhandle, nm))))\n      return nm;\n    (void)strmov(end, \"_add\");\n    if (!((tmp->func_add= (Udf_func_add) dlsym(tmp->dlhandle, nm))))\n      return nm;\n  }\n\n  (void) strmov(end,\"_deinit\");\n  tmp->func_deinit= (Udf_func_deinit) dlsym(tmp->dlhandle, nm);\n\n  (void) strmov(end,\"_init\");\n  tmp->func_init= (Udf_func_init) dlsym(tmp->dlhandle, nm);\n\n  /*\n    to prefent loading \"udf\" from, e.g. libc.so\n    let's ensure that at least one auxiliary symbol is defined\n  */\n  if (!tmp->func_init && !tmp->func_deinit && tmp->type != UDFTYPE_AGGREGATE)\n  {\n    if (!opt_allow_suspicious_udfs)\n      return nm;\n    if (current_thd->variables.log_warnings)\n      sql_print_warning(ER(ER_CANT_FIND_DL_ENTRY), nm);\n  }\n  return 0;\n}\n\n\nextern \"C\" uchar* get_hash_key(const uchar *buff, size_t *length,\n\t\t\t      my_bool not_used __attribute__((unused)))\n{\n  udf_func *udf=(udf_func*) buff;\n  *length=(uint) udf->name.length;\n  return (uchar*) udf->name.str;\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_rwlock_key key_rwlock_THR_LOCK_udf;\n\nstatic PSI_rwlock_info all_udf_rwlocks[]=\n{\n  { &key_rwlock_THR_LOCK_udf, \"THR_LOCK_udf\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_udf_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_udf_rwlocks);\n  PSI_server->register_rwlock(category, all_udf_rwlocks, count);\n}\n#endif\n\n/*\n  Read all predeclared functions from mysql.func and accept all that\n  can be used.\n*/\n\nvoid udf_init()\n{\n  udf_func *tmp;\n  TABLE_LIST tables;\n  READ_RECORD read_record_info;\n  TABLE *table;\n  int error;\n  DBUG_ENTER(\"ufd_init\");\n  char db[]= \"mysql\"; /* A subject to casednstr, can't be constant */\n\n  if (initialized)\n    DBUG_VOID_RETURN;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_udf_psi_keys();\n#endif\n\n  mysql_rwlock_init(key_rwlock_THR_LOCK_udf, &THR_LOCK_udf);\n\n  init_sql_alloc(&mem, UDF_ALLOC_BLOCK_SIZE, 0);\n  THD *new_thd = new THD;\n  if (!new_thd ||\n      my_hash_init(&udf_hash,system_charset_info,32,0,0,get_hash_key, NULL, 0))\n  {\n    sql_print_error(\"Can't allocate memory for udf structures\");\n    my_hash_free(&udf_hash);\n    free_root(&mem,MYF(0));\n    delete new_thd;\n    DBUG_VOID_RETURN;\n  }\n  initialized = 1;\n  new_thd->thread_stack= (char*) &new_thd;\n  new_thd->store_globals();\n  new_thd->set_db(db, sizeof(db)-1);\n\n  tables.init_one_table(db, sizeof(db)-1, \"func\", 4, \"func\", TL_READ);\n\n  if (open_and_lock_tables(new_thd, &tables, FALSE, MYSQL_LOCK_IGNORE_TIMEOUT))\n  {\n    DBUG_PRINT(\"error\",(\"Can't open udf table\"));\n    sql_print_error(\"Can't open the mysql.func table. Please \"\n                    \"run mysql_upgrade to create it.\");\n    goto end;\n  }\n\n  table= tables.table;\n  init_read_record(&read_record_info, new_thd, table, NULL,1,0,FALSE);\n  table->use_all_columns();\n  while (!(error= read_record_info.read_record(&read_record_info)))\n  {\n    DBUG_PRINT(\"info\",(\"init udf record\"));\n    LEX_STRING name;\n    name.str=get_field(&mem, table->field[0]);\n    name.length = (uint) strlen(name.str);\n    char *dl_name= get_field(&mem, table->field[2]);\n    bool new_dl=0;\n    Item_udftype udftype=UDFTYPE_FUNCTION;\n    if (table->s->fields >= 4)\t\t\t// New func table\n      udftype=(Item_udftype) table->field[3]->val_int();\n\n    /*\n      Ensure that the .dll doesn't have a path\n      This is done to ensure that only approved dll from the system\n      directories are used (to make this even remotely secure).\n\n      On windows we must check both FN_LIBCHAR and '/'.\n    */\n    if (check_valid_path(dl_name, strlen(dl_name)) ||\n        check_string_char_length(&name, \"\", NAME_CHAR_LEN,\n                                 system_charset_info, 1))\n    {\n      sql_print_error(\"Invalid row in mysql.func table for function '%.64s'\",\n                      name.str);\n      continue;\n    }\n\n    if (!(tmp= add_udf(&name,(Item_result) table->field[1]->val_int(),\n                       dl_name, udftype)))\n    {\n      sql_print_error(\"Can't alloc memory for udf function: '%.64s'\", name.str);\n      continue;\n    }\n\n    void *dl = find_udf_dl(tmp->dl);\n    if (dl == NULL)\n    {\n      char dlpath[FN_REFLEN];\n      strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", tmp->dl,\n               NullS);\n      (void) unpack_filename(dlpath, dlpath);\n      if (!(dl= dlopen(dlpath, RTLD_NOW)))\n      {\n\tconst char *errmsg;\n\tint error_number= dlopen_errno;\n\tDLERROR_GENERATE(errmsg, error_number);\n\n\t/* Print warning to log */\n        sql_print_error(ER(ER_CANT_OPEN_LIBRARY), tmp->dl, error_number, errmsg);\n\t/* Keep the udf in the hash so that we can remove it later */\n\tcontinue;\n      }\n      new_dl=1;\n    }\n    tmp->dlhandle = dl;\n    {\n      char buf[NAME_LEN+16], *missing;\n      if ((missing= init_syms(tmp, buf)))\n      {\n        sql_print_error(ER(ER_CANT_FIND_DL_ENTRY), missing);\n        del_udf(tmp);\n        if (new_dl)\n          dlclose(dl);\n      }\n    }\n  }\n  if (error > 0)\n    sql_print_error(\"Got unknown error: %d\", my_errno);\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n\nend:\n  close_mysql_tables(new_thd);\n  delete new_thd;\n  /* Remember that we don't have a THD */\n  my_pthread_setspecific_ptr(THR_THD,  0);\n  DBUG_VOID_RETURN;\n}\n\n\nvoid udf_free()\n{\n  /* close all shared libraries */\n  DBUG_ENTER(\"udf_free\");\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (udf->dlhandle)\t\t\t\t// Not closed before\n    {\n      /* Mark all versions using the same handler as closed */\n      for (uint j=idx+1 ;  j < udf_hash.records ; j++)\n      {\n\tudf_func *tmp=(udf_func*) my_hash_element(&udf_hash,j);\n\tif (udf->dlhandle == tmp->dlhandle)\n\t  tmp->dlhandle=0;\t\t\t// Already closed\n      }\n      dlclose(udf->dlhandle);\n    }\n  }\n  my_hash_free(&udf_hash);\n  free_root(&mem,MYF(0));\n  if (initialized)\n  {\n    initialized= 0;\n    mysql_rwlock_destroy(&THR_LOCK_udf);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void del_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"del_udf\");\n  if (!--udf->usage_count)\n  {\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n  }\n  else\n  {\n    /*\n      The functions is in use ; Rename the functions instead of removing it.\n      The functions will be automaticly removed when the least threads\n      doesn't use it anymore\n    */\n    char *name= udf->name.str;\n    uint name_length=udf->name.length;\n    udf->name.str=(char*) \"*\";\n    udf->name.length=1;\n    my_hash_update(&udf_hash,(uchar*) udf,(uchar*) name,name_length);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nvoid free_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"free_udf\");\n  \n  if (!initialized)\n    DBUG_VOID_RETURN;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!--udf->usage_count)\n  {\n    /*\n      We come here when someone has deleted the udf function\n      while another thread still was using the udf\n    */\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n    if (!find_udf_dl(udf->dl))\n      dlclose(udf->dlhandle);\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_VOID_RETURN;\n}\n\n\n/* This is only called if using_udf_functions != 0 */\n\nudf_func *find_udf(const char *name,uint length,bool mark_used)\n{\n  udf_func *udf=0;\n  DBUG_ENTER(\"find_udf\");\n\n  if (!initialized)\n    DBUG_RETURN(NULL);\n\n  /* TODO: This should be changed to reader locks someday! */\n  if (mark_used)\n    mysql_rwlock_wrlock(&THR_LOCK_udf);  /* Called during fix_fields */\n  else\n    mysql_rwlock_rdlock(&THR_LOCK_udf);  /* Called during parsing */\n\n  if ((udf=(udf_func*) my_hash_search(&udf_hash,(uchar*) name,\n                                      length ? length : (uint) strlen(name))))\n  {\n    if (!udf->dlhandle)\n      udf=0;\t\t\t\t\t// Could not be opened\n    else if (mark_used)\n      udf->usage_count++;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(udf);\n}\n\n\nstatic void *find_udf_dl(const char *dl)\n{\n  DBUG_ENTER(\"find_udf_dl\");\n\n  /*\n    Because only the function name is hashed, we have to search trough\n    all rows to find the dl.\n  */\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (!strcmp(dl, udf->dl) && udf->dlhandle != NULL)\n      DBUG_RETURN(udf->dlhandle);\n  }\n  DBUG_RETURN(0);\n}\n\n\n/* Assume that name && dl is already allocated */\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret, char *dl,\n\t\t\t Item_udftype type)\n{\n  if (!name || !dl || !(uint) type || (uint) type > (uint) UDFTYPE_AGGREGATE)\n    return 0;\n  udf_func *tmp= (udf_func*) alloc_root(&mem, sizeof(udf_func));\n  if (!tmp)\n    return 0;\n  bzero((char*) tmp,sizeof(*tmp));\n  tmp->name = *name; //dup !!\n  tmp->dl = dl;\n  tmp->returns = ret;\n  tmp->type = type;\n  tmp->usage_count=1;\n  if (my_hash_insert(&udf_hash,(uchar*)  tmp))\n    return 0;\n  using_udf_functions=1;\n  return tmp;\n}\n\n\n/**\n  Create a user defined function. \n\n  @note Like implementations of other DDL/DML in MySQL, this function\n  relies on the caller to close the thread tables. This is done in the\n  end of dispatch_command().\n*/\n\nint mysql_create_function(THD *thd,udf_func *udf)\n{\n  int error;\n  void *dl=0;\n  bool new_dl=0;\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *u_d;\n  bool save_binlog_row_based;\n  DBUG_ENTER(\"mysql_create_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0),\n               udf->name.str,\n               \"UDFs are unavailable with the --skip-grant-tables option\");\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER(ER_OUT_OF_RESOURCES), MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  /*\n    Ensure that the .dll doesn't have a path\n    This is done to ensure that only approved dll from the system\n    directories are used (to make this even remotely secure).\n  */\n  if (check_valid_path(udf->dl, strlen(udf->dl)))\n  {\n    my_message(ER_UDF_NO_PATHS, ER(ER_UDF_NO_PATHS), MYF(0));\n    DBUG_RETURN(1);\n  }\n  if (check_string_char_length(&udf->name, \"\", NAME_CHAR_LEN,\n                               system_charset_info, 1))\n  {\n    my_error(ER_TOO_LONG_IDENT, MYF(0), udf->name.str);\n    DBUG_RETURN(1);\n  }\n\n  /* \n    Turn off row binlogging of this statement and use statement-based \n    so that all supporting tables are updated for CREATE FUNCTION command.\n  */\n  if ((save_binlog_row_based= thd->is_current_stmt_binlog_format_row()))\n    thd->clear_current_stmt_binlog_format_row();\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if ((my_hash_search(&udf_hash,(uchar*) udf->name.str, udf->name.length)))\n  {\n    my_error(ER_UDF_EXISTS, MYF(0), udf->name.str);\n    goto err;\n  }\n  if (!(dl = find_udf_dl(udf->dl)))\n  {\n    char dlpath[FN_REFLEN];\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", udf->dl, NullS);\n    (void) unpack_filename(dlpath, dlpath);\n\n    if (!(dl = dlopen(dlpath, RTLD_NOW)))\n    {\n      const char *errmsg;\n      int error_number= dlopen_errno;\n      DLERROR_GENERATE(errmsg, error_number);\n\n      DBUG_PRINT(\"error\",(\"dlopen of %s failed, error: %d (%s)\",\n                          udf->dl, error_number, errmsg));\n      my_error(ER_CANT_OPEN_LIBRARY, MYF(0),\n               udf->dl, error_number, errmsg);\n      goto err;\n    }\n    new_dl=1;\n  }\n  udf->dlhandle=dl;\n  {\n    char buf[NAME_LEN+16], *missing;\n    if ((missing= init_syms(udf, buf)))\n    {\n      my_error(ER_CANT_FIND_DL_ENTRY, MYF(0), missing);\n      goto err;\n    }\n  }\n  udf->name.str=strdup_root(&mem,udf->name.str);\n  udf->dl=strdup_root(&mem,udf->dl);\n  if (!(u_d=add_udf(&udf->name,udf->returns,udf->dl,udf->type)))\n    goto err;\n  u_d->dlhandle = dl;\n  u_d->func=udf->func;\n  u_d->func_init=udf->func_init;\n  u_d->func_deinit=udf->func_deinit;\n  u_d->func_clear=udf->func_clear;\n  u_d->func_add=udf->func_add;\n\n  /* create entry in mysql.func table */\n\n  tables.init_one_table(\"mysql\", 5, \"func\", 4, \"func\", TL_WRITE);\n  /* Allow creation of functions even if we can't open func table */\n  if (!(table = open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    goto err;\n  table->use_all_columns();\n  restore_record(table, s->default_values);\t// Default values for fields\n  table->field[0]->store(u_d->name.str, u_d->name.length, system_charset_info);\n  table->field[1]->store((longlong) u_d->returns, TRUE);\n  table->field[2]->store(u_d->dl,(uint) strlen(u_d->dl), system_charset_info);\n  if (table->s->fields >= 4)\t\t\t// If not old func format\n    table->field[3]->store((longlong) u_d->type, TRUE);\n  error = table->file->ha_write_row(table->record[0]);\n\n  if (error)\n  {\n    my_error(ER_ERROR_ON_WRITE, MYF(0), \"mysql.func\", error);\n    del_udf(u_d);\n    goto err;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  /* Binlog the create function. */\n  if (write_bin_log(thd, TRUE, thd->query(), thd->query_length()))\n  {\n    /* Restore the state of binlog format */\n    DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n    if (save_binlog_row_based)\n      thd->set_current_stmt_binlog_format_row();\n    DBUG_RETURN(1);\n  }\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(0);\n\n err:\n  if (new_dl)\n    dlclose(dl);\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(1);\n}\n\n\nint mysql_drop_function(THD *thd,const LEX_STRING *udf_name)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *udf;\n  char *exact_name_str;\n  uint exact_name_len;\n  bool save_binlog_row_based;\n  DBUG_ENTER(\"mysql_drop_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER(ER_OUT_OF_RESOURCES), MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  /* \n    Turn off row binlogging of this statement and use statement-based\n    so that all supporting tables are updated for DROP FUNCTION command.\n  */\n  if ((save_binlog_row_based= thd->is_current_stmt_binlog_format_row()))\n    thd->clear_current_stmt_binlog_format_row();\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!(udf=(udf_func*) my_hash_search(&udf_hash,(uchar*) udf_name->str,\n                                       (uint) udf_name->length)))\n  {\n    my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    goto err;\n  }\n  exact_name_str= udf->name.str;\n  exact_name_len= udf->name.length;\n  del_udf(udf);\n  /*\n    Close the handle if this was function that was found during boot or\n    CREATE FUNCTION and it's not in use by any other udf function\n  */\n  if (udf->dlhandle && !find_udf_dl(udf->dl))\n    dlclose(udf->dlhandle);\n\n  tables.init_one_table(\"mysql\", 5, \"func\", 4, \"func\", TL_WRITE);\n\n  if (!(table = open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    goto err;\n  table->use_all_columns();\n  table->field[0]->store(exact_name_str, exact_name_len, &my_charset_bin);\n  if (!table->file->index_read_idx_map(table->record[0], 0,\n                                       (uchar*) table->field[0]->ptr,\n                                       HA_WHOLE_KEY,\n                                       HA_READ_KEY_EXACT))\n  {\n    int error;\n    if ((error = table->file->ha_delete_row(table->record[0])))\n      table->file->print_error(error, MYF(0));\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  /*\n    Binlog the drop function. Keep the table open and locked\n    while binlogging, to avoid binlog inconsistency.\n  */\n  if (write_bin_log(thd, TRUE, thd->query(), thd->query_length()))\n  {\n    /* Restore the state of binlog format */\n    DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n    if (save_binlog_row_based)\n      thd->set_current_stmt_binlog_format_row();\n    DBUG_RETURN(1);\n  }\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(0);\nerr:\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  /* Restore the state of binlog format */\n  DBUG_ASSERT(!thd->is_current_stmt_binlog_format_row());\n  if (save_binlog_row_based)\n    thd->set_current_stmt_binlog_format_row();\n  DBUG_RETURN(1);\n}\n\n#endif /* HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql/sql_plugin.cc": "/*\n   Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */\n\n#include \"sql_priv.h\"                         // SHOW_MY_BOOL\n#include \"unireg.h\"\n#include \"my_global.h\"                       // REQUIRED by m_string.h\n#include \"sql_class.h\"                          // set_var.h: THD\n#include \"sys_vars_shared.h\"\n#include \"sql_locale.h\"\n#include \"sql_plugin.h\"\n#include \"sql_parse.h\"          // check_table_access\n#include \"sql_base.h\"                           // close_mysql_tables\n#include \"key.h\"                                // key_copy\n#include \"sql_show.h\"           // remove_status_vars, add_status_vars\n#include \"strfunc.h\"            // find_set\n#include \"sql_acl.h\"                       // *_ACL\n#include \"records.h\"          // init_read_record, end_read_record\n#include <my_pthread.h>\n#include <my_getopt.h>\n#include \"sql_audit.h\"\n#include <mysql/plugin_auth.h>\n#include \"lock.h\"                               // MYSQL_LOCK_IGNORE_TIMEOUT\n#include \"debug_sync.h\"\n#define REPORT_TO_LOG  1\n#define REPORT_TO_USER 2\n\nextern struct st_mysql_plugin *mysql_optional_plugins[];\nextern struct st_mysql_plugin *mysql_mandatory_plugins[];\n\n/**\n  @note The order of the enumeration is critical.\n  @see construct_options\n*/\nconst char *global_plugin_typelib_names[]=\n  { \"OFF\", \"ON\", \"FORCE\", \"FORCE_PLUS_PERMANENT\", NULL };\nstatic TYPELIB global_plugin_typelib=\n  { array_elements(global_plugin_typelib_names)-1,\n    \"\", global_plugin_typelib_names, NULL };\n\n\nchar *opt_plugin_load= NULL;\nchar *opt_plugin_dir_ptr;\nchar opt_plugin_dir[FN_REFLEN];\n/*\n  When you ad a new plugin type, add both a string and make sure that the\n  init and deinit array are correctly updated.\n*/\nconst LEX_STRING plugin_type_names[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  { C_STRING_WITH_LEN(\"UDF\") },\n  { C_STRING_WITH_LEN(\"STORAGE ENGINE\") },\n  { C_STRING_WITH_LEN(\"FTPARSER\") },\n  { C_STRING_WITH_LEN(\"DAEMON\") },\n  { C_STRING_WITH_LEN(\"INFORMATION SCHEMA\") },\n  { C_STRING_WITH_LEN(\"AUDIT\") },\n  { C_STRING_WITH_LEN(\"REPLICATION\") },\n  { C_STRING_WITH_LEN(\"AUTHENTICATION\") }\n};\n\nextern int initialize_schema_table(st_plugin_int *plugin);\nextern int finalize_schema_table(st_plugin_int *plugin);\n\nextern int initialize_audit_plugin(st_plugin_int *plugin);\nextern int finalize_audit_plugin(st_plugin_int *plugin);\n\n/*\n  The number of elements in both plugin_type_initialize and\n  plugin_type_deinitialize should equal to the number of plugins\n  defined.\n*/\nplugin_type_init plugin_type_initialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0,ha_initialize_handlerton,0,0,initialize_schema_table,\n  initialize_audit_plugin,0,0\n};\n\nplugin_type_init plugin_type_deinitialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0,ha_finalize_handlerton,0,0,finalize_schema_table,\n  finalize_audit_plugin,0,0\n};\n\n#ifdef HAVE_DLOPEN\nstatic const char *plugin_interface_version_sym=\n                   \"_mysql_plugin_interface_version_\";\nstatic const char *sizeof_st_plugin_sym=\n                   \"_mysql_sizeof_struct_st_plugin_\";\nstatic const char *plugin_declarations_sym= \"_mysql_plugin_declarations_\";\nstatic int min_plugin_interface_version= MYSQL_PLUGIN_INTERFACE_VERSION & ~0xFF;\n#endif\n\n/* Note that 'int version' must be the first field of every plugin\n   sub-structure (plugin->info).\n*/\nstatic int min_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000,\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION\n};\nstatic int cur_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000, /* UDF: not implemented */\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION\n};\n\n/* support for Services */\n\n#include \"sql_plugin_services.h\"\n\n/*\n  A mutex LOCK_plugin_delete must be acquired before calling plugin_del\n  function. \n*/\nmysql_mutex_t LOCK_plugin_delete;\n\n/*\n  A mutex LOCK_plugin must be acquired before accessing the\n  following variables/structures.\n  We are always manipulating ref count, so a rwlock here is unneccessary.\n*/\nmysql_mutex_t LOCK_plugin;\nstatic DYNAMIC_ARRAY plugin_dl_array;\nstatic DYNAMIC_ARRAY plugin_array;\nstatic HASH plugin_hash[MYSQL_MAX_PLUGIN_TYPE_NUM];\nstatic bool reap_needed= false;\nstatic int plugin_array_version=0;\n\nstatic bool initialized= 0;\n\n/*\n  write-lock on LOCK_system_variables_hash is required before modifying\n  the following variables/structures\n*/\nstatic MEM_ROOT plugin_mem_root;\nstatic uint global_variables_dynamic_size= 0;\nstatic HASH bookmark_hash;\n\n\n/*\n  hidden part of opaque value passed to variable check functions.\n  Used to provide a object-like structure to non C++ consumers.\n*/\nstruct st_item_value_holder : public st_mysql_value\n{\n  Item *item;\n};\n\n\n/*\n  stored in bookmark_hash, this structure is never removed from the\n  hash and is used to mark a single offset for a thd local variable\n  even if plugins have been uninstalled and reinstalled, repeatedly.\n  This structure is allocated from plugin_mem_root.\n\n  The key format is as follows:\n    1 byte         - variable type code\n    name_len bytes - variable name\n    '\\0'           - end of key\n*/\nstruct st_bookmark\n{\n  uint name_len;\n  int offset;\n  uint version;\n  char key[1];\n};\n\n\n/*\n  skeleton of a plugin variable - portion of structure common to all.\n*/\nstruct st_mysql_sys_var\n{\n  MYSQL_PLUGIN_VAR_HEADER;\n};\n\nstatic SHOW_TYPE pluginvar_show_type(st_mysql_sys_var *plugin_var);\n\n\n/*\n  sys_var class for access to all plugin variables visible to the user\n*/\nclass sys_var_pluginvar: public sys_var\n{\npublic:\n  struct st_plugin_int *plugin;\n  struct st_mysql_sys_var *plugin_var;\n  /**\n    variable name from whatever is hard-coded in the plugin source\n    and doesn't have pluginname- prefix is replaced by an allocated name\n    with a plugin prefix. When plugin is uninstalled we need to restore the\n    pointer to point to the hard-coded value, because plugin may be\n    installed/uninstalled many times without reloading the shared object.\n  */\n  const char *orig_pluginvar_name;\n\n  static void *operator new(size_t size, MEM_ROOT *mem_root)\n  { return (void*) alloc_root(mem_root, size); }\n  static void operator delete(void *ptr_arg,size_t size)\n  { TRASH(ptr_arg, size); }\n\n  sys_var_pluginvar(sys_var_chain *chain, const char *name_arg,\n                    struct st_mysql_sys_var *plugin_var_arg)\n    :sys_var(chain, name_arg, plugin_var_arg->comment,\n             (plugin_var_arg->flags & PLUGIN_VAR_THDLOCAL ? SESSION : GLOBAL) |\n             (plugin_var_arg->flags & PLUGIN_VAR_READONLY ? READONLY : 0),\n             0, -1, NO_ARG, pluginvar_show_type(plugin_var_arg), 0, 0,\n             VARIABLE_NOT_IN_BINLOG, NULL, NULL, NULL, PARSE_NORMAL),\n    plugin_var(plugin_var_arg), orig_pluginvar_name(plugin_var_arg->name)\n  { plugin_var->name= name_arg; }\n  sys_var_pluginvar *cast_pluginvar() { return this; }\n  bool check_update_type(Item_result type);\n  SHOW_TYPE show_type();\n  uchar* real_value_ptr(THD *thd, enum_var_type type);\n  TYPELIB* plugin_var_typelib(void);\n  uchar* do_value_ptr(THD *thd, enum_var_type type, LEX_STRING *base);\n  uchar* session_value_ptr(THD *thd, LEX_STRING *base)\n  { return do_value_ptr(thd, OPT_SESSION, base); }\n  uchar* global_value_ptr(THD *thd, LEX_STRING *base)\n  { return do_value_ptr(thd, OPT_GLOBAL, base); }\n  bool do_check(THD *thd, set_var *var);\n  virtual void session_save_default(THD *thd, set_var *var) {}\n  virtual void global_save_default(THD *thd, set_var *var) {}\n  bool session_update(THD *thd, set_var *var);\n  bool global_update(THD *thd, set_var *var);\n};\n\n\n/* prototypes */\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv);\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list);\nstatic int test_plugin_options(MEM_ROOT *, struct st_plugin_int *,\n                               int *, char **);\nstatic bool register_builtin(struct st_mysql_plugin *, struct st_plugin_int *,\n                             struct st_plugin_int **);\nstatic void unlock_variables(THD *thd, struct system_variables *vars);\nstatic void cleanup_variables(THD *thd, struct system_variables *vars);\nstatic void plugin_vars_free_values(sys_var *vars);\nstatic bool plugin_var_memalloc_session_update(THD *thd,\n                                               struct st_mysql_sys_var *var,\n                                               char **dest, const char *value);\nstatic bool plugin_var_memalloc_global_update(THD *thd,\n                                              struct st_mysql_sys_var *var,\n                                              char **dest, const char *value);\nstatic void plugin_var_memalloc_free(struct system_variables *vars);\nstatic void restore_pluginvar_names(sys_var *first);\nstatic void plugin_opt_set_limits(struct my_option *,\n                                  const struct st_mysql_sys_var *);\n#define my_intern_plugin_lock(A,B) intern_plugin_lock(A,B)\n#define my_intern_plugin_lock_ci(A,B) intern_plugin_lock(A,B)\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref plugin);\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin);\nstatic void reap_plugins(void);\n\nstatic void report_error(int where_to, uint error, ...)\n{\n  va_list args;\n  if (where_to & REPORT_TO_USER)\n  {\n    va_start(args, error);\n    my_printv_error(error, ER(error), MYF(0), args);\n    va_end(args);\n  }\n  if (where_to & REPORT_TO_LOG)\n  {\n    va_start(args, error);\n    error_log_print(ERROR_LEVEL, ER_DEFAULT(error), args);\n    va_end(args);\n  }\n}\n\n/**\n   Check if the provided path is valid in the sense that it does cause\n   a relative reference outside the directory.\n\n   @note Currently, this function only check if there are any\n   characters in FN_DIRSEP in the string, but it might change in the\n   future.\n\n   @code\n   check_valid_path(\"../foo.so\") -> true\n   check_valid_path(\"foo.so\") -> false\n   @endcode\n */\nbool check_valid_path(const char *path, size_t len)\n{\n  size_t prefix= my_strcspn(files_charset_info, path, path + len, FN_DIRSEP);\n  return  prefix < len;\n}\n\n\n/****************************************************************************\n  Value type thunks, allows the C world to play in the C++ world\n****************************************************************************/\n\nstatic int item_value_type(struct st_mysql_value *value)\n{\n  switch (((st_item_value_holder*)value)->item->result_type()) {\n  case INT_RESULT:\n    return MYSQL_VALUE_TYPE_INT;\n  case REAL_RESULT:\n    return MYSQL_VALUE_TYPE_REAL;\n  default:\n    return MYSQL_VALUE_TYPE_STRING;\n  }\n}\n\nstatic const char *item_val_str(struct st_mysql_value *value,\n                                char *buffer, int *length)\n{\n  String str(buffer, *length, system_charset_info), *res;\n  if (!(res= ((st_item_value_holder*)value)->item->val_str(&str)))\n    return NULL;\n  *length= res->length();\n  if (res->c_ptr_quick() == buffer)\n    return buffer;\n\n  /*\n    Lets be nice and create a temporary string since the\n    buffer was too small\n  */\n  return current_thd->strmake(res->c_ptr_quick(), res->length());\n}\n\n\nstatic int item_val_int(struct st_mysql_value *value, long long *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_int();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\nstatic int item_is_unsigned(struct st_mysql_value *value)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  return item->unsigned_flag;\n}\n\nstatic int item_val_real(struct st_mysql_value *value, double *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_real();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\n\n/****************************************************************************\n  Plugin support code\n****************************************************************************/\n\n#ifdef HAVE_DLOPEN\n\nstatic struct st_plugin_dl *plugin_dl_find(const LEX_STRING *dl)\n{\n  uint i;\n  struct st_plugin_dl *tmp;\n  DBUG_ENTER(\"plugin_dl_find\");\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n    if (tmp->ref_count &&\n        ! my_strnncoll(files_charset_info,\n                       (const uchar *)dl->str, dl->length,\n                       (const uchar *)tmp->dl.str, tmp->dl.length))\n      DBUG_RETURN(tmp);\n  }\n  DBUG_RETURN(0);\n}\n\n\nstatic st_plugin_dl *plugin_dl_insert_or_reuse(struct st_plugin_dl *plugin_dl)\n{\n  uint i;\n  struct st_plugin_dl *tmp;\n  DBUG_ENTER(\"plugin_dl_insert_or_reuse\");\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n    if (! tmp->ref_count)\n    {\n      memcpy(tmp, plugin_dl, sizeof(struct st_plugin_dl));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (insert_dynamic(&plugin_dl_array, (uchar*)&plugin_dl))\n    DBUG_RETURN(0);\n  tmp= *dynamic_element(&plugin_dl_array, plugin_dl_array.elements - 1,\n                        struct st_plugin_dl **)=\n      (struct st_plugin_dl *) memdup_root(&plugin_mem_root, (uchar*)plugin_dl,\n                                           sizeof(struct st_plugin_dl));\n  DBUG_RETURN(tmp);\n}\n#endif /* HAVE_DLOPEN */\n\n\nstatic inline void free_plugin_mem(struct st_plugin_dl *p)\n{\n#ifdef HAVE_DLOPEN\n  if (p->handle)\n    dlclose(p->handle);\n#endif\n  my_free(p->dl.str);\n  if (p->version != MYSQL_PLUGIN_INTERFACE_VERSION)\n    my_free(p->plugins);\n}\n\n\nstatic st_plugin_dl *plugin_dl_add(const LEX_STRING *dl, int report)\n{\n#ifdef HAVE_DLOPEN\n  char dlpath[FN_REFLEN];\n  uint plugin_dir_len, dummy_errors, dlpathlen, i;\n  struct st_plugin_dl *tmp, plugin_dl;\n  void *sym;\n  DBUG_ENTER(\"plugin_dl_add\");\n  DBUG_PRINT(\"enter\", (\"dl->str: '%s', dl->length: %d\",\n                       dl->str, (int) dl->length));\n  plugin_dir_len= strlen(opt_plugin_dir);\n  /*\n    Ensure that the dll doesn't have a path.\n    This is done to ensure that only approved libraries from the\n    plugin directory are used (to make this even remotely secure).\n  */\n  if (check_valid_path(dl->str, dl->length) ||\n      check_string_char_length((LEX_STRING *) dl, \"\", NAME_CHAR_LEN,\n                               system_charset_info, 1) ||\n      plugin_dir_len + dl->length + 1 >= FN_REFLEN)\n  {\n    report_error(report, ER_UDF_NO_PATHS);\n    DBUG_RETURN(0);\n  }\n  /* If this dll is already loaded just increase ref_count. */\n  if ((tmp= plugin_dl_find(dl)))\n  {\n    tmp->ref_count++;\n    DBUG_RETURN(tmp);\n  }\n  bzero(&plugin_dl, sizeof(plugin_dl));\n  /* Compile dll path */\n  dlpathlen=\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", dl->str, NullS) -\n    dlpath;\n  (void) unpack_filename(dlpath, dlpath);\n  plugin_dl.ref_count= 1;\n  /* Open new dll handle */\n  if (!(plugin_dl.handle= dlopen(dlpath, RTLD_NOW)))\n  {\n    const char *errmsg;\n    int error_number= dlopen_errno;\n    DLERROR_GENERATE(errmsg, error_number);\n\n    if (!strncmp(dlpath, errmsg, dlpathlen))\n    { // if errmsg starts from dlpath, trim this prefix.\n      errmsg+=dlpathlen;\n      if (*errmsg == ':') errmsg++;\n      if (*errmsg == ' ') errmsg++;\n    }\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, error_number, errmsg);\n    DBUG_RETURN(0);\n  }\n  /* Determine interface version */\n  if (!(sym= dlsym(plugin_dl.handle, plugin_interface_version_sym)))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_interface_version_sym);\n    DBUG_RETURN(0);\n  }\n  plugin_dl.version= *(int *)sym;\n  /* Versioning */\n  if (plugin_dl.version < min_plugin_interface_version ||\n      (plugin_dl.version >> 8) > (MYSQL_PLUGIN_INTERFACE_VERSION >> 8))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0,\n                 \"plugin interface version mismatch\");\n    DBUG_RETURN(0);\n  }\n\n  /* link the services in */\n  for (i= 0; i < array_elements(list_of_services); i++)\n  {\n    if ((sym= dlsym(plugin_dl.handle, list_of_services[i].name)))\n    {\n      uint ver= (uint)(intptr)*(void**)sym;\n      if (ver > list_of_services[i].version ||\n        (ver >> 8) < (list_of_services[i].version >> 8))\n      {\n        char buf[MYSQL_ERRMSG_SIZE];\n        my_snprintf(buf, sizeof(buf),\n                    \"service '%s' interface version mismatch\",\n                    list_of_services[i].name);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0, buf);\n        DBUG_RETURN(0);\n      }\n      *(void**)sym= list_of_services[i].service;\n    }\n  }\n\n  /* Find plugin declarations */\n  if (!(sym= dlsym(plugin_dl.handle, plugin_declarations_sym)))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_declarations_sym);\n    DBUG_RETURN(0);\n  }\n\n  if (plugin_dl.version != MYSQL_PLUGIN_INTERFACE_VERSION)\n  {\n    uint sizeof_st_plugin;\n    struct st_mysql_plugin *old, *cur;\n    char *ptr= (char *)sym;\n\n    if ((sym= dlsym(plugin_dl.handle, sizeof_st_plugin_sym)))\n      sizeof_st_plugin= *(int *)sym;\n    else\n    {\n#ifdef ERROR_ON_NO_SIZEOF_PLUGIN_SYMBOL\n      report_error(report, ER_CANT_FIND_DL_ENTRY, sizeof_st_plugin_sym);\n      DBUG_RETURN(0);\n#else\n      /*\n        When the following assert starts failing, we'll have to switch\n        to the upper branch of the #ifdef\n      */\n      DBUG_ASSERT(min_plugin_interface_version == 0);\n      sizeof_st_plugin= (int)offsetof(struct st_mysql_plugin, version);\n#endif\n    }\n\n    /*\n      What's the purpose of this loop? If the goal is to catch a\n      missing 0 record at the end of a list, it will fail miserably\n      since the compiler is likely to optimize this away. /Matz\n     */\n    for (i= 0;\n         ((struct st_mysql_plugin *)(ptr+i*sizeof_st_plugin))->info;\n         i++)\n      /* no op */;\n\n    cur= (struct st_mysql_plugin*)\n      my_malloc((i+1)*sizeof(struct st_mysql_plugin), MYF(MY_ZEROFILL|MY_WME));\n    if (!cur)\n    {\n      free_plugin_mem(&plugin_dl);\n      report_error(report, ER_OUTOFMEMORY,\n                   static_cast<int>(plugin_dl.dl.length));\n      DBUG_RETURN(0);\n    }\n    /*\n      All st_plugin fields not initialized in the plugin explicitly, are\n      set to 0. It matches C standard behaviour for struct initializers that\n      have less values than the struct definition.\n    */\n    for (i=0;\n         (old=(struct st_mysql_plugin *)(ptr+i*sizeof_st_plugin))->info;\n         i++)\n      memcpy(cur+i, old, min(sizeof(cur[i]), sizeof_st_plugin));\n\n    sym= cur;\n  }\n  plugin_dl.plugins= (struct st_mysql_plugin *)sym;\n\n  /*\n    If report is REPORT_TO_USER, we were called from\n    mysql_install_plugin. Otherwise, we are called directly or\n    indirectly from plugin_init.\n   */\n  if (report == REPORT_TO_USER)\n  {\n    st_mysql_plugin *plugin= plugin_dl.plugins;\n    for ( ; plugin->info ; ++plugin)\n      if (plugin->flags & PLUGIN_OPT_NO_INSTALL)\n      {\n        report_error(report, ER_PLUGIN_NO_INSTALL, plugin->name);\n        free_plugin_mem(&plugin_dl);\n        DBUG_RETURN(0);\n   }\n  }\n\n  /* Duplicate and convert dll name */\n  plugin_dl.dl.length= dl->length * files_charset_info->mbmaxlen + 1;\n  if (! (plugin_dl.dl.str= (char*) my_malloc(plugin_dl.dl.length, MYF(0))))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(plugin_dl.dl.length));\n    DBUG_RETURN(0);\n  }\n  plugin_dl.dl.length= copy_and_convert(plugin_dl.dl.str, plugin_dl.dl.length,\n    files_charset_info, dl->str, dl->length, system_charset_info,\n    &dummy_errors);\n  plugin_dl.dl.str[plugin_dl.dl.length]= 0;\n  /* Add this dll to array */\n  if (! (tmp= plugin_dl_insert_or_reuse(&plugin_dl)))\n  {\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(sizeof(struct st_plugin_dl)));\n    DBUG_RETURN(0);\n  }\n  DBUG_RETURN(tmp);\n#else\n  DBUG_ENTER(\"plugin_dl_add\");\n  report_error(report, ER_FEATURE_DISABLED, \"plugin\", \"HAVE_DLOPEN\");\n  DBUG_RETURN(0);\n#endif\n}\n\n\nstatic void plugin_dl_del(const LEX_STRING *dl)\n{\n#ifdef HAVE_DLOPEN\n  uint i;\n  DBUG_ENTER(\"plugin_dl_del\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    struct st_plugin_dl *tmp= *dynamic_element(&plugin_dl_array, i,\n                                               struct st_plugin_dl **);\n    if (tmp->ref_count &&\n        ! my_strnncoll(files_charset_info,\n                       (const uchar *)dl->str, dl->length,\n                       (const uchar *)tmp->dl.str, tmp->dl.length))\n    {\n      /* Do not remove this element, unless no other plugin uses this dll. */\n      if (! --tmp->ref_count)\n      {\n        free_plugin_mem(tmp);\n        bzero(tmp, sizeof(struct st_plugin_dl));\n      }\n      break;\n    }\n  }\n  DBUG_VOID_RETURN;\n#endif\n}\n\n\nstatic struct st_plugin_int *plugin_find_internal(const LEX_STRING *name, int type)\n{\n  uint i;\n  DBUG_ENTER(\"plugin_find_internal\");\n  if (! initialized)\n    DBUG_RETURN(0);\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    {\n      struct st_plugin_int *plugin= (st_plugin_int *)\n        my_hash_search(&plugin_hash[i], (const uchar *)name->str, name->length);\n      if (plugin)\n        DBUG_RETURN(plugin);\n    }\n  }\n  else\n    DBUG_RETURN((st_plugin_int *)\n        my_hash_search(&plugin_hash[type], (const uchar *)name->str,\n                       name->length));\n  DBUG_RETURN(0);\n}\n\n\nstatic SHOW_COMP_OPTION plugin_status(const LEX_STRING *name, int type)\n{\n  SHOW_COMP_OPTION rc= SHOW_OPTION_NO;\n  struct st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_is_ready\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n  {\n    rc= SHOW_OPTION_DISABLED;\n    if (plugin->state == PLUGIN_IS_READY)\n      rc= SHOW_OPTION_YES;\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nbool plugin_is_ready(const LEX_STRING *name, int type)\n{\n  bool rc= FALSE;\n  if (plugin_status(name, type) == SHOW_OPTION_YES)\n    rc= TRUE;\n  return rc;\n}\n\n\nSHOW_COMP_OPTION plugin_status(const char *name, size_t len, int type)\n{\n  LEX_STRING plugin_name= { (char *) name, len };\n  return plugin_status(&plugin_name, type);\n}\n\n\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref rc)\n{\n  st_plugin_int *pi= plugin_ref_to_int(rc);\n  DBUG_ENTER(\"intern_plugin_lock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (pi->state & (PLUGIN_IS_READY | PLUGIN_IS_UNINITIALIZED))\n  {\n    plugin_ref plugin;\n#ifdef DBUG_OFF\n    /* built-in plugins don't need ref counting */\n    if (!pi->plugin_dl)\n      DBUG_RETURN(pi);\n\n    plugin= pi;\n#else\n    /*\n      For debugging, we do an additional malloc which allows the\n      memory manager and/or valgrind to track locked references and\n      double unlocks to aid resolving reference counting problems.\n    */\n    if (!(plugin= (plugin_ref) my_malloc(sizeof(pi), MYF(MY_WME))))\n      DBUG_RETURN(NULL);\n\n    *plugin= pi;\n#endif\n    pi->ref_count++;\n    DBUG_PRINT(\"info\",(\"thd: 0x%lx, plugin: \\\"%s\\\", ref_count: %d\",\n                       (long) current_thd, pi->name.str, pi->ref_count));\n\n    if (lex)\n      insert_dynamic(&lex->plugins, (uchar*)&plugin);\n    DBUG_RETURN(plugin);\n  }\n  DBUG_RETURN(NULL);\n}\n\n\nplugin_ref plugin_lock(THD *thd, plugin_ref *ptr)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc;\n  DBUG_ENTER(\"plugin_lock\");\n  mysql_mutex_lock(&LOCK_plugin);\n  rc= my_intern_plugin_lock_ci(lex, *ptr);\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nplugin_ref plugin_lock_by_name(THD *thd, const LEX_STRING *name, int type)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc= NULL;\n  st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_lock_by_name\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n    rc= my_intern_plugin_lock_ci(lex, plugin_int_to_ref(plugin));\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nstatic st_plugin_int *plugin_insert_or_reuse(struct st_plugin_int *plugin)\n{\n  uint i;\n  struct st_plugin_int *tmp;\n  DBUG_ENTER(\"plugin_insert_or_reuse\");\n  for (i= 0; i < plugin_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n    if (tmp->state == PLUGIN_IS_FREED)\n    {\n      memcpy(tmp, plugin, sizeof(struct st_plugin_int));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (insert_dynamic(&plugin_array, (uchar*)&plugin))\n    DBUG_RETURN(0);\n  tmp= *dynamic_element(&plugin_array, plugin_array.elements - 1,\n                        struct st_plugin_int **)=\n       (struct st_plugin_int *) memdup_root(&plugin_mem_root, (uchar*)plugin,\n                                            sizeof(struct st_plugin_int));\n  DBUG_RETURN(tmp);\n}\n\n\n/*\n  NOTE\n    Requires that a write-lock is held on LOCK_system_variables_hash\n*/\nstatic bool plugin_add(MEM_ROOT *tmp_root,\n                       const LEX_STRING *name, const LEX_STRING *dl,\n                       int *argc, char **argv, int report)\n{\n  struct st_plugin_int tmp;\n  struct st_mysql_plugin *plugin;\n  DBUG_ENTER(\"plugin_add\");\n  if (plugin_find_internal(name, MYSQL_ANY_PLUGIN))\n  {\n    report_error(report, ER_UDF_EXISTS, name->str);\n    DBUG_RETURN(TRUE);\n  }\n  /* Clear the whole struct to catch future extensions. */\n  bzero((char*) &tmp, sizeof(tmp));\n  if (! (tmp.plugin_dl= plugin_dl_add(dl, report)))\n    DBUG_RETURN(TRUE);\n  /* Find plugin by name */\n  for (plugin= tmp.plugin_dl->plugins; plugin->info; plugin++)\n  {\n    uint name_len= strlen(plugin->name);\n    if (plugin->type >= 0 && plugin->type < MYSQL_MAX_PLUGIN_TYPE_NUM &&\n        ! my_strnncoll(system_charset_info,\n                       (const uchar *)name->str, name->length,\n                       (const uchar *)plugin->name,\n                       name_len))\n    {\n      struct st_plugin_int *tmp_plugin_ptr;\n      if (*(int*)plugin->info <\n          min_plugin_info_interface_version[plugin->type] ||\n          ((*(int*)plugin->info) >> 8) >\n          (cur_plugin_info_interface_version[plugin->type] >> 8))\n      {\n        char buf[256];\n        strxnmov(buf, sizeof(buf) - 1, \"API version for \",\n                 plugin_type_names[plugin->type].str,\n                 \" plugin is too different\", NullS);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dl->str, 0, buf);\n        goto err;\n      }\n      tmp.plugin= plugin;\n      tmp.name.str= (char *)plugin->name;\n      tmp.name.length= name_len;\n      tmp.ref_count= 0;\n      tmp.state= PLUGIN_IS_UNINITIALIZED;\n      tmp.load_option= PLUGIN_ON;\n      if (test_plugin_options(tmp_root, &tmp, argc, argv))\n        tmp.state= PLUGIN_IS_DISABLED;\n\n      if ((tmp_plugin_ptr= plugin_insert_or_reuse(&tmp)))\n      {\n        plugin_array_version++;\n        if (!my_hash_insert(&plugin_hash[plugin->type], (uchar*)tmp_plugin_ptr))\n        {\n          init_alloc_root(&tmp_plugin_ptr->mem_root, 4096, 4096);\n          DBUG_RETURN(FALSE);\n        }\n        tmp_plugin_ptr->state= PLUGIN_IS_FREED;\n      }\n      mysql_del_sys_var_chain(tmp.system_vars);\n      restore_pluginvar_names(tmp.system_vars);\n      goto err;\n\n      /* plugin was disabled */\n      plugin_dl_del(dl);\n      DBUG_RETURN(FALSE);\n    }\n  }\n  report_error(report, ER_CANT_FIND_DL_ENTRY, name->str);\nerr:\n  plugin_dl_del(dl);\n  DBUG_RETURN(TRUE);\n}\n\n\nstatic void plugin_deinitialize(struct st_plugin_int *plugin, bool ref_check)\n{\n  /*\n    we don't want to hold the LOCK_plugin mutex as it may cause\n    deinitialization to deadlock if plugins have worker threads\n    with plugin locks\n  */\n  mysql_mutex_assert_not_owner(&LOCK_plugin);\n\n  if (plugin->plugin->status_vars)\n  {\n#ifdef FIX_LATER\n    /**\n      @todo\n      unfortunately, status variables were introduced without a\n      pluginname_ namespace, that is pluginname_ was not added automatically\n      to status variable names. It should be fixed together with the next\n      incompatible API change.\n    */\n    SHOW_VAR array[2]= {\n      {plugin->plugin->name, (char*)plugin->plugin->status_vars, SHOW_ARRAY},\n      {0, 0, SHOW_UNDEF}\n    };\n    remove_status_vars(array);\n#else\n    remove_status_vars(plugin->plugin->status_vars);\n#endif /* FIX_LATER */\n  }\n\n  if (plugin_type_deinitialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_deinitialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' of type %s failed deinitialization\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n    }\n  }\n  else if (plugin->plugin->deinit)\n  {\n    DBUG_PRINT(\"info\", (\"Deinitializing plugin: '%s'\", plugin->name.str));\n    if (plugin->plugin->deinit(plugin))\n    {\n      DBUG_PRINT(\"warning\", (\"Plugin '%s' deinit function returned error.\",\n                             plugin->name.str));\n    }\n  }\n  plugin->state= PLUGIN_IS_UNINITIALIZED;\n\n  /*\n    We do the check here because NDB has a worker THD which doesn't\n    exit until NDB is shut down.\n  */\n  if (ref_check && plugin->ref_count)\n    sql_print_error(\"Plugin '%s' has ref_count=%d after deinitialization.\",\n                    plugin->name.str, plugin->ref_count);\n}\n\nstatic void plugin_del(struct st_plugin_int *plugin)\n{\n  DBUG_ENTER(\"plugin_del(plugin)\");\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  mysql_mutex_assert_owner(&LOCK_plugin_delete);\n  /* Free allocated strings before deleting the plugin. */\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n  mysql_del_sys_var_chain(plugin->system_vars);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  restore_pluginvar_names(plugin->system_vars);\n  plugin_vars_free_values(plugin->system_vars);\n  my_hash_delete(&plugin_hash[plugin->plugin->type], (uchar*)plugin);\n  if (plugin->plugin_dl)\n    plugin_dl_del(&plugin->plugin_dl->dl);\n  plugin->state= PLUGIN_IS_FREED;\n  plugin_array_version++;\n  free_root(&plugin->mem_root, MYF(0));\n  DBUG_VOID_RETURN;\n}\n\nstatic void reap_plugins(void)\n{\n  uint count, idx;\n  struct st_plugin_int *plugin, **reap, **list;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!reap_needed)\n    return;\n\n  reap_needed= false;\n  count= plugin_array.elements;\n  reap= (struct st_plugin_int **)my_alloca(sizeof(plugin)*(count+1));\n  *(reap++)= NULL;\n\n  for (idx= 0; idx < count; idx++)\n  {\n    plugin= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n    if (plugin->state == PLUGIN_IS_DELETED && !plugin->ref_count)\n    {\n      /* change the status flag to prevent reaping by another thread */\n      plugin->state= PLUGIN_IS_DYING;\n      *(reap++)= plugin;\n    }\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  list= reap;\n  while ((plugin= *(--list)))\n    plugin_deinitialize(plugin, true);\n\n  mysql_mutex_lock(&LOCK_plugin_delete);\n  mysql_mutex_lock(&LOCK_plugin);\n\n  while ((plugin= *(--reap)))\n    plugin_del(plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin_delete);\n\n  my_afree(reap);\n}\n\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin)\n{\n  int i;\n  st_plugin_int *pi;\n  DBUG_ENTER(\"intern_plugin_unlock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!plugin)\n    DBUG_VOID_RETURN;\n\n  pi= plugin_ref_to_int(plugin);\n\n#ifdef DBUG_OFF\n  if (!pi->plugin_dl)\n    DBUG_VOID_RETURN;\n#else\n  my_free(plugin);\n#endif\n\n  DBUG_PRINT(\"info\",(\"unlocking plugin, name= %s, ref_count= %d\",\n                     pi->name.str, pi->ref_count));\n  if (lex)\n  {\n    /*\n      Remove one instance of this plugin from the use list.\n      We are searching backwards so that plugins locked last\n      could be unlocked faster - optimizing for LIFO semantics.\n    */\n    for (i= lex->plugins.elements - 1; i >= 0; i--)\n      if (plugin == *dynamic_element(&lex->plugins, i, plugin_ref*))\n      {\n        delete_dynamic_element(&lex->plugins, i);\n        break;\n      }\n    DBUG_ASSERT(i >= 0);\n  }\n\n  DBUG_ASSERT(pi->ref_count);\n  pi->ref_count--;\n\n  if (pi->state == PLUGIN_IS_DELETED && !pi->ref_count)\n    reap_needed= true;\n\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock(THD *thd, plugin_ref plugin)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock\");\n  if (!plugin)\n    DBUG_VOID_RETURN;\n#ifdef DBUG_OFF\n  /* built-in plugins don't need ref counting */\n  if (!plugin_dlib(plugin))\n    DBUG_VOID_RETURN;\n#endif\n  mysql_mutex_lock(&LOCK_plugin);\n  intern_plugin_unlock(lex, plugin);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock_list(THD *thd, plugin_ref *list, uint count)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock_list\");\n  DBUG_ASSERT(list);\n  mysql_mutex_lock(&LOCK_plugin);\n  while (count--)\n    intern_plugin_unlock(lex, *list++);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\nstatic int plugin_initialize(struct st_plugin_int *plugin)\n{\n  int ret= 1;\n  DBUG_ENTER(\"plugin_initialize\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  uint state= plugin->state;\n  DBUG_ASSERT(state == PLUGIN_IS_UNINITIALIZED);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (plugin_type_initialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_initialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' registration as a %s failed.\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n      goto err;\n    }\n  }\n  else if (plugin->plugin->init)\n  {\n    if (plugin->plugin->init(plugin))\n    {\n      sql_print_error(\"Plugin '%s' init function returned error.\",\n                      plugin->name.str);\n      goto err;\n    }\n  }\n  state= PLUGIN_IS_READY; // plugin->init() succeeded\n\n  if (plugin->plugin->status_vars)\n  {\n#ifdef FIX_LATER\n    /*\n      We have a problem right now where we can not prepend without\n      breaking backwards compatibility. We will fix this shortly so\n      that engines have \"use names\" and we wil use those for\n      CREATE TABLE, and use the plugin name then for adding automatic\n      variable names.\n    */\n    SHOW_VAR array[2]= {\n      {plugin->plugin->name, (char*)plugin->plugin->status_vars, SHOW_ARRAY},\n      {0, 0, SHOW_UNDEF}\n    };\n    if (add_status_vars(array)) // add_status_vars makes a copy\n      goto err;\n#else\n    if (add_status_vars(plugin->plugin->status_vars))\n      goto err;\n#endif /* FIX_LATER */\n  }\n\n  /*\n    set the plugin attribute of plugin's sys vars so they are pointing\n    to the active plugin\n  */\n  if (plugin->system_vars)\n  {\n    sys_var_pluginvar *var= plugin->system_vars->cast_pluginvar();\n    for (;;)\n    {\n      var->plugin= plugin;\n      if (!var->next)\n        break;\n      var= var->next->cast_pluginvar();\n    }\n  }\n\n  ret= 0;\n\nerr:\n  mysql_mutex_lock(&LOCK_plugin);\n  plugin->state= state;\n\n  /* maintain the obsolete @@have_innodb variable */\n  if (!my_strcasecmp(&my_charset_latin1, plugin->name.str, \"InnoDB\"))\n    have_innodb= state & PLUGIN_IS_READY ? SHOW_OPTION_YES\n                                         : SHOW_OPTION_DISABLED;\n\n  DBUG_RETURN(ret);\n}\n\n\nextern \"C\" uchar *get_plugin_hash_key(const uchar *, size_t *, my_bool);\nextern \"C\" uchar *get_bookmark_hash_key(const uchar *, size_t *, my_bool);\n\n\nuchar *get_plugin_hash_key(const uchar *buff, size_t *length,\n                           my_bool not_used __attribute__((unused)))\n{\n  struct st_plugin_int *plugin= (st_plugin_int *)buff;\n  *length= (uint)plugin->name.length;\n  return((uchar *)plugin->name.str);\n}\n\n\nuchar *get_bookmark_hash_key(const uchar *buff, size_t *length,\n                             my_bool not_used __attribute__((unused)))\n{\n  struct st_bookmark *var= (st_bookmark *)buff;\n  *length= var->name_len + 1;\n  return (uchar*) var->key;\n}\n\nstatic inline void convert_dash_to_underscore(char *str, int len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '-')\n      *p= '_';\n}\n\nstatic inline void convert_underscore_to_dash(char *str, int len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '_')\n      *p= '-';\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_key key_LOCK_plugin;\nstatic PSI_mutex_key key_LOCK_plugin_delete;\n\nstatic PSI_mutex_info all_plugin_mutexes[]=\n{\n  { &key_LOCK_plugin, \"LOCK_plugin\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_plugin_delete, \"LOCK_plugin_delete\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_plugin_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_plugin_mutexes);\n  PSI_server->register_mutex(category, all_plugin_mutexes, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\n/*\n  The logic is that we first load and initialize all compiled in plugins.\n  From there we load up the dynamic types (assuming we have not been told to\n  skip this part).\n\n  Finally we initialize everything, aka the dynamic that have yet to initialize.\n*/\nint plugin_init(int *argc, char **argv, int flags)\n{\n  uint i;\n  bool is_myisam;\n  struct st_mysql_plugin **builtins;\n  struct st_mysql_plugin *plugin;\n  struct st_plugin_int tmp, *plugin_ptr, **reap;\n  MEM_ROOT tmp_root;\n  bool reaped_mandatory_plugin= false;\n  bool mandatory= true;\n  DBUG_ENTER(\"plugin_init\");\n\n  if (initialized)\n    DBUG_RETURN(0);\n\n#ifdef HAVE_PSI_INTERFACE\n  init_plugin_psi_keys();\n#endif\n\n  init_alloc_root(&plugin_mem_root, 4096, 4096);\n  init_alloc_root(&tmp_root, 4096, 4096);\n\n  if (my_hash_init(&bookmark_hash, &my_charset_bin, 16, 0, 0,\n                   get_bookmark_hash_key, NULL, HASH_UNIQUE))\n      goto err;\n\n\n  mysql_mutex_init(key_LOCK_plugin, &LOCK_plugin, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_plugin_delete, &LOCK_plugin_delete, MY_MUTEX_INIT_FAST);\n\n  if (my_init_dynamic_array(&plugin_dl_array,\n                            sizeof(struct st_plugin_dl *),16,16) ||\n      my_init_dynamic_array(&plugin_array,\n                            sizeof(struct st_plugin_int *),16,16))\n    goto err;\n\n  for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n  {\n    if (my_hash_init(&plugin_hash[i], system_charset_info, 16, 0, 0,\n                     get_plugin_hash_key, NULL, HASH_UNIQUE))\n      goto err;\n  }\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  initialized= 1;\n\n  /*\n    First we register builtin plugins\n  */\n  for (builtins= mysql_mandatory_plugins; *builtins || mandatory; builtins++)\n  {\n    if (!*builtins)\n    {\n      builtins= mysql_optional_plugins;\n      mandatory= false;\n      if (!*builtins)\n        break;\n    }\n    for (plugin= *builtins; plugin->info; plugin++)\n    {\n      if (opt_ignore_builtin_innodb &&\n          !my_strnncoll(&my_charset_latin1, (const uchar*) plugin->name,\n                        6, (const uchar*) \"InnoDB\", 6))\n        continue;\n      bzero(&tmp, sizeof(tmp));\n      tmp.plugin= plugin;\n      tmp.name.str= (char *)plugin->name;\n      tmp.name.length= strlen(plugin->name);\n      tmp.state= 0;\n      tmp.load_option= mandatory ? PLUGIN_FORCE : PLUGIN_ON;\n\n      /*\n        If the performance schema is compiled in,\n        treat the storage engine plugin as 'mandatory',\n        to suppress any plugin-level options such as '--performance-schema'.\n        This is specific to the performance schema, and is done on purpose:\n        the server-level option '--performance-schema' controls the overall\n        performance schema initialization, which consists of much more that\n        the underlying storage engine initialization.\n        See mysqld.cc, set_vars.cc.\n        Suppressing ways to interfere directly with the storage engine alone\n        prevents awkward situations where:\n        - the user wants the performance schema functionality, by using\n          '--enable-performance-schema' (the server option),\n        - yet disable explicitly a component needed for the functionality\n          to work, by using '--skip-performance-schema' (the plugin)\n      */\n      if (!my_strcasecmp(&my_charset_latin1, plugin->name, \"PERFORMANCE_SCHEMA\"))\n        tmp.load_option= PLUGIN_FORCE;\n\n      free_root(&tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n      if (test_plugin_options(&tmp_root, &tmp, argc, argv))\n        tmp.state= PLUGIN_IS_DISABLED;\n      else\n        tmp.state= PLUGIN_IS_UNINITIALIZED;\n      if (register_builtin(plugin, &tmp, &plugin_ptr))\n        goto err_unlock;\n\n      /* only initialize MyISAM and CSV at this stage */\n      if (!(is_myisam=\n            !my_strcasecmp(&my_charset_latin1, plugin->name, \"MyISAM\")) &&\n          my_strcasecmp(&my_charset_latin1, plugin->name, \"CSV\"))\n        continue;\n\n      if (plugin_ptr->state != PLUGIN_IS_UNINITIALIZED ||\n          plugin_initialize(plugin_ptr))\n        goto err_unlock;\n\n      /*\n        initialize the global default storage engine so that it may\n        not be null in any child thread.\n      */\n      if (is_myisam)\n      {\n        DBUG_ASSERT(!global_system_variables.table_plugin);\n        global_system_variables.table_plugin=\n          my_intern_plugin_lock(NULL, plugin_int_to_ref(plugin_ptr));\n        DBUG_ASSERT(plugin_ptr->ref_count == 1);\n      }\n    }\n  }\n\n  /* should now be set to MyISAM storage engine */\n  DBUG_ASSERT(global_system_variables.table_plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  /* Register all dynamic plugins */\n  if (!(flags & PLUGIN_INIT_SKIP_DYNAMIC_LOADING))\n  {\n    if (opt_plugin_load)\n      plugin_load_list(&tmp_root, argc, argv, opt_plugin_load);\n    if (!(flags & PLUGIN_INIT_SKIP_PLUGIN_TABLE))\n      plugin_load(&tmp_root, argc, argv);\n  }\n\n  if (flags & PLUGIN_INIT_SKIP_INITIALIZATION)\n    goto end;\n\n  /*\n    Now we initialize all remaining plugins\n  */\n\n  mysql_mutex_lock(&LOCK_plugin);\n  reap= (st_plugin_int **) my_alloca((plugin_array.elements+1) * sizeof(void*));\n  *(reap++)= NULL;\n\n  for (i= 0; i < plugin_array.elements; i++)\n  {\n    plugin_ptr= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n    if (plugin_ptr->state == PLUGIN_IS_UNINITIALIZED)\n    {\n      if (plugin_initialize(plugin_ptr))\n      {\n        plugin_ptr->state= PLUGIN_IS_DYING;\n        *(reap++)= plugin_ptr;\n      }\n    }\n  }\n\n  /*\n    Check if any plugins have to be reaped\n  */\n  while ((plugin_ptr= *(--reap)))\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    if (plugin_ptr->load_option == PLUGIN_FORCE ||\n        plugin_ptr->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n      reaped_mandatory_plugin= TRUE;\n    plugin_deinitialize(plugin_ptr, true);\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_del(plugin_ptr);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  my_afree(reap);\n  if (reaped_mandatory_plugin)\n    goto err;\n\nend:\n  free_root(&tmp_root, MYF(0));\n\n  DBUG_RETURN(0);\n\nerr_unlock:\n  mysql_mutex_unlock(&LOCK_plugin);\nerr:\n  free_root(&tmp_root, MYF(0));\n  DBUG_RETURN(1);\n}\n\n\nstatic bool register_builtin(struct st_mysql_plugin *plugin,\n                             struct st_plugin_int *tmp,\n                             struct st_plugin_int **ptr)\n{\n  DBUG_ENTER(\"register_builtin\");\n  tmp->ref_count= 0;\n  tmp->plugin_dl= 0;\n\n  if (insert_dynamic(&plugin_array, (uchar*)&tmp))\n    DBUG_RETURN(1);\n\n  *ptr= *dynamic_element(&plugin_array, plugin_array.elements - 1,\n                         struct st_plugin_int **)=\n        (struct st_plugin_int *) memdup_root(&plugin_mem_root, (uchar*)tmp,\n                                             sizeof(struct st_plugin_int));\n\n  if (my_hash_insert(&plugin_hash[plugin->type],(uchar*) *ptr))\n    DBUG_RETURN(1);\n\n  DBUG_RETURN(0);\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv)\n{\n  THD thd;\n  TABLE_LIST tables;\n  TABLE *table;\n  READ_RECORD read_record_info;\n  int error;\n  THD *new_thd= &thd;\n  bool result;\n#ifdef EMBEDDED_LIBRARY\n  No_such_table_error_handler error_handler;\n#endif /* EMBEDDED_LIBRARY */\n  DBUG_ENTER(\"plugin_load\");\n\n  new_thd->thread_stack= (char*) &tables;\n  new_thd->store_globals();\n  new_thd->db= my_strdup(\"mysql\", MYF(0));\n  new_thd->db_length= 5;\n  bzero((char*) &thd.net, sizeof(thd.net));\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_READ);\n\n#ifdef EMBEDDED_LIBRARY\n  /*\n    When building an embedded library, if the mysql.plugin table\n    does not exist, we silently ignore the missing table\n  */\n  new_thd->push_internal_handler(&error_handler);\n#endif /* EMBEDDED_LIBRARY */\n\n  result= open_and_lock_tables(new_thd, &tables, FALSE, MYSQL_LOCK_IGNORE_TIMEOUT);\n\n#ifdef EMBEDDED_LIBRARY\n  new_thd->pop_internal_handler();\n  if (error_handler.safely_trapped_errors())\n    goto end;\n#endif /* EMBEDDED_LIBRARY */\n\n  if (result)\n  {\n    DBUG_PRINT(\"error\",(\"Can't open plugin table\"));\n    sql_print_error(\"Can't open the mysql.plugin table. Please \"\n                    \"run mysql_upgrade to create it.\");\n    goto end;\n  }\n  table= tables.table;\n  init_read_record(&read_record_info, new_thd, table, NULL, 1, 0, FALSE);\n  table->use_all_columns();\n  /*\n    there're no other threads running yet, so we don't need a mutex.\n    but plugin_add() before is designed to work in multi-threaded\n    environment, and it uses mysql_mutex_assert_owner(), so we lock\n    the mutex here to satisfy the assert\n  */\n  mysql_mutex_lock(&LOCK_plugin);\n  while (!(error= read_record_info.read_record(&read_record_info)))\n  {\n    DBUG_PRINT(\"info\", (\"init plugin record\"));\n    String str_name, str_dl;\n    get_field(tmp_root, table->field[0], &str_name);\n    get_field(tmp_root, table->field[1], &str_dl);\n\n    LEX_STRING name= {(char *)str_name.ptr(), str_name.length()};\n    LEX_STRING dl= {(char *)str_dl.ptr(), str_dl.length()};\n\n    if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n      sql_print_warning(\"Couldn't load plugin named '%s' with soname '%s'.\",\n                        str_name.c_ptr(), str_dl.c_ptr());\n    free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (error > 0)\n    sql_print_error(ER(ER_GET_ERRNO), my_errno);\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n  close_mysql_tables(new_thd);\nend:\n  /* Remember that we don't have a THD */\n  my_pthread_setspecific_ptr(THR_THD, 0);\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list)\n{\n  char buffer[FN_REFLEN];\n  LEX_STRING name= {buffer, 0}, dl= {NULL, 0}, *str= &name;\n  struct st_plugin_dl *plugin_dl;\n  struct st_mysql_plugin *plugin;\n  char *p= buffer;\n  DBUG_ENTER(\"plugin_load_list\");\n  while (list)\n  {\n    if (p == buffer + sizeof(buffer) - 1)\n    {\n      sql_print_error(\"plugin-load parameter too long\");\n      DBUG_RETURN(TRUE);\n    }\n\n    switch ((*(p++)= *(list++))) {\n    case '\\0':\n      list= NULL; /* terminate the loop */\n      /* fall through */\n#ifndef __WIN__\n    case ':':     /* can't use this as delimiter as it may be drive letter */\n#endif\n    case ';':\n      str->str[str->length]= '\\0';\n      if (str == &name)  // load all plugins in named module\n      {\n        if (!name.length)\n        {\n          p--;    /* reset pointer */\n          continue;\n        }\n\n        dl= name;\n        mysql_mutex_lock(&LOCK_plugin);\n        if ((plugin_dl= plugin_dl_add(&dl, REPORT_TO_LOG)))\n        {\n          for (plugin= plugin_dl->plugins; plugin->info; plugin++)\n          {\n            name.str= (char *) plugin->name;\n            name.length= strlen(name.str);\n\n            free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n            if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n              goto error;\n          }\n          plugin_dl_del(&dl); // reduce ref count\n        }\n      }\n      else\n      {\n        free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n        mysql_mutex_lock(&LOCK_plugin);\n        if (plugin_add(tmp_root, &name, &dl, argc, argv, REPORT_TO_LOG))\n          goto error;\n      }\n      mysql_mutex_unlock(&LOCK_plugin);\n      name.length= dl.length= 0;\n      dl.str= NULL; name.str= p= buffer;\n      str= &name;\n      continue;\n    case '=':\n    case '#':\n      if (str == &name)\n      {\n        name.str[name.length]= '\\0';\n        str= &dl;\n        str->str= p;\n        continue;\n      }\n    default:\n      str->length++;\n      continue;\n    }\n  }\n  DBUG_RETURN(FALSE);\nerror:\n  mysql_mutex_unlock(&LOCK_plugin);\n  sql_print_error(\"Couldn't load plugin named '%s' with soname '%s'.\",\n                  name.str, dl.str);\n  DBUG_RETURN(TRUE);\n}\n\n\nvoid plugin_shutdown(void)\n{\n  uint i, count= plugin_array.elements;\n  struct st_plugin_int **plugins, *plugin;\n  struct st_plugin_dl **dl;\n  DBUG_ENTER(\"plugin_shutdown\");\n\n  if (initialized)\n  {\n    mysql_mutex_lock(&LOCK_plugin);\n\n    reap_needed= true;\n\n    /*\n      We want to shut down plugins in a reasonable order, this will\n      become important when we have plugins which depend upon each other.\n      Circular references cannot be reaped so they are forced afterwards.\n      TODO: Have an additional step here to notify all active plugins that\n      shutdown is requested to allow plugins to deinitialize in parallel.\n    */\n    while (reap_needed && (count= plugin_array.elements))\n    {\n      reap_plugins();\n      for (i= 0; i < count; i++)\n      {\n        plugin= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n        if (plugin->state == PLUGIN_IS_READY)\n        {\n          plugin->state= PLUGIN_IS_DELETED;\n          reap_needed= true;\n        }\n      }\n      if (!reap_needed)\n      {\n        /*\n          release any plugin references held.\n        */\n        unlock_variables(NULL, &global_system_variables);\n        unlock_variables(NULL, &max_system_variables);\n      }\n    }\n\n    plugins= (struct st_plugin_int **) my_alloca(sizeof(void*) * (count+1));\n\n    /*\n      If we have any plugins which did not die cleanly, we force shutdown\n    */\n    for (i= 0; i < count; i++)\n    {\n      plugins[i]= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n      /* change the state to ensure no reaping races */\n      if (plugins[i]->state == PLUGIN_IS_DELETED)\n        plugins[i]->state= PLUGIN_IS_DYING;\n    }\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    /*\n      We loop through all plugins and call deinit() if they have one.\n    */\n    for (i= 0; i < count; i++)\n      if (!(plugins[i]->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_FREED |\n                                 PLUGIN_IS_DISABLED)))\n      {\n        sql_print_warning(\"Plugin '%s' will be forced to shutdown\",\n                          plugins[i]->name.str);\n        /*\n          We are forcing deinit on plugins so we don't want to do a ref_count\n          check until we have processed all the plugins.\n        */\n        plugin_deinitialize(plugins[i], false);\n      }\n\n    /*\n      It's perfectly safe not to lock LOCK_plugin, LOCK_plugin_delete, as\n      there're no concurrent threads anymore. But some functions called from\n      here use mysql_mutex_assert_owner(), so we lock the mutex to satisfy it\n    */\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n\n    /*\n      We defer checking ref_counts until after all plugins are deinitialized\n      as some may have worker threads holding on to plugin references.\n    */\n    for (i= 0; i < count; i++)\n    {\n      if (plugins[i]->ref_count)\n        sql_print_error(\"Plugin '%s' has ref_count=%d after shutdown.\",\n                        plugins[i]->name.str, plugins[i]->ref_count);\n      if (plugins[i]->state & PLUGIN_IS_UNINITIALIZED)\n        plugin_del(plugins[i]);\n    }\n\n    /*\n      Now we can deallocate all memory.\n    */\n\n    cleanup_variables(NULL, &global_system_variables);\n    cleanup_variables(NULL, &max_system_variables);\n    mysql_mutex_unlock(&LOCK_plugin);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n\n    initialized= 0;\n    mysql_mutex_destroy(&LOCK_plugin);\n    mysql_mutex_destroy(&LOCK_plugin_delete);\n\n    my_afree(plugins);\n  }\n\n  /* Dispose of the memory */\n\n  for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    my_hash_free(&plugin_hash[i]);\n  delete_dynamic(&plugin_array);\n\n  count= plugin_dl_array.elements;\n  dl= (struct st_plugin_dl **)my_alloca(sizeof(void*) * count);\n  for (i= 0; i < count; i++)\n    dl[i]= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n  for (i= 0; i < plugin_dl_array.elements; i++)\n    free_plugin_mem(dl[i]);\n  my_afree(dl);\n  delete_dynamic(&plugin_dl_array);\n\n  my_hash_free(&bookmark_hash);\n  free_root(&plugin_mem_root, MYF(0));\n\n  global_variables_dynamic_size= 0;\n\n  DBUG_VOID_RETURN;\n}\n\n\nbool mysql_install_plugin(THD *thd, const LEX_STRING *name, const LEX_STRING *dl)\n{\n  TABLE_LIST tables;\n  TABLE *table;\n  int error, argc=orig_argc;\n  char **argv=orig_argv;\n  struct st_plugin_int *tmp;\n  DBUG_ENTER(\"mysql_install_plugin\");\n\n  if (opt_noacl)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"--skip-grant-tables\");\n    DBUG_RETURN(TRUE);\n  }\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n  if (check_table_access(thd, INSERT_ACL, &tables, FALSE, 1, FALSE))\n    DBUG_RETURN(TRUE);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table = open_ltable(thd, &tables, TL_WRITE,\n                             MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(TRUE);\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n  */\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  DEBUG_SYNC(thd, \"acquired_LOCK_plugin\");\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n\n  if (my_load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv, NULL))\n  {\n    report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name->str);\n    goto err;\n  }\n  error= plugin_add(thd->mem_root, name, dl, &argc, argv, REPORT_TO_USER);\n  if (argv)\n    free_defaults(argv);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n\n  if (error || !(tmp= plugin_find_internal(name, MYSQL_ANY_PLUGIN)))\n    goto err;\n\n  if (tmp->state == PLUGIN_IS_DISABLED)\n  {\n    push_warning_printf(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                        ER_CANT_INITIALIZE_UDF, ER(ER_CANT_INITIALIZE_UDF),\n                        name->str, \"Plugin is disabled\");\n  }\n  else\n  {\n    if (plugin_initialize(tmp))\n    {\n      mysql_mutex_unlock(&LOCK_plugin);\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0), name->str,\n               \"Plugin initialization function failed.\");\n      goto deinit;\n    }\n  }\n\n  /*\n    We do not replicate the INSTALL PLUGIN statement. Disable binlogging\n    of the insert into the plugin table, so that it is not replicated in\n    row based mode.\n  */\n  mysql_mutex_unlock(&LOCK_plugin);\n  tmp_disable_binlog(thd);\n  table->use_all_columns();\n  restore_record(table, s->default_values);\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  table->field[1]->store(dl->str, dl->length, files_charset_info);\n  error= table->file->ha_write_row(table->record[0]);\n  reenable_binlog(thd);\n  if (error)\n  {\n    table->file->print_error(error, MYF(0));\n    goto deinit;\n  }\n  DBUG_RETURN(FALSE);\ndeinit:\n  mysql_mutex_lock(&LOCK_plugin);\n  tmp->state= PLUGIN_IS_DELETED;\n  reap_needed= true;\n  reap_plugins();\nerr:\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(TRUE);\n}\n\n\nbool mysql_uninstall_plugin(THD *thd, const LEX_STRING *name)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  struct st_plugin_int *plugin;\n  DBUG_ENTER(\"mysql_uninstall_plugin\");\n\n  if (opt_noacl)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"--skip-grant-tables\");\n    DBUG_RETURN(TRUE);\n  }\n\n  tables.init_one_table(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n\n  if (check_table_access(thd, DELETE_ACL, &tables, FALSE, 1, FALSE))\n    DBUG_RETURN(TRUE);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(TRUE);\n\n  if (!table->key_info)\n  {\n    my_printf_error(ER_UNKNOWN_ERROR,\n                    \"The table '%s.%s' does not have the necessary key(s) \"\n                    \"defined on it. Please check the table definition and \"\n                    \"create index(s) accordingly.\", MYF(0),\n                    table->s->db.str, table->s->table_name.str);\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n  */\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  if (!(plugin= plugin_find_internal(name, MYSQL_ANY_PLUGIN)) ||\n      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING))\n  {\n    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), \"PLUGIN\", name->str);\n    goto err;\n  }\n  if (!plugin->plugin_dl)\n  {\n    push_warning(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                 WARN_PLUGIN_DELETE_BUILTIN, ER(WARN_PLUGIN_DELETE_BUILTIN));\n    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), \"PLUGIN\", name->str);\n    goto err;\n  }\n  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n  {\n    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name->str);\n    goto err;\n  }\n  /*\n    Error message for ER_PLUGIN_IS_PERMANENT is not suitable for\n    plugins marked as not dynamically uninstallable, so we have a\n    separate one instead of changing the old one.\n   */\n  if (plugin->plugin->flags & PLUGIN_OPT_NO_UNINSTALL)\n  {\n    my_error(ER_PLUGIN_NO_UNINSTALL, MYF(0), plugin->plugin->name);\n    goto err;\n  }\n\n#ifdef HAVE_REPLICATION\n  /* Block Uninstallation of semi_sync plugins (Master/Slave)\n     when they are busy\n   */\n  char buff[20];\n  /*\n    Master: If there are active semi sync slaves for this Master,\n    then that means it is busy and rpl_semi_sync_master plugin\n    cannot be uninstalled. To check whether the master\n    has any semi sync slaves or not, check Rpl_semi_sync_master_cliens\n    status variable value, if it is not 0, that means it is busy.\n  */\n  if (!strcmp(name->str, \"rpl_semi_sync_master\") &&\n      get_status_var(thd,\n                     plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_master_clients\",buff) &&\n      strcmp(buff,\"0\") )\n  {\n    sql_print_error(\"Plugin 'rpl_semi_sync_master' cannot be uninstalled now. \"\n                    \"Stop any active semisynchronous slaves of this master \"\n                    \"first.\\n\");\n    my_error(ER_UNKNOWN_ERROR, MYF(0), name->str);\n    goto err;\n  }\n  /* Slave: If there is semi sync enabled IO thread active on this Slave,\n    then that means plugin is busy and rpl_semi_sync_slave plugin\n    cannot be uninstalled. To check whether semi sync\n    IO thread is active or not, check Rpl_semi_sync_slave_status status\n    variable value, if it is ON, that means it is busy.\n  */\n  if (!strcmp(name->str, \"rpl_semi_sync_slave\") &&\n      get_status_var(thd, plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_slave_status\", buff) &&\n      !strcmp(buff,\"ON\") )\n  {\n    sql_print_error(\"Plugin 'rpl_semi_sync_slave' cannot be uninstalled now. \"\n                    \"Stop any active semisynchronous I/O threads on this slave \"\n                    \"first.\\n\");\n    my_error(ER_UNKNOWN_ERROR, MYF(0), name->str);\n    goto err;\n  }\n#endif\n\n  plugin->state= PLUGIN_IS_DELETED;\n  if (plugin->ref_count)\n    push_warning(thd, MYSQL_ERROR::WARN_LEVEL_WARN,\n                 WARN_PLUGIN_BUSY, ER(WARN_PLUGIN_BUSY));\n  else\n    reap_needed= true;\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  uchar user_key[MAX_KEY_LENGTH];\n  table->use_all_columns();\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  key_copy(user_key, table->record[0], table->key_info,\n           table->key_info->key_length);\n  if (! table->file->index_read_idx_map(table->record[0], 0, user_key,\n                                        HA_WHOLE_KEY, HA_READ_KEY_EXACT))\n  {\n    int error;\n    /*\n      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging\n      of the delete from the plugin table, so that it is not replicated in\n      row based mode.\n    */\n    tmp_disable_binlog(thd);\n    error= table->file->ha_delete_row(table->record[0]);\n    reenable_binlog(thd);\n    if (error)\n    {\n      table->file->print_error(error, MYF(0));\n      DBUG_RETURN(TRUE);\n    }\n  }\n  DBUG_RETURN(FALSE);\nerr:\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(TRUE);\n}\n\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func *func,\n                       int type, uint state_mask, void *arg)\n{\n  uint idx, total;\n  struct st_plugin_int *plugin, **plugins;\n  int version=plugin_array_version;\n  DBUG_ENTER(\"plugin_foreach_with_mask\");\n\n  if (!initialized)\n    DBUG_RETURN(FALSE);\n\n  state_mask= ~state_mask; // do it only once\n\n  mysql_mutex_lock(&LOCK_plugin);\n  total= type == MYSQL_ANY_PLUGIN ? plugin_array.elements\n                                  : plugin_hash[type].records;\n  /*\n    Do the alloca out here in case we do have a working alloca:\n        leaving the nested stack frame invalidates alloca allocation.\n  */\n  plugins=(struct st_plugin_int **)my_alloca(total*sizeof(plugin));\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    for (idx= 0; idx < total; idx++)\n    {\n      plugin= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n      plugins[idx]= !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  }\n  else\n  {\n    HASH *hash= plugin_hash + type;\n    for (idx= 0; idx < total; idx++)\n    {\n      plugin= (struct st_plugin_int *) my_hash_element(hash, idx);\n      plugins[idx]= !(plugin->state & state_mask) ? plugin : NULL;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  for (idx= 0; idx < total; idx++)\n  {\n    if (unlikely(version != plugin_array_version))\n    {\n      mysql_mutex_lock(&LOCK_plugin);\n      for (uint i=idx; i < total; i++)\n        if (plugins[i] && plugins[i]->state & state_mask)\n          plugins[i]=0;\n      mysql_mutex_unlock(&LOCK_plugin);\n    }\n    plugin= plugins[idx];\n    /* It will stop iterating on first engine error when \"func\" returns TRUE */\n    if (plugin && func(thd, plugin_int_to_ref(plugin), arg))\n        goto err;\n  }\n\n  my_afree(plugins);\n  DBUG_RETURN(FALSE);\nerr:\n  my_afree(plugins);\n  DBUG_RETURN(TRUE);\n}\n\n\n/****************************************************************************\n  Internal type declarations for variables support\n****************************************************************************/\n\n#undef MYSQL_SYSVAR_NAME\n#define MYSQL_SYSVAR_NAME(name) name\n#define PLUGIN_VAR_TYPEMASK 0x007f\n\n#define EXTRA_OPTIONS 3 /* options for: 'foo', 'plugin-foo' and NULL */\n\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_str_t, char *);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_str_t, char *);\n\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_set_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_set_t, ulonglong);\n\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_int_t, int);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_long_t, long);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_uint_t, uint);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_double_t, double);\n\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_int_t, int);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_long_t, long);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_uint_t, uint);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_double_t, double);\n\n\n/****************************************************************************\n  default variable data check and update functions\n****************************************************************************/\n\nstatic int check_func_bool(THD *thd, struct st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int result, length;\n  long long tmp;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)) ||\n        (result= find_type(&bool_typelib, str, length, 1)-1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp) < 0)\n      goto err;\n    if (tmp > 1)\n      goto err;\n    result= (int) tmp;\n  }\n  *(my_bool *) save= -result;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_int(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(uint *)save= (uint) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(int *)save= (int) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\n\nstatic int check_func_long(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulong *)save= (ulong) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(long *)save= (long) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\n\nstatic int check_func_longlong(THD *thd, struct st_mysql_sys_var *var,\n                               void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulonglong *)save= getopt_ull_limit_value((ulonglong) val, &options,\n                                               &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(longlong *)save= getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\nstatic int check_func_str(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int length;\n\n  length= sizeof(buff);\n  if ((str= value->val_str(value, buff, &length)))\n    str= thd->strmake(str, length);\n  *(const char**)save= str;\n  return 0;\n}\n\n\nstatic int check_func_enum(THD *thd, struct st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  TYPELIB *typelib;\n  long long tmp;\n  long result;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_enum_t*) var)->typelib;\n  else\n    typelib= ((sysvar_enum_t*) var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    if ((result= (long)find_type(typelib, str, length, 0) - 1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp))\n      goto err;\n    if (tmp < 0 || tmp >= typelib->count)\n      goto err;\n    result= (long) tmp;\n  }\n  *(long*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_set(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE], *error= 0;\n  const char *str;\n  TYPELIB *typelib;\n  ulonglong result;\n  uint error_len= 0;                            // init as only set on error\n  bool not_used;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_set_t*) var)->typelib;\n  else\n    typelib= ((sysvar_set_t*)var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    result= find_set(typelib, str, length, NULL,\n                     &error, &error_len, &not_used);\n    if (error_len)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, (long long *)&result))\n      goto err;\n    if (unlikely((result >= (1ULL << typelib->count)) &&\n                 (typelib->count < sizeof(long)*8)))\n      goto err;\n  }\n  *(ulonglong*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\nstatic int check_func_double(THD *thd, struct st_mysql_sys_var *var,\n                             void *save, st_mysql_value *value)\n{\n  double v;\n  my_bool fixed;\n  struct my_option option;\n\n  value->val_real(value, &v);\n  plugin_opt_set_limits(&option, var);\n  *(double *) save= getopt_double_limit_value(v, &option, &fixed);\n\n  return throw_bounds_warning(thd, var->name, fixed, v);\n}\n\n\nstatic void update_func_bool(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(my_bool *) tgt= *(my_bool *) save ? TRUE : FALSE;\n}\n\n\nstatic void update_func_int(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(int *)tgt= *(int *) save;\n}\n\n\nstatic void update_func_long(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(long *)tgt= *(long *) save;\n}\n\n\nstatic void update_func_longlong(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(longlong *)tgt= *(ulonglong *) save;\n}\n\n\nstatic void update_func_str(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(char **) tgt= *(char **) save;\n}\n\nstatic void update_func_double(THD *thd, struct st_mysql_sys_var *var,\n                               void *tgt, const void *save)\n{\n  *(double *) tgt= *(double *) save;\n}\n\n/****************************************************************************\n  System Variables support\n****************************************************************************/\n\n\nsys_var *find_sys_var(THD *thd, const char *str, uint length)\n{\n  sys_var *var;\n  sys_var_pluginvar *pi= NULL;\n  plugin_ref plugin;\n  DBUG_ENTER(\"find_sys_var\");\n\n  mysql_mutex_lock(&LOCK_plugin);\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n  if ((var= intern_find_sys_var(str, length)) &&\n      (pi= var->cast_pluginvar()))\n  {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    LEX *lex= thd ? thd->lex : 0;\n    if (!(plugin= my_intern_plugin_lock(lex, plugin_int_to_ref(pi->plugin))))\n      var= NULL; /* failed to lock it, it must be uninstalling */\n    else\n    if (!(plugin_state(plugin) & PLUGIN_IS_READY))\n    {\n      /* initialization not completed */\n      var= NULL;\n      intern_plugin_unlock(lex, plugin);\n    }\n  }\n  else\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  if (!var)\n    my_error(ER_UNKNOWN_SYSTEM_VARIABLE, MYF(0), (char*) str);\n  DBUG_RETURN(var);\n}\n\n\n/*\n  called by register_var, construct_options and test_plugin_options.\n  Returns the 'bookmark' for the named variable.\n  LOCK_system_variables_hash should be at least read locked\n*/\nstatic st_bookmark *find_bookmark(const char *plugin, const char *name,\n                                  int flags)\n{\n  st_bookmark *result= NULL;\n  uint namelen, length, pluginlen= 0;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL))\n    return NULL;\n\n  namelen= strlen(name);\n  if (plugin)\n    pluginlen= strlen(plugin) + 1;\n  length= namelen + pluginlen + 2;\n  varname= (char*) my_alloca(length);\n\n  if (plugin)\n  {\n    strxmov(varname + 1, plugin, \"_\", name, NullS);\n    for (p= varname + 1; *p; p++)\n      if (*p == '-')\n        *p= '_';\n  }\n  else\n    memcpy(varname + 1, name, namelen + 1);\n\n  varname[0]= flags & PLUGIN_VAR_TYPEMASK;\n\n  result= (st_bookmark*) my_hash_search(&bookmark_hash,\n                                        (const uchar*) varname, length - 1);\n\n  my_afree(varname);\n  return result;\n}\n\n\n/*\n  returns a bookmark for thd-local variables, creating if neccessary.\n  returns null for non thd-local variables.\n  Requires that a write lock is obtained on LOCK_system_variables_hash\n*/\nstatic st_bookmark *register_var(const char *plugin, const char *name,\n                                 int flags)\n{\n  uint length= strlen(plugin) + strlen(name) + 3, size= 0, offset, new_size;\n  st_bookmark *result;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL))\n    return NULL;\n\n  switch (flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:\n    size= sizeof(my_bool);\n    break;\n  case PLUGIN_VAR_INT:\n    size= sizeof(int);\n    break;\n  case PLUGIN_VAR_LONG:\n  case PLUGIN_VAR_ENUM:\n    size= sizeof(long);\n    break;\n  case PLUGIN_VAR_LONGLONG:\n  case PLUGIN_VAR_SET:\n    size= sizeof(ulonglong);\n    break;\n  case PLUGIN_VAR_STR:\n    size= sizeof(char*);\n    break;\n  case PLUGIN_VAR_DOUBLE:\n    size= sizeof(double);\n    break;\n  default:\n    DBUG_ASSERT(0);\n    return NULL;\n  };\n\n  varname= ((char*) my_alloca(length));\n  strxmov(varname + 1, plugin, \"_\", name, NullS);\n  for (p= varname + 1; *p; p++)\n    if (*p == '-')\n      *p= '_';\n\n  if (!(result= find_bookmark(NULL, varname + 1, flags)))\n  {\n    result= (st_bookmark*) alloc_root(&plugin_mem_root,\n                                      sizeof(struct st_bookmark) + length-1);\n    varname[0]= flags & PLUGIN_VAR_TYPEMASK;\n    memcpy(result->key, varname, length);\n    result->name_len= length - 2;\n    result->offset= -1;\n\n    DBUG_ASSERT(size && !(size & (size-1))); /* must be power of 2 */\n\n    offset= global_system_variables.dynamic_variables_size;\n    offset= (offset + size - 1) & ~(size - 1);\n    result->offset= (int) offset;\n\n    new_size= (offset + size + 63) & ~63;\n\n    if (new_size > global_variables_dynamic_size)\n    {\n      global_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(global_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      max_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(max_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      /*\n        Clear the new variable value space. This is required for string\n        variables. If their value is non-NULL, it must point to a valid\n        string.\n      */\n      bzero(global_system_variables.dynamic_variables_ptr +\n            global_variables_dynamic_size,\n            new_size - global_variables_dynamic_size);\n      bzero(max_system_variables.dynamic_variables_ptr +\n            global_variables_dynamic_size,\n            new_size - global_variables_dynamic_size);\n      global_variables_dynamic_size= new_size;\n    }\n\n    global_system_variables.dynamic_variables_head= offset;\n    max_system_variables.dynamic_variables_head= offset;\n    global_system_variables.dynamic_variables_size= offset + size;\n    max_system_variables.dynamic_variables_size= offset + size;\n    global_system_variables.dynamic_variables_version++;\n    max_system_variables.dynamic_variables_version++;\n\n    result->version= global_system_variables.dynamic_variables_version;\n\n    /* this should succeed because we have already checked if a dup exists */\n    if (my_hash_insert(&bookmark_hash, (uchar*) result))\n    {\n      fprintf(stderr, \"failed to add placeholder to hash\");\n      DBUG_ASSERT(0);\n    }\n  }\n  my_afree(varname);\n  return result;\n}\n\nstatic void restore_pluginvar_names(sys_var *first)\n{\n  for (sys_var *var= first; var; var= var->next)\n  {\n    sys_var_pluginvar *pv= var->cast_pluginvar();\n    pv->plugin_var->name= pv->orig_pluginvar_name;\n  }\n}\n\n\n/*\n  returns a pointer to the memory which holds the thd-local variable or\n  a pointer to the global variable if thd==null.\n  If required, will sync with global variables if the requested variable\n  has not yet been allocated in the current thread.\n*/\nstatic uchar *intern_sys_var_ptr(THD* thd, int offset, bool global_lock)\n{\n  DBUG_ASSERT(offset >= 0);\n  DBUG_ASSERT((uint)offset <= global_system_variables.dynamic_variables_head);\n\n  if (!thd)\n    return (uchar*) global_system_variables.dynamic_variables_ptr + offset;\n\n  /*\n    dynamic_variables_head points to the largest valid offset\n  */\n  if (!thd->variables.dynamic_variables_ptr ||\n      (uint)offset > thd->variables.dynamic_variables_head)\n  {\n    uint idx;\n\n    mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n\n    thd->variables.dynamic_variables_ptr= (char*)\n      my_realloc(thd->variables.dynamic_variables_ptr,\n                 global_variables_dynamic_size,\n                 MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n\n    if (global_lock)\n      mysql_mutex_lock(&LOCK_global_system_variables);\n\n    mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n    memcpy(thd->variables.dynamic_variables_ptr +\n             thd->variables.dynamic_variables_size,\n           global_system_variables.dynamic_variables_ptr +\n             thd->variables.dynamic_variables_size,\n           global_system_variables.dynamic_variables_size -\n             thd->variables.dynamic_variables_size);\n\n    /*\n      now we need to iterate through any newly copied 'defaults'\n      and if it is a string type with MEMALLOC flag, we need to strdup\n    */\n    for (idx= 0; idx < bookmark_hash.records; idx++)\n    {\n      sys_var_pluginvar *pi;\n      sys_var *var;\n      st_bookmark *v= (st_bookmark*) my_hash_element(&bookmark_hash,idx);\n\n      if (v->version <= thd->variables.dynamic_variables_version ||\n          !(var= intern_find_sys_var(v->key + 1, v->name_len)) ||\n          !(pi= var->cast_pluginvar()) ||\n          v->key[0] != (pi->plugin_var->flags & PLUGIN_VAR_TYPEMASK))\n        continue;\n\n      /* Here we do anything special that may be required of the data types */\n\n      if ((pi->plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n          pi->plugin_var->flags & PLUGIN_VAR_MEMALLOC)\n      {\n         int varoff= *(int *) (pi->plugin_var + 1);\n         char **thdvar= (char **) (thd->variables.\n                                   dynamic_variables_ptr + varoff);\n         char **sysvar= (char **) (global_system_variables.\n                                   dynamic_variables_ptr + varoff);\n         *thdvar= NULL;\n         plugin_var_memalloc_session_update(thd, NULL, thdvar, *sysvar);\n      }\n    }\n\n    if (global_lock)\n      mysql_mutex_unlock(&LOCK_global_system_variables);\n\n    thd->variables.dynamic_variables_version=\n           global_system_variables.dynamic_variables_version;\n    thd->variables.dynamic_variables_head=\n           global_system_variables.dynamic_variables_head;\n    thd->variables.dynamic_variables_size=\n           global_system_variables.dynamic_variables_size;\n\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  }\n  return (uchar*)thd->variables.dynamic_variables_ptr + offset;\n}\n\n\n/**\n  For correctness and simplicity's sake, a pointer to a function\n  must be compatible with pointed-to type, that is, the return and\n  parameters types must be the same. Thus, a callback function is\n  defined for each scalar type. The functions are assigned in\n  construct_options to their respective types.\n*/\n\nstatic char *mysql_sys_var_char(THD* thd, int offset)\n{\n  return (char *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic int *mysql_sys_var_int(THD* thd, int offset)\n{\n  return (int *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long *mysql_sys_var_long(THD* thd, int offset)\n{\n  return (long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long *mysql_sys_var_ulong(THD* thd, int offset)\n{\n  return (unsigned long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long long *mysql_sys_var_longlong(THD* thd, int offset)\n{\n  return (long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long long *mysql_sys_var_ulonglong(THD* thd, int offset)\n{\n  return (unsigned long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic char **mysql_sys_var_str(THD* thd, int offset)\n{\n  return (char **) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic double *mysql_sys_var_double(THD* thd, int offset)\n{\n  return (double *) intern_sys_var_ptr(thd, offset, true);\n}\n\nvoid plugin_thdvar_init(THD *thd)\n{\n  plugin_ref old_table_plugin= thd->variables.table_plugin;\n  DBUG_ENTER(\"plugin_thdvar_init\");\n  \n  thd->variables.table_plugin= NULL;\n  cleanup_variables(thd, &thd->variables);\n  \n  thd->variables= global_system_variables;\n  thd->variables.table_plugin= NULL;\n\n  /* we are going to allocate these lazily */\n  thd->variables.dynamic_variables_version= 0;\n  thd->variables.dynamic_variables_size= 0;\n  thd->variables.dynamic_variables_ptr= 0;\n\n  mysql_mutex_lock(&LOCK_plugin);\n  thd->variables.table_plugin=\n        my_intern_plugin_lock(NULL, global_system_variables.table_plugin);\n  intern_plugin_unlock(NULL, old_table_plugin);\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Unlocks all system variables which hold a reference\n*/\nstatic void unlock_variables(THD *thd, struct system_variables *vars)\n{\n  intern_plugin_unlock(NULL, vars->table_plugin);\n  vars->table_plugin= NULL;\n}\n\n\n/*\n  Frees memory used by system variables\n\n  Unlike plugin_vars_free_values() it frees all variables of all plugins,\n  it's used on shutdown.\n*/\nstatic void cleanup_variables(THD *thd, struct system_variables *vars)\n{\n  if (thd)\n    plugin_var_memalloc_free(&thd->variables);\n\n  DBUG_ASSERT(vars->table_plugin == NULL);\n\n  my_free(vars->dynamic_variables_ptr);\n  vars->dynamic_variables_ptr= NULL;\n  vars->dynamic_variables_size= 0;\n  vars->dynamic_variables_version= 0;\n}\n\n\nvoid plugin_thdvar_cleanup(THD *thd)\n{\n  uint idx;\n  plugin_ref *list;\n  DBUG_ENTER(\"plugin_thdvar_cleanup\");\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  unlock_variables(thd, &thd->variables);\n  cleanup_variables(thd, &thd->variables);\n\n  if ((idx= thd->lex->plugins.elements))\n  {\n    list= ((plugin_ref*) thd->lex->plugins.buffer) + idx - 1;\n    DBUG_PRINT(\"info\",(\"unlocking %d plugins\", idx));\n    while ((uchar*) list >= thd->lex->plugins.buffer)\n      intern_plugin_unlock(NULL, *list--);\n  }\n\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  reset_dynamic(&thd->lex->plugins);\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  @brief Free values of thread variables of a plugin.\n\n  This must be called before a plugin is deleted. Otherwise its\n  variables are no longer accessible and the value space is lost. Note\n  that only string values with PLUGIN_VAR_MEMALLOC are allocated and\n  must be freed.\n\n  @param[in]        vars        Chain of system variables of a plugin\n*/\n\nstatic void plugin_vars_free_values(sys_var *vars)\n{\n  DBUG_ENTER(\"plugin_vars_free_values\");\n\n  for (sys_var *var= vars; var; var= var->next)\n  {\n    sys_var_pluginvar *piv= var->cast_pluginvar();\n    if (piv &&\n        ((piv->plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (piv->plugin_var->flags & PLUGIN_VAR_MEMALLOC))\n    {\n      /* Free the string from global_system_variables. */\n      char **valptr= (char**) piv->real_value_ptr(NULL, OPT_GLOBAL);\n      DBUG_PRINT(\"plugin\", (\"freeing value for: '%s'  addr: 0x%lx\",\n                            var->name.str, (long) valptr));\n      my_free(*valptr);\n      *valptr= NULL;\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n\nstatic SHOW_TYPE pluginvar_show_type(st_mysql_sys_var *plugin_var)\n{\n  switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:\n    return SHOW_MY_BOOL;\n  case PLUGIN_VAR_INT:\n    return SHOW_INT;\n  case PLUGIN_VAR_LONG:\n    return SHOW_LONG;\n  case PLUGIN_VAR_LONGLONG:\n    return SHOW_LONGLONG;\n  case PLUGIN_VAR_STR:\n    return SHOW_CHAR_PTR;\n  case PLUGIN_VAR_ENUM:\n  case PLUGIN_VAR_SET:\n    return SHOW_CHAR;\n  case PLUGIN_VAR_DOUBLE:\n    return SHOW_DOUBLE;\n  default:\n    DBUG_ASSERT(0);\n    return SHOW_UNDEF;\n  }\n}\n\n\n/**\n  Set value for thread local variable with PLUGIN_VAR_MEMALLOC flag.\n\n  @param[in]     thd   Thread context.\n  @param[in]     var   Plugin variable.\n  @param[in,out] dest  Destination memory pointer.\n  @param[in]     value '\\0'-terminated new value.\n\n  Most plugin variable values are stored on dynamic_variables_ptr.\n  Releasing memory occupied by these values is as simple as freeing\n  dynamic_variables_ptr.\n\n  An exception to the rule are PLUGIN_VAR_MEMALLOC variables, which\n  are stored on individual memory hunks. All of these hunks has to\n  be freed when it comes to cleanup.\n\n  It may happen that a plugin was uninstalled and descriptors of\n  it's variables are lost. In this case it is impossible to locate\n  corresponding values.\n\n  In addition to allocating and setting variable value, new element\n  is added to dynamic_variables_allocs list. When thread is done, it\n  has to call plugin_var_memalloc_free() to release memory used by\n  PLUGIN_VAR_MEMALLOC variables.\n\n  If var is NULL, variable update function is not called. This is\n  needed when we take snapshot of system variables during thread\n  initialization.\n\n  @note List element and variable value are stored on the same memory\n  hunk. List element is followed by variable value.\n\n  @return Completion status\n  @retval false Success\n  @retval true  Failure\n*/\n\nstatic bool plugin_var_memalloc_session_update(THD *thd,\n                                               struct st_mysql_sys_var *var,\n                                               char **dest, const char *value)\n\n{\n  LIST *old_element= NULL;\n  struct system_variables *vars= &thd->variables;\n  DBUG_ENTER(\"plugin_var_memalloc_session_update\");\n\n  if (value)\n  {\n    size_t length= strlen(value) + 1;\n    LIST *element;\n    if (!(element= (LIST *) my_malloc(sizeof(LIST) + length, MYF(MY_WME))))\n      DBUG_RETURN(true);\n    memcpy(element + 1, value, length);\n    value= (const char *) (element + 1);\n    vars->dynamic_variables_allocs= list_add(vars->dynamic_variables_allocs,\n                                             element);\n  }\n\n  if (*dest)\n    old_element= (LIST *) (*dest - sizeof(LIST));\n\n  if (var)\n    var->update(thd, var, (void **) dest, (const void *) &value);\n  else\n    *dest= (char *) value;\n\n  if (old_element)\n  {\n    vars->dynamic_variables_allocs= list_delete(vars->dynamic_variables_allocs,\n                                                old_element);\n    my_free(old_element);\n  }\n  DBUG_RETURN(false);\n}\n\n\n/**\n  Free all elements allocated by plugin_var_memalloc_session_update().\n\n  @param[in]     vars  system variables structure\n\n  @see plugin_var_memalloc_session_update\n*/\n\nstatic void plugin_var_memalloc_free(struct system_variables *vars)\n{\n  LIST *next, *root;\n  DBUG_ENTER(\"plugin_var_memalloc_free\");\n  for (root= vars->dynamic_variables_allocs; root; root= next)\n  {\n    next= root->next;\n    my_free(root);\n  }\n  vars->dynamic_variables_allocs= NULL;\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Set value for global variable with PLUGIN_VAR_MEMALLOC flag.\n\n  @param[in]     thd   Thread context.\n  @param[in]     var   Plugin variable.\n  @param[in,out] dest  Destination memory pointer.\n  @param[in]     value '\\0'-terminated new value.\n\n  @return Completion status\n  @retval false Success\n  @retval true  Failure\n*/\n\nstatic bool plugin_var_memalloc_global_update(THD *thd,\n                                              struct st_mysql_sys_var *var,\n                                              char **dest, const char *value)\n{\n  char *old_value= *dest;\n  DBUG_ENTER(\"plugin_var_memalloc_global_update\");\n\n  if (value && !(value= my_strdup(value, MYF(MY_WME))))\n    DBUG_RETURN(true);\n\n  var->update(thd, var, (void **) dest, (const void *) &value);\n\n  if (old_value)\n    my_free(old_value);\n\n  DBUG_RETURN(false);\n}\n\n\nbool sys_var_pluginvar::check_update_type(Item_result type)\n{\n  switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_INT:\n  case PLUGIN_VAR_LONG:\n  case PLUGIN_VAR_LONGLONG:\n    return type != INT_RESULT;\n  case PLUGIN_VAR_STR:\n    return type != STRING_RESULT;\n  case PLUGIN_VAR_ENUM:\n  case PLUGIN_VAR_BOOL:\n  case PLUGIN_VAR_SET:\n    return type != STRING_RESULT && type != INT_RESULT;\n  case PLUGIN_VAR_DOUBLE:\n    return type != INT_RESULT && type != REAL_RESULT && type != DECIMAL_RESULT;\n  default:\n    return true;\n  }\n}\n\n\nuchar* sys_var_pluginvar::real_value_ptr(THD *thd, enum_var_type type)\n{\n  DBUG_ASSERT(thd || (type == OPT_GLOBAL));\n  if (plugin_var->flags & PLUGIN_VAR_THDLOCAL)\n  {\n    if (type == OPT_GLOBAL)\n      thd= NULL;\n\n    return intern_sys_var_ptr(thd, *(int*) (plugin_var+1), false);\n  }\n  return *(uchar**) (plugin_var+1);\n}\n\n\nTYPELIB* sys_var_pluginvar::plugin_var_typelib(void)\n{\n  switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n  case PLUGIN_VAR_ENUM:\n    return ((sysvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET:\n    return ((sysvar_set_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_set_t *)plugin_var)->typelib;\n  default:\n    return NULL;\n  }\n  return NULL;\t/* Keep compiler happy */\n}\n\n\nuchar* sys_var_pluginvar::do_value_ptr(THD *thd, enum_var_type type,\n                                       LEX_STRING *base)\n{\n  uchar* result;\n\n  result= real_value_ptr(thd, type);\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_ENUM)\n    result= (uchar*) get_type(plugin_var_typelib(), *(ulong*)result);\n  else if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_SET)\n    result= (uchar*) set_to_string(thd, 0, *(ulonglong*) result,\n                                   plugin_var_typelib()->type_names);\n  return result;\n}\n\nbool sys_var_pluginvar::do_check(THD *thd, set_var *var)\n{\n  st_item_value_holder value;\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->check);\n\n  value.value_type= item_value_type;\n  value.val_str= item_val_str;\n  value.val_int= item_val_int;\n  value.val_real= item_val_real;\n  value.is_unsigned= item_is_unsigned;\n  value.item= var->value;\n\n  return plugin_var->check(thd, plugin_var, &var->save_result, &value);\n}\n\nbool sys_var_pluginvar::session_update(THD *thd, set_var *var)\n{\n  bool rc= false;\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->flags & PLUGIN_VAR_THDLOCAL);\n  DBUG_ASSERT(thd == current_thd);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  void *tgt= real_value_ptr(thd, var->type);\n  const void *src= var->value ? (void*)&var->save_result\n                              : (void*)real_value_ptr(thd, OPT_GLOBAL);\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n      plugin_var->flags & PLUGIN_VAR_MEMALLOC)\n    rc= plugin_var_memalloc_session_update(thd, plugin_var, (char **) tgt,\n                                           *(const char **) src);\n  else \n    plugin_var->update(thd, plugin_var, tgt, src);\n\n  return rc;\n}\n\nbool sys_var_pluginvar::global_update(THD *thd, set_var *var)\n{\n  bool rc= false;\n  DBUG_ASSERT(!is_readonly());\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  void *tgt= real_value_ptr(thd, var->type);\n  const void *src= &var->save_result;\n\n  if (!var->value)\n  {\n    switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n    case PLUGIN_VAR_INT:\n      src= &((sysvar_uint_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONG:\n      src= &((sysvar_ulong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      src= &((sysvar_ulonglong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_ENUM:\n      src= &((sysvar_enum_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_SET:\n      src= &((sysvar_set_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_BOOL:\n      src= &((sysvar_bool_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_STR:\n      src= &((sysvar_str_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      src= &((sysvar_double_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_uint_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_ulong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_ulonglong_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_enum_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_set_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_bool_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_str_t*) plugin_var)->def_val;\n      break;\n    case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n      src= &((thdvar_double_t*) plugin_var)->def_val;\n      break;\n    default:\n      DBUG_ASSERT(0);\n    }\n  }\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n      plugin_var->flags & PLUGIN_VAR_MEMALLOC)\n    rc= plugin_var_memalloc_global_update(thd, plugin_var, (char **) tgt,\n                                          *(const char **) src);\n  else \n    plugin_var->update(thd, plugin_var, tgt, src);\n\n  return rc;\n}\n\n\n#define OPTION_SET_LIMITS(type, options, opt) \\\n  options->var_type= type; \\\n  options->def_value= (opt)->def_val; \\\n  options->min_value= (opt)->min_val; \\\n  options->max_value= (opt)->max_val; \\\n  options->block_size= (long) (opt)->blk_sz\n\n#define OPTION_SET_LIMITS_DOUBLE(options, opt) \\\n  options->var_type= GET_DOUBLE; \\\n  options->def_value= (longlong) getopt_double2ulonglong((opt)->def_val); \\\n  options->min_value= (longlong) getopt_double2ulonglong((opt)->min_val); \\\n  options->max_value= getopt_double2ulonglong((opt)->max_val); \\\n  options->block_size= (long) (opt)->blk_sz;\n\n\nstatic void plugin_opt_set_limits(struct my_option *options,\n                                  const struct st_mysql_sys_var *opt)\n{\n  options->sub_size= 0;\n\n  switch (opt->flags & (PLUGIN_VAR_TYPEMASK |\n                        PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL)) {\n  /* global system variables */\n  case PLUGIN_VAR_INT:\n    OPTION_SET_LIMITS(GET_INT, options, (sysvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_UINT, options, (sysvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG:\n    OPTION_SET_LIMITS(GET_LONG, options, (sysvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULONG, options, (sysvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG:\n    OPTION_SET_LIMITS(GET_LL, options, (sysvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULL, options, (sysvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM:\n    options->var_type= GET_ENUM;\n    options->typelib= ((sysvar_enum_t*) opt)->typelib;\n    options->def_value= ((sysvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET:\n    options->var_type= GET_SET;\n    options->typelib= ((sysvar_set_t*) opt)->typelib;\n    options->def_value= ((sysvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((sysvar_bool_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_STR:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((sysvar_str_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_DOUBLE:\n    OPTION_SET_LIMITS_DOUBLE(options, (sysvar_double_t*) opt);\n    break;\n  /* threadlocal variables */\n  case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_INT, options, (thdvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_UINT, options, (thdvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LONG, options, (thdvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULONG, options, (thdvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LL, options, (thdvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULL, options, (thdvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS_DOUBLE(options, (thdvar_double_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_ENUM;\n    options->typelib= ((thdvar_enum_t*) opt)->typelib;\n    options->def_value= ((thdvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_SET;\n    options->typelib= ((thdvar_set_t*) opt)->typelib;\n    options->def_value= ((thdvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((thdvar_bool_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((thdvar_str_t*) opt)->def_val;\n    break;\n  default:\n    DBUG_ASSERT(0);\n  }\n  options->arg_type= REQUIRED_ARG;\n  if (opt->flags & PLUGIN_VAR_NOCMDARG)\n    options->arg_type= NO_ARG;\n  if (opt->flags & PLUGIN_VAR_OPCMDARG)\n    options->arg_type= OPT_ARG;\n}\n\nextern \"C\" my_bool get_one_plugin_option(int optid, const struct my_option *,\n                                         char *);\n\nmy_bool get_one_plugin_option(int optid __attribute__((unused)),\n                              const struct my_option *opt,\n                              char *argument)\n{\n  return 0;\n}\n\n\n/**\n  Creates a set of my_option objects associated with a specified plugin-\n  handle.\n\n  @param mem_root Memory allocator to be used.\n  @param tmp A pointer to a plugin handle\n  @param[out] options A pointer to a pre-allocated static array\n\n  The set is stored in the pre-allocated static array supplied to the function.\n  The size of the array is calculated as (number_of_plugin_varaibles*2+3). The\n  reason is that each option can have a prefix '--plugin-' in addtion to the\n  shorter form '--&lt;plugin-name&gt;'. There is also space allocated for\n  terminating NULL pointers.\n\n  @return\n    @retval -1 An error occurred\n    @retval 0 Success\n*/\n\nstatic int construct_options(MEM_ROOT *mem_root, struct st_plugin_int *tmp,\n                             my_option *options)\n{\n  const char *plugin_name= tmp->plugin->name;\n  const LEX_STRING plugin_dash = { C_STRING_WITH_LEN(\"plugin-\") };\n  uint plugin_name_len= strlen(plugin_name);\n  uint optnamelen;\n  const int max_comment_len= 180;\n  char *comment= (char *) alloc_root(mem_root, max_comment_len + 1);\n  char *optname;\n\n  int index= 0, offset= 0;\n  st_mysql_sys_var *opt, **plugin_option;\n  st_bookmark *v;\n\n  /** Used to circumvent the const attribute on my_option::name */\n  char *plugin_name_ptr, *plugin_name_with_prefix_ptr;\n\n  DBUG_ENTER(\"construct_options\");\n\n  plugin_name_ptr= (char*) alloc_root(mem_root, plugin_name_len + 1);\n  strcpy(plugin_name_ptr, plugin_name);\n  my_casedn_str(&my_charset_latin1, plugin_name_ptr);\n  convert_underscore_to_dash(plugin_name_ptr, plugin_name_len);\n  plugin_name_with_prefix_ptr= (char*) alloc_root(mem_root,\n                                                  plugin_name_len +\n                                                  plugin_dash.length + 1);\n  strxmov(plugin_name_with_prefix_ptr, plugin_dash.str, plugin_name_ptr, NullS);\n\n  if (tmp->load_option != PLUGIN_FORCE &&\n      tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n  {\n    /* support --skip-plugin-foo syntax */\n    options[0].name= plugin_name_ptr;\n    options[1].name= plugin_name_with_prefix_ptr;\n    options[0].id= options[1].id= 0;\n    options[0].var_type= options[1].var_type= GET_ENUM;\n    options[0].arg_type= options[1].arg_type= OPT_ARG;\n    options[0].def_value= options[1].def_value= 1; /* ON */\n    options[0].typelib= options[1].typelib= &global_plugin_typelib;\n\n    strxnmov(comment, max_comment_len, \"Enable or disable \", plugin_name,\n            \" plugin. Possible values are ON, OFF, FORCE (don't start \"\n            \"if the plugin fails to load).\", NullS);\n    options[0].comment= comment;\n    /*\n      Allocate temporary space for the value of the tristate.\n      This option will have a limited lifetime and is not used beyond\n      server initialization.\n      GET_ENUM value is an unsigned long integer.\n    */\n    options[0].value= options[1].value=\n                      (uchar **)alloc_root(mem_root, sizeof(ulong));\n    *((ulong*) options[0].value)= (ulong) options[0].def_value;\n\n    options+= 2;\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, plugin_name_ptr, \"NDBCLUSTER\"))\n  {\n    plugin_name_ptr= const_cast<char*>(\"ndb\"); // Use legacy \"ndb\" prefix\n    plugin_name_len= 3;\n  }\n\n  /*\n    Two passes as the 2nd pass will take pointer addresses for use\n    by my_getopt and register_var() in the first pass uses realloc\n  */\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    opt= *plugin_option;\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n      continue;\n    if (!(register_var(plugin_name_ptr, opt->name, opt->flags)))\n      continue;\n    switch (opt->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      ((thdvar_bool_t *) opt)->resolve= mysql_sys_var_char;\n      break;\n    case PLUGIN_VAR_INT:\n      ((thdvar_int_t *) opt)->resolve= mysql_sys_var_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      ((thdvar_long_t *) opt)->resolve= mysql_sys_var_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      ((thdvar_longlong_t *) opt)->resolve= mysql_sys_var_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      ((thdvar_str_t *) opt)->resolve= mysql_sys_var_str;\n      break;\n    case PLUGIN_VAR_ENUM:\n      ((thdvar_enum_t *) opt)->resolve= mysql_sys_var_ulong;\n      break;\n    case PLUGIN_VAR_SET:\n      ((thdvar_set_t *) opt)->resolve= mysql_sys_var_ulonglong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      ((thdvar_double_t *) opt)->resolve= mysql_sys_var_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    };\n  }\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    switch ((opt= *plugin_option)->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      if (!opt->check)\n        opt->check= check_func_bool;\n      if (!opt->update)\n        opt->update= update_func_bool;\n      break;\n    case PLUGIN_VAR_INT:\n      if (!opt->check)\n        opt->check= check_func_int;\n      if (!opt->update)\n        opt->update= update_func_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      if (!opt->check)\n        opt->check= check_func_long;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      if (!opt->check)\n        opt->check= check_func_longlong;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      if (!opt->check)\n        opt->check= check_func_str;\n      if (!opt->update)\n      {\n        opt->update= update_func_str;\n        if (!(opt->flags & (PLUGIN_VAR_MEMALLOC | PLUGIN_VAR_READONLY)))\n        {\n          opt->flags|= PLUGIN_VAR_READONLY;\n          sql_print_warning(\"Server variable %s of plugin %s was forced \"\n                            \"to be read-only: string variable without \"\n                            \"update_func and PLUGIN_VAR_MEMALLOC flag\",\n                            opt->name, plugin_name);\n        }\n      }\n      break;\n    case PLUGIN_VAR_ENUM:\n      if (!opt->check)\n        opt->check= check_func_enum;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_SET:\n      if (!opt->check)\n        opt->check= check_func_set;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      if (!opt->check)\n        opt->check= check_func_double;\n      if (!opt->update)\n        opt->update= update_func_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if ((opt->flags & (PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_THDLOCAL))\n                    == PLUGIN_VAR_NOCMDOPT)\n      continue;\n\n    if (!opt->name)\n    {\n      sql_print_error(\"Missing variable name in plugin '%s'.\",\n                      plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n    {\n      optnamelen= strlen(opt->name);\n      optname= (char*) alloc_root(mem_root, plugin_name_len + optnamelen + 2);\n      strxmov(optname, plugin_name_ptr, \"-\", opt->name, NullS);\n      optnamelen= plugin_name_len + optnamelen + 1;\n    }\n    else\n    {\n      /* this should not fail because register_var should create entry */\n      if (!(v= find_bookmark(plugin_name_ptr, opt->name, opt->flags)))\n      {\n        sql_print_error(\"Thread local variable '%s' not allocated \"\n                        \"in plugin '%s'.\", opt->name, plugin_name);\n        DBUG_RETURN(-1);\n      }\n\n      *(int*)(opt + 1)= offset= v->offset;\n\n      if (opt->flags & PLUGIN_VAR_NOCMDOPT)\n        continue;\n\n      optname= (char*) memdup_root(mem_root, v->key + 1, \n                                   (optnamelen= v->name_len) + 1);\n    }\n\n    convert_underscore_to_dash(optname, optnamelen);\n\n    options->name= optname;\n    options->comment= opt->comment;\n    options->app_type= opt;\n    options->id= 0;\n\n    plugin_opt_set_limits(options, opt);\n\n    if (opt->flags & PLUGIN_VAR_THDLOCAL)\n      options->value= options->u_max_value= (uchar**)\n        (global_system_variables.dynamic_variables_ptr + offset);\n    else\n      options->value= options->u_max_value= *(uchar***) (opt + 1);\n\n    char *option_name_ptr;\n    options[1]= options[0];\n    options[1].name= option_name_ptr= (char*) alloc_root(mem_root,\n                                                        plugin_dash.length +\n                                                        optnamelen + 1);\n    options[1].comment= 0; /* Hidden from the help text */\n    strxmov(option_name_ptr, plugin_dash.str, optname, NullS);\n\n    options+= 2;\n  }\n\n  DBUG_RETURN(0);\n}\n\n\nstatic my_option *construct_help_options(MEM_ROOT *mem_root,\n                                         struct st_plugin_int *p)\n{\n  st_mysql_sys_var **opt;\n  my_option *opts;\n  uint count= EXTRA_OPTIONS;\n  DBUG_ENTER(\"construct_help_options\");\n\n  for (opt= p->plugin->system_vars; opt && *opt; opt++, count+= 2)\n    ;\n\n  if (!(opts= (my_option*) alloc_root(mem_root, sizeof(my_option) * count)))\n    DBUG_RETURN(NULL);\n\n  bzero(opts, sizeof(my_option) * count);\n\n  /**\n    some plugin variables (those that don't have PLUGIN_VAR_NOSYSVAR flag)\n    have their names prefixed with the plugin name. Restore the names here\n    to get the correct (not double-prefixed) help text.\n    We won't need @@sysvars anymore and don't care about their proper names.\n  */\n  restore_pluginvar_names(p->system_vars);\n\n  if (construct_options(mem_root, p, opts))\n    DBUG_RETURN(NULL);\n\n  DBUG_RETURN(opts);\n}\n\n/**\n  Create and register system variables supplied from the plugin and\n  assigns initial values from corresponding command line arguments.\n\n  @param tmp_root Temporary scratch space\n  @param[out] plugin Internal plugin structure\n  @param argc Number of command line arguments\n  @param argv Command line argument vector\n\n  The plugin will be updated with a policy on how to handle errors during\n  initialization.\n\n  @note Requires that a write-lock is held on LOCK_system_variables_hash\n\n  @return How initialization of the plugin should be handled.\n    @retval  0 Initialization should proceed.\n    @retval  1 Plugin is disabled.\n    @retval -1 An error has occurred.\n*/\n\nstatic int test_plugin_options(MEM_ROOT *tmp_root, struct st_plugin_int *tmp,\n                               int *argc, char **argv)\n{\n  struct sys_var_chain chain= { NULL, NULL };\n  bool disable_plugin;\n  enum_plugin_load_option plugin_load_option= tmp->load_option;\n\n  MEM_ROOT *mem_root= alloc_root_inited(&tmp->mem_root) ?\n                      &tmp->mem_root : &plugin_mem_root;\n  st_mysql_sys_var **opt;\n  my_option *opts= NULL;\n  LEX_STRING plugin_name;\n  char *varname;\n  int error;\n  sys_var *v __attribute__((unused));\n  struct st_bookmark *var;\n  uint len, count= EXTRA_OPTIONS;\n  DBUG_ENTER(\"test_plugin_options\");\n  DBUG_ASSERT(tmp->plugin && tmp->name.str);\n\n  /*\n    The 'federated' and 'ndbcluster' storage engines are always disabled by\n    default.\n  */\n  if (!(my_strcasecmp(&my_charset_latin1, tmp->name.str, \"federated\") &&\n      my_strcasecmp(&my_charset_latin1, tmp->name.str, \"ndbcluster\")))\n    plugin_load_option= PLUGIN_OFF;\n\n  for (opt= tmp->plugin->system_vars; opt && *opt; opt++)\n    count+= 2; /* --{plugin}-{optname} and --plugin-{plugin}-{optname} */\n\n  if (count > EXTRA_OPTIONS || (*argc > 1))\n  {\n    if (!(opts= (my_option*) alloc_root(tmp_root, sizeof(my_option) * count)))\n    {\n      sql_print_error(\"Out of memory for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n    bzero(opts, sizeof(my_option) * count);\n\n    if (construct_options(tmp_root, tmp, opts))\n    {\n      sql_print_error(\"Bad options for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n\n    /*\n      We adjust the default value to account for the hardcoded exceptions\n      we have set for the federated and ndbcluster storage engines.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      opts[0].def_value= opts[1].def_value= plugin_load_option;\n\n    error= handle_options(argc, &argv, opts, NULL);\n    (*argc)++; /* add back one for the program name */\n\n    if (error)\n    {\n       sql_print_error(\"Parsing options for plugin '%s' failed.\",\n                       tmp->name.str);\n       goto err;\n    }\n    /*\n     Set plugin loading policy from option value. First element in the option\n     list is always the <plugin name> option value.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      plugin_load_option= (enum_plugin_load_option) *(ulong*) opts[0].value;\n  }\n\n  disable_plugin= (plugin_load_option == PLUGIN_OFF);\n  tmp->load_option= plugin_load_option;\n\n  /*\n    If the plugin is disabled it should not be initialized.\n  */\n  if (disable_plugin)\n  {\n    if (global_system_variables.log_warnings)\n      sql_print_information(\"Plugin '%s' is disabled.\",\n                            tmp->name.str);\n    if (opts)\n      my_cleanup_options(opts);\n    DBUG_RETURN(1);\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, tmp->name.str, \"NDBCLUSTER\"))\n  {\n    plugin_name.str= const_cast<char*>(\"ndb\"); // Use legacy \"ndb\" prefix\n    plugin_name.length= 3;\n  }\n  else\n    plugin_name= tmp->name;\n\n  error= 1;\n  for (opt= tmp->plugin->system_vars; opt && *opt; opt++)\n  {\n    st_mysql_sys_var *o;\n    if (((o= *opt)->flags & PLUGIN_VAR_NOSYSVAR))\n      continue;\n    if ((var= find_bookmark(plugin_name.str, o->name, o->flags)))\n      v= new (mem_root) sys_var_pluginvar(&chain, var->key + 1, o);\n    else\n    {\n      len= plugin_name.length + strlen(o->name) + 2;\n      varname= (char*) alloc_root(mem_root, len);\n      strxmov(varname, plugin_name.str, \"-\", o->name, NullS);\n      my_casedn_str(&my_charset_latin1, varname);\n      convert_dash_to_underscore(varname, len-1);\n      v= new (mem_root) sys_var_pluginvar(&chain, varname, o);\n    }\n    DBUG_ASSERT(v); /* check that an object was actually constructed */\n  } /* end for */\n  if (chain.first)\n  {\n    chain.last->next = NULL;\n    if (mysql_add_sys_var_chain(chain.first))\n    {\n      sql_print_error(\"Plugin '%s' has conflicting system variables\",\n                      tmp->name.str);\n      goto err;\n    }\n    tmp->system_vars= chain.first;\n  }\n  DBUG_RETURN(0);\n  \nerr:\n  if (opts)\n    my_cleanup_options(opts);\n  DBUG_RETURN(error);\n}\n\n\n/****************************************************************************\n  Help Verbose text with Plugin System Variables\n****************************************************************************/\n\n\nvoid add_plugin_options(DYNAMIC_ARRAY *options, MEM_ROOT *mem_root)\n{\n  struct st_plugin_int *p;\n  my_option *opt;\n\n  if (!initialized)\n    return;\n\n  for (uint idx= 0; idx < plugin_array.elements; idx++)\n  {\n    p= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n\n    if (!(opt= construct_help_options(mem_root, p)))\n      continue;\n\n    /* Only options with a non-NULL comment are displayed in help text */\n    for (;opt->name; opt++)\n      if (opt->comment)\n        insert_dynamic(options, (uchar*) opt);\n  }\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/cmake/dtrace.cmake": "# Copyright (c) 2009, 2014, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; version 2 of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA \n\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND CMAKE_COMPILER_IS_GNUCXX\n  AND CMAKE_SIZEOF_VOID_P EQUAL 4)\n  IF(NOT DEFINED BUGGY_GCC_NO_DTRACE_MODULES)\n    EXECUTE_PROCESS(\n      COMMAND ${CMAKE_C_COMPILER} ${CMAKE_C_COMPILER_ARG1}  --version\n      OUTPUT_VARIABLE out)\n    IF(out MATCHES \"3.4.6\")\n     # This gcc causes crashes in dlopen() for dtraced shared libs,\n     # while standard shipped with Solaris10 3.4.3 is ok\n     SET(BUGGY_GCC_NO_DTRACE_MODULES 1 CACHE INTERNAL \"\")\n    ELSE()\n     SET(BUGGY_GCC_NO_DTRACE_MODULES 0 CACHE INTERNAL \"\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n# Check if OS supports DTrace\nMACRO(CHECK_DTRACE)\n FIND_PROGRAM(DTRACE dtrace)\n MARK_AS_ADVANCED(DTRACE)\n\n # On FreeBSD, dtrace does not handle userland tracing yet\n IF(DTRACE AND NOT CMAKE_SYSTEM_NAME MATCHES \"FreeBSD\"\n     AND NOT BUGGY_GCC_NO_DTRACE_MODULES)\n   # 5.5 not able to do Sun dtrace on linux, just disable it\n   EXECUTE_PROCESS(\n     COMMAND ${DTRACE} -V\n     OUTPUT_VARIABLE out)\n   IF(out MATCHES \"Sun D\" AND CMAKE_SYSTEM_NAME MATCHES \"Linux\")\n     SET(ENABLE_DTRACE OFF CACHE BOOL \"Sun DTrace on Linux not supported\")\n   ELSE()\n     SET(ENABLE_DTRACE ON CACHE BOOL \"Enable dtrace\")\n   ENDIF()\n ENDIF()\n SET(HAVE_DTRACE ${ENABLE_DTRACE})\n IF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\")\n   IF(CMAKE_SIZEOF_VOID_P EQUAL 4)\n     SET(DTRACE_FLAGS -32 CACHE INTERNAL \"DTrace architecture flags\")\n   ELSE()\n     SET(DTRACE_FLAGS -64 CACHE INTERNAL \"DTrace architecture flags\")\n   ENDIF()\n ENDIF()\nENDMACRO()\n\nCHECK_DTRACE()\n\n# Produce a header file  with\n# DTrace macros\nMACRO (DTRACE_HEADER provider header header_no_dtrace)\n IF(ENABLE_DTRACE)\n ADD_CUSTOM_COMMAND(\n   OUTPUT  ${header} ${header_no_dtrace}\n   COMMAND ${DTRACE} -h -s ${provider} -o ${header}\n   COMMAND perl ${CMAKE_SOURCE_DIR}/scripts/dheadgen.pl -f ${provider} > ${header_no_dtrace}\n   DEPENDS ${provider}\n )\n ENDIF()\nENDMACRO()\n\n\n# Create provider headers\nIF(ENABLE_DTRACE)\n  CONFIGURE_FILE(${CMAKE_SOURCE_DIR}/include/probes_mysql.d.base \n    ${CMAKE_BINARY_DIR}/include/probes_mysql.d COPYONLY)\n  DTRACE_HEADER(\n   ${CMAKE_BINARY_DIR}/include/probes_mysql.d \n   ${CMAKE_BINARY_DIR}/include/probes_mysql_dtrace.h\n   ${CMAKE_BINARY_DIR}/include/probes_mysql_nodtrace.h\n  )\n  ADD_CUSTOM_TARGET(gen_dtrace_header\n  DEPENDS  \n  ${CMAKE_BINARY_DIR}/include/probes_mysql.d\n  ${CMAKE_BINARY_DIR}/include/probes_mysql_dtrace.h\n  ${CMAKE_BINARY_DIR}/include/probes_mysql_nodtrace.h\n  ) \nENDIF()\n\nFUNCTION(DTRACE_INSTRUMENT target)\n  IF(BUGGY_GCC_NO_DTRACE_MODULES)\n    GET_TARGET_PROPERTY(target_type ${target} TYPE)\n    IF(target_type MATCHES \"MODULE_LIBRARY\")\n      RETURN()\n    ENDIF()\n  ENDIF()\n  IF(ENABLE_DTRACE)\n    ADD_DEPENDENCIES(${target} gen_dtrace_header)\n\n    # Invoke dtrace to generate object file and link it together with target.\n    IF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\")\n      SET(objdir ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/${target}.dir)\n      SET(outfile ${objdir}/${target}_dtrace.o)\n      GET_TARGET_PROPERTY(target_type ${target} TYPE)\n      ADD_CUSTOM_COMMAND(\n        TARGET ${target} PRE_LINK \n        COMMAND ${CMAKE_COMMAND}\n          -DDTRACE=${DTRACE}\t  \n          -DOUTFILE=${outfile} \n          -DDFILE=${CMAKE_BINARY_DIR}/include/probes_mysql.d\n          -DDTRACE_FLAGS=${DTRACE_FLAGS}\n          -DDIRS=.\n          -DTYPE=${target_type}\n          -P ${CMAKE_SOURCE_DIR}/cmake/dtrace_prelink.cmake\n        WORKING_DIRECTORY ${objdir}\n      )\n    ELSEIF(CMAKE_SYSTEM_NAME MATCHES \"Linux\")\n      # dtrace on Linux runs gcc and uses flags from environment\n      SET(CFLAGS_SAVED $ENV{CFLAGS})\n      SET(ENV{CFLAGS} ${CMAKE_C_FLAGS})\n      SET(outfile \"${CMAKE_BINARY_DIR}/probes_mysql.o\")\n      # Systemtap object\n      EXECUTE_PROCESS(\n        COMMAND ${DTRACE} -G -s ${CMAKE_SOURCE_DIR}/include/probes_mysql.d.base\n        -o ${outfile}\n        )\n      SET(ENV{CFLAGS} ${CFLAGS_SAVED})\n    ENDIF()\n\n    # Do not try to extend the library if we have not built the .o file\n    IF(outfile)\n      # Add full  object path to linker flags\n      GET_TARGET_PROPERTY(target_type ${target} TYPE)\n      IF(NOT target_type MATCHES \"STATIC\")\n        SET_TARGET_PROPERTIES(${target} PROPERTIES LINK_FLAGS \"${outfile}\")\n      ELSE()\n        # For static library flags, add the object to the library.\n        # Note: DTrace probes in static libraries are  unusable currently \n        # (see explanation for DTRACE_INSTRUMENT_STATIC_LIBS below)\n        # but maybe one day this will be fixed.\n        GET_TARGET_PROPERTY(target_location ${target} LOCATION)\n        ADD_CUSTOM_COMMAND(\n          TARGET ${target} POST_BUILD\n          COMMAND ${CMAKE_AR} r  ${target_location} ${outfile}\n\t  COMMAND ${CMAKE_RANLIB} ${target_location}\n          )\n        # Used in DTRACE_INSTRUMENT_WITH_STATIC_LIBS\n        SET(TARGET_OBJECT_DIRECTORY_${target}  ${objdir} CACHE INTERNAL \"\")\n      ENDIF()\n    ENDIF()\n  ENDIF()\nENDFUNCTION()\n\n\n# Ugly workaround for Solaris' DTrace inability to use probes\n# from static libraries, discussed e.g in this thread\n# (http://opensolaris.org/jive/thread.jspa?messageID=432454)\n# We have to collect all object files that may be instrumented\n# and go into the mysqld (also those that come from in static libs)\n# run them again through dtrace -G to generate an ELF file that links\n# to mysqld.\nMACRO (DTRACE_INSTRUMENT_STATIC_LIBS target libs)\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND ENABLE_DTRACE)\n  # Filter out non-static libraries in the list, if any\n  SET(static_libs)\n  FOREACH(lib ${libs})\n    GET_TARGET_PROPERTY(libtype ${lib} TYPE)\n    IF(libtype MATCHES STATIC_LIBRARY)\n      SET(static_libs ${static_libs} ${lib})\n    ENDIF()\n  ENDFOREACH()\n\n  FOREACH(lib ${static_libs})\n    SET(dirs ${dirs} ${TARGET_OBJECT_DIRECTORY_${lib}})\n  ENDFOREACH()\n\n  SET (obj ${CMAKE_CURRENT_BINARY_DIR}/${target}_dtrace_all.o)\n  ADD_CUSTOM_COMMAND(\n  OUTPUT ${obj}\n  DEPENDS ${static_libs}\n  COMMAND ${CMAKE_COMMAND}\n   -DDTRACE=${DTRACE}\t  \n   -DOUTFILE=${obj} \n   -DDFILE=${CMAKE_BINARY_DIR}/include/probes_mysql.d\n   -DDTRACE_FLAGS=${DTRACE_FLAGS}\n   \"-DDIRS=${dirs}\"\n   -DTYPE=MERGE\n   -P ${CMAKE_SOURCE_DIR}/cmake/dtrace_prelink.cmake\n   VERBATIM\n  )\n  ADD_CUSTOM_TARGET(${target}_dtrace_all  DEPENDS ${obj})\n  ADD_DEPENDENCIES(${target} ${target}_dtrace_all)\n  TARGET_LINK_LIBRARIES(${target} ${obj})\nENDIF()\nENDMACRO()\n",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/cmake/os/SunOS.cmake": "# Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; version 2 of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA \n\nINCLUDE(CheckSymbolExists)\nINCLUDE(CheckCSourceRuns)\nINCLUDE(CheckCSourceCompiles) \n\n# Enable 64 bit file offsets\nSET(_FILE_OFFSET_BITS 64)\n\n# Legacy option, without it  my_pthread is having problems\nADD_DEFINITIONS(-DHAVE_RWLOCK_T)\n\n# On  Solaris, use of intrinsics will screw the lib search logic\n# Force using -lm, so rint etc are found.\nSET(LIBM m)\n\n# CMake defined -lthread as thread flag. This crashes in dlopen \n# when trying to load plugins workaround with -lpthread\nSET(CMAKE_THREADS_LIBS_INIT -lpthread CACHE INTERNAL \"\" FORCE)\n\n# Solaris specific large page support\nCHECK_SYMBOL_EXISTS(MHA_MAPSIZE_VA sys/mman.h  HAVE_DECL_MHA_MAPSIZE_VA)\nIF(HAVE_DECL_MHA_MAPSIZE_VA)\n SET(HAVE_SOLARIS_LARGE_PAGES 1)\n SET(HAVE_LARGE_PAGE_OPTION 1)\nENDIF()\n\n\n# Solaris atomics\nCHECK_C_SOURCE_RUNS(\n \"\n #include  <atomic.h>\n  int main()\n  {\n    int foo = -10; int bar = 10;\n    int64_t foo64 = -10; int64_t bar64 = 10;\n    if (atomic_add_int_nv((uint_t *)&foo, bar) || foo)\n      return -1;\n    bar = atomic_swap_uint((uint_t *)&foo, (uint_t)bar);\n    if (bar || foo != 10)\n     return -1;\n    bar = atomic_cas_uint((uint_t *)&bar, (uint_t)foo, 15);\n    if (bar)\n      return -1;\n    if (atomic_add_64_nv((volatile uint64_t *)&foo64, bar64) || foo64)\n      return -1;\n    bar64 = atomic_swap_64((volatile uint64_t *)&foo64, (uint64_t)bar64);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64 = atomic_cas_64((volatile uint64_t *)&bar64, (uint_t)foo64, 15);\n    if (bar64)\n      return -1;\n    atomic_or_64((volatile uint64_t *)&bar64, 0);\n    return 0;\n  }\n\"  HAVE_SOLARIS_ATOMIC)\n\n\n# Check is special processor flag needs to be set on older GCC\n#that defaults to v8 sparc . Code here is taken from my_rdtsc.c \nIF(CMAKE_COMPILER_IS_GNUCC AND CMAKE_SIZEOF_VOID_P EQUAL 4\n  AND CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n  SET(SOURCE\n  \"\n  int main()\n  {\n     long high\\;\n     long low\\;\n    __asm __volatile__ (\\\"rd %%tick,%1\\; srlx %1,32,%0\\\" : \\\"=r\\\" ( high), \\\"=r\\\" (low))\\;\n    return 0\\;\n  } \")\n  CHECK_C_SOURCE_COMPILES(${SOURCE}  HAVE_SPARC32_TICK)\n  IF(NOT HAVE_SPARC32_TICK)\n    SET(CMAKE_REQUIRED_FLAGS \"-mcpu=v9\")\n    CHECK_C_SOURCE_COMPILES(${SOURCE}  HAVE_SPARC32_TICK_WITH_V9)\n    SET(CMAKE_REQUIRED_FLAGS)\n    IF(HAVE_SPARC32_TICK_WITH_V9)\n      SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -mcpu=v9\")\n      SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -mcpu=v9\")\n    ENDIF()\n  ENDIF()\nENDIF()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/innobase/include/ut0mem.h",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/innobase/include/os0file.h",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/innobase/os/os0file.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/common/util/getarg.cat3",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/ndbapi/NdbUtil.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/ndbapi/NdbUtil.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/kernel/blocks/new-block.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/kernel/blocks/dbtc/Dbtc.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/kernel/blocks/dbdih/Dbdih.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/kernel/blocks/dbdict/Slave_AddTable.sfl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/kernel/blocks/dbdict/Dbdict.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/sisci_api_md.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/SISCI_LIBRARY_WIN32.TXT",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/sisci_api.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/scilib_mt.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/scilib_md.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/scilib.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/external/WIN32.x86/sci/lib/sisci_api_mt.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/C++/Closed.ICO",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/C++/CPC_GUI.suo",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/C++/small.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/C++/CPC_GUI.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/C++/bmp00001.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/C++/toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/C++/Open.ICO",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/csharp/NDB_CPC.ncb",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/csharp/DATABASE.ICO",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/src/cw/cpcc-win32/csharp/App.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/include/ndbapi/NdbScanFilter.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/include/transporter/TransporterCallback.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/test/ndbapi/bank/BankLoad.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/test/src/NDBT_Tables.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/test/src/getarg.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/test/include/getarg.h",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/test/run-test/atrt-example.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/test/odbc/driver/testOdbcDriver.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/storage/ndb/test/odbc/client/SQLPrepareTest.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql-bench/server-cfg.sh",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql-bench/crash-me.sh",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql-bench/limits/mysql-4.0.cfg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql-bench/limits/mysql-4.1.cfg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql-bench/Comments/postgres.benchmark",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/strings/decimal.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/strings/string.doc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/strings/ctype-latin1.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/strings/ctype-czech.c",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/packaging/WiX/AdminBackground.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/packaging/WiX/AdminHeader.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/packaging/WiX/MySQLServer.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/tests/fork2_test.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/tests/function.tst",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/tests/function.res",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/extra/yassl/taocrypt/benchmark/dsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/extra/yassl/taocrypt/benchmark/rsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/extra/yassl/taocrypt/benchmark/dh1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/extra/yassl/taocrypt/certs/client-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/extra/yassl/taocrypt/certs/client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/extra/yassl/taocrypt/certs/dsa512.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/extra/yassl/certs/client-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/extra/yassl/certs/dsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/extra/yassl/certs/client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug37631.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug49823.CSM",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/corrupt-relay-bin.000624",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/old_table-323.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug49823.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/14897.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/loaddata6.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug11747416_32228_binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/cluster_7022_table.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug16266.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug47205.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug48265.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug47142_master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug46565.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug47012.ARM",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug19371.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/corrupt_t1#P#p1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug47012.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/cluster_7022_table.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug33029-slave-relay-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/binlog_savepoint.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug36055.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/trunc_binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/binlog_transaction.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug47012.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug37631.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/corrupt_t1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug36055.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug19371.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug40482-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug36055.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug19371.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/vchar.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/bug46565.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_3.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1TIMESTAMP.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p1_first_1024.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1_blackhole.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p3.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p4.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51_data_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup50/BACKUP-2.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/std_data/ndb_backup51/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/include/ctype_utf8mb4.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/rpl/r/rpl_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/rpl/r/rpl_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/rpl/r/rpl_set_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/rpl/t/rpl_row_mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/rpl/t/rpl_set_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/rpl/t/rpl_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/rpl/t/rpl_temporary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-telco.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_17.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_r.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_s.001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/std_data/binlog_old_version_4_1.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/r/binlog_stm_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/r/binlog_row_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/binlog/t/binlog_mysqlbinlog-cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/funcs_1/lib/DataGen_local.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/funcs_1/r/memory_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/funcs_1/r/innodb_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/funcs_1/r/myisam_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0208_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0212_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0201_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0208_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis3.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0201_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0212_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/std_data/jisx0201_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/include/trim_sjis.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_rtrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_join_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_alter_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_join_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_create_db_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_trim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_join_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_ps_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_reverse_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_substring_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_insert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_replace_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_replace_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_trim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_substring_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_charlength_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_subquery_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_reverse_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_select_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_length_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_where_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_subquery_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_create_db_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_convert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_insert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_like_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_union_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_convert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_right_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_trim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_reverse_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_substring_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_subquery_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_update_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_alter_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_enum_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_like_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_replace_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_left_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_update_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_instr_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_alter_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_convert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_length_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_ps_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_like_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_locate_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_charlength_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_rtrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_enum_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_right_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_create_db_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_enum_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_lpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_charlength_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_left_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_charset_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_rpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_left_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_locate_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_charset_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_lpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_ltrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_select_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_rtrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_select_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_where_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_lpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_create_tbl_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_update_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_locate_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_instr_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_where_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_rpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_instr_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_insert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_ltrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_rpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_length_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_right_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/r/jp_ltrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_rpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_ps_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_left_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_alter_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_ps_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_charset_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_create_db_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_insert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_join_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_enum_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_charlength_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_instr_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_update_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_substring_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_subquery_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_reverse_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_locate_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_create_tbl_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_locate_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_where_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_insert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_join_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_union_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_instr_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_substring_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_subquery_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_convert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_replace_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_like_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_left_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_select_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_enum_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_enum_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_join_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_length_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_insert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_select_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_length_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_right_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_reverse_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_instr_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_alter_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_convert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_subquery_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_charlength_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_rtrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_convert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_ltrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_like_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_where_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_lpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_create_db_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_lpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_rpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_like_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_right_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_locate_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_length_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_right_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_select_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_reverse_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_update_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_left_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_rtrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_charset_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_ltrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_rpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_rtrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_ltrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_trim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_where_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_trim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_replace_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_create_db_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_substring_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_lpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_charlength_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_replace_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_alter_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/jp/t/jp_update_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_index.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_column.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_older_compatibility1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_column.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_older_compatibility1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/funcs/t/rpl_temporary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_index.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/iuds/r/strings_charsets_update_delete.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/engines/iuds/r/type_bit_iuds.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_big_tables_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/collation_database_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_log_bin_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_quote_show_create_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/character_set_results_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_warnings_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/collation_server_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/engine_condition_pushdown_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/pseudo_slave_mode_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_buffer_result_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_big_selects_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/collation_connection_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_low_priority_updates_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/innodb_table_locks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_notes_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/character_set_connection_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/character_set_client_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/query_cache_wlock_invalidate_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/character_set_client_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/innodb_support_xa_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_safe_updates_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/sql_log_off_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/r/foreign_key_checks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_big_tables_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_log_bin_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_warnings_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/engine_condition_pushdown_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_log_off_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_notes_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/character_set_results_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_buffer_result_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/character_set_client_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_safe_updates_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/character_set_connection_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_big_selects_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/collation_database_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/foreign_key_checks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_quote_show_create_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/innodb_table_locks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/collation_server_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/pseudo_slave_mode_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/sql_low_priority_updates_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/innodb_support_xa_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/query_cache_wlock_invalidate_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/suite/sys_vars/t/collation_connection_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/extra/binlog_tests/ctype_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/extra/rpl_tests/rpl_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_big5.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/alias.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_ucs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_utf8mb4_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_utf8mb4_heap.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/mysql_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/type_set.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/errors.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/show_check.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_utf8mb4.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/mysqldump.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/subselect2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/sp.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/cast.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_latin1_de.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/warnings.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/csv.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/query_cache.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/date_formats.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ddl_i18n_koi8r.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/binary.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/mysqltest.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ps.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_many.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/func_like.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_latin2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/rowid_order_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/type_decimal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/func_in.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_latin1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_utf8mb4_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/log_tables.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/union.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/func_test.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_recoding.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/explain.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_tis620.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/outfile_loaddata.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/events_bugs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/signal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ddl_i18n_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/alter_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/func_des_encrypt.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/type_enum.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/func_gconcat.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/ctype_cp1251.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/events_1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/r/grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/type_set.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_big5.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_latin1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/sp.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/union.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_ucs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/subselect2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/cast.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/warnings.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/query_cache.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/func_like.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/errors.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/events_bugs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/binary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/mysql_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/bug13633383.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_recoding.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/func_gconcat.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/alias.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_cp1251.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_latin1_de.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/events_1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/func_test.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/explain.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ps.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/func_in.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_utf8mb4.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_tis620.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/mysqldump.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/show_check.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ddl_i18n_koi8r.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/mysqltest.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/alter_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_many.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/type_decimal.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/log_tables.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/grant.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ctype_filesystem-master.opt",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/ddl_i18n_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/mysql-test/t/type_enum.test",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql/item_xmlfunc.cc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/sql/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/libmysqld/libmysqld.rc",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/libmysqld/examples/builder-sample/emb_samples.dfm",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/libmysqld/examples/builder-sample/snapshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/libmysqld/examples/builder-sample/images/logo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/libmysqld/examples/builder-sample/images/mysql.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/libmysqld/examples/builder-sample/images/db.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/libmysqld/examples/builder-sample/images/net.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mysql-5.5.62-ivwhpkiibguld4u3m4zuzxdjuh7h3moy/spack-src/libmysqld/examples/builder-sample/images/find.ico"
    ],
    "total_files": 9421
}