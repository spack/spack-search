{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/src/libawkward/kernel-dispatch.cpp": "// BSD 3-Clause License; see https://github.com/scikit-hep/awkward-1.0/blob/master/LICENSE\n\n#define FILENAME(line) FILENAME_FOR_EXCEPTIONS(\"src/libawkward/kernel-dispatch.cpp\", line)\n\n#include \"awkward/common.h\"\n#include \"awkward/util.h\"\n#include \"awkward/kernels/operations.h\"\n#include \"awkward/kernels/getitem.h\"\n#include \"awkward/kernels/identities.h\"\n#include \"awkward/kernels/reducers.h\"\n#include \"awkward/kernels/cuda-utils.h\"\n\n#include \"awkward/kernel-dispatch.h\"\n\n#define CREATE_KERNEL(libFnName, ptr_lib)          \\\n  auto handle = acquire_handle(ptr_lib);         \\\n  typedef decltype(libFnName) functor_type;      \\\n  auto* libFnName##_fcn =                        \\\n    reinterpret_cast<functor_type*>(acquire_symbol(handle, #libFnName));\n\nnamespace awkward {\n  namespace kernel {\n\n    std::shared_ptr<LibraryCallback> lib_callback =\n      std::make_shared<LibraryCallback>();\n\n    LibraryCallback::LibraryCallback() {\n      lib_path_callbacks[kernel::lib::cuda] =\n        std::vector<std::shared_ptr<LibraryPathCallback>>();\n    }\n\n    void LibraryCallback::add_library_path_callback(\n      kernel::lib ptr_lib,\n      const std::shared_ptr<LibraryPathCallback> &callback) {\n      std::lock_guard<std::mutex> lock(lib_path_callbacks_mutex);\n      lib_path_callbacks.at(ptr_lib).push_back(callback);\n    }\n\n    std::string LibraryCallback::awkward_library_path(kernel::lib ptr_lib) {\n#ifndef _MSC_VER\n      for (const auto& i : lib_path_callbacks.at(ptr_lib)) {\n        auto handle = dlopen(i->library_path().c_str(), RTLD_LAZY);\n        if (handle) {\n          return i->library_path();\n        }\n      }\n#endif\n      return std::string(\"\");\n    }\n\n    void* acquire_handle(kernel::lib ptr_lib) {\n#ifndef _MSC_VER\n      void *handle = nullptr;\n      std::string path = lib_callback->awkward_library_path(ptr_lib);\n      if (!path.empty()) {\n        handle = dlopen(path.c_str(), RTLD_LAZY);\n      }\n      if (!handle) {\n        if (ptr_lib == kernel::lib::cuda) {\n          throw std::invalid_argument(\n            std::string(\"array resides on a GPU, but 'awkward1-cuda-kernels' is not \"\n                        \"installed; install it with:\\n\\n    \"\n                        \"pip install awkward1[cuda] --upgrade\")\n            + FILENAME(__LINE__));\n        }\n        else {\n          throw std::runtime_error(\n            std::string(\"unrecognized ptr_lib in acquire_handle\")\n            + FILENAME(__LINE__));\n        }\n      }\n      return handle;\n#else\n      throw std::invalid_argument(\n          std::string(\"array resides on a GPU, but 'awkward1-cuda-kernels' is not\"\n                      \"supported on Windows\") + FILENAME(__LINE__));\n#endif\n    }\n\n    void *acquire_symbol(void* handle, const std::string& symbol_name) {\n      void *symbol_ptr = nullptr;\n#ifndef _MSC_VER\n      symbol_ptr = dlsym(handle, symbol_name.c_str());\n      if (!symbol_ptr) {\n        throw std::runtime_error(\n          symbol_name + std::string(\" not found in kernels library\")\n          + FILENAME(__LINE__));\n      }\n#endif\n      return symbol_ptr;\n    }\n\n    const std::string\n    lib_tostring(\n      kernel::lib ptr_lib,\n      void* ptr,\n      const std::string& indent,\n      const std::string& pre,\n      const std::string& post) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return std::string(\"\");\n      }\n\n      else if (ptr_lib == kernel::lib::cuda) {\n        int64_t num;\n        {\n          CREATE_KERNEL(awkward_cuda_ptr_device_num, ptr_lib);\n          struct Error err1 = (*awkward_cuda_ptr_device_num_fcn)(&num, ptr);\n          util::handle_error(err1);\n        }\n\n        char name[256];\n        CREATE_KERNEL(awkward_cuda_ptr_device_name, ptr_lib);\n        struct Error err2 = (*awkward_cuda_ptr_device_name_fcn)(name, ptr);\n        util::handle_error(err2);\n\n        std::stringstream out;\n        out << indent << pre << \"<Kernels lib=\\\"cuda\\\" device=\\\"\" << num\n            << \"\\\" device_name=\\\"\" << name << \"\\\"/>\" << post;\n        return out.str();\n      }\n\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in kernel::lib_tostring\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR copy_to(\n      kernel::lib to_lib,\n      kernel::lib from_lib,\n      void* to_ptr,\n      void* from_ptr,\n      int64_t bytelength) {\n      if (from_lib == lib::cpu  &&  to_lib == lib::cuda) {\n        CREATE_KERNEL(awkward_cuda_host_to_device, kernel::lib::cuda);\n        return (*awkward_cuda_host_to_device_fcn)(to_ptr, from_ptr, bytelength);\n      }\n      else if (from_lib == lib::cuda  &&  to_lib == lib::cpu) {\n        CREATE_KERNEL(awkward_cuda_device_to_host, kernel::lib::cuda);\n        return (*awkward_cuda_device_to_host_fcn)(to_ptr, from_ptr, bytelength);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized combination of from_lib and to_lib\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    const std::string\n    fully_qualified_cache_key(kernel::lib ptr_lib, const std::string& cache_key) {\n      switch (ptr_lib) {\n        case kernel::lib::cuda:\n          return cache_key + std::string(\":cuda\");\n        default:\n          return cache_key;\n      }\n    }\n\n  /////////////////////////////////// awkward/kernels/getitem.h\n\n    template<>\n    bool NumpyArray_getitem_at0(\n      kernel::lib ptr_lib,\n      bool *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArraybool_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArraybool_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArraybool_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in bool NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    int8_t NumpyArray_getitem_at0(\n      kernel::lib ptr_lib,\n      int8_t *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray8_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArray8_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArray8_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in int8_t NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    uint8_t NumpyArray_getitem_at0(\n      kernel::lib ptr_lib,\n      uint8_t *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArrayU8_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArrayU8_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArrayU8_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in uint8_t NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    int16_t NumpyArray_getitem_at0(\n      kernel::lib ptr_lib,\n      int16_t *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray16_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArray16_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArray16_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in int16_t NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    uint16_t NumpyArray_getitem_at0(\n      kernel::lib ptr_lib,\n      uint16_t *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArrayU16_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArrayU16_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArrayU16_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in uint16_t NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    int32_t NumpyArray_getitem_at0(\n      kernel::lib ptr_lib,\n      int32_t *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray32_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArray32_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArray32_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in int32_t NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    uint32_t NumpyArray_getitem_at0(\n      kernel::lib ptr_lib,\n      uint32_t *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArrayU32_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArrayU32_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArrayU32_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in uint32_t NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    int64_t NumpyArray_getitem_at0(\n        kernel::lib ptr_lib,\n        int64_t *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray64_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArray64_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArray64_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in int64_t NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    uint64_t NumpyArray_getitem_at0(\n        kernel::lib ptr_lib,\n        uint64_t *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArrayU64_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArrayU64_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArrayU64_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in uint64_t NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    float NumpyArray_getitem_at0(\n      kernel::lib ptr_lib,\n      float *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArrayfloat32_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArrayfloat32_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArrayfloat32_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in float NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    double NumpyArray_getitem_at0(\n      kernel::lib ptr_lib,\n      double *ptr) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArrayfloat64_getitem_at0(ptr);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArrayfloat64_getitem_at0, ptr_lib);\n        return (*awkward_NumpyArrayfloat64_getitem_at0_fcn)(ptr);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in double NumpyArray_getitem_at0\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    // FIXME: move regularize_rangeslice to common.h; it's not a kernel.\n    void regularize_rangeslice(\n      int64_t *start,\n      int64_t *stop,\n      bool posstep,\n      bool hasstart,\n      bool hasstop,\n      int64_t length) {\n      return awkward_regularize_rangeslice(\n        start,\n        stop,\n        posstep,\n        hasstart,\n        hasstop,\n        length);\n    }\n\n    ERROR regularize_arrayslice_64(\n      kernel::lib ptr_lib,\n      int64_t *flatheadptr,\n      int64_t lenflathead,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_regularize_arrayslice_64(\n          flatheadptr,\n          lenflathead,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for regularize_arrayslice_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for regularize_arrayslice_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_to_Index64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index8_to_Index64(\n          toptr,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index8_to_Index64, ptr_lib);\n        return (*awkward_Index8_to_Index64_fcn)(\n          toptr,\n          fromptr,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_to_Index64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_to_Index64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexU8_to_Index64(\n          toptr,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU8_to_Index64, ptr_lib);\n        return (*awkward_IndexU8_to_Index64_fcn)(\n          toptr,\n          fromptr,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_to_Index64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_to_Index64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index32_to_Index64(\n          toptr,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index32_to_Index64, ptr_lib);\n        return (*awkward_Index32_to_Index64_fcn)(\n          toptr,\n          fromptr,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_to_Index64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_to_Index64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexU32_to_Index64(\n          toptr,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU32_to_Index64, ptr_lib);\n        return (*awkward_IndexU32_to_Index64_fcn)(\n          toptr,\n          fromptr,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_to_Index64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_64<int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toindex,\n      const int8_t *fromindex,\n      const int64_t *carry,\n      int64_t lenfromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index8_carry_64(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index8_carry_64, ptr_lib);\n        return (*awkward_Index8_carry_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_64<uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toindex,\n      const uint8_t *fromindex,\n      const int64_t *carry,\n      int64_t lenfromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexU8_carry_64(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU8_carry_64, ptr_lib);\n        return (*awkward_IndexU8_carry_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_64<int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toindex,\n      const int32_t *fromindex,\n      const int64_t *carry,\n      int64_t lenfromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index32_carry_64(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index32_carry_64, ptr_lib);\n        return (*awkward_Index32_carry_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_64<uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toindex,\n      const uint32_t *fromindex,\n      const int64_t *carry,\n      int64_t lenfromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexU32_carry_64(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU32_carry_64, ptr_lib);\n        return (*awkward_IndexU32_carry_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *fromindex,\n      const int64_t *carry,\n      int64_t lenfromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index64_carry_64(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index64_carry_64, ptr_lib);\n        return (*awkward_Index64_carry_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          lenfromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_nocheck_64<int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toindex,\n      const int8_t *fromindex,\n      const int64_t *carry,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index8_carry_nocheck_64(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index8_carry_nocheck_64, ptr_lib);\n        return (*awkward_Index8_carry_nocheck_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_nocheck_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_nocheck_64<uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toindex,\n      const uint8_t *fromindex,\n      const int64_t *carry,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexU8_carry_nocheck_64(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU8_carry_nocheck_64, ptr_lib);\n        return (*awkward_IndexU8_carry_nocheck_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_nocheck_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_nocheck_64<int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toindex,\n      const int32_t *fromindex,\n      const int64_t *carry,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index32_carry_nocheck_64(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index32_carry_nocheck_64, ptr_lib);\n        return (*awkward_Index32_carry_nocheck_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_nocheck_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_nocheck_64<uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toindex,\n      const uint32_t *fromindex,\n      const int64_t *carry,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexU32_carry_nocheck_64(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU32_carry_nocheck_64, ptr_lib);\n        return (*awkward_IndexU32_carry_nocheck_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_nocheck_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Index_carry_nocheck_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *fromindex,\n      const int64_t *carry,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index64_carry_nocheck_64(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index64_carry_nocheck_64, ptr_lib);\n        return (*awkward_Index64_carry_nocheck_64_fcn)(\n          toindex,\n          fromindex,\n          carry,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Index_carry_nocheck_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR slicearray_ravel_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      int64_t ndim,\n      const int64_t *shape,\n      const int64_t *strides) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_slicearray_ravel_64(\n          toptr,\n          fromptr,\n          ndim,\n          shape,\n          strides);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for slicearray_ravel_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for slicearray_ravel_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR slicemissing_check_same(\n      kernel::lib ptr_lib,\n      bool *same,\n      const int8_t *bytemask,\n      const int64_t *missingindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_slicemissing_check_same(\n          same,\n          bytemask,\n          missingindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for slicemissing_check_same\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for slicemissing_check_same\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR carry_arange(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_carry_arange32(\n          toptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_carry_arange32, ptr_lib);\n        return (*awkward_carry_arange32_fcn)(\n          toptr,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for carry_arange\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR carry_arange(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_carry_arangeU32(\n          toptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_carry_arangeU32, ptr_lib);\n        return (*awkward_carry_arangeU32_fcn)(\n          toptr,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for carry_arange\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR carry_arange(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_carry_arange64(\n          toptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_carry_arange64, ptr_lib);\n        return (*awkward_carry_arange64_fcn)(\n          toptr,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for carry_arange\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_getitem_carry_64(\n      kernel::lib ptr_lib,\n      int32_t *newidentitiesptr,\n      const int32_t *identitiesptr,\n      const int64_t *carryptr,\n      int64_t lencarry,\n      int64_t width,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_getitem_carry_64(\n          newidentitiesptr,\n          identitiesptr,\n          carryptr,\n          lencarry,\n          width,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_getitem_carry_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_getitem_carry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_getitem_carry_64(\n      kernel::lib ptr_lib,\n      int64_t *newidentitiesptr,\n      const int64_t *identitiesptr,\n      const int64_t *carryptr,\n      int64_t lencarry,\n      int64_t width,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_getitem_carry_64(\n          newidentitiesptr,\n          identitiesptr,\n          carryptr,\n          lencarry,\n          width,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_getitem_carry_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_getitem_carry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_contiguous_init_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t skip,\n      int64_t stride) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_contiguous_init_64(\n          toptr,\n          skip,\n          stride);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArray_contiguous_init_64, ptr_lib);\n        return (*awkward_NumpyArray_contiguous_init_64_fcn)(\n          toptr,\n          skip,\n          stride);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_contiguous_init_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n\n    ERROR NumpyArray_contiguous_copy_64(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      const uint8_t *fromptr,\n      int64_t len,\n      int64_t stride,\n      const int64_t *pos) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_contiguous_copy_64(\n          toptr,\n          fromptr,\n          len,\n          stride,\n          pos);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_contiguous_copy_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_contiguous_copy_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_contiguous_next_64(\n      kernel::lib ptr_lib,\n      int64_t *topos,\n      const int64_t *frompos,\n      int64_t len,\n      int64_t skip,\n      int64_t stride) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_contiguous_next_64(\n          topos,\n          frompos,\n          len,\n          skip,\n          stride);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_contiguous_next_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_contiguous_next_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_getitem_next_null_64(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      const uint8_t *fromptr,\n      int64_t len,\n      int64_t stride,\n      const int64_t *pos) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_getitem_next_null_64(\n          toptr,\n          fromptr,\n          len,\n          stride,\n          pos);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_getitem_next_null_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_getitem_next_null_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_getitem_next_at_64(\n      kernel::lib ptr_lib,\n      int64_t *nextcarryptr,\n      const int64_t *carryptr,\n      int64_t lencarry,\n      int64_t skip,\n      int64_t at) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_getitem_next_at_64(\n          nextcarryptr,\n          carryptr,\n          lencarry,\n          skip,\n          at);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArray_getitem_next_at_64, ptr_lib);\n        return (*awkward_NumpyArray_getitem_next_at_64_fcn)(\n          nextcarryptr,\n          carryptr,\n          lencarry,\n          skip,\n          at);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_getitem_next_at_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_getitem_next_range_64(\n      kernel::lib ptr_lib,\n      int64_t *nextcarryptr,\n      const int64_t *carryptr,\n      int64_t lencarry,\n      int64_t lenhead,\n      int64_t skip,\n      int64_t start,\n      int64_t step) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_getitem_next_range_64(\n          nextcarryptr,\n          carryptr,\n          lencarry,\n          lenhead,\n          skip,\n          start,\n          step);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_getitem_next_range_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_getitem_next_range_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_getitem_next_range_advanced_64(\n      kernel::lib ptr_lib,\n      int64_t *nextcarryptr,\n      int64_t *nextadvancedptr,\n      const int64_t *carryptr,\n      const int64_t *advancedptr,\n      int64_t lencarry,\n      int64_t lenhead,\n      int64_t skip,\n      int64_t start,\n      int64_t step) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_getitem_next_range_advanced_64(\n          nextcarryptr,\n          nextadvancedptr,\n          carryptr,\n          advancedptr,\n          lencarry,\n          lenhead,\n          skip,\n          start,\n          step);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_getitem_next_range_advanced_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_getitem_next_range_advanced_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_getitem_next_array_64(\n      kernel::lib ptr_lib,\n      int64_t *nextcarryptr,\n      int64_t *nextadvancedptr,\n      const int64_t *carryptr,\n      const int64_t *flatheadptr,\n      int64_t lencarry,\n      int64_t lenflathead,\n      int64_t skip) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_getitem_next_array_64(\n          nextcarryptr,\n          nextadvancedptr,\n          carryptr,\n          flatheadptr,\n          lencarry,\n          lenflathead,\n          skip);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_getitem_next_array_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_getitem_next_array_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_getitem_next_array_advanced_64(\n      kernel::lib ptr_lib,\n      int64_t *nextcarryptr,\n      const int64_t *carryptr,\n      const int64_t *advancedptr,\n      const int64_t *flatheadptr,\n      int64_t lencarry,\n      int64_t skip) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_getitem_next_array_advanced_64(\n          nextcarryptr,\n          carryptr,\n          advancedptr,\n          flatheadptr,\n          lencarry,\n          skip);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_NumpyArray_getitem_next_array_advanced_64, ptr_lib);\n        return (*awkward_NumpyArray_getitem_next_array_advanced_64_fcn)(\n          nextcarryptr,\n          carryptr,\n          advancedptr,\n          flatheadptr,\n          lencarry,\n          skip);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_getitem_next_array_advanced_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_getitem_boolean_numtrue(\n      kernel::lib ptr_lib,\n      int64_t *numtrue,\n      const int8_t *fromptr,\n      int64_t length,\n      int64_t stride) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_getitem_boolean_numtrue(\n          numtrue,\n          fromptr,\n          length,\n          stride);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_getitem_boolean_numtrue\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_getitem_boolean_numtrue\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_getitem_boolean_nonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int8_t *fromptr,\n      int64_t length,\n      int64_t stride) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_getitem_boolean_nonzero_64(\n          toptr,\n          fromptr,\n          length,\n          stride);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_getitem_boolean_nonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_getitem_boolean_nonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_at_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t lenstarts,\n      int64_t at) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_getitem_next_at_64(\n          tocarry,\n          fromstarts,\n          fromstops,\n          lenstarts,\n          at);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_at_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_at_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_at_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t lenstarts,\n      int64_t at) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_getitem_next_at_64(\n          tocarry,\n          fromstarts,\n          fromstops,\n          lenstarts,\n          at);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_at_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_at_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_at_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t lenstarts,\n      int64_t at) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArray64_getitem_next_at_64(\n         tocarry,\n         fromstarts,\n         fromstops,\n         lenstarts,\n         at);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_at_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_at_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_next_range_carrylength<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *carrylength,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t lenstarts,\n      int64_t start,\n      int64_t stop,\n      int64_t step) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_getitem_next_range_carrylength(\n          carrylength,\n          fromstarts,\n          fromstops,\n          lenstarts,\n          start,\n          stop,\n          step);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_range_carrylength<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_carrylength<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_range_carrylength<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *carrylength,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t lenstarts,\n      int64_t start,\n      int64_t stop,\n      int64_t step) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArrayU32_getitem_next_range_carrylength(\n         carrylength,\n         fromstarts,\n         fromstops,\n         lenstarts,\n         start,\n         stop,\n         step);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_range_carrylength<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_carrylength<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_next_range_carrylength<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *carrylength,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t lenstarts,\n      int64_t start,\n      int64_t stop,\n      int64_t step) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_getitem_next_range_carrylength(\n          carrylength,\n          fromstarts,\n          fromstops,\n          lenstarts,\n          start,\n          stop,\n          step);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_range_carrylength<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_carrylength<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_range_64<int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *tooffsets,\n      int64_t *tocarry,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t lenstarts,\n      int64_t start,\n      int64_t stop,\n      int64_t step) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArray32_getitem_next_range_64(\n         tooffsets,\n         tocarry,\n         fromstarts,\n         fromstops,\n         lenstarts,\n         start,\n         stop,\n         step);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_range_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_next_range_64<uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *tooffsets,\n      int64_t *tocarry,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t lenstarts,\n      int64_t start,\n      int64_t stop,\n      int64_t step) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_getitem_next_range_64(\n          tooffsets,\n          tocarry,\n          fromstarts,\n          fromstops,\n          lenstarts,\n          start,\n          stop,\n          step);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_range_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_range_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      int64_t *tocarry,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t lenstarts,\n      int64_t start,\n      int64_t stop,\n      int64_t step) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_getitem_next_range_64(\n          tooffsets,\n          tocarry,\n          fromstarts,\n          fromstops,\n          lenstarts,\n          start,\n          stop,\n          step);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_range_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_range_counts_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *total,\n      const int32_t *fromoffsets,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_getitem_next_range_counts_64(\n          total,\n          fromoffsets,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArray32_getitem_next_range_counts_64, ptr_lib);\n        return (*awkward_ListArray32_getitem_next_range_counts_64_fcn)(\n          total,\n          fromoffsets,\n          lenstarts);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_counts_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_range_counts_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *total,\n      const uint32_t *fromoffsets,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_getitem_next_range_counts_64(\n          total,\n          fromoffsets,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArrayU32_getitem_next_range_counts_64, ptr_lib);\n        return (*awkward_ListArrayU32_getitem_next_range_counts_64_fcn)(\n          total,\n          fromoffsets,\n          lenstarts);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_counts_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_range_counts_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *total,\n      const int64_t *fromoffsets,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_getitem_next_range_counts_64(\n          total,\n          fromoffsets,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArray64_getitem_next_range_counts_64, ptr_lib);\n        return (*awkward_ListArray64_getitem_next_range_counts_64_fcn)(\n          total,\n          fromoffsets,\n          lenstarts);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_counts_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_range_spreadadvanced_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toadvanced,\n      const int64_t *fromadvanced,\n      const int32_t *fromoffsets,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArray32_getitem_next_range_spreadadvanced_64(\n         toadvanced,\n         fromadvanced,\n         fromoffsets,\n         lenstarts);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_range_spreadadvanced_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_spreadadvanced_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_next_range_spreadadvanced_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toadvanced,\n      const int64_t *fromadvanced,\n      const uint32_t *fromoffsets,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_getitem_next_range_spreadadvanced_64(\n          toadvanced,\n          fromadvanced,\n          fromoffsets,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_range_spreadadvanced_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_spreadadvanced_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_range_spreadadvanced_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toadvanced,\n      const int64_t *fromadvanced,\n      const int64_t *fromoffsets,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArray64_getitem_next_range_spreadadvanced_64(\n         toadvanced,\n         fromadvanced,\n         fromoffsets,\n         lenstarts);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_range_spreadadvanced_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_range_spreadadvanced_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_next_array_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toadvanced,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      const int64_t *fromarray,\n      int64_t lenstarts,\n      int64_t lenarray,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_getitem_next_array_64(\n          tocarry,\n          toadvanced,\n          fromstarts,\n          fromstops,\n          fromarray,\n          lenstarts,\n          lenarray,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_array_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_array_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_array_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toadvanced,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      const int64_t *fromarray,\n      int64_t lenstarts,\n      int64_t lenarray,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_getitem_next_array_64(\n          tocarry,\n          toadvanced,\n          fromstarts,\n          fromstops,\n          fromarray,\n          lenstarts,\n          lenarray,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_array_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_array_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_array_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toadvanced,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      const int64_t *fromarray,\n      int64_t lenstarts,\n      int64_t lenarray,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_getitem_next_array_64(\n          tocarry,\n          toadvanced,\n          fromstarts,\n          fromstops,\n          fromarray,\n          lenstarts,\n          lenarray,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_array_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_array_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_array_advanced_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toadvanced,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      const int64_t *fromarray,\n      const int64_t *fromadvanced,\n      int64_t lenstarts,\n      int64_t lenarray,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_getitem_next_array_advanced_64(\n          tocarry,\n          toadvanced,\n          fromstarts,\n          fromstops,\n          fromarray,\n          fromadvanced,\n          lenstarts,\n          lenarray,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_array_advanced_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_array_advanced_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_array_advanced_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toadvanced,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      const int64_t *fromarray,\n      const int64_t *fromadvanced,\n      int64_t lenstarts,\n      int64_t lenarray,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_getitem_next_array_advanced_64(\n          tocarry,\n          toadvanced,\n          fromstarts,\n          fromstops,\n          fromarray,\n          fromadvanced,\n          lenstarts,\n          lenarray,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_array_advanced_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_array_advanced_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_next_array_advanced_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toadvanced,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      const int64_t *fromarray,\n      const int64_t *fromadvanced,\n      int64_t lenstarts,\n      int64_t lenarray,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_getitem_next_array_advanced_64(\n          tocarry,\n          toadvanced,\n          fromstarts,\n          fromstops,\n          fromarray,\n          fromadvanced,\n          lenstarts,\n          lenarray,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_next_array_advanced_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_next_array_advanced_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_carry_64<int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *tostarts,\n      int32_t *tostops,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      const int64_t *fromcarry,\n      int64_t lenstarts,\n      int64_t lencarry) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_getitem_carry_64(\n          tostarts,\n          tostops,\n          fromstarts,\n          fromstops,\n          fromcarry,\n          lenstarts,\n          lencarry);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_carry_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_carry_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_carry_64<uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *tostarts,\n      uint32_t *tostops,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      const int64_t *fromcarry,\n      int64_t lenstarts,\n      int64_t lencarry) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArrayU32_getitem_carry_64(\n         tostarts,\n         tostops,\n         fromstarts,\n         fromstops,\n         fromcarry,\n         lenstarts,\n         lencarry);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_carry_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_carry_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_carry_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tostarts,\n      int64_t *tostops,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      const int64_t *fromcarry,\n      int64_t lenstarts,\n      int64_t lencarry) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_getitem_carry_64(\n          tostarts,\n          tostops,\n          fromstarts,\n          fromstops,\n          fromcarry,\n          lenstarts,\n          lencarry);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_carry_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_carry_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_getitem_next_at_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t at,\n      int64_t len,\n      int64_t size) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_getitem_next_at_64(\n          tocarry,\n          at,\n          len,\n          size);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_getitem_next_at_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_getitem_next_at_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_getitem_next_range_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t regular_start,\n      int64_t step,\n      int64_t len,\n      int64_t size,\n      int64_t nextsize) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_getitem_next_range_64(\n          tocarry,\n          regular_start,\n          step,\n          len,\n          size,\n          nextsize);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_getitem_next_range_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_getitem_next_range_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_getitem_next_range_spreadadvanced_64(\n      kernel::lib ptr_lib,\n      int64_t *toadvanced,\n      const int64_t *fromadvanced,\n      int64_t len,\n      int64_t nextsize) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_getitem_next_range_spreadadvanced_64(\n          toadvanced,\n          fromadvanced,\n          len,\n          nextsize);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_getitem_next_range_spreadadvanced_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_getitem_next_range_spreadadvanced_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_getitem_next_array_regularize_64(\n      kernel::lib ptr_lib,\n      int64_t *toarray,\n      const int64_t *fromarray,\n      int64_t lenarray,\n      int64_t size) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_getitem_next_array_regularize_64(\n          toarray,\n          fromarray,\n          lenarray,\n          size);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_getitem_next_array_regularize_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_getitem_next_array_regularize_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_getitem_next_array_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toadvanced,\n      const int64_t *fromarray,\n      int64_t len,\n      int64_t lenarray,\n      int64_t size) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_getitem_next_array_64(\n          tocarry,\n          toadvanced,\n          fromarray,\n          len,\n          lenarray,\n          size);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_getitem_next_array_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_getitem_next_array_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_getitem_next_array_advanced_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toadvanced,\n      const int64_t *fromadvanced,\n      const int64_t *fromarray,\n      int64_t len,\n      int64_t lenarray,\n      int64_t size) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_getitem_next_array_advanced_64(\n          tocarry,\n          toadvanced,\n          fromadvanced,\n          fromarray,\n          len,\n          lenarray,\n          size);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_RegularArray_getitem_next_array_advanced_64, ptr_lib);\n        return (*awkward_RegularArray_getitem_next_array_advanced_64_fcn)(\n          tocarry,\n          toadvanced,\n          fromadvanced,\n          fromarray,\n          len,\n          lenarray,\n          size);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_getitem_next_array_advanced_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_getitem_carry_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *fromcarry,\n      int64_t lencarry,\n      int64_t size) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_getitem_carry_64(\n          tocarry,\n          fromcarry,\n          lencarry,\n          size);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_getitem_carry_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_getitem_carry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_numnull<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *numnull,\n      const int32_t *fromindex,\n      int64_t lenindex) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_numnull(\n          numnull,\n          fromindex,\n          lenindex);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_numnull<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_numnull<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_numnull<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *numnull,\n      const uint32_t *fromindex,\n      int64_t lenindex) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_numnull(\n          numnull,\n          fromindex,\n          lenindex);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_numnull<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_numnull<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_numnull<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *numnull,\n      const int64_t *fromindex,\n      int64_t lenindex) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_numnull(\n          numnull,\n          fromindex,\n          lenindex);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_numnull<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_numnull<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_getitem_nextcarry_outindex_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int32_t *toindex,\n      const int32_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_IndexedArray32_getitem_nextcarry_outindex_64(\n         tocarry,\n         toindex,\n         fromindex,\n         lenindex,\n         lencontent);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_nextcarry_outindex_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_nextcarry_outindex_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR IndexedArray_getitem_nextcarry_outindex_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      uint32_t *toindex,\n      const uint32_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_getitem_nextcarry_outindex_64(\n          tocarry,\n          toindex,\n          fromindex,\n          lenindex,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_nextcarry_outindex_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_nextcarry_outindex_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_getitem_nextcarry_outindex_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toindex,\n      const int64_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_IndexedArray64_getitem_nextcarry_outindex_64(\n         tocarry,\n         toindex,\n         fromindex,\n         lenindex,\n         lencontent);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_nextcarry_outindex_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_nextcarry_outindex_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR IndexedArray_getitem_nextcarry_outindex_mask_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toindex,\n      const int32_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_getitem_nextcarry_outindex_mask_64(\n          tocarry,\n          toindex,\n          fromindex,\n          lenindex,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_nextcarry_outindex_mask_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_nextcarry_outindex_mask_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_getitem_nextcarry_outindex_mask_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toindex,\n      const uint32_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_IndexedArrayU32_getitem_nextcarry_outindex_mask_64(\n         tocarry,\n         toindex,\n         fromindex,\n         lenindex,\n         lencontent);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_nextcarry_outindex_mask_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_nextcarry_outindex_mask_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR IndexedArray_getitem_nextcarry_outindex_mask_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toindex,\n      const int64_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_getitem_nextcarry_outindex_mask_64(\n          tocarry,\n          toindex,\n          fromindex,\n          lenindex,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_nextcarry_outindex_mask_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_nextcarry_outindex_mask_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_getitem_adjust_offsets_64(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      int64_t *tononzero,\n      const int64_t *fromoffsets,\n      int64_t length,\n      const int64_t *nonzero,\n      int64_t nonzerolength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_getitem_adjust_offsets_64(\n          tooffsets,\n          tononzero,\n          fromoffsets,\n          length,\n          nonzero,\n          nonzerolength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_getitem_adjust_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_getitem_adjust_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_getitem_adjust_offsets_index_64(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      int64_t *tononzero,\n      const int64_t *fromoffsets,\n      int64_t length,\n      const int64_t *index,\n      int64_t indexlength,\n      const int64_t *nonzero,\n      int64_t nonzerolength,\n      const int8_t *originalmask,\n      int64_t masklength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_getitem_adjust_offsets_index_64(\n          tooffsets,\n          tononzero,\n          fromoffsets,\n          length,\n          index,\n          indexlength,\n          nonzero,\n          nonzerolength,\n          originalmask,\n          masklength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_getitem_adjust_offsets_index_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_getitem_adjust_offsets_index_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR IndexedArray_getitem_adjust_outindex_64(\n      kernel::lib ptr_lib,\n      int8_t *tomask,\n      int64_t *toindex,\n      int64_t *tononzero,\n      const int64_t *fromindex,\n      int64_t fromindexlength,\n      const int64_t *nonzero,\n      int64_t nonzerolength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray_getitem_adjust_outindex_64(\n          tomask,\n          toindex,\n          tononzero,\n          fromindex,\n          fromindexlength,\n          nonzero,\n          nonzerolength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_adjust_outindex_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_adjust_outindex_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_getitem_nextcarry_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int32_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_getitem_nextcarry_64(\n          tocarry,\n          fromindex,\n          lenindex,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_nextcarry_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_nextcarry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_getitem_nextcarry_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const uint32_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_getitem_nextcarry_64(\n          tocarry,\n          fromindex,\n          lenindex,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_nextcarry_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_nextcarry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_getitem_nextcarry_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_getitem_nextcarry_64(\n          tocarry,\n          fromindex,\n          lenindex,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_nextcarry_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_nextcarry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_getitem_carry_64<int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toindex,\n      const int32_t *fromindex,\n      const int64_t *fromcarry,\n      int64_t lenindex,\n      int64_t lencarry) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_IndexedArray32_getitem_carry_64(\n         toindex,\n         fromindex,\n         fromcarry,\n         lenindex,\n         lencarry);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_carry_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_carry_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR IndexedArray_getitem_carry_64<uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toindex,\n      const uint32_t *fromindex,\n      const int64_t *fromcarry,\n      int64_t lenindex,\n      int64_t lencarry) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_getitem_carry_64(\n          toindex,\n          fromindex,\n          fromcarry,\n          lenindex,\n          lencarry);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_carry_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_carry_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_getitem_carry_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *fromindex,\n      const int64_t *fromcarry,\n      int64_t lenindex,\n      int64_t lencarry) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_IndexedArray64_getitem_carry_64(\n         toindex,\n         fromindex,\n         fromcarry,\n         lenindex,\n         lencarry);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_getitem_carry_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_getitem_carry_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR UnionArray_regular_index_getsize<int8_t>(\n      kernel::lib ptr_lib,\n      int64_t *size,\n      const int8_t *fromtags,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_regular_index_getsize(\n          size,\n          fromtags,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_UnionArray8_regular_index_getsize, ptr_lib);\n        return (*awkward_UnionArray8_regular_index_getsize_fcn)(\n          size,\n          fromtags,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_regular_index_getsize<int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_regular_index<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toindex,\n      int32_t *current,\n      int64_t size,\n      const int8_t *fromtags,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_UnionArray8_32_regular_index(\n         toindex,\n         current,\n         size,\n         fromtags,\n         length);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_regular_index<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_regular_index<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR UnionArray_regular_index<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toindex,\n      uint32_t *current,\n      int64_t size,\n      const int8_t *fromtags,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_U32_regular_index(\n          toindex,\n          current,\n          size,\n          fromtags,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_regular_index<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_regular_index<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_regular_index<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t *current,\n      int64_t size,\n      const int8_t *fromtags,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_UnionArray8_64_regular_index(\n         toindex,\n         current,\n         size,\n         fromtags,\n         length);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_regular_index<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_regular_index<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR UnionArray_project_64<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *lenout,\n      int64_t *tocarry,\n      const int8_t *fromtags,\n      const int32_t *fromindex,\n      int64_t length,\n      int64_t which) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_32_project_64(\n          lenout,\n          tocarry,\n          fromtags,\n          fromindex,\n          length,\n          which);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_project_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_project_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_project_64<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *lenout,\n      int64_t *tocarry,\n      const int8_t *fromtags,\n      const uint32_t *fromindex,\n      int64_t length,\n      int64_t which) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_UnionArray8_U32_project_64(\n         lenout,\n         tocarry,\n         fromtags,\n         fromindex,\n         length,\n         which);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_project_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_project_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR UnionArray_project_64<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *lenout,\n      int64_t *tocarry,\n      const int8_t *fromtags,\n      const int64_t *fromindex,\n      int64_t length,\n      int64_t which) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_64_project_64(\n          lenout,\n          tocarry,\n          fromtags,\n          fromindex,\n          length,\n          which);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_project_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_project_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR missing_repeat_64(\n      kernel::lib ptr_lib,\n      int64_t *outindex,\n      const int64_t *index,\n      int64_t indexlength,\n      int64_t repetitions,\n      int64_t regularsize) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_missing_repeat_64(\n          outindex,\n          index,\n          indexlength,\n          repetitions,\n          regularsize);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for missing_repeat_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for missing_repeat_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_getitem_jagged_expand_64(\n      kernel::lib ptr_lib,\n      int64_t *multistarts,\n      int64_t *multistops,\n      const int64_t *singleoffsets,\n      int64_t regularsize,\n      int64_t regularlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_getitem_jagged_expand_64(\n          multistarts,\n          multistops,\n          singleoffsets,\n          regularsize,\n          regularlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_getitem_jagged_expand_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_getitem_jagged_expand_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_jagged_expand_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *multistarts,\n      int64_t *multistops,\n      const int64_t *singleoffsets,\n      int64_t *tocarry,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t jaggedsize,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_getitem_jagged_expand_64(\n          multistarts,\n          multistops,\n          singleoffsets,\n          tocarry,\n          fromstarts,\n          fromstops,\n          jaggedsize,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_expand_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_expand_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_jagged_expand_64(\n      kernel::lib ptr_lib,\n      int64_t *multistarts,\n      int64_t *multistops,\n      const int64_t *singleoffsets,\n      int64_t *tocarry,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t jaggedsize,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArrayU32_getitem_jagged_expand_64(\n         multistarts,\n         multistops,\n         singleoffsets,\n         tocarry,\n         fromstarts,\n         fromstops,\n         jaggedsize,\n         length);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_expand_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_expand_64\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_jagged_expand_64(\n      kernel::lib ptr_lib,\n      int64_t *multistarts,\n      int64_t *multistops,\n      const int64_t *singleoffsets,\n      int64_t *tocarry,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t jaggedsize,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_getitem_jagged_expand_64(\n          multistarts,\n          multistops,\n          singleoffsets,\n          tocarry,\n          fromstarts,\n          fromstops,\n          jaggedsize,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_expand_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_expand_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListArray_getitem_jagged_carrylen_64(\n      kernel::lib ptr_lib,\n      int64_t *carrylen,\n      const int64_t *slicestarts,\n      const int64_t *slicestops,\n      int64_t sliceouterlen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray_getitem_jagged_carrylen_64(\n          carrylen,\n          slicestarts,\n          slicestops,\n          sliceouterlen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_carrylen_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_carrylen_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_jagged_apply_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      int64_t *tocarry,\n      const int64_t *slicestarts,\n      const int64_t *slicestops,\n      int64_t sliceouterlen,\n      const int64_t *sliceindex,\n      int64_t sliceinnerlen,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t contentlen) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArray32_getitem_jagged_apply_64(\n         tooffsets,\n         tocarry,\n         slicestarts,\n         slicestops,\n         sliceouterlen,\n         sliceindex,\n         sliceinnerlen,\n         fromstarts,\n         fromstops,\n         contentlen);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_apply_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_apply_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_jagged_apply_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      int64_t *tocarry,\n      const int64_t *slicestarts,\n      const int64_t *slicestops,\n      int64_t sliceouterlen,\n      const int64_t *sliceindex,\n      int64_t sliceinnerlen,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t contentlen) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArrayU32_getitem_jagged_apply_64(\n         tooffsets,\n         tocarry,\n         slicestarts,\n         slicestops,\n         sliceouterlen,\n         sliceindex,\n         sliceinnerlen,\n         fromstarts,\n         fromstops,\n         contentlen);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_apply_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_apply_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_jagged_apply_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      int64_t *tocarry,\n      const int64_t *slicestarts,\n      const int64_t *slicestops,\n      int64_t sliceouterlen,\n      const int64_t *sliceindex,\n      int64_t sliceinnerlen,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t contentlen) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArray64_getitem_jagged_apply_64(\n         tooffsets,\n         tocarry,\n         slicestarts,\n         slicestops,\n         sliceouterlen,\n         sliceindex,\n         sliceinnerlen,\n         fromstarts,\n         fromstops,\n         contentlen);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_apply_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_apply_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    ERROR ListArray_getitem_jagged_numvalid_64(\n      kernel::lib ptr_lib,\n      int64_t *numvalid,\n      const int64_t *slicestarts,\n      const int64_t *slicestops,\n      int64_t length,\n      const int64_t *missing,\n      int64_t missinglength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray_getitem_jagged_numvalid_64(\n          numvalid,\n          slicestarts,\n          slicestops,\n          length,\n          missing,\n          missinglength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_numvalid_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_numvalid_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListArray_getitem_jagged_shrink_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *tosmalloffsets,\n      int64_t *tolargeoffsets,\n      const int64_t *slicestarts,\n      const int64_t *slicestops,\n      int64_t length,\n      const int64_t *missing) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray_getitem_jagged_shrink_64(\n          tocarry,\n          tosmalloffsets,\n          tolargeoffsets,\n          slicestarts,\n          slicestops,\n          length,\n          missing);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_shrink_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_shrink_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_jagged_descend_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int64_t *slicestarts,\n      const int64_t *slicestops,\n      int64_t sliceouterlen,\n      const int32_t *fromstarts,\n      const int32_t *fromstops) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_getitem_jagged_descend_64(\n          tooffsets,\n          slicestarts,\n          slicestops,\n          sliceouterlen,\n          fromstarts,\n          fromstops);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_descend_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_descend_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_getitem_jagged_descend_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int64_t *slicestarts,\n      const int64_t *slicestops,\n      int64_t sliceouterlen,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_ListArrayU32_getitem_jagged_descend_64(\n         tooffsets,\n         slicestarts,\n         slicestops,\n         sliceouterlen,\n         fromstarts,\n         fromstops);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_descend_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_descend_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR ListArray_getitem_jagged_descend_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int64_t *slicestarts,\n      const int64_t *slicestops,\n      int64_t sliceouterlen,\n      const int64_t *fromstarts,\n      const int64_t *fromstops) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_getitem_jagged_descend_64(\n          tooffsets,\n          slicestarts,\n          slicestops,\n          sliceouterlen,\n          fromstarts,\n          fromstops);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_getitem_jagged_descend_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_getitem_jagged_descend_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    int8_t index_getitem_at_nowrap(kernel::lib ptr_lib,\n                                   int8_t *ptr,\n                                   int64_t at) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index8_getitem_at_nowrap(\n          ptr,\n          at);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index8_getitem_at_nowrap, ptr_lib);\n        return (*awkward_Index8_getitem_at_nowrap_fcn)(\n          ptr,\n          at);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in int8_t index_getitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    uint8_t index_getitem_at_nowrap(kernel::lib ptr_lib,\n                                    uint8_t *ptr,\n                                    int64_t at) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexU8_getitem_at_nowrap(\n          ptr,\n          at);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU8_getitem_at_nowrap, ptr_lib);\n        return (*awkward_IndexU8_getitem_at_nowrap_fcn)(\n          ptr,\n          at);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in uint8_t index_getitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    int32_t index_getitem_at_nowrap(kernel::lib ptr_lib,\n                                    int32_t *ptr,\n                                    int64_t at) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index32_getitem_at_nowrap(\n          ptr,\n          at);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index32_getitem_at_nowrap, ptr_lib);\n        return (*awkward_Index32_getitem_at_nowrap_fcn)(\n          ptr,\n          at);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in int32_t index_getitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    uint32_t index_getitem_at_nowrap(kernel::lib ptr_lib,\n                                     uint32_t *ptr,\n                                     int64_t at) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexU32_getitem_at_nowrap(\n          ptr,\n          at);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU32_getitem_at_nowrap, ptr_lib);\n        return (*awkward_IndexU32_getitem_at_nowrap_fcn)(\n          ptr,\n          at);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in uint32_t index_getitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    int64_t index_getitem_at_nowrap(kernel::lib ptr_lib,\n                                    int64_t *ptr,\n                                    int64_t at) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Index64_getitem_at_nowrap(\n          ptr,\n          at);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index64_getitem_at_nowrap, ptr_lib);\n        return (*awkward_Index64_getitem_at_nowrap_fcn)(\n          ptr,\n          at);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in int64_t index_getitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    void index_setitem_at_nowrap(kernel::lib ptr_lib,\n                                 int8_t *ptr,\n                                 int64_t at,\n                                 int8_t value) {\n      if (ptr_lib == kernel::lib::cpu) {\n        awkward_Index8_setitem_at_nowrap(\n          ptr,\n          at,\n          value);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index8_setitem_at_nowrap, ptr_lib);\n        (*awkward_Index8_setitem_at_nowrap_fcn)(\n          ptr,\n          at,\n          value);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in void index_setitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    void index_setitem_at_nowrap(kernel::lib ptr_lib,\n                                 uint8_t *ptr,\n                                 int64_t at,\n                                 uint8_t value) {\n      if (ptr_lib == kernel::lib::cpu) {\n        awkward_IndexU8_setitem_at_nowrap(\n          ptr,\n          at,\n          value);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU8_setitem_at_nowrap, ptr_lib);\n        (*awkward_IndexU8_setitem_at_nowrap_fcn)(\n          ptr,\n          at,\n          value);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in void index_setitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    void index_setitem_at_nowrap(kernel::lib ptr_lib,\n                                 int32_t *ptr,\n                                 int64_t at,\n                                 int32_t value) {\n      if (ptr_lib == kernel::lib::cpu) {\n        awkward_Index32_setitem_at_nowrap(\n          ptr,\n          at,\n          value);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index32_setitem_at_nowrap, ptr_lib);\n        (*awkward_Index32_setitem_at_nowrap_fcn)(\n          ptr,\n          at,\n          value);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in void index_setitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    void index_setitem_at_nowrap(kernel::lib ptr_lib,\n                                 uint32_t *ptr,\n                                 int64_t at,\n                                 uint32_t value) {\n      if (ptr_lib == kernel::lib::cpu) {\n        awkward_IndexU32_setitem_at_nowrap(\n          ptr,\n          at,\n          value);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexU32_setitem_at_nowrap, ptr_lib);\n        (*awkward_IndexU32_setitem_at_nowrap_fcn)(\n          ptr,\n          at,\n          value);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in void index_setitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    void index_setitem_at_nowrap(kernel::lib ptr_lib,\n                                 int64_t *ptr,\n                                 int64_t at,\n                                 int64_t value) {\n      if (ptr_lib == kernel::lib::cpu) {\n        awkward_Index64_setitem_at_nowrap(\n          ptr,\n          at,\n          value);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Index64_setitem_at_nowrap, ptr_lib);\n        (*awkward_Index64_setitem_at_nowrap_fcn)(\n          ptr,\n          at,\n          value);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in void index_setitem_at_nowrap\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_getitem_carry_64(\n      kernel::lib ptr_lib,\n      int8_t *tomask,\n      const int8_t *frommask,\n      int64_t lenmask,\n      const int64_t *fromcarry,\n      int64_t lencarry) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_getitem_carry_64(\n          tomask,\n          frommask,\n          lenmask,\n          fromcarry,\n          lencarry);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ByteMaskedArray_getitem_carry_64, ptr_lib);\n        return (*awkward_ByteMaskedArray_getitem_carry_64_fcn)(\n          tomask,\n          frommask,\n          lenmask,\n          fromcarry,\n          lencarry);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_getitem_carry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_numnull(\n      kernel::lib ptr_lib,\n      int64_t *numnull,\n      const int8_t *mask,\n      int64_t length,\n      bool validwhen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_numnull(\n          numnull,\n          mask,\n          length,\n          validwhen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ByteMaskedArray_numnull\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_numnull\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_getitem_nextcarry_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int8_t *mask,\n      int64_t length,\n      bool validwhen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_getitem_nextcarry_64(\n          tocarry,\n          mask,\n          length,\n          validwhen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ByteMaskedArray_getitem_nextcarry_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_getitem_nextcarry_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_getitem_nextcarry_outindex_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      int64_t *toindex,\n      const int8_t *mask,\n      int64_t length,\n      bool validwhen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_getitem_nextcarry_outindex_64(\n          tocarry,\n          toindex,\n          mask,\n          length,\n          validwhen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ByteMaskedArray_getitem_nextcarry_outindex_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_getitem_nextcarry_outindex_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_toIndexedOptionArray64(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int8_t *mask,\n      int64_t length,\n      bool validwhen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_toIndexedOptionArray64(\n          toindex,\n          mask,\n          length,\n          validwhen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ByteMaskedArray_toIndexedOptionArray64, ptr_lib);\n        return (*awkward_ByteMaskedArray_toIndexedOptionArray64_fcn)(\n          toindex,\n          mask,\n          length,\n          validwhen);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_toIndexedOptionArray64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR Content_getitem_next_missing_jagged_getmaskstartstop(\n      kernel::lib ptr_lib,\n      int64_t *index_in,\n      int64_t *offsets_in,\n      int64_t *mask_out,\n      int64_t *starts_out,\n      int64_t *stops_out,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Content_getitem_next_missing_jagged_getmaskstartstop(\n          index_in,\n          offsets_in,\n          mask_out,\n          starts_out,\n          stops_out,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Content_getitem_next_missing_jagged_getmaskstartstop\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Content_getitem_next_missing_jagged_getmaskstartstop\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR MaskedArray_getitem_next_jagged_project(\n      kernel::lib ptr_lib,\n      int32_t *index,\n      int64_t *starts_in,\n      int64_t *stops_in,\n      int64_t *starts_out,\n      int64_t *stops_out,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_MaskedArray32_getitem_next_jagged_project(\n          index,\n          starts_in,\n          stops_in,\n          starts_out,\n          stops_out,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for MaskedArray_getitem_next_jagged_project\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for MaskedArray_getitem_next_jagged_project\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR MaskedArray_getitem_next_jagged_project(\n      kernel::lib ptr_lib,\n      uint32_t *index,\n      int64_t *starts_in,\n      int64_t *stops_in,\n      int64_t *starts_out,\n      int64_t *stops_out,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_MaskedArrayU32_getitem_next_jagged_project(\n          index,\n          starts_in,\n          stops_in,\n          starts_out,\n          stops_out,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for MaskedArray_getitem_next_jagged_project\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for MaskedArray_getitem_next_jagged_project\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR MaskedArray_getitem_next_jagged_project(\n      kernel::lib ptr_lib,\n      int64_t *index,\n      int64_t *starts_in,\n      int64_t *stops_in,\n      int64_t *starts_out,\n      int64_t *stops_out,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_MaskedArray64_getitem_next_jagged_project(\n          index,\n          starts_in,\n          stops_in,\n          starts_out,\n          stops_out,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for MaskedArray_getitem_next_jagged_project\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for MaskedArray_getitem_next_jagged_project\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    /////////////////////////////////// awkward/kernels/identities.h\n\n    template<>\n    ERROR new_Identities(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_new_Identities32(\n          toptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_new_Identities32, ptr_lib);\n        return (*awkward_new_Identities32_fcn)(toptr, length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for new_Identities\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR new_Identities(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_new_Identities64(\n          toptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_new_Identities64, ptr_lib);\n        return (*awkward_new_Identities64_fcn)(toptr, length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for new_Identities\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_to_Identities64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int32_t *fromptr,\n      int64_t length,\n      int64_t width) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_to_Identities64(\n          toptr,\n          fromptr,\n          length,\n          width);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_Identities32_to_Identities64, ptr_lib);\n        return (*awkward_Identities32_to_Identities64_fcn)(toptr, fromptr, length, width);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_to_Identities64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListOffsetArray<int32_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int32_t *fromoffsets,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_ListOffsetArray32(\n          toptr,\n          fromptr,\n          fromoffsets,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListOffsetArray<int32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListOffsetArray<int32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListOffsetArray<int32_t, uint32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const uint32_t *fromoffsets,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_ListOffsetArrayU32(\n          toptr,\n          fromptr,\n          fromoffsets,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListOffsetArray<int32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListOffsetArray<int32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListOffsetArray<int32_t, int64_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *fromoffsets,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_ListOffsetArray64(\n          toptr,\n          fromptr,\n          fromoffsets,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListOffsetArray<int32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListOffsetArray<int32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListOffsetArray<int64_t, int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int32_t *fromoffsets,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_ListOffsetArray32(\n          toptr,\n          fromptr,\n          fromoffsets,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListOffsetArray<int64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListOffsetArray<int64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListOffsetArray<int64_t, uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const uint32_t *fromoffsets,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_ListOffsetArrayU32(\n          toptr,\n          fromptr,\n          fromoffsets,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListOffsetArray<int64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListOffsetArray<int64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListOffsetArray<int64_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *fromoffsets,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_ListOffsetArray64(\n          toptr,\n          fromptr,\n          fromoffsets,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListOffsetArray<int64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListOffsetArray<int64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListArray<int32_t, int32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_ListArray32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromstarts,\n          fromstops,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListArray<int32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListArray<int32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListArray<int32_t, uint32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_ListArrayU32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromstarts,\n          fromstops,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListArray<int32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListArray<int32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListArray<int32_t, int64_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_ListArray64(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromstarts,\n          fromstops,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListArray<int32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListArray<int32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListArray<int64_t, int32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_ListArray32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromstarts,\n          fromstops,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListArray<int64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListArray<int64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListArray<int64_t, uint32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_ListArrayU32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromstarts,\n          fromstops,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListArray<int64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListArray<int64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_ListArray<int64_t, int64_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_ListArray64(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromstarts,\n          fromstops,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_ListArray<int64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_ListArray<int64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_RegularArray(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      int64_t size,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_RegularArray(\n          toptr,\n          fromptr,\n          size,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_RegularArray\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_RegularArray\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_RegularArray(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      int64_t size,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_RegularArray(\n          toptr,\n          fromptr,\n          size,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_RegularArray\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_RegularArray\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_IndexedArray<int32_t, int32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int32_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_IndexedArray32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromindex,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_IndexedArray<int32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_IndexedArray<int32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_IndexedArray<int32_t, uint32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const uint32_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_Identities32_from_IndexedArrayU32(\n         uniquecontents,\n         toptr,\n         fromptr,\n         fromindex,\n         tolength,\n         fromlength,\n         fromwidth);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_IndexedArray<int32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_IndexedArray<int32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR Identities_from_IndexedArray<int32_t, int64_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_IndexedArray64(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromindex,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_IndexedArray<int32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_IndexedArray<int32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_IndexedArray<int64_t, int32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int32_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_Identities64_from_IndexedArray32(\n         uniquecontents,\n         toptr,\n         fromptr,\n         fromindex,\n         tolength,\n         fromlength,\n         fromwidth);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_IndexedArray<int64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_IndexedArray<int64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR Identities_from_IndexedArray<int64_t, uint32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const uint32_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_IndexedArrayU32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromindex,\n          tolength,\n          fromlength,\n          fromwidth);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_IndexedArray<int64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_IndexedArray<int64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_IndexedArray<int64_t, int64_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth) {\n      if (ptr_lib == kernel::lib::cpu) {\n       return awkward_Identities64_from_IndexedArray64(\n         uniquecontents,\n         toptr,\n         fromptr,\n         fromindex,\n         tolength,\n         fromlength,\n         fromwidth);\n     }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_IndexedArray<int64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_IndexedArray<int64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n     }\n\n    template<>\n    ERROR Identities_from_UnionArray<int32_t, int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int8_t *fromtags,\n      const int32_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth,\n      int64_t which) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_UnionArray8_32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromtags,\n          fromindex,\n          tolength,\n          fromlength,\n          fromwidth,\n          which);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_UnionArray<int32_t, int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_UnionArray<int32_t, int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_UnionArray<int32_t, int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int8_t *fromtags,\n      const uint32_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth,\n      int64_t which) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_UnionArray8_U32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromtags,\n          fromindex,\n          tolength,\n          fromlength,\n          fromwidth,\n          which);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_UnionArray<int32_t, int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_UnionArray<int32_t, int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_UnionArray<int32_t, int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int8_t *fromtags,\n      const int64_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth,\n      int64_t which) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_from_UnionArray8_64(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromtags,\n          fromindex,\n          tolength,\n          fromlength,\n          fromwidth,\n          which);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_UnionArray<int32_t, int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_UnionArray<int32_t, int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_UnionArray<int64_t, int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int8_t *fromtags,\n      const int32_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth,\n      int64_t which) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_UnionArray8_32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromtags,\n          fromindex,\n          tolength,\n          fromlength,\n          fromwidth,\n          which);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_UnionArray<int64_t, int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_UnionArray<int64_t, int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_UnionArray<int64_t, int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int8_t *fromtags,\n      const uint32_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth,\n      int64_t which) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_UnionArray8_U32(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromtags,\n          fromindex,\n          tolength,\n          fromlength,\n          fromwidth,\n          which);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_UnionArray<int64_t, int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_UnionArray<int64_t, int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_from_UnionArray<int64_t, int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      bool *uniquecontents,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int8_t *fromtags,\n      const int64_t *fromindex,\n      int64_t tolength,\n      int64_t fromlength,\n      int64_t fromwidth,\n      int64_t which) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_from_UnionArray8_64(\n          uniquecontents,\n          toptr,\n          fromptr,\n          fromtags,\n          fromindex,\n          tolength,\n          fromlength,\n          fromwidth,\n          which);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_from_UnionArray<int64_t, int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_from_UnionArray<int64_t, int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_extend(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      int64_t fromlength,\n      int64_t tolength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities32_extend(\n          toptr,\n          fromptr,\n          fromlength,\n          tolength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_extend\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_extend\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR Identities_extend(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      int64_t fromlength,\n      int64_t tolength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_Identities64_extend(\n          toptr,\n          fromptr,\n          fromlength,\n          tolength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for Identities_extend\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for Identities_extend\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    /////////////////////////////////// awkward/kernels/operations.h\n\n    template<>\n    ERROR ListArray_num_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tonum,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_num_64(\n          tonum,\n          fromstarts,\n          fromstops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArray32_num_64, ptr_lib);\n        return (*awkward_ListArray32_num_64_fcn)(\n          tonum,\n          fromstarts,\n          fromstops,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in ListArray_num_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_num_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tonum,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_num_64(\n          tonum,\n          fromstarts,\n          fromstops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArrayU32_num_64, ptr_lib);\n        return (*awkward_ListArrayU32_num_64_fcn)(\n          tonum,\n          fromstarts,\n          fromstops,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in ListArray_num_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_num_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tonum,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_num_64(\n          tonum,\n          fromstarts,\n          fromstops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArray64_num_64, ptr_lib);\n        return (*awkward_ListArray64_num_64_fcn)(\n          tonum,\n          fromstarts,\n          fromstops,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in ListArray_num_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_num_64(\n      kernel::lib ptr_lib,\n      int64_t *tonum,\n      int64_t size,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_num_64(\n          tonum,\n          size,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_RegularArray_num_64, ptr_lib);\n        return (*awkward_RegularArray_num_64_fcn)(\n          tonum,\n          size,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib in RegularArray_num_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_flatten_offsets_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int32_t *outeroffsets,\n      int64_t outeroffsetslen,\n      const int64_t *inneroffsets,\n      int64_t inneroffsetslen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray32_flatten_offsets_64(\n          tooffsets,\n          outeroffsets,\n          outeroffsetslen,\n          inneroffsets,\n          inneroffsetslen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListOffsetArray32_flatten_offsets_64, ptr_lib);\n        return (*awkward_ListOffsetArray32_flatten_offsets_64_fcn)(tooffsets,\n          outeroffsets,\n          outeroffsetslen,\n          inneroffsets,\n          inneroffsetslen);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_flatten_offsets_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_flatten_offsets_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const uint32_t *outeroffsets,\n      int64_t outeroffsetslen,\n      const int64_t *inneroffsets,\n      int64_t inneroffsetslen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArrayU32_flatten_offsets_64(\n          tooffsets,\n          outeroffsets,\n          outeroffsetslen,\n          inneroffsets,\n          inneroffsetslen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListOffsetArrayU32_flatten_offsets_64, ptr_lib);\n        return (*awkward_ListOffsetArrayU32_flatten_offsets_64_fcn)(tooffsets,\n          outeroffsets,\n          outeroffsetslen,\n          inneroffsets,\n          inneroffsetslen);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_flatten_offsets_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_flatten_offsets_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int64_t *outeroffsets,\n      int64_t outeroffsetslen,\n      const int64_t *inneroffsets,\n      int64_t inneroffsetslen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray64_flatten_offsets_64(\n          tooffsets,\n          outeroffsets,\n          outeroffsetslen,\n          inneroffsets,\n          inneroffsetslen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListOffsetArray64_flatten_offsets_64, ptr_lib);\n        return (*awkward_ListOffsetArray64_flatten_offsets_64_fcn)(tooffsets,\n          outeroffsets,\n          outeroffsetslen,\n          inneroffsets,\n          inneroffsetslen);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_flatten_offsets_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_flatten_none2empty_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *outoffsets,\n      const int32_t *outindex,\n      int64_t outindexlength,\n      const int64_t *offsets,\n      int64_t offsetslength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_flatten_none2empty_64(\n          outoffsets,\n          outindex,\n          outindexlength,\n          offsets,\n          offsetslength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_flatten_none2empty_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_flatten_none2empty_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_flatten_none2empty_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *outoffsets,\n      const uint32_t *outindex,\n      int64_t outindexlength,\n      const int64_t *offsets,\n      int64_t offsetslength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_flatten_none2empty_64(\n          outoffsets,\n          outindex,\n          outindexlength,\n          offsets,\n          offsetslength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_flatten_none2empty_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_flatten_none2empty_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_flatten_none2empty_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *outoffsets,\n      const int64_t *outindex,\n      int64_t outindexlength,\n      const int64_t *offsets,\n      int64_t offsetslength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_flatten_none2empty_64(\n          outoffsets,\n          outindex,\n          outindexlength,\n          offsets,\n          offsetslength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_flatten_none2empty_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_flatten_none2empty_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_flatten_length_64<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *total_length,\n      const int8_t *fromtags,\n      const int32_t *fromindex,\n      int64_t length,\n      int64_t **offsetsraws) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray32_flatten_length_64(\n          total_length,\n          fromtags,\n          fromindex,\n          length,\n          offsetsraws);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_flatten_length_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_flatten_length_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_flatten_length_64<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *total_length,\n      const int8_t *fromtags,\n      const uint32_t *fromindex,\n      int64_t length,\n      int64_t **offsetsraws) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArrayU32_flatten_length_64(\n          total_length,\n          fromtags,\n          fromindex,\n          length,\n          offsetsraws);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_flatten_length_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_flatten_length_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_flatten_length_64<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *total_length,\n      const int8_t *fromtags,\n      const int64_t *fromindex,\n      int64_t length,\n      int64_t **offsetsraws) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray64_flatten_length_64(\n          total_length,\n          fromtags,\n          fromindex,\n          length,\n          offsetsraws);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_flatten_length_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_flatten_length_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_flatten_combine_64<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      int64_t *tooffsets,\n      const int8_t *fromtags,\n      const int32_t *fromindex,\n      int64_t length,\n      int64_t **offsetsraws) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray32_flatten_combine_64(\n          totags,\n          toindex,\n          tooffsets,\n          fromtags,\n          fromindex,\n          length,\n          offsetsraws);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_flatten_combine_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_flatten_combine_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_flatten_combine_64<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      int64_t *tooffsets,\n      const int8_t *fromtags,\n      const uint32_t *fromindex,\n      int64_t length,\n      int64_t **offsetsraws) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArrayU32_flatten_combine_64(\n          totags,\n          toindex,\n          tooffsets,\n          fromtags,\n          fromindex,\n          length,\n          offsetsraws);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_flatten_combine_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_flatten_combine_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_flatten_combine_64<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      int64_t *tooffsets,\n      const int8_t *fromtags,\n      const int64_t *fromindex,\n      int64_t length,\n      int64_t **offsetsraws) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray64_flatten_combine_64(\n          totags,\n          toindex,\n          tooffsets,\n          fromtags,\n          fromindex,\n          length,\n          offsetsraws);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_flatten_combine_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_flatten_combine_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_flatten_nextcarry_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int32_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_flatten_nextcarry_64(\n          tocarry,\n          fromindex,\n          lenindex,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_flatten_nextcarry_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_flatten_nextcarry_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_flatten_nextcarry_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const uint32_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_flatten_nextcarry_64(\n          tocarry,\n          fromindex,\n          lenindex,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_flatten_nextcarry_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_flatten_nextcarry_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_flatten_nextcarry_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *fromindex,\n      int64_t lenindex,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_flatten_nextcarry_64(\n          tocarry,\n          fromindex,\n          lenindex,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_flatten_nextcarry_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_flatten_nextcarry_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_overlay_mask8_to64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int8_t *mask,\n      const int32_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_overlay_mask8_to64(\n          toindex,\n          mask,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArray32_overlay_mask8_to64, ptr_lib);\n        return (*awkward_IndexedArray32_overlay_mask8_to64_fcn)(\n          toindex,\n          mask,\n          fromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_overlay_mask8_to64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_overlay_mask8_to64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int8_t *mask,\n      const uint32_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_overlay_mask8_to64(\n          toindex,\n          mask,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArrayU32_overlay_mask8_to64, ptr_lib);\n        return (*awkward_IndexedArrayU32_overlay_mask8_to64_fcn)(\n          toindex,\n          mask,\n          fromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_overlay_mask8_to64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_overlay_mask8_to64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int8_t *mask,\n      const int64_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_overlay_mask8_to64(\n          toindex,\n          mask,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArray64_overlay_mask8_to64, ptr_lib);\n        return (*awkward_IndexedArray64_overlay_mask8_to64_fcn)(\n          toindex,\n          mask,\n          fromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_overlay_mask8_to64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_mask8<int32_t>(\n      kernel::lib ptr_lib,\n      int8_t *tomask,\n      const int32_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_mask8(\n          tomask,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArray32_mask8, ptr_lib);\n        return (*awkward_IndexedArray32_mask8_fcn)(\n          tomask,\n          fromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_mask8<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_mask8<uint32_t>(\n      kernel::lib ptr_lib,\n      int8_t *tomask,\n      const uint32_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_mask8(\n          tomask,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArrayU32_mask8, ptr_lib);\n        return (*awkward_IndexedArrayU32_mask8_fcn)(\n          tomask,\n          fromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_mask8<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_mask8<int64_t>(\n      kernel::lib ptr_lib,\n      int8_t *tomask,\n      const int64_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_mask8(\n          tomask,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArray64_mask8, ptr_lib);\n        return (*awkward_IndexedArray64_mask8_fcn)(\n          tomask,\n          fromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_mask8<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_mask8(\n      kernel::lib ptr_lib,\n      int8_t *tomask,\n      const int8_t *frommask,\n      int64_t length,\n      bool validwhen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_mask8(\n          tomask,\n          frommask,\n          length,\n          validwhen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ByteMaskedArray_mask8, ptr_lib);\n        return (*awkward_ByteMaskedArray_mask8_fcn)(\n          tomask,\n          frommask,\n          length,\n          validwhen);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_mask8\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR zero_mask8(\n      kernel::lib ptr_lib,\n      int8_t *tomask,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_zero_mask8(tomask, length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_zero_mask8, ptr_lib);\n        return (*awkward_zero_mask8_fcn)(\n          tomask,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for zero_mask8\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_simplify32_to64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int32_t *outerindex,\n      int64_t outerlength,\n      const int32_t *innerindex,\n      int64_t innerlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_simplify32_to64(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_simplify32_to64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_simplify32_to64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_simplify32_to64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const uint32_t *outerindex,\n      int64_t outerlength,\n      const int32_t *innerindex,\n      int64_t innerlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_simplify32_to64(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_simplify32_to64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_simplify32_to64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_simplify32_to64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *outerindex,\n      int64_t outerlength,\n      const int32_t *innerindex,\n      int64_t innerlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_simplify32_to64(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_simplify32_to64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_simplify32_to64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_simplifyU32_to64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int32_t *outerindex,\n      int64_t outerlength,\n      const uint32_t *innerindex,\n      int64_t innerlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_simplifyU32_to64(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_simplifyU32_to64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_simplifyU32_to64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_simplifyU32_to64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const uint32_t *outerindex,\n      int64_t outerlength,\n      const uint32_t *innerindex,\n      int64_t innerlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_simplifyU32_to64(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_simplifyU32_to64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_simplifyU32_to64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_simplifyU32_to64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *outerindex,\n      int64_t outerlength,\n      const uint32_t *innerindex,\n      int64_t innerlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_simplifyU32_to64(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_simplifyU32_to64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_simplifyU32_to64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_simplify64_to64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int32_t *outerindex,\n      int64_t outerlength,\n      const int64_t *innerindex,\n      int64_t innerlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_simplify64_to64(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_simplify64_to64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_simplify64_to64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_simplify64_to64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const uint32_t *outerindex,\n      int64_t outerlength,\n      const int64_t *innerindex,\n      int64_t innerlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_simplify64_to64(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_simplify64_to64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_simplify64_to64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_simplify64_to64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *outerindex,\n      int64_t outerlength,\n      const int64_t *innerindex,\n      int64_t innerlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_simplify64_to64(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArray64_simplify64_to64, ptr_lib);\n        return (*awkward_IndexedArray64_simplify64_to64_fcn)(\n          toindex,\n          outerindex,\n          outerlength,\n          innerindex,\n          innerlength);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_simplify64_to64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_compact_offsets_64(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_compact_offsets_64(\n          tooffsets,\n          fromstarts,\n          fromstops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_compact_offsets_64(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_compact_offsets_64(\n          tooffsets,\n          fromstarts,\n          fromstops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_compact_offsets_64(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_compact_offsets_64(\n          tooffsets,\n          fromstarts,\n          fromstops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_compact_offsets_64(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      int64_t length,\n      int64_t size) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_compact_offsets64(\n          tooffsets,\n          length,\n          size);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_RegularArray_compact_offsets64, ptr_lib);\n        return (*awkward_RegularArray_compact_offsets64_fcn)(\n          tooffsets,\n          length,\n          size);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_compact_offsets_64(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int32_t *fromoffsets,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray32_compact_offsets_64(\n          tooffsets,\n          fromoffsets,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_compact_offsets_64(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const uint32_t *fromoffsets,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArrayU32_compact_offsets_64(\n          tooffsets,\n          fromoffsets,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_compact_offsets_64(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int64_t *fromoffsets,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray64_compact_offsets_64(\n          tooffsets,\n          fromoffsets,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_compact_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_broadcast_tooffsets_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *fromoffsets,\n      int64_t offsetslength,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_broadcast_tooffsets_64(\n          tocarry,\n          fromoffsets,\n          offsetslength,\n          fromstarts,\n          fromstops,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_broadcast_tooffsets_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_broadcast_tooffsets_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_broadcast_tooffsets_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *fromoffsets,\n      int64_t offsetslength,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_broadcast_tooffsets_64(\n          tocarry,\n          fromoffsets,\n          offsetslength,\n          fromstarts,\n          fromstops,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_broadcast_tooffsets_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_broadcast_tooffsets_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_broadcast_tooffsets_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *fromoffsets,\n      int64_t offsetslength,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_broadcast_tooffsets_64(\n          tocarry,\n          fromoffsets,\n          offsetslength,\n          fromstarts,\n          fromstops,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_broadcast_tooffsets_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_broadcast_tooffsets_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_broadcast_tooffsets_64(\n      kernel::lib ptr_lib,\n      const int64_t *fromoffsets,\n      int64_t offsetslength,\n      int64_t size) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_broadcast_tooffsets_64(\n          fromoffsets,\n          offsetslength,\n          size);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_RegularArray_broadcast_tooffsets_64, ptr_lib);\n        return (*awkward_RegularArray_broadcast_tooffsets_64_fcn)(\n          fromoffsets,\n          offsetslength,\n          size);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_broadcast_tooffsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_broadcast_tooffsets_size1_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *fromoffsets,\n      int64_t offsetslength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_broadcast_tooffsets_size1_64(\n          tocarry,\n          fromoffsets,\n          offsetslength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_broadcast_tooffsets_size1_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_broadcast_tooffsets_size1_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_toRegularArray<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *size,\n      const int32_t *fromoffsets,\n      int64_t offsetslength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray32_toRegularArray(\n          size,\n          fromoffsets,\n          offsetslength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_toRegularArray<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_toRegularArray<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_toRegularArray<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *size,\n      const uint32_t *fromoffsets,\n      int64_t offsetslength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArrayU32_toRegularArray(\n          size,\n          fromoffsets,\n          offsetslength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_toRegularArray<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_toRegularArray<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_toRegularArray(\n      kernel::lib ptr_lib,\n      int64_t *size,\n      const int64_t *fromoffsets,\n      int64_t offsetslength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray64_toRegularArray(\n          size,\n          fromoffsets,\n          offsetslength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_toRegularArray\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_toRegularArray\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_fill_frombool<double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill_frombool<double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill_frombool<double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<bool, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<bool, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const bool *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_frombool(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<bool, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<bool, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<int8_t, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int8_t, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const int8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int8_t, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int8_t, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<int16_t, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int16_t, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const int16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int16_t, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int16_t, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<int32_t, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int32_t, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const int32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int32_t, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int32_t, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<int64_t, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<int64_t, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const int64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<int64_t, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<int64_t, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<uint8_t, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint8_t, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const uint8_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromuint8(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint8_t, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint8_t, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<uint16_t, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint16_t, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const uint16_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromuint16(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint16_t, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint16_t, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<uint32_t, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint32_t, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const uint32_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromuint32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint32_t, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint32_t, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<uint64_t, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<uint64_t, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const uint64_t *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromuint64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<uint64_t, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<uint64_t, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<float, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<float, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const float *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromfloat32(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<float, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<float, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR NumpyArray_fill<double, bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tobool_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint8_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint16_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint32_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_toint64_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint8_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint16_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint32_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_touint64_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat32_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n    template <>\n    ERROR NumpyArray_fill<double, double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      int64_t tooffset,\n      const double *fromptr,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_fill_tofloat64_fromfloat64(\n          toptr,\n          tooffset,\n          fromptr,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_fill<double, double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_fill<double, double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_fill(\n      kernel::lib ptr_lib,\n      int64_t *tostarts,\n      int64_t tostartsoffset,\n      int64_t *tostops,\n      int64_t tostopsoffset,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray_fill_to64_from32(\n          tostarts,\n          tostartsoffset,\n          tostops,\n          tostopsoffset,\n          fromstarts,\n          fromstops,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_fill\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_fill\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_fill(\n      kernel::lib ptr_lib,\n      int64_t *tostarts,\n      int64_t tostartsoffset,\n      int64_t *tostops,\n      int64_t tostopsoffset,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray_fill_to64_fromU32(\n          tostarts,\n          tostartsoffset,\n          tostops,\n          tostopsoffset,\n          fromstarts,\n          fromstops,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_fill\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_fill\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_fill(\n      kernel::lib ptr_lib,\n      int64_t *tostarts,\n      int64_t tostartsoffset,\n      int64_t *tostops,\n      int64_t tostopsoffset,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray_fill_to64_from64(\n          tostarts,\n          tostartsoffset,\n          tostops,\n          tostopsoffset,\n          fromstarts,\n          fromstops,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_fill\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_fill\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_fill(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t toindexoffset,\n      const int32_t *fromindex,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray_fill_to64_from32(\n          toindex,\n          toindexoffset,\n          fromindex,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_fill\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_fill\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_fill(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t toindexoffset,\n      const uint32_t *fromindex,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray_fill_to64_fromU32(\n          toindex,\n          toindexoffset,\n          fromindex,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_fill\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_fill\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_fill(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t toindexoffset,\n      const int64_t *fromindex,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray_fill_to64_from64(\n          toindex,\n          toindexoffset,\n          fromindex,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_fill\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_fill\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR IndexedArray_fill_to64_count(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t toindexoffset,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray_fill_to64_count(\n          toindex,\n          toindexoffset,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArray_fill_to64_count, ptr_lib);\n        return (*awkward_IndexedArray_fill_to64_count_fcn)(\n          toindex,\n          toindexoffset,\n          length,\n          base);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_fill_to64_count\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR UnionArray_filltags_to8_from8(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t totagsoffset,\n      const int8_t *fromtags,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray_filltags_to8_from8(\n          totags,\n          totagsoffset,\n          fromtags,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_filltags_to8_from8\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_filltags_to8_from8\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_fillindex(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t toindexoffset,\n      const int32_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray_fillindex_to64_from32(\n          toindex,\n          toindexoffset,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_fillindex\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_fillindex\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_fillindex(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t toindexoffset,\n      const uint32_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray_fillindex_to64_fromU32(\n          toindex,\n          toindexoffset,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_fillindex\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_fillindex\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_fillindex(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t toindexoffset,\n      const int64_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray_fillindex_to64_from64(\n          toindex,\n          toindexoffset,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_fillindex\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_fillindex\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR UnionArray_filltags_to8_const(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t totagsoffset,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray_filltags_to8_const(\n          totags,\n          totagsoffset,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_filltags_to8_const\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_filltags_to8_const\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR UnionArray_fillindex_count_64(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t toindexoffset,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray_fillindex_to64_count(\n          toindex,\n          toindexoffset,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_fillindex_count_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_fillindex_count_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify8_32_to8_64<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *outertags,\n      const int32_t *outerindex,\n      const int8_t *innertags,\n      const int32_t *innerindex,\n      int64_t towhich,\n      int64_t innerwhich,\n      int64_t outerwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_32_simplify8_32_to8_64(\n          totags,\n          toindex,\n          outertags,\n          outerindex,\n          innertags,\n          innerindex,\n          towhich,\n          innerwhich,\n          outerwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify8_32_to8_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify8_32_to8_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify8_32_to8_64<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *outertags,\n      const uint32_t *outerindex,\n      const int8_t *innertags,\n      const int32_t *innerindex,\n      int64_t towhich,\n      int64_t innerwhich,\n      int64_t outerwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_U32_simplify8_32_to8_64(\n          totags,\n          toindex,\n          outertags,\n          outerindex,\n          innertags,\n          innerindex,\n          towhich,\n          innerwhich,\n          outerwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify8_32_to8_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify8_32_to8_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify8_32_to8_64<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *outertags,\n      const int64_t *outerindex,\n      const int8_t *innertags,\n      const int32_t *innerindex,\n      int64_t towhich,\n      int64_t innerwhich,\n      int64_t outerwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_64_simplify8_32_to8_64(\n          totags,\n          toindex,\n          outertags,\n          outerindex,\n          innertags,\n          innerindex,\n          towhich,\n          innerwhich,\n          outerwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify8_32_to8_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify8_32_to8_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify8_U32_to8_64<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *outertags,\n      const int32_t *outerindex,\n      const int8_t *innertags,\n      const uint32_t *innerindex,\n      int64_t towhich,\n      int64_t innerwhich,\n      int64_t outerwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_32_simplify8_U32_to8_64(\n          totags,\n          toindex,\n          outertags,\n          outerindex,\n          innertags,\n          innerindex,\n          towhich,\n          innerwhich,\n          outerwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify8_U32_to8_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify8_U32_to8_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify8_U32_to8_64<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *outertags,\n      const uint32_t *outerindex,\n      const int8_t *innertags,\n      const uint32_t *innerindex,\n      int64_t towhich,\n      int64_t innerwhich,\n      int64_t outerwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_U32_simplify8_U32_to8_64(\n          totags,\n          toindex,\n          outertags,\n          outerindex,\n          innertags,\n          innerindex,\n          towhich,\n          innerwhich,\n          outerwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify8_U32_to8_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify8_U32_to8_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify8_U32_to8_64<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *outertags,\n      const int64_t *outerindex,\n      const int8_t *innertags,\n      const uint32_t *innerindex,\n      int64_t towhich,\n      int64_t innerwhich,\n      int64_t outerwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_64_simplify8_U32_to8_64(\n          totags,\n          toindex,\n          outertags,\n          outerindex,\n          innertags,\n          innerindex,\n          towhich,\n          innerwhich,\n          outerwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify8_U32_to8_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify8_U32_to8_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify8_64_to8_64<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *outertags,\n      const int32_t *outerindex,\n      const int8_t *innertags,\n      const int64_t *innerindex,\n      int64_t towhich,\n      int64_t innerwhich,\n      int64_t outerwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_32_simplify8_64_to8_64(\n          totags,\n          toindex,\n          outertags,\n          outerindex,\n          innertags,\n          innerindex,\n          towhich,\n          innerwhich,\n          outerwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify8_64_to8_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify8_64_to8_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify8_64_to8_64<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *outertags,\n      const uint32_t *outerindex,\n      const int8_t *innertags,\n      const int64_t *innerindex,\n      int64_t towhich,\n      int64_t innerwhich,\n      int64_t outerwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_U32_simplify8_64_to8_64(\n          totags,\n          toindex,\n          outertags,\n          outerindex,\n          innertags,\n          innerindex,\n          towhich,\n          innerwhich,\n          outerwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify8_64_to8_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify8_64_to8_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify8_64_to8_64<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *outertags,\n      const int64_t *outerindex,\n      const int8_t *innertags,\n      const int64_t *innerindex,\n      int64_t towhich,\n      int64_t innerwhich,\n      int64_t outerwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_64_simplify8_64_to8_64(\n          totags,\n          toindex,\n          outertags,\n          outerindex,\n          innertags,\n          innerindex,\n          towhich,\n          innerwhich,\n          outerwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify8_64_to8_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify8_64_to8_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify_one_to8_64<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *fromtags,\n      const int32_t *fromindex,\n      int64_t towhich,\n      int64_t fromwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_32_simplify_one_to8_64(\n          totags,\n          toindex,\n          fromtags,\n          fromindex,\n          towhich,\n          fromwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify_one_to8_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify_one_to8_64<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify_one_to8_64<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *fromtags,\n      const uint32_t *fromindex,\n      int64_t towhich,\n      int64_t fromwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_U32_simplify_one_to8_64(\n          totags,\n          toindex,\n          fromtags,\n          fromindex,\n          towhich,\n          fromwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify_one_to8_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify_one_to8_64<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_simplify_one_to8_64<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      int8_t *totags,\n      int64_t *toindex,\n      const int8_t *fromtags,\n      const int64_t *fromindex,\n      int64_t towhich,\n      int64_t fromwhich,\n      int64_t length,\n      int64_t base) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_64_simplify_one_to8_64(\n          totags,\n          toindex,\n          fromtags,\n          fromindex,\n          towhich,\n          fromwhich,\n          length,\n          base);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for UnionArray_simplify_one_to8_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_simplify_one_to8_64<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_validity<int32_t>(\n      kernel::lib ptr_lib,\n      const int32_t *starts,\n      const int32_t *stops,\n      int64_t length,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_validity(\n          starts,\n          stops,\n          length,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArray32_validity, ptr_lib);\n        return (*awkward_ListArray32_validity_fcn)(\n          starts,\n          stops,\n          length,\n          lencontent);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_validity<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_validity<uint32_t>(\n      kernel::lib ptr_lib,\n      const uint32_t *starts,\n      const uint32_t *stops,\n      int64_t length,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_validity(\n          starts,\n          stops,\n          length,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArrayU32_validity, ptr_lib);\n        return (*awkward_ListArrayU32_validity_fcn)(\n          starts,\n          stops,\n          length,\n          lencontent);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_validity<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_validity<int64_t>(\n      kernel::lib ptr_lib,\n      const int64_t *starts,\n      const int64_t *stops,\n      int64_t length,\n      int64_t lencontent) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_validity(\n          starts,\n          stops,\n          length,\n          lencontent);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArray64_validity, ptr_lib);\n        return (*awkward_ListArray64_validity_fcn)(\n          starts,\n          stops,\n          length,\n          lencontent);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_validity<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_validity<int32_t>(\n      kernel::lib ptr_lib,\n      const int32_t *index,\n      int64_t length,\n      int64_t lencontent,\n      bool isoption) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_validity(\n          index,\n          length,\n          lencontent,\n          isoption);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArray32_validity, ptr_lib);\n        return (*awkward_IndexedArray32_validity_fcn)(\n          index,\n          length,\n          lencontent,\n          isoption);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_validity<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_validity<uint32_t>(\n      kernel::lib ptr_lib,\n      const uint32_t *index,\n      int64_t length,\n      int64_t lencontent,\n      bool isoption) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_validity(\n          index,\n          length,\n          lencontent,\n          isoption);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArrayU32_validity, ptr_lib);\n        return (*awkward_IndexedArrayU32_validity_fcn)(\n          index,\n          length,\n          lencontent,\n          isoption);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_validity<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_validity<int64_t>(\n      kernel::lib ptr_lib,\n      const int64_t *index,\n      int64_t length,\n      int64_t lencontent,\n      bool isoption) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_validity(\n          index,\n          length,\n          lencontent,\n          isoption);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArray64_validity, ptr_lib);\n        return (*awkward_IndexedArray64_validity_fcn)(\n          index,\n          length,\n          lencontent,\n          isoption);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_validity<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_validity<int8_t, int32_t>(\n      kernel::lib ptr_lib,\n      const int8_t *tags,\n      const int32_t *index,\n      int64_t length,\n      int64_t numcontents,\n      const int64_t *lencontents) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_32_validity(\n          tags,\n          index,\n          length,\n          numcontents,\n          lencontents);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_UnionArray8_32_validity, ptr_lib);\n        return (*awkward_UnionArray8_32_validity_fcn)(\n          tags,\n          index,\n          length,\n          numcontents,\n          lencontents);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_validity<int8_t, int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_validity<int8_t, uint32_t>(\n      kernel::lib ptr_lib,\n      const int8_t *tags,\n      const uint32_t *index,\n      int64_t length,\n      int64_t numcontents,\n      const int64_t *lencontents) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_U32_validity(\n          tags,\n          index,\n          length,\n          numcontents,\n          lencontents);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_UnionArray8_U32_validity, ptr_lib);\n        return (*awkward_UnionArray8_U32_validity_fcn)(\n          tags,\n          index,\n          length,\n          numcontents,\n          lencontents);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_validity<int8_t, uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_validity<int8_t, int64_t>(\n      kernel::lib ptr_lib,\n      const int8_t *tags,\n      const int64_t *index,\n      int64_t length,\n      int64_t numcontents,\n      const int64_t *lencontents) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray8_64_validity(\n          tags,\n          index,\n          length,\n          numcontents,\n          lencontents);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_UnionArray8_64_validity, ptr_lib);\n        return (*awkward_UnionArray8_64_validity_fcn)(\n          tags,\n          index,\n          length,\n          numcontents,\n          lencontents);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_validity<int8_t, int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_fillna_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int32_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray_fillna_from32_to64(\n          toindex,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_UnionArray_fillna_from32_to64, ptr_lib);\n        return (*awkward_UnionArray_fillna_from32_to64_fcn)(\n          toindex,\n          fromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_fillna_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_fillna_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const uint32_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray_fillna_fromU32_to64(\n          toindex,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_UnionArray_fillna_fromU32_to64, ptr_lib);\n        return (*awkward_UnionArray_fillna_fromU32_to64_fcn)(\n          toindex,\n          fromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_fillna_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR UnionArray_fillna_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_UnionArray_fillna_from64_to64(\n          toindex,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_UnionArray_fillna_from64_to64, ptr_lib);\n        return (*awkward_UnionArray_fillna_from64_to64_fcn)(\n          toindex,\n          fromindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for UnionArray_fillna_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR IndexedOptionArray_rpad_and_clip_mask_axis1_64(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int8_t *frommask,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedOptionArray_rpad_and_clip_mask_axis1_64(\n          toindex,\n          frommask,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedOptionArray_rpad_and_clip_mask_axis1_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedOptionArray_rpad_and_clip_mask_axis1_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR index_rpad_and_clip_axis0_64(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t target,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_index_rpad_and_clip_axis0_64(\n          toindex,\n          target,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for index_rpad_and_clip_axis0_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for index_rpad_and_clip_axis0_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR index_rpad_and_clip_axis1_64(\n      kernel::lib ptr_lib,\n      int64_t *tostarts,\n      int64_t *tostops,\n      int64_t target,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_index_rpad_and_clip_axis1_64(\n          tostarts,\n          tostops,\n          target,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for index_rpad_and_clip_axis1_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for index_rpad_and_clip_axis1_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_rpad_and_clip_axis1_64(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t target,\n      int64_t size,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_rpad_and_clip_axis1_64(\n          toindex,\n          target,\n          size,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_rpad_and_clip_axis1_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_rpad_and_clip_axis1_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_min_range<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tomin,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_min_range(\n          tomin,\n          fromstarts,\n          fromstops,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArray32_min_range, ptr_lib);\n        return (*awkward_ListArray32_min_range_fcn)(\n          tomin,\n          fromstarts,\n          fromstops,\n          lenstarts);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_min_range<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_min_range<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tomin,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_min_range(\n          tomin,\n          fromstarts,\n          fromstops,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArrayU32_min_range, ptr_lib);\n        return (*awkward_ListArrayU32_min_range_fcn)(\n          tomin,\n          fromstarts,\n          fromstops,\n          lenstarts);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_min_range<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_min_range<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tomin,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_min_range(\n          tomin,\n          fromstarts,\n          fromstops,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListArray64_min_range, ptr_lib);\n        return (*awkward_ListArray64_min_range_fcn)(\n          tomin,\n          fromstarts,\n          fromstops,\n          lenstarts);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_min_range<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_rpad_and_clip_length_axis1<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tolength,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int64_t target,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_rpad_and_clip_length_axis1(\n          tolength,\n          fromstarts,\n          fromstops,\n          target,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_rpad_and_clip_length_axis1<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_rpad_and_clip_length_axis1<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_rpad_and_clip_length_axis1<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *tolength,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      int64_t target,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_rpad_and_clip_length_axis1(\n          tolength,\n          fromstarts,\n          fromstops,\n          target,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_rpad_and_clip_length_axis1<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_rpad_and_clip_length_axis1<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_rpad_and_clip_length_axis1<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tolength,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t target,\n      int64_t lenstarts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_rpad_and_clip_length_axis1(\n          tolength,\n          fromstarts,\n          fromstops,\n          target,\n          lenstarts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_rpad_and_clip_length_axis1<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_rpad_and_clip_length_axis1<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_rpad_axis1_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int32_t *fromstarts,\n      const int32_t *fromstops,\n      int32_t *tostarts,\n      int32_t *tostops,\n      int64_t target,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_rpad_axis1_64(\n          toindex,\n          fromstarts,\n          fromstops,\n          tostarts,\n          tostops,\n          target,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_rpad_axis1_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_rpad_axis1_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_rpad_axis1_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const uint32_t *fromstarts,\n      const uint32_t *fromstops,\n      uint32_t *tostarts,\n      uint32_t *tostops,\n      int64_t target,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_rpad_axis1_64(\n          toindex,\n          fromstarts,\n          fromstops,\n          tostarts,\n          tostops,\n          target,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_rpad_axis1_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_rpad_axis1_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_rpad_axis1_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *fromstarts,\n      const int64_t *fromstops,\n      int64_t *tostarts,\n      int64_t *tostops,\n      int64_t target,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_rpad_axis1_64(\n          toindex,\n          fromstarts,\n          fromstops,\n          tostarts,\n          tostops,\n          target,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_rpad_axis1_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_rpad_axis1_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_rpad_and_clip_axis1_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int32_t *fromoffsets,\n      int64_t length,\n      int64_t target) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray32_rpad_and_clip_axis1_64(\n          toindex,\n          fromoffsets,\n          length,\n          target);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_rpad_and_clip_axis1_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_rpad_and_clip_axis1_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_rpad_and_clip_axis1_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const uint32_t *fromoffsets,\n      int64_t length,\n      int64_t target) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArrayU32_rpad_and_clip_axis1_64(\n          toindex,\n          fromoffsets,\n          length,\n          target);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_rpad_and_clip_axis1_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_rpad_and_clip_axis1_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_rpad_and_clip_axis1_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *fromoffsets,\n      int64_t length,\n      int64_t target) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray64_rpad_and_clip_axis1_64(\n          toindex,\n          fromoffsets,\n          length,\n          target);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_rpad_and_clip_axis1_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_rpad_and_clip_axis1_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_rpad_length_axis1<int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *tooffsets,\n      const int32_t *fromoffsets,\n      int64_t fromlength,\n      int64_t length,\n      int64_t *tocount) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray32_rpad_length_axis1(\n          tooffsets,\n          fromoffsets,\n          fromlength,\n          length,\n          tocount);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_rpad_length_axis1<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_rpad_length_axis1<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_rpad_length_axis1<uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *tooffsets,\n      const uint32_t *fromoffsets,\n      int64_t fromlength,\n      int64_t length,\n      int64_t *tocount) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArrayU32_rpad_length_axis1(\n          tooffsets,\n          fromoffsets,\n          fromlength,\n          length,\n          tocount);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_rpad_length_axis1<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_rpad_length_axis1<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_rpad_length_axis1<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *tooffsets,\n      const int64_t *fromoffsets,\n      int64_t fromlength,\n      int64_t length,\n      int64_t *tocount) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray64_rpad_length_axis1(\n          tooffsets,\n          fromoffsets,\n          fromlength,\n          length,\n          tocount);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_rpad_length_axis1<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_rpad_length_axis1<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_rpad_axis1_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int32_t *fromoffsets,\n      int64_t fromlength,\n      int64_t target) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray32_rpad_axis1_64(\n          toindex,\n          fromoffsets,\n          fromlength,\n          target);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_rpad_axis1_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_rpad_axis1_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_rpad_axis1_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const uint32_t *fromoffsets,\n      int64_t fromlength,\n      int64_t target) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArrayU32_rpad_axis1_64(\n          toindex,\n          fromoffsets,\n          fromlength,\n          target);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_rpad_axis1_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_rpad_axis1_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListOffsetArray_rpad_axis1_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *fromoffsets,\n      int64_t fromlength,\n      int64_t target) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray64_rpad_axis1_64(\n          toindex,\n          fromoffsets,\n          fromlength,\n          target);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_rpad_axis1_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_rpad_axis1_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR localindex_64(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_localindex_64(\n          toindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_localindex_64, ptr_lib);\n        return (*awkward_localindex_64_fcn)(\n          toindex,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for localindex_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_localindex_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int32_t *offsets,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_localindex_64(\n          toindex,\n          offsets,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_localindex_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_localindex_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_localindex_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const uint32_t *offsets,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_localindex_64(\n          toindex,\n          offsets,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_localindex_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_localindex_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_localindex_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const int64_t *offsets,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_localindex_64(\n          toindex,\n          offsets,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_localindex_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_localindex_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_localindex_64(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t size,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_localindex_64(\n          toindex,\n          size,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_localindex_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_localindex_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR combinations(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t n,\n      bool replacement,\n      int64_t singlelen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_combinations_64(\n          toindex,\n          n,\n          replacement,\n          singlelen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_combinations_64, ptr_lib);\n        return (*awkward_combinations_64_fcn)(\n          toindex,\n          n,\n          replacement,\n          singlelen);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for combinations\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_combinations_length_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *totallen,\n      int64_t *tooffsets,\n      int64_t n,\n      bool replacement,\n      const int32_t *starts,\n      const int32_t *stops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_combinations_length_64(\n          totallen,\n          tooffsets,\n          n,\n          replacement,\n          starts,\n          stops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_combinations_length_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_combinations_length_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_combinations_length_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *totallen,\n      int64_t *tooffsets,\n      int64_t n,\n      bool replacement,\n      const uint32_t *starts,\n      const uint32_t *stops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_combinations_length_64(\n          totallen,\n          tooffsets,\n          n,\n          replacement,\n          starts,\n          stops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_combinations_length_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_combinations_length_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_combinations_length_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *totallen,\n      int64_t *tooffsets,\n      int64_t n,\n      bool replacement,\n      const int64_t *starts,\n      const int64_t *stops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_combinations_length_64(\n          totallen,\n          tooffsets,\n          n,\n          replacement,\n          starts,\n          stops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_combinations_length_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_combinations_length_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_combinations_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t **tocarry,\n      int64_t *toindex,\n      int64_t *fromindex,\n      int64_t n,\n      bool replacement,\n      const int32_t *starts,\n      const int32_t *stops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray32_combinations_64(\n          tocarry,\n          toindex,\n          fromindex,\n          n,\n          replacement,\n          starts,\n          stops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_combinations_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_combinations_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_combinations_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t **tocarry,\n      int64_t *toindex,\n      int64_t *fromindex,\n      int64_t n,\n      bool replacement,\n      const uint32_t *starts,\n      const uint32_t *stops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArrayU32_combinations_64(\n          tocarry,\n          toindex,\n          fromindex,\n          n,\n          replacement,\n          starts,\n          stops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_combinations_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_combinations_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR ListArray_combinations_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t **tocarry,\n      int64_t *toindex,\n      int64_t *fromindex,\n      int64_t n,\n      bool replacement,\n      const int64_t *starts,\n      const int64_t *stops,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListArray64_combinations_64(\n          tocarry,\n          toindex,\n          fromindex,\n          n,\n          replacement,\n          starts,\n          stops,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListArray_combinations_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListArray_combinations_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR RegularArray_combinations_64(\n      kernel::lib ptr_lib,\n      int64_t **tocarry,\n      int64_t *toindex,\n      int64_t *fromindex,\n      int64_t n,\n      bool replacement,\n      int64_t size,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_RegularArray_combinations_64(\n          tocarry,\n          toindex,\n          fromindex,\n          n,\n          replacement,\n          size,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for RegularArray_combinations_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for RegularArray_combinations_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_overlay_mask8(\n      kernel::lib ptr_lib,\n      int8_t *tomask,\n      const int8_t *theirmask,\n      const int8_t *mymask,\n      int64_t length,\n      bool validwhen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_overlay_mask8(\n          tomask,\n          theirmask,\n          mymask,\n          length,\n          validwhen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ByteMaskedArray_overlay_mask8\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_overlay_mask8\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR BitMaskedArray_to_ByteMaskedArray(\n      kernel::lib ptr_lib,\n      int8_t *tobytemask,\n      const uint8_t *frombitmask,\n      int64_t bitmasklength,\n      bool validwhen,\n      bool lsb_order) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_BitMaskedArray_to_ByteMaskedArray(\n          tobytemask,\n          frombitmask,\n          bitmasklength,\n          validwhen,\n          lsb_order);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for BitMaskedArray_to_ByteMaskedArray\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for BitMaskedArray_to_ByteMaskedArray\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR BitMaskedArray_to_IndexedOptionArray64(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      const uint8_t *frombitmask,\n      int64_t bitmasklength,\n      bool validwhen,\n      bool lsb_order) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_BitMaskedArray_to_IndexedOptionArray64(\n          toindex,\n          frombitmask,\n          bitmasklength,\n          validwhen,\n          lsb_order);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for BitMaskedArray_to_IndexedOptionArray64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for BitMaskedArray_to_IndexedOptionArray64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    /////////////////////////////////// awkward/kernels/reducers.h\n\n    ERROR reduce_count_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_count_64(\n          toptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_count_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_count_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const bool *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_bool_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_int64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_uint64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const float *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_float32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_countnonzero_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const double *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_countnonzero_float64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_countnonzero_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const bool *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_int64_bool_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_int64_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_uint64_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_int64_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_uint64_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_int64_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_uint64_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_int64_int64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_uint64_uint64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      float *toptr,\n      const float *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_float32_float32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      double *toptr,\n      const double *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_float64_float64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const bool *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_int32_bool_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_int32_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_uint32_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_int32_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_uint32_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_int32_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_64(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_uint32_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const bool *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_bool_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const int64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_int64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const uint64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_uint64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const float *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_float32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_sum_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const double *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_sum_bool_float64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_sum_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const bool *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_int64_bool_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_int64_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_uint64_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_int64_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_uint64_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_int64_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_uint64_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_int64_int64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_uint64_uint64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      float *toptr,\n      const float *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_float32_float32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      double *toptr,\n      const double *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_float64_float64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const bool *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_int32_bool_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_int32_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_uint32_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_int32_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_uint32_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_int32_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_64(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_uint32_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const bool *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_bool_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const int64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_int64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const uint64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_uint64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const float *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_float32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_prod_bool_64(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const double *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_prod_bool_float64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_prod_bool_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      int8_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_int8_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      uint8_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_uint8_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      int16_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_int16_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      uint16_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_uint16_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      int32_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_int32_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      uint32_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_uint32_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      int64_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_int64_int64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      uint64_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_uint64_uint64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      float *toptr,\n      const float *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      float identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_float32_float32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_min_64(\n      kernel::lib ptr_lib,\n      double *toptr,\n      const double *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      double identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_min_float64_float64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_min_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      int8_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_int8_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      uint8_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_uint8_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      int16_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_int16_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      uint16_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_uint16_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      int32_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_int32_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      uint32_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_uint32_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      int64_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_int64_int64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      uint64_t identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_uint64_uint64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      float *toptr,\n      const float *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      float identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_float32_float32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_max_64(\n      kernel::lib ptr_lib,\n      double *toptr,\n      const double *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength,\n      double identity) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_max_float64_float64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength,\n          identity);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_max_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const bool *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_bool_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_int64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_uint64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const float *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_float32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmin_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const double *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmin_float64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmin_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const bool *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_bool_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_int8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_uint8_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_int16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint16_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_uint16_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_int32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint32_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_uint32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_int64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint64_t *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_uint64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const float *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_float32_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR reduce_argmax_64(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const double *fromptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_reduce_argmax_float64_64(\n          toptr,\n          fromptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for reduce_argmax_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR content_reduce_zeroparents_64(\n      kernel::lib ptr_lib,\n      int64_t *toparents,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_content_reduce_zeroparents_64(\n          toparents,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_content_reduce_zeroparents_64, ptr_lib);\n        return (*awkward_content_reduce_zeroparents_64_fcn)(\n          toparents,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for content_reduce_zeroparents_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_reduce_global_startstop_64(\n      kernel::lib ptr_lib,\n      int64_t *globalstart,\n      int64_t *globalstop,\n      const int64_t *offsets,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_reduce_global_startstop_64(\n          globalstart,\n          globalstop,\n          offsets,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListOffsetArray_reduce_global_startstop_64, ptr_lib);\n        return (*awkward_ListOffsetArray_reduce_global_startstop_64_fcn)(\n          globalstart,\n          globalstop,\n          offsets,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_reduce_global_startstop_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_reduce_nonlocal_maxcount_offsetscopy_64(\n      kernel::lib ptr_lib,\n      int64_t *maxcount,\n      int64_t *offsetscopy,\n      const int64_t *offsets,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_reduce_nonlocal_maxcount_offsetscopy_64(\n          maxcount,\n          offsetscopy,\n          offsets,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListOffsetArray_reduce_nonlocal_maxcount_offsetscopy_64, ptr_lib);\n        return (*awkward_ListOffsetArray_reduce_nonlocal_maxcount_offsetscopy_64_fcn)(\n          maxcount,\n          offsetscopy,\n          offsets,\n          length);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_reduce_nonlocal_maxcount_offsetscopy_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_reduce_nonlocal_preparenext_64(\n      kernel::lib ptr_lib,\n      int64_t *nextcarry,\n      int64_t *nextparents,\n      int64_t nextlen,\n      int64_t *maxnextparents,\n      int64_t *distincts,\n      int64_t distinctslen,\n      int64_t *offsetscopy,\n      const int64_t *offsets,\n      int64_t length,\n      const int64_t *parents,\n      int64_t maxcount) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_reduce_nonlocal_preparenext_64(\n          nextcarry,\n          nextparents,\n          nextlen,\n          maxnextparents,\n          distincts,\n          distinctslen,\n          offsetscopy,\n          offsets,\n          length,\n          parents,\n          maxcount);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_reduce_nonlocal_preparenext_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_reduce_nonlocal_preparenext_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_reduce_nonlocal_nextstarts_64(\n      kernel::lib ptr_lib,\n      int64_t *nextstarts,\n      const int64_t *nextparents,\n      int64_t nextlen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_reduce_nonlocal_nextstarts_64(\n          nextstarts,\n          nextparents,\n          nextlen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_ListOffsetArray_reduce_nonlocal_nextstarts_64, ptr_lib);\n        return (*awkward_ListOffsetArray_reduce_nonlocal_nextstarts_64_fcn)(\n          nextstarts,\n          nextparents,\n          nextlen);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_reduce_nonlocal_nextstarts_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_reduce_nonlocal_findgaps_64(\n      kernel::lib ptr_lib,\n      int64_t *gaps,\n      const int64_t *parents,\n      int64_t lenparents) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_reduce_nonlocal_findgaps_64(\n          gaps,\n          parents,\n          lenparents);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_reduce_nonlocal_findgaps_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_reduce_nonlocal_findgaps_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_reduce_nonlocal_outstartsstops_64(\n      kernel::lib ptr_lib,\n      int64_t *outstarts,\n      int64_t *outstops,\n      const int64_t *distincts,\n      int64_t lendistincts,\n      const int64_t *gaps,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_reduce_nonlocal_outstartsstops_64(\n          outstarts,\n          outstops,\n          distincts,\n          lendistincts,\n          gaps,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_reduce_nonlocal_outstartsstops_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_reduce_nonlocal_outstartsstops_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_reduce_nonlocal_nextshifts_64(\n      kernel::lib ptr_lib,\n      int64_t* nummissing,\n      int64_t* missing,\n      int64_t* nextshifts,\n      const int64_t* offsets,\n      int64_t length,\n      const int64_t* starts,\n      const int64_t* parents,\n      int64_t maxcount,\n      int64_t nextlen,\n      const int64_t* nextcarry) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_reduce_nonlocal_nextshifts_64(\n          nummissing,\n          missing,\n          nextshifts,\n          offsets,\n          length,\n          starts,\n          parents,\n          maxcount,\n          nextlen,\n          nextcarry);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_reduce_nonlocal_nextshifts_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_reduce_nonlocal_nextshifts_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_reduce_local_nextparents_64(\n      kernel::lib ptr_lib,\n      int64_t *nextparents,\n      const int64_t *offsets,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_reduce_local_nextparents_64(\n          nextparents,\n          offsets,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_reduce_local_nextparents_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_reduce_local_nextparents_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_reduce_local_outoffsets_64(\n      kernel::lib ptr_lib,\n      int64_t *outoffsets,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_reduce_local_outoffsets_64(\n          outoffsets,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_reduce_local_outoffsets_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_reduce_local_outoffsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_reduce_next_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *nextcarry,\n      int64_t *nextparents,\n      int64_t *outindex,\n      const int32_t *index,\n      int64_t *parents,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_reduce_next_64(\n          nextcarry,\n          nextparents,\n          outindex,\n          index,\n          parents,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_reduce_next_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_reduce_next_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *nextcarry,\n      int64_t *nextparents,\n      int64_t *outindex,\n      const uint32_t *index,\n      int64_t *parents,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_reduce_next_64(\n          nextcarry,\n          nextparents,\n          outindex,\n          index,\n          parents,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_reduce_next_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR IndexedArray_reduce_next_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *nextcarry,\n      int64_t *nextparents,\n      int64_t *outindex,\n      const int64_t *index,\n      int64_t *parents,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_reduce_next_64(\n          nextcarry,\n          nextparents,\n          outindex,\n          index,\n          parents,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_reduce_next_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR IndexedArray_reduce_next_nonlocal_nextshifts_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t* nextshifts,\n      const int32_t* index,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_reduce_next_nonlocal_nextshifts_64(\n          nextshifts,\n          index,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_reduce_next_nonlocal_nextshifts_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_nonlocal_nextshifts_64<int32_t\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR IndexedArray_reduce_next_nonlocal_nextshifts_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t* nextshifts,\n      const uint32_t* index,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_reduce_next_nonlocal_nextshifts_64(\n          nextshifts,\n          index,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_reduce_next_nonlocal_nextshifts_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_nonlocal_nextshifts_64<uint32_t\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR IndexedArray_reduce_next_nonlocal_nextshifts_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t* nextshifts,\n      const int64_t* index,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_reduce_next_nonlocal_nextshifts_64(\n          nextshifts,\n          index,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_reduce_next_nonlocal_nextshifts_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_nonlocal_nextshifts_64<int64_t\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR IndexedArray_reduce_next_nonlocal_nextshifts_fromshifts_64<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t* nextshifts,\n      const int32_t* index,\n      int64_t length,\n      const int64_t* shifts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray32_reduce_next_nonlocal_nextshifts_fromshifts_64(\n          nextshifts,\n          index,\n          length,\n          shifts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_reduce_next_nonlocal_nextshifts_fromshifts_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_nonlocal_nextshifts_fromshifts_64<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR IndexedArray_reduce_next_nonlocal_nextshifts_fromshifts_64<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t* nextshifts,\n      const uint32_t* index,\n      int64_t length,\n      const int64_t* shifts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArrayU32_reduce_next_nonlocal_nextshifts_fromshifts_64(\n          nextshifts,\n          index,\n          length,\n          shifts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_reduce_next_nonlocal_nextshifts_fromshifts_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_nonlocal_nextshifts_fromshifts_64<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template <>\n    ERROR IndexedArray_reduce_next_nonlocal_nextshifts_fromshifts_64<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t* nextshifts,\n      const int64_t* index,\n      int64_t length,\n      const int64_t* shifts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray64_reduce_next_nonlocal_nextshifts_fromshifts_64(\n          nextshifts,\n          index,\n          length,\n          shifts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_reduce_next_nonlocal_nextshifts_fromshifts_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_nonlocal_nextshifts_fromshifts_64<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR IndexedArray_reduce_next_fix_offsets_64(\n      kernel::lib ptr_lib,\n      int64_t *outoffsets,\n      const int64_t *starts,\n      int64_t startslength,\n      int64_t outindexlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray_reduce_next_fix_offsets_64(\n          outoffsets,\n          starts,\n          startslength,\n          outindexlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        CREATE_KERNEL(awkward_IndexedArray_reduce_next_fix_offsets_64, ptr_lib);\n        return (*awkward_IndexedArray_reduce_next_fix_offsets_64_fcn)(\n          outoffsets,\n          starts,\n          startslength,\n          outindexlength);\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_reduce_next_fix_offsets_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_reduce_adjust_starts_64(\n      kernel::lib ptr_lib,\n      int64_t* toptr,\n      int64_t outlength,\n      const int64_t* parents,\n      const int64_t* starts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_reduce_adjust_starts_64(\n          toptr,\n          outlength,\n          parents,\n          starts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_reduce_adjust_starts_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_reduce_adjust_starts_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_reduce_adjust_starts_shifts_64(\n      kernel::lib ptr_lib,\n      int64_t* toptr,\n      int64_t outlength,\n      const int64_t* parents,\n      const int64_t* starts,\n      const int64_t* shifts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_reduce_adjust_starts_shifts_64(\n          toptr,\n          outlength,\n          parents,\n          starts,\n          shifts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_reduce_adjust_starts_shifts_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_reduce_adjust_starts_shifts_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR NumpyArray_reduce_mask_ByteMaskedArray_64(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      const int64_t *parents,\n      int64_t lenparents,\n      int64_t outlength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_reduce_mask_ByteMaskedArray_64(\n          toptr,\n          parents,\n          lenparents,\n          outlength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_reduce_mask_ByteMaskedArray_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_reduce_mask_ByteMaskedArray_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_reduce_next_64(\n      kernel::lib ptr_lib,\n      int64_t *nextcarry,\n      int64_t *nextparents,\n      int64_t *outindex,\n      const int8_t *mask,\n      const int64_t *parents,\n      int64_t length,\n      bool valid_when) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_reduce_next_64(\n          nextcarry,\n          nextparents,\n          outindex,\n          mask,\n          parents,\n          length,\n          valid_when);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ByteMaskedArray_reduce_next_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_reduce_next_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_reduce_next_nonlocal_nextshifts_64(\n      kernel::lib ptr_lib,\n      int64_t* nextshifts,\n      const int8_t* mask,\n      int64_t length,\n      bool valid_when) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_reduce_next_nonlocal_nextshifts_64(\n          nextshifts,\n          mask,\n          length,\n          valid_when);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ByteMaskedArray_reduce_next_nonlocal_nextshifts_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_reduce_next_nonlocal_nextshifts_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ByteMaskedArray_reduce_next_nonlocal_nextshifts_fromshifts_64(\n      kernel::lib ptr_lib,\n      int64_t* nextshifts,\n      const int8_t* mask,\n      int64_t length,\n      bool valid_when,\n      const int64_t* shifts) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ByteMaskedArray_reduce_next_nonlocal_nextshifts_fromshifts_64(\n          nextshifts,\n          mask,\n          length,\n          valid_when,\n          shifts);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ByteMaskedArray_reduce_next_nonlocal_nextshifts_fromshifts_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ByteMaskedArray_reduce_next_nonlocal_nextshifts_fromshifts_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    /////////////////////////////////// awkward/kernels/sorting.h\n\n    ERROR sorting_ranges(\n      kernel::lib ptr_lib,\n      int64_t *toindex,\n      int64_t tolength,\n      const int64_t *parents,\n      int64_t parentslength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sorting_ranges(\n          toindex,\n          tolength,\n          parents,\n          parentslength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for sorting_ranges\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for sorting_ranges\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR sorting_ranges_length(\n      kernel::lib ptr_lib,\n      int64_t *tolength,\n      const int64_t *parents,\n      int64_t parentslength) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sorting_ranges_length(\n          tolength,\n          parents,\n          parentslength);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for sorting_ranges_length\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for sorting_ranges_length\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<bool>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const bool *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_bool(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<int8_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int8_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_int8(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<uint8_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint8_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_uint8(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<int16_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int16_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_int16(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<uint16_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint16_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_uint16(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<int32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int32_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_int32(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<uint32_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint32_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_uint32(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_int64(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<uint64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const uint64_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_uint64(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<float>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const float *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_float32(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_argsort<double>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const double *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_argsort_float64(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_argsort<double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_argsort<double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<bool>(\n      kernel::lib ptr_lib,\n      bool *toptr,\n      const bool *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_bool(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<bool>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<bool>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      const uint8_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_uint8(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<int8_t>(\n      kernel::lib ptr_lib,\n      int8_t *toptr,\n      const int8_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_int8(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<int8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<int8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<uint16_t>(\n      kernel::lib ptr_lib,\n      uint16_t *toptr,\n      const uint16_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_uint16(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<uint16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<int16_t>(\n      kernel::lib ptr_lib,\n      int16_t *toptr,\n      const int16_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_int16(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<int16_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<int16_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<uint32_t>(\n      kernel::lib ptr_lib,\n      uint32_t *toptr,\n      const uint32_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_uint32(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<uint32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<int32_t>(\n      kernel::lib ptr_lib,\n      int32_t *toptr,\n      const int32_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_int32(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<int32_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<uint64_t>(\n      kernel::lib ptr_lib,\n      uint64_t *toptr,\n      const uint64_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_uint64(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<uint64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<int64_t>(\n      kernel::lib ptr_lib,\n      int64_t *toptr,\n      const int64_t *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_int64(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<int64_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<float>(\n      kernel::lib ptr_lib,\n      float *toptr,\n      const float *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_float32(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<float>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<float>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort<double>(\n      kernel::lib ptr_lib,\n      double *toptr,\n      const double *fromptr,\n      int64_t length,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t parentslength,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_sort_float64(\n          toptr,\n          fromptr,\n          length,\n          offsets,\n          offsetslength,\n          parentslength,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort<double>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort<double>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    template<>\n    ERROR NumpyArray_sort_asstrings<uint8_t>(\n      kernel::lib ptr_lib,\n      uint8_t *toptr,\n      const uint8_t *fromptr,\n      const int64_t *offsets,\n      int64_t offsetslength,\n      int64_t *outoffsets,\n      bool ascending,\n      bool stable) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_NumpyArray_sort_asstrings_uint8(\n          toptr,\n          fromptr,\n          offsets,\n          offsetslength,\n          outoffsets,\n          ascending,\n          stable);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for NumpyArray_sort_asstrings<uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for NumpyArray_sort_asstrings<uint8_t>\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR ListOffsetArray_local_preparenext_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *fromindex,\n      int64_t length) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_ListOffsetArray_local_preparenext_64(\n          tocarry,\n          fromindex,\n          length);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for ListOffsetArray_local_preparenext_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for ListOffsetArray_local_preparenext_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n    ERROR IndexedArray_local_preparenext_64(\n      kernel::lib ptr_lib,\n      int64_t *tocarry,\n      const int64_t *starts,\n      const int64_t *parents,\n      const int64_t parentslength,\n      const int64_t *nextparents,\n      const int64_t nextlen) {\n      if (ptr_lib == kernel::lib::cpu) {\n        return awkward_IndexedArray_local_preparenext_64(\n          tocarry,\n          starts,\n          parents,\n          parentslength,\n          nextparents,\n          nextlen);\n      }\n      else if (ptr_lib == kernel::lib::cuda) {\n        throw std::runtime_error(\n          std::string(\"not implemented: ptr_lib == cuda_kernels for IndexedArray_local_preparenext_64\")\n          + FILENAME(__LINE__));\n      }\n      else {\n        throw std::runtime_error(\n          std::string(\"unrecognized ptr_lib for IndexedArray_local_preparenext_64\")\n          + FILENAME(__LINE__));\n      }\n    }\n\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/src/python/startup.cpp": "// BSD 3-Clause License; see https://github.com/scikit-hep/awkward-1.0/blob/master/LICENSE\n\n#include <iostream>\n#include <string>\n\n#include \"awkward/python/startup.h\"\n\n namespace ak = awkward;\n\nstd::string StartupLibraryPathCallback::library_path() {\n  // Fetches Path Eagerly\n  std::string eager_path;\n\n  try {\n    py::object awkward1_cuda_kernels = py::module::import(\n      \"awkward1_cuda_kernels\");\n\n    if (py::hasattr(awkward1_cuda_kernels, \"shared_library_path\")) {\n      py::object library_path_pyobj = py::getattr(awkward1_cuda_kernels,\n                                                  \"shared_library_path\");\n      eager_path = library_path_pyobj.cast<std::string>();\n    }\n  }\n  catch (...) {\n    // If the Python Extension fails to import the module, fall back to the\n    // previous fetched path\n    eager_path = library_path_;\n  }\n\n  // Keep the Library Patch as a cache, this will fetch paths even when the shared\n  // library path is changed but in case of a failure it will revert to the last\n  // successful library fetch. In case the shared Library ceases to exist, it will\n  // be handled by the dlopen and dlsym in the C++ layer.\n  library_path_ = eager_path;\n\n  return library_path_;\n}\n\nvoid\nmake_startup(py::module& m, const std::string& name) {\n  m.def(name.c_str(), []() -> void {\n    ak::kernel::lib_callback->add_library_path_callback(\n      ak::kernel::lib::cuda, std::make_shared<StartupLibraryPathCallback>());\n  });\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/studies/chep-2019/read_ttree.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/studies/chep-2019/read_ttree.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/panel-developers.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/panel-tutorials.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/panel-sphinx.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/panel-data-analysts.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/panel-doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/panel-tutorials-alternate.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/screenshots/github-issues-documentation.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/plots/awkward-0-popularity.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/plots/awkward-0-popularity.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/photos/desire-path.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/diagrams/cartoon-combinations.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/diagrams/cartoon-broadcasting.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/diagrams/git-strategy.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/diagrams/cartoon-cartesian.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/diagrams/awkward-1-0-layers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/diagrams/awkward-1-0-layers.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/diagrams/git-strategy.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/diagrams/how-it-works-muons.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/diagrams/cartoon-schematic.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/logo/logo-300px.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/logo/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-img/logo/logo-600px.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/list-depths-records-list.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/list-depths-strings.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/nullable-list-depths-strings.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/nullable-record-primitives.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/nullable-levels.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/nullable-list-depths-records-list.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/nullable-depths.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/nullable-list-depths-records.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/list-depths-simple.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/list-depths.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/nullable-record-primitives-simple.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/list-lengths.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/nonnullable-depths.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/list-depths-records.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/nullable-list-depths.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/tests/samples/record-primitives.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-jupyter/img/github-fraction.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-jupyter/img/hydra-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-jupyter/img/example-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-jupyter/img/ttbarHDecayDiagram_expanded.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-src/img/logo-300px.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-src/img/desire-path.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-src/img/github-issues-documentation.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-awkward1-0.3.1-i746s5vryut5z2mp6ftnhk3qxrdjrvdb/spack-src/docs-src/img/favicon.ico"
    ],
    "total_files": 542
}