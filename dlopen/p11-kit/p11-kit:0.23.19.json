{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/configure.ac": "AC_PREREQ(2.61)\n\nAC_INIT([p11-kit],\n\t[0.23.19],\n\t[https://github.com/p11-glue/p11-kit/issues],\n\t[p11-kit],\n\t[https://p11-glue.github.io/p11-glue/p11-kit.html])\n\n# ------------------------------------------------------------------------------\n# p11-kit libtool versioning\n# CURRENT : REVISION : AGE\n#   +1    :     0    : +1   == new interface that does not break old one.\n#   +1    :     0    :  0   == removed an interface. Breaks old apps.\n#    ?    :    +1    :  ?   == internal changes that doesn't break anything.\n\nP11KIT_CURRENT=3\nP11KIT_REVISION=0\nP11KIT_AGE=3\n\n# ------------------------------------------------------------------------------\n\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_MACRO_DIR([build/m4])\nAC_CONFIG_AUX_DIR([build/litter])\nAC_REQUIRE_AUX_FILE([tap-driver.sh])\nAM_INIT_AUTOMAKE([1.12 dist-xz no-dist-gzip foreign subdir-objects])\nAM_SANITY_CHECK\nAM_MAINTAINER_MODE([enable])\nm4_ifdef([AM_SILENT_RULES],[AM_SILENT_RULES([yes])],)\nm4_ifdef([PKG_PREREQ], [PKG_PREREQ(0.29)],\n  [m4_fatal([pkg.m4 is too old; copy the latest version in build/m4])])\n\ndnl Enable platform specific extensions.\nAC_USE_SYSTEM_EXTENSIONS\n\nLT_PREREQ([2.2.6])\nLT_INIT([dlopen disable-static])\n\ndnl Check if -Wl,--version-script is supported by the linker\ngl_LD_VERSION_SCRIPT\n\ndnl Checks for programs.\nAC_PROG_CC\nAC_PROG_CPP\nAM_PROG_CC_C_O\nPKG_PROG_PKG_CONFIG\n\nLINGUAS=\"\"\nAM_GNU_GETTEXT([external], [need-ngettext])\nAM_GNU_GETTEXT_VERSION([0.19.8])\nm4_ifdef([AM_GNU_GETTEXT_REQUIRE_VERSION],[\nAM_GNU_GETTEXT_REQUIRE_VERSION([0.19.8])\n])\n\nif test \"$enable_static\" = \"yes\"; then\n\tAC_MSG_ERROR([p11-kit cannot be used as a static library])\nfi\n\nAC_MSG_CHECKING([for win32])\ncase \"$host\" in\n\t*-*-mingw*)\n\t\tAC_DEFINE_UNQUOTED(OS_WIN32, 1, [Building for win32])\n\t\tos_win32=yes\n\t\tos_unix=no\n\t\t;;\n\t*)\n\t\tAC_DEFINE_UNQUOTED(OS_UNIX, 1, [Building for unix])\n\t\tos_win32=no\n\t\tos_unix=yes\n\t\t;;\nesac\nAC_MSG_RESULT([$os_win32])\nAM_CONDITIONAL(OS_WIN32, test \"$os_win32\" = \"yes\")\n\nAC_C_BIGENDIAN\n\n# ------------------------------------------------------------------------------\n# Checks for libraries and headers\n\nAC_HEADER_STDBOOL\n\nAC_CHECK_SIZEOF([unsigned long])\n\nif test \"$os_unix\" = \"yes\"; then\n\tAC_CHECK_FUNC([pthread_create], , [\n\t\tAC_CHECK_LIB(pthread, pthread_create, , [\n\t\t\tAC_MSG_ERROR([could not find pthread_create])\n\t\t])\n\t])\n\n\tAC_CHECK_FUNC([nanosleep], , [\n\t\tAC_SEARCH_LIBS([nanosleep], [rt], , [\n\t\t\tAC_MSG_ERROR([could not find nanosleep])\n\t\t])\n\t])\n\n\tAC_SEARCH_LIBS([dlopen], [dl dld], [], [\n\t\tAC_MSG_ERROR([could not find dlopen])\n\t])\n\n\t# for Solaris we need -lsocket -lnsl for socket stuff, gethostbyname\n\t# is just a dummy to find -lnsl\n\tAC_SEARCH_LIBS([gethostbyname], [nsl])\n\tAC_SEARCH_LIBS([connect], [socket], [], [\n\t\tAC_MSG_ERROR([could not find socket])\n\t])\n\n\tAC_CHECK_HEADERS([locale.h], [\n\t\tAC_CHECK_TYPES([locale_t], [], [], [[#include <locale.h>]])\n\t\tAC_CHECK_FUNCS([newlocale strerror_l])\n\t])\n\n\t# These are things we can work around\n\tAC_CHECK_HEADERS([sys/resource.h ucred.h])\n\tAC_CHECK_MEMBERS([struct dirent.d_type],,,[#include <dirent.h>])\n\tAC_CHECK_FUNCS([getprogname getexecname basename mkstemp mkdtemp])\n\tAC_CHECK_FUNCS([getauxval getresuid secure_getenv])\n\tAC_CHECK_FUNCS([strnstr memdup strndup strerror_r])\n\tAC_CHECK_FUNCS([reallocarray])\n\tAC_CHECK_DECLS([reallocarray], [], [], [[#include <stdlib.h>]])\n\tAC_CHECK_FUNCS([fdwalk])\n\tAC_CHECK_FUNCS([setenv])\n\tAC_CHECK_FUNCS([getpeereid])\n\tAC_CHECK_FUNCS([getpeerucred])\n\tAC_CHECK_FUNCS([issetugid])\n\n\tAC_CACHE_CHECK([for thread-local storage class],\n\t\t[ac_cv_tls_keyword],\n\t\t[ac_cv_tls_keyword=\n\t\tfor keyword in _Thread_local __thread; do\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <stdlib.h>]],\n\t\t\t[[static ]$keyword[ foo;]])],\n\t\t\t[ac_cv_tls_keyword=$keyword])\n\t\tdone])\n\tif test -n \"$ac_cv_tls_keyword\"; then\n\t\tAC_DEFINE_UNQUOTED([P11_TLS_KEYWORD], [$ac_cv_tls_keyword], [the compiler keyword to define thread-local storage])\n\tfi\n\n\t# Required functions\n\tAC_CHECK_FUNCS([gmtime_r],\n\t\t[AC_DEFINE([HAVE_GMTIME_R], 1, [Whether gmtime_r() is available])],\n\t\t[AC_MSG_ERROR([could not find required gmtime_r() function])])\n\n\t# Check if these are declared and/or available to link against\n\tAC_CHECK_DECLS([program_invocation_short_name], [], [], [#include <errno.h>])\n\tAC_MSG_CHECKING([whether program_invocation_short_name is available])\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <errno.h>]],\n\t                                [[program_invocation_short_name = \"test\";]])],\n\t               [AC_DEFINE([HAVE_PROGRAM_INVOCATION_SHORT_NAME], [1],\n\t                          [Whether program_invocation_short_name available])\n\t                AC_MSG_RESULT([yes])],\n\t               [AC_MSG_RESULT([no])])\n\tAC_CHECK_DECLS([__progname])\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[extern char *__progname;]], [[__progname=(char*)0;]])],\n\t\t[AC_DEFINE(HAVE___PROGNAME, [1], [Whether __progname available])])\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[extern int __libc_enable_secure;]], [[__libc_enable_secure = 0;]])],\n\t\t[AC_DEFINE(HAVE___LIBC_ENABLE_SECURE, [1], [Whether __libc_enable_secure available])])\n\tAC_CHECK_TYPES([sighandler_t, sig_t, __sighandler_t], [], [],\n\t\t[[#include <sys/types.h>\n\t\t  #include <signal.h>]])\n\n\tAC_MSG_CHECKING([whether vsock support is available])\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>\n\t\t\t\t\t  #include <linux/vm_sockets.h>]],\n\t                                [[struct sockaddr_vm sa = {\n\t\t\t\t\t  .svm_family = AF_VSOCK,\n\t\t\t\t\t  .svm_cid = VMADDR_CID_ANY,\n\t\t\t\t\t  };\n\t\t\t\t\t  (void)&sa;\n\t\t\t\t\t  return 0;]])],\n\t               [AC_DEFINE([HAVE_VSOCK], [1],\n\t                          [Whether vsock support available])\n\t                AC_MSG_RESULT([yes])],\n\t               [AC_MSG_RESULT([no])])\n\nfi\n\n# These are thngs we can work around\nAC_CHECK_FUNCS([asprintf vasprintf vsnprintf])\nAC_CHECK_DECLS([asprintf, vasprintf], [], [], [[#include <stdio.h>]])\n\nAC_CHECK_LIB(intl, dgettext)\n\n# ------------------------------------------------------------------------------\n# PKCS#11 Directories\n\nAC_ARG_WITH([module-config],\n            [AS_HELP_STRING([--with-module-config], [Module configuration files shipped by packages])],\n            [module_config=$withval],\n            [module_config='${pkgdatadir}/modules'])\n\nAC_ARG_WITH([system-config],\n            [AS_HELP_STRING([--with-system-config], [Change PKCS#11 system config directory])],\n            [system_config_dir=$withval],\n            [system_config_dir=$sysconfdir/pkcs11])\n\nAC_ARG_WITH([user-config],\n            [AS_HELP_STRING([--with-user-config], [Change PKCS#11 user config directory])],\n            [user_config_dir=$withval],\n            [user_config_dir=\"~/.config/pkcs11\"])\n\nAC_ARG_WITH([module-path],\n            [AS_HELP_STRING([--with-module-path], [Load modules with relative path names from here])],\n            [module_path=$withval],\n            [module_path=$libdir/pkcs11])\n\n# We expand these so we have concrete paths\np11_system_config=$system_config_dir\np11_system_config_file=$p11_system_config/pkcs11.conf\np11_system_config_modules=$p11_system_config/modules\np11_package_config_modules=$module_config\np11_user_config=$user_config_dir\np11_user_config_file=\"$p11_user_config/pkcs11.conf\"\np11_user_config_modules=\"$p11_user_config/modules\"\np11_module_path=\"$module_path\"\n\nAC_SUBST(p11_system_config)\nAC_SUBST(p11_system_config_file)\nAC_SUBST(p11_system_config_modules)\nAC_SUBST(p11_package_config_modules)\nAC_SUBST(p11_user_config)\nAC_SUBST(p11_user_config_file)\nAC_SUBST(p11_user_config_modules)\nAC_SUBST(p11_module_path)\n\n# --------------------------------------------------------------------\n# libtasn1 support\n\nAC_ARG_WITH([libtasn1],\n            AS_HELP_STRING([--without-libtasn1],\n                           [Disable dependency on libtasn1])\n)\n\nAS_IF([test \"$with_libtasn1\" != \"no\"], [\n\tPKG_CHECK_MODULES([LIBTASN1], [libtasn1 >= 2.3], [],\n\t\t[AC_MSG_ERROR([libtasn1 not found. Building without it results in significant loss of functionality. To proceed use --without-libtasn1])]\n\t)\n\tAC_SUBST(LIBTASN1_CFLAGS)\n\tAC_SUBST(LIBTASN1_LIBS)\n\twith_libtasn1=\"yes\"\n\tAC_DEFINE_UNQUOTED(WITH_ASN1, 1, [Build with libtasn1 and certificate support])\n])\n\nAM_CONDITIONAL(WITH_ASN1, test \"$with_libtasn1\" = \"yes\")\n\n# --------------------------------------------------------------------\n# libffi\n\nAC_ARG_WITH([libffi],\n            AS_HELP_STRING([--without-libffi],\n                           [Don't use libffi for building closures]))\n\nif test \"$with_libffi\" != \"no\"; then\n\tPKG_CHECK_MODULES(LIBFFI, [libffi >= 3.0.0])\n\tAC_DEFINE_UNQUOTED(WITH_FFI, 1, [Use libffi for building closures])\n\tAC_SUBST(LIBFFI_CFLAGS)\n\tAC_SUBST(LIBFFI_LIBS)\n\n\twith_libffi=\"yes\"\nfi\n\nAM_CONDITIONAL(WITH_FFI, test \"$with_libffi\" = \"yes\")\n\nAC_ARG_WITH([closures],\n\t    [AS_HELP_STRING([--with-closures[=NUM]],\n\t\t            [the number of precompiled closures, used when libffi is unavailable])],\n\t    [closures=$withval],\n\t    [closures=64])\n\nif test \"$closures\" -lt 1; then\n\tAC_MSG_ERROR([at least one closure must be compiled in])\nfi\n\nAC_DEFINE_UNQUOTED(P11_VIRTUAL_MAX_FIXED, [$closures], [the number of closures])\nAC_SUBST(closures)\n\n# --------------------------------------------------------------------\n# Hash implementation\n\nAC_ARG_WITH([hash-impl],\n            AS_HELP_STRING([--with-hash-impl=@<:@freebl/internal@:>@],\n                           [Choose the hash implementation to use])\n)\n\nAS_IF([test \"$with_hash_impl\" = \"\"], [with_hash_impl=internal])\n\nAS_CASE([$with_hash_impl],\n\t[freebl], [\n\t\tAC_CHECK_LIB(freebl3, NSSLOW_Init,\n\t\t\t[\n\t\t\t\tHASH_LIBS=-lfreebl3\n\t\t\t\tAC_DEFINE_UNQUOTED(WITH_FREEBL, 1, [Use freebl for hash implementation])\n\t\t\t],\n\t\t\tAC_MSG_ERROR([could not find the freebl3 library])\n\t\t)\n\t],\n\n\t[internal], [\n\t\tHASH_LIBS=\n\t],\n\n\t[\n\t\tAC_MSG_ERROR([unsupported hash impl: $with_hash_impl])\n\t]\n)\n\nAC_SUBST(HASH_LIBS)\n\n# --------------------------------------------------------------------\n# Trust Module\n\nAC_ARG_ENABLE([trust-module],\n              AS_HELP_STRING([--disable-trust-module],\n                             [Disable building the trust module])\n)\n\nAC_MSG_CHECKING([if trust module is enabled])\nAS_IF([test \"$with_libtasn1\" != \"yes\"], [\n\tAS_IF([test \"$enable_trust_module\" = \"yes\"], [\n\t\tAC_MSG_ERROR([--with-libtasn1 is needed in order to build the trust module])\n\t])\n\tAS_IF([test \"$enable_trust_module\" != \"no\"], [\n\t\tAC_MSG_WARN([--with-libtasn1 is needed in order to build the trust module, disabling])\n\t])\n\tenable_trust_module=\"no\"\n])\n\nAS_IF([test \"$enable_trust_module\" != \"no\"], [enable_trust_module=\"yes\"])\nAM_CONDITIONAL(WITH_TRUST_MODULE, test \"$enable_trust_module\" = \"yes\")\nAC_MSG_RESULT([$enable_trust_module])\n\nAC_ARG_WITH([trust-paths],\n            AS_HELP_STRING([--with-trust-paths=@<:@path@:>@]:\n                           [input paths for trust module])\n)\n\nAC_MSG_CHECKING([for trust module paths])\n\n# This option was disabled, no anchors\nif test \"$with_trust_paths\" = \"no\"; then\n\twith_trust_paths=\"\"\n\tAC_MSG_RESULT([disabled])\n\nelif test \"$enable_trust_module\" != \"yes\"; then\n\tif test \"$with_trust_paths\" != \"\"; then\n\t\tAC_MSG_ERROR([need --enable-trust-module in order to specify trust module paths.])\n\tfi\n\twith_trust_paths=\"\"\n\tAC_MSG_RESULT([disabled])\n\n# Option was not set, try to detect\nelif test \"$with_trust_paths\" = \"\" -o \"$with_trust_paths\" = \"yes\"; then\n\twith_trust_paths=\"\"\n\tfor f in /etc/pki/tls/certs/ca-bundle.crt \\\n\t\t/etc/ssl/certs/ca-certificates.crt \\\n\t\t/etc/ssl/ca-bundle.pem \\\n\t\t/etc/ssl/ca-bundle.crt; do\n\t\tif test -f \"$f\"; then\n\t\t\twith_trust_paths=\"$f\"\n\t\t\tbreak\n\t\tfi\n\tdone\n\n\tif test \"$with_trust_paths\" = \"\"; then\n\t\tAC_MSG_ERROR([could not find. Use --with-trust-paths=/path to set, or --without-trust-paths to disable])\n\tfi\n\n\tAC_MSG_RESULT($with_trust_paths)\n\nelse\n\t# Anchors explicitly set\n\tAC_MSG_RESULT($with_trust_paths)\nfi\n\nAC_DEFINE_UNQUOTED(TRUST_PATHS, [\"$with_trust_paths\"], [The trust module input paths])\nAC_SUBST(with_trust_paths)\n\n# --------------------------------------------------------------------\n# GTK Doc\n\ndnl check for tools\nAC_PATH_PROG([GTKDOC_CHECK],[gtkdoc-check])\nAC_PATH_PROGS([GTKDOC_REBASE],[gtkdoc-rebase],[true])\nAC_PATH_PROG([GTKDOC_MKPDF],[gtkdoc-mkpdf])\nAC_PATH_PROG([GTKDOC_SCAN],[gtkdoc-scan])\nAC_PATH_PROG([XSLTPROC], [xsltproc])\n\ndnl for overriding the documentation installation directory\nAC_ARG_WITH([html-dir],\n\tAS_HELP_STRING([--with-html-dir=PATH], [path to installed docs]),,\n\t               [with_html_dir='${datadir}/gtk-doc/html'])\nHTML_DIR=\"$with_html_dir\"\nAC_SUBST([HTML_DIR])\n\ndnl enable/disable documentation building\nAC_ARG_ENABLE([doc],\n\tAS_HELP_STRING([--enable-doc],\n\t               [build documentation using gtk-doc [[default=no]]]),,\n              [enable_doc=no])\n\nif test x$enable_doc = xyes; then\n\tif test -z \"$GTKDOC_SCAN\"; then\n\t\tAC_MSG_ERROR([gtk-doc not installed and --enable-doc requested])\n\tfi\n\tif test -z \"$XSLTPROC\"; then\n\t\tAC_MSG_ERROR([the xsltproc command was not found and --enable-doc requested])\n\tfi\n\tdoc_status=\"yes (manual, reference)\"\nelse\n\tenable_doc=no\n\tdoc_status=\"no (no manual or reference)\"\nfi\n\nAC_MSG_CHECKING([whether to build documentation])\nAC_MSG_RESULT($enable_doc)\n\ndnl enable/disable output formats\nAC_ARG_ENABLE([doc-html],\n\tAS_HELP_STRING([--enable-doc-html],\n\t               [build documentation in html format [[default=yes]]]),,\n\t          [enable_doc_html=yes])\nAC_ARG_ENABLE([doc-pdf],\n\tAS_HELP_STRING([--enable-doc-pdf],\n\t               [build documentation in pdf format [[default=no]]]),,\n              [enable_doc_pdf=no])\n\nif test -z \"$GTKDOC_MKPDF\"; then\n\tenable_doc_pdf=no\nfi\n\nAM_CONDITIONAL(ENABLE_GTK_DOC, [test x$enable_doc = xyes])\nAM_CONDITIONAL(GTK_DOC_BUILD_HTML, [test x$enable_doc_html = xyes])\nAM_CONDITIONAL(GTK_DOC_BUILD_PDF, [test x$enable_doc_pdf = xyes])\nAM_CONDITIONAL(GTK_DOC_USE_LIBTOOL, [test -n \"$LIBTOOL\"])\nAM_CONDITIONAL(GTK_DOC_USE_REBASE, [test -n \"$GTKDOC_REBASE\"])\n\n# --------------------------------------------------------------------\n# Compilation and linking options\n\nAC_MSG_CHECKING([for debug mode])\nAC_ARG_ENABLE(debug,\n              AC_HELP_STRING([--enable-debug=no/default/yes],\n              [Turn on or off debugging]))\n\nif test \"$enable_debug\" != \"no\"; then\n\tAC_DEFINE_UNQUOTED(WITH_DEBUG, 1, [Print debug output])\n\tAC_DEFINE_UNQUOTED(_DEBUG, 1, [In debug mode])\n\tCFLAGS=\"$CFLAGS -g\"\nfi\n\nif test \"$enable_debug\" = \"yes\"; then\n\tdebug_status=\"yes (-g, -O0, debug output)\"\n\tCFLAGS=\"$CFLAGS -O0\"\nelif test \"$enable_debug\" = \"no\"; then\n\tdebug_status=\"no (no debug output, NDEBUG)\"\n\tAC_DEFINE_UNQUOTED(NDEBUG, 1, [Disable glib assertions])\nelse\n\tdebug_status=\"default (-g, debug output)\"\nfi\n\nAC_MSG_RESULT($debug_status)\n\nAC_MSG_CHECKING(for more warnings)\nif test \"$GCC\" = \"yes\"; then\n\tCFLAGS=\"$CFLAGS \\\n\t\t-Wall -Wstrict-prototypes -Wmissing-declarations \\\n\t\t-Wmissing-prototypes -Wnested-externs -Wpointer-arith \\\n\t\t-Wdeclaration-after-statement -Wformat=2 -Winit-self \\\n\t\t-Waggregate-return -Wno-missing-format-attribute \\\n\t\t-fno-strict-aliasing -fno-common\"\n\n\tfor option in -Wmissing-include-dirs -Wundef; do\n\t\tSAVE_CFLAGS=\"$CFLAGS\"\n\t\tCFLAGS=\"$CFLAGS $option\"\n\t\tAC_MSG_CHECKING([whether gcc understands $option])\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [])],\n\t\t\t\t  [has_option=yes],\n\t\t\t\t  [has_option=no])\n\t\tAC_MSG_RESULT($has_option)\n\t\tif test $has_option = no; then\n\t\t\tCFLAGS=\"$SAVE_CFLAGS\"\n\t\tfi\n\tdone\nelse\n\tAC_MSG_RESULT(no)\nfi\n\nAC_ARG_ENABLE(strict,\n              [AS_HELP_STRING([--enable-strict], [Strict code compilation])]\n             )\n\nAC_MSG_CHECKING([build strict])\n\nif test \"$enable_strict\" = \"yes\"; then\n\tCFLAGS=\"$CFLAGS -Werror\"\n\tAC_DEFINE_UNQUOTED(WITH_STRICT, 1, [More strict checks])\n\tstrict_status=\"yes (-Werror, fatals)\"\nelse\n\tstrict_status=\"no\"\nfi\n\nAC_MSG_RESULT($strict_status)\n\nAC_MSG_CHECKING([whether to build with gcov testing])\nAC_ARG_ENABLE([coverage],\n\t\t[AS_HELP_STRING([--enable-coverage], [Whether to enable coverage testing ])],\n\t\t[],\n\t\t[enable_coverage=no])\n\nAC_MSG_RESULT([$enable_coverage])\n\nif test \"$enable_coverage\" = \"yes\"; then\n\tif test \"$GCC\" != \"yes\"; then\n\t\tAC_MSG_ERROR(Coverage testing requires GCC)\n\tfi\n\n\tAC_PATH_PROG(GCOV, gcov, no)\n\tif test \"$GCOV\" = \"no\" ; then\n\t\tAC_MSG_ERROR(gcov tool is not available)\n\tfi\n\n\tAC_PATH_PROG(LCOV, lcov, no)\n\tif test \"$LCOV\" = \"no\" ; then\n\t\tAC_MSG_ERROR(lcov tool is not installed)\n\tfi\n\n\tAC_PATH_PROG(GENHTML, genhtml, no)\n\tif test \"$GENHTML\" = \"no\" ; then\n\t\tAC_MSG_ERROR(lcov's genhtml tool is not installed)\n\tfi\n\n\tCFLAGS=\"$CFLAGS -O0 -g --coverage\"\n\tLDFLAGS=\"$LDFLAGS --coverage\"\nfi\n\nAM_CONDITIONAL([WITH_COVERAGE], [test \"$enable_coverage\" = \"yes\"])\nAC_SUBST(LCOV)\nAC_SUBST(GCOV)\nAC_SUBST(GENHTML)\n\n# ---------------------------------------------------------------------\n\nP11KIT_LT_RELEASE=$P11KIT_CURRENT:$P11KIT_REVISION:$P11KIT_AGE\nAC_SUBST(P11KIT_LT_RELEASE)\n\necho $PACKAGE_VERSION | tr '.' ' ' | while read major minor unused; do\n\tAC_DEFINE_UNQUOTED(PACKAGE_MAJOR, $major, [Major version of package])\n\tAC_DEFINE_UNQUOTED(PACKAGE_MINOR, $minor, [Minor version of package])\n\tbreak\ndone\n\ncase \"$host\" in\n*-*-darwin*)\n\t# It seems like libtool lies about this see:\n\t# https://bugs.freedesktop.org/show_bug.cgi?id=57714\n\tSHLEXT='.so'\n\t;;\n*)\n\teval SHLEXT=$shrext_cmds\n\t;;\nesac\n\nAC_DEFINE_UNQUOTED(SHLEXT, [\"$SHLEXT\"], [File extension for shared libraries])\nAC_SUBST(SHLEXT)\n\nAC_DEFINE_UNQUOTED(EXEEXT, [\"$EXEEXT\"], [File extension for executables])\n\nprivatedir='${libexecdir}/p11-kit'\nAC_SUBST(privatedir)\n\n# --------------------------------------------------------------------\n# systemd\n\nAC_ARG_WITH([systemd],\n            AS_HELP_STRING([--without-systemd],\n                           [Disable systemd socket activation]))\n\nAS_IF([test \"$with_systemd\" != \"no\"], [\n\tPKG_CHECK_MODULES([LIBSYSTEMD], [libsystemd], [],\n\t\t[with_systemd=no])\n\n\tPKG_CHECK_VAR([systemduserunitdir], [systemd], [systemduserunitdir], [],\n\t\t[with_systemd=no])\n\n\tAS_IF([test \"$with_systemd\" != \"no\"], [\n\t\twith_systemd=yes\n\t\tAC_DEFINE_UNQUOTED(WITH_SYSTEMD, 1, [Build with systemd socket activation])\n\t])\n])\n\nAM_CONDITIONAL(WITH_SYSTEMD, [test \"$with_systemd\" = \"yes\"])\n\n# --------------------------------------------------------------------\n# bash completion\n\nAC_ARG_WITH([bash-completion],\n            AS_HELP_STRING([--without-bash-completion],\n                           [Don't install bash completion files]))\n\nAS_IF([test \"$with_bash_completion\" != \"no\"], [\n\tPKG_CHECK_VAR([bashcompdir], [bash-completion], [completionsdir],\n\t\t[with_bash_completion=yes])\n\tAC_SUBST(bashcompdir)\n])\n\nAM_CONDITIONAL(WITH_BASH_COMPLETION, [test \"$with_bash_completion\" = \"yes\"])\n\n\nAC_CONFIG_FILES([Makefile\n\tdoc/Makefile\n\tdoc/manual/Makefile\n\tpo/Makefile.in\n\tp11-kit/p11-kit-1.pc\n\tp11-kit/pkcs11.conf.example\n\ttrust/trust-extract-compat\n\ttrust/test-init.sh\n])\nAC_OUTPUT\n\n# Format paths arguments which should wrap correctly in the output\nindent='\\n                                     '\ntrust_status=$(echo \"$with_trust_paths\" | sed -e \"s/:/$indent/g\")\n\nAC_MSG_NOTICE([build options:\n\n    Host:                            $host\n    Debug build:                     $debug_status\n    Strict build:                    $strict_status\n    Build documentation:             $doc_status\n    System global config:            $p11_system_config_file\n    System module config directory:  $p11_system_config_modules\n    Package module config directory: $p11_package_config_modules\n    User global config:              $p11_user_config_file\n    User module config directory:    $p11_user_config_modules\n    Load relative module paths from: $p11_module_path\n\n    With libtasn1 dependency:        $with_libtasn1\n    With libffi:                     $with_libffi\n    With hash implementation:        $with_hash_impl\n    With systemd:                    $with_systemd\n\n    Build trust module:              $enable_trust_module\n    Trust module paths:              $trust_status\n\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/meson.build": "project('p11-kit', 'c',\n        version: '0.23.19',\n        meson_version: '>= 0.49')\n\nversion_arr = meson.project_version().split('.')\nmajor_version = version_arr[0].to_int()\nminor_version = version_arr[1].to_int()\nmicro_version = version_arr[2].to_int()\n\ncc = meson.get_compiler('c')\n\ncurrent = 3\nrevision = 0\nage = 3\n\nsoversion = current - age\nlibrary_version = '@0@.@1@.@2@'.format(soversion, age, revision)\n\nconfiginc = include_directories('.')\ncommoninc = include_directories('common')\np11kitinc = include_directories('p11-kit')\ntrustinc = include_directories('trust')\n\nadd_project_arguments(['-D_GNU_SOURCE', '-DP11_KIT_FUTURE_UNSTABLE_API'],\n                      language: 'c')\n\nconf = configuration_data()\n\nconf.set('PACKAGE_MAJOR', major_version)\nconf.set('PACKAGE_MINOR', minor_version)\n\nhost_system = host_machine.system()\nconf.set(host_system == 'windows' ? 'OS_WIN32' : 'OS_UNIX', 1)\n\nif host_system == 'windows'\n  shlext = '.dll'\n  exeext = '.exe'\nelse\n  shlext = '.so'\n  exeext = ''\nendif\n\nconf.set_quoted('SHLEXT', shlext)\nconf.set_quoted('EXEEXT', exeext)\n\nif host_machine.endian() == 'big'\n  conf.set('WORDS_BIGENDIAN', 1)\nendif\n\nif get_option('debug')\n  conf.set('WITH_DEBUG', 1)\n  conf.set('_DEBUG', 1)\nendif\n\nconf.set10('WITH_STRICT', get_option('strict'))\n\nprefix = get_option('prefix')\ndatadir = get_option('datadir')\nbindir = get_option('bindir')\nlibdir = get_option('libdir')\nlibexecdir = get_option('libexecdir')\nsysconfdir = get_option('sysconfdir')\nmandir = get_option('mandir')\npkgdatadir = datadir / meson.project_name()\nprivatedir = libexecdir / meson.project_name()\n\ncommon_c_args = [\n  '-DBINDIR=\"@0@\"'.format(prefix / bindir),\n  '-DPRIVATEDIR=\"@0@\"'.format(prefix / privatedir),\n  '-DSYSCONFDIR=\"@0@\"'.format(prefix / sysconfdir)\n]\n\ntop_source_dir = meson.current_source_dir()\ntop_build_dir = meson.current_build_dir()\n\ntests_c_args = [\n  '-DSRCDIR=\"@0@\"'.format(top_source_dir),\n  '-DBUILDDIR=\"@0@\"'.format(top_build_dir)\n]\n\nconf.set('SIZEOF_UNSIGNED_LONG', cc.sizeof('unsigned long'))\n\nnanosleep_deps = []\ndlopen_deps = []\nsocket_deps = []\nthread_deps = []\n\nif host_system != 'windows'\n  thread_deps += dependency('threads')\n  if not cc.has_function('pthread_create', dependencies: thread_deps)\n    error('could not find pthread_create')\n  endif\n\n  if not cc.has_function('nanosleep')\n    librt = cc.find_library('rt', required: false)\n    if cc.has_function('nanosleep', dependencies: librt)\n      nanosleep_deps += librt\n    else\n      error('could not find nanosleep')\n    endif\n  endif\n\n  if not cc.has_function('dlopen')\n    libdl = cc.find_library('dl', required: false)\n    if cc.has_function('dlopen', dependencies: libdl)\n      dlopen_deps += libdl\n    else\n      error('could not find dlopen')\n    endif\n  endif\n\n  # for Solaris we need -lsocket -lnsl for socket stuff, gethostbyname\n  # is just a dummy to find -lnsl\n  libnsl = cc.find_library('nsl', required: false)\n  if libnsl.found()\n    if cc.has_function('gethostbyname', dependencies: libnsl)\n      socket_deps += libnsl\n    endif\n\n    libsocket = cc.find_library('socket', required: false)\n    if libsocket.found()\n      if cc.has_function('connect', dependencies: [libsocket, libnsl])\n        socket_deps += libsocket\n      else\n        error('could not find socket')\n      endif\n    endif\n  endif\n\n  if cc.has_header('locale.h')\n    conf.set('HAVE_LOCALE_H', 1)\n    if cc.has_type('locale_t', prefix: '#include <locale.h>')\n      conf.set('HAVE_LOCALE_T', 1)\n      if cc.has_function('newlocale', prefix: '#include <locale.h>')\n        conf.set('HAVE_NEWLOCALE', 1)\n      endif\n      if cc.has_function('strerror_l', prefix: '#include <string.h>')\n        conf.set('HAVE_STRERROR_L', 1)\n      endif\n    endif\n  endif\n\n  # These are things we can work around\n  headers = [\n    'sys/resource.h',\n    'ucred.h'\n  ]\n\n  foreach h : headers\n    if cc.has_header(h)\n      conf.set('HAVE_' + h.underscorify().to_upper(), 1)\n    endif\n  endforeach\n\n  functions = [\n    'fdwalk',\n    'getauxval',\n    'getexecname',\n    'getpeereid',\n    'getpeerucred',\n    'getprogname',\n    'getresuid',\n    'issetugid',\n    'mkdtemp',\n    'mkstemp',\n    'secure_getenv',\n    'strndup'\n  ]\n\n  foreach f : functions\n    if cc.has_function(f)\n      conf.set('HAVE_' + f.underscorify().to_upper(), 1)\n    endif\n  endforeach\n\n  if cc.has_member('struct dirent', 'd_type', prefix: '#include <dirent.h>')\n    conf.set('HAVE_STRUCT_DIRENT_D_TYPE', 1)\n  endif\n\n  tls_test_code_template = '''\n#include <stdlib.h>\nint main (void) {\nstatic @0@ foo;\nreturn 0;\n}\n'''\n  foreach keyword : ['_Thread_local', '__thread']\n    if cc.compiles(tls_test_code_template.format(keyword),\n                   name: 'thread-local storage class')\n      conf.set('P11_TLS_KEYWORD', keyword)\n      break\n    endif\n  endforeach\n\n  if cc.has_function('gmtime_r')\n    conf.set('HAVE_GMTIME_R', 1)\n  else\n    error('could not find required gmtime_r() function')\n  endif\n\n  # Check if these are declared and/or available to link against\n  program_invocation_short_name_test_code = '''\n#define _GNU_SOURCE\n#include <errno.h>\nint main (void) { program_invocation_short_name = \"test\"; }\n'''\n  if cc.links(program_invocation_short_name_test_code,\n              name: 'program_invocation_short_name_test_code')\n    conf.set('HAVE_PROGRAM_INVOCATION_SHORT_NAME', 1)\n  else\n    __progname_test_code = '''\nextern char *__progname;\nint main (void) { __progname = (char*)0; return 0; }\n'''\n    if cc.links(__progname_test_code, name: '__progname')\n      conf.set('HAVE___PROGNAME', 1)\n    endif\n  endif\n\n  __libc_enable_secure_test_code = '''\nextern int __libc_enable_secure;\nint main (void) { __libc_enable_secure = 0; return 0; }\n'''\n  if cc.links(__libc_enable_secure_test_code, name: '__libc_enable_secure')\n    conf.set('HAVE___LIBC_ENABLE_SECURE', 1)\n  endif\n\n  vsock_availability_test_code = '''\n#include <sys/socket.h>\n#include <linux/vm_sockets.h>\nstruct sockaddr_vm sa = { .svm_family = AF_VSOCK, .svm_cid = VMADDR_CID_ANY };\n'''\n  if cc.compiles(vsock_availability_test_code, name: 'vsock_test')\n    conf.set('HAVE_VSOCK', 1)\n  endif\n\n  foreach h : ['sys/types.h', 'signal.h']\n    foreach t : ['sighandler_t', 'sig_t', '__sighandler_t']\n      if cc.has_type(t, prefix: '#include <@0@>'.format(h))\n        define = 'HAVE_' + t.underscorify().to_upper()\n        conf.set(define, 1)\n      endif\n    endforeach\n  endforeach\nendif\n\nheaders = [\n  'stdbool.h',\n]\n\nforeach h : headers\n  if cc.has_header(h)\n    conf.set('HAVE_' + h.underscorify().to_upper(), 1)\n  endif\nendforeach\n\nfunctions = [\n  'asprintf',\n  'basename',\n  'memdup',\n  'reallocarray',\n  'secure_getenv',\n  'setenv',\n  'strerror_r',\n  'strnstr',\n  'vasprintf'\n]\n\nforeach f : functions\n  if cc.has_function(f)\n    conf.set('HAVE_' + f.underscorify().to_upper(), 1)\n  endif\nendforeach\n\nconf.set10('HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME',\n           cc.has_header_symbol('errno.h',\n                                'program_invocation_short_name',\n                                prefix: '#define _GNU_SOURCE'))\n\nconf.set10('HAVE_DECL_ASPRINTF',\n           cc.has_header_symbol('stdio.h', 'asprintf',\n                                prefix: '#define _GNU_SOURCE'))\n\nconf.set10('HAVE_DECL_VASPRINTF',\n           cc.has_header_symbol('stdio.h', 'vasprintf',\n                                prefix: '#define _GNU_SOURCE'))\n\nconf.set10('HAVE_DECL_REALLOCARRAY',\n           cc.has_header_symbol('stdlib.h', 'reallocarray'))\n\n# --------------------------------------------------------------------\n# libffi\n\nlibffi_deps = []\nlibffi = dependency('libffi', version: '>= 3.0.0', required: get_option('libffi'))\nif libffi.found()\n  conf.set('WITH_FFI', 1)\n  libffi_deps += libffi\nendif\n\nclosures = get_option('closures')\nif closures < 1\n  error('at least one closure must be compiled in')\nendif\n\nconf.set('P11_VIRTUAL_MAX_FIXED', closures)\n\n# ------------------------------------------------------------------------------\n# PKCS#11 Directories\n\np11_package_config_modules = get_option('module_config')\nif p11_package_config_modules == ''\n  p11_package_config_modules = pkgdatadir / 'modules'\nendif\n\np11_system_config = get_option('system_config')\nif p11_system_config == ''\n  p11_system_config = sysconfdir / 'pkcs11'\nendif\n\np11_user_config = get_option('user_config')\np11_module_path = get_option('module_path')\nif p11_module_path == ''\n  p11_module_path = libdir / 'pkcs11'\nendif\n\np11_system_config_file = p11_system_config / 'pkcs11.conf'\np11_system_config_modules = p11_system_config / 'modules'\np11_user_config_file = p11_user_config / 'pkcs11.conf'\np11_user_config_modules = p11_user_config / 'modules'\n\n# --------------------------------------------------------------------\n# Hash implementation\n\nhash_impl = get_option('hash_impl')\nif hash_impl == 'freebl'\n  libfreebl3 = cc.find_library('freebl3', required: false)\n  if libfreebl3.found() and cc.has_function('NSSLOW_Init',\n                                            dependencies: libfreebl3)\n    conf.set('WITH_FREEBL', 1)\n  else\n    error('could not find the freebl3 library')\n  endif\nendif\n\n# --------------------------------------------------------------------\n# Trust Module\n\nwith_trust_module = false\nlibtasn1_deps = []\nlibtasn1 = dependency('libtasn1', version: '>= 2.3',\n                      required: get_option('trust_module'))\nif libtasn1.found()\n  asn1Parser = find_program('asn1Parser', required: get_option('trust_module'))\n  if asn1Parser.found()\n    conf.set('WITH_ASN1', 1)\n    libtasn1_deps += libtasn1\n    with_trust_module = true\n  endif\nendif\n\ntrust_paths = get_option('trust_paths')\nconf.set_quoted('TRUST_PATHS', trust_paths)\n\n# --------------------------------------------------------------------\n# systemd\n\nwith_systemd = false\nlibsystemd_deps = []\nlibsystemd = dependency('libsystemd', required: get_option('systemd'))\nsystemd = dependency('systemd', required: get_option('systemd'))\nif libsystemd.found() and systemd.found()\n  systemduserunitdir = systemd.get_pkgconfig_variable('systemduserunitdir')\n  conf.set('WITH_SYSTEMD', 1)\n  libsystemd_deps += libsystemd\n  with_systemd = true\nendif\n\nconfigure_file(output: 'config.h', configuration: conf)\n\ngnome = import('gnome')\ni18n = import('i18n')\npkg = import('pkgconfig')\n\nsubdir('common')\nsubdir('p11-kit')\nif with_trust_module\n  subdir('trust')\nendif\nsubdir('doc/manual')\nsubdir('po')\nsubdir('bash-completion')\n",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/common/meson.build": "install_headers('pkcs11.h', 'pkcs11x.h', subdir: 'p11-kit-1/p11-kit')\n\nlibp11_common_sources = [\n  'argv.c',\n  'attrs.c',\n  'array.c',\n  'buffer.c',\n  'compat.c',\n  'constants.c',\n  'debug.c',\n  'dict.c',\n  'hash.c',\n  'lexer.c',\n  'message.c',\n  'path.c',\n  'runtime.c',\n  'url.c',\n  'vsock.c'\n]\n\nlibp11_common = static_library('p11-common', libp11_common_sources,\n                               gnu_symbol_visibility: 'hidden',\n                               include_directories: configinc)\n\nlibp11_common_dep = declare_dependency(include_directories: [configinc,\n                                                             commoninc],\n                                       link_with: libp11_common)\n\nlibp11_library = static_library('p11-library', 'library.c',\n                                gnu_symbol_visibility: 'hidden',\n                                include_directories: configinc)\n\nlibp11_library_dep = declare_dependency(link_with: libp11_library,\n                                        dependencies: [libp11_common_dep] + thread_deps)\n\nlibp11_test_sources = [\n  'mock.c',\n  'test.c'\n]\n\nlibp11_test = static_library('p11-test', libp11_test_sources,\n                             include_directories: configinc)\nlibp11_test_dep = declare_dependency(link_with: libp11_test,\n                                     dependencies: [libp11_common_dep] + thread_deps)\n\nlibp11_tool_sources = [\n  'tool.c'\n]\n\nif host_system != 'windows'\n  libp11_tool_sources += ['unix-peer.c', 'unix-peer.h']\nendif\n\nlibp11_tool = static_library('p11-tool', libp11_tool_sources,\n                             include_directories: configinc)\nlibp11_tool_dep = declare_dependency(link_with: libp11_tool,\n                                     dependencies: [libp11_common_dep])\n\n# Tests ----------------------------------------------------------------\n\ncommon_tests = [\n  'test-tests',\n  'test-compat',\n  'test-hash',\n  'test-dict',\n  'test-array',\n  'test-constants',\n  'test-attrs',\n  'test-buffer',\n  'test-url',\n  'test-path',\n  'test-lexer',\n  'test-message',\n  'test-argv',\n  'test-runtime'\n]\n\nforeach name : common_tests\n  t = executable(name, '@0@.c'.format(name),\n                 c_args: tests_c_args,\n                 include_directories: configinc,\n                 dependencies: dlopen_deps,\n                 link_with: [libp11_test, libp11_common])\n  test(name, t)\nendforeach\n\ncommon_progs = [\n  'frob-getauxval',\n  'frob-getenv'\n]\n\nforeach name : common_progs\n  executable(name, '@0@.c'.format(name),\n             include_directories: configinc,\n             dependencies: dlopen_deps,\n             link_with: [libp11_common])\nendforeach\n",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/common/compat.h": "/*\n * Copyright (c) 2011 Collabora Ltd.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions of source code must retain the above\n *       copyright notice, this list of conditions and the\n *       following disclaimer.\n *     * Redistributions in binary form must reproduce the\n *       above copyright notice, this list of conditions and\n *       the following disclaimer in the documentation and/or\n *       other materials provided with the distribution.\n *     * The names of contributors to this software may not be\n *       used to endorse or promote products derived from this\n *       software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Author: Stef Walter <stefw@collabora.co.uk>\n */\n\n#ifndef __COMPAT_H__\n#define __COMPAT_H__\n\n#include \"config.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if !defined(__cplusplus) && (__GNUC__ > 2)\n#define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))\n#else\n#define GNUC_PRINTF(x, y)\n#endif\n\n#if __GNUC__ >= 4\n#define GNUC_NULL_TERMINATED __attribute__((__sentinel__))\n#else\n#define GNUC_NULL_TERMINATED\n#endif\n\n/* For detecting clang features */\n#ifndef __has_feature\n#define __has_feature(x) 0\n#endif\n\n#ifndef CLANG_ANALYZER_NORETURN\n#if __has_feature(attribute_analyzer_noreturn)\n#define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))\n#else\n#define CLANG_ANALYZER_NORETURN\n#endif\n#endif\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n\n#ifndef HAVE_GETPROGNAME\nconst char * getprogname (void);\n#endif\n\n#ifndef HAVE_MKSTEMP\n\nint          mkstemp     (char *template);\n\n#endif /* HAVE_MKSTEMP */\n\n#ifndef HAVE_MKDTEMP\n\nchar *       mkdtemp     (char *template);\n\n#endif /* HAVE_MKDTEMP */\n\nchar *       strdup_path_mangle (const char *template);\n\nvoid         p11_dl_close       (void * dl);\n\n/* -----------------------------------------------------------------------------\n * WIN32\n */\n\n#ifdef OS_WIN32\n\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x500\n#endif\n\n#ifndef _WIN32_IE\n#define _WIN32_IE 0x500\n#endif\n\n#define WIN32_LEAN_AND_MEAN 1\n#include <windows.h>\n\n#include <io.h>\n\n/* Oh ... my ... god */\n#undef CreateMutex\n\ntypedef CRITICAL_SECTION p11_mutex_t;\n\ntypedef HANDLE p11_thread_t;\n\ntypedef DWORD p11_thread_id_t;\n\n#define P11_RECURSIVE_MUTEX_INIT(m) \\\n\t(InitializeCriticalSection (&m))\n#define p11_mutex_init(m) \\\n\t(InitializeCriticalSection (m))\n#define p11_mutex_lock(m) \\\n\t(EnterCriticalSection (m))\n#define p11_mutex_unlock(m) \\\n\t(LeaveCriticalSection (m))\n#define p11_mutex_uninit(m) \\\n\t(DeleteCriticalSection (m))\n\ntypedef void * (*p11_thread_routine) (void *arg);\n\nint p11_thread_create (p11_thread_t *thread, p11_thread_routine, void *arg);\n\nint p11_thread_join (p11_thread_t thread);\n\n/* Returns a thread_id_t */\n#define p11_thread_id_self() \\\n\t(GetCurrentThreadId ())\n\ntypedef HMODULE dl_module_t;\n\n#define p11_dl_open(f) \\\n\t(LoadLibrary (f))\n#define p11_dl_symbol(d, s) \\\n\t((void *)GetProcAddress ((d), (s)))\n\nchar *    p11_dl_error       (void);\n\n#define p11_sleep_ms(ms) \\\n\t(Sleep (ms))\n\ntypedef struct _p11_mmap p11_mmap;\n\np11_mmap *  p11_mmap_open   (const char *path,\n                             struct stat *sb,\n                             void **data,\n                             size_t *size);\n\nvoid        p11_mmap_close  (p11_mmap *map);\n\n#ifndef HAVE_SETENV\n#define setenv(n, v, z) _putenv_s(n, v)\n#endif /* HAVE_SETENV */\n\n#endif /* OS_WIN32 */\n\n/* ----------------------------------------------------------------------------\n * UNIX\n */\n\n#ifdef OS_UNIX\n\n#include <pthread.h>\n#include <dlfcn.h>\n#include <time.h>\n#include <unistd.h>\n\ntypedef pthread_mutex_t p11_mutex_t;\n\n#ifdef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n\n/* No implementation, because done by static initializer */\n#define P11_RECURSIVE_MUTEX_INIT(mutex)\n\n#else\n\n#define P11_RECURSIVE_MUTEX_INIT(mutex) \\\n\t(p11_recursive_mutex_init (&(mutex)))\n\nvoid        p11_recursive_mutex_init          (p11_mutex_t *mutex);\n\n#endif\n\n#define p11_mutex_init(m) \\\n\t(pthread_mutex_init (m, NULL))\n#define p11_mutex_lock(m) \\\n\t(pthread_mutex_lock (m))\n#define p11_mutex_unlock(m) \\\n\t(pthread_mutex_unlock (m))\n#define p11_mutex_uninit(m) \\\n\t(pthread_mutex_destroy(m))\n\ntypedef pthread_cond_t p11_cond_t;\n\n#define p11_cond_init(c) \\\n\t(pthread_cond_init (c, NULL))\n#define p11_cond_wait(c, m) \\\n        (pthread_cond_wait (c, m))\n#define p11_cond_signal(c) \\\n        (pthread_cond_signal (c))\n#define p11_cond_broadcast(c) \\\n        (pthread_cond_broadcast (c))\n#define p11_cond_uninit(c) \\\n        (pthread_cond_destroy (c))\n\ntypedef pthread_t p11_thread_t;\n\ntypedef pthread_t p11_thread_id_t;\n\ntypedef void * (*p11_thread_routine) (void *arg);\n\n#define p11_thread_create(t, r, a) \\\n\t(pthread_create ((t), NULL, (r), (a)))\n#define p11_thread_join(t) \\\n\t(pthread_join ((t), NULL))\n#define p11_thread_id_self(m) \\\n\t(pthread_self ())\n\ntypedef void * dl_module_t;\n\n#define p11_dl_open(f) \\\n\t(dlopen ((f), RTLD_LOCAL | RTLD_NOW))\n#define p11_dl_symbol(d, s) \\\n\t(dlsym ((d), (s)))\n\nchar * p11_dl_error (void);\n\n#define p11_sleep_ms(ms) \\\n\tdo { int _ms = (ms); \\\n\tstruct timespec _ts = { _ms / 1000, (_ms % 1000) * 1000 * 1000 }; \\\n\tnanosleep (&_ts, NULL); \\\n\t} while(0)\n\ntypedef struct _p11_mmap p11_mmap;\n\np11_mmap *  p11_mmap_open   (const char *path,\n                             struct stat *sb,\n                             void **data,\n                             size_t *size);\n\nvoid        p11_mmap_close  (p11_mmap *map);\n\n#endif /* OS_UNIX */\n\n/* ----------------------------------------------------------------------------\n * MORE COMPAT\n */\n\n#ifdef\tHAVE_ERRNO_H\n#include <errno.h>\n#endif\t/* HAVE_ERRNO_H */\n\n#ifndef HAVE_STRNSTR\n\nchar *     strnstr          (const char *s,\n                             const char *find,\n                             size_t slen);\n\n#endif /* HAVE_STRNSTR */\n\n#ifndef HAVE_MEMDUP\n\nvoid *     memdup           (const void *data,\n                             size_t length);\n\n#endif /* HAVE_MEMDUP */\n\n#ifndef HAVE_STRNDUP\n\nchar *     strndup          (const char *data,\n                             size_t length);\n\n#endif /* HAVE_STRDUP */\n\n#if defined HAVE_DECL_REALLOCARRAY && !HAVE_DECL_REALLOCARRAY\n\nvoid *     reallocarray     (void *ptr,\n                             size_t nmemb,\n                             size_t size);\n\n#endif /* HAVE_REALLOCARRAY */\n\n#ifdef HAVE_STDBOOL_H\n#include <stdbool.h>\n#else\ntypedef enum { false, true } bool;\n#endif\n\n#ifndef HAVE_STRCONCAT\n\nchar *     strconcat        (const char *first,\n                             ...) GNUC_NULL_TERMINATED;\n\n#endif /* HAVE_STRCONCAT */\n\n#if defined HAVE_DECL_ASPRINTF && !HAVE_DECL_ASPRINTF\n\nint        asprintf         (char **strp,\n                             const char *fmt,\n                             ...);\n\n#endif /* HAVE_ASPRINTF */\n\n#if defined HAVE_DECL_VASPRINTF && !HAVE_DECL_VASPRINTF\n#include <stdarg.h>\n\nint        vasprintf        (char **strp,\n                             const char *fmt,\n                             va_list ap);\n\n#endif /* HAVE_DECL_VASPRINTF */\n\n#ifndef HAVE_GMTIME_R\n#include <time.h>\n\nstruct tm * gmtime_r        (const time_t *timep,\n                             struct tm *result);\n\n#endif /* HAVE_GMTIME_R */\n\n#ifndef HAVE_TIMEGM\n#include <time.h>\n\ntime_t      timegm          (struct tm *tm);\n\n#endif /* HAVE_TIMEGM */\n\n#ifdef HAVE_GETAUXVAL\n\n#include <sys/auxv.h>\n\n#else /* !HAVE_GETAUXVAL */\n\nunsigned long     getauxval (unsigned long type);\n\n#define AT_SECURE 23\n\n#endif /* !HAVE_GETAUXVAL */\n\nchar *            secure_getenv (const char *name);\n\n#ifndef HAVE_STRERROR_R\n\nint         strerror_r      (int errnum,\n                             char *buf,\n                             size_t buflen);\n\n#endif /* HAVE_STRERROR_R */\n\n#ifndef HAVE_FDWALK\n\nint        fdwalk           (int (* cb) (void *data, int fd),\n                             void *data);\n\n#endif\n\n/* If either locale_t or newlocale() is not available, strerror_l()\n * cannot be used */\n#if !defined(HAVE_LOCALE_T) || !defined(HAVE_NEWLOCALE)\n#undef HAVE_STRERROR_L\n#endif\n\nint        p11_ascii_tolower (int c);\nint        p11_ascii_toupper (int c);\n\n#endif /* __COMPAT_H__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/p11-kit/modules.c": "/*\n * Copyright (C) 2008 Stefan Walter\n * Copyright (C) 2011 Collabora Ltd.\n * Copyright (C) 2017 Red Hat, Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions of source code must retain the above\n *       copyright notice, this list of conditions and the\n *       following disclaimer.\n *     * Redistributions in binary form must reproduce the\n *       above copyright notice, this list of conditions and\n *       the following disclaimer in the documentation and/or\n *       other materials provided with the distribution.\n *     * The names of contributors to this software may not be\n *       used to endorse or promote products derived from this\n *       software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Author: Stef Walter <stefw@collabora.co.uk>\n */\n\n#include \"config.h\"\n\n/* We use and define deprecated functions here */\n#define P11_KIT_NO_DEPRECATIONS\n#define P11_DEBUG_FLAG P11_DEBUG_LIB\n\n#include \"conf.h\"\n#include \"debug.h\"\n#include \"dict.h\"\n#include \"library.h\"\n#include \"log.h\"\n#include \"message.h\"\n#include \"modules.h\"\n#include \"path.h\"\n#include \"pkcs11.h\"\n#include \"p11-kit.h\"\n#include \"private.h\"\n#include \"proxy.h\"\n#include \"rpc.h\"\n#include \"virtual.h\"\n\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <assert.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n/**\n * SECTION:p11-kit\n * @title: Modules\n * @short_description: Module loading and initializing\n *\n * PKCS\\#11 modules are used by crypto libraries and applications to access\n * crypto objects (like keys and certificates) and to perform crypto operations.\n *\n * In order for applications to behave consistently with regard to the user's\n * installed PKCS\\#11 modules, each module must be configured so that applications\n * or libraries know that they should load it.\n *\n * When multiple consumers of a module (such as libraries or applications) are\n * in the same process, coordination of the initialization and finalization\n * of PKCS\\#11 modules is required. To do this modules are managed by p11-kit.\n * This means that various unsafe methods are coordinated between callers. Unmanaged\n * modules are simply the raw PKCS\\#11 module pointers without p11-kit getting in the\n * way. It is highly recommended that the default managed behavior is used.\n *\n * The functions here provide support for initializing configured modules. The\n * p11_kit_modules_load() function should be used to load and initialize\n * the configured modules. When done, the p11_kit_modules_release() function\n * should be used to release those modules and associated resources.\n *\n * In addition p11_kit_config_option() can be used to access other parts\n * of the module configuration.\n *\n * If a consumer wishes to load an arbitrary PKCS\\#11 module that's not\n * configured use p11_kit_module_load() to do so. And use p11_kit_module_release()\n * to later release it.\n *\n * Modules are represented by a pointer to their <code>CK_FUNCTION_LIST</code>\n * entry points.\n */\n\n/**\n * SECTION:p11-kit-deprecated\n * @title: Deprecated\n * @short_description: Deprecated functions\n *\n * These functions have been deprecated from p11-kit and are not recommended for\n * general usage. In large part they were deprecated because they did not adequately\n * insulate multiple callers of a PKCS\\#11 module from another, and could not\n * support the 'managed' mode needed to do this.\n */\n\n/**\n * P11_KIT_MODULE_UNMANAGED:\n *\n * Module is loaded in non 'managed' mode. This is not recommended,\n * disables many features, and prevents coordination between multiple\n * callers of the same module.\n */\n\n/**\n * P11_KIT_MODULE_CRITICAL:\n *\n * Flag to load a module in 'critical' mode. Failure to load a critical module\n * will prevent all other modules from loading. A failure when loading a\n * non-critical module skips that module.\n */\n\ntypedef struct _Module {\n\t/*\n\t * When using managed modules, this forms the base of the\n\t * virtual stack into which all the other modules call. This is also\n\t * the first field in this structure so we can cast between them.\n\t */\n\tp11_virtual virt;\n\n\t/* The initialize args built from configuration */\n\tCK_C_INITIALIZE_ARGS init_args;\n\tint ref_count;\n\tint init_count;\n\n\t/* Registered modules */\n\tchar *name;\n\tchar *filename;\n\tp11_dict *config;\n\tbool critical;\n\n\t/*\n\t * This is a pointer to the actual dl shared module, or perhaps\n\t * the RPC client context.\n\t */\n\tvoid *loaded_module;\n\tp11_kit_destroyer loaded_destroy;\n\n\t/* Initialization, mutex must be held */\n\tp11_mutex_t initialize_mutex;\n\tunsigned int initialize_called;\n\tp11_thread_id_t initialize_thread;\n} Module;\n\n/*\n * Shared data between threads, protected by the mutex, a structure so\n * we can audit thread safety easier.\n */\nstatic struct _Shared {\n\tp11_dict *modules;\n\tp11_dict *unmanaged_by_funcs;\n\tp11_dict *managed_by_closure;\n\tp11_dict *config;\n} gl = { NULL, NULL };\n\n/* These are global variables to be overridden in tests */\nconst char *p11_config_system_file = P11_SYSTEM_CONFIG_FILE;\nconst char *p11_config_user_file = P11_USER_CONFIG_FILE;\nconst char *p11_config_package_modules = P11_PACKAGE_CONFIG_MODULES;\nconst char *p11_config_system_modules = P11_SYSTEM_CONFIG_MODULES;\nconst char *p11_config_user_modules = P11_USER_CONFIG_MODULES;\n\n/* -----------------------------------------------------------------------------\n * P11-KIT FUNCTIONALITY\n */\n\n/**\n * p11_kit_override_system_files:\n * @system_conf: the system configuration file (default: system_config_dir/pkcs11.conf)\n * @user_conf: the user configuration file (default: ~/.config/pkcs11/pkcs11.conf)\n * @package_modules: location of modules shipped by p11-kit (default: system_config/modules)\n * @system_modules: location of system pkcs11 modules (default: system_config/modules)\n * @user_modules: location of user modules (default: ~/.config/pkcs11/modules)\n *\n * Overrides the default system configuration files. The\n * provided values should be accessible for the lifetime\n * of p11-kit usage.\n *\n * When the value %NULL is provided for any of the locations,\n * it will not be updated.\n *\n * This is function intended to be used in test suites and\n * not production, and as such %P11_KIT_FUTURE_UNSTABLE_API\n * must be defined before including p11-kit.h.\n *\n * Since: 0.23.10\n *\n */\nvoid\np11_kit_override_system_files (const char *system_conf,\n                               const char *user_conf,\n                               const char *package_modules,\n                               const char *system_modules,\n                               const char *user_modules)\n{\n\tif (system_conf)\n\t\tp11_config_system_file = system_conf;\n\n\tif (user_conf)\n\t\tp11_config_user_file = user_conf;\n\n\tif (package_modules)\n\t\tp11_config_package_modules = package_modules;\n\n\tif (system_modules)\n\t\tp11_config_system_modules = system_modules;\n\n\tif (user_modules)\n\t\tp11_config_user_modules = user_modules;\n}\n\nstatic CK_RV\ncreate_mutex (CK_VOID_PTR_PTR mut)\n{\n\tp11_mutex_t *pmutex;\n\n\treturn_val_if_fail (mut != NULL, CKR_ARGUMENTS_BAD);\n\n\tpmutex = malloc (sizeof (p11_mutex_t));\n\treturn_val_if_fail (pmutex != NULL, CKR_HOST_MEMORY);\n\n\tp11_mutex_init (pmutex);\n\t*mut = pmutex;\n\treturn CKR_OK;\n}\n\nstatic CK_RV\ndestroy_mutex (CK_VOID_PTR mut)\n{\n\tp11_mutex_t *pmutex = mut;\n\n\treturn_val_if_fail (mut != NULL, CKR_MUTEX_BAD);\n\n\tp11_mutex_uninit (pmutex);\n\tfree (pmutex);\n\treturn CKR_OK;\n}\n\nstatic CK_RV\nlock_mutex (CK_VOID_PTR mut)\n{\n\tp11_mutex_t *pmutex = mut;\n\n\treturn_val_if_fail (mut != NULL, CKR_MUTEX_BAD);\n\n\tp11_mutex_lock (pmutex);\n\treturn CKR_OK;\n}\n\nstatic CK_RV\nunlock_mutex (CK_VOID_PTR mut)\n{\n\tp11_mutex_t *pmutex = mut;\n\n\treturn_val_if_fail (mut != NULL, CKR_MUTEX_BAD);\n\n\tp11_mutex_unlock (pmutex);\n\treturn CKR_OK;\n}\n\nstatic void\nfree_module_unlocked (void *data)\n{\n\tModule *mod = data;\n\n\tassert (mod != NULL);\n\n\t/* Module must have no outstanding references */\n\tassert (mod->ref_count == 0);\n\n\tif (mod->init_count > 0) {\n\t\tp11_debug_precond (\"module unloaded without C_Finalize having been \"\n\t\t                   \"called for each C_Initialize\");\n\t} else {\n\t\tassert (mod->initialize_thread == 0);\n\t}\n\n\tp11_virtual_uninit (&mod->virt);\n\n\tif (mod->loaded_destroy)\n\t\tmod->loaded_destroy (mod->loaded_module);\n\n\tp11_mutex_uninit (&mod->initialize_mutex);\n\tp11_dict_free (mod->config);\n\tfree (mod->name);\n\tfree (mod->filename);\n\tfree (mod->init_args.pReserved);\n\tfree (mod);\n}\n\nstatic Module *\nalloc_module_unlocked (void)\n{\n\tModule *mod;\n\n\tmod = calloc (1, sizeof (Module));\n\treturn_val_if_fail (mod != NULL, NULL);\n\n\tmod->init_args.CreateMutex = create_mutex;\n\tmod->init_args.DestroyMutex = destroy_mutex;\n\tmod->init_args.LockMutex = lock_mutex;\n\tmod->init_args.UnlockMutex = unlock_mutex;\n\tmod->init_args.flags = CKF_OS_LOCKING_OK;\n\tp11_mutex_init (&mod->initialize_mutex);\n\n\t/*\n\t * The default for configured modules is non-critical, but for\n\t * modules loaded explicitly, and not from config, we treat them\n\t * as critical. So this gets overridden for configured modules\n\t * later when the config is loaded.\n\t */\n\tmod->critical = true;\n\n\treturn mod;\n}\n\n#ifdef __GNUC__\nbool       p11_proxy_module_check                    (CK_FUNCTION_LIST_PTR module) __attribute__((weak));\n\nbool\np11_proxy_module_check (CK_FUNCTION_LIST_PTR module)\n{\n\treturn false;\n}\n#endif\n\nstatic CK_RV\ndlopen_and_get_function_list (Module *mod,\n                              const char *path,\n                              CK_FUNCTION_LIST **funcs)\n{\n\tCK_C_GetFunctionList gfl;\n\tdl_module_t dl;\n\tchar *error;\n\tCK_RV rv;\n\n\tassert (mod != NULL);\n\tassert (path != NULL);\n\tassert (funcs != NULL);\n\n\tdl = p11_dl_open (path);\n\tif (dl == NULL) {\n\t\terror = p11_dl_error ();\n\t\tp11_message (\"couldn't load module: %s: %s\", path, error);\n\t\tfree (error);\n\t\treturn CKR_GENERAL_ERROR;\n\t}\n\n\t/* When the Module goes away, dlclose the loaded module */\n\tmod->loaded_destroy = (p11_kit_destroyer)p11_dl_close;\n\tmod->loaded_module = dl;\n\n\tgfl = p11_dl_symbol (dl, \"C_GetFunctionList\");\n\tif (!gfl) {\n\t\terror = p11_dl_error ();\n\t\tp11_message (\"couldn't find C_GetFunctionList entry point in module: %s: %s\",\n\t\t             path, error);\n\t\tfree (error);\n\t\treturn CKR_GENERAL_ERROR;\n\t}\n\n\trv = gfl (funcs);\n\tif (rv != CKR_OK) {\n\t\tp11_message (\"call to C_GetFunctiontList failed in module: %s: %s\",\n\t\t             path, p11_kit_strerror (rv));\n\t\treturn rv;\n\t}\n\n\tif (p11_proxy_module_check (*funcs)) {\n\t\tp11_message (\"refusing to load the p11-kit-proxy.so module as a registered module\");\n\t\treturn CKR_FUNCTION_FAILED;\n\t}\n\n\tp11_virtual_init (&mod->virt, &p11_virtual_base, *funcs, NULL);\n\tp11_debug (\"opened module: %s\", path);\n\treturn CKR_OK;\n}\n\nstatic CK_RV\nload_module_from_file_inlock (const char *name,\n                              const char *path,\n                              Module **result)\n{\n\tCK_FUNCTION_LIST *funcs;\n\tchar *expand = NULL;\n\tModule *mod;\n\tModule *prev;\n\tCK_RV rv;\n\n\tassert (path != NULL);\n\tassert (result != NULL);\n\n\tmod = alloc_module_unlocked ();\n\treturn_val_if_fail (mod != NULL, CKR_HOST_MEMORY);\n\n\tif (!p11_path_absolute (path)) {\n\t\tp11_debug (\"module path is relative, loading from: %s\", P11_MODULE_PATH);\n\t\tpath = expand = p11_path_build (P11_MODULE_PATH, path, NULL);\n\t\treturn_val_if_fail (path != NULL, CKR_HOST_MEMORY);\n\t}\n\n\tp11_debug (\"loading module %s%sfrom path: %s\",\n\t           name ? name : \"\", name ? \" \" : \"\", path);\n\n\tmod->filename = strdup (path);\n\n\trv = dlopen_and_get_function_list (mod, path, &funcs);\n\tfree (expand);\n\n\tif (rv != CKR_OK) {\n\t\tfree_module_unlocked (mod);\n\t\treturn rv;\n\t}\n\n\t/* Do we have a previous one like this, if so ignore load */\n\tprev = p11_dict_get (gl.unmanaged_by_funcs, funcs);\n\n\t/* If same module was loaded previously, just take over config */\n\tif (prev != NULL) {\n\t\tif (!name || prev->name || prev->config)\n\t\t\tp11_debug (\"duplicate module %s, using previous\", name);\n\t\tfree_module_unlocked (mod);\n\t\tmod = prev;\n\n\t/* This takes ownership of the module */\n\t} else if (!p11_dict_set (gl.modules, mod, mod) ||\n\t\t   !p11_dict_set (gl.unmanaged_by_funcs, funcs, mod)) {\n\t\treturn_val_if_reached (CKR_HOST_MEMORY);\n\t}\n\n\t*result= mod;\n\treturn CKR_OK;\n}\n\nstatic CK_RV\nsetup_module_for_remote_inlock (const char *name,\n                                const char *remote,\n                                Module **result)\n{\n\tp11_rpc_transport *rpc;\n\tModule *mod;\n\n\tp11_debug (\"remoting module %s using: %s\", name, remote);\n\n\tmod = alloc_module_unlocked ();\n\treturn_val_if_fail (mod != NULL, CKR_HOST_MEMORY);\n\n\trpc = p11_rpc_transport_new (&mod->virt, remote, name);\n\tif (rpc == NULL) {\n\t\tfree_module_unlocked (mod);\n\t\treturn CKR_DEVICE_ERROR;\n\t}\n\n\tmod->filename = NULL;\n\tmod->loaded_module = rpc;\n\tmod->loaded_destroy = p11_rpc_transport_free;\n\n\t/* This takes ownership of the module */\n\tif (!p11_dict_set (gl.modules, mod, mod))\n\t\treturn_val_if_reached (CKR_HOST_MEMORY);\n\n\t*result = mod;\n\treturn CKR_OK;\n}\n\nstatic int\nis_list_delimiter (char ch)\n{\n\treturn ch == ',' ||  isspace (ch);\n}\n\nstatic bool\nis_string_in_list (const char *list,\n                   const char *string)\n{\n\tconst char *where;\n\tconst char *start = list;\n\n\twhile (*start != '\\0') {\n\t\twhere = strstr (start, string);\n\t\tif (where == NULL)\n\t\t\treturn false;\n\n\t\t/* Has to be at beginning/end of string, and delimiter before/after */\n\t\tif (where != list && !is_list_delimiter (*(where - 1))) {\n\t\t\tstart += strlen (string);\n\t\t\tcontinue;\n\t\t}\n\n\t\twhere += strlen (string);\n\t\tif (*where == '\\0' || is_list_delimiter (*where)) {\n\t\t\treturn true;\n\t\t}\n\t\tstart = where;\n\t}\n\n\treturn false;\n}\n\nstatic bool\nis_module_enabled_unlocked (const char *name,\n                            p11_dict *config,\n                            int flags)\n{\n\tconst char *progname;\n\tconst char *enable_in;\n\tconst char *disable_in;\n\tbool enable = false;\n\n\tenable_in = p11_dict_get (config, \"enable-in\");\n\tdisable_in = p11_dict_get (config, \"disable-in\");\n\n\t/* Defaults to enabled if neither of these are set */\n\tif (!enable_in && !disable_in)\n\t\treturn true;\n\n\tprogname = _p11_get_progname_unlocked ();\n\tif (enable_in && disable_in)\n\t\tp11_message (\"module '%s' has both enable-in and disable-in options\", name);\n\tif (enable_in) {\n\t\tenable = (progname != NULL &&\n\t\t\t  is_string_in_list (enable_in, progname)) ||\n\t\t\t((flags & P11_KIT_MODULE_LOADED_FROM_PROXY) != 0 &&\n\t\t\t is_string_in_list (enable_in, \"p11-kit-proxy\"));\n\t} else if (disable_in) {\n\t\tenable = (progname == NULL ||\n\t\t\t  !is_string_in_list (disable_in, progname)) &&\n\t\t\t((flags & P11_KIT_MODULE_LOADED_FROM_PROXY) == 0 ||\n\t\t\t !is_string_in_list (disable_in, \"p11-kit-proxy\"));\n\t}\n\n\tp11_debug (\"%s module '%s' running in '%s'\",\n\t            enable ? \"enabled\" : \"disabled\",\n\t            name,\n\t            progname ? progname : \"(null)\");\n\treturn enable;\n}\n\nstatic CK_RV\ntake_config_and_load_module_inlock (char **name,\n                                    p11_dict **config,\n                                    bool critical,\n                                    bool verbose)\n{\n\tconst char *filename = NULL;\n\tconst char *remote = NULL;\n\tchar *init_reserved = NULL;\n\tCK_RV rv = CKR_OK;\n\tModule *mod;\n\n\tassert (name);\n\tassert (*name);\n\tassert (config);\n\tassert (*config);\n\n\tif (!is_module_enabled_unlocked (*name, *config, 0))\n\t\tgoto out;\n\n\tremote = p11_dict_get (*config, \"remote\");\n\tif (remote == NULL) {\n\t\tfilename = p11_dict_get (*config, \"module\");\n\t\tif (filename == NULL) {\n\t\t\tp11_debug (\"no module path for module, skipping: %s\", *name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (remote != NULL) {\n\t\trv = setup_module_for_remote_inlock (*name, remote, &mod);\n\t\tif (rv != CKR_OK)\n\t\t\tgoto out;\n\n\t} else {\n\n\t\trv = load_module_from_file_inlock (*name, filename, &mod);\n\t\tif (rv != CKR_OK)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We support setting of CK_C_INITIALIZE_ARGS.pReserved from\n\t * 'x-init-reserved' setting in the config. This only works with specific\n\t * PKCS#11 modules, and is non-standard use of that field.\n\t */\n\tinit_reserved = p11_dict_get (*config, \"x-init-reserved\");\n\tif (init_reserved) {\n\t\tif (verbose) {\n\t\t\tinit_reserved = strconcat (init_reserved, \" verbose=yes\", NULL);\n\t\t} else {\n\t\t\tinit_reserved = strdup (init_reserved);\n\t\t}\n\t\tif (init_reserved == NULL) {\n\t\t\trv = CKR_HOST_MEMORY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmod->init_args.pReserved = init_reserved;\n\n\t/* Take ownership of these variables */\n\tp11_dict_free (mod->config);\n\tmod->config = *config;\n\t*config = NULL;\n\tfree (mod->name);\n\tmod->name = *name;\n\t*name = NULL;\n\tmod->critical = critical;\n\nout:\n\treturn rv;\n}\n\nstatic CK_RV\nload_registered_modules_unlocked (int flags)\n{\n\tp11_dictiter iter;\n\tp11_dict *configs;\n\tvoid *key;\n\tchar *name;\n\tp11_dict *config;\n\tint mode;\n\tCK_RV rv;\n\tbool critical;\n\tbool verbose;\n\n\tif (gl.config)\n\t\treturn CKR_OK;\n\n\t/* Load the global configuration files */\n\tconfig = _p11_conf_load_globals (p11_config_system_file, p11_config_user_file, &mode);\n\tif (config == NULL)\n\t\treturn CKR_GENERAL_ERROR;\n\n\tassert (mode != CONF_USER_INVALID);\n\n\tconfigs = _p11_conf_load_modules (mode,\n\t                                  p11_config_package_modules,\n\t                                  p11_config_system_modules,\n\t                                  p11_config_user_modules);\n\tif (configs == NULL) {\n\t\trv = CKR_GENERAL_ERROR;\n\t\tp11_dict_free (config);\n\t\treturn rv;\n\t}\n\n\tassert (gl.config == NULL);\n\tgl.config = config;\n\n\t/*\n\t * Now go through each config and turn it into a module. As we iterate\n\t * we steal the values of the config.\n\t */\n\tp11_dict_iterate (configs, &iter);\n\twhile (p11_dict_next (&iter, &key, NULL)) {\n\t\tif (!p11_dict_steal (configs, key, (void**)&name, (void**)&config))\n\t\t\tassert_not_reached ();\n\n\t\t/* Is this a critical module, should abort loading of others? */\n\t\tcritical = _p11_conf_parse_boolean (p11_dict_get (config, \"critical\"), false);\n\t\tverbose = (flags & P11_KIT_MODULE_VERBOSE) != 0;\n\t\trv = take_config_and_load_module_inlock (&name, &config, critical, verbose);\n\n\t\t/*\n\t\t * These variables will be cleared if ownership is transeferred\n\t\t * by the above function call.\n\t\t */\n\t\tp11_dict_free (config);\n\n\t\tif (critical && rv != CKR_OK) {\n\t\t\tp11_message (\"aborting initialization because module '%s' was marked as critical\",\n\t\t\t             name);\n\t\t\tp11_dict_free (configs);\n\t\t\tfree (name);\n\t\t\treturn rv;\n\t\t}\n\n\t\tfree (name);\n\t}\n\n\tp11_dict_free (configs);\n\treturn CKR_OK;\n}\n\nstatic CK_RV\ninitialize_module_inlock_reentrant (Module *mod, CK_C_INITIALIZE_ARGS *init_args)\n{\n\tCK_RV rv = CKR_OK;\n\tp11_thread_id_t self;\n\n\tassert (mod);\n\n\tself = p11_thread_id_self ();\n\n\tif (mod->initialize_thread == self) {\n\t\tp11_message (\"p11-kit initialization called recursively\");\n\t\treturn CKR_FUNCTION_FAILED;\n\t}\n\n\t/*\n\t * Increase ref first, so module doesn't get freed out from\n\t * underneath us when the mutex is unlocked below.\n\t */\n\t++mod->ref_count;\n\tmod->initialize_thread = self;\n\n\t/* Change over to the module specific mutex */\n\tp11_unlock ();\n\tp11_mutex_lock (&mod->initialize_mutex);\n\n\tif (mod->initialize_called != p11_forkid) {\n\t\tp11_debug (\"C_Initialize: calling\");\n\n\t\t/* The init_args argument takes precedence over mod->init_args */\n\t\tif (init_args == NULL)\n\t\t\tinit_args = &mod->init_args;\n\n\t\trv = mod->virt.funcs.C_Initialize (&mod->virt.funcs,\n\t\t\t\t\t\t   init_args);\n\n\t\tp11_debug (\"C_Initialize: result: %lu\", rv);\n\n\t\t/* Module was initialized and C_Finalize should be called */\n\t\tif (rv == CKR_OK)\n\t\t\tmod->initialize_called = p11_forkid;\n\t\telse\n\t\t\tmod->initialize_called = 0;\n\n\t\t/* Module was already initialized, we don't call C_Finalize */\n\t\tif (rv == CKR_CRYPTOKI_ALREADY_INITIALIZED)\n\t\t\trv = CKR_OK;\n\n\t\t/* Matches the init count in finalize_module_inlock_reentrant() */\n\t\tif (rv == CKR_OK)\n\t\t\tmod->init_count = 0;\n\t}\n\n\tp11_mutex_unlock (&mod->initialize_mutex);\n\tp11_lock ();\n\n\tif (rv == CKR_OK) {\n\t\t/* Matches the ref count in finalize_module_inlock_reentrant() */\n\t\tif (mod->init_count == 0)\n\t\t\tmod->ref_count++;\n\t\tmod->init_count++;\n\t}\n\n\tmod->ref_count--;\n\tmod->initialize_thread = 0;\n\treturn rv;\n}\n\nstatic CK_RV\ninit_globals_unlocked (void)\n{\n\tstatic bool once = false;\n\n\tif (!gl.modules) {\n\t\tgl.modules = p11_dict_new (p11_dict_direct_hash,\n\t\t                           p11_dict_direct_equal,\n\t\t                           free_module_unlocked, NULL);\n\t\treturn_val_if_fail (gl.modules != NULL, CKR_HOST_MEMORY);\n\t}\n\n\tif (!gl.unmanaged_by_funcs) {\n\t\tgl.unmanaged_by_funcs = p11_dict_new (p11_dict_direct_hash,\n\t\t                                      p11_dict_direct_equal,\n\t\t                                      NULL, NULL);\n\t\treturn_val_if_fail (gl.unmanaged_by_funcs != NULL, CKR_HOST_MEMORY);\n\t}\n\n\tif (!gl.managed_by_closure) {\n\t\tgl.managed_by_closure = p11_dict_new (p11_dict_direct_hash,\n\t\t                                      p11_dict_direct_equal,\n\t\t                                      NULL, NULL);\n\t\treturn_val_if_fail (gl.managed_by_closure != NULL, CKR_HOST_MEMORY);\n\t}\n\n\tif (once)\n\t\treturn CKR_OK;\n\n\tonce = true;\n\n\treturn CKR_OK;\n}\n\nstatic void\nfree_modules_when_no_refs_unlocked (void)\n{\n\tif (gl.modules) {\n\t\tModule *mod;\n\t\tp11_dictiter iter;\n\n\t\t/* Check if any modules have a ref count */\n\t\tp11_dict_iterate (gl.modules, &iter);\n\t\twhile (p11_dict_next (&iter, (void **)&mod, NULL)) {\n\t\t\tif (mod->ref_count)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tp11_dict_free (gl.unmanaged_by_funcs);\n\tgl.unmanaged_by_funcs = NULL;\n\n\tp11_dict_free (gl.managed_by_closure);\n\tgl.managed_by_closure = NULL;\n\n\tp11_dict_free (gl.modules);\n\tgl.modules = NULL;\n\n\tp11_dict_free (gl.config);\n\tgl.config = NULL;\n}\n\nstatic CK_RV\nfinalize_module_inlock_reentrant (Module *mod)\n{\n\tassert (mod);\n\n\t/*\n\t * We leave module info around until all are finalized\n\t * so we can encounter these zombie Module structures.\n\t */\n\tif (mod->ref_count == 0)\n\t\treturn CKR_ARGUMENTS_BAD;\n\n\tif (--mod->init_count > 0)\n\t\treturn CKR_OK;\n\n\t/*\n\t * Because of the mutex unlock below, we temporarily increase\n\t * the ref count. This prevents module from being freed out\n\t * from ounder us.\n\t */\n\n\tp11_unlock ();\n\tp11_mutex_lock (&mod->initialize_mutex);\n\n\tif (mod->initialize_called == p11_forkid) {\n\t\tmod->virt.funcs.C_Finalize (&mod->virt.funcs, NULL);\n\t\tmod->initialize_called = 0;\n\t}\n\n\tp11_mutex_unlock (&mod->initialize_mutex);\n\tp11_lock ();\n\n\t/* Match the ref increment in initialize_module_inlock_reentrant() */\n\tmod->ref_count--;\n\n\tfree_modules_when_no_refs_unlocked ();\n\treturn CKR_OK;\n}\n\nstatic CK_RV\ninitialize_registered_inlock_reentrant (void)\n{\n\tp11_dictiter iter;\n\tModule *mod;\n\tCK_RV rv;\n\n\t/*\n\t * This is only called by deprecated code. The caller expects all\n\t * configured and enabled modules to be initialized.\n\t */\n\n\trv = init_globals_unlocked ();\n\tif (rv != CKR_OK)\n\t\treturn rv;\n\n\trv = load_registered_modules_unlocked (0);\n\tif (rv == CKR_OK) {\n\t\tp11_dict_iterate (gl.unmanaged_by_funcs, &iter);\n\t\twhile (rv == CKR_OK && p11_dict_next (&iter, NULL, (void **)&mod)) {\n\n\t\t\t/* Skip all modules that aren't registered or enabled */\n\t\t\tif (mod->name == NULL || !is_module_enabled_unlocked (mod->name, mod->config, 0))\n\t\t\t\tcontinue;\n\n\t\t\trv = initialize_module_inlock_reentrant (mod, NULL);\n\t\t\tif (rv != CKR_OK) {\n\t\t\t\tif (mod->critical) {\n\t\t\t\t\tp11_message (\"initialization of critical module '%s' failed: %s\",\n\t\t\t\t\t             mod->name, p11_kit_strerror (rv));\n\t\t\t\t} else {\n\t\t\t\t\tp11_message (\"skipping module '%s' whose initialization failed: %s\",\n\t\t\t\t\t             mod->name, p11_kit_strerror (rv));\n\t\t\t\t\trv = CKR_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rv;\n}\n\nstatic Module *\nmodule_for_functions_inlock (CK_FUNCTION_LIST *funcs)\n{\n\tif (p11_virtual_is_wrapper (funcs))\n\t\treturn p11_dict_get (gl.managed_by_closure, funcs);\n\telse\n\t\treturn p11_dict_get (gl.unmanaged_by_funcs, funcs);\n}\n\nstatic CK_FUNCTION_LIST *\nunmanaged_for_module_inlock (Module *mod)\n{\n\tCK_FUNCTION_LIST *funcs;\n\n\tfuncs = mod->virt.lower_module;\n\tif (p11_dict_get (gl.unmanaged_by_funcs, funcs) == mod)\n\t\treturn funcs;\n\n\treturn NULL;\n}\n\n/**\n * p11_kit_initialize_registered:\n *\n * Initialize all the registered PKCS\\#11 modules.\n *\n * If this is the first time this function is called multiple times\n * consecutively within a single process, then it merely increments an\n * initialization reference count for each of these modules.\n *\n * Use p11_kit_finalize_registered() to finalize these registered modules once\n * the caller is done with them.\n *\n * If this function fails, then an error message will be available via the\n * p11_kit_message() function.\n *\n * Deprecated: Since: 0.19.0: Use p11_kit_modules_load() instead.\n *\n * Returns: CKR_OK if the initialization succeeded, or an error code.\n */\nCK_RV\np11_kit_initialize_registered (void)\n{\n\tCK_RV rv;\n\n\tp11_library_init_once ();\n\n\t/* WARNING: This function must be reentrant */\n\tp11_debug (\"in\");\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\t/* WARNING: Reentrancy can occur here */\n\t\trv = initialize_registered_inlock_reentrant ();\n\n\t\t_p11_kit_default_message (rv);\n\n\tp11_unlock ();\n\n\t/* Cleanup any partial initialization */\n\tif (rv != CKR_OK)\n\t\tp11_kit_finalize_registered ();\n\n\tp11_debug (\"out: %lu\", rv);\n\treturn rv;\n}\n\nstatic CK_RV\nfinalize_registered_inlock_reentrant (void)\n{\n\tModule *mod;\n\tp11_dictiter iter;\n\tModule **to_finalize;\n\tint i, count;\n\n\t/*\n\t * This is only called from deprecated code. The caller expects all\n\t * modules initialized earlier to be finalized (once). If non-critical\n\t * modules failed to initialize, then it is not possible to completely\n\t * guarantee the internal state.\n\t */\n\n\tif (!gl.modules)\n\t\treturn CKR_CRYPTOKI_NOT_INITIALIZED;\n\n\t/* WARNING: This function must be reentrant */\n\n\tto_finalize = calloc (p11_dict_size (gl.unmanaged_by_funcs), sizeof (Module *));\n\tif (!to_finalize)\n\t\treturn CKR_HOST_MEMORY;\n\n\tcount = 0;\n\tp11_dict_iterate (gl.unmanaged_by_funcs, &iter);\n\twhile (p11_dict_next (&iter, NULL, (void **)&mod)) {\n\n\t\t/* Skip all modules that aren't registered */\n\t\tif (mod->name && mod->init_count)\n\t\t\tto_finalize[count++] = mod;\n\t}\n\n\tp11_debug (\"finalizing %d modules\", count);\n\n\tfor (i = 0; i < count; ++i) {\n\t\t/* WARNING: Reentrant calls can occur here */\n\t\tfinalize_module_inlock_reentrant (to_finalize[i]);\n\t}\n\n\tfree (to_finalize);\n\n\t/* In case nothing loaded, free up internal memory */\n\tif (count == 0)\n\t\tfree_modules_when_no_refs_unlocked ();\n\n\treturn CKR_OK;\n}\n\n/**\n * p11_kit_finalize_registered:\n *\n * Finalize all the registered PKCS\\#11 modules. These should have been\n * initialized with p11_kit_initialize_registered().\n *\n * If p11_kit_initialize_registered() has been called more than once in this\n * process, then this function must be called the same number of times before\n * actual finalization will occur.\n *\n * If this function fails, then an error message will be available via the\n * p11_kit_message() function.\n *\n * Deprecated: Since 0.19.0: Use p11_kit_modules_release() instead.\n *\n * Returns: CKR_OK if the finalization succeeded, or an error code.\n */\n\nCK_RV\np11_kit_finalize_registered (void)\n{\n\tCK_RV rv;\n\n\tp11_library_init_once ();\n\n\t/* WARNING: This function must be reentrant */\n\tp11_debug (\"in\");\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\t/* WARNING: Reentrant calls can occur here */\n\t\trv = finalize_registered_inlock_reentrant ();\n\n\t\t_p11_kit_default_message (rv);\n\n\tp11_unlock ();\n\n\tp11_debug (\"out: %lu\", rv);\n\treturn rv;\n}\n\nstatic int\ncompar_priority (const void *one,\n                 const void *two)\n{\n\tCK_FUNCTION_LIST_PTR f1 = *((CK_FUNCTION_LIST_PTR *)one);\n\tCK_FUNCTION_LIST_PTR f2 = *((CK_FUNCTION_LIST_PTR *)two);\n\tModule *m1, *m2;\n\tconst char *v1, *v2;\n\tint o1, o2;\n\n\tm1 = module_for_functions_inlock (f1);\n\tm2 = module_for_functions_inlock (f2);\n\tassert (m1 != NULL && m2 != NULL);\n\n\tv1 = p11_dict_get (m1->config, \"priority\");\n\tv2 = p11_dict_get (m2->config, \"priority\");\n\n\to1 = atoi (v1 ? v1 : \"0\");\n\to2 = atoi (v2 ? v2 : \"0\");\n\n\t/* Priority is in descending order, highest first */\n\tif (o1 != o2)\n\t\treturn o1 > o2 ? -1 : 1;\n\n\t/*\n\t * Otherwise use the names alphabetically in ascending order. This\n\t * is really just to provide consistency between various loads of\n\t * the configuration.\n\t */\n\tif (m1->name == m2->name)\n\t\treturn 0;\n\tif (!m1->name)\n\t\treturn -1;\n\tif (!m2->name)\n\t\treturn 1;\n\treturn strcmp (m1->name, m2->name);\n}\n\nstatic void\nsort_modules_by_priority (CK_FUNCTION_LIST_PTR *modules,\n                          int count)\n{\n\tqsort (modules, count, sizeof (CK_FUNCTION_LIST_PTR), compar_priority);\n}\n\nstatic CK_FUNCTION_LIST **\nlist_registered_modules_inlock (void)\n{\n\tCK_FUNCTION_LIST **result = NULL;\n\tCK_FUNCTION_LIST *funcs;\n\tModule *mod;\n\tp11_dictiter iter;\n\tint i = 0;\n\n\t/*\n\t * This is only called by deprecated code. The caller expects to get\n\t * a list of all registered enabled modules that have been initialized.\n\t */\n\n\tif (gl.unmanaged_by_funcs) {\n\t\tresult = calloc (p11_dict_size (gl.unmanaged_by_funcs) + 1,\n\t\t                 sizeof (CK_FUNCTION_LIST *));\n\t\treturn_val_if_fail (result != NULL, NULL);\n\n\t\tp11_dict_iterate (gl.unmanaged_by_funcs, &iter);\n\t\twhile (p11_dict_next (&iter, (void **)&funcs, (void **)&mod)) {\n\n\t\t\t/*\n\t\t\t * We don't include unreferenced modules. We don't include\n\t\t\t * modules that have been initialized but aren't in the\n\t\t\t * registry. These have a NULL name.\n\t\t\t *\n\t\t\t * In addition we check again that the module isn't disabled\n\t\t\t * using enable-in or disable-in. This is because a caller\n\t\t\t * can change the progname we recognize the process as after\n\t\t\t * having initialized. This is a corner case, but want to make\n\t\t\t * sure to cover it.\n\t\t\t */\n\t\t\tif (mod->ref_count && mod->name && mod->init_count &&\n\t\t\t    is_module_enabled_unlocked (mod->name, mod->config, 0)) {\n\t\t\t\tresult[i++] = funcs;\n\t\t\t}\n\t\t}\n\n\t\tsort_modules_by_priority (result, i);\n\t}\n\n\treturn result;\n}\n\n/**\n * p11_kit_registered_modules:\n *\n * Get a list of all the registered PKCS\\#11 modules. This list will be valid\n * once the p11_kit_initialize_registered() function has been called.\n *\n * The returned value is a <code>NULL</code> terminated array of\n * <code>CK_FUNCTION_LIST_PTR</code> pointers.\n *\n * The returned modules are unmanaged.\n *\n * Deprecated: Since 0.19.0: Use p11_kit_modules_load() instead.\n *\n * Returns: A list of all the registered modules. Use the free() function to\n * free the list.\n */\nCK_FUNCTION_LIST_PTR_PTR\np11_kit_registered_modules (void)\n{\n\tCK_FUNCTION_LIST_PTR_PTR result;\n\n\tp11_library_init_once ();\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\tresult = list_registered_modules_inlock ();\n\n\tp11_unlock ();\n\n\treturn result;\n}\n\n/**\n * p11_kit_registered_module_to_name:\n * @module: pointer to a registered module\n *\n * Get the name of a registered PKCS\\#11 module.\n *\n * You can use p11_kit_registered_modules() to get a list of all the registered\n * modules. This name is specified by the registered module configuration.\n *\n * Deprecated: Since 0.19.0: Use p11_kit_module_get_name() instead.\n *\n * Returns: A newly allocated string containing the module name, or\n *     <code>NULL</code> if no such registered module exists. Use free() to\n *     free this string.\n */\nchar*\np11_kit_registered_module_to_name (CK_FUNCTION_LIST_PTR module)\n{\n\treturn_val_if_fail (module != NULL, NULL);\n\treturn p11_kit_module_get_name (module);\n}\n\n/**\n * p11_kit_module_get_name:\n * @module: pointer to a loaded module\n *\n * Get the configured name of the PKCS\\#11 module.\n *\n * Configured modules are loaded by p11_kit_modules_load(). The module\n * passed to this function can be either managed or unmanaged. Non\n * configured modules will return %NULL.\n *\n * Use free() to release the return value when you're done with it.\n *\n * Returns: a newly allocated string containing the module name, or\n *     <code>NULL</code> if the module is not a configured module\n */\nchar *\np11_kit_module_get_name (CK_FUNCTION_LIST *module)\n{\n\tModule *mod;\n\tchar *name = NULL;\n\n\treturn_val_if_fail (module != NULL, NULL);\n\n\tp11_library_init_once ();\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\tif (gl.modules) {\n\t\t\tmod = module_for_functions_inlock (module);\n\t\t\tif (mod && mod->name)\n\t\t\t\tname = strdup (mod->name);\n\t\t}\n\n\tp11_unlock ();\n\n\treturn name;\n}\n\n/**\n * p11_kit_module_get_filename:\n * @module: pointer to a loaded module\n *\n * Get the configured name of the PKCS\\#11 module.\n *\n * Configured modules are loaded by p11_kit_modules_load(). The module\n * passed to this function can be either managed or unmanaged. Non\n * configured modules will return %NULL.\n *\n * Use free() to release the return value when you're done with it.\n *\n * Returns: a newly allocated string containing the module name, or\n *     <code>NULL</code> if the module is not a configured module\n */\nchar *\np11_kit_module_get_filename (CK_FUNCTION_LIST *module)\n{\n\tModule *mod;\n\tchar *name = NULL;\n\n\treturn_val_if_fail (module != NULL, NULL);\n\n\tp11_library_init_once ();\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\tif (gl.modules) {\n\t\t\tmod = module_for_functions_inlock (module);\n\t\t\tif (mod && mod->filename)\n\t\t\t\tname = strdup (mod->filename);\n\t\t}\n\n\tp11_unlock ();\n\n\treturn name;\n}\n\nstatic const char *\nmodule_get_option_inlock (Module *mod,\n                          const char *option)\n{\n\tp11_dict *config;\n\n\tif (mod == NULL)\n\t\tconfig = gl.config;\n\telse\n\t\tconfig = mod->config;\n\tif (config == NULL)\n\t\treturn NULL;\n\treturn p11_dict_get (config, option);\n}\n\n/**\n * p11_kit_module_get_flags:\n * @module: the module\n *\n * Get the flags for this module.\n *\n * The %P11_KIT_MODULE_UNMANAGED flag will be set if the module is not\n * managed by p11-kit. It is a raw PKCS\\#11 module function list.\n *\n * The %P11_KIT_MODULE_CRITICAL flag will be set if the module is configured\n * to be critical, and not be skipped over if it fails to initialize or\n * load. This flag is also set for modules that are not configured, but have\n * been loaded in another fashion.\n *\n * Returns: the flags for the module\n */\nint\np11_kit_module_get_flags (CK_FUNCTION_LIST *module)\n{\n\tconst char *trusted;\n\tModule *mod;\n\tint flags = 0;\n\n\treturn_val_if_fail (module != NULL, 0);\n\n\tp11_library_init_once ();\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\tif (gl.modules) {\n\t\t\tif (p11_virtual_is_wrapper (module)) {\n\t\t\t\tmod = p11_dict_get (gl.managed_by_closure, module);\n\t\t\t} else {\n\t\t\t\tflags |= P11_KIT_MODULE_UNMANAGED;\n\t\t\t\tmod = p11_dict_get (gl.unmanaged_by_funcs, module);\n\t\t\t}\n\t\t\tif (!mod || mod->critical)\n\t\t\t\tflags |= P11_KIT_MODULE_CRITICAL;\n\t\t\tif (mod) {\n\t\t\t\ttrusted = module_get_option_inlock (mod, \"trust-policy\");\n\t\t\t\tif (_p11_conf_parse_boolean (trusted, false))\n\t\t\t\t\tflags |= P11_KIT_MODULE_TRUSTED;\n\t\t\t}\n\t\t}\n\n\tp11_unlock ();\n\n\treturn flags;\n}\n\n/**\n * p11_kit_registered_name_to_module:\n * @name: name of a registered module\n *\n * Lookup a registered PKCS\\#11 module by its name. This name is specified by\n * the registered module configuration.\n *\n * Deprecated: Since 0.19.0: Use p11_kit_module_for_name() instead.\n *\n * Returns: a pointer to a PKCS\\#11 module, or <code>NULL</code> if this name was\n *     not found.\n */\nCK_FUNCTION_LIST_PTR\np11_kit_registered_name_to_module (const char *name)\n{\n\tCK_FUNCTION_LIST_PTR module = NULL;\n\tCK_FUNCTION_LIST_PTR funcs;\n\tp11_dictiter iter;\n\tModule *mod;\n\n\treturn_val_if_fail (name != NULL, NULL);\n\n\tp11_lock ();\n\n\tp11_message_clear ();\n\n\tif (gl.modules) {\n\n\t\tassert (name);\n\n\t\tp11_dict_iterate (gl.unmanaged_by_funcs, &iter);\n\t\twhile (p11_dict_next (&iter, (void **)&funcs, (void **)&mod)) {\n\t\t\tif (mod->ref_count && mod->name && strcmp (name, mod->name) == 0) {\n\t\t\t\tmodule = funcs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tp11_unlock ();\n\n\treturn module;\n}\n\n/**\n * p11_kit_module_for_name:\n * @modules: a list of modules to look through\n * @name: the name of the module to find\n *\n * Look through the list of @modules and return the module whose @name\n * matches.\n *\n * Only configured modules have names. Configured modules are loaded by\n * p11_kit_modules_load(). The module passed to this function can be either\n * managed or unmanaged.\n *\n * The return value is not copied or duplicated in anyway. It is still\n * 'owned' by the @modules list.\n *\n * Returns: the module which matches the name, or %NULL if no match.\n */\nCK_FUNCTION_LIST *\np11_kit_module_for_name (CK_FUNCTION_LIST **modules,\n                         const char *name)\n{\n\tCK_FUNCTION_LIST *ret = NULL;\n\tModule *mod;\n\tint i;\n\n\treturn_val_if_fail (name != NULL, NULL);\n\n\tif (!modules)\n\t\treturn NULL;\n\n\tp11_library_init_once ();\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\tfor (i = 0; gl.modules && modules[i] != NULL; i++) {\n\t\t\tmod = module_for_functions_inlock (modules[i]);\n\t\t\tif (mod && mod->name && strcmp (mod->name, name) == 0) {\n\t\t\t\tret = modules[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tp11_unlock ();\n\n\treturn ret;\n}\n\n/**\n * p11_kit_registered_option:\n * @module: a pointer to a registered module\n * @field: the name of the option to lookup.\n *\n * Lookup a configured option for a registered PKCS\\#11 module. If a\n * <code>NULL</code> module argument is specified, then this will lookup\n * the configuration option in the global config file.\n *\n * Deprecated: Since 0.19.0: Use p11_kit_config_option() instead.\n *\n * Returns: A newly allocated string containing the option value, or\n *     <code>NULL</code> if the registered module or the option were not found.\n *     Use free() to free the returned string.\n */\nchar*\np11_kit_registered_option (CK_FUNCTION_LIST_PTR module, const char *field)\n{\n\tModule *mod = NULL;\n\tchar *option = NULL;\n\tconst char *value;\n\n\treturn_val_if_fail (field != NULL, NULL);\n\n\tp11_library_init_once ();\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\tif (module == NULL)\n\t\t\tmod = NULL;\n\t\telse\n\t\t\tmod = gl.unmanaged_by_funcs ? p11_dict_get (gl.unmanaged_by_funcs, module) : NULL;\n\n\t\tvalue = module_get_option_inlock (mod, field);\n\t\tif (value)\n\t\t\toption = strdup (value);\n\n\tp11_unlock ();\n\n\treturn option;\n}\n\n/**\n * p11_kit_config_option:\n * @module: the module to retrieve the option for, or %NULL for global options\n * @option: the option to retrieve\n *\n * Retrieve the value for a configured option.\n *\n * If @module is %NULL, then the global option with the given name will\n * be retrieved. Otherwise @module should point to a configured loaded module.\n * If no such @option or configured @module exists, then %NULL will be returned.\n *\n * Use free() to release the returned value.\n *\n * Returns: the option value or %NULL\n */\nchar *\np11_kit_config_option (CK_FUNCTION_LIST *module,\n                       const char *option)\n{\n\tModule *mod = NULL;\n\tconst char *value = NULL;\n\tchar *ret = NULL;\n\n\treturn_val_if_fail (option != NULL, NULL);\n\n\tp11_library_init_once ();\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\tif (gl.modules) {\n\t\t\tif (module != NULL) {\n\t\t\t\tmod = module_for_functions_inlock (module);\n\t\t\t\tif (mod == NULL)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tvalue = module_get_option_inlock (mod, option);\n\t\t\tif (value)\n\t\t\t\tret = strdup (value);\n\t\t}\n\n\ncleanup:\n\tp11_unlock ();\n\treturn ret;\n}\n\ntypedef struct {\n\tp11_virtual virt;\n\tModule *mod;\n\tunsigned int initialized;\n\tp11_dict *sessions;\n} Managed;\n\nstatic CK_RV\nmanaged_C_Initialize (CK_X_FUNCTION_LIST *self,\n                      CK_VOID_PTR init_args)\n{\n\tManaged *managed = ((Managed *)self);\n\tp11_dict *sessions;\n\tCK_RV rv;\n\n\tp11_debug (\"in\");\n\tp11_lock ();\n\n\tif (managed->initialized == p11_forkid) {\n\t\trv = CKR_CRYPTOKI_ALREADY_INITIALIZED;\n\n\t} else {\n\t\tsessions = p11_dict_new (p11_dict_ulongptr_hash,\n\t\t                         p11_dict_ulongptr_equal,\n\t\t                         free, free);\n\t\tif (!sessions)\n\t\t\trv = CKR_HOST_MEMORY;\n\t\telse\n\t\t\trv = initialize_module_inlock_reentrant (managed->mod, init_args);\n\t\tif (rv == CKR_OK) {\n\t\t\tif (managed->sessions)\n\t\t\t\tp11_dict_free (managed->sessions);\n\t\t\tmanaged->sessions = sessions;\n\t\t\tmanaged->initialized = p11_forkid;\n\t\t} else {\n\t\t\tp11_dict_free (sessions);\n\t\t}\n\t}\n\n\tp11_unlock ();\n\tp11_debug (\"out: %lu\", rv);\n\n\treturn rv;\n}\n\nstatic CK_RV\nmanaged_track_session_inlock (p11_dict *sessions,\n                              CK_SLOT_ID slot_id,\n                              CK_SESSION_HANDLE session)\n{\n\tvoid *key;\n\tvoid *value;\n\n\tkey = memdup (&session, sizeof (CK_SESSION_HANDLE));\n\treturn_val_if_fail (key != NULL, CKR_HOST_MEMORY);\n\n\tvalue = memdup (&slot_id, sizeof (CK_SESSION_HANDLE));\n\treturn_val_if_fail (value != NULL, CKR_HOST_MEMORY);\n\n\tif (!p11_dict_set (sessions, key, value))\n\t\treturn_val_if_reached (CKR_HOST_MEMORY);\n\n\treturn CKR_OK;\n}\n\nstatic void\nmanaged_untrack_session_inlock (p11_dict *sessions,\n                                CK_SESSION_HANDLE session)\n{\n\tp11_dict_remove (sessions, &session);\n}\n\nstatic CK_SESSION_HANDLE *\nmanaged_steal_sessions_inlock (p11_dict *sessions,\n                        bool matching_slot_id,\n                        CK_SLOT_ID slot_id,\n                        int *count)\n{\n\tCK_SESSION_HANDLE *stolen;\n\tCK_SESSION_HANDLE *key;\n\tCK_SLOT_ID *value;\n\tp11_dictiter iter;\n\tint at, i;\n\n\tassert (sessions != NULL);\n\tassert (count != NULL);\n\n\tstolen = calloc (p11_dict_size (sessions), sizeof (CK_SESSION_HANDLE));\n\treturn_val_if_fail (stolen != NULL, NULL);\n\n\tat = 0;\n\tp11_dict_iterate (sessions, &iter);\n\twhile (p11_dict_next (&iter, (void **)&key, (void **)&value)) {\n\t\tif (!matching_slot_id || slot_id == *value)\n\t\t\tstolen[at++] = *key;\n\t}\n\n\t/* Removed them all, clear the whole array */\n\tif (at == p11_dict_size (sessions)) {\n\t\tp11_dict_clear (sessions);\n\n\t/* Only removed some, go through and remove those */\n\t} else {\n\t\tfor (i = 0; i < at; i++) {\n\t\t\tif (!p11_dict_remove (sessions, stolen + i))\n\t\t\t\tassert_not_reached ();\n\t\t}\n\t}\n\n\t*count = at;\n\treturn stolen;\n}\n\nstatic void\nmanaged_close_sessions (CK_X_FUNCTION_LIST *funcs,\n                        CK_SESSION_HANDLE *stolen,\n                        int count)\n{\n\tCK_RV rv;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\trv = funcs->C_CloseSession (funcs, stolen[i]);\n\t\tif (rv != CKR_OK)\n\t\t\tp11_message (\"couldn't close session: %s\", p11_kit_strerror (rv));\n\t}\n}\n\nstatic CK_RV\nmanaged_C_Finalize (CK_X_FUNCTION_LIST *self,\n                    CK_VOID_PTR reserved)\n{\n\tManaged *managed = ((Managed *)self);\n\tCK_SESSION_HANDLE *sessions;\n\tint count;\n\tCK_RV rv;\n\n\tp11_debug (\"in\");\n\tp11_lock ();\n\n\tif (managed->initialized == 0) {\n\t\trv = CKR_CRYPTOKI_NOT_INITIALIZED;\n\n\t} else if (managed->initialized != p11_forkid) {\n\t\t/*\n\t\t * In theory we should be returning CKR_CRYPTOKI_NOT_INITIALIZED here\n\t\t * but enough callers are not completely aware of their forking.\n\t\t * So we just clean up any state we have, rather than forcing callers\n\t\t * to initialize just to finalize.\n\t\t */\n\t\tp11_debug (\"finalizing module in wrong process, skipping C_Finalize\");\n\t\trv = CKR_OK;\n\n\t} else {\n\t\tsessions = managed_steal_sessions_inlock (managed->sessions, false, 0, &count);\n\n\t\tif (sessions && count) {\n\t\t\t/* WARNING: reentrancy can occur here */\n\t\t\tp11_unlock ();\n\t\t\tmanaged_close_sessions (&managed->mod->virt.funcs, sessions, count);\n\t\t\tp11_lock ();\n\t\t}\n\n\t\tfree (sessions);\n\n\t\t/* WARNING: reentrancy can occur here */\n\t\trv = finalize_module_inlock_reentrant (managed->mod);\n\t}\n\n\tif (rv == CKR_OK) {\n\t\tmanaged->initialized = 0;\n\t\tp11_dict_free (managed->sessions);\n\t\tmanaged->sessions = NULL;\n\t}\n\n\tp11_unlock ();\n\tp11_debug (\"out: %lu\", rv);\n\n\treturn rv;\n}\n\nstatic CK_RV\nmanaged_C_OpenSession (CK_X_FUNCTION_LIST *self,\n                       CK_SLOT_ID slot_id,\n                       CK_FLAGS flags,\n                       CK_VOID_PTR application,\n                       CK_NOTIFY notify,\n                       CK_SESSION_HANDLE_PTR session)\n{\n\tManaged *managed = ((Managed *)self);\n\tCK_RV rv;\n\n\treturn_val_if_fail (session != NULL, CKR_ARGUMENTS_BAD);\n\n\tself = &managed->mod->virt.funcs;\n\trv = self->C_OpenSession (self, slot_id, flags, application, notify, session);\n\n\tif (rv == CKR_OK) {\n\t\tp11_lock ();\n\t\trv = managed_track_session_inlock (managed->sessions, slot_id, *session);\n\t\tp11_unlock ();\n\t}\n\n\treturn rv;\n}\n\nstatic CK_RV\nmanaged_C_CloseSession (CK_X_FUNCTION_LIST *self,\n                        CK_SESSION_HANDLE session)\n{\n\tManaged *managed = ((Managed *)self);\n\tCK_RV rv;\n\n\tself = &managed->mod->virt.funcs;\n\trv = self->C_CloseSession (self, session);\n\n\tif (rv == CKR_OK) {\n\t\tp11_lock ();\n\t\tmanaged_untrack_session_inlock (managed->sessions, session);\n\t\tp11_unlock ();\n\t}\n\n\treturn rv;\n}\n\nstatic CK_RV\nmanaged_C_CloseAllSessions (CK_X_FUNCTION_LIST *self,\n                            CK_SLOT_ID slot_id)\n{\n\tManaged *managed = ((Managed *)self);\n\tCK_SESSION_HANDLE *stolen;\n\tint count;\n\n\tp11_lock ();\n\tstolen = managed_steal_sessions_inlock (managed->sessions, true, slot_id, &count);\n\tp11_unlock ();\n\n\tself = &managed->mod->virt.funcs;\n\tmanaged_close_sessions (self, stolen, count);\n\tif (stolen) {\n\t\tfree (stolen);\n\t\treturn CKR_OK;\n\t} else {\n\t\treturn CKR_GENERAL_ERROR;\n\t}\n\n}\n\nstatic void\nmanaged_free_inlock (void *data)\n{\n\tManaged *managed = data;\n\tmanaged->mod->ref_count--;\n\tfree (managed);\n}\n\nstatic p11_virtual *\nmanaged_create_inlock (Module *mod)\n{\n\tManaged *managed;\n\n\tmanaged = calloc (1, sizeof (Managed));\n\treturn_val_if_fail (managed != NULL, NULL);\n\n\tp11_virtual_init (&managed->virt, &p11_virtual_stack,\n\t                  &mod->virt, NULL);\n\tmanaged->virt.funcs.C_Initialize = managed_C_Initialize;\n\tmanaged->virt.funcs.C_Finalize = managed_C_Finalize;\n\tmanaged->virt.funcs.C_CloseAllSessions = managed_C_CloseAllSessions;\n\tmanaged->virt.funcs.C_CloseSession = managed_C_CloseSession;\n\tmanaged->virt.funcs.C_OpenSession = managed_C_OpenSession;\n\tmanaged->mod = mod;\n\tmod->ref_count++;\n\n\treturn &managed->virt;\n}\n\nstatic bool\nlookup_managed_option (Module *mod,\n                       bool supported,\n                       const char *option,\n                       bool def_value)\n{\n\tconst char *string;\n\tbool value;\n\n\tstring = module_get_option_inlock (NULL, option);\n\tif (!string)\n\t\tstring = module_get_option_inlock (mod, option);\n\tif (!string) {\n\t\tif (!supported)\n\t\t\treturn false;\n\t\treturn def_value;\n\t}\n\n\tvalue = _p11_conf_parse_boolean (string, def_value);\n\n\tif (!supported && value != supported) {\n\t  /*\n\t   * This is because the module is running in unmanaged mode, so turn off the\n\t   */\n\t  p11_message (\"the '%s' option for module '%s' is only supported for managed modules\",\n\t\t       option, mod->name);\n\t}\n\n\treturn value;\n}\n\nstatic CK_RV\nrelease_module_inlock_rentrant (CK_FUNCTION_LIST *module,\n                                const char *caller_func)\n{\n\tModule *mod;\n\n\tassert (module != NULL);\n\n\t/* See if a managed module, and finalize if so */\n\tif (p11_virtual_is_wrapper (module)) {\n\t\tmod = p11_dict_get (gl.managed_by_closure, module);\n\t\tif (mod != NULL) {\n\t\t\tif (!p11_dict_remove (gl.managed_by_closure, module))\n\t\t\t\tassert_not_reached ();\n\t\t\tp11_virtual_unwrap (module);\n\t\t}\n\n\t/* If an unmanaged module then caller should have finalized */\n\t} else {\n\t\tmod = p11_dict_get (gl.unmanaged_by_funcs, module);\n\t}\n\n\tif (mod == NULL) {\n\t\tp11_debug_precond (\"invalid module pointer passed to %s\", caller_func);\n\t\treturn CKR_ARGUMENTS_BAD;\n\t}\n\n\t/* Matches the ref in prepare_module_inlock_reentrant() */\n\tmod->ref_count--;\n\treturn CKR_OK;\n}\n\nCK_RV\np11_modules_release_inlock_reentrant (CK_FUNCTION_LIST **modules)\n{\n\tCK_RV ret = CKR_OK;\n\tCK_RV rv;\n\tint i;\n\n\tfor (i = 0; modules[i] != NULL; i++) {\n\t\trv = release_module_inlock_rentrant (modules[i], __PRETTY_FUNCTION__);\n\t\tif (rv != CKR_OK)\n\t\t\tret = rv;\n\t}\n\n\tfree (modules);\n\n\t/* In case nothing loaded, free up internal memory */\n\tfree_modules_when_no_refs_unlocked ();\n\n\treturn ret;\n}\n\nstatic CK_RV\nprepare_module_inlock_reentrant (Module *mod,\n                                 int flags,\n                                 CK_FUNCTION_LIST **module)\n{\n\tp11_destroyer destroyer;\n\tconst char *trusted;\n\tp11_virtual *virt;\n\tbool is_managed;\n\tbool with_log;\n\n\tassert (module != NULL);\n\n\tif (flags & P11_KIT_MODULE_TRUSTED) {\n\t\ttrusted = module_get_option_inlock (mod, \"trust-policy\");\n\t\tif (!_p11_conf_parse_boolean (trusted, false))\n\t\t\treturn CKR_FUNCTION_NOT_SUPPORTED;\n\t}\n\n\tif (flags & P11_KIT_MODULE_UNMANAGED) {\n\t\tis_managed = false;\n\t\twith_log = false;\n\t} else {\n\t\tis_managed = lookup_managed_option (mod, true, \"managed\", true);\n\t\twith_log = lookup_managed_option (mod, is_managed, \"log-calls\", false);\n\t}\n\n\tif (is_managed) {\n\t\tvirt = managed_create_inlock (mod);\n\t\treturn_val_if_fail (virt != NULL, CKR_HOST_MEMORY);\n\t\tdestroyer = managed_free_inlock;\n\n\t\t/* Add the logger if configured */\n\t\tif (p11_log_force || with_log) {\n\t\t\tvirt = p11_log_subclass (virt, destroyer);\n\t\t\tdestroyer = p11_log_release;\n\t\t}\n\n\t\t*module = p11_virtual_wrap (virt, destroyer);\n\t\tif (*module == NULL)\n\t\t\treturn CKR_GENERAL_ERROR;\n\n\t\tif (!p11_dict_set (gl.managed_by_closure, *module, mod))\n\t\t\treturn_val_if_reached (CKR_HOST_MEMORY);\n\n\t} else {\n\t\t*module = unmanaged_for_module_inlock (mod);\n\t\tif (*module == NULL)\n\t\t\treturn CKR_FUNCTION_NOT_SUPPORTED;\n\t}\n\n\t/* Matches the deref in release_module_inlock_rentrant() */\n\tmod->ref_count++;\n\treturn CKR_OK;\n}\n\nCK_RV\np11_modules_load_inlock_reentrant (int flags,\n                                   CK_FUNCTION_LIST ***results)\n{\n\tCK_FUNCTION_LIST **modules;\n\tModule *mod;\n\tp11_dictiter iter;\n\tCK_RV rv;\n\tint at;\n\n\trv = init_globals_unlocked ();\n\tif (rv != CKR_OK)\n\t\treturn rv;\n\n\trv = load_registered_modules_unlocked (flags);\n\tif (rv != CKR_OK)\n\t\treturn rv;\n\n\tmodules = calloc (p11_dict_size (gl.modules) + 1, sizeof (CK_FUNCTION_LIST *));\n\treturn_val_if_fail (modules != NULL, CKR_HOST_MEMORY);\n\n\tat = 0;\n\trv = CKR_OK;\n\n\tp11_dict_iterate (gl.modules, &iter);\n\twhile (p11_dict_next (&iter, NULL, (void **)&mod)) {\n\n\t\t/*\n\t\t * We don't include unreferenced modules. We don't include\n\t\t * modules that have been initialized but aren't in the\n\t\t * registry. These have a NULL name.\n\t\t *\n\t\t * In addition we check again that the module isn't disabled\n\t\t * using enable-in or disable-in. This is because a caller\n\t\t * can change the progname we recognize the process as after\n\t\t * having initialized. This is a corner case, but want to make\n\t\t * sure to cover it.\n\t\t */\n\t\tif (!mod->name || !is_module_enabled_unlocked (mod->name, mod->config, flags))\n\t\t\tcontinue;\n\n\t\trv = prepare_module_inlock_reentrant (mod, flags, modules + at);\n\t\tif (rv == CKR_OK)\n\t\t\tat++;\n\t\telse if (rv == CKR_FUNCTION_NOT_SUPPORTED)\n\t\t\trv = CKR_OK;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tmodules[at] = NULL;\n\n\tif (rv != CKR_OK) {\n\t\tp11_modules_release_inlock_reentrant (modules);\n\t\treturn rv;\n\t}\n\n\tsort_modules_by_priority (modules, at);\n\t*results = modules;\n\treturn CKR_OK;\n}\n\n/**\n * p11_kit_modules_load:\n * @reserved: set to %NULL\n * @flags: flags to use to load the module\n *\n * Load the configured PKCS\\#11 modules.\n *\n * If @flags contains the %P11_KIT_MODULE_UNMANAGED flag, then the\n * modules will be not be loaded in 'managed' mode regardless of its\n * configuration. This is not recommended for general usage.\n *\n * If @flags contains the %P11_KIT_MODULE_CRITICAL flag then the\n * modules will all be treated as 'critical', regardless of the module\n * configuration. This means that a failure to load any module will\n * cause this function to fail.\n *\n * For unmanaged modules there is no guarantee to the state of the\n * modules. Other callers may be using the modules. Using unmanaged\n * modules haphazardly is not recommended for this reason. Some\n * modules (such as those configured with RPC) cannot be loaded in\n * unmanaged mode, and will be skipped.\n *\n * If @flags contains the %P11_KIT_MODULE_TRUSTED flag then only the\n * marked as trusted modules will be loaded.\n *\n * Use p11_kit_modules_release() to release the modules returned by\n * this function.\n *\n * If this function fails, then an error message will be available via the\n * p11_kit_message() function.\n *\n * Returns: a null terminated list of modules represented as PKCS\\#11\n *     function lists, or %NULL on failure\n */\nCK_FUNCTION_LIST **\np11_kit_modules_load (const char *reserved,\n                      int flags)\n{\n\tCK_FUNCTION_LIST **modules;\n\tCK_RV rv;\n\n\t/* progname attribute not implemented yet */\n\treturn_val_if_fail (reserved == NULL, NULL);\n\n\tp11_library_init_once ();\n\n\t/* WARNING: This function must be reentrant */\n\tp11_debug (\"in\");\n\n\t/* mask out internal flags */\n\tflags &= P11_KIT_MODULE_MASK;\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\t/* WARNING: Reentrancy can occur here */\n\t\trv = p11_modules_load_inlock_reentrant (flags, &modules);\n\n\tp11_unlock ();\n\n\tif (rv != CKR_OK)\n\t\tmodules = NULL;\n\n\tp11_debug (\"out: %s\", modules ? \"success\" : \"fail\");\n\treturn modules;\n}\n\n/**\n * p11_kit_modules_initialize:\n * @modules: a %NULL terminated list of modules\n * @failure_callback: called with modules that fail to initialize\n *\n * Initialize all the modules in the @modules list by calling their\n * <literal>C_Initialize</literal> function.\n *\n * For managed modules the <literal>C_Initialize</literal> function\n * is overridden so that multiple callers can initialize the same\n * modules. In addition for managed modules multiple callers can\n * initialize from different threads, and still guarantee consistent\n * thread-safe behavior.\n *\n * For unmanaged modules if multiple callers try to initialize\n * a module, then one of the calls will return\n * <literal>CKR_CRYPTOKI_ALREADY_INITIALIZED</literal> according to the\n * PKCS\\#11 specification. In addition there are no guarantees that\n * thread-safe behavior will occur if multiple callers initialize from\n * different threads.\n *\n * When a module fails to initialize it is removed from the @modules list.\n * If the @failure_callback is not %NULL then it is called with the modules that\n * fail to initialize. For example, you may pass p11_kit_module_release()\n * as a @failure_callback if the @modules list was loaded wit p11_kit_modules_load().\n *\n * The return value will return the failure code of the last critical\n * module that failed to initialize. Non-critical module failures do not affect\n * the return value. If no critical modules failed to initialize then the\n * return value will be <literal>CKR_OK</literal>.\n *\n * When modules are removed, the list will be %NULL terminated at the\n * appropriate place so it can continue to be used as a modules list.\n *\n * This function does not accept a <code>CK_C_INITIALIZE_ARGS</code> argument.\n * Custom initialization arguments cannot be supported when multiple consumers\n * load the same module.\n *\n * Returns: <literal>CKR_OK</literal> or the failure code of the last critical\n * \tmodule that failed to initialize.\n */\nCK_RV\np11_kit_modules_initialize (CK_FUNCTION_LIST **modules,\n                            p11_kit_destroyer failure_callback)\n{\n\tCK_RV ret = CKR_OK;\n\tCK_RV rv;\n\tbool critical;\n\tchar *name;\n\tint i, out;\n\n\treturn_val_if_fail (modules != NULL, CKR_ARGUMENTS_BAD);\n\n\tfor (i = 0, out = 0; modules[i] != NULL; i++, out++) {\n\t\trv = modules[i]->C_Initialize (NULL);\n\t\tif (rv != CKR_OK && rv != CKR_CRYPTOKI_ALREADY_INITIALIZED) {\n\t\t\tname = p11_kit_module_get_name (modules[i]);\n\t\t\tif (name == NULL)\n\t\t\t\tname = strdup (\"(unknown)\");\n\t\t\treturn_val_if_fail (name != NULL, CKR_HOST_MEMORY);\n\t\t\tcritical = (p11_kit_module_get_flags (modules[i]) & P11_KIT_MODULE_CRITICAL);\n\t\t\tp11_message (\"%s: module failed to initialize%s: %s\",\n\t\t\t             name, critical ? \"\" : \", skipping\", p11_kit_strerror (rv));\n\t\t\tif (critical)\n\t\t\t\tret = rv;\n\t\t\tif (failure_callback)\n\t\t\t\tfailure_callback (modules[i]);\n\t\t\tout--;\n\t\t\tfree (name);\n\t\t} else {\n\t\t\tif (rv == CKR_CRYPTOKI_ALREADY_INITIALIZED) {\n\t\t\t\tname = p11_kit_module_get_name (modules[i]);\n\t\t\t\tp11_message (\"%s: module was already initialized\",\n\t\t\t\t             name ? name : \"(unknown)\");\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t\tmodules[out] = modules[i];\n\t\t}\n\t}\n\n\t/* NULL terminate after above changes */\n\tmodules[out] = NULL;\n\treturn ret;\n}\n\n/**\n * p11_kit_modules_load_and_initialize:\n * @flags: flags to use to load the modules\n *\n * Load and initialize configured modules.\n *\n * If a critical module fails to load or initialize then the function will\n * return <literal>NULL</literal>. Non-critical modules will be skipped\n * and not included in the returned module list.\n *\n * Use p11_kit_modules_finalize_and_release() when you're done with the\n * modules returned by this function.\n *\n * The @flags allowed by this function, as well as their meaning, are the\n * same as with p11_kit_modules_load().\n *\n * Returns: a <literal>NULL</literal> terminated list of modules, or\n * \t<literal>NULL</literal> on failure\n */\nCK_FUNCTION_LIST **\np11_kit_modules_load_and_initialize (int flags)\n{\n\tCK_FUNCTION_LIST **modules;\n\tCK_RV rv;\n\n\t/* mask out internal flags */\n\tflags &= P11_KIT_MODULE_MASK;\n\n\tmodules = p11_kit_modules_load (NULL, flags);\n\tif (modules == NULL)\n\t\treturn NULL;\n\n\trv = p11_kit_modules_initialize (modules, (p11_destroyer)p11_kit_module_release);\n\tif (rv != CKR_OK) {\n\t\tp11_kit_modules_release (modules);\n\t\tmodules = NULL;\n\t}\n\n\treturn modules;\n}\n\n/**\n * p11_kit_modules_finalize:\n * @modules: a <literal>NULL</literal> terminated list of modules\n *\n * Finalize each module in the @modules list by calling its\n * <literal>C_Finalize</literal> function. Regardless of failures, all\n * @modules will have their <literal>C_Finalize</literal> function called.\n *\n * If a module returns a failure from its <literal>C_Finalize</literal>\n * method it will be returned. If multiple modules fail, the last failure\n * will be returned.\n *\n * For managed modules the <literal>C_Finalize</literal> function\n * is overridden so that multiple callers can finalize the same\n * modules. In addition for managed modules multiple callers can\n * finalize from different threads, and still guarantee consistent\n * thread-safe behavior.\n *\n * For unmanaged modules if multiple callers try to finalize\n * a module, then one of the calls will return\n * <literal>CKR_CRYPTOKI_NOT_INITIALIZED</literal> according to the\n * PKCS\\#11 specification. In addition there are no guarantees that\n * thread-safe behavior will occur if multiple callers finalize from\n * different threads.\n *\n * Returns: <literal>CKR_OK</literal> or the failure code of the last\n * \tmodule that failed to finalize\n */\nCK_RV\np11_kit_modules_finalize (CK_FUNCTION_LIST **modules)\n{\n\tCK_RV ret = CKR_OK;\n\tCK_RV rv;\n\tchar *name;\n\tint i;\n\n\treturn_val_if_fail (modules != NULL, CKR_ARGUMENTS_BAD);\n\n\tfor (i = 0; modules[i] != NULL; i++) {\n\t\trv = modules[i]->C_Finalize (NULL);\n\t\tif (rv != CKR_OK) {\n\t\t\tname = p11_kit_module_get_name (modules[i]);\n\t\t\tp11_message (\"%s: module failed to finalize: %s\",\n\t\t\t             name ? name : \"(unknown)\", p11_kit_strerror (rv));\n\t\t\tfree (name);\n\t\t\tret = rv;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/**\n * p11_kit_modules_release:\n * @modules: the modules to release\n *\n * Release the a set of loaded PKCS\\#11 modules.\n *\n * The modules may be either managed or unmanaged. The array containing\n * the module pointers is also freed by this function.\n *\n * Managed modules will not be actually released until all\n * callers using them have done so. If the modules were initialized, they\n * should have been finalized first.\n */\nvoid\np11_kit_modules_release (CK_FUNCTION_LIST **modules)\n{\n\tp11_library_init_once ();\n\n\treturn_if_fail (modules != NULL);\n\n\t/* WARNING: This function must be reentrant */\n\tp11_debug (\"in\");\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\t\tp11_modules_release_inlock_reentrant (modules);\n\n\tp11_unlock ();\n\n\tp11_debug (\"out\");\n}\n\n/**\n * p11_kit_modules_finalize_and_release:\n * @modules: the modules to release\n *\n * Finalize and then release the a set of loaded PKCS\\#11 modules.\n *\n * The modules may be either managed or unmanaged. The array containing\n * the module pointers is also freed by this function.\n *\n * Modules are released even if their finalization returns an error code.\n * Managed modules will not be actually finalized or released until all\n * callers using them have done so.\n *\n * For managed modules the <literal>C_Finalize</literal> function\n * is overridden so that multiple callers can finalize the same\n * modules. In addition for managed modules multiple callers can\n * finalize from different threads, and still guarantee consistent\n * thread-safe behavior.\n *\n * For unmanaged modules if multiple callers try to finalize\n * a module, then one of the calls will return\n * <literal>CKR_CRYPTOKI_NOT_INITIALIZED</literal> according to the\n * PKCS\\#11 specification. In addition there are no guarantees that\n * thread-safe behavior will occur if multiple callers initialize from\n * different threads.\n */\nvoid\np11_kit_modules_finalize_and_release (CK_FUNCTION_LIST **modules)\n{\n\treturn_if_fail (modules != NULL);\n\tp11_kit_modules_finalize (modules);\n\tp11_kit_modules_release (modules);\n}\n\n/**\n * p11_kit_initialize_module:\n * @module: loaded module to initialize.\n *\n * Initialize an arbitrary PKCS\\#11 module. Normally using the\n * p11_kit_initialize_registered() is preferred.\n *\n * Using this function to initialize modules allows coordination between\n * multiple users of the same module in a single process. It should be called\n * on modules that have been loaded (with dlopen() for example) but not yet\n * initialized. The caller should not yet have called the module's\n * <code>C_Initialize</code> method. This function will call\n * <code>C_Initialize</code> as necessary.\n *\n * Subsequent calls to this function for the same module will result in an\n * initialization count being incremented for the module. It is safe (although\n * usually unnecessary) to use this function on registered modules.\n *\n * The module must be finalized with p11_kit_finalize_module() instead of\n * calling its <code>C_Finalize</code> method directly.\n *\n * This function does not accept a <code>CK_C_INITIALIZE_ARGS</code> argument.\n * Custom initialization arguments cannot be supported when multiple consumers\n * load the same module.\n *\n * If this function fails, then an error message will be available via the\n * p11_kit_message() function.\n *\n * Deprecated: Since 0.19.0: Use p11_kit_module_initialize() instead.\n *\n * Returns: CKR_OK if the initialization was successful.\n */\nCK_RV\np11_kit_initialize_module (CK_FUNCTION_LIST_PTR module)\n{\n\tCK_FUNCTION_LIST_PTR result;\n\tModule *mod;\n\tint flags;\n\tCK_RV rv;\n\n\treturn_val_if_fail (module != NULL, CKR_ARGUMENTS_BAD);\n\n\tp11_library_init_once ();\n\n\t/* WARNING: This function must be reentrant for the same arguments */\n\tp11_debug (\"in\");\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\tflags = P11_KIT_MODULE_CRITICAL | P11_KIT_MODULE_UNMANAGED;\n\t\trv = p11_module_load_inlock_reentrant (module, flags, &result);\n\n\t\t/* An unmanaged module should return the same pointer */\n\t\tassert (rv != CKR_OK || result == module);\n\n\t\tif (rv == CKR_OK) {\n\t\t\tmod = p11_dict_get (gl.unmanaged_by_funcs, module);\n\t\t\tassert (mod != NULL);\n\t\t\trv = initialize_module_inlock_reentrant (mod, NULL);\n\t\t\tif (rv != CKR_OK) {\n\t\t\t\tp11_message (\"module initialization failed: %s\", p11_kit_strerror (rv));\n\t\t\t\tp11_module_release_inlock_reentrant (module);\n\t\t\t}\n\t\t}\n\n\tp11_unlock ();\n\n\tp11_debug (\"out: %lu\", rv);\n\treturn rv;\n}\n\nCK_RV\np11_module_load_inlock_reentrant (CK_FUNCTION_LIST *module,\n                                  int flags,\n                                  CK_FUNCTION_LIST **result)\n{\n\tModule *allocated = NULL;\n\tModule *mod;\n\tCK_RV rv = CKR_OK;\n\n\trv = init_globals_unlocked ();\n\tif (rv == CKR_OK) {\n\n\t\tmod = p11_dict_get (gl.unmanaged_by_funcs, module);\n\t\tif (mod == NULL) {\n\t\t\tp11_debug (\"allocating new module\");\n\t\t\tallocated = mod = alloc_module_unlocked ();\n\t\t\treturn_val_if_fail (mod != NULL, CKR_HOST_MEMORY);\n\t\t\tp11_virtual_init (&mod->virt, &p11_virtual_base, module, NULL);\n\t\t}\n\n\t\t/* If this was newly allocated, add it to the list */\n\t\tif (allocated) {\n\t\t\tif (!p11_dict_set (gl.modules, allocated, allocated) ||\n\t\t\t    !p11_dict_set (gl.unmanaged_by_funcs, module, allocated))\n\t\t\t\treturn_val_if_reached (CKR_HOST_MEMORY);\n\t\t\tallocated = NULL;\n\t\t}\n\n\t\t\t/* WARNING: Reentrancy can occur here */\n\t\t\trv = prepare_module_inlock_reentrant (mod, flags, result);\n\n\t\tfree (allocated);\n\t}\n\n\t/*\n\t * If initialization failed, we may need to cleanup.\n\t * If we added this module above, then this will\n\t * clean things up as expected.\n\t */\n\tif (rv != CKR_OK)\n\t\tfree_modules_when_no_refs_unlocked ();\n\n\t_p11_kit_default_message (rv);\n\treturn rv;\n}\n\n/**\n * p11_kit_module_load:\n * @module_path: relative or full file path of module library\n * @flags: flags to use when loading the module\n *\n * Load an arbitrary PKCS\\#11 module from a dynamic library file, and\n * initialize it. Normally using the p11_kit_modules_load() function\n * is preferred.\n *\n * A full file path or just (path/)filename relative to\n * P11_MODULE_PATH are accepted.\n *\n * Using this function to load modules allows coordination between multiple\n * callers of the same module in a single process. If @flags contains the\n * %P11_KIT_MODULE_UNMANAGED flag, then the modules will be not be loaded\n * in 'managed' mode and not be coordinated. This is not recommended\n * for general usage.\n *\n * Subsequent calls to this function for the same module will result in an\n * initialization count being incremented for the module. It is safe (although\n * usually unnecessary) to use this function on registered modules.\n *\n * The module should be released with p11_kit_module_release().\n *\n * If this function fails, then an error message will be available via the\n * p11_kit_message() function.\n *\n * Returns: the loaded module PKCS\\#11 functions or %NULL on failure\n */\nCK_FUNCTION_LIST *\np11_kit_module_load (const char *module_path,\n                     int flags)\n{\n\tCK_FUNCTION_LIST *module = NULL;\n\tCK_RV rv;\n\tModule *mod;\n\n\treturn_val_if_fail (module_path != NULL, NULL);\n\n\tp11_library_init_once ();\n\n\t/* WARNING: This function must be reentrant for the same arguments */\n\tp11_debug (\"in: %s\", module_path);\n\n\t/* mask out internal flags */\n\tflags &= P11_KIT_MODULE_MASK;\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\trv = init_globals_unlocked ();\n\t\tif (rv == CKR_OK) {\n\n\t\t\trv = load_module_from_file_inlock (NULL, module_path, &mod);\n\t\t\tif (rv == CKR_OK) {\n\t\t\t\t/* WARNING: Reentrancy can occur here */\n\t\t\t\trv = prepare_module_inlock_reentrant (mod, flags, &module);\n\t\t\t\tif (rv != CKR_OK)\n\t\t\t\t\tmodule = NULL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If initialization failed, we may need to cleanup.\n\t\t * If we added this module above, then this will\n\t\t * clean things up as expected.\n\t\t */\n\t\tif (rv != CKR_OK)\n\t\t\tfree_modules_when_no_refs_unlocked ();\n\n\tp11_unlock ();\n\n\tp11_debug (\"out: %s\", module ? \"success\" : \"fail\");\n\treturn module;\n\n}\n\n/**\n * p11_kit_finalize_module:\n * @module: loaded module to finalize.\n *\n * Finalize an arbitrary PKCS\\#11 module. The module must have been initialized\n * using p11_kit_initialize_module(). In most cases callers will want to use\n * p11_kit_finalize_registered() instead of this function.\n *\n * Using this function to finalize modules allows coordination between\n * multiple users of the same module in a single process. The caller should not\n * call the module's <code>C_Finalize</code> method. This function will call\n * <code>C_Finalize</code> as necessary.\n *\n * If the module was initialized more than once, then this function will\n * decrement an initialization count for the module. When the count reaches zero\n * the module will be truly finalized. It is safe (although usually unnecessary)\n * to use this function on registered modules if (and only if) they were\n * initialized using p11_kit_initialize_module() for some reason.\n *\n * If this function fails, then an error message will be available via the\n * p11_kit_message() function.\n *\n * Deprecated: Since 0.19.0: Use p11_kit_module_finalize() and\n * \tp11_kit_module_release() instead.\n *\n * Returns: CKR_OK if the finalization was successful.\n */\nCK_RV\np11_kit_finalize_module (CK_FUNCTION_LIST *module)\n{\n\tModule *mod;\n\tCK_RV rv = CKR_OK;\n\n\treturn_val_if_fail (module != NULL, CKR_ARGUMENTS_BAD);\n\n\tp11_library_init_once ();\n\n\t/* WARNING: This function must be reentrant for the same arguments */\n\tp11_debug (\"in\");\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\tmod = gl.unmanaged_by_funcs ? p11_dict_get (gl.unmanaged_by_funcs, module) : NULL;\n\t\tif (mod == NULL) {\n\t\t\tp11_debug (\"module not found\");\n\t\t\trv = CKR_ARGUMENTS_BAD;\n\t\t} else {\n\t\t\t/* WARNING: Rentrancy can occur here */\n\t\t\trv = finalize_module_inlock_reentrant (mod);\n\t\t}\n\n\t\t_p11_kit_default_message (rv);\n\n\tp11_unlock ();\n\n\tp11_debug (\"out: %lu\", rv);\n\treturn rv;\n}\n\n/**\n * p11_kit_module_initialize:\n * @module: the module to initialize\n *\n * Initialize a PKCS\\#11 module by calling its <literal>C_Initialize</literal>\n * function.\n *\n * For managed modules the <literal>C_Initialize</literal> function\n * is overridden so that multiple callers can initialize the same\n * modules. In addition for managed modules multiple callers can\n * initialize from different threads, and still guarantee consistent\n * thread-safe behavior.\n *\n * For unmanaged modules if multiple callers try to initialize\n * a module, then one of the calls will return\n * <literal>CKR_CRYPTOKI_ALREADY_INITIALIZED</literal> according to the\n * PKCS\\#11 specification. In addition there are no guarantees that\n * thread-safe behavior will occur if multiple callers initialize from\n * different threads.\n *\n * This function does not accept a <code>CK_C_INITIALIZE_ARGS</code> argument.\n * Custom initialization arguments cannot be supported when multiple consumers\n * load the same module.\n *\n * Returns: <literal>CKR_OK</literal> or a failure code\n */\nCK_RV\np11_kit_module_initialize (CK_FUNCTION_LIST *module)\n{\n\tchar *name;\n\tCK_RV rv;\n\n\treturn_val_if_fail (module != NULL, CKR_ARGUMENTS_BAD);\n\n\trv = module->C_Initialize (NULL);\n\tif (rv != CKR_OK) {\n\t\tname = p11_kit_module_get_name (module);\n\t\tp11_message (\"%s: module failed to initialize: %s\",\n\t\t             name ? name : \"(unknown)\", p11_kit_strerror (rv));\n\t\tfree (name);\n\t}\n\n\treturn rv;\n}\n\n/**\n * p11_kit_module_finalize:\n * @module: the module to finalize\n *\n * Finalize a PKCS\\#11 module by calling its <literal>C_Finalize</literal>\n * function.\n *\n * For managed modules the <literal>C_Finalize</literal> function\n * is overridden so that multiple callers can finalize the same\n * modules. In addition for managed modules multiple callers can\n * finalize from different threads, and still guarantee consistent\n * thread-safe behavior.\n *\n * For unmanaged modules if multiple callers try to finalize\n * a module, then one of the calls will return\n * <literal>CKR_CRYPTOKI_NOT_INITIALIZED</literal> according to the\n * PKCS\\#11 specification. In addition there are no guarantees that\n * thread-safe behavior will occur if multiple callers finalize from\n * different threads.\n *\n * Returns: <literal>CKR_OK</literal> or a failure code\n */\nCK_RV\np11_kit_module_finalize (CK_FUNCTION_LIST *module)\n{\n\tchar *name;\n\tCK_RV rv;\n\n\treturn_val_if_fail (module != NULL, CKR_ARGUMENTS_BAD);\n\n\trv = module->C_Finalize (NULL);\n\tif (rv != CKR_OK) {\n\t\tname = p11_kit_module_get_name (module);\n\t\tp11_message (\"%s: module failed to finalize: %s\",\n\t\t             name ? name : \"(unknown)\", p11_kit_strerror (rv));\n\t\tfree (name);\n\t}\n\n\treturn rv;\n\n}\n\n\n/**\n * p11_kit_module_release:\n * @module: the module to release\n *\n * Release the a loaded PKCS\\#11 modules.\n *\n * The module may be either managed or unmanaged. The <literal>C_Finalize</literal>\n * function will be called if no other callers are using this module.\n */\nvoid\np11_kit_module_release (CK_FUNCTION_LIST *module)\n{\n\treturn_if_fail (module != NULL);\n\n\tp11_library_init_once ();\n\n\t/* WARNING: This function must be reentrant for the same arguments */\n\tp11_debug (\"in\");\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\trelease_module_inlock_rentrant (module, __PRETTY_FUNCTION__);\n\n\tp11_unlock ();\n\n\tp11_debug (\"out\");\n}\n\nCK_RV\np11_module_release_inlock_reentrant (CK_FUNCTION_LIST *module)\n{\n\treturn release_module_inlock_rentrant (module, __PRETTY_FUNCTION__);\n}\n\n/**\n * p11_kit_load_initialize_module:\n * @module_path: full file path of module library\n * @module: location to place loaded module pointer\n *\n * Load an arbitrary PKCS\\#11 module from a dynamic library file, and\n * initialize it. Normally using the p11_kit_initialize_registered() function\n * is preferred.\n *\n * Using this function to load and initialize modules allows coordination between\n * multiple users of the same module in a single process. The caller should not\n * call the module's <code>C_Initialize</code> method. This function will call\n * <code>C_Initialize</code> as necessary.\n *\n * If a module has already been loaded, then use of this function is unnecesasry.\n * Instead use the p11_kit_initialize_module() function to initialize it.\n *\n * Subsequent calls to this function for the same module will result in an\n * initialization count being incremented for the module. It is safe (although\n * usually unnecessary) to use this function on registered modules.\n *\n * The module must be finalized with p11_kit_finalize_module() instead of\n * calling its <code>C_Finalize</code> method directly.\n *\n * This function does not accept a <code>CK_C_INITIALIZE_ARGS</code> argument.\n * Custom initialization arguments cannot be supported when multiple consumers\n * load the same module.\n *\n * If this function fails, then an error message will be available via the\n * p11_kit_message() function.\n *\n * Deprecated: Since 0.19.0: Use p11_kit_module_load() instead.\n *\n * Returns: CKR_OK if the initialization was successful.\n */\nCK_RV\np11_kit_load_initialize_module (const char *module_path,\n                                CK_FUNCTION_LIST_PTR_PTR module)\n{\n\tModule *mod;\n\tCK_RV rv = CKR_OK;\n\n\treturn_val_if_fail (module_path != NULL, CKR_ARGUMENTS_BAD);\n\treturn_val_if_fail (module != NULL, CKR_ARGUMENTS_BAD);\n\n\tp11_library_init_once ();\n\n\t/* WARNING: This function must be reentrant for the same arguments */\n\tp11_debug (\"in: %s\", module_path);\n\n\tp11_lock ();\n\n\t\tp11_message_clear ();\n\n\t\trv = init_globals_unlocked ();\n\t\tif (rv == CKR_OK) {\n\n\t\t\trv = load_module_from_file_inlock (NULL, module_path, &mod);\n\t\t\tif (rv == CKR_OK) {\n\n\t\t\t\t/* WARNING: Reentrancy can occur here */\n\t\t\t\trv = initialize_module_inlock_reentrant (mod, NULL);\n\t\t\t}\n\t\t}\n\n\t\tif (rv == CKR_OK) {\n\t\t\t*module = unmanaged_for_module_inlock (mod);\n\t\t\tassert (*module != NULL);\n\t\t}\n\n\t\t/*\n\t\t * If initialization failed, we may need to cleanup.\n\t\t * If we added this module above, then this will\n\t\t * clean things up as expected.\n\t\t */\n\t\tif (rv != CKR_OK)\n\t\t\tfree_modules_when_no_refs_unlocked ();\n\n\t\t_p11_kit_default_message (rv);\n\n\tp11_unlock ();\n\n\tp11_debug (\"out: %lu\", rv);\n\treturn rv;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/p11-kit/meson.build": "install_headers('deprecated.h',\n                'iter.h',\n                'p11-kit.h',\n                'pin.h',\n                'remote.h',\n                'uri.h',\n                subdir: 'p11-kit-1/p11-kit')\n\nlibp11_kit_internal_sources = [\n  'conf.c',\n  'log.c',\n  'filter.c',\n  'rpc-transport.c',\n  'rpc-message.c',\n  'rpc-client.c'\n]\n\nlibp11_kit_internal_sources += custom_target('generate virtual-fixed-generated.h',\n                                             output: 'virtual-fixed-generated.h',\n                                             command: [\n                                               meson.current_source_dir() / 'gen-virtual-fixed.sh',\n                                               '@OUTPUT@', '64'\n                                             ])\nlibp11_kit_internal_sources += 'virtual.c'\n\nlibp11_kit_internal_c_args = [\n  '-DP11_SYSTEM_CONFIG_FILE=\"@0@\"'.format(prefix / p11_system_config_file),\n  '-DP11_SYSTEM_CONFIG_MODULES=\"@0@\"'.format(prefix / p11_system_config_modules),\n  '-DP11_PACKAGE_CONFIG_MODULES=\"@0@\"'.format(prefix / p11_package_config_modules),\n  '-DP11_USER_CONFIG_FILE=\"@0@\"'.format(p11_user_config_file),\n  '-DP11_USER_CONFIG_MODULES=\"@0@\"'.format(p11_user_config_modules),\n  '-DP11_MODULE_PATH=\"@0@\"'.format(prefix / p11_module_path)\n]\n\nlibp11_kit_internal = static_library('p11-kit-internal',\n                                     libp11_kit_internal_sources,\n                                     dependencies: [libp11_library_dep] + libffi_deps,\n                                     c_args: libp11_kit_internal_c_args,\n                                     implicit_include_directories: false,\n                                     gnu_symbol_visibility: 'hidden')\n\nlibp11_kit_sources = [\n  'iter.c',\n  'messages.c',\n  'modules.c',\n  'pin.c',\n  'proxy.c',\n  'proxy-init.c',\n  'rpc-server.c',\n  'uri.c',\n  'util.c'\n]\n\nlibp11_kit_symbol_map = meson.current_source_dir() / 'libp11-kit.map'\nlibp11_kit_ldflags = cc.get_supported_link_arguments([\n  '-Wl,--version-script,' + libp11_kit_symbol_map\n])\nlibp11_kit_symbol_def = meson.current_source_dir() / 'libp11-kit-@0@.dll.def'.format(soversion)\n\nlibp11_kit = shared_library('p11-kit',\n                            libp11_kit_sources,\n                            install: true,\n                            version: library_version,\n                            soversion: soversion,\n                            dependencies: libffi_deps + dlopen_deps,\n                            include_directories: [configinc, commoninc],\n                            implicit_include_directories: false,\n                            c_args: libp11_kit_internal_c_args,\n                            link_args: libp11_kit_ldflags,\n                            link_depends: [libp11_kit_symbol_map,\n                                           libp11_kit_symbol_def],\n                            link_with: libp11_kit_internal,\n                            vs_module_defs: libp11_kit_symbol_def)\n\nlibp11_kit_dep = declare_dependency(link_with: libp11_kit,\n                                    include_directories: [configinc, commoninc])\n\nmeson.add_install_script(\n  'meson_post_install.sh',\n  libdir,\n  datadir / 'p11-kit' / 'modules'\n)\n\np11_module_symbol_map = meson.current_source_dir() / 'p11-module.map'\np11_module_ldflags = cc.get_supported_link_arguments([\n  '-Wl,--version-script,' + p11_module_symbol_map\n])\np11_module_symbol_def = meson.current_source_dir() / 'p11-module.def'\n\nif host_system != 'windows'\n  shared_module('p11-kit-client',\n                'client.c', 'client-init.c',\n                name_prefix: '',\n                include_directories: [configinc, commoninc],\n                link_args: p11_module_ldflags,\n                link_depends: [p11_module_symbol_map,\n                               p11_module_symbol_def],\n                link_with: [libp11_kit_internal],\n                vs_module_defs: p11_module_symbol_def,\n                install: true,\n                install_dir: p11_module_path)\nendif\n\nfixtures_dir = meson.current_source_dir() / 'fixtures'\n\nif host_system == 'windows'\n  libp11_kit_testable_c_args = [\n    '-DP11_SYSTEM_CONFIG_FILE=\"@0@\"'.format(fixtures_dir / 'system-pkcs11.conf'),\n    '-DP11_SYSTEM_CONFIG_MODULES=\"@0@\"'.format(fixtures_dir / 'system-modules' / 'win32'),\n    '-DP11_PACKAGE_CONFIG_MODULES=\"@0@\"'.format(fixtures_dir / 'package-modules' / 'win32'),\n    '-DP11_USER_CONFIG_FILE=\"@0@\"'.format(fixtures_dir / 'user-pkcs11.conf'),\n    '-DP11_USER_CONFIG_MODULES=\"@0@\"'.format(fixtures_dir / 'user-modules' / 'win32')\n  ]\nelse\n  libp11_kit_testable_c_args = [\n    '-DP11_SYSTEM_CONFIG_FILE=\"@0@\"'.format(fixtures_dir / 'system-pkcs11.conf'),\n    '-DP11_SYSTEM_CONFIG_MODULES=\"@0@\"'.format(fixtures_dir / 'system-modules'),\n    '-DP11_PACKAGE_CONFIG_MODULES=\"@0@\"'.format(fixtures_dir / 'package-modules'),\n    '-DP11_USER_CONFIG_FILE=\"@0@\"'.format(fixtures_dir / 'user-pkcs11.conf'),\n    '-DP11_USER_CONFIG_MODULES=\"@0@\"'.format(fixtures_dir / 'user-modules')\n  ]\nendif\n\nlibp11_kit_testable_c_args += '-DP11_MODULE_PATH=\"@0@\"'.format(meson.current_build_dir())\n\nlibp11_kit_testable = static_library('p11-kit-testable',\n                                     libp11_kit_internal_sources,\n                                     libp11_kit_sources,\n                                     c_args: libp11_kit_testable_c_args,\n                                     implicit_include_directories: false,\n                                     dependencies: [libp11_library_dep] + libffi_deps + dlopen_deps)\n\np11_kit_sources = [\n  'lists.c',\n  'p11-kit.c'\n]\n\nexecutable('p11-kit',\n           p11_kit_sources,\n           c_args: common_c_args,\n           dependencies: [libp11_tool_dep] + libffi_deps + dlopen_deps,\n           link_with: libp11_kit,\n           install: true)\n\nexecutable('p11-kit-remote',\n           'remote.c',\n           c_args: common_c_args,\n           dependencies: [libp11_tool_dep] + libffi_deps + dlopen_deps,\n           link_with: libp11_kit,\n           install: true,\n           install_dir: prefix / privatedir)\n\nexecutable('p11-kit-remote-testable',\n           'remote.c',\n           c_args: common_c_args,\n           dependencies: [libp11_tool_dep] + libffi_deps + dlopen_deps,\n           link_with: libp11_kit_testable)\n\nexecutable('p11-kit-server',\n           'server.c',\n           c_args: common_c_args + [\n             '-DP11_KIT_REMOTE=\"p11-kit-remote\"'\n           ],\n           dependencies: [libp11_tool_dep] + libsystemd_deps + libffi_deps + dlopen_deps,\n           implicit_include_directories: false,\n           link_with: libp11_kit,\n           install: true,\n           install_dir: prefix / privatedir)\n\nexecutable('p11-kit-server-testable',\n           'server.c',\n           c_args: common_c_args + [\n             '-DP11_KIT_REMOTE=\"p11-kit-remote-testable\"'\n           ],\n           implicit_include_directories: false,\n           dependencies: [libp11_tool_dep] + libsystemd_deps + libffi_deps + dlopen_deps,\n           link_with: libp11_kit_testable)\n\nif with_systemd\n  p11_kit_server_service_conf = configuration_data({\n    'bindir': prefix / bindir\n  })\n  p11_kit_server_service = configure_file(input: 'p11-kit-server.service.in',\n                                          output: '@BASENAME@',\n                                          configuration: p11_kit_server_service_conf)\n  install_data([p11_kit_server_service, 'p11-kit-server.socket'],\n               install_dir: systemduserunitdir)\nendif\n\n# Check if compilation succeeds with CRYPTOKI_GNU=1\n\npkcs11_gnu_headers = [\n  'iter.h',\n  'pin.h',\n  'uri.h'\n]\n\ngnu_h_gen = generator(find_program('gen-pkcs11-gnu.sh'),\n                      output: 'pkcs11-gnu-@BASENAME@.h',\n                      arguments: ['@INPUT@', '@OUTPUT@'])\n\ngnu_h = gnu_h_gen.process(pkcs11_gnu_headers)\n\nstatic_library('p11-kit-pkcs11-gnu',\n               gnu_h,\n               'pkcs11-gnu.c',\n               include_directories: [configinc, commoninc])\n\n# Tests ----------------------------------------------------------------\n\np11_kit_tests = [\n  'test-progname',\n  'test-util',\n  'test-conf',\n  'test-uri',\n  'test-pin',\n  'test-init',\n  'test-modules',\n  'test-deprecated',\n  'test-proxy',\n  'test-iter',\n  'test-rpc',\n  'test-virtual',\n  'test-managed',\n  'test-log',\n  'test-filter',\n  'test-transport'\n]\n\nif host_system != 'windows'\n  p11_kit_tests += 'test-server'\nendif\n\nforeach name : p11_kit_tests\n  t = executable(name, '@0@.c'.format(name),\n                 c_args: tests_c_args + libp11_kit_testable_c_args,\n                 include_directories: [configinc, commoninc],\n                 dependencies: [libp11_test_dep] + libffi_deps + dlopen_deps,\n                 link_with: libp11_kit_testable)\n  test(name, t)\nendforeach\n\np11_kit_progs = [\n  'print-messages',\n  'frob-setuid'\n]\n\nforeach name : p11_kit_progs\n  t = executable(name, '@0@.c'.format(name),\n                 c_args: tests_c_args,\n                 include_directories: [configinc, commoninc],\n                 dependencies: [libp11_test_dep] + libffi_deps + dlopen_deps,\n                 link_with: libp11_kit_testable)\nendforeach\n\np11_kit_tests_env = environment()\np11_kit_tests_env.set('abs_top_builddir', top_build_dir)\np11_kit_tests_env.set('P11_MODULE_PATH', meson.current_build_dir())\n\nif host_system != 'windows'\n  test('test-messages.sh',\n       find_program('test-messages.sh'),\n       env: p11_kit_tests_env)\n\n  test('test-server.sh',\n       find_program('test-server.sh'),\n       env: p11_kit_tests_env)\nendif\n\nmock_sources = {\n  'mock-one': ['mock-module-ep.c'],\n  'mock-two': ['mock-module-ep2.c'],\n  'mock-three': ['mock-module-ep.c'],\n  'mock-four': ['mock-module-ep.c'],\n  'mock-five': ['mock-module-ep3.c'],\n  'mock-seven': ['mock-module-ep5.c'],\n  'mock-eight': ['mock-module-ep6.c'],\n  'mock-nine': ['mock-module-ep7.c']\n}\n\nif host_system != 'windows'\n  mock_sources += {'mock-six': ['mock-module-ep4.c']}\nendif\n\nforeach name, sources : mock_sources\n  shared_module(name,\n                sources,\n                name_prefix: '',\n                link_args: p11_module_ldflags,\n                link_depends: [p11_module_symbol_map,\n                               p11_module_symbol_def],\n                vs_module_defs: p11_module_symbol_def,\n                dependencies: [libp11_test_dep])\nendforeach\n\np11_kit_pc_variables = [\n  'p11_module_configs=@0@'.format(prefix / p11_package_config_modules),\n  'p11_module_path=@0@'.format(prefix / p11_module_path),\n  'proxy_module=@0@/p11-kit-proxy.so'.format(prefix / libdir),\n  'p11_system_config_modules=@0@'.format(prefix / p11_package_config_modules)\n]\n\nif trust_paths != ''\n  p11_kit_pc_variables += [\n    'p11_trust_paths=@0@'.format(trust_paths)\n  ]\nendif\n\npkg.generate(libraries: libp11_kit,\n             filebase: 'p11-kit-1',\n             name: 'p11-kit',\n             description: 'Library and proxy module for properly loading and sharing PKCS#11 modules.',\n             subdirs: 'p11-kit-1',\n             variables: p11_kit_pc_variables)\n\npkcs11_conf_example_conf = configuration_data({\n  'p11_system_config_file': prefix / p11_system_config_file,\n  'p11_user_config': p11_user_config\n})\npkcs11_conf_example = configure_file(input: 'pkcs11.conf.example.in',\n                                     output: '@BASENAME@',\n                                     configuration: pkcs11_conf_example_conf)\ninstall_data(pkcs11_conf_example,\n             install_dir: prefix / p11_system_config)\n",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/meson.build": "libtrust_data_sources = [\n  'asn1.c',\n  'base64.c',\n  'pem.c',\n  'oid.c',\n  'utf8.c',\n  'x509.c'\n]\n\nasn_sources = [\n  'basic.asn',\n  'pkix.asn',\n  'openssl.asn'\n]\n\nasn_h_gen = generator(asn1Parser,\n                      output: '@BASENAME@.h',\n                      arguments: ['-o', '@OUTPUT@', '@INPUT@'])\nasn_h = asn_h_gen.process(asn_sources)\n\nlibtrust_data = static_library('libtrust-data',\n                               asn_h,\n                               libtrust_data_sources,\n                               include_directories: [configinc, commoninc],\n                               dependencies: libtasn1_deps)\n\nlibtrust_sources = [\n  'builder.c',\n  'digest.c',\n  'index.c',\n  'parser.c',\n  'persist.c',\n  'module.c',\n  'save.c',\n  'session.c',\n  'token.c'\n]\n\ninstall_data('p11-kit-trust.module',\n             install_dir: prefix / p11_package_config_modules)\n\np11_kit_trust_c_args = [\n  '-DP11_DEFAULT_TRUST_PREFIX=\"@0@\"'.format(prefix / datadir),\n  '-DP11_SYSTEM_TRUST_PREFIX=\"@0@\"'.format(prefix / sysconfdir)\n]\n\nshared_module('p11-kit-trust',\n              libtrust_sources,\n              'module-init.c',\n              name_prefix: '',\n              c_args: p11_kit_trust_c_args,\n              dependencies: [libp11_library_dep] + libtasn1_deps,\n              link_args: p11_module_ldflags,\n              link_depends: [p11_module_symbol_map,\n                             p11_module_symbol_def],\n              link_with: libtrust_data,\n              vs_module_defs: p11_module_symbol_def,\n              install: true,\n              install_dir: prefix / p11_module_path)\n\nlibtrust_testable_c_args = [\n  '-DP11_DEFAULT_TRUST_PREFIX=\"@0@\"'.format(meson.current_build_dir() / 'default'),\n  '-DP11_SYSTEM_TRUST_PREFIX=\"@0@\"'.format(meson.current_build_dir() / 'system')\n]\n\nlibtrust_testable = static_library('libtrust-testable',\n                                   libtrust_sources,\n                                   include_directories: [configinc, commoninc],\n                                   c_args: libtrust_testable_c_args,\n                                   dependencies: libtasn1_deps)\n\ntrust_sources = [\n  'anchor.c',\n  'parser.c',\n  'persist.c',\n  'digest.c',\n  'dump.c',\n  'enumerate.c',\n  'extract.c',\n  'extract-jks.c',\n  'extract-edk2.c',\n  'extract-openssl.c',\n  'extract-pem.c',\n  'extract-cer.c',\n  'list.c',\n  'save.c',\n  'trust.c'\n]\n\nexecutable('trust',\n           asn_h,\n           trust_sources,\n           c_args: common_c_args,\n           link_with: libtrust_data,\n           dependencies: [libp11_kit_dep,\n                          libp11_tool_dep] + libffi_deps + dlopen_deps + libtasn1_deps,\n           install: true)\n\n# Tests ----------------------------------------------------------------\n\nlibtrust_test_sources = [\n  'test-trust.c',\n  'digest.c'\n]\n\nlibtrust_test = static_library('libtrust-test',\n                               libtrust_test_sources,\n                               include_directories: [configinc, commoninc])\n\ntrust_tests = [\n  'test-digest',\n  'test-asn1',\n  'test-base64',\n  'test-pem',\n  'test-oid',\n  'test-utf8',\n  'test-x509',\n  'test-persist',\n  'test-index',\n  'test-parser',\n  'test-builder',\n  'test-token',\n  'test-module',\n  'test-save',\n  'test-enumerate',\n  'test-cer',\n  'test-bundle',\n  'test-openssl',\n  'test-edk2',\n  'test-jks'\n]\n\nforeach name : trust_tests\n  t = executable(name, '@0@.c'.format(name),\n                 c_args: common_c_args + tests_c_args + libtrust_testable_c_args,\n                 dependencies: [libp11_kit_dep,\n                                libp11_library_dep,\n                                libp11_test_dep] + dlopen_deps,\n                 link_with: [libtrust_testable, libtrust_data, libtrust_test])\n  test(name, t)\nendforeach\n\ntrust_progs = [\n  'frob-pow',\n  'frob-token',\n  'frob-nss-trust',\n  'frob-cert',\n  'frob-bc',\n  'frob-ku',\n  'frob-eku',\n  'frob-ext',\n  'frob-oid'\n]\n\nforeach name : trust_progs\n  t = executable(name, '@0@.c'.format(name),\n                 c_args: tests_c_args,\n                 dependencies: [libp11_kit_dep,\n                                libp11_library_dep,\n                                libp11_test_dep] + libffi_deps + dlopen_deps,\n                 link_with: [libtrust_testable, libtrust_data, libtrust_test])\nendforeach\n",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/frob-multi-init.c": "/*\n * gcc -Wall -o frob-multi-init $(pkg-config p11-kit-1 --cflags --libs) -ldl frob-multi-init.c\n */\n\n#include <assert.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#include <p11-kit/p11-kit.h>\n\n#define TRUST_SO \"/usr/lib64/pkcs11/p11-kit-trust.so\"\n\nint\nmain (void)\n{\n\tCK_C_INITIALIZE_ARGS args =\n\t\t{ NULL, NULL, NULL, NULL, CKF_OS_LOCKING_OK, NULL, };\n\tCK_C_GetFunctionList C_GetFunctionList;\n\tCK_SESSION_HANDLE session;\n\tCK_FUNCTION_LIST *module;\n\tCK_SLOT_ID slots[8];\n\tCK_SESSION_INFO info;\n\tCK_ULONG count;\n\tCK_RV rv;\n\tvoid *dl;\n\n\tdl = dlopen (TRUST_SO, RTLD_LOCAL | RTLD_NOW);\n\tif (dl == NULL)\n\t\tfprintf (stderr, \"%s\\n\", dlerror());\n\tassert (dl != NULL);\n\n\tC_GetFunctionList = dlsym (dl, \"C_GetFunctionList\");\n\tassert (C_GetFunctionList != NULL);\n\n\trv = C_GetFunctionList (&module);\n\tassert (rv == CKR_OK);\n\tassert (module != NULL);\n\n\trv = module->C_Initialize (&args);\n\tassert (rv == CKR_OK);\n\n\tcount = 8;\n\trv = module->C_GetSlotList (CK_TRUE, slots, &count);\n\tassert (rv == CKR_OK);\n\tassert (count > 1);\n\n\trv = module->C_OpenSession (slots[0], CKF_SERIAL_SESSION, NULL, NULL, &session);\n\tassert (rv == CKR_OK);\n\n\trv = module->C_GetSessionInfo (session, &info);\n\tassert (rv == CKR_OK);\n\n\trv = p11_kit_initialize_registered ();\n\tassert (rv == CKR_OK);\n\n\trv = module->C_GetSessionInfo (session, &info);\n\tif (rv == CKR_OK) {\n\t\tprintf (\"no reinitialization bug\\n\");\n\t\treturn 0;\n\n\t} else if (rv == CKR_SESSION_HANDLE_INVALID) {\n\t\tprintf (\"reinitialization bug present\\n\");\n\t\treturn 1;\n\n\t} else {\n\t\tprintf (\"another error: %lu\\n\", rv);\n\t\treturn 1;\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/doc/manual/meson.build": "if get_option('gtk_doc')\n  ignore_headers = [\n    'private.h',\n    'pkcs11.h',\n    'conf.h',\n    'debug.h',\n    'dict.h',\n    'filter.h',\n    'log.h',\n    'mock.h',\n    'modules.h',\n    'pkcs11.h',\n    'pkcs11i.h',\n    'pkcs11x.h',\n    'private.h',\n    'client.h',\n    'proxy.h',\n    'rpc.h',\n    'rpc-message.h',\n    'util.h',\n    'virtual.h',\n    'virtual-fixed.h',\n    'array.h',\n    'compat.h'\n  ]\n\n  content_files = [\n    'p11-kit-config.xml',\n    'p11-kit-sharing.xml',\n    'p11-kit-devel.xml',\n    'p11-kit-proxy.xml',\n    'p11-kit-trust.xml',\n    'p11-kit-remoting.xml',\n    'p11-kit.xml',\n    'pkcs11.conf.xml',\n    'trust.xml',\n    'annotation-glossary.xml'\n  ]\n\n  configure_file(\n    input: 'version.xml.in',\n    output: '@BASENAME@',\n    configuration: {'VERSION': meson.project_version()})\n\n  configure_file(\n    input: 'userdir.xml.in',\n    output: '@BASENAME@',\n    configuration: {'p11_user_config': p11_user_config})\n\n  configure_file(\n    input: 'sysdir.xml.in',\n    output: '@BASENAME@',\n    configuration: {'p11_system_config': p11_system_config})\n\n  glib_prefix = dependency('glib-2.0').get_pkgconfig_variable('prefix')\n  fixxref_args = [\n    '--html-dir=' + (prefix / gnome.gtkdoc_html_dir(meson.project_name())),\n    '--extra-dir=' + (glib_prefix / gnome.gtkdoc_html_dir('glib')),\n  ]\n\n  gnome.gtkdoc('p11-kit',\n              main_xml: 'p11-kit-docs.xml',\n              namespace: 'p11_kit',\n              src_dir: 'p11-kit',\n              dependencies: libffi_deps + dlopen_deps,\n              scan_args: [\n                '--ignore-headers=' + ' '.join(ignore_headers),\n                '--rebuild-types',\n                '--deprecated-guards=\"P11_KIT_DISABLE_DEPRECATED\"'\n              ],\n              scanobjs_args: [\n                '--version'\n              ],\n              content_files: content_files,\n              fixxref_args: fixxref_args,\n              install: true)\nendif\n\nif get_option('man')\n  xsltproc = find_program('xsltproc')\n  xsltproc_xsl = 'http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl'\n  if run_command([xsltproc, '--nonet', xsltproc_xsl]).returncode() != 0\n    error('Docbook stylesheet for manpages is missing')\n  endif\n\n  xsltproc_flags = [\n    '--nonet',\n    '--stringparam', 'man.output.quietly', '1',\n    '--stringparam', 'funcsynopsis.style', 'ansi',\n    '--stringparam', 'man.th.extra1.suppress', '1',\n    '--stringparam', 'man.authors.section.enabled', '0',\n    '--stringparam', 'man.copyright.section.enabled', '0',\n    '--path', meson.current_build_dir(),\n  ]\n\n  man_pages = {\n    '1': ['trust'],\n    '5': ['pkcs11.conf'],\n    '8': ['p11-kit'],\n  }\n\n  foreach section, pages: man_pages\n    foreach page: pages\n      man_src = '@0@.xml'.format(page)\n      man_dst = '@0@.@1@'.format(page, section)\n      man_section = 'man@0@'.format(section)\n      custom_target(man_dst,\n                    command: [\n                      xsltproc,\n                      xsltproc_flags,\n                      '-o', '@OUTPUT@',\n                      xsltproc_xsl,\n                      '@INPUT@',\n                    ],\n                    input: man_src,\n                    output: man_dst,\n                    install: true,\n                    install_dir: join_paths(mandir, man_section),\n                    build_be_default: true)\n    endforeach\n  endforeach\nendif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/testing-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/testing-server.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/redhat-newca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/verisign-v1.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/cacert-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/distant-end-date.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/entrust-invalid.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/self-server.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/self-signed-with-eku.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/self-signed-with-ku.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/build/certs/cacert3.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/testing-server.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/verisign-v1.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/cacert-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/duplicated1.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/redhat-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/multiple.jks",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/self-signed-with-eku.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/multiple.edk2",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/duplicated2.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/duplicated.jks",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/self-signed-with-ku.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/fixtures/cacert3.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/input/cacert-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/input/anchors/testing-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/input/anchors/cacert3.der",
        "/tmp/vanessa/spack-stage/spack-stage-p11-kit-0.23.19-xm4te42wqo7v6vj6lm4yg2ihvrdllllj/spack-src/trust/input/blacklist/self-server.der"
    ],
    "total_files": 446
}