{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-billiard-3.6.0.0-3tkgnuuk7cep4yqueiw36dnud4c7jhjj/spack-src/billiard/util.py": "#\n# Module providing various facilities to other parts of the package\n#\n# billiard/util.py\n#\n# Copyright (c) 2006-2008, R Oudkerk --- see COPYING.txt\n# Licensed to PSF under a Contributor Agreement.\n#\nfrom __future__ import absolute_import\n\nimport sys\nimport errno\nimport functools\nimport atexit\n\ntry:\n    import cffi\nexcept ImportError:\n    import ctypes\n\ntry:\n    from subprocess import _args_from_interpreter_flags  # noqa\nexcept ImportError:  # pragma: no cover\n    def _args_from_interpreter_flags():  # noqa\n        \"\"\"Return a list of command-line arguments reproducing the current\n        settings in sys.flags and sys.warnoptions.\"\"\"\n        flag_opt_map = {\n            'debug': 'd',\n            'optimize': 'O',\n            'dont_write_bytecode': 'B',\n            'no_user_site': 's',\n            'no_site': 'S',\n            'ignore_environment': 'E',\n            'verbose': 'v',\n            'bytes_warning': 'b',\n            'hash_randomization': 'R',\n            'py3k_warning': '3',\n        }\n        args = []\n        for flag, opt in flag_opt_map.items():\n            v = getattr(sys.flags, flag)\n            if v > 0:\n                args.append('-' + opt * v)\n        for opt in sys.warnoptions:\n            args.append('-W' + opt)\n        return args\n\nfrom multiprocessing.util import (  # noqa\n    _afterfork_registry,\n    _afterfork_counter,\n    _exit_function,\n    _finalizer_registry,\n    _finalizer_counter,\n    Finalize,\n    ForkAwareLocal,\n    ForkAwareThreadLock,\n    get_temp_dir,\n    is_exiting,\n    register_after_fork,\n    _run_after_forkers,\n    _run_finalizers,\n)\n\nfrom .compat import get_errno\n\n__all__ = [\n    'sub_debug', 'debug', 'info', 'sub_warning', 'get_logger',\n    'log_to_stderr', 'get_temp_dir', 'register_after_fork',\n    'is_exiting', 'Finalize', 'ForkAwareThreadLock', 'ForkAwareLocal',\n    'SUBDEBUG', 'SUBWARNING',\n]\n\n\n# Constants from prctl.h\nPR_GET_PDEATHSIG = 2\nPR_SET_PDEATHSIG = 1\n\n#\n# Logging\n#\n\nNOTSET = 0\nSUBDEBUG = 5\nDEBUG = 10\nINFO = 20\nSUBWARNING = 25\nERROR = 40\n\nLOGGER_NAME = 'multiprocessing'\nDEFAULT_LOGGING_FORMAT = '[%(levelname)s/%(processName)s] %(message)s'\n\n_logger = None\n_log_to_stderr = False\n\n\ndef sub_debug(msg, *args, **kwargs):\n    if _logger:\n        _logger.log(SUBDEBUG, msg, *args, **kwargs)\n\n\ndef debug(msg, *args, **kwargs):\n    if _logger:\n        _logger.log(DEBUG, msg, *args, **kwargs)\n\n\ndef info(msg, *args, **kwargs):\n    if _logger:\n        _logger.log(INFO, msg, *args, **kwargs)\n\n\ndef sub_warning(msg, *args, **kwargs):\n    if _logger:\n        _logger.log(SUBWARNING, msg, *args, **kwargs)\n\n\ndef error(msg, *args, **kwargs):\n    if _logger:\n        _logger.log(ERROR, msg, *args, **kwargs)\n\n\ndef get_logger():\n    '''\n    Returns logger used by multiprocessing\n    '''\n    global _logger\n    import logging\n\n    logging._acquireLock()\n    try:\n        if not _logger:\n\n            _logger = logging.getLogger(LOGGER_NAME)\n            _logger.propagate = 0\n            logging.addLevelName(SUBDEBUG, 'SUBDEBUG')\n            logging.addLevelName(SUBWARNING, 'SUBWARNING')\n\n            # XXX multiprocessing should cleanup before logging\n            if hasattr(atexit, 'unregister'):\n                atexit.unregister(_exit_function)\n                atexit.register(_exit_function)\n            else:\n                atexit._exithandlers.remove((_exit_function, (), {}))\n                atexit._exithandlers.append((_exit_function, (), {}))\n    finally:\n        logging._releaseLock()\n\n    return _logger\n\n\ndef log_to_stderr(level=None):\n    '''\n    Turn on logging and add a handler which prints to stderr\n    '''\n    global _log_to_stderr\n    import logging\n\n    logger = get_logger()\n    formatter = logging.Formatter(DEFAULT_LOGGING_FORMAT)\n    handler = logging.StreamHandler()\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n    if level:\n        logger.setLevel(level)\n    _log_to_stderr = True\n    return _logger\n\n\ndef get_pdeathsig():\n    \"\"\"\n    Return the current value of the parent process death signal\n    \"\"\"\n    if not sys.platform.startswith('linux'):\n        # currently we support only linux platform.\n        raise OSError()\n    try:\n        if 'cffi' in sys.modules:\n            ffi = cffi.FFI()\n            ffi.cdef(\"int prctl (int __option, ...);\")\n            arg = ffi.new(\"int *\")\n            C = ffi.dlopen(None)\n            C.prctl(PR_GET_PDEATHSIG, arg)\n            return arg[0]\n        else:\n            sig = ctypes.c_int()\n            libc = ctypes.cdll.LoadLibrary(\"libc.so.6\")\n            libc.prctl(PR_GET_PDEATHSIG, ctypes.byref(sig))\n            return sig.value\n    except Exception:\n        raise OSError()\n\n\ndef set_pdeathsig(sig):\n    \"\"\"\n    Set the parent process death signal of the calling process to sig\n    (either a signal value in the range 1..maxsig, or 0 to clear).\n    This is the signal that the calling process will get when its parent dies.\n    This value is cleared for the child of a fork(2) and\n    (since Linux 2.4.36 / 2.6.23) when executing a set-user-ID or set-group-ID binary.\n    \"\"\"\n    if not sys.platform.startswith('linux'):\n        # currently we support only linux platform.\n        raise OSError()\n    try:\n        if 'cffi' in sys.modules:\n            ffi = cffi.FFI()\n            ffi.cdef(\"int prctl (int __option, ...);\")\n            C = ffi.dlopen(None)\n            C.prctl(PR_SET_PDEATHSIG, ffi.cast(\"int\", sig))\n        else:\n            libc = ctypes.cdll.LoadLibrary(\"libc.so.6\")\n            libc.prctl(PR_SET_PDEATHSIG, sig)\n    except Exception:\n        raise OSError()\n\ndef _eintr_retry(func):\n    '''\n    Automatic retry after EINTR.\n    '''\n\n    @functools.wraps(func)\n    def wrapped(*args, **kwargs):\n        while 1:\n            try:\n                return func(*args, **kwargs)\n            except OSError as exc:\n                if get_errno(exc) != errno.EINTR:\n                    raise\n    return wrapped\n"
    },
    "skipped": [],
    "total_files": 70
}