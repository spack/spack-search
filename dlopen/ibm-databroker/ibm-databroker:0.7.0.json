{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.7.0-li2eos3bvsdvwot5tfzvxjp74irwqffp/spack-src/src/lib/backend.c": "/*\n * Copyright \u00a9 2018-2020 IBM Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"logutil.h\"\n#include \"backend.h\"\n#include \"common/utility.h\"\n\n#include <stddef.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n#ifndef DEFAULT_BE\n#define DEFAULT_BE_LIB \"libdbbe_redis.so\"\n#endif\n\n\nstatic dbrBackend_t *gBE = NULL;\n\ndbrBackend_t* dbrlib_backend_get_handle(void)\n{\n  // check backend context and initialize\n  dbrBackend_t *be = NULL;\n  if( gBE == NULL )\n  {\n    char *to_str = dbBE_Extract_env( DBR_BACKEND_ENV, DEFAULT_BE_LIB );\n    if( to_str == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to get backend environment variable.\\n\" );\n      goto error;\n    }\n\n    be = (dbrBackend_t*)calloc( 1, sizeof( dbrBackend_t ));\n    if( be == NULL )\n      return NULL;\n\n    if( (be->_library = dlopen( to_str, RTLD_LAZY )) == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to load Backend Library %s. Looked for in %s\\n\", to_str, getenv(\"LD_LIBRARY_PATH\") );\n      goto error;\n    }\n    dlerror();\n    if( (be->_api = dlsym( be->_library, \"dbBE\" )) == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: symbol 'dbBE' not defined in %s\\n\", to_str );\n      goto error;\n    }\n\n    be->_context = be->_api->initialize( );\n    gBE = be;\n  }\n  return gBE;\n\nerror:\n  if( be != NULL )\n  {\n    if( be->_api != NULL ) be->_api = NULL;\n    if( be->_library != NULL )\n    {\n      dlclose( be->_library );\n      be->_library = NULL;\n    }\n    free( be );\n    be = NULL;\n    gBE = NULL;\n  }\n  return (dbBE_Handle_t)be;\n}\n\nint dbrlib_backend_delete( dbrBackend_t *be )\n{\n  if( be == NULL )\n    return -EINVAL;\n\n  int rc = 0;\n  if( be->_api != NULL )\n    rc = be->_api->exit( be->_context );\n\n  if( be->_library != NULL )\n    rc = dlclose( be->_library );\n\n  free( be );\n  gBE = NULL;\n  return rc;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.7.0-li2eos3bvsdvwot5tfzvxjp74irwqffp/spack-src/src/util/dbrUtils.c": "/*\n * Copyright \u00a9 2018-2020 IBM Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n#include \"logutil.h\"\n#include \"libdatabroker.h\"\n#include \"libdatabroker_int.h\"\n#include \"libdbrAPI.h\"\n\n#include \"lib/sge.h\"\n#include \"lib/backend.h\"\n\n#ifdef __APPLE__\n#include <stdlib.h>\n#else\n#include <stdlib.h>\n#include <malloc.h>\n#endif\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <pthread.h>\n#include <dlfcn.h>\n\nstatic dbrMain_context_t *gMain_context = NULL;\nstatic pthread_mutex_t gMain_creation_lock = PTHREAD_MUTEX_INITIALIZER;\n\ndbrMain_context_t* dbrCheckCreateMainCTX(void)\n{\n  pthread_mutex_lock( &gMain_creation_lock );\n  if( gMain_context == NULL )\n  {\n    gMain_context = (dbrMain_context_t*)malloc( sizeof( dbrMain_context_t ) );\n    if( gMain_context == NULL )\n    {\n      errno = ENOMEM;\n      pthread_mutex_unlock( &gMain_creation_lock );\n      return NULL;\n    }\n    memset( gMain_context, 0, sizeof( dbrMain_context_t ) );\n\n    char *to_str = getenv(DBR_TIMEOUT_ENV);\n    if( to_str == NULL )\n      gMain_context->_config._timeout_sec = DBR_TIMEOUT_DEFAULT;\n    else\n    {\n      gMain_context->_config._timeout_sec = strtol( to_str, NULL, 10 );\n      if(( gMain_context->_config._timeout_sec == LONG_MIN ) || ( gMain_context->_config._timeout_sec == LONG_MAX ))\n        gMain_context->_config._timeout_sec = DBR_TIMEOUT_DEFAULT;\n    }\n    if( gMain_context->_config._timeout_sec == 0 )\n      gMain_context->_config._timeout_sec = INT_MAX;\n\n    gMain_context->_tmp_testkey_buf = malloc( DBR_TMP_BUFFER_LEN );\n    if( gMain_context->_tmp_testkey_buf == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to allocate tmp key buffer.\\n\" );\n      free( gMain_context );\n      gMain_context = NULL;\n      pthread_mutex_unlock( &gMain_creation_lock );\n      return NULL;\n    }\n\n    gMain_context->_be_ctx = dbrlib_backend_get_handle();\n    if( gMain_context->_be_ctx == NULL )\n    {\n      LOG( DBG_ERR, stderr, \"libdatabroker: failed to create/connect backend.\\n\" );\n      pthread_mutex_unlock( &gMain_creation_lock );\n      dbrMain_exit();\n      return NULL;\n    }\n\n#ifdef DBR_DATA_ADAPTERS\n    // get plugin location from env variable\n    to_str = getenv(DBR_PLUGIN_ENV);\n    if( to_str == NULL )\n      gMain_context->_data_adapter = NULL;\n    else\n    {\n      // dlopen and load adapter symbol\n      if( (gMain_context->_da_library = dlopen( to_str, RTLD_LAZY )) == NULL )\n      {\n        LOG( DBG_ERR, stderr, \"libdatabroker: failed to load Data Adapter library %s. Looked for in %s\\n\", to_str, getenv(\"LD_LIBRARY_PATH\") );\n        pthread_mutex_unlock( &gMain_creation_lock );\n        dbrMain_exit();\n        return NULL;\n      }\n      dlerror();\n      if( (gMain_context->_data_adapter = dlsym( gMain_context->_da_library, \"dbrDA\" )) == NULL )\n      {\n        LOG( DBG_ERR, stderr, \"libdatabroker: symbol 'dbrDA' not defined in %s\\n\", to_str );\n        pthread_mutex_unlock( &gMain_creation_lock );\n        dbrMain_exit();\n        return NULL;\n      }\n    }\n#endif\n    pthread_mutex_init( &gMain_context->_biglock, NULL );\n  }\n\n  pthread_mutex_unlock( &gMain_creation_lock );\n  return gMain_context;\n}\n\nint dbrMain_exit(void)\n{\n  pthread_mutex_lock( &gMain_creation_lock );\n  if( gMain_context == NULL )\n  {\n    pthread_mutex_unlock( &gMain_creation_lock );\n    return 0;\n  }\n\n  int rc = dbrlib_backend_delete( gMain_context->_be_ctx );\n\n  if( gMain_context->_tmp_testkey_buf != NULL )\n  {\n    LOG( DBG_VERBOSE, stdout, \"Cleaning up temporary buffer\\n\");\n    memset( gMain_context->_tmp_testkey_buf, 0, DBR_TMP_BUFFER_LEN );\n    free( gMain_context->_tmp_testkey_buf );\n    gMain_context->_tmp_testkey_buf = NULL;\n  }\n\n#ifdef DBR_DATA_ADAPTERS\n  if( gMain_context->_da_library != NULL )\n  {\n    dlclose( gMain_context->_da_library );\n    gMain_context->_data_adapter = NULL;\n  }\n#endif\n\n  pthread_mutex_destroy( &gMain_context->_biglock );\n  memset( gMain_context, 0, sizeof( dbrMain_context_t ) );\n  free( gMain_context );\n  gMain_context = NULL;\n\n  pthread_mutex_unlock( &gMain_creation_lock );\n  return rc;\n}\n\n\nDBR_Tag_t dbrTag_get( dbrMain_context_t *ctx )\n{\n  if( ctx == NULL )\n    return DB_TAG_ERROR;\n\n  typeof(ctx->_tag_head) t = ctx->_tag_head;\n\n  // hop through the work entries to check for available tags\n  while( ctx->_cs_wq[ t ] != NULL )\n  {\n    // while we're at it: clean up any closed request entries\n    // !! make sure the whole chain is in closed state !!\n\n    dbrRequestContext_t *rctx = ctx->_cs_wq[ t ];\n    dbrRequest_status_t st = rctx->_status;\n    while(( st == dbrSTATUS_CLOSED ) && ( rctx->_next != NULL ))\n    {\n      rctx = rctx->_next;\n      st = rctx->_status;\n    }\n\n    if( st == dbrSTATUS_CLOSED )\n    {\n      dbrRequestContext_t *r = ctx->_cs_wq[ t ];\n      memset( r, 0, sizeof( dbrRequestContext_t ) + r->_req._sge_count * sizeof(dbBE_sge_t) );\n      free( r );\n      ctx->_cs_wq[ t ] = NULL;\n      break;\n    }\n\n    t = ( t + 1 ) % dbrMAX_TAGS;\n    if( t == ctx->_tag_head )\n    {\n      LOG( DBG_ERR, stderr, \"No more tags available for async op\\n\" );\n      return DB_TAG_ERROR;\n    }\n  }\n\n  ctx->_tag_head = ( t + 1 ) % dbrMAX_TAGS;\n\n#ifdef DBR_INTTAG\n//  LOG( DBG_INFO, stdout, \"Returning Tag: %d\\n\", t );\n  return (DBR_Tag_t)t;\n#else\n  // needs to point into the array!\n  // -> otherwise there is no index calculation afterwards\n  return (DBR_Tag_t)&ctx->_cs_wq[ t ];\n#endif\n}\n\nDBR_Errorcode_t dbrValidateTag( dbrRequestContext_t *rctx, DBR_Tag_t req_tag )\n{\n#ifdef DBR_INTTAG\n  if(( req_tag >= 0 ) && ( req_tag < dbrMAX_TAGS ))\n#else\n  if(( req_tag != NULL ) && ( req_tag != DB_TAG_ERROR ))\n#endif\n    return DBR_SUCCESS;\n  else\n    return DBR_ERR_TAGERROR;\n}\n\n\nvoid __attribute__ ((destructor)) unload( void )\n{\n  LOG( DBG_VERBOSE, stdout, \"Unloading library\\n\");\n  dbrMain_exit();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.7.0-li2eos3bvsdvwot5tfzvxjp74irwqffp/spack-src/bindings/python/dbr_module/dbr.py": " #\n # Copyright (C) 2018-2020 IBM Corporation\n #\n # Licensed under the Apache License, Version 2.0 (the \"License\");\n # you may not use this file except in compliance with the License.\n # You may obtain a copy of the License at\n #\n #    http://www.apache.org/licenses/LICENSE-2.0\n #\n # Unless required by applicable law or agreed to in writing, software\n # distributed under the License is distributed on an \"AS IS\" BASIS,\n # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n # See the License for the specific language governing permissions and\n # limitations under the License.\n #\nfrom _dbr_interface import ffi\nlibtransport = ffi.dlopen(\"libdbbe_transport.so\", ffi.RTLD_GLOBAL|ffi.RTLD_NOW)\nlibbackend = ffi.dlopen(\"libdbbe_redis.so\", ffi.RTLD_GLOBAL|ffi.RTLD_NOW)\nlibdatabroker = ffi.dlopen(\"libdatabroker.so\")\nimport _cffi_backend\nfrom dbr_module.dbr_errorcodes import Errors\nimport pickle\n\nERRORTABLE = Errors()\n\n# Copy for direct access\nDBR_SUCCESS = ERRORTABLE.DBR_SUCCESS # no error, clean result, operation successful\nDBR_ERR_GENERIC = ERRORTABLE.DBR_ERR_GENERIC # a general or unknown error has occurred\nDBR_ERR_INVALID = ERRORTABLE.DBR_ERR_INVALID # an invalid parameter was passed into a function or other general error\nDBR_ERR_HANDLE = ERRORTABLE.DBR_ERR_HANDLE # an invalid handle was encountered\nDBR_ERR_INPROGRESS = ERRORTABLE.DBR_ERR_INPROGRESS # a request is still in progress, check again later\nDBR_ERR_TIMEOUT = ERRORTABLE.DBR_ERR_TIMEOUT # a timeout occurred\nDBR_ERR_UBUFFER = ERRORTABLE.DBR_ERR_UBUFFER # provided user buffer problem (too small, not available)\nDBR_ERR_UNAVAIL = ERRORTABLE.DBR_ERR_UNAVAIL # the requested tuple or namespace is not available in the backing storage\nDBR_ERR_EXISTS = ERRORTABLE.DBR_ERR_EXISTS # Entry already exists\nDBR_ERR_NSBUSY = ERRORTABLE.DBR_ERR_NSBUSY # there are still clients attached to a namespace\nDBR_ERR_NSINVAL = ERRORTABLE.DBR_ERR_NSINVAL # invalid name space\nDBR_ERR_NOMEMORY = ERRORTABLE.DBR_ERR_NOMEMORY # the amount of memory or storage was insufficient to\nDBR_ERR_TAGERROR = ERRORTABLE.DBR_ERR_TAGERROR # the returned tag is an error\nDBR_ERR_NOFILE = ERRORTABLE.DBR_ERR_NOFILE # a file was not found\nDBR_ERR_NOAUTH = ERRORTABLE.DBR_ERR_NOAUTH # access authorization required or failed\nDBR_ERR_NOCONNECT = ERRORTABLE.DBR_ERR_NOCONNECT # connection to a storage backend failed\nDBR_ERR_CANCELLED = ERRORTABLE.DBR_ERR_CANCELLED # operation was cancelled\nDBR_ERR_NOTIMPL = ERRORTABLE.DBR_ERR_NOTIMPL # operation not implemented\nDBR_ERR_INVALIDOP = ERRORTABLE.DBR_ERR_INVALIDOP # invalid operation\nDBR_ERR_BE_POST = ERRORTABLE.DBR_ERR_BE_POST #  posting request to back-end failed\nDBR_ERR_BE_GENERAL = ERRORTABLE.DBR_ERR_BE_GENERAL # Unspecified back-end error\nDBR_ERR_ITERATOR = ERRORTABLE.DBR_ERR_ITERATOR\nDBR_ERR_PLUGIN = ERRORTABLE.DBR_ERR_PLUGIN\nDBR_ERR_MAXERROR = ERRORTABLE.DBR_ERR_MAXERROR\n\n# Tuple persist level\nDBR_PERST_VOLATILE_SIMPLE = libdatabroker.DBR_PERST_VOLATILE_SIMPLE\nDBR_PERST_VOLATILE_FT = libdatabroker.DBR_PERST_VOLATILE_FT\nDBR_PERST_TEMPORARY_SIMPLE = libdatabroker.DBR_PERST_TEMPORARY_SIMPLE\nDBR_PERST_TEMPORARY_FT = libdatabroker.DBR_PERST_TEMPORARY_FT\nDBR_PERST_PERMANENT_SIMPLE = libdatabroker.DBR_PERST_PERMANENT_SIMPLE\nDBR_PERST_PERMANENT_FT = libdatabroker.DBR_PERST_PERMANENT_FT\nDBR_PERST_MAX = libdatabroker.DBR_PERST_MAX\n\nDBR_FLAGS_NONE = libdatabroker.DBR_FLAGS_NONE\nDBR_FLAGS_NOWAIT = libdatabroker.DBR_FLAGS_NOWAIT\nDBR_FLAGS_MAX = libdatabroker.DBR_FLAGS_MAX\n\nDBR_GROUP_LIST_EMPTY = '0' #libdatabroker.DBR_GROUP_LIST_EMPTY\nDBR_GROUP_EMPTY = '0'      #libdatabroker.DBR_GROUP_EMPTY\nDBR_ITERATOR_NEW = ffi.NULL \nDBR_ITERATOR_DONE = ffi.NULL\n\n# Mask\nDBR_STATE_MASK_ALL = libdatabroker.DBR_STATE_MASK_ALL\n\n\n# Utility\ndef getErrorCode(error_code):\n    return ERRORTABLE.getErrorCode(error_code).decode()\n\ndef getErrorMessage(error_code):\n    if error_code < DBR_ERR_MAXERROR:\n        return ERRORTABLE.getErrorMessage(error_code).decode()\n    return \"Unknown Error\"\n\ndef createBuf(buftype, bufsize):\n    retval = ffi.buffer(ffi.new(buftype, bufsize))\n    return retval\n\n# Data Broker\ndef create(dbrname, level, groups):\n    dbr_hdl = libdatabroker.dbrCreate(dbrname.encode(), level, groups)\n    return dbr_hdl\n\ndef attach(dbr_name):\n    dbr_hdl = libdatabroker.dbrAttach(dbr_name.encode())\n    return dbr_hdl\n\ndef delete(dbr_name):\n    retval = libdatabroker.dbrDelete(dbr_name.encode())\n    return retval\n\ndef detach(dbr_handle):\n    retval = libdatabroker.dbrDetach(dbr_handle)\n    return retval\n\ndef query(dbr_handle, dbr_state, state_mask):\n    retval =  libdatabroker.dbrQuery(dbr_handle, dbr_state, state_mask)\n    return retval\n\ndef addUnits(dbr_handle, units):\n    retval = libdatabroker.dbrAddUnits(dbr_handle, units)\n    return retval \n\ndef removeUnits(dbr_handle, units):\n    retval = libdatabroker.dbrRemoveUnits(dbr_handle, units)\n    return retval\n\ndef put(dbr_hdl, tuple_val, tuple_name, group):\n    dumpedtuple = None\n    if isinstance(tuple_val, str):\n        dumpedtuple = tuple_val.encode()\n    else:\n        dumpedtuple = pickle.dumps(tuple_val)\n    size = len(dumpedtuple)\n    retval = libdatabroker.dbrPut(dbr_hdl, dumpedtuple, size, tuple_name.encode(), group.encode())\n    return retval\n\ndef read(dbr_hdl, tuple_name, match_template, group, flag, buffer_size=None):\n    out_size = ffi.new('int64_t*')\n    if buffer_size is None :\n        buffer_size=[256]\n    out_size[0] = buffer_size[0]\n    out_buffer = createBuf('char[]', out_size[0])\n    retval = libdatabroker.dbrRead(dbr_hdl, ffi.from_buffer(out_buffer), out_size, tuple_name.encode(), match_template.encode(), group.encode(), flag)\n    if retval != 0:\n        return None, retval\n    buffer_size[0] = out_size[0]\n    result = None\n    try:\n        result = pickle.loads(out_buffer[:])\n    except:\n        result = out_buffer[:].decode()\n    return result, retval\n\ndef get(dbr_hdl, tuple_name, match_template, group, flag, buffer_size=None):\n    out_size = ffi.new('int64_t*')\n    if buffer_size is None :\n        buffer_size=[128]\n    out_size[0] = buffer_size[0]\n    out_buffer = createBuf('char[]', out_size[0])\n    retval = libdatabroker.dbrGet(dbr_hdl, ffi.from_buffer(out_buffer), out_size, tuple_name.encode(), match_template.encode(), group.encode(), flag)\n    if retval != 0:\n        return None, retval\n    buffer_size[0] = out_size[0]\n    result = None\n    try:\n        result = pickle.loads(out_buffer[:])\n    except:\n        result = out_buffer[:].decode()\n    return result, retval\n    #return pickle.loads(out_buffer[:]), retval\n\ndef readA(dbr_hdl, tuple_name, match_template, group, flag=DBR_FLAGS_NONE, buffer_size=None):\n    out_size = ffi.new('int64_t*')\n    if buffer_size is None :\n        buffer_size=[128]\n    out_size[0] = buffer_size[0]\n    out_buffer = createBuf('char[]', out_size[0])\n    tag = libdatabroker.dbrReadA(dbr_hdl, ffi.from_buffer(out_buffer), out_size, tuple_name.encode(), match_template.encode(), group.encode(), flags)\n    buffer_size[0] = out_size[0]\n    return tag, out_buffer \n\ndef putA(dbr_hdl, tuple_val, tuple_name, group):\n    #dumpedtuple = pickle.dumps(tuple_val)\n    dumpedtuple = None\n    if isinstance(tuple_val, str):\n        dumpedtuple = tuple_val.encode()\n    else:\n        dumpedtuple = pickle.dumps(tuple_val)\n    size = len(dumpedtuple)\n    tag = libdatabroker.dbrPutA(dbr_hdl, dumpedtuple, size, tuple_name.encode(), group.encode())\n    return tag\n\ndef getA(dbr_hdl, tuple_name, match_template, group, flag=DBR_FLAGS_NONE, buffer_size=None):\n    out_size = ffi.new('int64_t*')\n    if buffer_size is None :\n        buffer_size=[128]\n    out_size[0] = buffer_size[0]\n    out_buffer = createBuf('char[]', out_size[0])\n    tag = libdatabroker.dbrGetA(dbr_hdl, ffi.from_buffer(out_buffer), out_size, tuple_name.encode(), match_template.encode(), group.encode(), flags)\n    buffer_size[0] = out_size[0]\n    return tag, out_buffer # pickle.loads(out_buffer[:]) \n\ndef decodeTuple(tuple_buffer):\n    result = None\n    try:\n        result = pickle.loads(tuple_buffer[:])\n    except:\n        result = tuple_buffer[:].decode()\n    return result\n    #return pickle.loads(tuple_buffer[:])\n\ndef testKey(dbr_hdl, tuple_name):\n    retval = libdatabroker.dbrTestKey(dbr_hdl, tuple_name)\n    return retval\n\ndef directory(dbr_hdl, match_template, group, count, size):\n    tbuf = createBuf('char[]',size)\n    rsize = ffi.new('int64_t*')\n    retval = libdatabroker.dbrDirectory(dbr_hdl, match_template.encode(), group.encode(), count, ffi.from_buffer(tbuf), ffi.cast('const size_t',size), rsize)\n    result_buffer=(tbuf[0:rsize[0]].decode().split('\\n'))\n    return result_buffer, rsize[0], retval\n\ndef move(src_DBRHandle, src_group, tuple_name, match_template, dest_DBRHandle, dest_group):\n    retval = libdatabroker.dbrMove(src_DBRHandle, src_group.encode(), tuple_name.encode(), match_template.encode(), dest_DBRHandle, dest_group.encode())\n    return retval\n\ndef remove(dbr_hdl, group, tuple_name, match_template):\n    retval = libdatabroker.dbrRemove(dbr_hdl, group.encode(), tuple_name.encode(), match_template.encode())\n    return retval\n\ndef test(tag):\n    retval = libdatabroker.dbrTest(tag)\n    return retval\n\ndef cancel(tag):\n    retval = libdatabroker.dbrCancel(tag)\n    return retval\n\ndef iterator(dbr_hdl, iterator, group, match_template):\n    out_buffer = createBuf('char[]', libdatabroker.DBR_MAX_KEY_LEN)\n    it = libdatabroker.dbrIterator(dbr_hdl, iterator, group.encode(), match_template.encode(), ffi.from_buffer(out_buffer))\n    key = None\n    try:\n        key = out_buffer[:].decode()\n    except:\n        key = None \n    return key, it \n    \n\n\ndef eval(dbr_hdl, tuple_val, tuple_name, size, group, fn_ptr):\n    retval = libdatabroker.dbrEval(dbr_hdl, tuple_val.encode(), size, tuple_name.encode(), group.encode(), fn_ptr)\n    return retval\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.7.0-li2eos3bvsdvwot5tfzvxjp74irwqffp/spack-src/doc/fig/architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-ibm-databroker-0.7.0-li2eos3bvsdvwot5tfzvxjp74irwqffp/spack-src/doc/fig/dbrworkflow.png"
    ],
    "total_files": 230
}