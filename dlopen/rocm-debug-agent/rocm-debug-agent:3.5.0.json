{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocm-debug-agent-3.5.0-nz7uryanh2xx2blcsjblbaph3uw6ht3f/spack-src/src/AgentUtils.cpp": "////////////////////////////////////////////////////////////////////////////////\n//\n// The University of Illinois/NCSA\n// Open Source License (NCSA)\n//\n// Copyright (c) 2018, Advanced Micro Devices, Inc. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal with the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n//  - Redistributions of source code must retain the above copyright notice,\n//    this list of conditions and the following disclaimers.\n//  - Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimers in\n//    the documentation and/or other materials provided with the distribution.\n//  - Neither the names of Advanced Micro Devices, Inc,\n//    nor the names of its contributors may be used to endorse or promote\n//    products derived from this Software without specific prior written\n//    permission.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS WITH THE SOFTWARE.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#include <cassert>\n#include <cstring>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fstream>\n#include <iostream>\n#include <libelf.h>\n#include <mutex>\n#include <sys/stat.h>\n\n// Debug Agent Headers\n#include \"AgentLogging.h\"\n#include \"AgentUtils.h\"\n#include \"HSADebugInfo.h\"\n\n// Just a simple function so that all the exit behavior can be handled in one place\n// We can add logging parameters but it is expected that you would call the logging\n// functions before you fatally exit\n// We will try to restrict this function's usage so that the process  dies only from\n// errors in system calls\nvoid AgentFatalExit()\n{\n    AgentErrorLog(\"FatalExit\\n\");\n    exit(-1);\n}\n\nstd::string GetHsaStatusString(const hsa_status_t s)\n{\n    const char* pszbuff = { 0 };\n    hsa_status_string(s, &pszbuff);\n\n    std::string str = pszbuff;\n    return str;\n}\n\nbool AgentIsFileExists(const char *fileName)\n{\n    std::ifstream infile(fileName);\n    return infile.good();\n}\n\nbool AgentIsDirExists(const char *path)\n{\n    struct stat pathStat;\n    if (stat(path, &pathStat))\n    {\n        return false;\n    }\n    if (!S_ISDIR(pathStat.st_mode))\n    {\n        return false;\n    }\n    return true;\n}\n\nDebugAgentStatus AgentCreateTmpDir()\n{\n    char* pTmpPathEnvVar = nullptr;\n\n    pTmpPathEnvVar = std::getenv(\"ROCM_DEBUG_SAVE_CODE_OBJECT\");\n\n    if (pTmpPathEnvVar != nullptr)\n    {\n        sprintf(g_codeObjDir, \"/%s\", pTmpPathEnvVar);\n        g_deleteTmpFile = false;\n\n        if ((mkdir(g_codeObjDir, 0777) != 0) && errno != EEXIST)\n        {\n            AGENT_WARNING(\"Failed creating temp code object file directory at given path, set path to default.\");\n            pTmpPathEnvVar = nullptr;\n            memset(g_codeObjDir, 0, sizeof(g_codeObjDir));\n        }\n    }\n\n    if (pTmpPathEnvVar == nullptr)\n    {\n        char sessionID[64];\n        DebugAgentStatus agentStatus = AgentGetDebugSessionID(&sessionID[0]);\n        if (agentStatus != DEBUG_AGENT_STATUS_SUCCESS)\n        {\n            AGENT_ERROR(\"Interception: Cannot get debug session id\");\n            return agentStatus;\n        }\n        sprintf(g_codeObjDir, \"/tmp/ROCm_Tmp_%s\", sessionID);\n\n        if (mkdir(g_codeObjDir, 0777) != 0)\n        {\n            AGENT_ERROR(\"Failed creating temp code object file directory at default path.\");\n            return DEBUG_AGENT_STATUS_FAILURE;\n        }\n    }\n    return DEBUG_AGENT_STATUS_SUCCESS;\n}\n\nDebugAgentStatus AgentDeleteFile(const char* ipFilename)\n{\n    DebugAgentStatus status = DEBUG_AGENT_STATUS_FAILURE;\n\n    if (ipFilename == nullptr)\n    {\n        AGENT_LOG(\"AgentDeleteFile: invalid filename\");\n        return status;\n    }\n\n    if (remove(ipFilename) != 0)\n    {\n        int err_no = errno;\n        AGENT_ERROR(\"Error deleting \" << ipFilename <<\n                    \", errno: \" << err_no << \" \" << strerror(err_no));\n    }\n    else\n    {\n        status = DEBUG_AGENT_STATUS_SUCCESS;\n    }\n\n    return status;\n}\n\nDebugAgentStatus AgentLoadFileAsSharedObject(const std::string& ipFilename)\n{\n    void* hModule = nullptr;\n    DebugAgentStatus status = DEBUG_AGENT_STATUS_FAILURE;\n\n    dlerror(); // clear error status before processing\n    hModule = dlopen(ipFilename.c_str(), RTLD_LAZY );\n    char* dllstatus = dlerror();\n\n    if (nullptr != hModule)\n    {\n        AGENT_OP(\"File: \"  << ipFilename << \" loaded as a shared library\");\n        status = DEBUG_AGENT_STATUS_SUCCESS;\n    }\n    else\n    {\n        if (nullptr != dllstatus)\n        {\n            AGENT_ERROR(\"\\\"\" <<ipFilename << \"\\\"\" << \"Not Loaded (error: \" << dllstatus << \")\");\n        }\n        else\n        {\n            AGENT_ERROR(ipFilename  << \"\\t Not Loaded \" << dllstatus );\n        }\n    }\n\n    return status;\n}\n\nDebugAgentStatus AgentWriteBinaryToFile(const void*  pBinary, size_t binarySize, const char*  pFilename)\n{\n    DebugAgentStatus status = DEBUG_AGENT_STATUS_FAILURE;\n    if (pBinary == nullptr)\n    {\n        AgentErrorLog(\"WriteBinaryToFile: Error Binary is null\\n\");\n        return status;\n    }\n\n    if (binarySize <= 0)\n    {\n        AgentErrorLog(\"WriteBinaryToFile: Error Binary size is invalid\\n\");\n        return status;\n    }\n\n    if (pFilename == nullptr)\n    {\n        AgentErrorLog(\"WriteBinaryToFile: Filename is nullptr\\n\");\n        return status;\n    }\n\n    FILE* pFd = fopen(pFilename, \"wb\");\n\n    if (pFd == nullptr)\n    {\n        AgentErrorLog(\"WriteBinaryToFile: Error opening file\\n\");\n        assert(!\"Error opening file\\n\");\n        return status;\n    }\n\n    size_t retSize = fwrite(pBinary, sizeof(char), binarySize, pFd);\n\n    fclose(pFd);\n\n    if (retSize != binarySize)\n    {\n        AgentErrorLog(\"WriteBinaryToFile: Error writing to file\\n\");\n        assert(!\"WriteBinaryToFile: Error: fwrite failure.\");\n    }\n    else\n    {\n        status = DEBUG_AGENT_STATUS_SUCCESS;\n    }\n\n    return status;\n}\n\nbool AgentWriteDLLPathToString(const std::string& dllName, std::string& msg)\n{\n    // Same as struct link_map in <link.h>\n    typedef struct _LinkMap\n    {\n        void* pAddr;    // Difference between the address in the ELF file and the addresses in memory.\n        char* pPath;    // Absolute file name object was found in.\n        void* pLd;      // Dynamic section of the shared object.\n        struct _LinkMap* pNext, *pPrev; // Chain of loaded objects.\n    } LinkMap;\n\n    bool ret = false;\n    void* hModule = nullptr;\n    char* status = nullptr;\n\n    dlerror(); // clear error status before processing\n    hModule = dlopen(dllName.c_str(), RTLD_LAZY | RTLD_NOLOAD);\n    status = dlerror();\n\n    if (nullptr != hModule)\n    {\n        // Get the path\n        LinkMap* pLm = reinterpret_cast<LinkMap*>(hModule);\n        msg.assign(pLm->pPath);\n        msg += \"\\t Loaded\";\n\n        dlclose(hModule);\n        ret = true;\n    }\n    else\n    {\n        if (nullptr != status)\n        {\n            msg += dllName + \"\\t Not Loaded (error \" + status + \")\";\n        }\n        else\n        {\n            msg += dllName + \"\\t Not Loaded (can be expected)\";\n        }\n\n        ret = false;\n    }\n\n    return ret;\n}\n\nDebugAgentStatus SaveCodeObjectTempFile(uint64_t elfBaseAddress,\n                                        uint64_t elfSize,\n                                        CodeObjectInfo* pCodeObject)\n{\n    DebugAgentStatus agentStatus = DEBUG_AGENT_STATUS_SUCCESS;\n\n    // Check for code object directory, it is created in OnLoad.\n    if (!AgentIsDirExists(g_codeObjDir))\n    {\n        AGENT_ERROR(\"Interception: The code object directory doesn't exist\");\n        return agentStatus;\n    }\n\n    agentStatus =  AgentWriteBinaryToFile((const void*)uintptr_t(elfBaseAddress), elfSize, pCodeObject->path);\n    if (agentStatus != DEBUG_AGENT_STATUS_SUCCESS)\n    {\n        AGENT_ERROR(\"Cannot create temp code object file\");\n        return agentStatus;\n    }\n\n    return agentStatus;\n}\n\nDebugAgentStatus SaveWaveStateDumpToFile(std::stringstream& dump)\n{\n    DebugAgentStatus agentStatus = DEBUG_AGENT_STATUS_SUCCESS;\n\n    // Check for code object directory, it is created in OnLoad.\n    if (!AgentIsDirExists(g_codeObjDir))\n    {\n        AGENT_ERROR(\"Interception: The wave state directory doesn't exist\");\n        return agentStatus;\n    }\n\n    std::string waveStatePath = g_codeObjDir;\n    waveStatePath += \"/ROCm_Wave_State_Dump\";\n    std::ofstream opStream;\n    opStream.open(waveStatePath, std::ofstream::app);\n\n    if (!opStream.is_open())\n    {\n        AGENT_ERROR(\"Cannot open wave state dump file\");\n        return DEBUG_AGENT_STATUS_FAILURE;\n    }\n\n    opStream << dump.rdbuf();\n    opStream.close();\n\n    std::cout << \"Wave States Dump File: \" << waveStatePath << std::endl;\n    return agentStatus;\n}\n"
    },
    "skipped": [],
    "total_files": 40
}