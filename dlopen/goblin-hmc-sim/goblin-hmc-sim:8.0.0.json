{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/src/hmc_cmc.c": "/*\n * _HMC_CMC_C_\n *\n * Hybrid memory cube simulation library\n *\n * Custom memory cube functionality\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include \"hmc_sim.h\"\n\n\n/* Function Prototypes */\nextern int hmcsim_trace_rqst( struct hmcsim_t *hmc,\n                              char *rqst,\n                              uint32_t dev,\n                              uint32_t quad,\n                              uint32_t vault,\n                              uint32_t bank,\n                              uint64_t addr,\n                              uint32_t size );\n\n\n/* conversion table for cmc request enums, opcodes and struct indices */\nstruct cmc_table{\n  hmc_rqst_t type;\n  uint32_t cmd;\n  uint32_t idx;\n};\n\nstruct cmc_table ctable[HMC_MAX_CMC] = {\n\n  {CMC04,4,0},\n  {CMC05,5,1},\n  {CMC06,6,2},\n  {CMC07,7,3},\n  {CMC20,20,4},\n  {CMC21,21,5},\n  {CMC22,22,6},\n  {CMC23,23,7},\n  {CMC32,32,8},\n  {CMC36,36,9},\n  {CMC37,37,10},\n  {CMC38,38,11},\n  {CMC39,39,12},\n  {CMC41,41,13},\n  {CMC42,42,14},\n  {CMC43,43,15},\n  {CMC44,44,16},\n  {CMC45,45,17},\n  {CMC46,46,18},\n  {CMC47,47,19},\n  {CMC56,56,20},\n  {CMC57,57,21},\n  {CMC58,58,22},\n  {CMC59,59,23},\n  {CMC60,60,24},\n  {CMC61,61,25},\n  {CMC62,62,26},\n  {CMC63,63,27},\n  {CMC69,69,28},\n  {CMC70,70,29},\n  {CMC71,71,30},\n  {CMC72,72,31},\n  {CMC73,73,32},\n  {CMC74,74,33},\n  {CMC75,75,34},\n  {CMC76,76,35},\n  {CMC77,77,36},\n  {CMC78,78,37},\n  {CMC85,85,38},\n  {CMC86,86,39},\n  {CMC87,87,40},\n  {CMC88,88,41},\n  {CMC89,89,42},\n  {CMC90,90,43},\n  {CMC91,91,44},\n  {CMC92,92,45},\n  {CMC93,93,46},\n  {CMC94,94,47},\n  {CMC102,102,48},\n  {CMC103,103,49},\n  {CMC107,107,50},\n  {CMC108,108,51},\n  {CMC109,109,52},\n  {CMC110,110,53},\n  {CMC111,111,54},\n  {CMC112,112,55},\n  {CMC113,113,56},\n  {CMC114,114,57},\n  {CMC115,115,58},\n  {CMC116,116,59},\n  {CMC117,117,60},\n  {CMC118,118,61},\n  {CMC120,120,62},\n  {CMC121,121,63},\n  {CMC122,122,64},\n  {CMC123,123,65},\n  {CMC124,124,66},\n  {CMC125,125,67},\n  {CMC126,126,68},\n  {CMC127,127,69}\n\n};\n\n\n/* ----------------------------------------------------- HMCSIM_CMC_RAWTOIDX */\nextern uint32_t hmcsim_cmc_rawtoidx( uint32_t raw ){\n  uint32_t i = 0;\n\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    if( ctable[i].cmd == raw ){\n      return i;\n    }\n  }\n  return HMC_MAX_CMC; /* redundant, but squashes gcc warning */\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_IDXTOCMD */\nextern hmc_rqst_t hmcsim_cmc_idxtocmd( uint32_t idx ){\n  return ctable[idx].type;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_CMDTOIDX */\nextern uint32_t hmcsim_cmc_cmdtoidx( hmc_rqst_t rqst ){\n  uint32_t i = 0;\n\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    if( ctable[i].type == rqst ){\n      return i;\n    }\n  }\n  return HMC_MAX_CMC; /* redundant, but squashes gcc warning */\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_TRACE_HEADER */\nextern void hmcsim_cmc_trace_header( struct hmcsim_t *hmc ){\n\n  /* vars */\n  uint32_t i      = 0;\n  uint32_t active = 0;\n  char str[256];\n  void (*cmc_str)(char *)  = NULL;\n  /* ---- */\n\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    active += hmc->cmcs[i].active;\n  }\n\n  if( active == 0 ){\n    /* nothing active, dump out */\n    return ;\n  }\n\n  /* print everything active */\n  fprintf( hmc->tfile, \"%s\\n\",    \"#---------------------------------------------------------\" );\n  fprintf( hmc->tfile, \"%s\\n\",    \"# CMC_OP:CMC_STR:RQST_LEN:RSP_LEN:RSP_CMD_CODE\" );\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    if( hmc->cmcs[i].active == 1 ){\n      cmc_str = hmc->cmcs[i].cmc_str;\n      (*cmc_str)(&(str[0]));\n      fprintf( hmc->tfile, \"%s%d%s%s%s%d%s%d%s%d\\n\",\n               \"#\",\n               hmc->cmcs[i].cmd,\n               \":\",\n               str,\n               \":\",\n               hmc->cmcs[i].rqst_len,\n               \":\",\n               hmc->cmcs[i].rsp_len,\n               \":\",\n               hmc->cmcs[i].rsp_cmd_code );\n    }\n  }\n  fprintf( hmc->tfile, \"%s\\n\",    \"#---------------------------------------------------------\" );\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_FUNCTIONS */\n/*\n * HMCSIM_REGISTER_FUNCTIONS\n *\n */\nstatic int    hmcsim_register_functions( struct hmcsim_t *hmc, char *cmc_lib ){\n\n  /* vars */\n  hmc_rqst_t rqst;\n  uint32_t cmd;\n  uint32_t idx;\n  uint32_t rqst_len;\n  uint32_t rsp_len;\n  hmc_response_t rsp_cmd;\n  uint8_t rsp_cmd_code;\n\n  void *handle = NULL;\n  int (*cmc_register)(hmc_rqst_t *,\n                      uint32_t *,\n                      uint32_t *,\n                      uint32_t *,\n                      hmc_response_t *,\n                      uint8_t *) = NULL;\n  int (*cmc_execute)(void *,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint64_t,\n                     uint32_t,\n                     uint64_t,\n                     uint64_t,\n                     uint64_t *,\n                     uint64_t *) = NULL;\n  void (*cmc_str)(char *) = NULL;\n  void (*cmc_power)(uint32_t *,float *) = NULL;\n  uint32_t (*cmc_dyn_rsp)() = NULL;\n  uint32_t (*cmc_dyn_rqst)() = NULL;\n  uint32_t (*cmc_dyn)() = NULL;\n  uint32_t dynamic = 0;\n  /* ---- */\n\n  /* attempt to load the library */\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"LOADING CMC LIBRARY\" );\n#endif\n  handle = dlopen( cmc_lib, RTLD_NOW );\n\n  if( handle == NULL ){\n#ifdef HMC_DEBUG\n    HMCSIM_PRINT_TRACE(dlerror());\n#endif\n    return -1;\n  }\n\n  /* library is loaded, resolve the functions */\n  /* -- hmcsim_register_cmc */\n  cmc_register = (int (*)(hmc_rqst_t *,\n                          uint32_t *,\n                          uint32_t *,\n                          uint32_t *,\n                          hmc_response_t *,\n                          uint8_t *))dlsym(handle,\"hmcsim_register_cmc\");\n  if( cmc_register == NULL ){\n    dlclose( handle );\n    return -1;\n  }\n\n  if( (*cmc_register)(&rqst,\n                      &cmd,\n                      &rqst_len,\n                      &rsp_len,\n                      &rsp_cmd,\n                      &rsp_cmd_code) != 0 ){\n    dlclose( handle );\n    return -1;\n  }\n\n  /* -- hmcsim_execute_cmc */\n  cmc_execute = (int (*)(void *,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint64_t,\n                     uint32_t,\n                     uint64_t,\n                     uint64_t,\n                     uint64_t *,\n                     uint64_t *))dlsym(handle,\"hmcsim_execute_cmc\");\n  if( cmc_execute == NULL ){\n    dlclose( handle );\n    return -1;\n  }\n\n  /* -- hmcsim_cmc_str */\n  cmc_str = (void (*)(char *))dlsym(handle,\"hmcsim_cmc_str\");\n  if( cmc_str == NULL ){\n    dlclose( handle );\n    return -1;\n  }\n\n  /* -- hmcsim_cmc_power */\n  cmc_power = (void (*)(uint32_t *,float *))dlsym(handle,\"hmcsim_cmc_power\");\n\n  /* hmcsim_cmc_dynamic */\n  cmc_dyn = (uint32_t (*)())dlsym(handle,\"hmcsim_cmc_dynamic\");\n  if( cmc_dyn != NULL ){\n    dynamic = (*cmc_dyn)();\n  }\n  if( dynamic ){\n    /* load the remainder of the dynamic rqst/rsp functions */\n    cmc_dyn_rsp = (uint32_t (*)())dlsym(handle,\"hmcsim_cmc_dynamic_rsp_len\");\n    cmc_dyn_rqst = (uint32_t (*)())dlsym(handle,\"hmcsim_cmc_dynamic_rqst_len\");\n  }\n\n\n  /* done loading functions */\n\n  idx = hmcsim_cmc_rawtoidx( cmd );\n#ifdef HMC_DEBUG\n  printf( \"HMCSIM_REGISTER_FUNCTIONS: Setting CMC command (%d) at IDX=%d to ACTIVE\\n\",\n          cmd,idx );\n#endif\n\n  if( hmc->cmcs[idx].active == 1 ){\n    /* previously activated, this is an error */\n    dlclose( handle );\n    return -1;\n  }\n\n  /* write the necessary references into the structure */\n  if( cmc_power != NULL ){\n    hmc->cmcs[idx].cmc_power    = cmc_power;\n    hmc->cmcs[idx].track_power  = 1;\n  }else{\n    hmc->cmcs[idx].cmc_power    = NULL;\n    hmc->cmcs[idx].track_power  = 0;\n  }\n  hmc->cmcs[idx].type         = rqst;\n  hmc->cmcs[idx].cmd          = cmd;\n  hmc->cmcs[idx].rqst_len     = rqst_len;\n  hmc->cmcs[idx].rsp_len      = rsp_len;\n  hmc->cmcs[idx].rsp_cmd      = rsp_cmd;\n\n  hmc->cmcs[idx].active       = 1;\n  hmc->cmcs[idx].handle       = handle;\n  hmc->cmcs[idx].cmc_register = cmc_register;\n  hmc->cmcs[idx].cmc_execute  = cmc_execute;\n  hmc->cmcs[idx].cmc_str      = cmc_str;\n\n  hmc->cmcs[idx].dynamic      = dynamic;\n  hmc->cmcs[idx].cmc_dyn_rsp  = cmc_dyn_rsp;\n  hmc->cmcs[idx].cmc_dyn_rqst = cmc_dyn_rqst;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_QUERY_CMC */\nextern int  hmcsim_query_cmc( struct hmcsim_t *hmc,\n                              hmc_rqst_t type,\n                              uint32_t *flits,\n                              uint8_t *cmd ){\n  /* vars */\n  uint32_t idx      = HMC_MAX_CMC;\n  uint32_t (*cmc_dyn_rqst)() = NULL;\n  /* ---- */\n\n  idx = hmcsim_cmc_cmdtoidx( type );\n\n#ifdef HMC_DEBUG\n  printf( \"HMCSIM_QUERY_CMC: RQST_TYPE = %d; IDX = %d\\n\",\n       type, idx );\n#endif\n\n  if( idx == HMC_MAX_CMC ){\n    return -1;\n  }else if( hmc->cmcs[idx].active == 0 ){\n#ifdef HMC_DEBUG\n    printf( \"ERROR : HMCSIM_QUERY_CMC: CMC OP AT IDX=%d IS INACTIVE\\n\",\n            idx );\n#endif\n    return -1;\n  }\n\n  *flits  = hmc->cmcs[idx].rqst_len;\n  *cmd    = hmc->cmcs[idx].cmd;\n\n  /* check for a dynamic command */\n  if( hmc->cmcs[idx].dynamic == 1){\n    // this cmc command has a dynamic request or response length\n    cmc_dyn_rqst = hmc->cmcs[idx].cmc_dyn_rqst;\n    *flits = (*cmc_dyn_rqst)();\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_PROCESS_CMC */\nextern int  hmcsim_process_cmc( struct hmcsim_t *hmc,\n                                uint32_t rawcmd,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *raw_rsp_cmd,\n                                uint32_t *row_ops,\n                                float *tpower ){\n\n  /* vars */\n  uint32_t idx  = 0;\n  int rtn       = 0;\n  char op_name[256];\n  int (*cmc_execute)(void *,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint32_t,\n                     uint64_t,\n                     uint32_t,\n                     uint64_t,\n                     uint64_t,\n                     uint64_t *,\n                     uint64_t *) = NULL;\n  void (*cmc_str)(char *);\n  void (*cmc_power)(uint32_t *,float *) = NULL;\n  uint32_t (*cmc_dyn_rsp)() = NULL;\n  /* ---- */\n\n  /* resolve the index of the cmc in the lookup table */\n  idx = hmcsim_cmc_rawtoidx( rawcmd );\n\n  if( idx == HMC_MAX_CMC ){\n    /* erroneous request */\n    return -1;\n  }else if( hmc->cmcs[idx].active == 0 ){\n    /* command not active */\n    return -1;\n  }\n\n  /* -- new power measurement items */\n  if( (row_ops == NULL) || (tpower == NULL) ){\n    return -1;\n  }\n\n  /* command is active, process it */\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"PROCESSING CMC PACKET\" );\n  printf( \"CMC RAWCMD:IDX = %d:%d\\n\", rawcmd,idx );\n#endif\n  cmc_execute = hmc->cmcs[idx].cmc_execute;\n  rtn = (*cmc_execute)( (void *)(hmc),\n                        dev,\n                        quad,\n                        vault,\n                        bank,\n                        addr,\n                        length,\n                        head,\n                        tail,\n                        rqst_payload,\n                        rsp_payload);\n\n  if( rtn == -1 ){\n    return HMC_ERROR;\n  }\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"DONE PROCESSING CMC PACKET\" );\n  HMCSIM_PRINT_TRACE( \"REGISTERING RESPONSES IF NECESSARY\" );\n#endif\n\n  /* register all the response data */\n  if( hmc->cmcs[idx].dynamic == 1 ){\n    cmc_dyn_rsp = hmc->cmcs[idx].cmc_dyn_rsp;\n    *rsp_len      = (*cmc_dyn_rsp)();\n  }else{\n    *rsp_len      = hmc->cmcs[idx].rsp_len;\n  }\n  *rsp_cmd      = hmc->cmcs[idx].rsp_cmd;\n\n  if( *rsp_len > 0 ){\n    if( *rsp_cmd == RSP_CMC ){\n      *raw_rsp_cmd  = hmc->cmcs[idx].rsp_cmd_code;\n    }else{\n      /* encode the normal reponse */\n      switch( *rsp_cmd ){\n      case RD_RS:\n        *raw_rsp_cmd = 0x38;\n        break;\n      case WR_RS:\n        *raw_rsp_cmd = 0x39;\n        break;\n      case MD_RD_RS:\n        *raw_rsp_cmd = 0x3A;\n        break;\n      case MD_WR_RS:\n        *raw_rsp_cmd = 0x3B;\n        break;\n      case RSP_ERROR:\n      default:\n        *raw_rsp_cmd = 0x00;\n        break;\n      }\n    }\n  }else{\n    *raw_rsp_cmd = 0x00;\n  }\n\n  /* trace it */\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"DUMPING TRACE DATA FOR CMC COMMAND\" );\n#endif\n  /* -- get the name of the op */\n  cmc_str = hmc->cmcs[idx].cmc_str;\n  (*cmc_str)(&(op_name[0]));\n\n  /* -- insert the trace */\n  hmcsim_trace_rqst( hmc,\n                     &(op_name[0]),\n                     dev,\n                     quad,\n                     vault,\n                     bank,\n                     addr,\n                     length );\n\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"DUMPING POWER/THERMAL DATA FOR CMC COMMAND\" );\n#endif\n  /* -- get the power */\n  if( hmc->cmcs[idx].track_power == 1 ){\n    cmc_power = hmc->cmcs[idx].cmc_power;\n    (*cmc_power)(row_ops,tpower);\n  }else{\n    *row_ops = 1;\n    *tpower  = 0.;\n  }\n\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"CMC PROCESSING COMPLETE\" );\n#endif\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_FREE_CMC */\n/*\n * HMCSIM_FREE_CMC\n *\n */\nextern int    hmcsim_free_cmc( struct hmcsim_t *hmc ){\n  uint32_t i = 0;\n\n  if( hmc == NULL ){\n    return -1;\n  }\n\n  if( hmc->cmcs == NULL ){\n    return -1;\n  }\n\n  for( i=0; i<HMC_MAX_CMC; i++ ){\n    if( hmc->cmcs[i].active == 1 ){\n      dlclose( hmc->cmcs[i].handle );\n    }\n  }\n\n  return 0;\n};\n\n/* ----------------------------------------------------- HMCSIM_LOAD_CMC */\n/*\n * HMCSIM_LOAD_CMC\n *\n */\nextern int      hmcsim_load_cmc( struct hmcsim_t *hmc, char *cmc_lib ){\n\n  if((hmc == NULL) || (cmc_lib == NULL)){\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"ERROR PROCESSING FUNCTION ARGUMENTS\" );\n#endif\n    return -1;\n  }\n\n#ifdef HMC_DEBUG\n  printf( \"ATTEMPTING TO LOAD CMC LIBRARY: %s\\n\", cmc_lib );\n#endif\n\n  /* register the library functions */\n  if( hmcsim_register_functions( hmc, cmc_lib ) != 0 ){\n#ifdef HMC_DEBUG\n  HMCSIM_PRINT_TRACE( \"FAILED TO REGISTER CMC FUNCTIONS\" );\n#endif\n    return -1;\n  }\n\n  return 0;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/dynamic_template/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a dynamic CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"DYNAMIC_TEMPLATE_OP\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC04;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 4;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 1;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = RD_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.5;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* __dynamic_rsp_len : Contains the instantaneous dynamic response len\n                     : for the packet currently being processed in flits\n*/\nuint32_t __dynamic_rsp_len = 0;\n\n/* __dynamic_rqst_len : Contains the instantaneous dynamic request len\n                      : for the packet currently being processed in flits\n*/\nuint32_t __dynamic_rqst_len = 0;\n\n/* __dynamic_cmc : Determines if dynamic request and response packets\n                 : are enabled; 0=no; 1=yes\n*/\nstatic uint32_t __dynamic_cmc = 1;\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n\n  /* relevant function pointers */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                  uint64_t,\n                  uint64_t *,\n                  uint32_t ) = NULL;\n  int (*read_cmcreg)(struct hmcsim_t *,\n                     uint32_t,\n                     uint64_t,\n                     uint64_t *) = NULL;\n  int (*write_cmcreg)(struct hmcsim_t *,\n                      uint32_t,\n                      uint64_t,\n                      uint64_t ) = NULL;\n\n  /* init the function pointers */\n  readmem       = l_hmc->readmem;\n  writemem      = l_hmc->writemem;\n  read_cmcreg   = l_hmc->read_cmcreg;\n  write_cmcreg  = l_hmc->write_cmcreg;\n\n  /*\n   * !!! perform your operation !!!\n   *\n   */\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  /* initialize the dynamic packet lengths */\n  __dynamic_rsp_len = __rsp_len;\n  __dynamic_rqst_len = __rqst_len;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_DYNAMIC */\n/*\n * Returns whether or not this packet contains dynamic request or response\n * values. 0=no; 1=yes\n *\n */\nuint32_t hmcsim_cmc_dynamic(){\n  return __dynamic_cmc;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_RSP_LEN */\n/*\n * Returns the value of the dynamic packet response.\n * If dynamic packets are not enabled, this function returns\n * the value of __rsp_len\n *\n */\nuint32_t hmcsim_cmc_dynamic_rsp_len(){\n  if( __dynamic_cmc == 1 ){\n    return __dynamic_rsp_len;\n  }else{\n    return __rsp_len;\n  }\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_RQST_LEN */\n/*\n * Returns the value of the dynamic packet request.\n * If dynamic packets are not enabled, this function returns\n * the value of __rqst_len\n *\n */\nuint32_t hmcsim_cmc_dynamic_rqst_len(){\n  if( __dynamic_cmc ){\n    return __dynamic_rqst_len;\n  }else{\n    return __rqst_len;\n  }\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n */\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/amo_popcount/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"AMO_POPCOUNT\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC05;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 5;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 1;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = RD_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n                  : Only utilized if __rsp_cmd = RSP_CMC\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.5;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 1;\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data   = 0x00ull;\n\n  /* function pointer for read operation */\n  int (*readmem)( struct hmcsim_t *,\n                  uint64_t,\n                  uint64_t *,\n                  uint32_t ) = NULL;\n\n  /* init the function pointer */\n  readmem = l_hmc->readmem;\n\n  /* read the memory */\n  if( (*readmem)(l_hmc, addr, &data, 1 ) != 0 ){\n    /* error */\n    return -1;\n  }\n\n  /* perform the popcount\n   * write the response to the response payload\n   */\n  rsp_payload[1]  =  __builtin_popcountll( data );\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/template/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"TEMPLATE_OP\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC04;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 1;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 1;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = RD_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.5;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n\n  /* relevant function pointers */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                  uint64_t,\n                  uint64_t *,\n                  uint32_t ) = NULL;\n  int (*read_cmcreg)(struct hmcsim_t *,\n                     uint32_t,\n                     uint64_t,\n                     uint64_t *) = NULL;\n  int (*write_cmcreg)(struct hmcsim_t *,\n                      uint32_t,\n                      uint64_t,\n                      uint64_t ) = NULL;\n\n  /* init the function pointers */\n  readmem       = l_hmc->readmem;\n  writemem      = l_hmc->writemem;\n  read_cmcreg   = l_hmc->read_cmcreg;\n  write_cmcreg  = l_hmc->write_cmcreg;\n\n  /*\n   * !!! perform your operation !!!\n   *\n   */\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n */\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/WriteEF/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"WRITEEF\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC75;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 75;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 2;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = WR_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.2;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 3;\n\n/* ----------------------------------------------------- GLOBALS */\nuint32_t __local_row_ops;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* bit address */\n  uint8_t bit = 0x00;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* get the bit value */\n  bit = fe_get_bit( hmc, addr );\n\n  if( bit == 0 ){\n    /* set the bit */\n    fe_set_bit( hmc, addr, 1 );\n\n    if( (*writemem)(l_hmc, addr, rqst_payload, 1 ) != 0 ){\n      return -1;\n    }\n\n    rsp_payload[0] = 0x01ull;\n    rsp_payload[1] = 0x01ull;\n    __local_row_ops = __row_ops;\n  }else{\n    rsp_payload[0] = 0x00ull;\n    rsp_payload[1] = 0x00ull;\n    __local_row_ops = 1;\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __local_row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/ClrXX/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"CLRXX\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC85;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 85;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 1;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 0;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = WR_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.3;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ull;\n\n  /* function pointer */\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  writemem  = l_hmc->writemem;\n\n  /* clear the memory */\n  if( (*writemem)(l_hmc, addr, &data, 1) != 0 ){\n    return -1;\n  }\n\n  /* clear the bit */\n  fe_set_bit( hmc,\n              addr,\n              0 );\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/ReadFF/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"READFF\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC73;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 73;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 1;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = RD_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.3;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data[2]  = {0x00ull,0x00ull};\n\n  /* bit address */\n  uint8_t bit = 0x00;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* get the bit value */\n  bit = fe_get_bit( hmc, addr );\n\n  if( bit == 1 ){\n    /* set the bit */\n    fe_set_bit( hmc, addr, 1 );\n\n    if( (*readmem)(l_hmc, addr, &(data[0]), 1 ) != 0 ){\n      return -1;\n    }\n\n    rsp_payload[0] = data[0];\n    rsp_payload[1] = 0x01ull;\n\n  }else{\n    rsp_payload[0] = 0x00ull;\n    rsp_payload[1] = 0x00ull;\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/WriteXE/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"WRITEXE\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC77;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 77;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 2;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = WR_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.2;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 3;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* set the bit */\n  fe_set_bit( hmc, addr, 0 );\n\n  if( (*writemem)(l_hmc, addr, rqst_payload, 1 ) != 0 ){\n    return -1;\n  }\n\n  rsp_payload[0] = 0x01ull;\n  rsp_payload[1] = 0x01ull;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/ReadEF/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"READEF\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC71;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 71;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 1;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = RD_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.2;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 3;\n\n/* ----------------------------------------------------- GLOBALS */\nuint32_t __local_row_ops;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  /* grab the address */\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data[2]  = {0x00ull,0x00ull};\n\n  /* bit address */\n  uint8_t bit = 0x00;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* get the bit value */\n  bit = fe_get_bit( hmc, addr );\n\n  if( bit == 0 ){\n    /* set the bit */\n    fe_set_bit( hmc, addr, 1 );\n\n    if( (*readmem)(l_hmc, addr, &(data[0]), 1 ) != 0 ){\n      return -1;\n    }\n\n    rsp_payload[0] = data[0];\n    rsp_payload[1] = 0x01ull;\n\n    __local_row_ops = __row_ops;\n\n  }else{\n    rsp_payload[0] = 0x00ull;\n    rsp_payload[1] = 0x00ull;\n    __local_row_ops = 1;\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __local_row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/WriteFF/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"WRITEFF\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC76;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 76;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 2;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = WR_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.2;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* bit address */\n  uint8_t bit = 0x00;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* get the bit value */\n  bit = fe_get_bit( hmc, addr );\n\n  if( bit == 1 ){\n    /* set the bit */\n    fe_set_bit( hmc, addr, 1 );\n\n    if( (*writemem)(l_hmc, addr, rqst_payload, 1 ) != 0 ){\n      return -1;\n    }\n\n    rsp_payload[0] = 0x01ull;\n    rsp_payload[1] = 0x01ull;\n  }else{\n    rsp_payload[0] = 0x00ull;\n    rsp_payload[1] = 0x00ull;\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/ReadXX/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"READXX\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC74;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 74;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 1;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = RD_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.2;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data[2]  = {0x00ull,0x00ull};\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  if( (*readmem)(l_hmc, addr, &(data[0]), 1 ) != 0 ){\n    return -1;\n  }\n\n  rsp_payload[0] = data[0];\n  rsp_payload[1] = 0x01ull;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/IncFF/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"INCFF\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC70;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 70;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 2;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = WR_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.3;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 3;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data[2]  = {0x00ull,0x00ull};\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  uint8_t bit = 0x00;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* get the value of the bit */\n  bit = fe_get_bit( hmc, addr );\n\n  if( bit == 1 ){\n    /* mem = old+data; ret(1,mem) */\n    if( (*readmem)(l_hmc, addr, &(data[0]), 1 ) != 0 ){\n      return -1;\n    }\n\n    rsp_payload[0] = data[0];\n    rsp_payload[1] = 0x01ull;\n    data[0] += rqst_payload[0];\n    if( (*writemem)(l_hmc, addr, &(data[0]), 1 ) != 0 ){\n      return -1;\n    }\n\n    /* set the bit, not necessary, but pedantic */\n    fe_set_bit( hmc, addr, 1 );\n\n  }else{\n    /* ret(0,0x00ull) */\n    rsp_payload[0] = 0x00ull;\n    rsp_payload[1] = 0x00ull;\n  }\n\n  /* read the memory */\n  if( (*readmem)(l_hmc, addr, &(data[0]), 2 ) != 0 ){\n    return -1;\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n */\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/ReadFE/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"READFE\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC72;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 72;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 1;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = RD_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.5;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* ----------------------------------------------------- GLOBALS */\nuint32_t __local_row_ops;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data[2]  = {0x00ull,0x00ull};\n\n  /* bit address */\n  uint8_t bit = 0x00;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* get the bit value */\n  bit = fe_get_bit( hmc, addr );\n\n  if( bit == 1 ){\n    /* set the bit */\n    fe_set_bit( hmc, addr, 0 );\n\n    if( (*readmem)(l_hmc, addr, &(data[0]), 1 ) != 0 ){\n      return -1;\n    }\n\n    rsp_payload[0] = data[0];\n    rsp_payload[1] = 0x01ull;\n    __local_row_ops = __row_ops;\n  }else{\n    rsp_payload[0] = 0x00ull;\n    rsp_payload[1] = 0x00ull;\n    __local_row_ops = 1;\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __local_row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/fullempty/WriteXF/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"WRITEXF\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC78;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 78;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 2;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = WR_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.2;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 3;\n\n/* ----------------------------------------------------- FE_GET_ADDR */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint64_t fe_get_addr( uint64_t addr, uint8_t *bit ){\n  uint64_t new  = 0x00ull;\n  uint64_t tmp  = 0x00ull;\n\n  tmp   = (addr>>4);\n#ifdef _4GB_\n  new   = ((0xFFFFFFFF-(tmp/8))<<4);\n#else\n  new   = ((0x1FFFFFFFF-(tmp/8))<<4);\n#endif\n  *bit  = (tmp%8);\n\n  return new;\n}\n\n/* ----------------------------------------------------- FE_GET_BIT */\n/*\n * get the value of the FE bit for the corresponding addr\n *\n */\nuint8_t fe_get_bit( void *hmc,\n                         uint64_t addr ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  return tbit;\n}\n\n/* ----------------------------------------------------- FE_SET_BIT */\n/*\n * set the value of the FE bit for the corresponding addr\n *\n */\nvoid fe_set_bit( void *hmc,\n                 uint64_t addr,\n                 uint8_t febit ){\n  uint8_t bit   = 0x00;\n  uint8_t tbit  = 0x00;\n  uint64_t tmp  = fe_get_addr( addr, &bit );\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data = 0x00ll;\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  (*readmem)(l_hmc, tmp, &data, 1 );\n\n  /* get the bit value */\n  tbit = (uint8_t)((data>>bit)&1);\n\n  if( (tbit == 1) && (febit == 0) ){\n    /* clear the bit */\n    data &= ~(1<<bit);\n  }else if( (tbit == 0) && (febit == 1) ){\n    data |= (1<<bit);\n  }/* else, bit matches, do nothing */\n\n  /* write the memory back */\n  (*writemem)(l_hmc, addr, &data, 1);\n}\n\n\n\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* set the bit */\n  fe_set_bit( hmc, addr, 1 );\n\n  if( (*writemem)(l_hmc, addr, rqst_payload, 1 ) != 0 ){\n    return -1;\n  }\n\n  rsp_payload[0] = 0x01ull;\n  rsp_payload[1] = 0x01ull;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/mutex/hmc_unlock/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"HMC_UNLOCK\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC127;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 127;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 2;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = WR_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.5;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data[2]  = {0x00ull,0x00ull};\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                  uint64_t,\n                  uint64_t *,\n                  uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  if( (*readmem)(l_hmc, addr, &(data[0]), 2 ) != 0 ){\n    return -1;\n  }\n\n  if( data[0] == 0 ){\n    /* report failure */\n    rsp_payload[1] = 0x01ull;\n  }else if( data[1] != rqst_payload[1] ){\n    /* report failure */\n    rsp_payload[1] = 0x01ull;\n  }else{\n    /* success */\n    if( (*writemem)(l_hmc, addr, &(data[0]), 2) != 0 ){\n      return -1;\n    }\n    rsp_payload[1] = 0x00ull;\n    rsp_payload[2] = 0x00ull;\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/mutex/hmc_trylock/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"HMC_TRYLOCK\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC126;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 126;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 2;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = RD_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.5;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data[2]  = {0x00ull,0x00ull};\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                  uint64_t,\n                  uint64_t *,\n                  uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  if( (*readmem)(l_hmc, addr, &(data[0]), 2 ) != 0 ){\n    return -1;\n  }\n\n  if( data[0] == 0 ){\n    /* grab the lock */\n    data[0] = 0x01ull;\n    data[1] = rqst_payload[1];\n    if( (*writemem)(l_hmc, addr, &(data[0]), 2) != 0 ){\n      return -1;\n    }\n\n    /* write the response block */\n    rsp_payload[1]  = data[0];\n  }else{\n    /* lock already taken */\n    /* write the response block */\n    rsp_payload[1]  = data[0];\n    rsp_payload[2]  = data[1];\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n",
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/cmc/mutex/hmc_lock/cmc.c": "/*\n * _CMC_C_\n *\n * Implements a single CMC operation\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"hmc_sim.h\"\n\n\n/* ----------------------------------------------------- GLOBALS */\n/* These globals define the CMC operation parameters, the request\n   enum and the command code.  Modify these values for your\n   respective CMC operation.  If more than one CMC library is used\n   in a simulation, these values MUST be unique across disparate\n   libraries.\n*/\n\n\n/* __op_name : Contains a string representative for the trace logs */\nstatic char *__op_name      = \"HMC_LOCK\";\n\n/* __rqst : Contains the respective command enum that the simulated\n          : application uses to initiate a request for this command.\n          : See hmc_rqst_t enums from hmc_sim_types.h\n          : MUST BE UNIQUE ACROSS CMC LIBS\n*/\nstatic hmc_rqst_t __rqst    = CMC125;\n\n/* __cmd : Contains the respective command code for this CMC operation.\n         : This MUST match the __rqst field.  For example, if we have\n         : CMC32 as the __rqst, then the __cmd is (uint32_t)(32).\n*/\nstatic uint32_t __cmd       = 125;\n\n/* __rqst_len : Contains the respective command request packet len in flits\n              : Permissible values are 1->17.  This must include the header\n              : and tail flits.  Commands with just an address have 1 flit.\n              : Commands with data will include at least two flits.\n              : It is up to the implementor to decode the data flits\n*/\nstatic uint32_t __rqst_len  = 2;\n\n/* __rsp_len : Contains the respective command response packet len in flits\n             : Permissible values are 0->17.  This must include the header\n             : and tail flits.  If __rsp_len is 0, then the operation\n             : is assumed to be posted.\n*/\nstatic uint32_t __rsp_len   = 2;\n\n/* __rsp_cmd : Contains the respective response command.  See hmc_response_t\n             : enum in hmc_sim_types.h.  All normal commands are permissible.\n             : If RSP_CMC is selected, you must also set __rsp_cmd_code\n*/\nstatic hmc_response_t __rsp_cmd = WR_RS;\n\n\n/* __rsp_cmd_code : Contains the command code for RSP_CMC command\n                  : responses.  The code must be <= 127 decimal.\n                  : Unused response commands are 64->127\n*/\nstatic uint8_t __rsp_cmd_code = 0x00;\n\n/* __transient_power : Contains the transient power of the respective\n                     : CMC operation.  If this field is unknown,\n                     : the CMC infrastructure will assume a value of 0.\n*/\nstatic float __transient_power = 0.5;\n\n/* __row_ops : Contains the number of row operations for the respective\n             : CMC operation.  If this field is unknown, the CMC\n             : infrastructure will assume a value of 1.\n*/\nstatic uint32_t __row_ops = 2;\n\n/* ----------------------------------------------------- HMCSIM_EXECUTE_CMC */\n/*\n * Performs the actual CMC operation.  All your custom logic belongs in this\n * function.\n *\n * *hmc is a void pointer to the core hmc structure.  Note that this must\n *    be cast to (struct hmcsim_t *)\n * dev is the respective device where the op is occurring\n * quad is the respective quad where the op is occurring\n * vault is the respective vault where the op is occurring\n * bank is the respective bank where the op is occurring\n * addr is the base address of the incoming request\n * length is the length of the incoming request\n * head is the packet head\n * tail is the packet tail\n * *rqst_payload is the incoming request payload formatted as the maximum\n *    possible packet (256 bytes of data).  Its up to this function to\n *    pull the required bits from this payload.\n * *rsp_payload is the outgoing response data payload formatted as the\n *    maximum possible packet (256 bytes of data).  Its up to this function\n *    to write the required number of output bits in the response payload.\n *    Note that the calling infrastructure will only utilize the number of\n *    bytes as defined by the rsp_len of this CMC operation\n *\n */\nextern int hmcsim_execute_cmc(  void *hmc,\n                                uint32_t dev,\n                                uint32_t quad,\n                                uint32_t vault,\n                                uint32_t bank,\n                                uint64_t addr,\n                                uint32_t length,\n                                uint64_t head,\n                                uint64_t tail,\n                                uint64_t *rqst_payload,\n                                uint64_t *rsp_payload ){\n  /* hmc struct pointer */\n  struct hmcsim_t *l_hmc  = (struct hmcsim_t *)(hmc);\n\n  /* data for the operation */\n  uint64_t data[2]  = {0x00ull,0x00ull};\n\n  /* function pointer */\n  int (*readmem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n  int (*writemem)(struct hmcsim_t *,\n                 uint64_t,\n                 uint64_t *,\n                 uint32_t ) = NULL;\n\n  /* init the function pointers */\n  readmem   = l_hmc->readmem;\n  writemem  = l_hmc->writemem;\n\n  /* read the memory */\n  if( (*readmem)(l_hmc, addr, &(data[0]), 2 ) != 0 ){\n    return -1;\n  }\n\n  if( data[0] == 0 ){\n    /* grab the lock */\n    data[0] = 0x01ull;\n    data[1] = rqst_payload[1];\n    if( (*writemem)(l_hmc, addr, &(data[0]), 2) != 0 ){\n      return -1;\n    }\n\n    /* write the response block */\n    rsp_payload[1] = data[0];\n  }else{\n    /* lock already taken */\n    /* write the response block */\n    rsp_payload[1] = data[0];\n  }\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_REGISTER_CMC */\n/*\n * Registers the target CMC library instance with the core simulation. This\n * function is loaded via dlopen and called from the HMC-Sim library when\n * the sim makes a call to hmcsim_load_cmc().  Most users will not need\n * to change this function.\n *\n * *rqst is a pointer to a valid hmc_rqst_t that defines which CMC operation\n *     command enum that this library will utilize.  See the hmc_rqst_t\n *     enums labeled CMCnn in ~/include/hmc_sim_types.h.\n *\n * *cmd is the respective command code that matches the *rqst command enum.\n *     For example, if *rqst returns CMC32, then the *cmd is \"32\".\n *\n * *rsp_len is the respective command's response packet length.\n *    This must fit within the standard HMC response packet sizes\n *\n * *rsp_cmd is the respective command's response command type.  See\n *    the values defined in the hmc_response_t enum in ~/include/hmc_sim_types.h\n *\n * *rsp_cmd_code is the respective command's response command code in raw form.\n *\n */\nextern int hmcsim_register_cmc( hmc_rqst_t *rqst,\n                                uint32_t *cmd,\n                                uint32_t *rqst_len,\n                                uint32_t *rsp_len,\n                                hmc_response_t *rsp_cmd,\n                                uint8_t *rsp_cmd_code){\n  *rqst         = __rqst;\n  *cmd          = __cmd;\n  *rqst_len     = __rqst_len;\n  *rsp_len      = __rsp_len;\n  *rsp_cmd      = __rsp_cmd;\n  *rsp_cmd_code = __rsp_cmd_code;\n\n  return 0;\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_STR */\n/*\n * Returns the name of the CMC operation for use in tracing\n * Most users will not need to change this function\n *\n * *out is the output string that is written to\n *\n */\nextern void hmcsim_cmc_str( char *out ){\n  sprintf( out, \"%s\", __op_name );\n}\n\n/* ----------------------------------------------------- HMCSIM_CMC_POWER */\n/*\n * Returns the amount of transient power and the number of row operations\n * for this respective operation.  If these values are not known, then\n * the CMC infrastructure assumes a transient power of 0 and 1 row op.\n * Users can modify these values based upon the runtime of the operation.\n * This function is not called until AFTER the processing is complete\n *\n*/\nextern void hmcsim_cmc_power( uint32_t *row_ops, float *tpower ){\n  *row_ops = __row_ops;\n  *tpower  = __transient_power;\n}\n\n/* EOF */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-goblin-hmc-sim-8.0.0-a7nt4y4kryj4p2fo5ivlkbtgix3k66od/spack-src/test/dyn_cmc/src/.execute_test.c.swp"
    ],
    "total_files": 280
}