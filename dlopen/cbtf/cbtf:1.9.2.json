{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-1.9.2-yybpzusk7umeqpmntjt2ac73dxlitjm6/spack-src/libcbtf/ComponentImpl.cpp": "////////////////////////////////////////////////////////////////////////////////\n// Copyright (c) 2010,2011 Krell Institute. All Rights Reserved.\n//\n// This program is free software; you can redistribute it and/or modify it under\n// the terms of the GNU General Public License as published by the Free Software\n// Foundation; either version 2 of the License, or (at your option) any later\n// version.\n//\n// This program is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n// details.\n//\n// You should have received a copy of the GNU General Public License along with\n// this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n// Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\n/** @file Definition of the ComponentImpl class. */\n\n#include <boost/assert.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/format.hpp>\n#include <boost/thread/locks.hpp>\n#include <dlfcn.h>\n#include <set>\n#include <stdexcept>\n\n#include \"ComponentImpl.hpp\"\n#include \"Global.hpp\"\n#include \"Raise.hpp\"\n#include \"ResolvePath.hpp\"\n\nusing namespace KrellInstitute::CBTF;\nusing namespace KrellInstitute::CBTF::Impl;\n\n\n\n/** Anonymous namespace hiding implementation details. */\nnamespace {\n\n    /** Global associative container used to track the loaded plugins. */\n    KRELL_INSTITUTE_CBTF_IMPL_GLOBAL(Plugins, std::set<boost::filesystem::path>)\n\n    /** \n     * Global associative container mapping the available component\n     * types and versions to their corresponding factory function.\n     */\n    KRELL_INSTITUTE_CBTF_IMPL_GLOBAL(\n        Factories,\n        std::map<\n            Type BOOST_PP_COMMA() \n            std::map<Version BOOST_PP_COMMA() Component::FactoryFunction>\n            >\n        )\n    \n} // namespace <anonymous>\n\n\n\n//------------------------------------------------------------------------------\n// Load the module with the specified path (after path resolution) if it hasn't\n// already been loaded. Loading a module causes all of the components contained\n// within that module to be registered with this class.\n//------------------------------------------------------------------------------\nvoid ComponentImpl::registerPlugin(const boost::filesystem::path& path)\n{\n    boost::filesystem::path resolved_path = resolvePath(kPluginFileType, path);\n\n    if (resolved_path.empty())\n    {\n        raise<std::runtime_error>(\n            \"The specified plugin (%1%) doesn't exist.\", path\n            );\n    }\n    \n    Plugins::GuardType guard_plugins(Plugins::mutex());\n\n    if (Plugins::value().find(resolved_path) != Plugins::value().end())\n    {\n        return;\n    }\n    \n    if (dlopen(resolved_path.string().c_str(), RTLD_NOW) == NULL)\n    {\n        raise<std::runtime_error>(\n            \"The specified plugin (%1%) doesn't exist or is not \"\n            \"of the correct format. dlopen() reported \\\"%2%\\\".\",\n            resolved_path, dlerror()\n            );\n    }\n    \n    Plugins::value().insert(path);\n}\n\n\n\n//------------------------------------------------------------------------------\n// Add the specified component factory function to the set of available\n// components. Doing so requires instantiating the component in order to\n// obtain its type and version.\n//------------------------------------------------------------------------------\nvoid ComponentImpl::registerFactoryFunction(\n    const Component::FactoryFunction& function\n    )\n{\n    Component::Instance instance = function();\n\n    Factories::GuardType guard_factories(Factories::mutex());\n    \n    Factories::Type::iterator i = Factories::value().find(instance->getType());\n    if (i == Factories::value().end())\n    {\n        i = Factories::value().insert(\n            std::make_pair(instance->getType(), Factories::Type::mapped_type())\n            ).first;\n    }\n    \n    i->second.insert(std::make_pair(instance->getVersion(), function));\n}\n\n\n\n//------------------------------------------------------------------------------\n// Construct and return the set of available component types.\n//------------------------------------------------------------------------------\nstd::set<Type> ComponentImpl::getAvailableTypes()\n{\n    Factories::GuardType guard_factories(Factories::mutex());\n\n    std::set<Type> available_types;\n    for (Factories::Type::const_iterator\n             i = Factories::value().begin(); i != Factories::value().end(); ++i)\n    {\n        available_types.insert(i->first);\n    }\n    \n    return available_types;\n}\n\n\n\n//------------------------------------------------------------------------------\n// Construct and return the set of available versions of the given component\n// type.\n//------------------------------------------------------------------------------\nstd::set<Version> ComponentImpl::getAvailableVersions(const Type& type)\n{\n    Factories::GuardType guard_factories(Factories::mutex());\n\n    Factories::Type::const_iterator i = Factories::value().find(type);\n    if (i == Factories::value().end())\n    {\n        raise<std::runtime_error>(\n            \"There are no available versions of \"\n            \"of the given component type (%1%).\",\n            type\n            );\n    }\n\n    std::set<Version> available_versions;\n    for (Factories::Type::mapped_type::const_iterator\n             j = i->second.begin(); j != i->second.end(); ++j)\n    {\n        available_versions.insert(j->first);\n    }\n    \n    return available_versions;\n}\n\n\n\n//------------------------------------------------------------------------------\n// Use the set of available components to find the component factory function\n// corresponding to the specified component type and version, then instantiate\n// the component and return it.\n//------------------------------------------------------------------------------\nComponent::Instance ComponentImpl::instantiate(\n    const Type& type,\n    const boost::optional<Version>& version\n    )\n{\n    Factories::GuardType guard_factories(Factories::mutex());\n\n    Factories::Type::const_iterator i = Factories::value().find(type);\n    if (i == Factories::value().end())\n    {\n        raise<std::runtime_error>(\n            \"There is no factory function registered \"\n            \"for the specified component type (%1%).\",\n            type\n            );\n    }\n\n    if (!version)\n    {\n        return i->second.rbegin()->second();\n    }\n\n    Factories::Type::mapped_type::const_iterator j = \n        i->second.find(version.get());\n\n    if (j == i->second.end())\n    {\n        raise<std::runtime_error>(\n            \"There is no factory function registered \"\n            \"for the specified component version (%1%).\",\n            *version\n            );\n    }\n    \n    return j->second();\n}\n\n\n\n//------------------------------------------------------------------------------\n// Check the validity of the specified connection and then add it to the\n// output component's connections.\n//------------------------------------------------------------------------------\nvoid ComponentImpl::connect(Component::Instance output_instance,\n                            const std::string& output_name,\n                            Component::Instance input_instance,\n                            const std::string& input_name)\n{\n    ComponentImpl& output_impl = *(output_instance->dm_impl);\n    ComponentImpl& input_impl = *(input_instance->dm_impl);\n\n    boost::unique_lock<boost::shared_mutex> guard_output(output_impl.dm_mutex);\n\n    boost::shared_ptr<boost::shared_lock<boost::shared_mutex> > guard_input;\n    if (input_instance->dm_impl != output_instance->dm_impl)\n    {\n        guard_input.reset(\n            new boost::shared_lock<boost::shared_mutex>(input_impl.dm_mutex)\n            );\n    }\n    \n    if (output_impl.dm_outputs.find(output_name) == \n        output_impl.dm_outputs.end())\n    {\n        raise<std::runtime_error>(\n            \"The requested output (%1%) doesn't exist.\", output_name\n            );\n    }\n    \n    if (input_impl.dm_inputs.find(input_name) ==\n        input_impl.dm_inputs.end())\n    {\n        raise<std::runtime_error>(\n            \"The requested input (%1%) doesn't exist.\", input_name\n            );\n    }\n    \n    if (output_impl.dm_outputs.find(output_name)->second !=\n        input_impl.dm_inputs.find(input_name)->second)\n    {\n        raise<std::runtime_error>(\n            \"The requested output (%1%) and input \"\n            \"(%2%) are not of compatible types.\",\n            output_name, input_name\n            );\n    }\n\n    const ConnectionMap::const_iterator i_begin =\n        output_impl.dm_connections.lower_bound(output_name);\n    const ConnectionMap::const_iterator i_end =\n        output_impl.dm_connections.upper_bound(output_name);\n\n    for (ConnectionMap::const_iterator i = i_begin; i != i_end; ++i)\n    {\n        Component::Instance i_instance = i->second.first.lock();\n\n        if (i_instance && (i_instance == input_instance) &&\n            (i->second.second == input_name))\n        {\n            raise<std::runtime_error>(\n                \"The requested output (%1%) and input (%2%) \"\n                \"are already connected to each other.\",\n                output_name, input_name\n                );\n        }\n    }\n\n    output_impl.dm_connections.insert(\n        std::make_pair(output_name, std::make_pair(input_instance, input_name))\n        );\n}\n\n\n\n//------------------------------------------------------------------------------\n// Check the validity of the specified connection and then remove it from the\n// output component's connections.\n//------------------------------------------------------------------------------\nvoid ComponentImpl::disconnect(Component::Instance output_instance,\n                               const std::string& output_name,\n                               Component::Instance input_instance,\n                               const std::string& input_name)\n{\n    ComponentImpl& output_impl = *(output_instance->dm_impl);\n    ComponentImpl& input_impl = *(input_instance->dm_impl);\n\n    boost::unique_lock<boost::shared_mutex> guard_output(output_impl.dm_mutex);\n\n    boost::shared_ptr<boost::shared_lock<boost::shared_mutex> > guard_input;\n    if (input_instance->dm_impl != output_instance->dm_impl)\n    {\n        guard_input.reset(\n            new boost::shared_lock<boost::shared_mutex>(input_impl.dm_mutex)\n            );\n    }\n    \n    if (output_impl.dm_outputs.find(output_name) ==\n        output_impl.dm_outputs.end())\n    {\n        raise<std::runtime_error>(\n            \"The requested output (%1%) doesn't exist.\", output_name\n            );\n    }\n    \n    if (input_impl.dm_inputs.find(input_name) ==\n        input_impl.dm_inputs.end())\n    {\n        raise<std::runtime_error>(\n            \"The requested input (%1%) doesn't exist.\", input_name\n            );\n    }\n\n    const ConnectionMap::iterator i_begin =\n        output_impl.dm_connections.lower_bound(output_name);\n    const ConnectionMap::iterator i_end =\n        output_impl.dm_connections.upper_bound(output_name);\n\n    for (ConnectionMap::iterator i = i_begin; i != i_end; ++i)\n    {\n        Component::Instance i_instance = i->second.first.lock();\n\n        if (i_instance && (i_instance == input_instance) &&\n            (i->second.second == input_name))\n        {\n            output_impl.dm_connections.erase(i);\n            return;\n        }\n    }\n    \n    raise<std::runtime_error>(\n        \"The requested output (%1%) and input \"\n        \"(%2%) are not connected to each other.\",\n        output_name, input_name\n        );\n}\n\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\nComponentImpl::ComponentImpl(const Type& type, const Version& version) :\n    dm_mutex(),\n    dm_type(type),\n    dm_version(version),\n    dm_inputs(),\n    dm_outputs(),\n    dm_handlers(),\n    dm_connections()\n{\n}\n\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\nComponentImpl::~ComponentImpl()\n{\n}\n\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\nstd::string ComponentImpl::getBuildString() const\n{\n#if defined(__GNUC__)\n    return boost::str(\n        boost::format(\"Built by GCC %1%.%2%.%3% at %4% on %5%.\")\n        % __GNUC__ % __GNUC_MINOR__ % __GNUC_PATCHLEVEL__ % __TIME__ % __DATE__\n        );    \n#else\n    return boost::str(\n        boost::format(\"Built by an unidentified compiler at %1% on %2%.\")\n        % __TIME__ % __DATE__\n        );\n#endif\n}\n\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\nType ComponentImpl::getType() const\n{\n    return dm_type;\n}\n\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\nVersion ComponentImpl::getVersion() const\n{\n    return dm_version;\n}\n\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\nstd::map<std::string, Type> ComponentImpl::getInputs() const\n{\n    boost::shared_lock<boost::shared_mutex> guard_this(dm_mutex);\n    return dm_inputs;\n}\n\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\nstd::map<std::string, Type> ComponentImpl::getOutputs() const\n{\n    boost::shared_lock<boost::shared_mutex> guard_this(dm_mutex);\n    return dm_outputs;\n}\n\n\n\n//------------------------------------------------------------------------------\n// Add the specified input to this component's inputs.\n//------------------------------------------------------------------------------\nvoid ComponentImpl::declareInputImpl(\n    const std::string& name,\n    const Type& type,\n    const boost::shared_ptr<Impl::Invoker>& handler\n    )\n{\n    boost::unique_lock<boost::shared_mutex> guard_this(dm_mutex);\n\n    if (dm_inputs.find(name) != dm_inputs.end())\n    {\n        raise<std::invalid_argument>(\n            \"An input has already been declared with the given name (%1%).\",\n            name\n            );\n    }\n\n    dm_inputs.insert(std::make_pair(name, type));\n    dm_handlers.insert(std::make_pair(name, handler));\n}\n\n\n\n//------------------------------------------------------------------------------\n// Add the specified output to this component's outputs.\n//------------------------------------------------------------------------------\nvoid ComponentImpl::declareOutputImpl(const std::string& name, const Type& type)\n{\n    boost::unique_lock<boost::shared_mutex> guard_this(dm_mutex);\n\n    if (dm_outputs.find(name) != dm_outputs.end())\n    {\n        raise<std::invalid_argument>(\n            \"An output has already been declared with the given name (%1%).\",\n            name\n            );\n    }\n\n    dm_outputs.insert(std::make_pair(name, type));\n}\n\n\n\n//------------------------------------------------------------------------------\n// Pass the specified output value to each of the component inputs to which\n// the given output is connected.\n//------------------------------------------------------------------------------\nvoid ComponentImpl::emitOutputImpl(const std::string& name, const Type& type,\n                                   const boost::any& value)\n{\n    boost::shared_lock<boost::shared_mutex> guard_this(dm_mutex);\n\n    if (dm_outputs.find(name) == dm_outputs.end())\n    {\n        raise<std::invalid_argument>(\n            \"The requested output (%1%) wasn't declared.\", name\n            );\n    }\n    if (dm_outputs.find(name)->second != type)\n    {\n        raise<std::invalid_argument>(\n            \"The given value type (%1%) doesn't \"\n            \"match the output's declared type (%2%).\",\n            type, dm_outputs.find(name)->second\n            );\n    }\n    \n    const ConnectionMap::const_iterator i_begin =\n        dm_connections.lower_bound(name);\n    const ConnectionMap::const_iterator i_end =\n        dm_connections.upper_bound(name);\n    \n    for (ConnectionMap::const_iterator i = i_begin; i != i_end; ++i)\n    {\n        Component::Instance i_instance = i->second.first.lock();\n        if (!i_instance)\n        {\n            continue;\n        }\n\n        const ComponentImpl& input_impl = *(i_instance->dm_impl);\n        const std::string& input_name = i->second.second;\n\n        BOOST_ASSERT(input_impl.dm_inputs.find(input_name) !=\n                     input_impl.dm_inputs.end());\n        BOOST_ASSERT(input_impl.dm_inputs.find(input_name)->second == type);\n        \n        const HandlerMap::const_iterator j = \n            input_impl.dm_handlers.find(input_name);\n        if (j != input_impl.dm_handlers.end())\n        {\n            (*(j->second))(value);\n        }\n    }\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-1.9.2-yybpzusk7umeqpmntjt2ac73dxlitjm6/spack-src/.git/objects/pack/pack-a47816cf3adc11763526112c68fd56ac81a4be8b.pack",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-1.9.2-yybpzusk7umeqpmntjt2ac73dxlitjm6/spack-src/.git/objects/pack/pack-a47816cf3adc11763526112c68fd56ac81a4be8b.idx",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-1.9.2-yybpzusk7umeqpmntjt2ac73dxlitjm6/spack-src/doc/images/cbtf-1smaller2.png",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-1.9.2-yybpzusk7umeqpmntjt2ac73dxlitjm6/spack-src/doc/images/dcn_smaller.png",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-1.9.2-yybpzusk7umeqpmntjt2ac73dxlitjm6/spack-src/doc/images/cbtf-2smaller2.png",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-1.9.2-yybpzusk7umeqpmntjt2ac73dxlitjm6/spack-src/doc/tutorial/Tutorial.pages",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-1.9.2-yybpzusk7umeqpmntjt2ac73dxlitjm6/spack-src/doc/tutorial/Tutorial.pdf"
    ],
    "total_files": 150
}