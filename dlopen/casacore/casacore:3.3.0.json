{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/casa/OS/DynLib.cc": "//# DynLib.cc: Class to handle loading of dynamic libraries\n//# Copyright (C) 2009\n//# Associated Universities, Inc. Washington DC, USA.\n//#\n//# This library is free software; you can redistribute it and/or modify it\n//# under the terms of the GNU Library General Public License as published by\n//# the Free Software Foundation; either version 2 of the License, or (at your\n//# option) any later version.\n//#\n//# This library is distributed in the hope that it will be useful, but WITHOUT\n//# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n//# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public\n//# License for more details.\n//#\n//# You should have received a copy of the GNU Library General Public License\n//# along with this library; if not, write to the Free Software Foundation,\n//# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.\n//#\n//# Correspondence concerning AIPS++ should be addressed as follows:\n//#        Internet email: aips2-request@nrao.edu.\n//#        Postal address: AIPS++ Project Office\n//#                        National Radio Astronomy Observatory\n//#                        520 Edgemont Road\n//#                        Charlottesville, VA 22903-2475 USA\n//#\n//# $Id$\n\n//# For the time being assume that all systems have dlopen.\n#ifndef HAVE_DLOPEN\n# define HAVE_DLOPEN\n#endif\n\n//# Includes\n#include <casacore/casa/OS/DynLib.h>\n#include <casacore/casa/OS/EnvVar.h>\n#include <casacore/casa/BasicSL/String.h>\n#include <casacore/casa/Arrays/Array.h>\n#include <casacore/casa/Utilities/Assert.h>\n#include <casacore/casa/Logging/LogIO.h>\n#include <casacore/casa/Exceptions/Error.h>\n#ifdef HAVE_DLOPEN\n#include <dlfcn.h>\n#endif\n\nusing namespace std;\n\nnamespace casacore { //# NAMESPACE CASACORE - BEGIN\n\n  DynLib::DynLib (const std::string& library,\n                  const std::string& prefix,\n                  const std::string& funcName,\n                  bool closeOnDestruction)\n    : itsHandle  (0),\n      itsDoClose (closeOnDestruction)\n  {\n    attach (library, prefix, std::string(), funcName);\n  }\n\n  DynLib::DynLib (const std::string& library,\n                  const std::string& prefix,\n                  const std::string& version,\n                  const std::string& funcName,\n                  bool closeOnDestruction)\n    : itsHandle  (0),\n      itsDoClose (closeOnDestruction)\n  {\n    // Add a dot to the version if needed.\n    std::string vers(version);\n    if (! vers.empty()  &&  vers[0] != '.') {\n      vers = '.' + vers;\n    }\n    attach (library, prefix, vers, funcName);\n  }\n\n  DynLib::DynLib (const std::string& library,\n                  Bool closeOnDestruction,\n                  const std::string& prefix,\n                  const std::string& suffix)\n    : itsHandle  (0),\n      itsDoClose (closeOnDestruction)\n  {\n    open (prefix + library + suffix);\n  }\n\n  DynLib::~DynLib()\n  {\n    if (itsDoClose) {\n      close();\n    }\n  }\n\n  void* DynLib::getFunc (const std::string& funcName)\n  {\n    itsError.clear();\n#ifdef HAVE_DLOPEN\n    if (itsHandle ) {\n      void* fptr = dlsym (itsHandle, funcName.c_str());\n      if (fptr == 0) {\n        itsError = dlerror();\n      }\n      return fptr;\n    }\n#endif\n    return 0;\n  }\n\n  void DynLib::open (const std::string& name)\n  {\n#ifdef HAVE_DLOPEN\n    itsHandle = dlopen (name.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (itsHandle == 0) {\n      itsError += string(dlerror()) + '\\n';\n    }\n#endif\n  }\n\n  void DynLib::close()\n  {\n    if (itsHandle) {\n#ifdef HAVE_DLOPEN\n      dlclose (itsHandle);\n#endif\n      itsHandle= 0;\n    }\n  }\n\n  std::string DynLib::tryOpen (const std::string& library,\n                               const std::string& dir,\n                               const std::string& prefix,\n                               const std::string& version)\n  {\n    std::string pref(prefix);\n    std::string vers(version);\n    std::string fullName;\n    // Try a maximum 4 times (1 or 2 prefix, 1 or 2 version, 1 ext).\n    int i=0;\n    while (i<4  &&  itsHandle==0) {\n#ifdef __APPLE__\n      fullName = dir + pref + library + vers + \".dylib\";\n#else\n      fullName = dir + pref + library + \".so\" + vers;\n#endif\n      open (fullName);\n      i++;\n      if (i == 2) {\n        if (pref == \"lib\") i += 2;     // no specific prefix given\n        pref = \"lib\";\n      }\n      if (i%2 == 1) {\n        vers = std::string();\n        if (version.empty()) i++;      // no version given\n      } else {\n        vers = version; \n      }\n    }\n    return (itsHandle==0  ?  std::string() : fullName);\n  }\n\n  void DynLib::attach (const std::string& library,\n                       const std::string& prefix,\n                       const std::string& version,\n                       const std::string& funcName)\n  {\n    std::string fullName = tryCasacorePath (library, prefix, version);\n    if (fullName.empty()) {\n      fullName = tryOpen (library, string(), prefix, version);\n    }\n    if (itsHandle == 0) {\n      throw AipsError (\"Shared library \" + library +\n                       \" not found in CASACORE_LDPATH or (DY)LD_LIBRARY_PATH\\n\"\n                       + itsError);\n    }\n    LogIO os(LogOrigin(\"DynLib\"));\n    os << LogIO::NORMAL3\n       << \"Loaded shared library \" << fullName\n       << LogIO::POST;\n    if (itsHandle  &&  !funcName.empty()) {\n      // Found the dynamic library.\n      // Now find and execute the given function.\n      // Because a compiler like g++ gives a warning when casting a pointer\n      // to a function pointer, a union is used to achieve this.\n      // Ensure the pointer sizes are the same.\n      typedef void (*func_ptr)();\n      AlwaysAssert (sizeof(func_ptr) == sizeof(void*), AipsError);\n      typedef union {\n\tfunc_ptr funcPtr;\n\tvoid* ptr;\n      } ptrCastUnion;\n      ptrCastUnion ptrCast;\n      ptrCast.ptr = getFunc (funcName.c_str());\n      if (! ptrCast.ptr) {\n        close();\n        throw AipsError(\"Found dynamic library \" + fullName +\n                        \", but not its \" + funcName + \" function\\n  \" +\n                        itsError);\n      }\n/// Note: the following is a g++ specific way to avoid the warning.\n///#ifdef __GNUC__\n///__extension__\n///#endif\n      // Execute the function.\n      ptrCast.funcPtr();\n      os << LogIO::NORMAL3\n         << \"Executed \" << funcName << \" in shared library \" << fullName\n         << LogIO::POST;\n    }\n  }\n\n  std::string DynLib::tryCasacorePath (const std::string& library,\n                                       const std::string& prefix,\n                                       const std::string& version)\n  {\n    // Check if CASACORE_LDPATH is defined.\n    String casapath(\"CASACORE_LDPATH\");\n    String path = EnvironmentVariable::get(casapath);\n    if (! path.empty()) {\n      // Split using : as delimiter.\n      Vector<String> parts = stringToVector (path, ':');\n      for (uInt j=0; j<parts.size(); ++j) {\n        if (! parts[j].empty()) {\n          string libDir = parts[j] + '/';\n          // Check if shared library can be found there.\n          std::string fullName = tryOpen (library, libDir, prefix, version);\n          if (itsHandle) {\n            return fullName;\n          }\n        }\n      }\n    }\n    return std::string();\n  }\n\n} //# NAMESPACE CASACORE - END\n",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/casa/OS/DynLib.h": "//# DynLib.h: Class to handle loadig of dynamic libraries\n//# Copyright (C) 2009\n//# Associated Universities, Inc. Washington DC, USA.\n//#\n//# This library is free software; you can redistribute it and/or modify it\n//# under the terms of the GNU Library General Public License as published by\n//# the Free Software Foundation; either version 2 of the License, or (at your\n//# option) any later version.\n//#\n//# This library is distributed in the hope that it will be useful, but WITHOUT\n//# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n//# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public\n//# License for more details.\n//#\n//# You should have received a copy of the GNU Library General Public License\n//# along with this library; if not, write to the Free Software Foundation,\n//# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.\n//#\n//# Correspondence concerning AIPS++ should be addressed as follows:\n//#        Internet email: aips2-request@nrao.edu.\n//#        Postal address: AIPS++ Project Office\n//#                        National Radio Astronomy Observatory\n//#                        520 Edgemont Road\n//#                        Charlottesville, VA 22903-2475 USA\n//#\n//# $Id$\n\n#ifndef CASA_DYNLIB_H\n#define CASA_DYNLIB_H\n\n//# Includes\n#include <casacore/casa/aips.h>\n#include <string>\n\nnamespace casacore { //# NAMESPACE CASACORE - BEGIN\n\n  // <summary> \n  // Class to handle loading of dynamic libraries\n  // </summary>\n  // <reviewed reviewer=\"UNKNOWN\" date=\"before2004/08/25\" tests=\"\" demos=\"\">\n  // </reviewed>\n\n  // <use visibility=export>\n\n  // <prerequisite> \n  //    <li> Basic knowledge of the dlopen function family\n  // </prerequisite>\n\n  // <synopsis> \n  // This class makes it possible to load a dynamic library and execute an\n  // initialization function. Furthermore, one can get a pointer to any function\n  // in the dynamic library and close the library.\n  //\n  // The search path of the shared library is as follows:\n  // <ul>\n  //  <li> If the environment library CASACORE_LDPATH is defined, it is tried to\n  //       find the library using that path.\n  //  <li> If not defined or not found, the system's (DY)LD_LIBRARY_PATH is used.\n  //  <li> The library looked for has the name 'prefix'libname'suffix'.\n  //       <br>As prefix first \"lib\" is used, thereafter the given one\n  //       (e.g., \"libcasa_\").\n  //       <br>As suffix first \".so\" is used, thereafter \".dylib\" (for OS-X).\n  // </ul>\n  //\n  // It is a wrapper around functions dlopen, dlsym, and dlclose.\n  // If dlopen and so are not supported on a platform, the class acts as if\n  // the shared library could not be found.\n  // </synopsis>\n\n  // <example>\n  // <srcblock>\n  //    DynLib dl(\"derivedmscal\", \"libcasa_\", \"register_derivedmscal\");\n  //    AlwaysAssert (dl.getHandle());\n  // </srcblock>\n  // Using this \n  //  loads the shared library <src>libcasa_derivedmscal.so</src> and\n  //  executes the given register initialization function.\n  // </example>\n\n  // <motivation> \n  // dlopen is a standard UNIX system call, but some operating systems\n  // do not support it or have different function names (notably Windows).\n  // In this way use of dynamic libraries is centralized and can easily b\n  // tailored as needed.\n  // </motivation>\n\n  class DynLib\n  {\n  public:\n\n    // Load the dynamic library. It is tried with prefixes <src>prefix</src>\n    // and \"lib\" (in that order) and with suffix \".so\" or \".dylib\" (for Apple).\n    // No library version number is used.\n    // If not loaded successfully, an exception is thrown.\n    // <br>If a non-empty funcName is given, that function is looked up and\n    // executed for initialization purposes. Its signature must be\n    // <src>void func()</src>.\n    // Note that the function name should not be mangled, thus declared\n    // <src>extern \"C\"</src>.\n    // An exception is thrown if the library is loaded successfully, but\n    // <src>funcName</src> could not be found.\n    // <br>If <src>closeOnDestruction=True</src>, the dynamic library is\n    // closed on destruction of the DynLib object.\n    DynLib (const std::string& library,\n            const std::string& prefix=std::string(),\n            const std::string& funcName=std::string(),\n            bool closeOnDestruction=True);\n\n    // The same as above, but it is tried with and without the given version\n    // (in that order).\n    DynLib (const std::string& library,\n            const std::string& prefix,\n            const std::string& version,\n            const std::string& funcName,\n            bool closeOnDestruction=True);\n\n    // Load the dynamic library with the given name, prefix, and suffix.\n    // If not loaded successfully, the internal handle is NULL.\n    // <br>If <src>closeOnDestruction=True</src>, the dynamic library is closed\n    // when the DynLib object is destructed.\n    DynLib (const std::string& library,\n            Bool closeOnDestruction,\n            const std::string& prefix=\"lib\",\n#ifdef __APPLE__\n            const std::string& suffix=\".dylib\");\n#else\n            const std::string& suffix=\".so\");\n#endif\n\n    // Close the dynamic library if told so in the constructor.\n    ~DynLib();\n\n    // Get a pointer to a function in the dynamic library.\n    // The pointer has to be casted with a reinterpret_cast to a function\n    // pointer with the correct signature. When compiling with -pedantic the\n    // compiler will give a warning for such a cast, because on some systems\n    // (in particular some micro-controllers) a data pointer differs from a\n    // function pointer. However, that problem cannot be solved.\n    // For example:\n    // <srcblock>\n    //   typedef Int MyFunc(Int, Int);\n    //   void* initfunc = DynLib::getFunc (mod, (\"register_\"+name).c_str());\n    //   if (initFunc) {\n    //     MyFunc* func = reinterpret_cast<MyFunc*>(initfunc);\n    //     Int result = func(1,2);\n    //   }\n    // </srcblock>\n    // casts to a function returning Int and taking two Ints.\n    // <br>A null pointer is returned if the function could not be found.\n    void* getFunc (const std::string& funcName);\n\n    // Get the dynamic library handle.\n    void* getHandle() const\n      { return itsHandle; }\n\n    // Get the possible error.\n    const std::string& getError() const\n      { return itsError; }\n\n  private:\n    // Try to open the library with some prefixes, suffixes and versions\n    // and to execute the initialization function.\n    // If successful, itsHandle is filled. Otherwise an exception is thrown.\n    void attach (const std::string& name,\n                 const std::string& prefix,\n                 const std::string& version,\n                 const std::string& funcName);\n\n    // Try to open the library with some prefixes, suffixes and versions\n    // If successful, itsHandle is filled and the full library name is\n    // returned. Otherwise an empty name is returned.\n    std::string tryOpen (const std::string& name,\n                         const std::string& libdir,\n                         const std::string& prefix,\n                         const std::string& version);\n\n    // Open (load) the dynamic library.\n    void open (const std::string& name);\n\n    // Close (unload) the dynamic library (if opened).\n    void close();\n\n    // Try if the library can be opened using CASACORE_LDPATH.\n    std::string tryCasacorePath (const std::string& library,\n                                 const std::string& prefix,\n                                 const std::string& version);\n\n    //# Handle to dynamic library; note that the pointer is not owned, so the\n    //# generated copy ctor and assignment are fine.\n    void*       itsHandle;\n    Bool        itsDoClose;\n    std::string itsError;\n  };\n\n} //# NAMESPACE CASACORE - END\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/cmake/FindDL.cmake": "# - find where dlopen and friends are located.\n# DL_FOUND - system has dynamic linking interface available\n# DL_INCLUDE_DIR - where dlfcn.h is located.\n# DL_LIBRARIES - libraries needed to use dlopen\n\ninclude(CheckFunctionExists)\n\nfind_path(DL_INCLUDE_DIR NAMES dlfcn.h)\nfind_library(DL_LIBRARIES NAMES dl)\nif(DL_LIBRARIES)\n  set(DL_FOUND)\nelse(DL_LIBRARIES)\n  check_function_exists(dlopen DL_FOUND)\n  # If dlopen can be found without linking in dl then dlopen is part\n  # of libc, so don't need to link extra libs.\n  set(DL_LIBRARIES \"\")\nendif(DL_LIBRARIES)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/qualityimage.fits",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/imageStats.fits",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/mexinputtest.fits",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/imagetestimage.fits",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/test_image.im/table.f0_TSM0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/test_image.im/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/test_image.im/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/test_image.im/table.lock",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/test_image.im/logtable/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/test_image.im/logtable/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/test_image.im/logtable/table.lock",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/decon_test.im/table.f0_TSM0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/decon_test.im/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/decon_test.im/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/decon_test.im/table.lock",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/decon_test.im/logtable/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/decon_test.im/logtable/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/images/Images/test/decon_test.im/logtable/table.lock",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/measures/Measures/test/tMeasIERS.in_tgz",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/casa/IO/IO_2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/casa/IO/IO_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/casa/OS/OS_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/casa/Containers/test/tHashMap.in_words.gz",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v1/table.f2",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v1/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v1/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v1/table.f0i0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v1/table.f1",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v0/table.f2",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v0/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v0/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v0/table.f0i0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/Tables/test/tTable_2.data_v0/table.f1",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/tables/DataMan/test/tSSMAddRemove.in",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/ms/MSSel/test/mssel_test_small_multifield_spw.ms.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/ms/MSSel/test/mssel_test_small.ms.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-ihi3wrdrbcgkzn4lr7fl3amrpcl5v5ii/spack-src/ms/MSOper/test/tMSSummary.in"
    ],
    "total_files": 3213
}