{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/make.py": "# Copyright (c) 2013 Google Inc. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n# Notes:\n#\n# This is all roughly based on the Makefile system used by the Linux\n# kernel, but is a non-recursive make -- we put the entire dependency\n# graph in front of make and let it figure it out.\n#\n# The code below generates a separate .mk file for each target, but\n# all are sourced by the top-level Makefile.  This means that all\n# variables in .mk-files clobber one another.  Be careful to use :=\n# where appropriate for immediate evaluation, and similarly to watch\n# that you're not relying on a variable value to last beween different\n# .mk files.\n#\n# TODOs:\n#\n# Global settings and utility functions are currently stuffed in the\n# toplevel Makefile.  It may make sense to generate some .mk files on\n# the side to keep the the files readable.\n\nimport os\nimport re\nimport sys\nimport subprocess\nimport gyp\nimport gyp.common\nimport gyp.xcode_emulation\nfrom gyp.common import GetEnvironFallback\nfrom gyp.common import GypError\n\ngenerator_default_variables = {\n  'EXECUTABLE_PREFIX': '',\n  'EXECUTABLE_SUFFIX': '',\n  'STATIC_LIB_PREFIX': 'lib',\n  'SHARED_LIB_PREFIX': 'lib',\n  'STATIC_LIB_SUFFIX': '.a',\n  'INTERMEDIATE_DIR': '$(obj).$(TOOLSET)/$(TARGET)/geni',\n  'SHARED_INTERMEDIATE_DIR': '$(obj)/gen',\n  'PRODUCT_DIR': '$(builddir)',\n  'RULE_INPUT_ROOT': '%(INPUT_ROOT)s',  # This gets expanded by Python.\n  'RULE_INPUT_DIRNAME': '%(INPUT_DIRNAME)s',  # This gets expanded by Python.\n  'RULE_INPUT_PATH': '$(abspath $<)',\n  'RULE_INPUT_EXT': '$(suffix $<)',\n  'RULE_INPUT_NAME': '$(notdir $<)',\n  'CONFIGURATION_NAME': '$(BUILDTYPE)',\n}\n\n# Make supports multiple toolsets\ngenerator_supports_multiple_toolsets = True\n\n# Request sorted dependencies in the order from dependents to dependencies.\ngenerator_wants_sorted_dependencies = False\n\n# Placates pylint.\ngenerator_additional_non_configuration_keys = []\ngenerator_additional_path_sections = []\ngenerator_extra_sources_for_rules = []\ngenerator_filelist_paths = None\n\n\ndef CalculateVariables(default_variables, params):\n  \"\"\"Calculate additional variables for use in the build (called by gyp).\"\"\"\n  flavor = gyp.common.GetFlavor(params)\n  if flavor == 'mac':\n    default_variables.setdefault('OS', 'mac')\n    default_variables.setdefault('SHARED_LIB_SUFFIX', '.dylib')\n    default_variables.setdefault('SHARED_LIB_DIR',\n                                 generator_default_variables['PRODUCT_DIR'])\n    default_variables.setdefault('LIB_DIR',\n                                 generator_default_variables['PRODUCT_DIR'])\n\n    # Copy additional generator configuration data from Xcode, which is shared\n    # by the Mac Make generator.\n    import gyp.generator.xcode as xcode_generator\n    global generator_additional_non_configuration_keys\n    generator_additional_non_configuration_keys = getattr(xcode_generator,\n        'generator_additional_non_configuration_keys', [])\n    global generator_additional_path_sections\n    generator_additional_path_sections = getattr(xcode_generator,\n        'generator_additional_path_sections', [])\n    global generator_extra_sources_for_rules\n    generator_extra_sources_for_rules = getattr(xcode_generator,\n        'generator_extra_sources_for_rules', [])\n    COMPILABLE_EXTENSIONS.update({'.m': 'objc', '.mm' : 'objcxx'})\n  else:\n    operating_system = flavor\n    if flavor == 'android':\n      operating_system = 'linux'  # Keep this legacy behavior for now.\n    default_variables.setdefault('OS', operating_system)\n    default_variables.setdefault('SHARED_LIB_SUFFIX', '.so')\n    default_variables.setdefault('SHARED_LIB_DIR','$(builddir)/lib.$(TOOLSET)')\n    default_variables.setdefault('LIB_DIR', '$(obj).$(TOOLSET)')\n\n\ndef CalculateGeneratorInputInfo(params):\n  \"\"\"Calculate the generator specific info that gets fed to input (called by\n  gyp).\"\"\"\n  generator_flags = params.get('generator_flags', {})\n  android_ndk_version = generator_flags.get('android_ndk_version', None)\n  # Android NDK requires a strict link order.\n  if android_ndk_version:\n    global generator_wants_sorted_dependencies\n    generator_wants_sorted_dependencies = True\n\n  output_dir = params['options'].generator_output or \\\n               params['options'].toplevel_dir\n  builddir_name = generator_flags.get('output_dir', 'out')\n  qualified_out_dir = os.path.normpath(os.path.join(\n    output_dir, builddir_name, 'gypfiles'))\n\n  global generator_filelist_paths\n  generator_filelist_paths = {\n    'toplevel': params['options'].toplevel_dir,\n    'qualified_out_dir': qualified_out_dir,\n  }\n\n\n# The .d checking code below uses these functions:\n# wildcard, sort, foreach, shell, wordlist\n# wildcard can handle spaces, the rest can't.\n# Since I could find no way to make foreach work with spaces in filenames\n# correctly, the .d files have spaces replaced with another character. The .d\n# file for\n#     Chromium\\ Framework.framework/foo\n# is for example\n#     out/Release/.deps/out/Release/Chromium?Framework.framework/foo\n# This is the replacement character.\nSPACE_REPLACEMENT = '?'\n\n\nLINK_COMMANDS_LINUX = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) crsT $@ $(filter %.o,$^)\n\n# Due to circular dependencies between libraries :(, we wrap the\n# special \"figure out circular dependencies\" flags around the entire\n# input list during linking.\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) -Wl,--end-group $(LIBS)\n\n# We support two kinds of shared objects (.so):\n# 1) shared_library, which is just bundling together many dependent libraries\n# into a link line.\n# 2) loadable_module, which is generating a module intended for dlopen().\n#\n# They differ only slightly:\n# In the former case, we want to package all dependent code into the .so.\n# In the latter case, we want to package just the API exposed by the\n# outermost module.\n# This means shared_library uses --whole-archive, while loadable_module doesn't.\n# (Note that --whole-archive is incompatible with the --start-group used in\n# normal linking.)\n\n# Other shared-object link notes:\n# - Set SONAME to the library filename so our binaries don't reference\n# the local, absolute paths used on the link command-line.\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--whole-archive $(LD_INPUTS) -Wl,--no-whole-archive $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--start-group $(filter-out FORCE_DO_CMD, $^) -Wl,--end-group $(LIBS)\n\"\"\"\n\nLINK_COMMANDS_MAC = \"\"\"\\\nquiet_cmd_alink = LIBTOOL-STATIC $@\ncmd_alink = rm -f $@ && ./gyp-mac-tool filter-libtool libtool $(GYP_LIBTOOLFLAGS) -static -o $@ $(filter %.o,$^)\n\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o \"$@\" $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o \"$@\" $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -bundle $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n\"\"\"\n\nLINK_COMMANDS_ANDROID = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) crsT $@ $(filter %.o,$^)\n\n# Due to circular dependencies between libraries :(, we wrap the\n# special \"figure out circular dependencies\" flags around the entire\n# input list during linking.\nquiet_cmd_link = LINK($(TOOLSET)) $@\nquiet_cmd_link_host = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) -Wl,--end-group $(LIBS)\ncmd_link_host = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\n# Other shared-object link notes:\n# - Set SONAME to the library filename so our binaries don't reference\n# the local, absolute paths used on the link command-line.\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--whole-archive $(LD_INPUTS) -Wl,--no-whole-archive $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--start-group $(filter-out FORCE_DO_CMD, $^) -Wl,--end-group $(LIBS)\nquiet_cmd_solink_module_host = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module_host = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n\"\"\"\n\n\nLINK_COMMANDS_AIX = \"\"\"\\\nquiet_cmd_alink = AR($(TOOLSET)) $@\ncmd_alink = rm -f $@ && $(AR.$(TOOLSET)) -X32_64 crs $@ $(filter %.o,$^)\n\nquiet_cmd_alink_thin = AR($(TOOLSET)) $@\ncmd_alink_thin = rm -f $@ && $(AR.$(TOOLSET)) -X32_64 crs $@ $(filter %.o,$^)\n\nquiet_cmd_link = LINK($(TOOLSET)) $@\ncmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink = SOLINK($(TOOLSET)) $@\ncmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(LD_INPUTS) $(LIBS)\n\nquiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\ncmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n\"\"\"\n\n\n# Header of toplevel Makefile.\n# This should go into the build tree, but it's easier to keep it here for now.\nSHARED_HEADER = (\"\"\"\\\n# We borrow heavily from the kernel build setup, though we are simpler since\n# we don't have Kconfig tweaking settings on us.\n\n# The implicit make rules have it looking for RCS files, among other things.\n# We instead explicitly write all the rules we care about.\n# It's even quicker (saves ~200ms) to pass -r on the command line.\nMAKEFLAGS=-r\n\n# The source directory tree.\nsrcdir := %(srcdir)s\nabs_srcdir := $(abspath $(srcdir))\n\n# The name of the builddir.\nbuilddir_name ?= %(builddir)s\n\n# The V=1 flag on command line makes us verbosely print command lines.\nifdef V\n  quiet=\nelse\n  quiet=quiet_\nendif\n\n# Specify BUILDTYPE=Release on the command line for a release build.\nBUILDTYPE ?= %(default_configuration)s\n\n# Directory all our build output goes into.\n# Note that this must be two directories beneath src/ for unit tests to pass,\n# as they reach into the src/ directory for data with relative paths.\nbuilddir ?= $(builddir_name)/$(BUILDTYPE)\nabs_builddir := $(abspath $(builddir))\ndepsdir := $(builddir)/.deps\n\n# Object output directory.\nobj := $(builddir)/obj\nabs_obj := $(abspath $(obj))\n\n# We build up a list of every single one of the targets so we can slurp in the\n# generated dependency rule Makefiles in one pass.\nall_deps :=\n\n%(make_global_settings)s\n\nCC.target ?= %(CC.target)s\nCFLAGS.target ?= $(CPPFLAGS) $(CFLAGS)\nCXX.target ?= %(CXX.target)s\nCXXFLAGS.target ?= $(CPPFLAGS) $(CXXFLAGS)\nLINK.target ?= %(LINK.target)s\nLDFLAGS.target ?= $(LDFLAGS)\nAR.target ?= $(AR)\n\n# C++ apps need to be linked with g++.\nLINK ?= $(CXX.target)\n\n# TODO(evan): move all cross-compilation logic to gyp-time so we don't need\n# to replicate this environment fallback in make as well.\nCC.host ?= %(CC.host)s\nCFLAGS.host ?= $(CPPFLAGS_host) $(CFLAGS_host)\nCXX.host ?= %(CXX.host)s\nCXXFLAGS.host ?= $(CPPFLAGS_host) $(CXXFLAGS_host)\nLINK.host ?= %(LINK.host)s\nLDFLAGS.host ?=\nAR.host ?= %(AR.host)s\n\n# Define a dir function that can handle spaces.\n# http://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions\n# \"leading spaces cannot appear in the text of the first argument as written.\n# These characters can be put into the argument value by variable substitution.\"\nempty :=\nspace := $(empty) $(empty)\n\n# http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\nreplace_spaces = $(subst $(space),\"\"\" + SPACE_REPLACEMENT + \"\"\",$1)\nunreplace_spaces = $(subst \"\"\" + SPACE_REPLACEMENT + \"\"\",$(space),$1)\ndirx = $(call unreplace_spaces,$(dir $(call replace_spaces,$1)))\n\n# Flags to make gcc output dependency info.  Note that you need to be\n# careful here to use the flags that ccache and distcc can understand.\n# We write to a dep file on the side first and then rename at the end\n# so we can't end up with a broken dep file.\ndepfile = $(depsdir)/$(call replace_spaces,$@).d\nDEPFLAGS = -MMD -MF $(depfile).raw\n\n# We have to fixup the deps output in a few ways.\n# (1) the file output should mention the proper .o file.\n# ccache or distcc lose the path to the target, so we convert a rule of\n# the form:\n#   foobar.o: DEP1 DEP2\n# into\n#   path/to/foobar.o: DEP1 DEP2\n# (2) we want missing files not to cause us to fail to build.\n# We want to rewrite\n#   foobar.o: DEP1 DEP2 \\\\\n#               DEP3\n# to\n#   DEP1:\n#   DEP2:\n#   DEP3:\n# so if the files are missing, they're just considered phony rules.\n# We have to do some pretty insane escaping to get those backslashes\n# and dollar signs past make, the shell, and sed at the same time.\n# Doesn't work with spaces, but that's fine: .d files have spaces in\n# their names replaced with other characters.\"\"\"\nr\"\"\"\ndefine fixup_dep\n# The depfile may not exist if the input file didn't have any #includes.\ntouch $(depfile).raw\n# Fixup path as in (1).\nsed -e \"s|^$(notdir $@)|$@|\" $(depfile).raw >> $(depfile)\n# Add extra rules as in (2).\n# We remove slashes and replace spaces with new lines;\n# remove blank lines;\n# delete the first line and append a colon to the remaining lines.\nsed -e 's|\\\\||' -e 'y| |\\n|' $(depfile).raw |\\\n  grep -v '^$$'                             |\\\n  sed -e 1d -e 's|$$|:|'                     \\\n    >> $(depfile)\nrm $(depfile).raw\nendef\n\"\"\"\n\"\"\"\n# Command definitions:\n# - cmd_foo is the actual command to run;\n# - quiet_cmd_foo is the brief-output summary of the command.\n\nquiet_cmd_cc = CC($(TOOLSET)) $@\ncmd_cc = $(CC.$(TOOLSET)) $(GYP_CFLAGS) $(DEPFLAGS) $(CFLAGS.$(TOOLSET)) -c -o $@ $<\n\nquiet_cmd_cxx = CXX($(TOOLSET)) $@\ncmd_cxx = $(CXX.$(TOOLSET)) $(GYP_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\n%(extra_commands)s\nquiet_cmd_touch = TOUCH $@\ncmd_touch = touch $@\n\nquiet_cmd_copy = COPY $@\n# send stderr to /dev/null to ignore messages when linking directories.\ncmd_copy = rm -rf \"$@\" && cp %(copy_archive_args)s \"$<\" \"$@\"\n\n%(link_commands)s\n\"\"\"\n\nr\"\"\"\n# Define an escape_quotes function to escape single quotes.\n# This allows us to handle quotes properly as long as we always use\n# use single quotes and escape_quotes.\nescape_quotes = $(subst ','\\'',$(1))\n# This comment is here just to include a ' to unconfuse syntax highlighting.\n# Define an escape_vars function to escape '$' variable syntax.\n# This allows us to read/write command lines with shell variables (e.g.\n# $LD_LIBRARY_PATH), without triggering make substitution.\nescape_vars = $(subst $$,$$$$,$(1))\n# Helper that expands to a shell command to echo a string exactly as it is in\n# make. This uses printf instead of echo because printf's behaviour with respect\n# to escape sequences is more portable than echo's across different shells\n# (e.g., dash, bash).\nexact_echo = printf '%%s\\n' '$(call escape_quotes,$(1))'\n\"\"\"\n\"\"\"\n# Helper to compare the command we're about to run against the command\n# we logged the last time we ran the command.  Produces an empty\n# string (false) when the commands match.\n# Tricky point: Make has no string-equality test function.\n# The kernel uses the following, but it seems like it would have false\n# positives, where one string reordered its arguments.\n#   arg_check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \\\\\n#                       $(filter-out $(cmd_$@), $(cmd_$(1))))\n# We instead substitute each for the empty string into the other, and\n# say they're equal if both substitutions produce the empty string.\n# .d files contain \"\"\" + SPACE_REPLACEMENT + \\\n                   \"\"\" instead of spaces, take that into account.\ncommand_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\\\n                       $(subst $(cmd_$(call replace_spaces,$@)),,$(cmd_$(1))))\n\n# Helper that is non-empty when a prerequisite changes.\n# Normally make does this implicitly, but we force rules to always run\n# so we can check their command lines.\n#   $? -- new prerequisites\n#   $| -- order-only dependencies\nprereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n\n# Helper that executes all postbuilds until one fails.\ndefine do_postbuilds\n  @E=0;\\\\\n  for p in $(POSTBUILDS); do\\\\\n    eval $$p;\\\\\n    E=$$?;\\\\\n    if [ $$E -ne 0 ]; then\\\\\n      break;\\\\\n    fi;\\\\\n  done;\\\\\n  if [ $$E -ne 0 ]; then\\\\\n    rm -rf \"$@\";\\\\\n    exit $$E;\\\\\n  fi\nendef\n\n# do_cmd: run a command via the above cmd_foo names, if necessary.\n# Should always run for a given target to handle command-line changes.\n# Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n# Third argument, if non-zero, makes it do POSTBUILDS processing.\n# Note: We intentionally do NOT call dirx for depfile, since it contains \"\"\" + \\\n                                                     SPACE_REPLACEMENT + \"\"\" for\n# spaces already and dirx strips the \"\"\" + SPACE_REPLACEMENT + \\\n                                     \"\"\" characters.\ndefine do_cmd\n$(if $(or $(command_changed),$(prereq_changed)),\n  @$(call exact_echo,  $($(quiet)cmd_$(1)))\n  @mkdir -p \"$(call dirx,$@)\" \"$(dir $(depfile))\"\n  $(if $(findstring flock,$(word %(flock_index)d,$(cmd_$1))),\n    @$(cmd_$(1))\n    @echo \"  $(quiet_cmd_$(1)): Finished\",\n    @$(cmd_$(1))\n  )\n  @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n  @$(if $(2),$(fixup_dep))\n  $(if $(and $(3), $(POSTBUILDS)),\n    $(call do_postbuilds)\n  )\n)\nendef\n\n# Declare the \"%(default_target)s\" target first so it is the default,\n# even though we don't have the deps yet.\n.PHONY: %(default_target)s\n%(default_target)s:\n\n# make looks for ways to re-generate included makefiles, but in our case, we\n# don't have a direct way. Explicitly telling make that it has nothing to do\n# for them makes it go faster.\n%%.d: ;\n\n# Use FORCE_DO_CMD to force a target to run.  Should be coupled with\n# do_cmd.\n.PHONY: FORCE_DO_CMD\nFORCE_DO_CMD:\n\n\"\"\")\n\nSHARED_HEADER_MAC_COMMANDS = \"\"\"\nquiet_cmd_objc = CXX($(TOOLSET)) $@\ncmd_objc = $(CC.$(TOOLSET)) $(GYP_OBJCFLAGS) $(DEPFLAGS) -c -o $@ $<\n\nquiet_cmd_objcxx = CXX($(TOOLSET)) $@\ncmd_objcxx = $(CXX.$(TOOLSET)) $(GYP_OBJCXXFLAGS) $(DEPFLAGS) -c -o $@ $<\n\n# Commands for precompiled header files.\nquiet_cmd_pch_c = CXX($(TOOLSET)) $@\ncmd_pch_c = $(CC.$(TOOLSET)) $(GYP_PCH_CFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\nquiet_cmd_pch_cc = CXX($(TOOLSET)) $@\ncmd_pch_cc = $(CC.$(TOOLSET)) $(GYP_PCH_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\nquiet_cmd_pch_m = CXX($(TOOLSET)) $@\ncmd_pch_m = $(CC.$(TOOLSET)) $(GYP_PCH_OBJCFLAGS) $(DEPFLAGS) -c -o $@ $<\nquiet_cmd_pch_mm = CXX($(TOOLSET)) $@\ncmd_pch_mm = $(CC.$(TOOLSET)) $(GYP_PCH_OBJCXXFLAGS) $(DEPFLAGS) -c -o $@ $<\n\n# gyp-mac-tool is written next to the root Makefile by gyp.\n# Use $(4) for the command, since $(2) and $(3) are used as flag by do_cmd\n# already.\nquiet_cmd_mac_tool = MACTOOL $(4) $<\ncmd_mac_tool = ./gyp-mac-tool $(4) $< \"$@\"\n\nquiet_cmd_mac_package_framework = PACKAGE FRAMEWORK $@\ncmd_mac_package_framework = ./gyp-mac-tool package-framework \"$@\" $(4)\n\nquiet_cmd_infoplist = INFOPLIST $@\ncmd_infoplist = $(CC.$(TOOLSET)) -E -P -Wno-trigraphs -x c $(INFOPLIST_DEFINES) \"$<\" -o \"$@\"\n\"\"\"\n\n\ndef WriteRootHeaderSuffixRules(writer):\n  extensions = sorted(COMPILABLE_EXTENSIONS.keys(), key=str.lower)\n\n  writer.write('# Suffix rules, putting all outputs into $(obj).\\n')\n  for ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(srcdir)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\n\n  writer.write('\\n# Try building from generated source, too.\\n')\n  for ext in extensions:\n    writer.write(\n        '$(obj).$(TOOLSET)/%%.o: $(obj).$(TOOLSET)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\n  writer.write('\\n')\n  for ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(obj)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\n  writer.write('\\n')\n\n\nSHARED_HEADER_SUFFIX_RULES_COMMENT1 = (\"\"\"\\\n# Suffix rules, putting all outputs into $(obj).\n\"\"\")\n\n\nSHARED_HEADER_SUFFIX_RULES_COMMENT2 = (\"\"\"\\\n# Try building from generated source, too.\n\"\"\")\n\n\nSHARED_FOOTER = \"\"\"\\\n# \"all\" is a concatenation of the \"all\" targets from all the included\n# sub-makefiles. This is just here to clarify.\nall:\n\n# Add in dependency-tracking rules.  $(all_deps) is the list of every single\n# target in our tree. Only consider the ones with .d (dependency) info:\nd_files := $(wildcard $(foreach f,$(all_deps),$(depsdir)/$(f).d))\nifneq ($(d_files),)\n  include $(d_files)\nendif\n\"\"\"\n\nheader = \"\"\"\\\n# This file is generated by gyp; do not edit.\n\n\"\"\"\n\n# Maps every compilable file extension to the do_cmd that compiles it.\nCOMPILABLE_EXTENSIONS = {\n  '.c': 'cc',\n  '.cc': 'cxx',\n  '.cpp': 'cxx',\n  '.cxx': 'cxx',\n  '.s': 'cc',\n  '.S': 'cc',\n}\n\ndef Compilable(filename):\n  \"\"\"Return true if the file is compilable (should be in OBJS).\"\"\"\n  for res in (filename.endswith(e) for e in COMPILABLE_EXTENSIONS):\n    if res:\n      return True\n  return False\n\n\ndef Linkable(filename):\n  \"\"\"Return true if the file is linkable (should be on the link line).\"\"\"\n  return filename.endswith('.o')\n\n\ndef Target(filename):\n  \"\"\"Translate a compilable filename to its .o target.\"\"\"\n  return os.path.splitext(filename)[0] + '.o'\n\n\ndef EscapeShellArgument(s):\n  \"\"\"Quotes an argument so that it will be interpreted literally by a POSIX\n     shell. Taken from\n     http://stackoverflow.com/questions/35817/whats-the-best-way-to-escape-ossystem-calls-in-python\n     \"\"\"\n  return \"'\" + s.replace(\"'\", \"'\\\\''\") + \"'\"\n\n\ndef EscapeMakeVariableExpansion(s):\n  \"\"\"Make has its own variable expansion syntax using $. We must escape it for\n     string to be interpreted literally.\"\"\"\n  return s.replace('$', '$$')\n\n\ndef EscapeCppDefine(s):\n  \"\"\"Escapes a CPP define so that it will reach the compiler unaltered.\"\"\"\n  s = EscapeShellArgument(s)\n  s = EscapeMakeVariableExpansion(s)\n  # '#' characters must be escaped even embedded in a string, else Make will\n  # treat it as the start of a comment.\n  return s.replace('#', r'\\#')\n\n\ndef QuoteIfNecessary(string):\n  \"\"\"TODO: Should this ideally be replaced with one or more of the above\n     functions?\"\"\"\n  if '\"' in string:\n    string = '\"' + string.replace('\"', '\\\\\"') + '\"'\n  return string\n\n\ndef StringToMakefileVariable(string):\n  \"\"\"Convert a string to a value that is acceptable as a make variable name.\"\"\"\n  return re.sub('[^a-zA-Z0-9_]', '_', string)\n\n\nsrcdir_prefix = ''\ndef Sourceify(path):\n  \"\"\"Convert a path to its source directory form.\"\"\"\n  if '$(' in path:\n    return path\n  if os.path.isabs(path):\n    return path\n  return srcdir_prefix + path\n\n\ndef QuoteSpaces(s, quote=r'\\ '):\n  return s.replace(' ', quote)\n\n\n# TODO: Avoid code duplication with _ValidateSourcesForMSVSProject in msvs.py.\ndef _ValidateSourcesForOSX(spec, all_sources):\n  \"\"\"Makes sure if duplicate basenames are not specified in the source list.\n\n  Arguments:\n    spec: The target dictionary containing the properties of the target.\n  \"\"\"\n  if spec.get('type', None) != 'static_library':\n    return\n\n  basenames = {}\n  for source in all_sources:\n    name, ext = os.path.splitext(source)\n    is_compiled_file = ext in [\n        '.c', '.cc', '.cpp', '.cxx', '.m', '.mm', '.s', '.S']\n    if not is_compiled_file:\n      continue\n    basename = os.path.basename(name)  # Don't include extension.\n    basenames.setdefault(basename, []).append(source)\n\n  error = ''\n  for basename, files in basenames.iteritems():\n    if len(files) > 1:\n      error += '  %s: %s\\n' % (basename, ' '.join(files))\n\n  if error:\n    print('static library %s has several files with the same basename:\\n' %\n          spec['target_name'] + error + 'libtool on OS X will generate' +\n          ' warnings for them.')\n    raise GypError('Duplicate basenames in sources section, see list above')\n\n\n# Map from qualified target to path to output.\ntarget_outputs = {}\n# Map from qualified target to any linkable output.  A subset\n# of target_outputs.  E.g. when mybinary depends on liba, we want to\n# include liba in the linker line; when otherbinary depends on\n# mybinary, we just want to build mybinary first.\ntarget_link_deps = {}\n\n\nclass MakefileWriter(object):\n  \"\"\"MakefileWriter packages up the writing of one target-specific foobar.mk.\n\n  Its only real entry point is Write(), and is mostly used for namespacing.\n  \"\"\"\n\n  def __init__(self, generator_flags, flavor):\n    self.generator_flags = generator_flags\n    self.flavor = flavor\n\n    self.suffix_rules_srcdir = {}\n    self.suffix_rules_objdir1 = {}\n    self.suffix_rules_objdir2 = {}\n\n    # Generate suffix rules for all compilable extensions.\n    for ext in COMPILABLE_EXTENSIONS.keys():\n      # Suffix rules for source folder.\n      self.suffix_rules_srcdir.update({ext: (\"\"\"\\\n$(obj).$(TOOLSET)/$(TARGET)/%%.o: $(srcdir)/%%%s FORCE_DO_CMD\n\t@$(call do_cmd,%s,1)\n\"\"\" % (ext, COMPILABLE_EXTENSIONS[ext]))})\n\n      # Suffix rules for generated source files.\n      self.suffix_rules_objdir1.update({ext: (\"\"\"\\\n$(obj).$(TOOLSET)/$(TARGET)/%%.o: $(obj).$(TOOLSET)/%%%s FORCE_DO_CMD\n\t@$(call do_cmd,%s,1)\n\"\"\" % (ext, COMPILABLE_EXTENSIONS[ext]))})\n      self.suffix_rules_objdir2.update({ext: (\"\"\"\\\n$(obj).$(TOOLSET)/$(TARGET)/%%.o: $(obj)/%%%s FORCE_DO_CMD\n\t@$(call do_cmd,%s,1)\n\"\"\" % (ext, COMPILABLE_EXTENSIONS[ext]))})\n\n\n  def Write(self, qualified_target, base_path, output_filename, spec, configs,\n            part_of_all):\n    \"\"\"The main entry point: writes a .mk file for a single target.\n\n    Arguments:\n      qualified_target: target we're generating\n      base_path: path relative to source root we're building in, used to resolve\n                 target-relative paths\n      output_filename: output .mk file name to write\n      spec, configs: gyp info\n      part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    gyp.common.EnsureDirExists(output_filename)\n\n    self.fp = open(output_filename, 'w')\n\n    self.fp.write(header)\n\n    self.qualified_target = qualified_target\n    self.path = base_path\n    self.target = spec['target_name']\n    self.type = spec['type']\n    self.toolset = spec['toolset']\n\n    self.is_mac_bundle = gyp.xcode_emulation.IsMacBundle(self.flavor, spec)\n    if self.flavor == 'mac':\n      self.xcode_settings = gyp.xcode_emulation.XcodeSettings(spec)\n    else:\n      self.xcode_settings = None\n\n    deps, link_deps = self.ComputeDeps(spec)\n\n    # Some of the generation below can add extra output, sources, or\n    # link dependencies.  All of the out params of the functions that\n    # follow use names like extra_foo.\n    extra_outputs = []\n    extra_sources = []\n    extra_link_deps = []\n    extra_mac_bundle_resources = []\n    mac_bundle_deps = []\n\n    if self.is_mac_bundle:\n      self.output = self.ComputeMacBundleOutput(spec)\n      self.output_binary = self.ComputeMacBundleBinaryOutput(spec)\n    else:\n      self.output = self.output_binary = self.ComputeOutput(spec)\n\n    self.is_standalone_static_library = bool(\n        spec.get('standalone_static_library', 0))\n    self._INSTALLABLE_TARGETS = ('executable', 'loadable_module',\n                                 'shared_library')\n    if (self.is_standalone_static_library or\n        self.type in self._INSTALLABLE_TARGETS):\n      self.alias = os.path.basename(self.output)\n      install_path = self._InstallableTargetInstallPath()\n    else:\n      self.alias = self.output\n      install_path = self.output\n\n    self.WriteLn(\"TOOLSET := \" + self.toolset)\n    self.WriteLn(\"TARGET := \" + self.target)\n\n    # Actions must come first, since they can generate more OBJs for use below.\n    if 'actions' in spec:\n      self.WriteActions(spec['actions'], extra_sources, extra_outputs,\n                        extra_mac_bundle_resources, part_of_all)\n\n    # Rules must be early like actions.\n    if 'rules' in spec:\n      self.WriteRules(spec['rules'], extra_sources, extra_outputs,\n                      extra_mac_bundle_resources, part_of_all)\n\n    if 'copies' in spec:\n      self.WriteCopies(spec['copies'], extra_outputs, part_of_all)\n\n    # Bundle resources.\n    if self.is_mac_bundle:\n      all_mac_bundle_resources = (\n          spec.get('mac_bundle_resources', []) + extra_mac_bundle_resources)\n      self.WriteMacBundleResources(all_mac_bundle_resources, mac_bundle_deps)\n      self.WriteMacInfoPlist(mac_bundle_deps)\n\n    # Sources.\n    all_sources = spec.get('sources', []) + extra_sources\n    if all_sources:\n      if self.flavor == 'mac':\n        # libtool on OS X generates warnings for duplicate basenames in the same\n        # target.\n        _ValidateSourcesForOSX(spec, all_sources)\n      self.WriteSources(\n          configs, deps, all_sources, extra_outputs,\n          extra_link_deps, part_of_all,\n          gyp.xcode_emulation.MacPrefixHeader(\n              self.xcode_settings, lambda p: Sourceify(self.Absolutify(p)),\n              self.Pchify))\n      sources = filter(Compilable, all_sources)\n      if sources:\n        self.WriteLn(SHARED_HEADER_SUFFIX_RULES_COMMENT1)\n        extensions = set([os.path.splitext(s)[1] for s in sources])\n        for ext in extensions:\n          if ext in self.suffix_rules_srcdir:\n            self.WriteLn(self.suffix_rules_srcdir[ext])\n        self.WriteLn(SHARED_HEADER_SUFFIX_RULES_COMMENT2)\n        for ext in extensions:\n          if ext in self.suffix_rules_objdir1:\n            self.WriteLn(self.suffix_rules_objdir1[ext])\n        for ext in extensions:\n          if ext in self.suffix_rules_objdir2:\n            self.WriteLn(self.suffix_rules_objdir2[ext])\n        self.WriteLn('# End of this set of suffix rules')\n\n        # Add dependency from bundle to bundle binary.\n        if self.is_mac_bundle:\n          mac_bundle_deps.append(self.output_binary)\n\n    self.WriteTarget(spec, configs, deps, extra_link_deps + link_deps,\n                     mac_bundle_deps, extra_outputs, part_of_all)\n\n    # Update global list of target outputs, used in dependency tracking.\n    target_outputs[qualified_target] = install_path\n\n    # Update global list of link dependencies.\n    if self.type in ('static_library', 'shared_library'):\n      target_link_deps[qualified_target] = self.output_binary\n\n    # Currently any versions have the same effect, but in future the behavior\n    # could be different.\n    if self.generator_flags.get('android_ndk_version', None):\n      self.WriteAndroidNdkModuleRule(self.target, all_sources, link_deps)\n\n    self.fp.close()\n\n\n  def WriteSubMake(self, output_filename, makefile_path, targets, build_dir):\n    \"\"\"Write a \"sub-project\" Makefile.\n\n    This is a small, wrapper Makefile that calls the top-level Makefile to build\n    the targets from a single gyp file (i.e. a sub-project).\n\n    Arguments:\n      output_filename: sub-project Makefile name to write\n      makefile_path: path to the top-level Makefile\n      targets: list of \"all\" targets for this sub-project\n      build_dir: build output directory, relative to the sub-project\n    \"\"\"\n    gyp.common.EnsureDirExists(output_filename)\n    self.fp = open(output_filename, 'w')\n    self.fp.write(header)\n    # For consistency with other builders, put sub-project build output in the\n    # sub-project dir (see test/subdirectory/gyptest-subdir-all.py).\n    self.WriteLn('export builddir_name ?= %s' %\n                 os.path.join(os.path.dirname(output_filename), build_dir))\n    self.WriteLn('.PHONY: all')\n    self.WriteLn('all:')\n    if makefile_path:\n      makefile_path = ' -C ' + makefile_path\n    self.WriteLn('\\t$(MAKE)%s %s' % (makefile_path, ' '.join(targets)))\n    self.fp.close()\n\n\n  def WriteActions(self, actions, extra_sources, extra_outputs,\n                   extra_mac_bundle_resources, part_of_all):\n    \"\"\"Write Makefile code for any 'actions' from the gyp input.\n\n    extra_sources: a list that will be filled in with newly generated source\n                   files, if any\n    extra_outputs: a list that will be filled in with any outputs of these\n                   actions (used to make other pieces dependent on these\n                   actions)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    env = self.GetSortedXcodeEnv()\n    for action in actions:\n      name = StringToMakefileVariable('%s_%s' % (self.qualified_target,\n                                                 action['action_name']))\n      self.WriteLn('### Rules for action \"%s\":' % action['action_name'])\n      inputs = action['inputs']\n      outputs = action['outputs']\n\n      # Build up a list of outputs.\n      # Collect the output dirs we'll need.\n      dirs = set()\n      for out in outputs:\n        dir = os.path.split(out)[0]\n        if dir:\n          dirs.add(dir)\n      if int(action.get('process_outputs_as_sources', False)):\n        extra_sources += outputs\n      if int(action.get('process_outputs_as_mac_bundle_resources', False)):\n        extra_mac_bundle_resources += outputs\n\n      # Write the actual command.\n      action_commands = action['action']\n      if self.flavor == 'mac':\n        action_commands = [gyp.xcode_emulation.ExpandEnvVars(command, env)\n                          for command in action_commands]\n      command = gyp.common.EncodePOSIXShellList(action_commands)\n      if 'message' in action:\n        self.WriteLn('quiet_cmd_%s = ACTION %s $@' % (name, action['message']))\n      else:\n        self.WriteLn('quiet_cmd_%s = ACTION %s $@' % (name, name))\n      if len(dirs) > 0:\n        command = 'mkdir -p %s' % ' '.join(dirs) + '; ' + command\n\n      cd_action = 'cd %s; ' % Sourceify(self.path or '.')\n\n      # command and cd_action get written to a toplevel variable called\n      # cmd_foo. Toplevel variables can't handle things that change per\n      # makefile like $(TARGET), so hardcode the target.\n      command = command.replace('$(TARGET)', self.target)\n      cd_action = cd_action.replace('$(TARGET)', self.target)\n\n      # Set LD_LIBRARY_PATH in case the action runs an executable from this\n      # build which links to shared libs from this build.\n      # actions run on the host, so they should in theory only use host\n      # libraries, but until everything is made cross-compile safe, also use\n      # target libraries.\n      # TODO(piman): when everything is cross-compile safe, remove lib.target\n      self.WriteLn('cmd_%s = LD_LIBRARY_PATH=$(builddir)/lib.host:'\n                   '$(builddir)/lib.target:$$LD_LIBRARY_PATH; '\n                   'export LD_LIBRARY_PATH; '\n                   '%s%s'\n                   % (name, cd_action, command))\n      self.WriteLn()\n      outputs = map(self.Absolutify, outputs)\n      # The makefile rules are all relative to the top dir, but the gyp actions\n      # are defined relative to their containing dir.  This replaces the obj\n      # variable for the action rule with an absolute version so that the output\n      # goes in the right place.\n      # Only write the 'obj' and 'builddir' rules for the \"primary\" output (:1);\n      # it's superfluous for the \"extra outputs\", and this avoids accidentally\n      # writing duplicate dummy rules for those outputs.\n      # Same for environment.\n      self.WriteLn(\"%s: obj := $(abs_obj)\" % QuoteSpaces(outputs[0]))\n      self.WriteLn(\"%s: builddir := $(abs_builddir)\" % QuoteSpaces(outputs[0]))\n      self.WriteSortedXcodeEnv(outputs[0], self.GetSortedXcodeEnv())\n\n      for input in inputs:\n        assert ' ' not in input, (\n            \"Spaces in action input filenames not supported (%s)\"  % input)\n      for output in outputs:\n        assert ' ' not in output, (\n            \"Spaces in action output filenames not supported (%s)\"  % output)\n\n      # See the comment in WriteCopies about expanding env vars.\n      outputs = [gyp.xcode_emulation.ExpandEnvVars(o, env) for o in outputs]\n      inputs = [gyp.xcode_emulation.ExpandEnvVars(i, env) for i in inputs]\n\n      self.WriteDoCmd(outputs, map(Sourceify, map(self.Absolutify, inputs)),\n                      part_of_all=part_of_all, command=name)\n\n      # Stuff the outputs in a variable so we can refer to them later.\n      outputs_variable = 'action_%s_outputs' % name\n      self.WriteLn('%s := %s' % (outputs_variable, ' '.join(outputs)))\n      extra_outputs.append('$(%s)' % outputs_variable)\n      self.WriteLn()\n\n    self.WriteLn()\n\n\n  def WriteRules(self, rules, extra_sources, extra_outputs,\n                 extra_mac_bundle_resources, part_of_all):\n    \"\"\"Write Makefile code for any 'rules' from the gyp input.\n\n    extra_sources: a list that will be filled in with newly generated source\n                   files, if any\n    extra_outputs: a list that will be filled in with any outputs of these\n                   rules (used to make other pieces dependent on these rules)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    env = self.GetSortedXcodeEnv()\n    for rule in rules:\n      name = StringToMakefileVariable('%s_%s' % (self.qualified_target,\n                                                 rule['rule_name']))\n      count = 0\n      self.WriteLn('### Generated for rule %s:' % name)\n\n      all_outputs = []\n\n      for rule_source in rule.get('rule_sources', []):\n        dirs = set()\n        (rule_source_dirname, rule_source_basename) = os.path.split(rule_source)\n        (rule_source_root, rule_source_ext) = \\\n            os.path.splitext(rule_source_basename)\n\n        outputs = [self.ExpandInputRoot(out, rule_source_root,\n                                        rule_source_dirname)\n                   for out in rule['outputs']]\n\n        for out in outputs:\n          dir = os.path.dirname(out)\n          if dir:\n            dirs.add(dir)\n        if int(rule.get('process_outputs_as_sources', False)):\n          extra_sources += outputs\n        if int(rule.get('process_outputs_as_mac_bundle_resources', False)):\n          extra_mac_bundle_resources += outputs\n        inputs = map(Sourceify, map(self.Absolutify, [rule_source] +\n                                    rule.get('inputs', [])))\n        actions = ['$(call do_cmd,%s_%d)' % (name, count)]\n\n        if name == 'resources_grit':\n          # HACK: This is ugly.  Grit intentionally doesn't touch the\n          # timestamp of its output file when the file doesn't change,\n          # which is fine in hash-based dependency systems like scons\n          # and forge, but not kosher in the make world.  After some\n          # discussion, hacking around it here seems like the least\n          # amount of pain.\n          actions += ['@touch --no-create $@']\n\n        # See the comment in WriteCopies about expanding env vars.\n        outputs = [gyp.xcode_emulation.ExpandEnvVars(o, env) for o in outputs]\n        inputs = [gyp.xcode_emulation.ExpandEnvVars(i, env) for i in inputs]\n\n        outputs = map(self.Absolutify, outputs)\n        all_outputs += outputs\n        # Only write the 'obj' and 'builddir' rules for the \"primary\" output\n        # (:1); it's superfluous for the \"extra outputs\", and this avoids\n        # accidentally writing duplicate dummy rules for those outputs.\n        self.WriteLn('%s: obj := $(abs_obj)' % outputs[0])\n        self.WriteLn('%s: builddir := $(abs_builddir)' % outputs[0])\n        self.WriteMakeRule(outputs, inputs, actions,\n                           command=\"%s_%d\" % (name, count))\n        # Spaces in rule filenames are not supported, but rule variables have\n        # spaces in them (e.g. RULE_INPUT_PATH expands to '$(abspath $<)').\n        # The spaces within the variables are valid, so remove the variables\n        # before checking.\n        variables_with_spaces = re.compile(r'\\$\\([^ ]* \\$<\\)')\n        for output in outputs:\n          output = re.sub(variables_with_spaces, '', output)\n          assert ' ' not in output, (\n              \"Spaces in rule filenames not yet supported (%s)\"  % output)\n        self.WriteLn('all_deps += %s' % ' '.join(outputs))\n\n        action = [self.ExpandInputRoot(ac, rule_source_root,\n                                       rule_source_dirname)\n                  for ac in rule['action']]\n        mkdirs = ''\n        if len(dirs) > 0:\n          mkdirs = 'mkdir -p %s; ' % ' '.join(dirs)\n        cd_action = 'cd %s; ' % Sourceify(self.path or '.')\n\n        # action, cd_action, and mkdirs get written to a toplevel variable\n        # called cmd_foo. Toplevel variables can't handle things that change\n        # per makefile like $(TARGET), so hardcode the target.\n        if self.flavor == 'mac':\n          action = [gyp.xcode_emulation.ExpandEnvVars(command, env)\n                    for command in action]\n        action = gyp.common.EncodePOSIXShellList(action)\n        action = action.replace('$(TARGET)', self.target)\n        cd_action = cd_action.replace('$(TARGET)', self.target)\n        mkdirs = mkdirs.replace('$(TARGET)', self.target)\n\n        # Set LD_LIBRARY_PATH in case the rule runs an executable from this\n        # build which links to shared libs from this build.\n        # rules run on the host, so they should in theory only use host\n        # libraries, but until everything is made cross-compile safe, also use\n        # target libraries.\n        # TODO(piman): when everything is cross-compile safe, remove lib.target\n        self.WriteLn(\n            \"cmd_%(name)s_%(count)d = LD_LIBRARY_PATH=\"\n              \"$(builddir)/lib.host:$(builddir)/lib.target:$$LD_LIBRARY_PATH; \"\n              \"export LD_LIBRARY_PATH; \"\n              \"%(cd_action)s%(mkdirs)s%(action)s\" % {\n          'action': action,\n          'cd_action': cd_action,\n          'count': count,\n          'mkdirs': mkdirs,\n          'name': name,\n        })\n        self.WriteLn(\n            'quiet_cmd_%(name)s_%(count)d = RULE %(name)s_%(count)d $@' % {\n          'count': count,\n          'name': name,\n        })\n        self.WriteLn()\n        count += 1\n\n      outputs_variable = 'rule_%s_outputs' % name\n      self.WriteList(all_outputs, outputs_variable)\n      extra_outputs.append('$(%s)' % outputs_variable)\n\n      self.WriteLn('### Finished generating for rule: %s' % name)\n      self.WriteLn()\n    self.WriteLn('### Finished generating for all rules')\n    self.WriteLn('')\n\n\n  def WriteCopies(self, copies, extra_outputs, part_of_all):\n    \"\"\"Write Makefile code for any 'copies' from the gyp input.\n\n    extra_outputs: a list that will be filled in with any outputs of this action\n                   (used to make other pieces dependent on this action)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n    self.WriteLn('### Generated for copy rule.')\n\n    variable = StringToMakefileVariable(self.qualified_target + '_copies')\n    outputs = []\n    for copy in copies:\n      for path in copy['files']:\n        # Absolutify() may call normpath, and will strip trailing slashes.\n        path = Sourceify(self.Absolutify(path))\n        filename = os.path.split(path)[1]\n        output = Sourceify(self.Absolutify(os.path.join(copy['destination'],\n                                                        filename)))\n\n        # If the output path has variables in it, which happens in practice for\n        # 'copies', writing the environment as target-local doesn't work,\n        # because the variables are already needed for the target name.\n        # Copying the environment variables into global make variables doesn't\n        # work either, because then the .d files will potentially contain spaces\n        # after variable expansion, and .d file handling cannot handle spaces.\n        # As a workaround, manually expand variables at gyp time. Since 'copies'\n        # can't run scripts, there's no need to write the env then.\n        # WriteDoCmd() will escape spaces for .d files.\n        env = self.GetSortedXcodeEnv()\n        output = gyp.xcode_emulation.ExpandEnvVars(output, env)\n        path = gyp.xcode_emulation.ExpandEnvVars(path, env)\n        self.WriteDoCmd([output], [path], 'copy', part_of_all)\n        outputs.append(output)\n    self.WriteLn('%s = %s' % (variable, ' '.join(map(QuoteSpaces, outputs))))\n    extra_outputs.append('$(%s)' % variable)\n    self.WriteLn()\n\n\n  def WriteMacBundleResources(self, resources, bundle_deps):\n    \"\"\"Writes Makefile code for 'mac_bundle_resources'.\"\"\"\n    self.WriteLn('### Generated for mac_bundle_resources')\n\n    for output, res in gyp.xcode_emulation.GetMacBundleResources(\n        generator_default_variables['PRODUCT_DIR'], self.xcode_settings,\n        map(Sourceify, map(self.Absolutify, resources))):\n      _, ext = os.path.splitext(output)\n      if ext != '.xcassets':\n        # Make does not supports '.xcassets' emulation.\n        self.WriteDoCmd([output], [res], 'mac_tool,,,copy-bundle-resource',\n                        part_of_all=True)\n        bundle_deps.append(output)\n\n\n  def WriteMacInfoPlist(self, bundle_deps):\n    \"\"\"Write Makefile code for bundle Info.plist files.\"\"\"\n    info_plist, out, defines, extra_env = gyp.xcode_emulation.GetMacInfoPlist(\n        generator_default_variables['PRODUCT_DIR'], self.xcode_settings,\n        lambda p: Sourceify(self.Absolutify(p)))\n    if not info_plist:\n      return\n    if defines:\n      # Create an intermediate file to store preprocessed results.\n      intermediate_plist = ('$(obj).$(TOOLSET)/$(TARGET)/' +\n          os.path.basename(info_plist))\n      self.WriteList(defines, intermediate_plist + ': INFOPLIST_DEFINES', '-D',\n          quoter=EscapeCppDefine)\n      self.WriteMakeRule([intermediate_plist], [info_plist],\n          ['$(call do_cmd,infoplist)',\n           # \"Convert\" the plist so that any weird whitespace changes from the\n           # preprocessor do not affect the XML parser in mac_tool.\n           '@plutil -convert xml1 $@ $@'])\n      info_plist = intermediate_plist\n    # plists can contain envvars and substitute them into the file.\n    self.WriteSortedXcodeEnv(\n        out, self.GetSortedXcodeEnv(additional_settings=extra_env))\n    self.WriteDoCmd([out], [info_plist], 'mac_tool,,,copy-info-plist',\n                    part_of_all=True)\n    bundle_deps.append(out)\n\n\n  def WriteSources(self, configs, deps, sources,\n                   extra_outputs, extra_link_deps,\n                   part_of_all, precompiled_header):\n    \"\"\"Write Makefile code for any 'sources' from the gyp input.\n    These are source files necessary to build the current target.\n\n    configs, deps, sources: input from gyp.\n    extra_outputs: a list of extra outputs this action should be dependent on;\n                   used to serialize action/rules before compilation\n    extra_link_deps: a list that will be filled in with any outputs of\n                     compilation (to be used in link lines)\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n\n    # Write configuration-specific variables for CFLAGS, etc.\n    for configname in sorted(configs.keys()):\n      config = configs[configname]\n      self.WriteList(config.get('defines'), 'DEFS_%s' % configname, prefix='-D',\n          quoter=EscapeCppDefine)\n\n      if self.flavor == 'mac':\n        cflags = self.xcode_settings.GetCflags(configname)\n        cflags_c = self.xcode_settings.GetCflagsC(configname)\n        cflags_cc = self.xcode_settings.GetCflagsCC(configname)\n        cflags_objc = self.xcode_settings.GetCflagsObjC(configname)\n        cflags_objcc = self.xcode_settings.GetCflagsObjCC(configname)\n      else:\n        cflags = config.get('cflags')\n        cflags_c = config.get('cflags_c')\n        cflags_cc = config.get('cflags_cc')\n\n      self.WriteLn(\"# Flags passed to all source files.\");\n      self.WriteList(cflags, 'CFLAGS_%s' % configname)\n      self.WriteLn(\"# Flags passed to only C files.\");\n      self.WriteList(cflags_c, 'CFLAGS_C_%s' % configname)\n      self.WriteLn(\"# Flags passed to only C++ files.\");\n      self.WriteList(cflags_cc, 'CFLAGS_CC_%s' % configname)\n      if self.flavor == 'mac':\n        self.WriteLn(\"# Flags passed to only ObjC files.\");\n        self.WriteList(cflags_objc, 'CFLAGS_OBJC_%s' % configname)\n        self.WriteLn(\"# Flags passed to only ObjC++ files.\");\n        self.WriteList(cflags_objcc, 'CFLAGS_OBJCC_%s' % configname)\n      includes = config.get('include_dirs')\n      if includes:\n        includes = map(Sourceify, map(self.Absolutify, includes))\n      self.WriteList(includes, 'INCS_%s' % configname, prefix='-I')\n\n    compilable = filter(Compilable, sources)\n    objs = map(self.Objectify, map(self.Absolutify, map(Target, compilable)))\n    self.WriteList(objs, 'OBJS')\n\n    for obj in objs:\n      assert ' ' not in obj, (\n          \"Spaces in object filenames not supported (%s)\"  % obj)\n    self.WriteLn('# Add to the list of files we specially track '\n                 'dependencies for.')\n    self.WriteLn('all_deps += $(OBJS)')\n    self.WriteLn()\n\n    # Make sure our dependencies are built first.\n    if deps:\n      self.WriteMakeRule(['$(OBJS)'], deps,\n                         comment = 'Make sure our dependencies are built '\n                                   'before any of us.',\n                         order_only = True)\n\n    # Make sure the actions and rules run first.\n    # If they generate any extra headers etc., the per-.o file dep tracking\n    # will catch the proper rebuilds, so order only is still ok here.\n    if extra_outputs:\n      self.WriteMakeRule(['$(OBJS)'], extra_outputs,\n                         comment = 'Make sure our actions/rules run '\n                                   'before any of us.',\n                         order_only = True)\n\n    pchdeps = precompiled_header.GetObjDependencies(compilable, objs )\n    if pchdeps:\n      self.WriteLn('# Dependencies from obj files to their precompiled headers')\n      for source, obj, gch in pchdeps:\n        self.WriteLn('%s: %s' % (obj, gch))\n      self.WriteLn('# End precompiled header dependencies')\n\n    if objs:\n      extra_link_deps.append('$(OBJS)')\n      self.WriteLn(\"\"\"\\\n# CFLAGS et al overrides must be target-local.\n# See \"Target-specific Variable Values\" in the GNU Make manual.\"\"\")\n      self.WriteLn(\"$(OBJS): TOOLSET := $(TOOLSET)\")\n      self.WriteLn(\"$(OBJS): GYP_CFLAGS := \"\n                   \"$(DEFS_$(BUILDTYPE)) \"\n                   \"$(INCS_$(BUILDTYPE)) \"\n                   \"%s \" % precompiled_header.GetInclude('c') +\n                   \"$(CFLAGS_$(BUILDTYPE)) \"\n                   \"$(CFLAGS_C_$(BUILDTYPE))\")\n      self.WriteLn(\"$(OBJS): GYP_CXXFLAGS := \"\n                   \"$(DEFS_$(BUILDTYPE)) \"\n                   \"$(INCS_$(BUILDTYPE)) \"\n                   \"%s \" % precompiled_header.GetInclude('cc') +\n                   \"$(CFLAGS_$(BUILDTYPE)) \"\n                   \"$(CFLAGS_CC_$(BUILDTYPE))\")\n      if self.flavor == 'mac':\n        self.WriteLn(\"$(OBJS): GYP_OBJCFLAGS := \"\n                     \"$(DEFS_$(BUILDTYPE)) \"\n                     \"$(INCS_$(BUILDTYPE)) \"\n                     \"%s \" % precompiled_header.GetInclude('m') +\n                     \"$(CFLAGS_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_C_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_OBJC_$(BUILDTYPE))\")\n        self.WriteLn(\"$(OBJS): GYP_OBJCXXFLAGS := \"\n                     \"$(DEFS_$(BUILDTYPE)) \"\n                     \"$(INCS_$(BUILDTYPE)) \"\n                     \"%s \" % precompiled_header.GetInclude('mm') +\n                     \"$(CFLAGS_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_CC_$(BUILDTYPE)) \"\n                     \"$(CFLAGS_OBJCC_$(BUILDTYPE))\")\n\n    self.WritePchTargets(precompiled_header.GetPchBuildCommands())\n\n    # If there are any object files in our input file list, link them into our\n    # output.\n    extra_link_deps += filter(Linkable, sources)\n\n    self.WriteLn()\n\n  def WritePchTargets(self, pch_commands):\n    \"\"\"Writes make rules to compile prefix headers.\"\"\"\n    if not pch_commands:\n      return\n\n    for gch, lang_flag, lang, input in pch_commands:\n      extra_flags = {\n        'c': '$(CFLAGS_C_$(BUILDTYPE))',\n        'cc': '$(CFLAGS_CC_$(BUILDTYPE))',\n        'm': '$(CFLAGS_C_$(BUILDTYPE)) $(CFLAGS_OBJC_$(BUILDTYPE))',\n        'mm': '$(CFLAGS_CC_$(BUILDTYPE)) $(CFLAGS_OBJCC_$(BUILDTYPE))',\n      }[lang]\n      var_name = {\n        'c': 'GYP_PCH_CFLAGS',\n        'cc': 'GYP_PCH_CXXFLAGS',\n        'm': 'GYP_PCH_OBJCFLAGS',\n        'mm': 'GYP_PCH_OBJCXXFLAGS',\n      }[lang]\n      self.WriteLn(\"%s: %s := %s \" % (gch, var_name, lang_flag) +\n                   \"$(DEFS_$(BUILDTYPE)) \"\n                   \"$(INCS_$(BUILDTYPE)) \"\n                   \"$(CFLAGS_$(BUILDTYPE)) \" +\n                   extra_flags)\n\n      self.WriteLn('%s: %s FORCE_DO_CMD' % (gch, input))\n      self.WriteLn('\\t@$(call do_cmd,pch_%s,1)' % lang)\n      self.WriteLn('')\n      assert ' ' not in gch, (\n          \"Spaces in gch filenames not supported (%s)\"  % gch)\n      self.WriteLn('all_deps += %s' % gch)\n      self.WriteLn('')\n\n\n  def ComputeOutputBasename(self, spec):\n    \"\"\"Return the 'output basename' of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      'libfoobar.so'\n    \"\"\"\n    assert not self.is_mac_bundle\n\n    if self.flavor == 'mac' and self.type in (\n        'static_library', 'executable', 'shared_library', 'loadable_module'):\n      return self.xcode_settings.GetExecutablePath()\n\n    target = spec['target_name']\n    target_prefix = ''\n    target_ext = ''\n    if self.type == 'static_library':\n      if target[:3] == 'lib':\n        target = target[3:]\n      target_prefix = 'lib'\n      target_ext = '.a'\n    elif self.type in ('loadable_module', 'shared_library'):\n      if target[:3] == 'lib':\n        target = target[3:]\n      target_prefix = 'lib'\n      target_ext = '.so'\n    elif self.type == 'none':\n      target = '%s.stamp' % target\n    elif self.type != 'executable':\n      print (\"ERROR: What output file should be generated?\",\n             \"type\", self.type, \"target\", target)\n\n    target_prefix = spec.get('product_prefix', target_prefix)\n    target = spec.get('product_name', target)\n    product_ext = spec.get('product_extension')\n    if product_ext:\n      target_ext = '.' + product_ext\n\n    return target_prefix + target + target_ext\n\n\n  def _InstallImmediately(self):\n    return self.toolset == 'target' and self.flavor == 'mac' and self.type in (\n          'static_library', 'executable', 'shared_library', 'loadable_module')\n\n\n  def ComputeOutput(self, spec):\n    \"\"\"Return the 'output' (full output path) of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      '$(obj)/baz/libfoobar.so'\n    \"\"\"\n    assert not self.is_mac_bundle\n\n    path = os.path.join('$(obj).' + self.toolset, self.path)\n    if self.type == 'executable' or self._InstallImmediately():\n      path = '$(builddir)'\n    path = spec.get('product_dir', path)\n    return os.path.join(path, self.ComputeOutputBasename(spec))\n\n\n  def ComputeMacBundleOutput(self, spec):\n    \"\"\"Return the 'output' (full output path) to a bundle output directory.\"\"\"\n    assert self.is_mac_bundle\n    path = generator_default_variables['PRODUCT_DIR']\n    return os.path.join(path, self.xcode_settings.GetWrapperName())\n\n\n  def ComputeMacBundleBinaryOutput(self, spec):\n    \"\"\"Return the 'output' (full output path) to the binary in a bundle.\"\"\"\n    path = generator_default_variables['PRODUCT_DIR']\n    return os.path.join(path, self.xcode_settings.GetExecutablePath())\n\n\n  def ComputeDeps(self, spec):\n    \"\"\"Compute the dependencies of a gyp spec.\n\n    Returns a tuple (deps, link_deps), where each is a list of\n    filenames that will need to be put in front of make for either\n    building (deps) or linking (link_deps).\n    \"\"\"\n    deps = []\n    link_deps = []\n    if 'dependencies' in spec:\n      deps.extend([target_outputs[dep] for dep in spec['dependencies']\n                   if target_outputs[dep]])\n      for dep in spec['dependencies']:\n        if dep in target_link_deps:\n          link_deps.append(target_link_deps[dep])\n      deps.extend(link_deps)\n      # TODO: It seems we need to transitively link in libraries (e.g. -lfoo)?\n      # This hack makes it work:\n      # link_deps.extend(spec.get('libraries', []))\n    return (gyp.common.uniquer(deps), gyp.common.uniquer(link_deps))\n\n\n  def WriteDependencyOnExtraOutputs(self, target, extra_outputs):\n    self.WriteMakeRule([self.output_binary], extra_outputs,\n                       comment = 'Build our special outputs first.',\n                       order_only = True)\n\n\n  def WriteTarget(self, spec, configs, deps, link_deps, bundle_deps,\n                  extra_outputs, part_of_all):\n    \"\"\"Write Makefile code to produce the final target of the gyp spec.\n\n    spec, configs: input from gyp.\n    deps, link_deps: dependency lists; see ComputeDeps()\n    extra_outputs: any extra outputs that our target should depend on\n    part_of_all: flag indicating this target is part of 'all'\n    \"\"\"\n\n    self.WriteLn('### Rules for final target.')\n\n    if extra_outputs:\n      self.WriteDependencyOnExtraOutputs(self.output_binary, extra_outputs)\n      self.WriteMakeRule(extra_outputs, deps,\n                         comment=('Preserve order dependency of '\n                                  'special output on deps.'),\n                         order_only = True)\n\n    target_postbuilds = {}\n    if self.type != 'none':\n      for configname in sorted(configs.keys()):\n        config = configs[configname]\n        if self.flavor == 'mac':\n          ldflags = self.xcode_settings.GetLdflags(configname,\n              generator_default_variables['PRODUCT_DIR'],\n              lambda p: Sourceify(self.Absolutify(p)))\n\n          # TARGET_POSTBUILDS_$(BUILDTYPE) is added to postbuilds later on.\n          gyp_to_build = gyp.common.InvertRelativePath(self.path)\n          target_postbuild = self.xcode_settings.AddImplicitPostbuilds(\n              configname,\n              QuoteSpaces(os.path.normpath(os.path.join(gyp_to_build,\n                                                        self.output))),\n              QuoteSpaces(os.path.normpath(os.path.join(gyp_to_build,\n                                                        self.output_binary))))\n          if target_postbuild:\n            target_postbuilds[configname] = target_postbuild\n        else:\n          ldflags = config.get('ldflags', [])\n          # Compute an rpath for this output if needed.\n          if any(dep.endswith('.so') or '.so.' in dep for dep in deps):\n            # We want to get the literal string \"$ORIGIN\" into the link command,\n            # so we need lots of escaping.\n            ldflags.append(r'-Wl,-rpath=\\$$ORIGIN/lib.%s/' % self.toolset)\n            ldflags.append(r'-Wl,-rpath-link=\\$(builddir)/lib.%s/' %\n                           self.toolset)\n        library_dirs = config.get('library_dirs', [])\n        ldflags += [('-L%s' % library_dir) for library_dir in library_dirs]\n        self.WriteList(ldflags, 'LDFLAGS_%s' % configname)\n        if self.flavor == 'mac':\n          self.WriteList(self.xcode_settings.GetLibtoolflags(configname),\n                         'LIBTOOLFLAGS_%s' % configname)\n      libraries = spec.get('libraries')\n      if libraries:\n        # Remove duplicate entries\n        libraries = gyp.common.uniquer(libraries)\n        if self.flavor == 'mac':\n          libraries = self.xcode_settings.AdjustLibraries(libraries)\n      self.WriteList(libraries, 'LIBS')\n      self.WriteLn('%s: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))' %\n          QuoteSpaces(self.output_binary))\n      self.WriteLn('%s: LIBS := $(LIBS)' % QuoteSpaces(self.output_binary))\n\n      if self.flavor == 'mac':\n        self.WriteLn('%s: GYP_LIBTOOLFLAGS := $(LIBTOOLFLAGS_$(BUILDTYPE))' %\n            QuoteSpaces(self.output_binary))\n\n    # Postbuild actions. Like actions, but implicitly depend on the target's\n    # output.\n    postbuilds = []\n    if self.flavor == 'mac':\n      if target_postbuilds:\n        postbuilds.append('$(TARGET_POSTBUILDS_$(BUILDTYPE))')\n      postbuilds.extend(\n          gyp.xcode_emulation.GetSpecPostbuildCommands(spec))\n\n    if postbuilds:\n      # Envvars may be referenced by TARGET_POSTBUILDS_$(BUILDTYPE),\n      # so we must output its definition first, since we declare variables\n      # using \":=\".\n      self.WriteSortedXcodeEnv(self.output, self.GetSortedXcodePostbuildEnv())\n\n      for configname in target_postbuilds:\n        self.WriteLn('%s: TARGET_POSTBUILDS_%s := %s' %\n            (QuoteSpaces(self.output),\n             configname,\n             gyp.common.EncodePOSIXShellList(target_postbuilds[configname])))\n\n      # Postbuilds expect to be run in the gyp file's directory, so insert an\n      # implicit postbuild to cd to there.\n      postbuilds.insert(0, gyp.common.EncodePOSIXShellList(['cd', self.path]))\n      for i in xrange(len(postbuilds)):\n        if not postbuilds[i].startswith('$'):\n          postbuilds[i] = EscapeShellArgument(postbuilds[i])\n      self.WriteLn('%s: builddir := $(abs_builddir)' % QuoteSpaces(self.output))\n      self.WriteLn('%s: POSTBUILDS := %s' % (\n          QuoteSpaces(self.output), ' '.join(postbuilds)))\n\n    # A bundle directory depends on its dependencies such as bundle resources\n    # and bundle binary. When all dependencies have been built, the bundle\n    # needs to be packaged.\n    if self.is_mac_bundle:\n      # If the framework doesn't contain a binary, then nothing depends\n      # on the actions -- make the framework depend on them directly too.\n      self.WriteDependencyOnExtraOutputs(self.output, extra_outputs)\n\n      # Bundle dependencies. Note that the code below adds actions to this\n      # target, so if you move these two lines, move the lines below as well.\n      self.WriteList(map(QuoteSpaces, bundle_deps), 'BUNDLE_DEPS')\n      self.WriteLn('%s: $(BUNDLE_DEPS)' % QuoteSpaces(self.output))\n\n      # After the framework is built, package it. Needs to happen before\n      # postbuilds, since postbuilds depend on this.\n      if self.type in ('shared_library', 'loadable_module'):\n        self.WriteLn('\\t@$(call do_cmd,mac_package_framework,,,%s)' %\n            self.xcode_settings.GetFrameworkVersion())\n\n      # Bundle postbuilds can depend on the whole bundle, so run them after\n      # the bundle is packaged, not already after the bundle binary is done.\n      if postbuilds:\n        self.WriteLn('\\t@$(call do_postbuilds)')\n      postbuilds = []  # Don't write postbuilds for target's output.\n\n      # Needed by test/mac/gyptest-rebuild.py.\n      self.WriteLn('\\t@true  # No-op, used by tests')\n\n      # Since this target depends on binary and resources which are in\n      # nested subfolders, the framework directory will be older than\n      # its dependencies usually. To prevent this rule from executing\n      # on every build (expensive, especially with postbuilds), expliclity\n      # update the time on the framework directory.\n      self.WriteLn('\\t@touch -c %s' % QuoteSpaces(self.output))\n\n    if postbuilds:\n      assert not self.is_mac_bundle, ('Postbuilds for bundles should be done '\n          'on the bundle, not the binary (target \\'%s\\')' % self.target)\n      assert 'product_dir' not in spec, ('Postbuilds do not work with '\n          'custom product_dir')\n\n    if self.type == 'executable':\n      self.WriteLn('%s: LD_INPUTS := %s' % (\n          QuoteSpaces(self.output_binary),\n          ' '.join(map(QuoteSpaces, link_deps))))\n      if self.toolset == 'host' and self.flavor == 'android':\n        self.WriteDoCmd([self.output_binary], link_deps, 'link_host',\n                        part_of_all, postbuilds=postbuilds)\n      else:\n        self.WriteDoCmd([self.output_binary], link_deps, 'link', part_of_all,\n                        postbuilds=postbuilds)\n\n    elif self.type == 'static_library':\n      for link_dep in link_deps:\n        assert ' ' not in link_dep, (\n            \"Spaces in alink input filenames not supported (%s)\"  % link_dep)\n      if (self.flavor not in ('mac', 'openbsd', 'netbsd', 'win') and not\n          self.is_standalone_static_library):\n        self.WriteDoCmd([self.output_binary], link_deps, 'alink_thin',\n                        part_of_all, postbuilds=postbuilds)\n      else:\n        self.WriteDoCmd([self.output_binary], link_deps, 'alink', part_of_all,\n                        postbuilds=postbuilds)\n    elif self.type == 'shared_library':\n      self.WriteLn('%s: LD_INPUTS := %s' % (\n            QuoteSpaces(self.output_binary),\n            ' '.join(map(QuoteSpaces, link_deps))))\n      self.WriteDoCmd([self.output_binary], link_deps, 'solink', part_of_all,\n                      postbuilds=postbuilds)\n    elif self.type == 'loadable_module':\n      for link_dep in link_deps:\n        assert ' ' not in link_dep, (\n            \"Spaces in module input filenames not supported (%s)\"  % link_dep)\n      if self.toolset == 'host' and self.flavor == 'android':\n        self.WriteDoCmd([self.output_binary], link_deps, 'solink_module_host',\n                        part_of_all, postbuilds=postbuilds)\n      else:\n        self.WriteDoCmd(\n            [self.output_binary], link_deps, 'solink_module', part_of_all,\n            postbuilds=postbuilds)\n    elif self.type == 'none':\n      # Write a stamp line.\n      self.WriteDoCmd([self.output_binary], deps, 'touch', part_of_all,\n                      postbuilds=postbuilds)\n    else:\n      print \"WARNING: no output for\", self.type, target\n\n    # Add an alias for each target (if there are any outputs).\n    # Installable target aliases are created below.\n    if ((self.output and self.output != self.target) and\n        (self.type not in self._INSTALLABLE_TARGETS)):\n      self.WriteMakeRule([self.target], [self.output],\n                         comment='Add target alias', phony = True)\n      if part_of_all:\n        self.WriteMakeRule(['all'], [self.target],\n                           comment = 'Add target alias to \"all\" target.',\n                           phony = True)\n\n    # Add special-case rules for our installable targets.\n    # 1) They need to install to the build dir or \"product\" dir.\n    # 2) They get shortcuts for building (e.g. \"make chrome\").\n    # 3) They are part of \"make all\".\n    if (self.type in self._INSTALLABLE_TARGETS or\n        self.is_standalone_static_library):\n      if self.type == 'shared_library':\n        file_desc = 'shared library'\n      elif self.type == 'static_library':\n        file_desc = 'static library'\n      else:\n        file_desc = 'executable'\n      install_path = self._InstallableTargetInstallPath()\n      installable_deps = [self.output]\n      if (self.flavor == 'mac' and not 'product_dir' in spec and\n          self.toolset == 'target'):\n        # On mac, products are created in install_path immediately.\n        assert install_path == self.output, '%s != %s' % (\n            install_path, self.output)\n\n      # Point the target alias to the final binary output.\n      self.WriteMakeRule([self.target], [install_path],\n                         comment='Add target alias', phony = True)\n      if install_path != self.output:\n        assert not self.is_mac_bundle  # See comment a few lines above.\n        self.WriteDoCmd([install_path], [self.output], 'copy',\n                        comment = 'Copy this to the %s output path.' %\n                        file_desc, part_of_all=part_of_all)\n        installable_deps.append(install_path)\n      if self.output != self.alias and self.alias != self.target:\n        self.WriteMakeRule([self.alias], installable_deps,\n                           comment = 'Short alias for building this %s.' %\n                           file_desc, phony = True)\n      if part_of_all:\n        self.WriteMakeRule(['all'], [install_path],\n                           comment = 'Add %s to \"all\" target.' % file_desc,\n                           phony = True)\n\n\n  def WriteList(self, value_list, variable=None, prefix='',\n                quoter=QuoteIfNecessary):\n    \"\"\"Write a variable definition that is a list of values.\n\n    E.g. WriteList(['a','b'], 'foo', prefix='blah') writes out\n         foo = blaha blahb\n    but in a pretty-printed style.\n    \"\"\"\n    values = ''\n    if value_list:\n      value_list = [quoter(prefix + l) for l in value_list]\n      values = ' \\\\\\n\\t' + ' \\\\\\n\\t'.join(value_list)\n    self.fp.write('%s :=%s\\n\\n' % (variable, values))\n\n\n  def WriteDoCmd(self, outputs, inputs, command, part_of_all, comment=None,\n                 postbuilds=False):\n    \"\"\"Write a Makefile rule that uses do_cmd.\n\n    This makes the outputs dependent on the command line that was run,\n    as well as support the V= make command line flag.\n    \"\"\"\n    suffix = ''\n    if postbuilds:\n      assert ',' not in command\n      suffix = ',,1'  # Tell do_cmd to honor $POSTBUILDS\n    self.WriteMakeRule(outputs, inputs,\n                       actions = ['$(call do_cmd,%s%s)' % (command, suffix)],\n                       comment = comment,\n                       command = command,\n                       force = True)\n    # Add our outputs to the list of targets we read depfiles from.\n    # all_deps is only used for deps file reading, and for deps files we replace\n    # spaces with ? because escaping doesn't work with make's $(sort) and\n    # other functions.\n    outputs = [QuoteSpaces(o, SPACE_REPLACEMENT) for o in outputs]\n    self.WriteLn('all_deps += %s' % ' '.join(outputs))\n\n\n  def WriteMakeRule(self, outputs, inputs, actions=None, comment=None,\n                    order_only=False, force=False, phony=False, command=None):\n    \"\"\"Write a Makefile rule, with some extra tricks.\n\n    outputs: a list of outputs for the rule (note: this is not directly\n             supported by make; see comments below)\n    inputs: a list of inputs for the rule\n    actions: a list of shell commands to run for the rule\n    comment: a comment to put in the Makefile above the rule (also useful\n             for making this Python script's code self-documenting)\n    order_only: if true, makes the dependency order-only\n    force: if true, include FORCE_DO_CMD as an order-only dep\n    phony: if true, the rule does not actually generate the named output, the\n           output is just a name to run the rule\n    command: (optional) command name to generate unambiguous labels\n    \"\"\"\n    outputs = map(QuoteSpaces, outputs)\n    inputs = map(QuoteSpaces, inputs)\n\n    if comment:\n      self.WriteLn('# ' + comment)\n    if phony:\n      self.WriteLn('.PHONY: ' + ' '.join(outputs))\n    if actions:\n      self.WriteLn(\"%s: TOOLSET := $(TOOLSET)\" % outputs[0])\n    force_append = ' FORCE_DO_CMD' if force else ''\n\n    if order_only:\n      # Order only rule: Just write a simple rule.\n      # TODO(evanm): just make order_only a list of deps instead of this hack.\n      self.WriteLn('%s: | %s%s' %\n                   (' '.join(outputs), ' '.join(inputs), force_append))\n    elif len(outputs) == 1:\n      # Regular rule, one output: Just write a simple rule.\n      self.WriteLn('%s: %s%s' % (outputs[0], ' '.join(inputs), force_append))\n    else:\n      # Regular rule, more than one output: Multiple outputs are tricky in\n      # make. We will write three rules:\n      # - All outputs depend on an intermediate file.\n      # - Make .INTERMEDIATE depend on the intermediate.\n      # - The intermediate file depends on the inputs and executes the\n      #   actual command.\n      # - The intermediate recipe will 'touch' the intermediate file.\n      # - The multi-output rule will have an do-nothing recipe.\n      intermediate = \"%s.intermediate\" % (command if command else self.target)\n      self.WriteLn('%s: %s' % (' '.join(outputs), intermediate))\n      self.WriteLn('\\t%s' % '@:');\n      self.WriteLn('%s: %s' % ('.INTERMEDIATE', intermediate))\n      self.WriteLn('%s: %s%s' %\n                   (intermediate, ' '.join(inputs), force_append))\n      actions.insert(0, '$(call do_cmd,touch)')\n\n    if actions:\n      for action in actions:\n        self.WriteLn('\\t%s' % action)\n    self.WriteLn()\n\n\n  def WriteAndroidNdkModuleRule(self, module_name, all_sources, link_deps):\n    \"\"\"Write a set of LOCAL_XXX definitions for Android NDK.\n\n    These variable definitions will be used by Android NDK but do nothing for\n    non-Android applications.\n\n    Arguments:\n      module_name: Android NDK module name, which must be unique among all\n          module names.\n      all_sources: A list of source files (will be filtered by Compilable).\n      link_deps: A list of link dependencies, which must be sorted in\n          the order from dependencies to dependents.\n    \"\"\"\n    if self.type not in ('executable', 'shared_library', 'static_library'):\n      return\n\n    self.WriteLn('# Variable definitions for Android applications')\n    self.WriteLn('include $(CLEAR_VARS)')\n    self.WriteLn('LOCAL_MODULE := ' + module_name)\n    self.WriteLn('LOCAL_CFLAGS := $(CFLAGS_$(BUILDTYPE)) '\n                 '$(DEFS_$(BUILDTYPE)) '\n                 # LOCAL_CFLAGS is applied to both of C and C++.  There is\n                 # no way to specify $(CFLAGS_C_$(BUILDTYPE)) only for C\n                 # sources.\n                 '$(CFLAGS_C_$(BUILDTYPE)) '\n                 # $(INCS_$(BUILDTYPE)) includes the prefix '-I' while\n                 # LOCAL_C_INCLUDES does not expect it.  So put it in\n                 # LOCAL_CFLAGS.\n                 '$(INCS_$(BUILDTYPE))')\n    # LOCAL_CXXFLAGS is obsolete and LOCAL_CPPFLAGS is preferred.\n    self.WriteLn('LOCAL_CPPFLAGS := $(CFLAGS_CC_$(BUILDTYPE))')\n    self.WriteLn('LOCAL_C_INCLUDES :=')\n    self.WriteLn('LOCAL_LDLIBS := $(LDFLAGS_$(BUILDTYPE)) $(LIBS)')\n\n    # Detect the C++ extension.\n    cpp_ext = {'.cc': 0, '.cpp': 0, '.cxx': 0}\n    default_cpp_ext = '.cpp'\n    for filename in all_sources:\n      ext = os.path.splitext(filename)[1]\n      if ext in cpp_ext:\n        cpp_ext[ext] += 1\n        if cpp_ext[ext] > cpp_ext[default_cpp_ext]:\n          default_cpp_ext = ext\n    self.WriteLn('LOCAL_CPP_EXTENSION := ' + default_cpp_ext)\n\n    self.WriteList(map(self.Absolutify, filter(Compilable, all_sources)),\n                   'LOCAL_SRC_FILES')\n\n    # Filter out those which do not match prefix and suffix and produce\n    # the resulting list without prefix and suffix.\n    def DepsToModules(deps, prefix, suffix):\n      modules = []\n      for filepath in deps:\n        filename = os.path.basename(filepath)\n        if filename.startswith(prefix) and filename.endswith(suffix):\n          modules.append(filename[len(prefix):-len(suffix)])\n      return modules\n\n    # Retrieve the default value of 'SHARED_LIB_SUFFIX'\n    params = {'flavor': 'linux'}\n    default_variables = {}\n    CalculateVariables(default_variables, params)\n\n    self.WriteList(\n        DepsToModules(link_deps,\n                      generator_default_variables['SHARED_LIB_PREFIX'],\n                      default_variables['SHARED_LIB_SUFFIX']),\n        'LOCAL_SHARED_LIBRARIES')\n    self.WriteList(\n        DepsToModules(link_deps,\n                      generator_default_variables['STATIC_LIB_PREFIX'],\n                      generator_default_variables['STATIC_LIB_SUFFIX']),\n        'LOCAL_STATIC_LIBRARIES')\n\n    if self.type == 'executable':\n      self.WriteLn('include $(BUILD_EXECUTABLE)')\n    elif self.type == 'shared_library':\n      self.WriteLn('include $(BUILD_SHARED_LIBRARY)')\n    elif self.type == 'static_library':\n      self.WriteLn('include $(BUILD_STATIC_LIBRARY)')\n    self.WriteLn()\n\n\n  def WriteLn(self, text=''):\n    self.fp.write(text + '\\n')\n\n\n  def GetSortedXcodeEnv(self, additional_settings=None):\n    return gyp.xcode_emulation.GetSortedXcodeEnv(\n        self.xcode_settings, \"$(abs_builddir)\",\n        os.path.join(\"$(abs_srcdir)\", self.path), \"$(BUILDTYPE)\",\n        additional_settings)\n\n\n  def GetSortedXcodePostbuildEnv(self):\n    # CHROMIUM_STRIP_SAVE_FILE is a chromium-specific hack.\n    # TODO(thakis): It would be nice to have some general mechanism instead.\n    strip_save_file = self.xcode_settings.GetPerTargetSetting(\n        'CHROMIUM_STRIP_SAVE_FILE', '')\n    # Even if strip_save_file is empty, explicitly write it. Else a postbuild\n    # might pick up an export from an earlier target.\n    return self.GetSortedXcodeEnv(\n        additional_settings={'CHROMIUM_STRIP_SAVE_FILE': strip_save_file})\n\n\n  def WriteSortedXcodeEnv(self, target, env):\n    for k, v in env:\n      # For\n      #  foo := a\\ b\n      # the escaped space does the right thing. For\n      #  export foo := a\\ b\n      # it does not -- the backslash is written to the env as literal character.\n      # So don't escape spaces in |env[k]|.\n      self.WriteLn('%s: export %s := %s' % (QuoteSpaces(target), k, v))\n\n\n  def Objectify(self, path):\n    \"\"\"Convert a path to its output directory form.\"\"\"\n    if '$(' in path:\n      path = path.replace('$(obj)/', '$(obj).%s/$(TARGET)/' % self.toolset)\n    if not '$(obj)' in path:\n      path = '$(obj).%s/$(TARGET)/%s' % (self.toolset, path)\n    return path\n\n\n  def Pchify(self, path, lang):\n    \"\"\"Convert a prefix header path to its output directory form.\"\"\"\n    path = self.Absolutify(path)\n    if '$(' in path:\n      path = path.replace('$(obj)/', '$(obj).%s/$(TARGET)/pch-%s' %\n                          (self.toolset, lang))\n      return path\n    return '$(obj).%s/$(TARGET)/pch-%s/%s' % (self.toolset, lang, path)\n\n\n  def Absolutify(self, path):\n    \"\"\"Convert a subdirectory-relative path into a base-relative path.\n    Skips over paths that contain variables.\"\"\"\n    if '$(' in path:\n      # Don't call normpath in this case, as it might collapse the\n      # path too aggressively if it features '..'. However it's still\n      # important to strip trailing slashes.\n      return path.rstrip('/')\n    return os.path.normpath(os.path.join(self.path, path))\n\n\n  def ExpandInputRoot(self, template, expansion, dirname):\n    if '%(INPUT_ROOT)s' not in template and '%(INPUT_DIRNAME)s' not in template:\n      return template\n    path = template % {\n        'INPUT_ROOT': expansion,\n        'INPUT_DIRNAME': dirname,\n        }\n    return path\n\n\n  def _InstallableTargetInstallPath(self):\n    \"\"\"Returns the location of the final output for an installable target.\"\"\"\n    # Xcode puts shared_library results into PRODUCT_DIR, and some gyp files\n    # rely on this. Emulate this behavior for mac.\n\n    # XXX(TooTallNate): disabling this code since we don't want this behavior...\n    #if (self.type == 'shared_library' and\n    #    (self.flavor != 'mac' or self.toolset != 'target')):\n    #  # Install all shared libs into a common directory (per toolset) for\n    #  # convenient access with LD_LIBRARY_PATH.\n    #  return '$(builddir)/lib.%s/%s' % (self.toolset, self.alias)\n    return '$(builddir)/' + self.alias\n\n\ndef WriteAutoRegenerationRule(params, root_makefile, makefile_name,\n                              build_files):\n  \"\"\"Write the target to regenerate the Makefile.\"\"\"\n  options = params['options']\n  build_files_args = [gyp.common.RelativePath(filename, options.toplevel_dir)\n                      for filename in params['build_files_arg']]\n\n  gyp_binary = gyp.common.FixIfRelativePath(params['gyp_binary'],\n                                            options.toplevel_dir)\n  if not gyp_binary.startswith(os.sep):\n    gyp_binary = os.path.join('.', gyp_binary)\n\n  root_makefile.write(\n      \"quiet_cmd_regen_makefile = ACTION Regenerating $@\\n\"\n      \"cmd_regen_makefile = cd $(srcdir); %(cmd)s\\n\"\n      \"%(makefile_name)s: %(deps)s\\n\"\n      \"\\t$(call do_cmd,regen_makefile)\\n\\n\" % {\n          'makefile_name': makefile_name,\n          'deps': ' '.join(map(Sourceify, build_files)),\n          'cmd': gyp.common.EncodePOSIXShellList(\n                     [gyp_binary, '-fmake'] +\n                     gyp.RegenerateFlags(options) +\n                     build_files_args)})\n\n\ndef PerformBuild(data, configurations, params):\n  options = params['options']\n  for config in configurations:\n    arguments = ['make']\n    if options.toplevel_dir and options.toplevel_dir != '.':\n      arguments += '-C', options.toplevel_dir\n    arguments.append('BUILDTYPE=' + config)\n    print 'Building [%s]: %s' % (config, arguments)\n    subprocess.check_call(arguments)\n\n\ndef GenerateOutput(target_list, target_dicts, data, params):\n  options = params['options']\n  flavor = gyp.common.GetFlavor(params)\n  generator_flags = params.get('generator_flags', {})\n  builddir_name = generator_flags.get('output_dir', 'out')\n  android_ndk_version = generator_flags.get('android_ndk_version', None)\n  default_target = generator_flags.get('default_target', 'all')\n\n  def CalculateMakefilePath(build_file, base_name):\n    \"\"\"Determine where to write a Makefile for a given gyp file.\"\"\"\n    # Paths in gyp files are relative to the .gyp file, but we want\n    # paths relative to the source root for the master makefile.  Grab\n    # the path of the .gyp file as the base to relativize against.\n    # E.g. \"foo/bar\" when we're constructing targets for \"foo/bar/baz.gyp\".\n    base_path = gyp.common.RelativePath(os.path.dirname(build_file),\n                                        options.depth)\n    # We write the file in the base_path directory.\n    output_file = os.path.join(options.depth, base_path, base_name)\n    if options.generator_output:\n      output_file = os.path.join(\n          options.depth, options.generator_output, base_path, base_name)\n    base_path = gyp.common.RelativePath(os.path.dirname(build_file),\n                                        options.toplevel_dir)\n    return base_path, output_file\n\n  # TODO:  search for the first non-'Default' target.  This can go\n  # away when we add verification that all targets have the\n  # necessary configurations.\n  default_configuration = None\n  toolsets = set([target_dicts[target]['toolset'] for target in target_list])\n  for target in target_list:\n    spec = target_dicts[target]\n    if spec['default_configuration'] != 'Default':\n      default_configuration = spec['default_configuration']\n      break\n  if not default_configuration:\n    default_configuration = 'Default'\n\n  srcdir = '.'\n  makefile_name = 'Makefile' + options.suffix\n  makefile_path = os.path.join(options.toplevel_dir, makefile_name)\n  if options.generator_output:\n    global srcdir_prefix\n    makefile_path = os.path.join(\n        options.toplevel_dir, options.generator_output, makefile_name)\n    srcdir = gyp.common.RelativePath(srcdir, options.generator_output)\n    srcdir_prefix = '$(srcdir)/'\n\n  flock_command= 'flock'\n  copy_archive_arguments = '-af'\n  header_params = {\n      'default_target': default_target,\n      'builddir': builddir_name,\n      'default_configuration': default_configuration,\n      'flock': flock_command,\n      'flock_index': 1,\n      'link_commands': LINK_COMMANDS_LINUX,\n      'extra_commands': '',\n      'srcdir': srcdir,\n      'copy_archive_args': copy_archive_arguments,\n    }\n  if flavor == 'mac':\n    flock_command = './gyp-mac-tool flock'\n    header_params.update({\n        'flock': flock_command,\n        'flock_index': 2,\n        'link_commands': LINK_COMMANDS_MAC,\n        'extra_commands': SHARED_HEADER_MAC_COMMANDS,\n    })\n  elif flavor == 'android':\n    header_params.update({\n        'link_commands': LINK_COMMANDS_ANDROID,\n    })\n  elif flavor == 'solaris':\n    header_params.update({\n        'flock': './gyp-flock-tool flock',\n        'flock_index': 2,\n    })\n  elif flavor == 'freebsd':\n    # Note: OpenBSD has sysutils/flock. lockf seems to be FreeBSD specific.\n    header_params.update({\n        'flock': 'lockf',\n    })\n  elif flavor == 'openbsd':\n    copy_archive_arguments = '-pPRf'\n    header_params.update({\n        'copy_archive_args': copy_archive_arguments,\n    })\n  elif flavor == 'aix':\n    copy_archive_arguments = '-pPRf'\n    header_params.update({\n        'copy_archive_args': copy_archive_arguments,\n        'link_commands': LINK_COMMANDS_AIX,\n        'flock': './gyp-flock-tool flock',\n        'flock_index': 2,\n    })\n\n  header_params.update({\n    'CC.target':   GetEnvironFallback(('CC_target', 'CC'), '$(CC)'),\n    'AR.target':   GetEnvironFallback(('AR_target', 'AR'), '$(AR)'),\n    'CXX.target':  GetEnvironFallback(('CXX_target', 'CXX'), '$(CXX)'),\n    'LINK.target': GetEnvironFallback(('LINK_target', 'LINK'), '$(LINK)'),\n    'CC.host':     GetEnvironFallback(('CC_host', 'CC'), 'gcc'),\n    'AR.host':     GetEnvironFallback(('AR_host', 'AR'), 'ar'),\n    'CXX.host':    GetEnvironFallback(('CXX_host', 'CXX'), 'g++'),\n    'LINK.host':   GetEnvironFallback(('LINK_host', 'LINK'), '$(CXX.host)'),\n  })\n\n  build_file, _, _ = gyp.common.ParseQualifiedTarget(target_list[0])\n  make_global_settings_array = data[build_file].get('make_global_settings', [])\n  wrappers = {}\n  for key, value in make_global_settings_array:\n    if key.endswith('_wrapper'):\n      wrappers[key[:-len('_wrapper')]] = '$(abspath %s)' % value\n  make_global_settings = ''\n  for key, value in make_global_settings_array:\n    if re.match('.*_wrapper', key):\n      continue\n    if value[0] != '$':\n      value = '$(abspath %s)' % value\n    wrapper = wrappers.get(key)\n    if wrapper:\n      value = '%s %s' % (wrapper, value)\n      del wrappers[key]\n    if key in ('CC', 'CC.host', 'CXX', 'CXX.host'):\n      make_global_settings += (\n          'ifneq (,$(filter $(origin %s), undefined default))\\n' % key)\n      # Let gyp-time envvars win over global settings.\n      env_key = key.replace('.', '_')  # CC.host -> CC_host\n      if env_key in os.environ:\n        value = os.environ[env_key]\n      make_global_settings += '  %s = %s\\n' % (key, value)\n      make_global_settings += 'endif\\n'\n    else:\n      make_global_settings += '%s ?= %s\\n' % (key, value)\n  # TODO(ukai): define cmd when only wrapper is specified in\n  # make_global_settings.\n\n  header_params['make_global_settings'] = make_global_settings\n\n  gyp.common.EnsureDirExists(makefile_path)\n  root_makefile = open(makefile_path, 'w')\n  root_makefile.write(SHARED_HEADER % header_params)\n  # Currently any versions have the same effect, but in future the behavior\n  # could be different.\n  if android_ndk_version:\n    root_makefile.write(\n        '# Define LOCAL_PATH for build of Android applications.\\n'\n        'LOCAL_PATH := $(call my-dir)\\n'\n        '\\n')\n  for toolset in toolsets:\n    root_makefile.write('TOOLSET := %s\\n' % toolset)\n    WriteRootHeaderSuffixRules(root_makefile)\n\n  # Put build-time support tools next to the root Makefile.\n  dest_path = os.path.dirname(makefile_path)\n  gyp.common.CopyTool(flavor, dest_path)\n\n  # Find the list of targets that derive from the gyp file(s) being built.\n  needed_targets = set()\n  for build_file in params['build_files']:\n    for target in gyp.common.AllTargets(target_list, target_dicts, build_file):\n      needed_targets.add(target)\n\n  build_files = set()\n  include_list = set()\n  for qualified_target in target_list:\n    build_file, target, toolset = gyp.common.ParseQualifiedTarget(\n        qualified_target)\n\n    this_make_global_settings = data[build_file].get('make_global_settings', [])\n    assert make_global_settings_array == this_make_global_settings, (\n        \"make_global_settings needs to be the same for all targets. %s vs. %s\" %\n        (this_make_global_settings, make_global_settings))\n\n    build_files.add(gyp.common.RelativePath(build_file, options.toplevel_dir))\n    included_files = data[build_file]['included_files']\n    for included_file in included_files:\n      # The included_files entries are relative to the dir of the build file\n      # that included them, so we have to undo that and then make them relative\n      # to the root dir.\n      relative_include_file = gyp.common.RelativePath(\n          gyp.common.UnrelativePath(included_file, build_file),\n          options.toplevel_dir)\n      abs_include_file = os.path.abspath(relative_include_file)\n      # If the include file is from the ~/.gyp dir, we should use absolute path\n      # so that relocating the src dir doesn't break the path.\n      if (params['home_dot_gyp'] and\n          abs_include_file.startswith(params['home_dot_gyp'])):\n        build_files.add(abs_include_file)\n      else:\n        build_files.add(relative_include_file)\n\n    base_path, output_file = CalculateMakefilePath(build_file,\n        target + '.' + toolset + options.suffix + '.mk')\n\n    spec = target_dicts[qualified_target]\n    configs = spec['configurations']\n\n    if flavor == 'mac':\n      gyp.xcode_emulation.MergeGlobalXcodeSettingsToSpec(data[build_file], spec)\n\n    writer = MakefileWriter(generator_flags, flavor)\n    writer.Write(qualified_target, base_path, output_file, spec, configs,\n                 part_of_all=qualified_target in needed_targets)\n\n    # Our root_makefile lives at the source root.  Compute the relative path\n    # from there to the output_file for including.\n    mkfile_rel_path = gyp.common.RelativePath(output_file,\n                                              os.path.dirname(makefile_path))\n    include_list.add(mkfile_rel_path)\n\n  # Write out per-gyp (sub-project) Makefiles.\n  depth_rel_path = gyp.common.RelativePath(options.depth, os.getcwd())\n  for build_file in build_files:\n    # The paths in build_files were relativized above, so undo that before\n    # testing against the non-relativized items in target_list and before\n    # calculating the Makefile path.\n    build_file = os.path.join(depth_rel_path, build_file)\n    gyp_targets = [target_dicts[target]['target_name'] for target in target_list\n                   if target.startswith(build_file) and\n                   target in needed_targets]\n    # Only generate Makefiles for gyp files with targets.\n    if not gyp_targets:\n      continue\n    base_path, output_file = CalculateMakefilePath(build_file,\n        os.path.splitext(os.path.basename(build_file))[0] + '.Makefile')\n    makefile_rel_path = gyp.common.RelativePath(os.path.dirname(makefile_path),\n                                                os.path.dirname(output_file))\n    writer.WriteSubMake(output_file, makefile_rel_path, gyp_targets,\n                        builddir_name)\n\n\n  # Write out the sorted list of includes.\n  root_makefile.write('\\n')\n  for include_file in sorted(include_list):\n    # We wrap each .mk include in an if statement so users can tell make to\n    # not load a file by setting NO_LOAD.  The below make code says, only\n    # load the .mk file if the .mk filename doesn't start with a token in\n    # NO_LOAD.\n    root_makefile.write(\n        \"ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\\\\n\"\n        \"    $(findstring $(join ^,$(prefix)),\\\\\\n\"\n        \"                 $(join ^,\" + include_file + \")))),)\\n\")\n    root_makefile.write(\"  include \" + include_file + \"\\n\")\n    root_makefile.write(\"endif\\n\")\n  root_makefile.write('\\n')\n\n  if (not generator_flags.get('standalone')\n      and generator_flags.get('auto_regeneration', True)):\n    WriteAutoRegenerationRule(params, root_makefile, makefile_name, build_files)\n\n  root_makefile.write(SHARED_FOOTER)\n\n  root_makefile.close()\n",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/include/node/uv-win.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef _WIN32_WINNT\n# define _WIN32_WINNT   0x0600\n#endif\n\n#if !defined(_SSIZE_T_) && !defined(_SSIZE_T_DEFINED)\ntypedef intptr_t ssize_t;\n# define _SSIZE_T_\n# define _SSIZE_T_DEFINED\n#endif\n\n#include <winsock2.h>\n\n#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)\ntypedef struct pollfd {\n  SOCKET fd;\n  short  events;\n  short  revents;\n} WSAPOLLFD, *PWSAPOLLFD, *LPWSAPOLLFD;\n#endif\n\n#ifndef LOCALE_INVARIANT\n# define LOCALE_INVARIANT 0x007f\n#endif\n\n#include <mswsock.h>\n#include <ws2tcpip.h>\n#include <windows.h>\n\n#include <process.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#include \"tree.h\"\n#include \"uv-threadpool.h\"\n\n#define MAX_PIPENAME_LEN 256\n\n#ifndef S_IFLNK\n# define S_IFLNK 0xA000\n#endif\n\n/* Additional signals supported by uv_signal and or uv_kill. The CRT defines\n * the following signals already:\n *\n *   #define SIGINT           2\n *   #define SIGILL           4\n *   #define SIGABRT_COMPAT   6\n *   #define SIGFPE           8\n *   #define SIGSEGV         11\n *   #define SIGTERM         15\n *   #define SIGBREAK        21\n *   #define SIGABRT         22\n *\n * The additional signals have values that are common on other Unix\n * variants (Linux and Darwin)\n */\n#define SIGHUP                1\n#define SIGKILL               9\n#define SIGWINCH             28\n\n/* The CRT defines SIGABRT_COMPAT as 6, which equals SIGABRT on many */\n/* unix-like platforms. However MinGW doesn't define it, so we do. */\n#ifndef SIGABRT_COMPAT\n# define SIGABRT_COMPAT       6\n#endif\n\n/*\n * Guids and typedefs for winsock extension functions\n * Mingw32 doesn't have these :-(\n */\n#ifndef WSAID_ACCEPTEX\n# define WSAID_ACCEPTEX                                                       \\\n         {0xb5367df1, 0xcbac, 0x11cf,                                         \\\n         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n\n# define WSAID_CONNECTEX                                                      \\\n         {0x25a207b9, 0xddf3, 0x4660,                                         \\\n         {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}}\n\n# define WSAID_GETACCEPTEXSOCKADDRS                                           \\\n         {0xb5367df2, 0xcbac, 0x11cf,                                         \\\n         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n\n# define WSAID_DISCONNECTEX                                                   \\\n         {0x7fda2e11, 0x8630, 0x436f,                                         \\\n         {0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57}}\n\n# define WSAID_TRANSMITFILE                                                   \\\n         {0xb5367df0, 0xcbac, 0x11cf,                                         \\\n         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n\n  typedef BOOL (PASCAL *LPFN_ACCEPTEX)\n                      (SOCKET sListenSocket,\n                       SOCKET sAcceptSocket,\n                       PVOID lpOutputBuffer,\n                       DWORD dwReceiveDataLength,\n                       DWORD dwLocalAddressLength,\n                       DWORD dwRemoteAddressLength,\n                       LPDWORD lpdwBytesReceived,\n                       LPOVERLAPPED lpOverlapped);\n\n  typedef BOOL (PASCAL *LPFN_CONNECTEX)\n                      (SOCKET s,\n                       const struct sockaddr* name,\n                       int namelen,\n                       PVOID lpSendBuffer,\n                       DWORD dwSendDataLength,\n                       LPDWORD lpdwBytesSent,\n                       LPOVERLAPPED lpOverlapped);\n\n  typedef void (PASCAL *LPFN_GETACCEPTEXSOCKADDRS)\n                      (PVOID lpOutputBuffer,\n                       DWORD dwReceiveDataLength,\n                       DWORD dwLocalAddressLength,\n                       DWORD dwRemoteAddressLength,\n                       LPSOCKADDR* LocalSockaddr,\n                       LPINT LocalSockaddrLength,\n                       LPSOCKADDR* RemoteSockaddr,\n                       LPINT RemoteSockaddrLength);\n\n  typedef BOOL (PASCAL *LPFN_DISCONNECTEX)\n                      (SOCKET hSocket,\n                       LPOVERLAPPED lpOverlapped,\n                       DWORD dwFlags,\n                       DWORD reserved);\n\n  typedef BOOL (PASCAL *LPFN_TRANSMITFILE)\n                      (SOCKET hSocket,\n                       HANDLE hFile,\n                       DWORD nNumberOfBytesToWrite,\n                       DWORD nNumberOfBytesPerSend,\n                       LPOVERLAPPED lpOverlapped,\n                       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,\n                       DWORD dwFlags);\n\n  typedef PVOID RTL_SRWLOCK;\n  typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;\n#endif\n\ntypedef int (WSAAPI* LPFN_WSARECV)\n            (SOCKET socket,\n             LPWSABUF buffers,\n             DWORD buffer_count,\n             LPDWORD bytes,\n             LPDWORD flags,\n             LPWSAOVERLAPPED overlapped,\n             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n\ntypedef int (WSAAPI* LPFN_WSARECVFROM)\n            (SOCKET socket,\n             LPWSABUF buffers,\n             DWORD buffer_count,\n             LPDWORD bytes,\n             LPDWORD flags,\n             struct sockaddr* addr,\n             LPINT addr_len,\n             LPWSAOVERLAPPED overlapped,\n             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n\n#ifndef _NTDEF_\n  typedef LONG NTSTATUS;\n  typedef NTSTATUS *PNTSTATUS;\n#endif\n\n#ifndef RTL_CONDITION_VARIABLE_INIT\n  typedef PVOID CONDITION_VARIABLE, *PCONDITION_VARIABLE;\n#endif\n\ntypedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE Handle;\n  ULONG Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;\n\ntypedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER Timeout;\n  ULONG NumberOfHandles;\n  ULONG Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;\n\n#define UV_MSAFD_PROVIDER_COUNT 3\n\n\n/**\n * It should be possible to cast uv_buf_t[] to WSABUF[]\n * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx\n */\ntypedef struct uv_buf_t {\n  ULONG len;\n  char* base;\n} uv_buf_t;\n\ntypedef int uv_file;\ntypedef SOCKET uv_os_sock_t;\ntypedef HANDLE uv_os_fd_t;\ntypedef int uv_pid_t;\n\ntypedef HANDLE uv_thread_t;\n\ntypedef HANDLE uv_sem_t;\n\ntypedef CRITICAL_SECTION uv_mutex_t;\n\n/* This condition variable implementation is based on the SetEvent solution\n * (section 3.2) at http://www.cs.wustl.edu/~schmidt/win32-cv-1.html\n * We could not use the SignalObjectAndWait solution (section 3.4) because\n * it want the 2nd argument (type uv_mutex_t) of uv_cond_wait() and\n * uv_cond_timedwait() to be HANDLEs, but we use CRITICAL_SECTIONs.\n */\n\ntypedef union {\n  CONDITION_VARIABLE cond_var;\n  struct {\n    unsigned int waiters_count;\n    CRITICAL_SECTION waiters_count_lock;\n    HANDLE signal_event;\n    HANDLE broadcast_event;\n  } fallback;\n} uv_cond_t;\n\ntypedef union {\n  struct {\n    unsigned int num_readers_;\n    CRITICAL_SECTION num_readers_lock_;\n    HANDLE write_semaphore_;\n  } state_;\n  /* TODO: remove me in v2.x. */\n  struct {\n    SRWLOCK unused_;\n  } unused1_;\n  /* TODO: remove me in v2.x. */\n  struct {\n    uv_mutex_t unused1_;\n    uv_mutex_t unused2_;\n  } unused2_;\n} uv_rwlock_t;\n\ntypedef struct {\n  unsigned int n;\n  unsigned int count;\n  uv_mutex_t mutex;\n  uv_sem_t turnstile1;\n  uv_sem_t turnstile2;\n} uv_barrier_t;\n\ntypedef struct {\n  DWORD tls_index;\n} uv_key_t;\n\n#define UV_ONCE_INIT { 0, NULL }\n\ntypedef struct uv_once_s {\n  unsigned char ran;\n  HANDLE event;\n} uv_once_t;\n\n/* Platform-specific definitions for uv_spawn support. */\ntypedef unsigned char uv_uid_t;\ntypedef unsigned char uv_gid_t;\n\ntypedef struct uv__dirent_s {\n  int d_type;\n  char d_name[1];\n} uv__dirent_t;\n\n#define HAVE_DIRENT_TYPES\n#define UV__DT_DIR     UV_DIRENT_DIR\n#define UV__DT_FILE    UV_DIRENT_FILE\n#define UV__DT_LINK    UV_DIRENT_LINK\n#define UV__DT_FIFO    UV_DIRENT_FIFO\n#define UV__DT_SOCKET  UV_DIRENT_SOCKET\n#define UV__DT_CHAR    UV_DIRENT_CHAR\n#define UV__DT_BLOCK   UV_DIRENT_BLOCK\n\n/* Platform-specific definitions for uv_dlopen support. */\n#define UV_DYNAMIC FAR WINAPI\ntypedef struct {\n  HMODULE handle;\n  char* errmsg;\n} uv_lib_t;\n\nRB_HEAD(uv_timer_tree_s, uv_timer_s);\n\n#define UV_LOOP_PRIVATE_FIELDS                                                \\\n    /* The loop's I/O completion port */                                      \\\n  HANDLE iocp;                                                                \\\n  /* The current time according to the event loop. in msecs. */               \\\n  uint64_t time;                                                              \\\n  /* Tail of a single-linked circular queue of pending reqs. If the queue */  \\\n  /* is empty, tail_ is NULL. If there is only one item, */                   \\\n  /* tail_->next_req == tail_ */                                              \\\n  uv_req_t* pending_reqs_tail;                                                \\\n  /* Head of a single-linked list of closed handles */                        \\\n  uv_handle_t* endgame_handles;                                               \\\n  /* The head of the timers tree */                                           \\\n  struct uv_timer_tree_s timers;                                              \\\n    /* Lists of active loop (prepare / check / idle) watchers */              \\\n  uv_prepare_t* prepare_handles;                                              \\\n  uv_check_t* check_handles;                                                  \\\n  uv_idle_t* idle_handles;                                                    \\\n  /* This pointer will refer to the prepare/check/idle handle whose */        \\\n  /* callback is scheduled to be called next. This is needed to allow */      \\\n  /* safe removal from one of the lists above while that list being */        \\\n  /* iterated over. */                                                        \\\n  uv_prepare_t* next_prepare_handle;                                          \\\n  uv_check_t* next_check_handle;                                              \\\n  uv_idle_t* next_idle_handle;                                                \\\n  /* This handle holds the peer sockets for the fast variant of uv_poll_t */  \\\n  SOCKET poll_peer_sockets[UV_MSAFD_PROVIDER_COUNT];                          \\\n  /* Counter to keep track of active tcp streams */                           \\\n  unsigned int active_tcp_streams;                                            \\\n  /* Counter to keep track of active udp streams */                           \\\n  unsigned int active_udp_streams;                                            \\\n  /* Counter to started timer */                                              \\\n  uint64_t timer_counter;                                                     \\\n  /* Threadpool */                                                            \\\n  void* wq[2];                                                                \\\n  uv_mutex_t wq_mutex;                                                        \\\n  uv_async_t wq_async;\n\n#define UV_REQ_TYPE_PRIVATE                                                   \\\n  /* TODO: remove the req suffix */                                           \\\n  UV_ACCEPT,                                                                  \\\n  UV_FS_EVENT_REQ,                                                            \\\n  UV_POLL_REQ,                                                                \\\n  UV_PROCESS_EXIT,                                                            \\\n  UV_READ,                                                                    \\\n  UV_UDP_RECV,                                                                \\\n  UV_WAKEUP,                                                                  \\\n  UV_SIGNAL_REQ,\n\n#define UV_REQ_PRIVATE_FIELDS                                                 \\\n  union {                                                                     \\\n    /* Used by I/O operations */                                              \\\n    struct {                                                                  \\\n      OVERLAPPED overlapped;                                                  \\\n      size_t queued_bytes;                                                    \\\n    } io;                                                                     \\\n  } u;                                                                        \\\n  struct uv_req_s* next_req;\n\n#define UV_WRITE_PRIVATE_FIELDS                                               \\\n  int ipc_header;                                                             \\\n  uv_buf_t write_buffer;                                                      \\\n  HANDLE event_handle;                                                        \\\n  HANDLE wait_handle;\n\n#define UV_CONNECT_PRIVATE_FIELDS                                             \\\n  /* empty */\n\n#define UV_SHUTDOWN_PRIVATE_FIELDS                                            \\\n  /* empty */\n\n#define UV_UDP_SEND_PRIVATE_FIELDS                                            \\\n  /* empty */\n\n#define UV_PRIVATE_REQ_TYPES                                                  \\\n  typedef struct uv_pipe_accept_s {                                           \\\n    UV_REQ_FIELDS                                                             \\\n    HANDLE pipeHandle;                                                        \\\n    struct uv_pipe_accept_s* next_pending;                                    \\\n  } uv_pipe_accept_t;                                                         \\\n                                                                              \\\n  typedef struct uv_tcp_accept_s {                                            \\\n    UV_REQ_FIELDS                                                             \\\n    SOCKET accept_socket;                                                     \\\n    char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32];             \\\n    HANDLE event_handle;                                                      \\\n    HANDLE wait_handle;                                                       \\\n    struct uv_tcp_accept_s* next_pending;                                     \\\n  } uv_tcp_accept_t;                                                          \\\n                                                                              \\\n  typedef struct uv_read_s {                                                  \\\n    UV_REQ_FIELDS                                                             \\\n    HANDLE event_handle;                                                      \\\n    HANDLE wait_handle;                                                       \\\n  } uv_read_t;\n\n#define uv_stream_connection_fields                                           \\\n  unsigned int write_reqs_pending;                                            \\\n  uv_shutdown_t* shutdown_req;\n\n#define uv_stream_server_fields                                               \\\n  uv_connection_cb connection_cb;\n\n#define UV_STREAM_PRIVATE_FIELDS                                              \\\n  unsigned int reqs_pending;                                                  \\\n  int activecnt;                                                              \\\n  uv_read_t read_req;                                                         \\\n  union {                                                                     \\\n    struct { uv_stream_connection_fields } conn;                              \\\n    struct { uv_stream_server_fields     } serv;                              \\\n  } stream;\n\n#define uv_tcp_server_fields                                                  \\\n  uv_tcp_accept_t* accept_reqs;                                               \\\n  unsigned int processed_accepts;                                             \\\n  uv_tcp_accept_t* pending_accepts;                                           \\\n  LPFN_ACCEPTEX func_acceptex;\n\n#define uv_tcp_connection_fields                                              \\\n  uv_buf_t read_buffer;                                                       \\\n  LPFN_CONNECTEX func_connectex;\n\n#define UV_TCP_PRIVATE_FIELDS                                                 \\\n  SOCKET socket;                                                              \\\n  int delayed_error;                                                          \\\n  union {                                                                     \\\n    struct { uv_tcp_server_fields } serv;                                     \\\n    struct { uv_tcp_connection_fields } conn;                                 \\\n  } tcp;\n\n#define UV_UDP_PRIVATE_FIELDS                                                 \\\n  SOCKET socket;                                                              \\\n  unsigned int reqs_pending;                                                  \\\n  int activecnt;                                                              \\\n  uv_req_t recv_req;                                                          \\\n  uv_buf_t recv_buffer;                                                       \\\n  struct sockaddr_storage recv_from;                                          \\\n  int recv_from_len;                                                          \\\n  uv_udp_recv_cb recv_cb;                                                     \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  LPFN_WSARECV func_wsarecv;                                                  \\\n  LPFN_WSARECVFROM func_wsarecvfrom;\n\n#define uv_pipe_server_fields                                                 \\\n  int pending_instances;                                                      \\\n  uv_pipe_accept_t* accept_reqs;                                              \\\n  uv_pipe_accept_t* pending_accepts;\n\n#define uv_pipe_connection_fields                                             \\\n  uv_timer_t* eof_timer;                                                      \\\n  uv_write_t ipc_header_write_req;                                            \\\n  int ipc_pid;                                                                \\\n  uint64_t remaining_ipc_rawdata_bytes;                                       \\\n  struct {                                                                    \\\n    void* queue[2];                                                           \\\n    int queue_len;                                                            \\\n  } pending_ipc_info;                                                         \\\n  uv_write_t* non_overlapped_writes_tail;                                     \\\n  uv_mutex_t readfile_mutex;                                                  \\\n  volatile HANDLE readfile_thread;\n\n#define UV_PIPE_PRIVATE_FIELDS                                                \\\n  HANDLE handle;                                                              \\\n  WCHAR* name;                                                                \\\n  union {                                                                     \\\n    struct { uv_pipe_server_fields } serv;                                    \\\n    struct { uv_pipe_connection_fields } conn;                                \\\n  } pipe;\n\n/* TODO: put the parser states in an union - TTY handles are always */\n/* half-duplex so read-state can safely overlap write-state. */\n#define UV_TTY_PRIVATE_FIELDS                                                 \\\n  HANDLE handle;                                                              \\\n  union {                                                                     \\\n    struct {                                                                  \\\n      /* Used for readable TTY handles */                                     \\\n      /* TODO: remove me in v2.x. */                                          \\\n      HANDLE unused_;                                                         \\\n      uv_buf_t read_line_buffer;                                              \\\n      HANDLE read_raw_wait;                                                   \\\n      /* Fields used for translating win keystrokes into vt100 characters */  \\\n      char last_key[8];                                                       \\\n      unsigned char last_key_offset;                                          \\\n      unsigned char last_key_len;                                             \\\n      WCHAR last_utf16_high_surrogate;                                        \\\n      INPUT_RECORD last_input_record;                                         \\\n    } rd;                                                                     \\\n    struct {                                                                  \\\n      /* Used for writable TTY handles */                                     \\\n      /* utf8-to-utf16 conversion state */                                    \\\n      unsigned int utf8_codepoint;                                            \\\n      unsigned char utf8_bytes_left;                                          \\\n      /* eol conversion state */                                              \\\n      unsigned char previous_eol;                                             \\\n      /* ansi parser state */                                                 \\\n      unsigned char ansi_parser_state;                                        \\\n      unsigned char ansi_csi_argc;                                            \\\n      unsigned short ansi_csi_argv[4];                                        \\\n      COORD saved_position;                                                   \\\n      WORD saved_attributes;                                                  \\\n    } wr;                                                                     \\\n  } tty;\n\n#define UV_POLL_PRIVATE_FIELDS                                                \\\n  SOCKET socket;                                                              \\\n  /* Used in fast mode */                                                     \\\n  SOCKET peer_socket;                                                         \\\n  AFD_POLL_INFO afd_poll_info_1;                                              \\\n  AFD_POLL_INFO afd_poll_info_2;                                              \\\n  /* Used in fast and slow mode. */                                           \\\n  uv_req_t poll_req_1;                                                        \\\n  uv_req_t poll_req_2;                                                        \\\n  unsigned char submitted_events_1;                                           \\\n  unsigned char submitted_events_2;                                           \\\n  unsigned char mask_events_1;                                                \\\n  unsigned char mask_events_2;                                                \\\n  unsigned char events;\n\n#define UV_TIMER_PRIVATE_FIELDS                                               \\\n  RB_ENTRY(uv_timer_s) tree_entry;                                            \\\n  uint64_t due;                                                               \\\n  uint64_t repeat;                                                            \\\n  uint64_t start_id;                                                          \\\n  uv_timer_cb timer_cb;\n\n#define UV_ASYNC_PRIVATE_FIELDS                                               \\\n  struct uv_req_s async_req;                                                  \\\n  uv_async_cb async_cb;                                                       \\\n  /* char to avoid alignment issues */                                        \\\n  char volatile async_sent;\n\n#define UV_PREPARE_PRIVATE_FIELDS                                             \\\n  uv_prepare_t* prepare_prev;                                                 \\\n  uv_prepare_t* prepare_next;                                                 \\\n  uv_prepare_cb prepare_cb;\n\n#define UV_CHECK_PRIVATE_FIELDS                                               \\\n  uv_check_t* check_prev;                                                     \\\n  uv_check_t* check_next;                                                     \\\n  uv_check_cb check_cb;\n\n#define UV_IDLE_PRIVATE_FIELDS                                                \\\n  uv_idle_t* idle_prev;                                                       \\\n  uv_idle_t* idle_next;                                                       \\\n  uv_idle_cb idle_cb;\n\n#define UV_HANDLE_PRIVATE_FIELDS                                              \\\n  uv_handle_t* endgame_next;                                                  \\\n  unsigned int flags;\n\n#define UV_GETADDRINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getaddrinfo_cb getaddrinfo_cb;                                           \\\n  void* alloc;                                                                \\\n  WCHAR* node;                                                                \\\n  WCHAR* service;                                                             \\\n  /* The addrinfoW field is used to store a pointer to the hints, and    */   \\\n  /* later on to store the result of GetAddrInfoW. The final result will */   \\\n  /* be converted to struct addrinfo* and stored in the addrinfo field.  */   \\\n  struct addrinfoW* addrinfow;                                                \\\n  struct addrinfo* addrinfo;                                                  \\\n  int retcode;\n\n#define UV_GETNAMEINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getnameinfo_cb getnameinfo_cb;                                           \\\n  struct sockaddr_storage storage;                                            \\\n  int flags;                                                                  \\\n  char host[NI_MAXHOST];                                                      \\\n  char service[NI_MAXSERV];                                                   \\\n  int retcode;\n\n#define UV_PROCESS_PRIVATE_FIELDS                                             \\\n  struct uv_process_exit_s {                                                  \\\n    UV_REQ_FIELDS                                                             \\\n  } exit_req;                                                                 \\\n  BYTE* child_stdio_buffer;                                                   \\\n  int exit_signal;                                                            \\\n  HANDLE wait_handle;                                                         \\\n  HANDLE process_handle;                                                      \\\n  volatile char exit_cb_pending;\n\n#define UV_FS_PRIVATE_FIELDS                                                  \\\n  struct uv__work work_req;                                                   \\\n  int flags;                                                                  \\\n  DWORD sys_errno_;                                                           \\\n  union {                                                                     \\\n    /* TODO: remove me in 0.9. */                                             \\\n    WCHAR* pathw;                                                             \\\n    int fd;                                                                   \\\n  } file;                                                                     \\\n  union {                                                                     \\\n    struct {                                                                  \\\n      int mode;                                                               \\\n      WCHAR* new_pathw;                                                       \\\n      int file_flags;                                                         \\\n      int fd_out;                                                             \\\n      unsigned int nbufs;                                                     \\\n      uv_buf_t* bufs;                                                         \\\n      int64_t offset;                                                         \\\n      uv_buf_t bufsml[4];                                                     \\\n    } info;                                                                   \\\n    struct {                                                                  \\\n      double atime;                                                           \\\n      double mtime;                                                           \\\n    } time;                                                                   \\\n  } fs;\n\n#define UV_WORK_PRIVATE_FIELDS                                                \\\n  struct uv__work work_req;\n\n#define UV_FS_EVENT_PRIVATE_FIELDS                                            \\\n  struct uv_fs_event_req_s {                                                  \\\n    UV_REQ_FIELDS                                                             \\\n  } req;                                                                      \\\n  HANDLE dir_handle;                                                          \\\n  int req_pending;                                                            \\\n  uv_fs_event_cb cb;                                                          \\\n  WCHAR* filew;                                                               \\\n  WCHAR* short_filew;                                                         \\\n  WCHAR* dirw;                                                                \\\n  char* buffer;\n\n#define UV_SIGNAL_PRIVATE_FIELDS                                              \\\n  RB_ENTRY(uv_signal_s) tree_entry;                                           \\\n  struct uv_req_s signal_req;                                                 \\\n  unsigned long pending_signum;\n\n#ifndef F_OK\n#define F_OK 0\n#endif\n#ifndef R_OK\n#define R_OK 4\n#endif\n#ifndef W_OK\n#define W_OK 2\n#endif\n#ifndef X_OK\n#define X_OK 1\n#endif\n\n/* fs open() flags supported on this platform: */\n#define UV_FS_O_APPEND       _O_APPEND\n#define UV_FS_O_CREAT        _O_CREAT\n#define UV_FS_O_EXCL         _O_EXCL\n#define UV_FS_O_RANDOM       _O_RANDOM\n#define UV_FS_O_RDONLY       _O_RDONLY\n#define UV_FS_O_RDWR         _O_RDWR\n#define UV_FS_O_SEQUENTIAL   _O_SEQUENTIAL\n#define UV_FS_O_SHORT_LIVED  _O_SHORT_LIVED\n#define UV_FS_O_TEMPORARY    _O_TEMPORARY\n#define UV_FS_O_TRUNC        _O_TRUNC\n#define UV_FS_O_WRONLY       _O_WRONLY\n\n/* fs open() flags supported on other platforms (or mapped on this platform): */\n#define UV_FS_O_DIRECT       0x02000000 /* FILE_FLAG_NO_BUFFERING */\n#define UV_FS_O_DIRECTORY    0\n#define UV_FS_O_DSYNC        0x04000000 /* FILE_FLAG_WRITE_THROUGH */\n#define UV_FS_O_EXLOCK       0x10000000 /* EXCLUSIVE SHARING MODE */\n#define UV_FS_O_NOATIME      0\n#define UV_FS_O_NOCTTY       0\n#define UV_FS_O_NOFOLLOW     0\n#define UV_FS_O_NONBLOCK     0\n#define UV_FS_O_SYMLINK      0\n#define UV_FS_O_SYNC         0x08000000 /* FILE_FLAG_WRITE_THROUGH */\n",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/include/node/uv.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n/* See https://github.com/libuv/libuv#documentation for documentation. */\n\n#ifndef UV_H\n#define UV_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _WIN32\n  /* Windows - set up dll import/export decorators. */\n# if defined(BUILDING_UV_SHARED)\n    /* Building shared library. */\n#   define UV_EXTERN __declspec(dllexport)\n# elif defined(USING_UV_SHARED)\n    /* Using shared library. */\n#   define UV_EXTERN __declspec(dllimport)\n# else\n    /* Building static library. */\n#   define UV_EXTERN /* nothing */\n# endif\n#elif __GNUC__ >= 4\n# define UV_EXTERN __attribute__((visibility(\"default\")))\n#else\n# define UV_EXTERN /* nothing */\n#endif\n\n#include \"uv-errno.h\"\n#include \"uv-version.h\"\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#if defined(_WIN32)\n# include \"uv-win.h\"\n#else\n# include \"uv-unix.h\"\n#endif\n\n/* Expand this list if necessary. */\n#define UV_ERRNO_MAP(XX)                                                      \\\n  XX(E2BIG, \"argument list too long\")                                         \\\n  XX(EACCES, \"permission denied\")                                             \\\n  XX(EADDRINUSE, \"address already in use\")                                    \\\n  XX(EADDRNOTAVAIL, \"address not available\")                                  \\\n  XX(EAFNOSUPPORT, \"address family not supported\")                            \\\n  XX(EAGAIN, \"resource temporarily unavailable\")                              \\\n  XX(EAI_ADDRFAMILY, \"address family not supported\")                          \\\n  XX(EAI_AGAIN, \"temporary failure\")                                          \\\n  XX(EAI_BADFLAGS, \"bad ai_flags value\")                                      \\\n  XX(EAI_BADHINTS, \"invalid value for hints\")                                 \\\n  XX(EAI_CANCELED, \"request canceled\")                                        \\\n  XX(EAI_FAIL, \"permanent failure\")                                           \\\n  XX(EAI_FAMILY, \"ai_family not supported\")                                   \\\n  XX(EAI_MEMORY, \"out of memory\")                                             \\\n  XX(EAI_NODATA, \"no address\")                                                \\\n  XX(EAI_NONAME, \"unknown node or service\")                                   \\\n  XX(EAI_OVERFLOW, \"argument buffer overflow\")                                \\\n  XX(EAI_PROTOCOL, \"resolved protocol is unknown\")                            \\\n  XX(EAI_SERVICE, \"service not available for socket type\")                    \\\n  XX(EAI_SOCKTYPE, \"socket type not supported\")                               \\\n  XX(EALREADY, \"connection already in progress\")                              \\\n  XX(EBADF, \"bad file descriptor\")                                            \\\n  XX(EBUSY, \"resource busy or locked\")                                        \\\n  XX(ECANCELED, \"operation canceled\")                                         \\\n  XX(ECHARSET, \"invalid Unicode character\")                                   \\\n  XX(ECONNABORTED, \"software caused connection abort\")                        \\\n  XX(ECONNREFUSED, \"connection refused\")                                      \\\n  XX(ECONNRESET, \"connection reset by peer\")                                  \\\n  XX(EDESTADDRREQ, \"destination address required\")                            \\\n  XX(EEXIST, \"file already exists\")                                           \\\n  XX(EFAULT, \"bad address in system call argument\")                           \\\n  XX(EFBIG, \"file too large\")                                                 \\\n  XX(EHOSTUNREACH, \"host is unreachable\")                                     \\\n  XX(EINTR, \"interrupted system call\")                                        \\\n  XX(EINVAL, \"invalid argument\")                                              \\\n  XX(EIO, \"i/o error\")                                                        \\\n  XX(EISCONN, \"socket is already connected\")                                  \\\n  XX(EISDIR, \"illegal operation on a directory\")                              \\\n  XX(ELOOP, \"too many symbolic links encountered\")                            \\\n  XX(EMFILE, \"too many open files\")                                           \\\n  XX(EMSGSIZE, \"message too long\")                                            \\\n  XX(ENAMETOOLONG, \"name too long\")                                           \\\n  XX(ENETDOWN, \"network is down\")                                             \\\n  XX(ENETUNREACH, \"network is unreachable\")                                   \\\n  XX(ENFILE, \"file table overflow\")                                           \\\n  XX(ENOBUFS, \"no buffer space available\")                                    \\\n  XX(ENODEV, \"no such device\")                                                \\\n  XX(ENOENT, \"no such file or directory\")                                     \\\n  XX(ENOMEM, \"not enough memory\")                                             \\\n  XX(ENONET, \"machine is not on the network\")                                 \\\n  XX(ENOPROTOOPT, \"protocol not available\")                                   \\\n  XX(ENOSPC, \"no space left on device\")                                       \\\n  XX(ENOSYS, \"function not implemented\")                                      \\\n  XX(ENOTCONN, \"socket is not connected\")                                     \\\n  XX(ENOTDIR, \"not a directory\")                                              \\\n  XX(ENOTEMPTY, \"directory not empty\")                                        \\\n  XX(ENOTSOCK, \"socket operation on non-socket\")                              \\\n  XX(ENOTSUP, \"operation not supported on socket\")                            \\\n  XX(EPERM, \"operation not permitted\")                                        \\\n  XX(EPIPE, \"broken pipe\")                                                    \\\n  XX(EPROTO, \"protocol error\")                                                \\\n  XX(EPROTONOSUPPORT, \"protocol not supported\")                               \\\n  XX(EPROTOTYPE, \"protocol wrong type for socket\")                            \\\n  XX(ERANGE, \"result too large\")                                              \\\n  XX(EROFS, \"read-only file system\")                                          \\\n  XX(ESHUTDOWN, \"cannot send after transport endpoint shutdown\")              \\\n  XX(ESPIPE, \"invalid seek\")                                                  \\\n  XX(ESRCH, \"no such process\")                                                \\\n  XX(ETIMEDOUT, \"connection timed out\")                                       \\\n  XX(ETXTBSY, \"text file is busy\")                                            \\\n  XX(EXDEV, \"cross-device link not permitted\")                                \\\n  XX(UNKNOWN, \"unknown error\")                                                \\\n  XX(EOF, \"end of file\")                                                      \\\n  XX(ENXIO, \"no such device or address\")                                      \\\n  XX(EMLINK, \"too many links\")                                                \\\n  XX(EHOSTDOWN, \"host is down\")                                               \\\n  XX(EREMOTEIO, \"remote I/O error\")                                           \\\n  XX(ENOTTY, \"inappropriate ioctl for device\")                                \\\n\n#define UV_HANDLE_TYPE_MAP(XX)                                                \\\n  XX(ASYNC, async)                                                            \\\n  XX(CHECK, check)                                                            \\\n  XX(FS_EVENT, fs_event)                                                      \\\n  XX(FS_POLL, fs_poll)                                                        \\\n  XX(HANDLE, handle)                                                          \\\n  XX(IDLE, idle)                                                              \\\n  XX(NAMED_PIPE, pipe)                                                        \\\n  XX(POLL, poll)                                                              \\\n  XX(PREPARE, prepare)                                                        \\\n  XX(PROCESS, process)                                                        \\\n  XX(STREAM, stream)                                                          \\\n  XX(TCP, tcp)                                                                \\\n  XX(TIMER, timer)                                                            \\\n  XX(TTY, tty)                                                                \\\n  XX(UDP, udp)                                                                \\\n  XX(SIGNAL, signal)                                                          \\\n\n#define UV_REQ_TYPE_MAP(XX)                                                   \\\n  XX(REQ, req)                                                                \\\n  XX(CONNECT, connect)                                                        \\\n  XX(WRITE, write)                                                            \\\n  XX(SHUTDOWN, shutdown)                                                      \\\n  XX(UDP_SEND, udp_send)                                                      \\\n  XX(FS, fs)                                                                  \\\n  XX(WORK, work)                                                              \\\n  XX(GETADDRINFO, getaddrinfo)                                                \\\n  XX(GETNAMEINFO, getnameinfo)                                                \\\n\ntypedef enum {\n#define XX(code, _) UV_ ## code = UV__ ## code,\n  UV_ERRNO_MAP(XX)\n#undef XX\n  UV_ERRNO_MAX = UV__EOF - 1\n} uv_errno_t;\n\ntypedef enum {\n  UV_UNKNOWN_HANDLE = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_HANDLE_TYPE_MAP(XX)\n#undef XX\n  UV_FILE,\n  UV_HANDLE_TYPE_MAX\n} uv_handle_type;\n\ntypedef enum {\n  UV_UNKNOWN_REQ = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_REQ_TYPE_MAP(XX)\n#undef XX\n  UV_REQ_TYPE_PRIVATE\n  UV_REQ_TYPE_MAX\n} uv_req_type;\n\n\n/* Handle types. */\ntypedef struct uv_loop_s uv_loop_t;\ntypedef struct uv_handle_s uv_handle_t;\ntypedef struct uv_stream_s uv_stream_t;\ntypedef struct uv_tcp_s uv_tcp_t;\ntypedef struct uv_udp_s uv_udp_t;\ntypedef struct uv_pipe_s uv_pipe_t;\ntypedef struct uv_tty_s uv_tty_t;\ntypedef struct uv_poll_s uv_poll_t;\ntypedef struct uv_timer_s uv_timer_t;\ntypedef struct uv_prepare_s uv_prepare_t;\ntypedef struct uv_check_s uv_check_t;\ntypedef struct uv_idle_s uv_idle_t;\ntypedef struct uv_async_s uv_async_t;\ntypedef struct uv_process_s uv_process_t;\ntypedef struct uv_fs_event_s uv_fs_event_t;\ntypedef struct uv_fs_poll_s uv_fs_poll_t;\ntypedef struct uv_signal_s uv_signal_t;\n\n/* Request types. */\ntypedef struct uv_req_s uv_req_t;\ntypedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\ntypedef struct uv_getnameinfo_s uv_getnameinfo_t;\ntypedef struct uv_shutdown_s uv_shutdown_t;\ntypedef struct uv_write_s uv_write_t;\ntypedef struct uv_connect_s uv_connect_t;\ntypedef struct uv_udp_send_s uv_udp_send_t;\ntypedef struct uv_fs_s uv_fs_t;\ntypedef struct uv_work_s uv_work_t;\n\n/* None of the above. */\ntypedef struct uv_cpu_info_s uv_cpu_info_t;\ntypedef struct uv_interface_address_s uv_interface_address_t;\ntypedef struct uv_dirent_s uv_dirent_t;\ntypedef struct uv_passwd_s uv_passwd_t;\n\ntypedef enum {\n  UV_LOOP_BLOCK_SIGNAL\n} uv_loop_option;\n\ntypedef enum {\n  UV_RUN_DEFAULT = 0,\n  UV_RUN_ONCE,\n  UV_RUN_NOWAIT\n} uv_run_mode;\n\n\nUV_EXTERN unsigned int uv_version(void);\nUV_EXTERN const char* uv_version_string(void);\n\ntypedef void* (*uv_malloc_func)(size_t size);\ntypedef void* (*uv_realloc_func)(void* ptr, size_t size);\ntypedef void* (*uv_calloc_func)(size_t count, size_t size);\ntypedef void (*uv_free_func)(void* ptr);\n\nUV_EXTERN int uv_replace_allocator(uv_malloc_func malloc_func,\n                                   uv_realloc_func realloc_func,\n                                   uv_calloc_func calloc_func,\n                                   uv_free_func free_func);\n\nUV_EXTERN uv_loop_t* uv_default_loop(void);\nUV_EXTERN int uv_loop_init(uv_loop_t* loop);\nUV_EXTERN int uv_loop_close(uv_loop_t* loop);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12), users should\n *  allocate the loop manually and use uv_loop_init instead.\n */\nUV_EXTERN uv_loop_t* uv_loop_new(void);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12). Users should use\n *  uv_loop_close and free the memory manually instead.\n */\nUV_EXTERN void uv_loop_delete(uv_loop_t*);\nUV_EXTERN size_t uv_loop_size(void);\nUV_EXTERN int uv_loop_alive(const uv_loop_t* loop);\nUV_EXTERN int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);\nUV_EXTERN int uv_loop_fork(uv_loop_t* loop);\n\nUV_EXTERN int uv_run(uv_loop_t*, uv_run_mode mode);\nUV_EXTERN void uv_stop(uv_loop_t*);\n\nUV_EXTERN void uv_ref(uv_handle_t*);\nUV_EXTERN void uv_unref(uv_handle_t*);\nUV_EXTERN int uv_has_ref(const uv_handle_t*);\n\nUV_EXTERN void uv_update_time(uv_loop_t*);\nUV_EXTERN uint64_t uv_now(const uv_loop_t*);\n\nUV_EXTERN int uv_backend_fd(const uv_loop_t*);\nUV_EXTERN int uv_backend_timeout(const uv_loop_t*);\n\ntypedef void (*uv_alloc_cb)(uv_handle_t* handle,\n                            size_t suggested_size,\n                            uv_buf_t* buf);\ntypedef void (*uv_read_cb)(uv_stream_t* stream,\n                           ssize_t nread,\n                           const uv_buf_t* buf);\ntypedef void (*uv_write_cb)(uv_write_t* req, int status);\ntypedef void (*uv_connect_cb)(uv_connect_t* req, int status);\ntypedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\ntypedef void (*uv_connection_cb)(uv_stream_t* server, int status);\ntypedef void (*uv_close_cb)(uv_handle_t* handle);\ntypedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);\ntypedef void (*uv_timer_cb)(uv_timer_t* handle);\ntypedef void (*uv_async_cb)(uv_async_t* handle);\ntypedef void (*uv_prepare_cb)(uv_prepare_t* handle);\ntypedef void (*uv_check_cb)(uv_check_t* handle);\ntypedef void (*uv_idle_cb)(uv_idle_t* handle);\ntypedef void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal);\ntypedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);\ntypedef void (*uv_fs_cb)(uv_fs_t* req);\ntypedef void (*uv_work_cb)(uv_work_t* req);\ntypedef void (*uv_after_work_cb)(uv_work_t* req, int status);\ntypedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,\n                                  int status,\n                                  struct addrinfo* res);\ntypedef void (*uv_getnameinfo_cb)(uv_getnameinfo_t* req,\n                                  int status,\n                                  const char* hostname,\n                                  const char* service);\n\ntypedef struct {\n  long tv_sec;\n  long tv_nsec;\n} uv_timespec_t;\n\n\ntypedef struct {\n  uint64_t st_dev;\n  uint64_t st_mode;\n  uint64_t st_nlink;\n  uint64_t st_uid;\n  uint64_t st_gid;\n  uint64_t st_rdev;\n  uint64_t st_ino;\n  uint64_t st_size;\n  uint64_t st_blksize;\n  uint64_t st_blocks;\n  uint64_t st_flags;\n  uint64_t st_gen;\n  uv_timespec_t st_atim;\n  uv_timespec_t st_mtim;\n  uv_timespec_t st_ctim;\n  uv_timespec_t st_birthtim;\n} uv_stat_t;\n\n\ntypedef void (*uv_fs_event_cb)(uv_fs_event_t* handle,\n                               const char* filename,\n                               int events,\n                               int status);\n\ntypedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,\n                              int status,\n                              const uv_stat_t* prev,\n                              const uv_stat_t* curr);\n\ntypedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);\n\n\ntypedef enum {\n  UV_LEAVE_GROUP = 0,\n  UV_JOIN_GROUP\n} uv_membership;\n\n\nUV_EXTERN int uv_translate_sys_error(int sys_errno);\n\nUV_EXTERN const char* uv_strerror(int err);\nUV_EXTERN const char* uv_err_name(int err);\n\n\n#define UV_REQ_FIELDS                                                         \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_req_type type;                                                           \\\n  /* private */                                                               \\\n  void* active_queue[2];                                                      \\\n  void* reserved[4];                                                          \\\n  UV_REQ_PRIVATE_FIELDS                                                       \\\n\n/* Abstract base class of all requests. */\nstruct uv_req_s {\n  UV_REQ_FIELDS\n};\n\n\n/* Platform-specific request types. */\nUV_PRIVATE_REQ_TYPES\n\n\nUV_EXTERN int uv_shutdown(uv_shutdown_t* req,\n                          uv_stream_t* handle,\n                          uv_shutdown_cb cb);\n\nstruct uv_shutdown_s {\n  UV_REQ_FIELDS\n  uv_stream_t* handle;\n  uv_shutdown_cb cb;\n  UV_SHUTDOWN_PRIVATE_FIELDS\n};\n\n\n#define UV_HANDLE_FIELDS                                                      \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_loop_t* loop;                                                            \\\n  uv_handle_type type;                                                        \\\n  /* private */                                                               \\\n  uv_close_cb close_cb;                                                       \\\n  void* handle_queue[2];                                                      \\\n  union {                                                                     \\\n    int fd;                                                                   \\\n    void* reserved[4];                                                        \\\n  } u;                                                                        \\\n  UV_HANDLE_PRIVATE_FIELDS                                                    \\\n\n/* The abstract base class of all handles. */\nstruct uv_handle_s {\n  UV_HANDLE_FIELDS\n};\n\nUV_EXTERN size_t uv_handle_size(uv_handle_type type);\nUV_EXTERN uv_handle_type uv_handle_get_type(const uv_handle_t* handle);\nUV_EXTERN const char* uv_handle_type_name(uv_handle_type type);\nUV_EXTERN void* uv_handle_get_data(const uv_handle_t* handle);\nUV_EXTERN uv_loop_t* uv_handle_get_loop(const uv_handle_t* handle);\nUV_EXTERN void uv_handle_set_data(uv_handle_t* handle, void* data);\n\nUV_EXTERN size_t uv_req_size(uv_req_type type);\nUV_EXTERN void* uv_req_get_data(const uv_req_t* req);\nUV_EXTERN void uv_req_set_data(uv_req_t* req, void* data);\nUV_EXTERN uv_req_type uv_req_get_type(const uv_req_t* req);\nUV_EXTERN const char* uv_req_type_name(uv_req_type type);\n\nUV_EXTERN int uv_is_active(const uv_handle_t* handle);\n\nUV_EXTERN void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);\n\n/* Helpers for ad hoc debugging, no API/ABI stability guaranteed. */\nUV_EXTERN void uv_print_all_handles(uv_loop_t* loop, FILE* stream);\nUV_EXTERN void uv_print_active_handles(uv_loop_t* loop, FILE* stream);\n\nUV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n\nUV_EXTERN int uv_send_buffer_size(uv_handle_t* handle, int* value);\nUV_EXTERN int uv_recv_buffer_size(uv_handle_t* handle, int* value);\n\nUV_EXTERN int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);\n\nUV_EXTERN uv_buf_t uv_buf_init(char* base, unsigned int len);\n\n\n#define UV_STREAM_FIELDS                                                      \\\n  /* number of bytes queued for writing */                                    \\\n  size_t write_queue_size;                                                    \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_read_cb read_cb;                                                         \\\n  /* private */                                                               \\\n  UV_STREAM_PRIVATE_FIELDS\n\n/*\n * uv_stream_t is a subclass of uv_handle_t.\n *\n * uv_stream is an abstract class.\n *\n * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t and uv_tty_t.\n */\nstruct uv_stream_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n};\n\nUV_EXTERN size_t uv_stream_get_write_queue_size(const uv_stream_t* stream);\n\nUV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\nUV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);\n\nUV_EXTERN int uv_read_start(uv_stream_t*,\n                            uv_alloc_cb alloc_cb,\n                            uv_read_cb read_cb);\nUV_EXTERN int uv_read_stop(uv_stream_t*);\n\nUV_EXTERN int uv_write(uv_write_t* req,\n                       uv_stream_t* handle,\n                       const uv_buf_t bufs[],\n                       unsigned int nbufs,\n                       uv_write_cb cb);\nUV_EXTERN int uv_write2(uv_write_t* req,\n                        uv_stream_t* handle,\n                        const uv_buf_t bufs[],\n                        unsigned int nbufs,\n                        uv_stream_t* send_handle,\n                        uv_write_cb cb);\nUV_EXTERN int uv_try_write(uv_stream_t* handle,\n                           const uv_buf_t bufs[],\n                           unsigned int nbufs);\n\n/* uv_write_t is a subclass of uv_req_t. */\nstruct uv_write_s {\n  UV_REQ_FIELDS\n  uv_write_cb cb;\n  uv_stream_t* send_handle;\n  uv_stream_t* handle;\n  UV_WRITE_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_is_readable(const uv_stream_t* handle);\nUV_EXTERN int uv_is_writable(const uv_stream_t* handle);\n\nUV_EXTERN int uv_stream_set_blocking(uv_stream_t* handle, int blocking);\n\nUV_EXTERN int uv_is_closing(const uv_handle_t* handle);\n\n\n/*\n * uv_tcp_t is a subclass of uv_stream_t.\n *\n * Represents a TCP stream or TCP server.\n */\nstruct uv_tcp_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TCP_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\nUV_EXTERN int uv_tcp_init_ex(uv_loop_t*, uv_tcp_t* handle, unsigned int flags);\nUV_EXTERN int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\nUV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle,\n                               int enable,\n                               unsigned int delay);\nUV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);\n\nenum uv_tcp_flags {\n  /* Used with uv_tcp_bind, when an IPv6 address is used. */\n  UV_TCP_IPV6ONLY = 1\n};\n\nUV_EXTERN int uv_tcp_bind(uv_tcp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\nUV_EXTERN int uv_tcp_getsockname(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_getpeername(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_connect(uv_connect_t* req,\n                             uv_tcp_t* handle,\n                             const struct sockaddr* addr,\n                             uv_connect_cb cb);\n\n/* uv_connect_t is a subclass of uv_req_t. */\nstruct uv_connect_s {\n  UV_REQ_FIELDS\n  uv_connect_cb cb;\n  uv_stream_t* handle;\n  UV_CONNECT_PRIVATE_FIELDS\n};\n\n\n/*\n * UDP support.\n */\n\nenum uv_udp_flags {\n  /* Disables dual stack mode. */\n  UV_UDP_IPV6ONLY = 1,\n  /*\n   * Indicates message was truncated because read buffer was too small. The\n   * remainder was discarded by the OS. Used in uv_udp_recv_cb.\n   */\n  UV_UDP_PARTIAL = 2,\n  /*\n   * Indicates if SO_REUSEADDR will be set when binding the handle.\n   * This sets the SO_REUSEPORT socket flag on the BSDs and OS X. On other\n   * Unix platforms, it sets the SO_REUSEADDR flag.  What that means is that\n   * multiple threads or processes can bind to the same address without error\n   * (provided they all set the flag) but only the last one to bind will receive\n   * any traffic, in effect \"stealing\" the port from the previous listener.\n   */\n  UV_UDP_REUSEADDR = 4\n};\n\ntypedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);\ntypedef void (*uv_udp_recv_cb)(uv_udp_t* handle,\n                               ssize_t nread,\n                               const uv_buf_t* buf,\n                               const struct sockaddr* addr,\n                               unsigned flags);\n\n/* uv_udp_t is a subclass of uv_handle_t. */\nstruct uv_udp_s {\n  UV_HANDLE_FIELDS\n  /* read-only */\n  /*\n   * Number of bytes queued for sending. This field strictly shows how much\n   * information is currently queued.\n   */\n  size_t send_queue_size;\n  /*\n   * Number of send requests currently in the queue awaiting to be processed.\n   */\n  size_t send_queue_count;\n  UV_UDP_PRIVATE_FIELDS\n};\n\n/* uv_udp_send_t is a subclass of uv_req_t. */\nstruct uv_udp_send_s {\n  UV_REQ_FIELDS\n  uv_udp_t* handle;\n  uv_udp_send_cb cb;\n  UV_UDP_SEND_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\nUV_EXTERN int uv_udp_init_ex(uv_loop_t*, uv_udp_t* handle, unsigned int flags);\nUV_EXTERN int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_udp_bind(uv_udp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\n\nUV_EXTERN int uv_udp_getsockname(const uv_udp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,\n                                    const char* multicast_addr,\n                                    const char* interface_addr,\n                                    uv_membership membership);\nUV_EXTERN int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_set_multicast_interface(uv_udp_t* handle,\n                                             const char* interface_addr);\nUV_EXTERN int uv_udp_set_broadcast(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_send(uv_udp_send_t* req,\n                          uv_udp_t* handle,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          const struct sockaddr* addr,\n                          uv_udp_send_cb send_cb);\nUV_EXTERN int uv_udp_try_send(uv_udp_t* handle,\n                              const uv_buf_t bufs[],\n                              unsigned int nbufs,\n                              const struct sockaddr* addr);\nUV_EXTERN int uv_udp_recv_start(uv_udp_t* handle,\n                                uv_alloc_cb alloc_cb,\n                                uv_udp_recv_cb recv_cb);\nUV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);\nUV_EXTERN size_t uv_udp_get_send_queue_size(const uv_udp_t* handle);\nUV_EXTERN size_t uv_udp_get_send_queue_count(const uv_udp_t* handle);\n\n\n/*\n * uv_tty_t is a subclass of uv_stream_t.\n *\n * Representing a stream for the console.\n */\nstruct uv_tty_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TTY_PRIVATE_FIELDS\n};\n\ntypedef enum {\n  /* Initial/normal terminal mode */\n  UV_TTY_MODE_NORMAL,\n  /* Raw input mode (On Windows, ENABLE_WINDOW_INPUT is also enabled) */\n  UV_TTY_MODE_RAW,\n  /* Binary-safe I/O mode for IPC (Unix-only) */\n  UV_TTY_MODE_IO\n} uv_tty_mode_t;\n\nUV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\nUV_EXTERN int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);\nUV_EXTERN int uv_tty_reset_mode(void);\nUV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n\n#ifdef __cplusplus\nextern \"C++\" {\n\ninline int uv_tty_set_mode(uv_tty_t* handle, int mode) {\n  return uv_tty_set_mode(handle, static_cast<uv_tty_mode_t>(mode));\n}\n\n}\n#endif\n\nUV_EXTERN uv_handle_type uv_guess_handle(uv_file file);\n\n/*\n * uv_pipe_t is a subclass of uv_stream_t.\n *\n * Representing a pipe stream or pipe server. On Windows this is a Named\n * Pipe. On Unix this is a Unix domain socket.\n */\nstruct uv_pipe_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  int ipc; /* non-zero if this pipe is used for passing handles */\n  UV_PIPE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\nUV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);\nUV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);\nUV_EXTERN void uv_pipe_connect(uv_connect_t* req,\n                               uv_pipe_t* handle,\n                               const char* name,\n                               uv_connect_cb cb);\nUV_EXTERN int uv_pipe_getsockname(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN int uv_pipe_getpeername(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN void uv_pipe_pending_instances(uv_pipe_t* handle, int count);\nUV_EXTERN int uv_pipe_pending_count(uv_pipe_t* handle);\nUV_EXTERN uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);\nUV_EXTERN int uv_pipe_chmod(uv_pipe_t* handle, int flags);\n\n\nstruct uv_poll_s {\n  UV_HANDLE_FIELDS\n  uv_poll_cb poll_cb;\n  UV_POLL_PRIVATE_FIELDS\n};\n\nenum uv_poll_event {\n  UV_READABLE = 1,\n  UV_WRITABLE = 2,\n  UV_DISCONNECT = 4,\n  UV_PRIORITIZED = 8\n};\n\nUV_EXTERN int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);\nUV_EXTERN int uv_poll_init_socket(uv_loop_t* loop,\n                                  uv_poll_t* handle,\n                                  uv_os_sock_t socket);\nUV_EXTERN int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nUV_EXTERN int uv_poll_stop(uv_poll_t* handle);\n\n\nstruct uv_prepare_s {\n  UV_HANDLE_FIELDS\n  UV_PREPARE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\nUV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\nUV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);\n\n\nstruct uv_check_s {\n  UV_HANDLE_FIELDS\n  UV_CHECK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);\nUV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);\nUV_EXTERN int uv_check_stop(uv_check_t* check);\n\n\nstruct uv_idle_s {\n  UV_HANDLE_FIELDS\n  UV_IDLE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\nUV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\nUV_EXTERN int uv_idle_stop(uv_idle_t* idle);\n\n\nstruct uv_async_s {\n  UV_HANDLE_FIELDS\n  UV_ASYNC_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_async_init(uv_loop_t*,\n                            uv_async_t* async,\n                            uv_async_cb async_cb);\nUV_EXTERN int uv_async_send(uv_async_t* async);\n\n\n/*\n * uv_timer_t is a subclass of uv_handle_t.\n *\n * Used to get woken up at a specified time in the future.\n */\nstruct uv_timer_s {\n  UV_HANDLE_FIELDS\n  UV_TIMER_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* handle);\nUV_EXTERN int uv_timer_start(uv_timer_t* handle,\n                             uv_timer_cb cb,\n                             uint64_t timeout,\n                             uint64_t repeat);\nUV_EXTERN int uv_timer_stop(uv_timer_t* handle);\nUV_EXTERN int uv_timer_again(uv_timer_t* handle);\nUV_EXTERN void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);\nUV_EXTERN uint64_t uv_timer_get_repeat(const uv_timer_t* handle);\n\n\n/*\n * uv_getaddrinfo_t is a subclass of uv_req_t.\n *\n * Request object for uv_getaddrinfo.\n */\nstruct uv_getaddrinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* struct addrinfo* addrinfo is marked as private, but it really isn't. */\n  UV_GETADDRINFO_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_getaddrinfo(uv_loop_t* loop,\n                             uv_getaddrinfo_t* req,\n                             uv_getaddrinfo_cb getaddrinfo_cb,\n                             const char* node,\n                             const char* service,\n                             const struct addrinfo* hints);\nUV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);\n\n\n/*\n* uv_getnameinfo_t is a subclass of uv_req_t.\n*\n* Request object for uv_getnameinfo.\n*/\nstruct uv_getnameinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* host and service are marked as private, but they really aren't. */\n  UV_GETNAMEINFO_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_getnameinfo(uv_loop_t* loop,\n                             uv_getnameinfo_t* req,\n                             uv_getnameinfo_cb getnameinfo_cb,\n                             const struct sockaddr* addr,\n                             int flags);\n\n\n/* uv_spawn() options. */\ntypedef enum {\n  UV_IGNORE         = 0x00,\n  UV_CREATE_PIPE    = 0x01,\n  UV_INHERIT_FD     = 0x02,\n  UV_INHERIT_STREAM = 0x04,\n\n  /*\n   * When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and UV_WRITABLE_PIPE\n   * determine the direction of flow, from the child process' perspective. Both\n   * flags may be specified to create a duplex data stream.\n   */\n  UV_READABLE_PIPE  = 0x10,\n  UV_WRITABLE_PIPE  = 0x20\n} uv_stdio_flags;\n\ntypedef struct uv_stdio_container_s {\n  uv_stdio_flags flags;\n\n  union {\n    uv_stream_t* stream;\n    int fd;\n  } data;\n} uv_stdio_container_t;\n\ntypedef struct uv_process_options_s {\n  uv_exit_cb exit_cb; /* Called after the process exits. */\n  const char* file;   /* Path to program to execute. */\n  /*\n   * Command line arguments. args[0] should be the path to the program. On\n   * Windows this uses CreateProcess which concatenates the arguments into a\n   * string this can cause some strange errors. See the note at\n   * windows_verbatim_arguments.\n   */\n  char** args;\n  /*\n   * This will be set as the environ variable in the subprocess. If this is\n   * NULL then the parents environ will be used.\n   */\n  char** env;\n  /*\n   * If non-null this represents a directory the subprocess should execute\n   * in. Stands for current working directory.\n   */\n  const char* cwd;\n  /*\n   * Various flags that control how uv_spawn() behaves. See the definition of\n   * `enum uv_process_flags` below.\n   */\n  unsigned int flags;\n  /*\n   * The `stdio` field points to an array of uv_stdio_container_t structs that\n   * describe the file descriptors that will be made available to the child\n   * process. The convention is that stdio[0] points to stdin, fd 1 is used for\n   * stdout, and fd 2 is stderr.\n   *\n   * Note that on windows file descriptors greater than 2 are available to the\n   * child process only if the child processes uses the MSVCRT runtime.\n   */\n  int stdio_count;\n  uv_stdio_container_t* stdio;\n  /*\n   * Libuv can change the child process' user/group id. This happens only when\n   * the appropriate bits are set in the flags fields. This is not supported on\n   * windows; uv_spawn() will fail and set the error to UV_ENOTSUP.\n   */\n  uv_uid_t uid;\n  uv_gid_t gid;\n} uv_process_options_t;\n\n/*\n * These are the flags that can be used for the uv_process_options.flags field.\n */\nenum uv_process_flags {\n  /*\n   * Set the child process' user id. The user id is supplied in the `uid` field\n   * of the options struct. This does not work on windows; setting this flag\n   * will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETUID = (1 << 0),\n  /*\n   * Set the child process' group id. The user id is supplied in the `gid`\n   * field of the options struct. This does not work on windows; setting this\n   * flag will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETGID = (1 << 1),\n  /*\n   * Do not wrap any arguments in quotes, or perform any other escaping, when\n   * converting the argument list into a command line string. This option is\n   * only meaningful on Windows systems. On Unix it is silently ignored.\n   */\n  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),\n  /*\n   * Spawn the child process in a detached state - this will make it a process\n   * group leader, and will effectively enable the child to keep running after\n   * the parent exits.  Note that the child process will still keep the\n   * parent's event loop alive unless the parent process calls uv_unref() on\n   * the child's process handle.\n   */\n  UV_PROCESS_DETACHED = (1 << 3),\n  /*\n   * Hide the subprocess console window that would normally be created. This\n   * option is only meaningful on Windows systems. On Unix it is silently\n   * ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE = (1 << 4)\n};\n\n/*\n * uv_process_t is a subclass of uv_handle_t.\n */\nstruct uv_process_s {\n  UV_HANDLE_FIELDS\n  uv_exit_cb exit_cb;\n  int pid;\n  UV_PROCESS_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_spawn(uv_loop_t* loop,\n                       uv_process_t* handle,\n                       const uv_process_options_t* options);\nUV_EXTERN int uv_process_kill(uv_process_t*, int signum);\nUV_EXTERN int uv_kill(int pid, int signum);\nUV_EXTERN uv_pid_t uv_process_get_pid(const uv_process_t*);\n\n\n/*\n * uv_work_t is a subclass of uv_req_t.\n */\nstruct uv_work_s {\n  UV_REQ_FIELDS\n  uv_loop_t* loop;\n  uv_work_cb work_cb;\n  uv_after_work_cb after_work_cb;\n  UV_WORK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_queue_work(uv_loop_t* loop,\n                            uv_work_t* req,\n                            uv_work_cb work_cb,\n                            uv_after_work_cb after_work_cb);\n\nUV_EXTERN int uv_cancel(uv_req_t* req);\n\n\nstruct uv_cpu_info_s {\n  char* model;\n  int speed;\n  struct uv_cpu_times_s {\n    uint64_t user;\n    uint64_t nice;\n    uint64_t sys;\n    uint64_t idle;\n    uint64_t irq;\n  } cpu_times;\n};\n\nstruct uv_interface_address_s {\n  char* name;\n  char phys_addr[6];\n  int is_internal;\n  union {\n    struct sockaddr_in address4;\n    struct sockaddr_in6 address6;\n  } address;\n  union {\n    struct sockaddr_in netmask4;\n    struct sockaddr_in6 netmask6;\n  } netmask;\n};\n\nstruct uv_passwd_s {\n  char* username;\n  long uid;\n  long gid;\n  char* shell;\n  char* homedir;\n};\n\ntypedef enum {\n  UV_DIRENT_UNKNOWN,\n  UV_DIRENT_FILE,\n  UV_DIRENT_DIR,\n  UV_DIRENT_LINK,\n  UV_DIRENT_FIFO,\n  UV_DIRENT_SOCKET,\n  UV_DIRENT_CHAR,\n  UV_DIRENT_BLOCK\n} uv_dirent_type_t;\n\nstruct uv_dirent_s {\n  const char* name;\n  uv_dirent_type_t type;\n};\n\nUV_EXTERN char** uv_setup_args(int argc, char** argv);\nUV_EXTERN int uv_get_process_title(char* buffer, size_t size);\nUV_EXTERN int uv_set_process_title(const char* title);\nUV_EXTERN int uv_resident_set_memory(size_t* rss);\nUV_EXTERN int uv_uptime(double* uptime);\nUV_EXTERN uv_os_fd_t uv_get_osfhandle(int fd);\n\ntypedef struct {\n  long tv_sec;\n  long tv_usec;\n} uv_timeval_t;\n\ntypedef struct {\n   uv_timeval_t ru_utime; /* user CPU time used */\n   uv_timeval_t ru_stime; /* system CPU time used */\n   uint64_t ru_maxrss;    /* maximum resident set size */\n   uint64_t ru_ixrss;     /* integral shared memory size */\n   uint64_t ru_idrss;     /* integral unshared data size */\n   uint64_t ru_isrss;     /* integral unshared stack size */\n   uint64_t ru_minflt;    /* page reclaims (soft page faults) */\n   uint64_t ru_majflt;    /* page faults (hard page faults) */\n   uint64_t ru_nswap;     /* swaps */\n   uint64_t ru_inblock;   /* block input operations */\n   uint64_t ru_oublock;   /* block output operations */\n   uint64_t ru_msgsnd;    /* IPC messages sent */\n   uint64_t ru_msgrcv;    /* IPC messages received */\n   uint64_t ru_nsignals;  /* signals received */\n   uint64_t ru_nvcsw;     /* voluntary context switches */\n   uint64_t ru_nivcsw;    /* involuntary context switches */\n} uv_rusage_t;\n\nUV_EXTERN int uv_getrusage(uv_rusage_t* rusage);\n\nUV_EXTERN int uv_os_homedir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_tmpdir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_get_passwd(uv_passwd_t* pwd);\nUV_EXTERN void uv_os_free_passwd(uv_passwd_t* pwd);\nUV_EXTERN uv_pid_t uv_os_getpid(void);\nUV_EXTERN uv_pid_t uv_os_getppid(void);\n\nUV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);\nUV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);\n\nUV_EXTERN int uv_interface_addresses(uv_interface_address_t** addresses,\n                                     int* count);\nUV_EXTERN void uv_free_interface_addresses(uv_interface_address_t* addresses,\n                                           int count);\n\nUV_EXTERN int uv_os_getenv(const char* name, char* buffer, size_t* size);\nUV_EXTERN int uv_os_setenv(const char* name, const char* value);\nUV_EXTERN int uv_os_unsetenv(const char* name);\n\nUV_EXTERN int uv_os_gethostname(char* buffer, size_t* size);\n\n\ntypedef enum {\n  UV_FS_UNKNOWN = -1,\n  UV_FS_CUSTOM,\n  UV_FS_OPEN,\n  UV_FS_CLOSE,\n  UV_FS_READ,\n  UV_FS_WRITE,\n  UV_FS_SENDFILE,\n  UV_FS_STAT,\n  UV_FS_LSTAT,\n  UV_FS_FSTAT,\n  UV_FS_FTRUNCATE,\n  UV_FS_UTIME,\n  UV_FS_FUTIME,\n  UV_FS_ACCESS,\n  UV_FS_CHMOD,\n  UV_FS_FCHMOD,\n  UV_FS_FSYNC,\n  UV_FS_FDATASYNC,\n  UV_FS_UNLINK,\n  UV_FS_RMDIR,\n  UV_FS_MKDIR,\n  UV_FS_MKDTEMP,\n  UV_FS_RENAME,\n  UV_FS_SCANDIR,\n  UV_FS_LINK,\n  UV_FS_SYMLINK,\n  UV_FS_READLINK,\n  UV_FS_CHOWN,\n  UV_FS_FCHOWN,\n  UV_FS_REALPATH,\n  UV_FS_COPYFILE\n} uv_fs_type;\n\n/* uv_fs_t is a subclass of uv_req_t. */\nstruct uv_fs_s {\n  UV_REQ_FIELDS\n  uv_fs_type fs_type;\n  uv_loop_t* loop;\n  uv_fs_cb cb;\n  ssize_t result;\n  void* ptr;\n  const char* path;\n  uv_stat_t statbuf;  /* Stores the result of uv_fs_stat() and uv_fs_fstat(). */\n  UV_FS_PRIVATE_FIELDS\n};\n\nUV_EXTERN uv_fs_type uv_fs_get_type(const uv_fs_t*);\nUV_EXTERN ssize_t uv_fs_get_result(const uv_fs_t*);\nUV_EXTERN void* uv_fs_get_ptr(const uv_fs_t*);\nUV_EXTERN const char* uv_fs_get_path(const uv_fs_t*);\nUV_EXTERN uv_stat_t* uv_fs_get_statbuf(uv_fs_t*);\n\nUV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);\nUV_EXTERN int uv_fs_close(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_open(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         int flags,\n                         int mode,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_read(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         uv_file file,\n                         const uv_buf_t bufs[],\n                         unsigned int nbufs,\n                         int64_t offset,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_unlink(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_write(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          int64_t offset,\n                          uv_fs_cb cb);\n/*\n * This flag can be used with uv_fs_copyfile() to return an error if the\n * destination already exists.\n */\n#define UV_FS_COPYFILE_EXCL   0x0001\n\nUV_EXTERN int uv_fs_copyfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             const char* new_path,\n                             int flags,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdtemp(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* tpl,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_rmdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir_next(uv_fs_t* req,\n                                 uv_dirent_t* ent);\nUV_EXTERN int uv_fs_stat(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_fstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_rename(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           const char* new_path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_fsync(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              int64_t offset,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_sendfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             uv_file out_fd,\n                             uv_file in_fd,\n                             int64_t in_offset,\n                             size_t length,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_access(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chmod(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_utime(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          double atime,\n                          double mtime,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_futime(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           double atime,\n                           double mtime,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_lstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_link(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         const char* new_path,\n                         uv_fs_cb cb);\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * path argument points to a directory.\n */\n#define UV_FS_SYMLINK_DIR          0x0001\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * the symlink is to be created using junction points.\n */\n#define UV_FS_SYMLINK_JUNCTION     0x0002\n\nUV_EXTERN int uv_fs_symlink(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            const char* new_path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_readlink(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_realpath(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchmod(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chown(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_uid_t uid,\n                          uv_gid_t gid,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchown(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           uv_uid_t uid,\n                           uv_gid_t gid,\n                           uv_fs_cb cb);\n\n\nenum uv_fs_event {\n  UV_RENAME = 1,\n  UV_CHANGE = 2\n};\n\n\nstruct uv_fs_event_s {\n  UV_HANDLE_FIELDS\n  /* private */\n  char* path;\n  UV_FS_EVENT_PRIVATE_FIELDS\n};\n\n\n/*\n * uv_fs_stat() based polling file watcher.\n */\nstruct uv_fs_poll_s {\n  UV_HANDLE_FIELDS\n  /* Private, don't touch. */\n  void* poll_ctx;\n};\n\nUV_EXTERN int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_start(uv_fs_poll_t* handle,\n                               uv_fs_poll_cb poll_cb,\n                               const char* path,\n                               unsigned int interval);\nUV_EXTERN int uv_fs_poll_stop(uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_getpath(uv_fs_poll_t* handle,\n                                 char* buffer,\n                                 size_t* size);\n\n\nstruct uv_signal_s {\n  UV_HANDLE_FIELDS\n  uv_signal_cb signal_cb;\n  int signum;\n  UV_SIGNAL_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);\nUV_EXTERN int uv_signal_start(uv_signal_t* handle,\n                              uv_signal_cb signal_cb,\n                              int signum);\nUV_EXTERN int uv_signal_start_oneshot(uv_signal_t* handle,\n                                      uv_signal_cb signal_cb,\n                                      int signum);\nUV_EXTERN int uv_signal_stop(uv_signal_t* handle);\n\nUV_EXTERN void uv_loadavg(double avg[3]);\n\n\n/*\n * Flags to be passed to uv_fs_event_start().\n */\nenum uv_fs_event_flags {\n  /*\n   * By default, if the fs event watcher is given a directory name, we will\n   * watch for all events in that directory. This flags overrides this behavior\n   * and makes fs_event report only changes to the directory entry itself. This\n   * flag does not affect individual files watched.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_WATCH_ENTRY = 1,\n\n  /*\n   * By default uv_fs_event will try to use a kernel interface such as inotify\n   * or kqueue to detect events. This may not work on remote filesystems such\n   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a\n   * regular interval.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_STAT = 2,\n\n  /*\n   * By default, event watcher, when watching directory, is not registering\n   * (is ignoring) changes in it's subdirectories.\n   * This flag will override this behaviour on platforms that support it.\n   */\n  UV_FS_EVENT_RECURSIVE = 4\n};\n\n\nUV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_start(uv_fs_event_t* handle,\n                                uv_fs_event_cb cb,\n                                const char* path,\n                                unsigned int flags);\nUV_EXTERN int uv_fs_event_stop(uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_getpath(uv_fs_event_t* handle,\n                                  char* buffer,\n                                  size_t* size);\n\nUV_EXTERN int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);\nUV_EXTERN int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr);\n\nUV_EXTERN int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size);\nUV_EXTERN int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size);\n\nUV_EXTERN int uv_inet_ntop(int af, const void* src, char* dst, size_t size);\nUV_EXTERN int uv_inet_pton(int af, const char* src, void* dst);\n\n#if defined(IF_NAMESIZE)\n# define UV_IF_NAMESIZE (IF_NAMESIZE + 1)\n#elif defined(IFNAMSIZ)\n# define UV_IF_NAMESIZE (IFNAMSIZ + 1)\n#else\n# define UV_IF_NAMESIZE (16 + 1)\n#endif\n\nUV_EXTERN int uv_if_indextoname(unsigned int ifindex,\n                                char* buffer,\n                                size_t* size);\nUV_EXTERN int uv_if_indextoiid(unsigned int ifindex,\n                               char* buffer,\n                               size_t* size);\n\nUV_EXTERN int uv_exepath(char* buffer, size_t* size);\n\nUV_EXTERN int uv_cwd(char* buffer, size_t* size);\n\nUV_EXTERN int uv_chdir(const char* dir);\n\nUV_EXTERN uint64_t uv_get_free_memory(void);\nUV_EXTERN uint64_t uv_get_total_memory(void);\n\nUV_EXTERN uint64_t uv_hrtime(void);\n\nUV_EXTERN void uv_disable_stdio_inheritance(void);\n\nUV_EXTERN int uv_dlopen(const char* filename, uv_lib_t* lib);\nUV_EXTERN void uv_dlclose(uv_lib_t* lib);\nUV_EXTERN int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);\nUV_EXTERN const char* uv_dlerror(const uv_lib_t* lib);\n\nUV_EXTERN int uv_mutex_init(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_init_recursive(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_destroy(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_lock(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_trylock(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_unlock(uv_mutex_t* handle);\n\nUV_EXTERN int uv_rwlock_init(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_destroy(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);\n\nUV_EXTERN int uv_sem_init(uv_sem_t* sem, unsigned int value);\nUV_EXTERN void uv_sem_destroy(uv_sem_t* sem);\nUV_EXTERN void uv_sem_post(uv_sem_t* sem);\nUV_EXTERN void uv_sem_wait(uv_sem_t* sem);\nUV_EXTERN int uv_sem_trywait(uv_sem_t* sem);\n\nUV_EXTERN int uv_cond_init(uv_cond_t* cond);\nUV_EXTERN void uv_cond_destroy(uv_cond_t* cond);\nUV_EXTERN void uv_cond_signal(uv_cond_t* cond);\nUV_EXTERN void uv_cond_broadcast(uv_cond_t* cond);\n\nUV_EXTERN int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);\nUV_EXTERN void uv_barrier_destroy(uv_barrier_t* barrier);\nUV_EXTERN int uv_barrier_wait(uv_barrier_t* barrier);\n\nUV_EXTERN void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);\nUV_EXTERN int uv_cond_timedwait(uv_cond_t* cond,\n                                uv_mutex_t* mutex,\n                                uint64_t timeout);\n\nUV_EXTERN void uv_once(uv_once_t* guard, void (*callback)(void));\n\nUV_EXTERN int uv_key_create(uv_key_t* key);\nUV_EXTERN void uv_key_delete(uv_key_t* key);\nUV_EXTERN void* uv_key_get(uv_key_t* key);\nUV_EXTERN void uv_key_set(uv_key_t* key, void* value);\n\ntypedef void (*uv_thread_cb)(void* arg);\n\nUV_EXTERN int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);\nUV_EXTERN uv_thread_t uv_thread_self(void);\nUV_EXTERN int uv_thread_join(uv_thread_t *tid);\nUV_EXTERN int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);\n\n/* The presence of these unions force similar struct layout. */\n#define XX(_, name) uv_ ## name ## _t name;\nunion uv_any_handle {\n  UV_HANDLE_TYPE_MAP(XX)\n};\n\nunion uv_any_req {\n  UV_REQ_TYPE_MAP(XX)\n};\n#undef XX\n\n\nstruct uv_loop_s {\n  /* User data - use this for whatever. */\n  void* data;\n  /* Loop reference counting. */\n  unsigned int active_handles;\n  void* handle_queue[2];\n  void* active_reqs[2];\n  /* Internal flag to signal loop stop. */\n  unsigned int stop_flag;\n  UV_LOOP_PRIVATE_FIELDS\n};\n\nUV_EXTERN void* uv_loop_get_data(const uv_loop_t*);\nUV_EXTERN void uv_loop_set_data(uv_loop_t*, void* data);\n\n/* Don't export the private CPP symbols. */\n#undef UV_HANDLE_TYPE_PRIVATE\n#undef UV_REQ_TYPE_PRIVATE\n#undef UV_REQ_PRIVATE_FIELDS\n#undef UV_STREAM_PRIVATE_FIELDS\n#undef UV_TCP_PRIVATE_FIELDS\n#undef UV_PREPARE_PRIVATE_FIELDS\n#undef UV_CHECK_PRIVATE_FIELDS\n#undef UV_IDLE_PRIVATE_FIELDS\n#undef UV_ASYNC_PRIVATE_FIELDS\n#undef UV_TIMER_PRIVATE_FIELDS\n#undef UV_GETADDRINFO_PRIVATE_FIELDS\n#undef UV_GETNAMEINFO_PRIVATE_FIELDS\n#undef UV_FS_REQ_PRIVATE_FIELDS\n#undef UV_WORK_PRIVATE_FIELDS\n#undef UV_FS_EVENT_PRIVATE_FIELDS\n#undef UV_SIGNAL_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_PLATFORM_FIELDS\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* UV_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/include/node/uv-unix.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef UV_UNIX_H\n#define UV_UNIX_H\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n\n#include <termios.h>\n#include <pwd.h>\n\n#if !defined(__MVS__)\n#include <semaphore.h>\n#endif\n#include <pthread.h>\n#include <signal.h>\n\n#include \"uv-threadpool.h\"\n\n#if defined(__linux__)\n# include \"uv-linux.h\"\n#elif defined (__MVS__)\n# include \"uv-os390.h\"\n#elif defined(_PASE)\n# include \"uv-posix.h\"\n#elif defined(_AIX)\n# include \"uv-aix.h\"\n#elif defined(__sun)\n# include \"uv-sunos.h\"\n#elif defined(__APPLE__)\n# include \"uv-darwin.h\"\n#elif defined(__DragonFly__)       || \\\n      defined(__FreeBSD__)         || \\\n      defined(__FreeBSD_kernel__)  || \\\n      defined(__OpenBSD__)         || \\\n      defined(__NetBSD__)\n# include \"uv-bsd.h\"\n#elif defined(__CYGWIN__) || defined(__MSYS__)\n# include \"uv-posix.h\"\n#endif\n\n#ifndef PTHREAD_BARRIER_SERIAL_THREAD\n# include \"pthread-barrier.h\"\n#endif\n\n#ifndef NI_MAXHOST\n# define NI_MAXHOST 1025\n#endif\n\n#ifndef NI_MAXSERV\n# define NI_MAXSERV 32\n#endif\n\n#ifndef UV_IO_PRIVATE_PLATFORM_FIELDS\n# define UV_IO_PRIVATE_PLATFORM_FIELDS /* empty */\n#endif\n\nstruct uv__io_s;\nstruct uv_loop_s;\n\ntypedef void (*uv__io_cb)(struct uv_loop_s* loop,\n                          struct uv__io_s* w,\n                          unsigned int events);\ntypedef struct uv__io_s uv__io_t;\n\nstruct uv__io_s {\n  uv__io_cb cb;\n  void* pending_queue[2];\n  void* watcher_queue[2];\n  unsigned int pevents; /* Pending event mask i.e. mask at next tick. */\n  unsigned int events;  /* Current event mask. */\n  int fd;\n  UV_IO_PRIVATE_PLATFORM_FIELDS\n};\n\n#ifndef UV_PLATFORM_SEM_T\n# define UV_PLATFORM_SEM_T sem_t\n#endif\n\n#ifndef UV_PLATFORM_LOOP_FIELDS\n# define UV_PLATFORM_LOOP_FIELDS /* empty */\n#endif\n\n#ifndef UV_PLATFORM_FS_EVENT_FIELDS\n# define UV_PLATFORM_FS_EVENT_FIELDS /* empty */\n#endif\n\n#ifndef UV_STREAM_PRIVATE_PLATFORM_FIELDS\n# define UV_STREAM_PRIVATE_PLATFORM_FIELDS /* empty */\n#endif\n\n/* Note: May be cast to struct iovec. See writev(2). */\ntypedef struct uv_buf_t {\n  char* base;\n  size_t len;\n} uv_buf_t;\n\ntypedef int uv_file;\ntypedef int uv_os_sock_t;\ntypedef int uv_os_fd_t;\ntypedef pid_t uv_pid_t;\n\n#define UV_ONCE_INIT PTHREAD_ONCE_INIT\n\ntypedef pthread_once_t uv_once_t;\ntypedef pthread_t uv_thread_t;\ntypedef pthread_mutex_t uv_mutex_t;\ntypedef pthread_rwlock_t uv_rwlock_t;\ntypedef UV_PLATFORM_SEM_T uv_sem_t;\ntypedef pthread_cond_t uv_cond_t;\ntypedef pthread_key_t uv_key_t;\ntypedef pthread_barrier_t uv_barrier_t;\n\n\n/* Platform-specific definitions for uv_spawn support. */\ntypedef gid_t uv_gid_t;\ntypedef uid_t uv_uid_t;\n\ntypedef struct dirent uv__dirent_t;\n\n#if defined(DT_UNKNOWN)\n# define HAVE_DIRENT_TYPES\n# if defined(DT_REG)\n#  define UV__DT_FILE DT_REG\n# else\n#  define UV__DT_FILE -1\n# endif\n# if defined(DT_DIR)\n#  define UV__DT_DIR DT_DIR\n# else\n#  define UV__DT_DIR -2\n# endif\n# if defined(DT_LNK)\n#  define UV__DT_LINK DT_LNK\n# else\n#  define UV__DT_LINK -3\n# endif\n# if defined(DT_FIFO)\n#  define UV__DT_FIFO DT_FIFO\n# else\n#  define UV__DT_FIFO -4\n# endif\n# if defined(DT_SOCK)\n#  define UV__DT_SOCKET DT_SOCK\n# else\n#  define UV__DT_SOCKET -5\n# endif\n# if defined(DT_CHR)\n#  define UV__DT_CHAR DT_CHR\n# else\n#  define UV__DT_CHAR -6\n# endif\n# if defined(DT_BLK)\n#  define UV__DT_BLOCK DT_BLK\n# else\n#  define UV__DT_BLOCK -7\n# endif\n#endif\n\n/* Platform-specific definitions for uv_dlopen support. */\n#define UV_DYNAMIC /* empty */\n\ntypedef struct {\n  void* handle;\n  char* errmsg;\n} uv_lib_t;\n\n#define UV_LOOP_PRIVATE_FIELDS                                                \\\n  unsigned long flags;                                                        \\\n  int backend_fd;                                                             \\\n  void* pending_queue[2];                                                     \\\n  void* watcher_queue[2];                                                     \\\n  uv__io_t** watchers;                                                        \\\n  unsigned int nwatchers;                                                     \\\n  unsigned int nfds;                                                          \\\n  void* wq[2];                                                                \\\n  uv_mutex_t wq_mutex;                                                        \\\n  uv_async_t wq_async;                                                        \\\n  uv_rwlock_t cloexec_lock;                                                   \\\n  uv_handle_t* closing_handles;                                               \\\n  void* process_handles[2];                                                   \\\n  void* prepare_handles[2];                                                   \\\n  void* check_handles[2];                                                     \\\n  void* idle_handles[2];                                                      \\\n  void* async_handles[2];                                                     \\\n  void (*async_unused)(void);  /* TODO(bnoordhuis) Remove in libuv v2. */     \\\n  uv__io_t async_io_watcher;                                                  \\\n  int async_wfd;                                                              \\\n  struct {                                                                    \\\n    void* min;                                                                \\\n    unsigned int nelts;                                                       \\\n  } timer_heap;                                                               \\\n  uint64_t timer_counter;                                                     \\\n  uint64_t time;                                                              \\\n  int signal_pipefd[2];                                                       \\\n  uv__io_t signal_io_watcher;                                                 \\\n  uv_signal_t child_watcher;                                                  \\\n  int emfile_fd;                                                              \\\n  UV_PLATFORM_LOOP_FIELDS                                                     \\\n\n#define UV_REQ_TYPE_PRIVATE /* empty */\n\n#define UV_REQ_PRIVATE_FIELDS  /* empty */\n\n#define UV_PRIVATE_REQ_TYPES /* empty */\n\n#define UV_WRITE_PRIVATE_FIELDS                                               \\\n  void* queue[2];                                                             \\\n  unsigned int write_index;                                                   \\\n  uv_buf_t* bufs;                                                             \\\n  unsigned int nbufs;                                                         \\\n  int error;                                                                  \\\n  uv_buf_t bufsml[4];                                                         \\\n\n#define UV_CONNECT_PRIVATE_FIELDS                                             \\\n  void* queue[2];                                                             \\\n\n#define UV_SHUTDOWN_PRIVATE_FIELDS /* empty */\n\n#define UV_UDP_SEND_PRIVATE_FIELDS                                            \\\n  void* queue[2];                                                             \\\n  struct sockaddr_storage addr;                                               \\\n  unsigned int nbufs;                                                         \\\n  uv_buf_t* bufs;                                                             \\\n  ssize_t status;                                                             \\\n  uv_udp_send_cb send_cb;                                                     \\\n  uv_buf_t bufsml[4];                                                         \\\n\n#define UV_HANDLE_PRIVATE_FIELDS                                              \\\n  uv_handle_t* next_closing;                                                  \\\n  unsigned int flags;                                                         \\\n\n#define UV_STREAM_PRIVATE_FIELDS                                              \\\n  uv_connect_t *connect_req;                                                  \\\n  uv_shutdown_t *shutdown_req;                                                \\\n  uv__io_t io_watcher;                                                        \\\n  void* write_queue[2];                                                       \\\n  void* write_completed_queue[2];                                             \\\n  uv_connection_cb connection_cb;                                             \\\n  int delayed_error;                                                          \\\n  int accepted_fd;                                                            \\\n  void* queued_fds;                                                           \\\n  UV_STREAM_PRIVATE_PLATFORM_FIELDS                                           \\\n\n#define UV_TCP_PRIVATE_FIELDS /* empty */\n\n#define UV_UDP_PRIVATE_FIELDS                                                 \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_udp_recv_cb recv_cb;                                                     \\\n  uv__io_t io_watcher;                                                        \\\n  void* write_queue[2];                                                       \\\n  void* write_completed_queue[2];                                             \\\n\n#define UV_PIPE_PRIVATE_FIELDS                                                \\\n  const char* pipe_fname; /* strdup'ed */\n\n#define UV_POLL_PRIVATE_FIELDS                                                \\\n  uv__io_t io_watcher;\n\n#define UV_PREPARE_PRIVATE_FIELDS                                             \\\n  uv_prepare_cb prepare_cb;                                                   \\\n  void* queue[2];                                                             \\\n\n#define UV_CHECK_PRIVATE_FIELDS                                               \\\n  uv_check_cb check_cb;                                                       \\\n  void* queue[2];                                                             \\\n\n#define UV_IDLE_PRIVATE_FIELDS                                                \\\n  uv_idle_cb idle_cb;                                                         \\\n  void* queue[2];                                                             \\\n\n#define UV_ASYNC_PRIVATE_FIELDS                                               \\\n  uv_async_cb async_cb;                                                       \\\n  void* queue[2];                                                             \\\n  int pending;                                                                \\\n\n#define UV_TIMER_PRIVATE_FIELDS                                               \\\n  uv_timer_cb timer_cb;                                                       \\\n  void* heap_node[3];                                                         \\\n  uint64_t timeout;                                                           \\\n  uint64_t repeat;                                                            \\\n  uint64_t start_id;\n\n#define UV_GETADDRINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getaddrinfo_cb cb;                                                       \\\n  struct addrinfo* hints;                                                     \\\n  char* hostname;                                                             \\\n  char* service;                                                              \\\n  struct addrinfo* addrinfo;                                                  \\\n  int retcode;\n\n#define UV_GETNAMEINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getnameinfo_cb getnameinfo_cb;                                           \\\n  struct sockaddr_storage storage;                                            \\\n  int flags;                                                                  \\\n  char host[NI_MAXHOST];                                                      \\\n  char service[NI_MAXSERV];                                                   \\\n  int retcode;\n\n#define UV_PROCESS_PRIVATE_FIELDS                                             \\\n  void* queue[2];                                                             \\\n  int status;                                                                 \\\n\n#define UV_FS_PRIVATE_FIELDS                                                  \\\n  const char *new_path;                                                       \\\n  uv_file file;                                                               \\\n  int flags;                                                                  \\\n  mode_t mode;                                                                \\\n  unsigned int nbufs;                                                         \\\n  uv_buf_t* bufs;                                                             \\\n  off_t off;                                                                  \\\n  uv_uid_t uid;                                                               \\\n  uv_gid_t gid;                                                               \\\n  double atime;                                                               \\\n  double mtime;                                                               \\\n  struct uv__work work_req;                                                   \\\n  uv_buf_t bufsml[4];                                                         \\\n\n#define UV_WORK_PRIVATE_FIELDS                                                \\\n  struct uv__work work_req;\n\n#define UV_TTY_PRIVATE_FIELDS                                                 \\\n  struct termios orig_termios;                                                \\\n  int mode;\n\n#define UV_SIGNAL_PRIVATE_FIELDS                                              \\\n  /* RB_ENTRY(uv_signal_s) tree_entry; */                                     \\\n  struct {                                                                    \\\n    struct uv_signal_s* rbe_left;                                             \\\n    struct uv_signal_s* rbe_right;                                            \\\n    struct uv_signal_s* rbe_parent;                                           \\\n    int rbe_color;                                                            \\\n  } tree_entry;                                                               \\\n  /* Use two counters here so we don have to fiddle with atomics. */          \\\n  unsigned int caught_signals;                                                \\\n  unsigned int dispatched_signals;\n\n#define UV_FS_EVENT_PRIVATE_FIELDS                                            \\\n  uv_fs_event_cb cb;                                                          \\\n  UV_PLATFORM_FS_EVENT_FIELDS                                                 \\\n\n/* fs open() flags supported on this platform: */\n#if defined(O_APPEND)\n# define UV_FS_O_APPEND       O_APPEND\n#else\n# define UV_FS_O_APPEND       0\n#endif\n#if defined(O_CREAT)\n# define UV_FS_O_CREAT        O_CREAT\n#else\n# define UV_FS_O_CREAT        0\n#endif\n#if defined(O_DIRECT)\n# define UV_FS_O_DIRECT       O_DIRECT\n#else\n# define UV_FS_O_DIRECT       0\n#endif\n#if defined(O_DIRECTORY)\n# define UV_FS_O_DIRECTORY    O_DIRECTORY\n#else\n# define UV_FS_O_DIRECTORY    0\n#endif\n#if defined(O_DSYNC)\n# define UV_FS_O_DSYNC        O_DSYNC\n#else\n# define UV_FS_O_DSYNC        0\n#endif\n#if defined(O_EXCL)\n# define UV_FS_O_EXCL         O_EXCL\n#else\n# define UV_FS_O_EXCL         0\n#endif\n#if defined(O_EXLOCK)\n# define UV_FS_O_EXLOCK       O_EXLOCK\n#else\n# define UV_FS_O_EXLOCK       0\n#endif\n#if defined(O_NOATIME)\n# define UV_FS_O_NOATIME      O_NOATIME\n#else\n# define UV_FS_O_NOATIME      0\n#endif\n#if defined(O_NOCTTY)\n# define UV_FS_O_NOCTTY       O_NOCTTY\n#else\n# define UV_FS_O_NOCTTY       0\n#endif\n#if defined(O_NOFOLLOW)\n# define UV_FS_O_NOFOLLOW     O_NOFOLLOW\n#else\n# define UV_FS_O_NOFOLLOW     0\n#endif\n#if defined(O_NONBLOCK)\n# define UV_FS_O_NONBLOCK     O_NONBLOCK\n#else\n# define UV_FS_O_NONBLOCK     0\n#endif\n#if defined(O_RDONLY)\n# define UV_FS_O_RDONLY       O_RDONLY\n#else\n# define UV_FS_O_RDONLY       0\n#endif\n#if defined(O_RDWR)\n# define UV_FS_O_RDWR         O_RDWR\n#else\n# define UV_FS_O_RDWR         0\n#endif\n#if defined(O_SYMLINK)\n# define UV_FS_O_SYMLINK      O_SYMLINK\n#else\n# define UV_FS_O_SYMLINK      0\n#endif\n#if defined(O_SYNC)\n# define UV_FS_O_SYNC         O_SYNC\n#else\n# define UV_FS_O_SYNC         0\n#endif\n#if defined(O_TRUNC)\n# define UV_FS_O_TRUNC        O_TRUNC\n#else\n# define UV_FS_O_TRUNC        0\n#endif\n#if defined(O_WRONLY)\n# define UV_FS_O_WRONLY       O_WRONLY\n#else\n# define UV_FS_O_WRONLY       0\n#endif\n\n/* fs open() flags supported on other platforms: */\n#define UV_FS_O_RANDOM        0\n#define UV_FS_O_SHORT_LIVED   0\n#define UV_FS_O_SEQUENTIAL    0\n#define UV_FS_O_TEMPORARY     0\n\n#endif /* UV_UNIX_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/include/node/openssl/dso.h": "/* dso.h */\n/*\n * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project\n * 2000.\n */\n/* ====================================================================\n * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n#ifndef HEADER_DSO_H\n# define HEADER_DSO_H\n\n# include <openssl/crypto.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* These values are used as commands to DSO_ctrl() */\n# define DSO_CTRL_GET_FLAGS      1\n# define DSO_CTRL_SET_FLAGS      2\n# define DSO_CTRL_OR_FLAGS       3\n\n/*\n * By default, DSO_load() will translate the provided filename into a form\n * typical for the platform (more specifically the DSO_METHOD) using the\n * dso_name_converter function of the method. Eg. win32 will transform \"blah\"\n * into \"blah.dll\", and dlfcn will transform it into \"libblah.so\". The\n * behaviour can be overriden by setting the name_converter callback in the\n * DSO object (using DSO_set_name_converter()). This callback could even\n * utilise the DSO_METHOD's converter too if it only wants to override\n * behaviour for one or two possible DSO methods. However, the following flag\n * can be set in a DSO to prevent *any* native name-translation at all - eg.\n * if the caller has prompted the user for a path to a driver library so the\n * filename should be interpreted as-is.\n */\n# define DSO_FLAG_NO_NAME_TRANSLATION            0x01\n/*\n * An extra flag to give if only the extension should be added as\n * translation.  This is obviously only of importance on Unix and other\n * operating systems where the translation also may prefix the name with\n * something, like 'lib', and ignored everywhere else. This flag is also\n * ignored if DSO_FLAG_NO_NAME_TRANSLATION is used at the same time.\n */\n# define DSO_FLAG_NAME_TRANSLATION_EXT_ONLY      0x02\n\n/*\n * The following flag controls the translation of symbol names to upper case.\n * This is currently only being implemented for OpenVMS.\n */\n# define DSO_FLAG_UPCASE_SYMBOL                  0x10\n\n/*\n * This flag loads the library with public symbols. Meaning: The exported\n * symbols of this library are public to all libraries loaded after this\n * library. At the moment only implemented in unix.\n */\n# define DSO_FLAG_GLOBAL_SYMBOLS                 0x20\n\ntypedef void (*DSO_FUNC_TYPE) (void);\n\ntypedef struct dso_st DSO;\n\n/*\n * The function prototype used for method functions (or caller-provided\n * callbacks) that transform filenames. They are passed a DSO structure\n * pointer (or NULL if they are to be used independantly of a DSO object) and\n * a filename to transform. They should either return NULL (if there is an\n * error condition) or a newly allocated string containing the transformed\n * form that the caller will need to free with OPENSSL_free() when done.\n */\ntypedef char *(*DSO_NAME_CONVERTER_FUNC)(DSO *, const char *);\n/*\n * The function prototype used for method functions (or caller-provided\n * callbacks) that merge two file specifications. They are passed a DSO\n * structure pointer (or NULL if they are to be used independantly of a DSO\n * object) and two file specifications to merge. They should either return\n * NULL (if there is an error condition) or a newly allocated string\n * containing the result of merging that the caller will need to free with\n * OPENSSL_free() when done. Here, merging means that bits and pieces are\n * taken from each of the file specifications and added together in whatever\n * fashion that is sensible for the DSO method in question.  The only rule\n * that really applies is that if the two specification contain pieces of the\n * same type, the copy from the first string takes priority.  One could see\n * it as the first specification is the one given by the user and the second\n * being a bunch of defaults to add on if they're missing in the first.\n */\ntypedef char *(*DSO_MERGER_FUNC)(DSO *, const char *, const char *);\n\ntypedef struct dso_meth_st {\n    const char *name;\n    /*\n     * Loads a shared library, NB: new DSO_METHODs must ensure that a\n     * successful load populates the loaded_filename field, and likewise a\n     * successful unload OPENSSL_frees and NULLs it out.\n     */\n    int (*dso_load) (DSO *dso);\n    /* Unloads a shared library */\n    int (*dso_unload) (DSO *dso);\n    /* Binds a variable */\n    void *(*dso_bind_var) (DSO *dso, const char *symname);\n    /*\n     * Binds a function - assumes a return type of DSO_FUNC_TYPE. This should\n     * be cast to the real function prototype by the caller. Platforms that\n     * don't have compatible representations for different prototypes (this\n     * is possible within ANSI C) are highly unlikely to have shared\n     * libraries at all, let alone a DSO_METHOD implemented for them.\n     */\n    DSO_FUNC_TYPE (*dso_bind_func) (DSO *dso, const char *symname);\n/* I don't think this would actually be used in any circumstances. */\n# if 0\n    /* Unbinds a variable */\n    int (*dso_unbind_var) (DSO *dso, char *symname, void *symptr);\n    /* Unbinds a function */\n    int (*dso_unbind_func) (DSO *dso, char *symname, DSO_FUNC_TYPE symptr);\n# endif\n    /*\n     * The generic (yuck) \"ctrl()\" function. NB: Negative return values\n     * (rather than zero) indicate errors.\n     */\n    long (*dso_ctrl) (DSO *dso, int cmd, long larg, void *parg);\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_NAME_CONVERTER_FUNC dso_name_converter;\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_MERGER_FUNC dso_merger;\n    /* [De]Initialisation handlers. */\n    int (*init) (DSO *dso);\n    int (*finish) (DSO *dso);\n    /* Return pathname of the module containing location */\n    int (*pathbyaddr) (void *addr, char *path, int sz);\n    /* Perform global symbol lookup, i.e. among *all* modules */\n    void *(*globallookup) (const char *symname);\n} DSO_METHOD;\n\n/**********************************************************************/\n/* The low-level handle type used to refer to a loaded shared library */\n\nstruct dso_st {\n    DSO_METHOD *meth;\n    /*\n     * Standard dlopen uses a (void *). Win32 uses a HANDLE. VMS doesn't use\n     * anything but will need to cache the filename for use in the dso_bind\n     * handler. All in all, let each method control its own destiny.\n     * \"Handles\" and such go in a STACK.\n     */\n    STACK_OF(void) *meth_data;\n    int references;\n    int flags;\n    /*\n     * For use by applications etc ... use this for your bits'n'pieces, don't\n     * touch meth_data!\n     */\n    CRYPTO_EX_DATA ex_data;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_name_converter. NB: This\n     * should normally set using DSO_set_name_converter().\n     */\n    DSO_NAME_CONVERTER_FUNC name_converter;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_merger. NB: This should\n     * normally set using DSO_set_merger().\n     */\n    DSO_MERGER_FUNC merger;\n    /*\n     * This is populated with (a copy of) the platform-independant filename\n     * used for this DSO.\n     */\n    char *filename;\n    /*\n     * This is populated with (a copy of) the translated filename by which\n     * the DSO was actually loaded. It is NULL iff the DSO is not currently\n     * loaded. NB: This is here because the filename translation process may\n     * involve a callback being invoked more than once not only to convert to\n     * a platform-specific form, but also to try different filenames in the\n     * process of trying to perform a load. As such, this variable can be\n     * used to indicate (a) whether this DSO structure corresponds to a\n     * loaded library or not, and (b) the filename with which it was actually\n     * loaded.\n     */\n    char *loaded_filename;\n};\n\nDSO *DSO_new(void);\nDSO *DSO_new_method(DSO_METHOD *method);\nint DSO_free(DSO *dso);\nint DSO_flags(DSO *dso);\nint DSO_up_ref(DSO *dso);\nlong DSO_ctrl(DSO *dso, int cmd, long larg, void *parg);\n\n/*\n * This function sets the DSO's name_converter callback. If it is non-NULL,\n * then it will be used instead of the associated DSO_METHOD's function. If\n * oldcb is non-NULL then it is set to the function pointer value being\n * replaced. Return value is non-zero for success.\n */\nint DSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb,\n                           DSO_NAME_CONVERTER_FUNC *oldcb);\n/*\n * These functions can be used to get/set the platform-independant filename\n * used for a DSO. NB: set will fail if the DSO is already loaded.\n */\nconst char *DSO_get_filename(DSO *dso);\nint DSO_set_filename(DSO *dso, const char *filename);\n/*\n * This function will invoke the DSO's name_converter callback to translate a\n * filename, or if the callback isn't set it will instead use the DSO_METHOD's\n * converter. If \"filename\" is NULL, the \"filename\" in the DSO itself will be\n * used. If the DSO_FLAG_NO_NAME_TRANSLATION flag is set, then the filename is\n * simply duplicated. NB: This function is usually called from within a\n * DSO_METHOD during the processing of a DSO_load() call, and is exposed so\n * that caller-created DSO_METHODs can do the same thing. A non-NULL return\n * value will need to be OPENSSL_free()'d.\n */\nchar *DSO_convert_filename(DSO *dso, const char *filename);\n/*\n * This function will invoke the DSO's merger callback to merge two file\n * specifications, or if the callback isn't set it will instead use the\n * DSO_METHOD's merger.  A non-NULL return value will need to be\n * OPENSSL_free()'d.\n */\nchar *DSO_merge(DSO *dso, const char *filespec1, const char *filespec2);\n/*\n * If the DSO is currently loaded, this returns the filename that it was\n * loaded under, otherwise it returns NULL. So it is also useful as a test as\n * to whether the DSO is currently loaded. NB: This will not necessarily\n * return the same value as DSO_convert_filename(dso, dso->filename), because\n * the DSO_METHOD's load function may have tried a variety of filenames (with\n * and/or without the aid of the converters) before settling on the one it\n * actually loaded.\n */\nconst char *DSO_get_loaded_filename(DSO *dso);\n\nvoid DSO_set_default_method(DSO_METHOD *meth);\nDSO_METHOD *DSO_get_default_method(void);\nDSO_METHOD *DSO_get_method(DSO *dso);\nDSO_METHOD *DSO_set_method(DSO *dso, DSO_METHOD *meth);\n\n/*\n * The all-singing all-dancing load function, you normally pass NULL for the\n * first and third parameters. Use DSO_up and DSO_free for subsequent\n * reference count handling. Any flags passed in will be set in the\n * constructed DSO after its init() function but before the load operation.\n * If 'dso' is non-NULL, 'flags' is ignored.\n */\nDSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags);\n\n/* This function binds to a variable inside a shared library. */\nvoid *DSO_bind_var(DSO *dso, const char *symname);\n\n/* This function binds to a function inside a shared library. */\nDSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname);\n\n/*\n * This method is the default, but will beg, borrow, or steal whatever method\n * should be the default on any particular platform (including\n * DSO_METH_null() if necessary).\n */\nDSO_METHOD *DSO_METHOD_openssl(void);\n\n/*\n * This method is defined for all platforms - if a platform has no DSO\n * support then this will be the only method!\n */\nDSO_METHOD *DSO_METHOD_null(void);\n\n/*\n * If DSO_DLFCN is defined, the standard dlfcn.h-style functions (dlopen,\n * dlclose, dlsym, etc) will be used and incorporated into this method. If\n * not, this method will return NULL.\n */\nDSO_METHOD *DSO_METHOD_dlfcn(void);\n\n/*\n * If DSO_DL is defined, the standard dl.h-style functions (shl_load,\n * shl_unload, shl_findsym, etc) will be used and incorporated into this\n * method. If not, this method will return NULL.\n */\nDSO_METHOD *DSO_METHOD_dl(void);\n\n/* If WIN32 is defined, use DLLs. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_win32(void);\n\n/* If VMS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_vms(void);\n\n/*\n * This function writes null-terminated pathname of DSO module containing\n * 'addr' into 'sz' large caller-provided 'path' and returns the number of\n * characters [including trailing zero] written to it. If 'sz' is 0 or\n * negative, 'path' is ignored and required amount of charachers [including\n * trailing zero] to accomodate pathname is returned. If 'addr' is NULL, then\n * pathname of cryptolib itself is returned. Negative or zero return value\n * denotes error.\n */\nint DSO_pathbyaddr(void *addr, char *path, int sz);\n\n/*\n * This function should be used with caution! It looks up symbols in *all*\n * loaded modules and if module gets unloaded by somebody else attempt to\n * dereference the pointer is doomed to have fatal consequences. Primary\n * usage for this function is to probe *core* system functionality, e.g.\n * check if getnameinfo(3) is available at run-time without bothering about\n * OS-specific details such as libc.so.versioning or where does it actually\n * reside: in libc itself or libsocket.\n */\nvoid *DSO_global_lookup(const char *name);\n\n/* If BeOS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_beos(void);\n\n/* BEGIN ERROR CODES */\n/*\n * The following lines are auto generated by the script mkerr.pl. Any changes\n * made after this point may be overwritten when the script is next run.\n */\nvoid ERR_load_DSO_strings(void);\n\n/* Error codes for the DSO functions. */\n\n/* Function codes. */\n# define DSO_F_BEOS_BIND_FUNC                             144\n# define DSO_F_BEOS_BIND_VAR                              145\n# define DSO_F_BEOS_LOAD                                  146\n# define DSO_F_BEOS_NAME_CONVERTER                        147\n# define DSO_F_BEOS_UNLOAD                                148\n# define DSO_F_DLFCN_BIND_FUNC                            100\n# define DSO_F_DLFCN_BIND_VAR                             101\n# define DSO_F_DLFCN_LOAD                                 102\n# define DSO_F_DLFCN_MERGER                               130\n# define DSO_F_DLFCN_NAME_CONVERTER                       123\n# define DSO_F_DLFCN_UNLOAD                               103\n# define DSO_F_DL_BIND_FUNC                               104\n# define DSO_F_DL_BIND_VAR                                105\n# define DSO_F_DL_LOAD                                    106\n# define DSO_F_DL_MERGER                                  131\n# define DSO_F_DL_NAME_CONVERTER                          124\n# define DSO_F_DL_UNLOAD                                  107\n# define DSO_F_DSO_BIND_FUNC                              108\n# define DSO_F_DSO_BIND_VAR                               109\n# define DSO_F_DSO_CONVERT_FILENAME                       126\n# define DSO_F_DSO_CTRL                                   110\n# define DSO_F_DSO_FREE                                   111\n# define DSO_F_DSO_GET_FILENAME                           127\n# define DSO_F_DSO_GET_LOADED_FILENAME                    128\n# define DSO_F_DSO_GLOBAL_LOOKUP                          139\n# define DSO_F_DSO_LOAD                                   112\n# define DSO_F_DSO_MERGE                                  132\n# define DSO_F_DSO_NEW_METHOD                             113\n# define DSO_F_DSO_PATHBYADDR                             140\n# define DSO_F_DSO_SET_FILENAME                           129\n# define DSO_F_DSO_SET_NAME_CONVERTER                     122\n# define DSO_F_DSO_UP_REF                                 114\n# define DSO_F_GLOBAL_LOOKUP_FUNC                         138\n# define DSO_F_PATHBYADDR                                 137\n# define DSO_F_VMS_BIND_SYM                               115\n# define DSO_F_VMS_LOAD                                   116\n# define DSO_F_VMS_MERGER                                 133\n# define DSO_F_VMS_UNLOAD                                 117\n# define DSO_F_WIN32_BIND_FUNC                            118\n# define DSO_F_WIN32_BIND_VAR                             119\n# define DSO_F_WIN32_GLOBALLOOKUP                         142\n# define DSO_F_WIN32_GLOBALLOOKUP_FUNC                    143\n# define DSO_F_WIN32_JOINER                               135\n# define DSO_F_WIN32_LOAD                                 120\n# define DSO_F_WIN32_MERGER                               134\n# define DSO_F_WIN32_NAME_CONVERTER                       125\n# define DSO_F_WIN32_PATHBYADDR                           141\n# define DSO_F_WIN32_SPLITTER                             136\n# define DSO_F_WIN32_UNLOAD                               121\n\n/* Reason codes. */\n# define DSO_R_CTRL_FAILED                                100\n# define DSO_R_DSO_ALREADY_LOADED                         110\n# define DSO_R_EMPTY_FILE_STRUCTURE                       113\n# define DSO_R_FAILURE                                    114\n# define DSO_R_FILENAME_TOO_BIG                           101\n# define DSO_R_FINISH_FAILED                              102\n# define DSO_R_INCORRECT_FILE_SYNTAX                      115\n# define DSO_R_LOAD_FAILED                                103\n# define DSO_R_NAME_TRANSLATION_FAILED                    109\n# define DSO_R_NO_FILENAME                                111\n# define DSO_R_NO_FILE_SPECIFICATION                      116\n# define DSO_R_NULL_HANDLE                                104\n# define DSO_R_SET_FILENAME_FAILED                        112\n# define DSO_R_STACK_ERROR                                105\n# define DSO_R_SYM_FAILURE                                106\n# define DSO_R_UNLOAD_FAILED                              107\n# define DSO_R_UNSUPPORTED                                108\n\n#ifdef  __cplusplus\n}\n#endif\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/node-libs-browser/mock/process.js": "exports.nextTick = function nextTick(fn) {\n\tsetTimeout(fn, 0);\n};\n\nexports.platform = exports.arch = \nexports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n\tthrow new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () { return cwd };\n    exports.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = \nexports.umask = exports.dlopen = \nexports.uptime = exports.memoryUsage = \nexports.uvCounters = function() {};\nexports.features = {};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/cli_plugin/install/__fixtures__/replies/banana.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/cli_plugin/install/__fixtures__/replies/corrupt.zip",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/cli_plugin/install/__fixtures__/replies/invalid_name.zip",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/cli_plugin/install/__fixtures__/replies/test_plugin.zip",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/cli_plugin/install/__fixtures__/replies/test_plugin_no_kibana.zip",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/cli_plugin/install/__fixtures__/replies/test_plugin_different_version.zip",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/cli_plugin/install/__fixtures__/replies/test_plugin_many.zip",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/server/sample_data/data_sets/flights/flights.json.gz",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/ne.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/cv.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/de.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/us.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/go.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/ni.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/favicons/android-chrome-256x256.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/favicons/favicon-32x32.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/favicons/android-chrome-192x192.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/favicons/favicon-16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/favicons/mstile-150x150.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/favicons/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/favicons/apple-touch-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_700.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_300.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_700.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_600.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_600.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_300.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_600.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_700.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_300.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_regular.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_700.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_300.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/assets/fonts/open_sans/open_sans_v15_latin_600.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/styles/fonts/glyphicons-halflings-regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/styles/fonts/glyphicons-halflings-regular.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/styles/fonts/glyphicons-halflings-regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/ui/public/styles/fonts/glyphicons-halflings-regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/timelion/public/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/redis_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/nginx_logs/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/apm/apm.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/mysql_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/kubernetes_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/apache_logs/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/system_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/mongodb_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/uwsgi_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/rabbitmq_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/system_logs/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/apache_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/kafka_logs/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/redis_logs/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/nginx_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/mysql_logs/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/osquery_logs/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/tutorial_resources/docker_metrics/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/src/core_plugins/kibana/public/home/sample_data_resources/flights/dashboard.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/html/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/retry/equation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/cli-table2/examples/screenshots/basic-usage-with-colors.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/cli-table2/examples/screenshots/multi-line-colors.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/cli-table2/examples/screenshots/truncation-with-colors.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/qrcode-terminal/example/basic.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/read/node_modules/mute-stream/coverage/lcov-report/sort-arrow-sprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/update-notifier/node_modules/boxen/node_modules/term-size/vendor/windows/term-size.exe",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/unique-filename/coverage/sort-arrow-sprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node/lib/node_modules/npm/node_modules/tar/node_modules/minipass/minipass-benchmarks.xlsx",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/f4769f9bdb7466be65088239c12046d1.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/e18bbf611f2a2e43afc071aa2f4e1512.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/dfb02f8f6d0cedc009ee5887cc68f1f3.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/7c87870ab40d63cfb8870c1f183f9939.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/4b5a84aaf1c9485e060c503a0ff8cadb.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/fa2772327f55d8198301fdb8bcfc8158.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/45c73723862c6fc5eb3d6961db2d71fb.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/448c34a56d699c29117adc64c43affeb.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/ne.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/cv.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/de.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/us.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/go.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/optimize/bundles/src/ui/public/field_editor/components/field_format_editor/editors/url/icons/ni.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/retry/equation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/point.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/band.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/category20.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/cubehelix.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/magma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/cool.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/plasma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/warm.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/viridis.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/category20b.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/inferno.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/category10.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/category20c.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale/img/rainbow.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet-draw/dist/images/marker-icon-2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet-draw/dist/images/spritesheet.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet-draw/dist/images/marker-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet-draw/dist/images/spritesheet-2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet-draw/dist/images/marker-shadow.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet-draw/dist/images/layers.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet-draw/dist/images/layers-2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/highlight.js/styles/brown-papersq.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/highlight.js/styles/school-book.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/highlight.js/styles/pojoaque.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/even-better/images/good.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/even-better/node_modules/joi/images/joi.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/even-better/node_modules/joi/images/validation.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/even-better/node_modules/boom/images/boom.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/even-better/node_modules/hoek/images/hoek.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/even-better/node_modules/wreck/images/wreck.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/dragula/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/dragula/resources/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/dragula/resources/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/dragula/resources/eyes.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/dragula/resources/demo.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/hapi-auth-cookie/node_modules/joi/images/joi.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/hapi-auth-cookie/node_modules/joi/images/validation.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/hapi-auth-cookie/node_modules/hoek/images/hoek.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-zoom/img/dots.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-zoom/img/brush.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-zoom/img/transition.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-zoom/img/axis.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/apm/public/images/apm-ml-anomaly-detection-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/graph/public/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/server/browsers/chromium/driver/screenshot_stitcher/fixtures/2x2-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/server/browsers/chromium/driver/screenshot_stitcher/fixtures/2x1-checkerboard.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/server/browsers/chromium/driver/screenshot_stitcher/fixtures/single-black-pixel.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/server/browsers/chromium/driver/screenshot_stitcher/fixtures/single-white-pixel.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/server/browsers/chromium/driver/screenshot_stitcher/fixtures/2x2-black.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/server/browsers/chromium/driver/screenshot_stitcher/fixtures/4x4-checkerboard.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/server/browsers/chromium/driver/screenshot_stitcher/fixtures/2x2-checkerboard.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/export_types/printable_pdf/server/lib/pdf/assets/img/logo-grey.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/export_types/printable_pdf/server/lib/pdf/assets/fonts/roboto/Roboto-Italic.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/export_types/printable_pdf/server/lib/pdf/assets/fonts/roboto/Roboto-Medium.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/export_types/printable_pdf/server/lib/pdf/assets/fonts/roboto/Roboto-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/export_types/printable_pdf/server/lib/pdf/assets/fonts/noto/NotoSansCJKtc-Medium.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/export_types/printable_pdf/server/lib/pdf/assets/fonts/noto/NotoSansCJKtc-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/.phantom/phantomjs-2.1.1-linux-x86_64.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/plugins/reporting/.chromium/chromium-503a3e4-linux.zip",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/point.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/band.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/category20.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/cubehelix.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/magma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/cool.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/plasma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/warm.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/viridis.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/category20b.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/inferno.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/category10.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/category20c.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/d3-scale/img/rainbow.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/joi/images/joi.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/joi/images/validation.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/point.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/band.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/category20.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/cubehelix.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/magma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/cool.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/plasma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/warm.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/viridis.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/category20b.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/inferno.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/category10.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/category20c.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/react-vis/node_modules/d3-scale/img/rainbow.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/boom/images/boom.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/boom/node_modules/hoek/images/hoek.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/x-pack/node_modules/hoek/images/hoek.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/querystring/.Readme.md.un~",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/querystring/.package.json.un~",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/querystring/.History.md.un~",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/getos/imgs/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/hclLong.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/lab.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/hsl.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/cubehelixGamma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/cubehelix.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/hcl.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/cubehelixLong.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/rgb.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/rgbGamma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/hslLong.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-interpolate/img/cubehelixGammaLong.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-sankey/img/energy.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-sankey/img/align-right.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-sankey/img/align-center.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-sankey/img/align-left.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/font-awesome/fonts/fontawesome-webfont.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/font-awesome/fonts/FontAwesome.otf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/font-awesome/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/font-awesome/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/font-awesome/fonts/fontawesome-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/vega-scale/node_modules/d3-scale/img/point.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/vega-scale/node_modules/d3-scale/img/band.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/html/img/copyashtml.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/html/img/before.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/html/img/after.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/linebreak/src/classes.trie",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-array/img/histogram.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/dragselect/src/typewriter.gif",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/dragselect/dist/typewriter.gif",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-drag/img/dots.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-drag/img/force-collide.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-drag/img/canvas.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-drag/img/voronoi.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-drag/img/force-graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-drag/img/drawing.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/angular/angular.min.js.gzip",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/YlOrBr.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Accent.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Reds.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/PRGn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/RdGy.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Greens.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/RdBu.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Pastel2.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Greys.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/RdYlGn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Paired.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/YlGnBu.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Set1.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/PiYG.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/PuBuGn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/cubehelix.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Pastel1.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/magma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Set2.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Purples.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/PuOr.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/cool.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Oranges.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/PuRd.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/plasma.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/warm.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/YlGn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/BuGn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/PuBu.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/YlOrRd.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Dark2.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/viridis.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/BuPu.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/inferno.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/RdPu.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Spectral.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/BrBG.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/GnBu.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Set3.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/category10.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/Blues.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/OrRd.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/RdYlBu.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-scale-chromatic/img/rainbow.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/cubicIn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/quadOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/quadIn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/sinIn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/backIn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/elasticOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/circleOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/expOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/expIn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/circleInOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/polyInOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/circleIn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/linear.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/cubicOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/polyIn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/bounceOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/backInOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/cubicInOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/elasticInOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/polyOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/sinOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/bounceIn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/backOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/expInOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/sinInOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/quadInOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/bounceInOut.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-ease/img/elasticIn.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/js-base64/1x1.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/unicode-properties/data.trie",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet/dist/images/marker-icon-2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet/dist/images/marker-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet/dist/images/marker-shadow.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet/dist/images/layers.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/leaflet/dist/images/layers-2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-voronoi/graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/png-js/images/broken.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/png-js/images/djay-indexed.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/png-js/images/ball.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/png-js/images/djay.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/png-js/images/spinfox.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/png-js/images/laptop.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/png-js/images/loading.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/png-js/images/chompy.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/png-js/images/trees.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/fa69a3d1d6c58ef671715ccb3f602ef8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/8213b0f9cba80ea178885fdd0ddaed51.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/backgrounds/images/aboutus-hero.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/backgrounds/images/gray-cloud.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-semibold-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-regular-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-bold-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-semibold-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-black-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-black-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-regular-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-bold-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-light-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-regular-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-extralight-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-it-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-black-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-extralight-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-it-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-light-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-bold-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-it-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-light-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-semibold-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/pivotal-ui/css/typography/fonts/sourcesanspro-extralight-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/scroll-into-view/scrollintoview.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-force/img/collide.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-force/img/graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-force/img/beeswarm.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-force/img/phyllotaxis.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-force/img/tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-force/img/lattice.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/vision/node_modules/hoek/images/hoek.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/good-squeeze/node_modules/hoek/images/hoek.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-hierarchy/img/pack.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-hierarchy/img/cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-hierarchy/img/treemap.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-hierarchy/img/stratify.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-hierarchy/img/partition.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/d3-hierarchy/img/tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/brace/assets/brace.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/venn.js/build/venn.zip",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/tinygradient/images/hsv2.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/tinygradient/images/rgb.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/tinygradient/images/hsv.png",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/fontkit/indic.trie",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/fontkit/use.trie",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/fontkit/data.trie",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/fontkit/src/opentype/shapers/indic.trie",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/fontkit/src/opentype/shapers/use.trie",
        "/tmp/vanessa/spack-stage/spack-stage-kibana-6.4.0-zp55m7wu6koongpw4qutvxuxxsqxb2mt/spack-src/node_modules/fontkit/src/opentype/shapers/data.trie"
    ],
    "total_files": 56280
}