{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pnmpi-1.7-cy5e2kw6o5gvmxhwxfpv2boxamuhrwdo/spack-src/README.md": "PnMPI Tool Infrastructure\n========================================\n\n[![Travis](https://img.shields.io/travis/LLNL/PnMPI/master.svg?style=flat-square)](https://travis-ci.org/LLNL/PnMPI)\n[![Codecov](https://img.shields.io/codecov/c/github/LLNL/PnMPI.svg?style=flat-square)](https://codecov.io/github/LLNL/PnMPI?branch=master)\n[![](https://img.shields.io/github/issues-raw/LLNL/PnMPI.svg?style=flat-square)](https://github.com/LLNL/PnMPI/issues)\n[![](https://img.shields.io/badge/license-LGPL-blue.svg?style=flat-square)](LICENSE)\n\nby Martin Schulz, schulzm@llnl.gov, LLNL-CODE-402774\n---------\n\nPnMPI is a dynamic MPI tool infrastructure that builds on top of the\nstandardized PMPI interface. It allows the user to\n\n  * run multiple PMPI tools concurrently\n  * activate PMPI tools without relinking by just changing a configuration file\n  * multiplex toolsets during a single run\n  * write cooperative PMPI tools\n\nThe package contains two main components:\n\n  * The PnMPI core infrastructure\n  * Tool modules that can explicitly exploit PnMPI's capabilities\n\nSo far, this software has mainly been tested on Linux clusters with RHEL-based\nOS distributions as well as IBM's BG/P systems. Continuous integration tests run\nat Ubuntu 12.04 and 14.04, OSX El Capitan and macOS Sierra. Some preliminary\nexperiments have also included SGI Altix systems. Ports to other platforms\nshould be straightforward, but this is not extensively tested. Please file an\n[issue](https://github.com/LLNL/PnMPI/issues) if you run into problems porting\nPnMPI or if you successfully deployed PnMPI on a new platform.\n\nMany thanks to our\n[contributors](https://github.com/LLNL/PnMPI/graphs/contributors).\n\n\nA) Building PnMPI\n===============================================================\nPnMPI uses CMake for its build system.\n\n\nA1) Dependencies\n----------------\n\n  * [CMake](http://www.cmake.org) (at least version 2.8.11.2 is required).\n  * [argp](https://www.gnu.org/software/libc/manual/html_node/Argp.html) is\n    usually included in glibc. However at macOS you have to install it from\n    homebrew as `argp-standalone` package.\n  * [binutils](https://www.gnu.org/software/binutils/) and libiberty for the\n    patcher utility *(optional)*\n  * [Doxygen](www.doxygen.org) for generating the docs and man-pages.\n    *(optional)*\n  * [help2man](https://www.gnu.org/software/help2man/) for generating man-pages.\n    *(optional)*\n  * An MPI implementation with header files. So far, PnMPI has been tested with\n    MPICH, OpenMPI and IntelMPI.\n\nIn addition, PnMPI uses git submodules for several CMake modules,\n[wrap](https://github.com/LLNL/wrap) and\n[adept-utils](https://github.com/LLNL/adept-utils). While the deploy source\ntarball includes all required submodules, git users need to checkout them with\nthe following command in the root of the cloned repository:\n\n    git submodule update --init --recursive\n\n\nA2) Configure the project\n-------------------------\nIn the simplest case, you can run this in the top-level directory of the PnMPI\ntree:\n\n    cmake -DCMAKE_INSTALL_PREFIX=/path/to/install/destination\n    make\n    make install\n\nThis will configure, build, and install PnMPI to the destination specified.\nPnMPI supports parallel make with the `-j` parameter. E.g., for using eight\nbuild tasks, use:\n\n    cmake -DCMAKE_INSTALL_PREFIX=/path/to/install/destination\n    make -j8\n    make install\n\nOn more complex machines, such as those with filesystems shared among multiple\nplatforms, you will want to separate out your build directories for each\nplatform. CMake makes this easy.\n\nCreate a new build directory named according to the platform you are using, `cd`\ninto it, an run `cmake` there.  For example:\n\n    cd <pnmpi>\n    mkdir x86_64\n    cd x86_64\n    cmake -DCMAKE_INSTALL_PREFIX=/path/to/install/destination ..\n\nHere, `<pnmpi>` is the top-level directory in the PnMPI tree. Note that when you\nrun CMake this way, you need to supply the path to the PnMPI *source* directory\nas the last parameter. Here, that's just `..` as we are building in a\nsubdirectory of the source directory. Once you run CMake, simply run make and\nmake install as before:\n\n    make -j8\n    make install\n\nThe PnMPI build should auto-detect your MPI installation and determine library\nand header locations. If you want to build with a particular MPI that is NOT the\none auto-detected by the build, you can supply your particular MPI compiler as a\nparameter:\n\n    cmake \\\n      -DCMAKE_INSTALL_PREFIX=/path/to/install/destination \\\n      -DMPI_C_COMPILER=/path/to/my/mpicc \\\n      ..\n\nSee the documentation in [FindMPI.cmake](cmakemodules/legacy/FindMPI.cmake) for\nmore details on MPI build configuration options.\n\nIf you have problems, you may want to build PnMPI in debug mode. You can do this\nby supplying an additional parameter to `cmake`, e.g.:\n\n    cmake \\\n      -DCMAKE_INSTALL_PREFIX=/path/to/install/destination \\\n      -DCMAKE_BUILD_TYPE=Debug \\\n      ..\n\nThe `extra/build` directory contains a few sample invocations of CMake that have\nbeen successfully used on LLNL systems.\n\n\nA3) Configuring with/without Fortran\n------------------------------------\nBy default PnMPI is configured to work with C/C++ and Fortran codes. However, on\nsystems where Fortran is not available, the system should auto-detect this and\nnot build the Fortran libraries and test cases. It can also be manually turned\noff by adding\n\n    -DENABLE_FORTRAN=OFF\n\nto the `cmake` configuration command.\n\nThe PnMPI distribution contains test cases for C and Fortran that allow you to\ntest the correct linkage.\n\n\nA3a) Optional configuration options\n-----------------------------------\nIf you want to change the default build configuration, you can enable / disable\nfeatures by adding the following flags to the `cmake` configuration command.\n\n  * `-DBUILD_DOC=ON`: Generate the public code documentation and man-pages.\n    PnMPI developers may enable `BUILD_DOC_INTERNAL` instead for additional\n    PnMPI internal documentation. *(requires Doxygen and help2man)*\n  * `-DENABLE_DEBUG=OFF`: Disable PnMPI on-demand debug logging. *Disable this\n    option only for performance optimization.*\n  * `-DENABLE_MODULES=OFF`: Don't build the built-in modules.\n  * `-DENABLE_TESTING=ON`: Build the test cases and enable the `test` target.\n  * `-DENABLE_THREAD_SAFETY=OFF`: Build PnMPI without thread safety. PnMPI will\n    limit the MPI threading level if this option is enabled, so it still will be\n    thread safe. *Disable this option only for performance optimization.*\n  * `-DENABLE_PNMPIZE=OFF`: Don't build the PnMPI invocation tool and don't run\n    any tests for it. This option may be required when testing PnMPI at a\n    platform that doesn't support the `execvp()` syscall.\n  * `-DENABLE_ADEPT_UTILS=ON`: Enable support for adept-utils, to check the\n    module's symbols for their origin. *(Not supported with all compilers.)*\n  * [CMake-codecov](https://github.com/RWTH-HPC/CMake-codecov) provides the\n    additional `-DENABLE_COVERAGE=ON` option to enable code coverage. You can\n    generate coverage reports with the `gcov` and `lcov` targets. Read their\n    [README](https://github.com/RWTH-HPC/CMake-codecov/blob/master/README.md)\n    for more information.\n  * [cmake-sanitizers](https://github.com/arsenm/sanitizers-cmake) provides\n    additional options to enable sanitizers for all PnMPI targets. E.g. for\n    AddressSanitizer add `-DSANITIZE_ADDRESS=ON`. Read their\n    [README](https://github.com/arsenm/sanitizers-cmake/blob/master/README.md)\n    for more information.\n\n\nA4) Configuring for cross-compiled environments\n-----------------------------------------------\nWhen configuring PnMPI in cross-compiled environments (such as Blue Gene/Q\nsystems), it is necessary to provide a matching tool chain file. Many toolchain\nfiles are included in CMake, additional example files that allow the compilation\non certain LC machines can be found in `cmakemodules/Platform` and\n`cmakemodules/Toolchain`.\n\nFor example, to configure PnMPI for a BG/Q machine using the GNU compliler\nsuite, add the following to the `cmake` configuration command:\n\n    -DCMAKE_TOOLCHAIN_FILE=../cmakemodules/Toolchain/BlueGeneQ-gnu.cmake\n\n*You may need to modify the toolchain file for your system.*\n\n\nA5) Installed structure\n-----------------------\nOnce you've installed, all your PnMPI files and executables should be in\n`<CMAKE_INSTALL_PREFIX>`, the path specified during configuration. Roughly, the\ninstall tree looks like this:\n\n    bin/\n      pnmpi                PnMPI invocation tool\n      pnmpi-patch          Library patching utility\n    lib/\n      libpnmpi[f].[so,a]   PnMPI runtime libraries\n      pnmpi-modules/       System-installed tool modules\n      cmake/               Build files for external modules\n    include/\n      pnmpi/               PnMPI header directory\n        debug_io.h         PnMPI module debug print functions.\n        hooks.h            PnMPI module hook definitions.\n        service.h          PnMPI module service functions.\n        ...\n      pnmpi.h              PnMPI main header\n      pnmpimod.h           PnMPI module support (legacy)\n      pnmpi-config.h       CMake generated configuration file\n    share/\n      cmake/               CMake files to support tool module builds\n\nTest programs are not installed, but in the [tests/src](tests/src) folder of the\nbuild directory, there should also be test programs built with PnMPI. See below\nfor details on running these to test your PnMPI installation.\n\n\nA6) Environment setup\n-----------------------\nYou will need to set one environment variable to run PnMPI:\n\n  * `PNMPI_LIB_PATH` should be set to the full path to the PnMPI modules\n    directory. If not set, the default path of your installation directory will\n    be used.\n  * `PNMPI_CONF` should be set to the full to the path of the PnMPI\n    configuration file to be used.\n  * `PNMPI_BE_SILENT` will silence the PnMPI banner. For benchmark purposes you\n    should also disable `ENABLE_DEBUG` in your CMake configuration. **Note:**\n    Warnings on errors still will be printed.\n\n\nA6a) Using the PnMPI invocation tool\n------------------------------------\nTo run PnMPI in front of any application (that is dynamically linked to MPI),\nyou may use the `bin/pnmpi` tool. It will setup the environment and preloads\nPnMPI for you. For a list of supported arguments, invoke it with the `--help`\nflag.\n\n    :~$ pnmpi --help\n    Usage: pnmpi [OPTION...] utility [utility options]\n    P^nMPI -- Virtualization Layer for the MPI Profiling Interface\n\n      -c, --config=FILE          Configuration file\n      -q, -s, --quiet, --silent  Don't produce any output\n      -?, --help                 Give this help list\n          --usage                Give a short usage message\n      -V, --version              Print program version\n    ...\n\n\n    :~$ mpiexec -np 2 pnmpi -c pnmpi.conf a.out\n      _____   _ __   __  __  _____   _____\n     |  __ \\ | '_ \\ |  \\/  ||  __ \\ |_   _|\n     | |__) || | | || \\  / || |__) |  | |\n     |  ___/ |_| |_|| |\\/| ||  ___/   | |\n     | |            | |  | || |      _| |_\n     |_|            |_|  |_||_|     |_____|\n\n\n     Application:\n      MPI interface: C\n\n     Global settings:\n      Pcontrol: 5\n\n     Loaded modules:\n      Stack default:\n        sample1 (Pcontrol: 1)\n      Stack foo:\n    ...\n\n**Note:** The PnMPI invocation tool is not compatible with all platforms (e.g.\nBlueGene/Q), as it requires the `execvp()` function, which might not be\nsupported.\n\n\nA7) RPATH settings\n-----------------------\nBy default, the build adds the paths of all dependency libraries to the rpath of\nthe installed PnMPI library. This is the preferred behavior on LLNL systems,\nwhere many packages are installed and `LD_LIBRARY_PATH` usage can become\nconfusing.\n\nIf you are installing on a system where you do NOT want dependent libraries\nadded to your RPATH, e.g. if you expect all of PnMPI's dependencies to be found\nin system paths, then you can build without rpath additions using this option to\n`cmake`:\n\n    -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=FALSE\n\nThis will add only the PnMPI installation lib directory to the rpath of the\nPnMPI library.\n\n\nB) Usage\n========\nPnMPI supports multiple ways to use it with an MPI application:\n\nB1) Dynamic linking\n-------------------\nIf your application is dynamically linked against the MPI library, you may use\nPnMPI by simply preloading it via `LD_PRELOAD` (or `DYLD_INSERT_LIBRARIES` at\nmacOS).\n\nInstead of manually preloading, you may use the PnMPI invocation tool in\n`bin/pnmpi`.\n\nB2) Static linking\n------------------\nInstead of linking your application against the MPI library, you may link\nagainst the static MPI library.\n\n**Note:** By default the linker will only link functions used by your code, so\nmost of the API functions would not get linked into your binary. PnMPI\nimplements a helper function to force the linker to link all required functions\ninto the binary. However there might be complications, if not all functions\nwrapped by the modules are used by the application. You should tell the linker\nto link the whole PnMPI archive explicitly:\n\n    mpicc main.o -Wl,--whole-archive pnmpi.a -Wl,--no-whole-archive -o test\n\n*Note: The linker option `--whole-archive` is not available at mac OS.*\n\n\nC) Modules\n==========\nPnMPI supports two different kind of tool modules:\n\n  * Transparent modules\n  * PnMPI-specific modules\n\nAmong the former are modules that have been created independently of PnMPI and\nare just based on the PMPI interface. To use a transparent module in PnMPI the\nuser has to perform two steps:\n\n  1. Build the tool as a shared module (a dlopen-able shared library).\n  2. Patch the tool using the `pnmpi-patch` utility, which is included\n     with the PnMPI distribution.\n\nUsage:\n\n    pnmpi-patch <original tool (in)> <patched tool (out)>\n\ne.g.:\n\n    pnmpi-patch my-module.so my-pnmpi-module.so\n\nAfter that, copy the tool in one of the directories listed in `$PNMPI_LIB_PATH`\nso that PnMPI can pick it up. *Note that all of this is handled automatically\nby the CMake build files included with PnMPI (see below for more information).*\n\nThe second option is the use of PnMPI specific modules: these modules also rely\non the PMPI interface, but explicitly use some of the PnMPI features (i.e., they\nwon't run outside of PnMPI). These modules include the PnMPI header files, which\ndescribe the interface that modules can use. In short, the interface offers an\nability to register a module and after that use a publish/subscribe interface to\noffer/use services in other modules.\n\n**Note:** also PnMPI specific modules have to be patched using the utility\ndescribed above, if they don't use the XMPI interface instead of the PMPI.\n\n\nC1) Built-in modules\n--------------------\nThis package includes a set of modules that can be used both to create other\ntools using their services and as templates for new modules.\n\nThe source for all modules is stored in separate directories inside the\n`src/modules/` directory. There are:\n\n* **sample:**\n  A set of example modules that show how to wrap send and receive operations.\n\n* **empty:**\n  A transparent module that simply wraps all calls without executing any code.\n  This can be used to test overhead or as a sample for new modules.\n\n* **status:**\n  This PnMPI specific module offers a service to add extra data to each status\n  object to store additional information.\n\n* **requests:**\n  This PnMPI specific module offers a service to track asynchronous\n  communication requests. It relies on the status module.\n\n* **datatype:**\n  This PnMPI specific module tracks all datatype creations and provides an\n  iterator to walk any datatype.\n\n* **comm:**\n  This PnMPI specific module abstracts all communication in a few simple\n  callback routines. It can be used to write quick prototype tools that\n  intercept all communication operations independent of the originating MPI\n  call. This infrastructure can be used by creating submodules: two such\n  submodules are included: an empty one that can be used as a template and one\n  that prints every message.\n  Note: this module relies on the status, requests, and datatype modules. A more\n  detailed description on how to implemented submodules is included in the comm\n  directory as a separate README.\n\n* **limit-threading**\n  This PnMPI specific module limits the MPI threading level to the value set in\n  the `PNMPI_THREADING_LEVEL` environment variable. It may be used to check the\n  behaviour of an application, if the MPI environment doesn't support a specific\n  threading level.\n\n* **metrics-counter**\n  This PnMPI specific module counts the MPI call invocations. Add the module at\n  the top of your config file to count how often each rank invoked which MPI\n  call or in front of a specific module to count how often invocations reached\n  this module.\n\n* **metrics-timing**\n  This PnMPI specific module measures the time MPI call invocations take. It has\n  two different operation modes:\n\n  * simple: Add it in front of a module and it will measure the time of all\n    following modules.\n\n        module metrics-timing\n        module sample1\n\n  * advanced: Add the timing module before and after the modules you want to\n    measure and it will only measure the time of these, but not the following\n    modules.\n\n        module metrics-timing\n        module sample1\n        module sample2\n        module metrics-timing\n\n        module empty\n\n    Measuring `MPI_Pcontrol` is available in advanced mode, only. To measure\n    `MPI_Pcontrol` calls both `metrics-timing` invocations need to be pcontrol\n    enabled:\n\n        module metrics-timing\n        pcontrol on # May be ignored if metrics-timing is the first module.\n        module sample1\n        module metrics-timing\n        pcontrol on\n\n* **wait-for-debugger**\n  This module prints the PID of each rank before executing the application. If\n  the `WAIT_AT_STARTUP` environment variable is set to a numeric value, the\n  execution will be delayed up to `value` seconds, so you may attach with a\n  debugger in that time.\n\n**Note:** All modules must be compiled with the same MPI as PnMPI is build\nwith. Modules should only be linked to their required libraries, except PnMPI\nand MPI, as these routines will be provided by PnMPI when the module will be\nloaded.\n\n\nD) Building your own modules with CMake\n=======================================\nPnMPI installs CMake build files with its distribution to allow external\nprojects to quickly build MPI tool modules. The build files allow external\ntools to use PnMPI, the `pnmpi-patch` utility, PnMPI's wrapper generator, and\nPnMPI's dependency libraries.\n\nTo create a new PnMPI module, simply create a new project that looks something\nlike this:\n\n    my-project/\n      CMakeLists.txt\n      foo.c\n      wrapper.w\n\nAssume that `wrapper.w` is a wrapper generator input file that will generate\nanother file called `wrapper.c`, which contains MPI interceptor functions for\nthe tool library. `foo.c` is additional code needed for the tool library.\n`CMakeLists.txt` is the CMake build file.\n\nYour `CMakeLists.txt` file should start with something like this:\n\n```CMake\nproject(my-module C)\ncmake_minimum_required(VERSION 2.8.11.2)\n\nfind_package(PnMPI REQUIRED)\nfind_package(MPI REQUIRED)\n\nadd_wrapped_file(wrapper.c wrapper.w)\npnmpi_add_pmpi_module(foo foo.c wrapper.c)\n\ninstall(TARGETS foo DESTINATION ${PnMPI_MODULES_DIR})\n\ninclude_directories(\n  ${MPI_INCLUDE_PATH}\n  ${PnMPI_INCLUDE_DIR}\n  ${CMAKE_CURRENT_SOURCE_DIR})\n```\n\n* `project()` and `cmake_minimum_required()` are standard.  These tell the build\n  the name of the project and what version of CMake it will need.\n\n* `find_package(PnMPI)` will try to find PnMPI in system locations, and if\n  it is not found, it will fail because the `REQUIRED` option has been\n  specified.\n\n* `find_package(MPI)` locates the system MPI installation so that you can use\n  its variables in the `CMakeLists.txt` file.\n\n* `add_wrapped_file()` tells the build that `wrapper.c` is generated from\n  `wrapper.w`, and it adds rules and dependencies to the build to automatically\n  run the wrapper generator when `wrapper.c` is needed.\n\n* Finally, `pnmpi_add_pmpi_module()` function's much like CMake's builtin\n  `add_library()` command, but it ensures that the PnMPI library is built as a\n  loadable module and that the library is properly patched.\n\n  If your module uses the XMPI interface (i.e. doesn't need to be patched), use\n  `pnmpi_add_xmpi_module()` instead, so it will build the module but don't patch\n  it.\n\n* `install()` functions just as it does in a standard CMake build, but here we\n  install to the `PnMPI_MODULES_DIR` instead of an install-relative location.\n  This variable is set if PnMPI is found by `find_package(PnMPI)`, and it allows\n  users to install directly into the system PnMPI installation.\n\n* Finally, `include_directories()` functions as it would in a normal CMake\n  build.\n\nOnce you've make your `CMakeLists.txt` file like this, you can build your PnMPI\nmodule like so:\n\n    cd my-module\n    mkdir $SYS_TYPE && cd $SYS_TYPE\n    cmake ..\n    make -j8\n    make -j8 install\n\nThis should find PnMPI on your system and build your module, assuming that you\nhave your environment set up correctly.\n\n\nD2) Limiting the threading level\n--------------------------------\nIf your module is not thread safe or is only able to process a limited amount of\nthreading, it should limit the required threading level in the `MPI_Init_thread`\nwrapper:\n\n```C\nint MPI_Init_thread(int *argc, char ***argv, int required, int *provided)\n{\n  if (required > MPI_THREAD_SINGLE)\n    required = MPI_THREAD_SINGLE;\n\n  return XMPI_Init_thread(argc, argv, required, provided);\n}\n```\n\n\nD3) Module hooks\n----------------\nAt different points hooks will be called in all loaded modules. These can be\nused to trigger some functionality at a given time. All hooks have the return\ntype `void` and are defined in `pnmpi/hooks.h`, which should be included for\ntype safety. These following hooks will be called in all modules:\n\n* `PNMPI_RegistrationPoint`: This hook will be called just after the module has\n  been loaded. It may be used to register the name of the module, services\n  provided by the module, etc.\n* `PNMPI_UnregistrationPoint`: This hook will be called just before the module\n  will be unloaded. It may be used e.g. to free allocated memory.\n* `PNMPI_Init`: This hook will be called just after all modules have been\n  registered to initialize the module. It may be used to initialize the module's\n  to code and is communicate with other modules.\n* `PNMPI_Fini`: This hook will be called just before all modules will be\n  unregistered. The modules may communicate with each other and should execute\n  some final steps in here.\n\n*Note: You can use `PNMPI_Service_CallHook()` to call custom hooks in your\nmodules. Just pass a custom hook name as first parameter.*\n\nFor a detailed description, see the Doxygen docs or man-pages for these\nfunctions.\n\n\nD4) Module service functions\n----------------------------\nModules may interact with the PnMPI core and other modules with the module\nservice functions defined in `pnmpi/service.h`. For a detailed description about\nthese functions, see the Doxygen docs for the service header or the man-pages.\n\n\nD5) Debug message functions\n---------------------------\nModules may print debug messages, warnings and errors with the PnMPI API\nfunctions `PNMPI_Debug`, `PNMPI_Warning` and `PNMPI_Warning` defined in\n`pnmpi/debug_io.h`. *PnMPI will add additional informations like rank or line\nnumbers to the printed messages.*\n\nFor a detailed description, see the Doxygen docs or man-pages for these\nfunctions.\n\n\nE) Debug Options\n================\nIf PnMPI is build with `ENABLE_DEBUG`, PnMPI includes debug print functions,\nthat can be dynamically enabled. To control it, the environment variable\n`PNMPI_DBGLEVEL` can be set to any combination of the following debug levels:\n\n* `0x01` - Messages about PnMPI initialization (before MPI is initialized).\n* `0x02` - Messages about module loading.\n* `0x04` - Messages about MPI call entry and exit.\n\n**NOTE:** The first two levels should be enabled for single-rank executions\nonly, as their output can't be limited to a single rank and thus will be printed\non **all** ranks.\n\nAdditionally, the printouts can be restricted to a single node by setting the\nvariable `PNMPI_DBGNODE` to an MPI rank.\n\n\nE1) Using the PnMPI invocation tool\n-----------------------------------\nYou may set the above options in the PnMPI invocation tool. Use the `--debug`\noption to enable a specific debug level and `--debug-node` to limit the debug\noutput to a single rank.\n\n\nF) Configuration and Demo codes\n===============================\nThe PnMPI distribution includes test cases (in C and Fortran). They can be used\nto experiment with the basic PnMPI functionalities and to test the system setup.\nThe following describes the C version (the F77 version works similarly):\n\n1. Change into the [tests/src](tests/src) directory.\n2. The program [test-mpi.c](tests/src/test-mpi.c), which only initializes and\n   then finalizes MPI, was compiled into three binaries:\n\n    * `testbin-binary_mpi_c-preload` (plain MPI code)\n    * `testbin-binary_mpi_c-dynamic` (linked dynamically against PnMPI)\n    * `testbin-binary_mpi_c-static` (linked statically against PnMPI)\n\n3. Executing the `*-preload` binary will not print any output, but the binaries\n   linked against PnMPI will print the PnMPI header, indicating PnMPI is loaded\n   before MPI.\n\n4. PnMPI is configured through a configuration file that lists all modules to be\n   load by PnMPI as well as optional arguments. The name for this file can be\n   specified by the environment variable `PNMPI_CONF`. If this variable is not\n   set or the file specified can not be found, PnMPI looks for a file called\n   `.pnmpi_conf` in the current working directory, and if not found, in the\n   user's home directory.\n\n   A simple configuration file may look as follows:\n\n       module sample1\n       module sample2\n       module sample3\n       module sample4\n\n  (plus some additional lines starting with `#`, which indicates comments)\n\n  This configuration causes these four modules to be loaded in the specified\n  order. PnMPI will look for the corresponding modules (.so shared library\n  files) in `PNMPI_LIB_PATH`.\n\n5. Running the `testbin-binary_mpi_sendrecv` (a simple test sending messages\n   between the ranks) will load all four modules in the specified order and\n   intercept all MPI calls included in these modules:\n\n    * sample1: send and receive\n    * sample2: send\n    * sample3: receive\n    * sample4: send and receive\n\n  The program output (for 2 nodes) will be:\n\n  ```\n    _____   _ __   __  __  _____   _____\n   |  __ \\ | '_ \\ |  \\/  ||  __ \\ |_   _|\n   | |__) || | | || \\  / || |__) |  | |\n   |  ___/ |_| |_|| |\\/| ||  ___/   | |\n   | |            | |  | || |      _| |_\n   |_|            |_|  |_||_|     |_____|\n\n\n   Application:\n    MPI interface: C\n\n   Global settings:\n    Pcontrol: 5\n\n   Loaded modules:\n    Stack default:\n      sample1 (Pcontrol: 1)\n      sample2\n      sample3\n      sample4\n\n  WRAPPER 1: Before recv\n  WRAPPER 1: Before send\n  WRAPPER 2: Before send\n  WRAPPER 4: Before send\n  WRAPPER 4: After send\n  WRAPPER 2: After send\n  WRAPPER 1: After send\n  WRAPPER 1: Before recv\n  WRAPPER 3: Before recv\n  WRAPPER 4: Before recv\n  WRAPPER 3: Before recv\n  WRAPPER 4: Before recv\n  WRAPPER 4: After recv\n  WRAPPER 3: After recv\n  WRAPPER 1: After recv\n  Got 1 from rank 1.\n  WRAPPER 1: Before send\n  WRAPPER 2: Before send\n  WRAPPER 4: Before send\n  WRAPPER 4: After send\n  WRAPPER 4: After recv\n  WRAPPER 3: After recv\n  WRAPPER 1: After recv\n  Got 1 from rank 0.\n  WRAPPER 2: After send\n  WRAPPER 1: After send\n  ```\n\n  When running on a BG/P systems, it is necessary to explicitly export some\n  environment variables. Here is an example:\n\n        mpirun -np 4 -exp_env LD_LIBRARY_PATH -exp_env PNMPI_LIB_PATH \\\n          -cwd $PWD testbin-binary_mpi_sendrecv\n\n\nG) Using `MPI_Pcontrol`\n========================\nThe MPI standard defines the `MPI_Pcontrol`, which does not have any direct\neffect (it is implemented as a dummy call inside of MPI), but that can be\nreplaced by PMPI to accepts additional information from MPI applications (e.g.,\nturn on/off data collection or markers for main iterations). The information is\nused by a PMPI tool linked to the application. When it is used with PnMPI the\nuser must therefore decide which tool an `MPI_Pcontrol` call is directed to.\n\nBy default PnMPI will direct `MPI_Pcontrol` calls to first module in the tool\nstack only. If this is not the desired effect, users can turn on and off which\nmodule Pcontrols reach by adding `pcontrol on` and `pcontrol off` into the\nconfiguration file in a separate line following the corresponding module\nspecification. Note that PnMPI allows that `MPI_Pcontrol` calls are sent to\nmultiple modules.\n\nIn addition, the general behavior of Pcontrols can be specified with a global\noption at the beginning of the configuration file. This option is called\n`globalpcontrol` and can take one of the following arguments:\n\n* `int`: Only deliver the first argument, but ignore the variable list arguments\n  (default)\n* `pmpi`: Forward the variable list arguments\n* `pnmpi`: Requires the application to specify a specific format in the variable\n  argument list known to PnMPI (level must be `PNMPI_PCONTROL_LEVEL`)\n* `mixed`\n  * Same as pnmpi, if `level == PNMPI_PCONTROL_LEVEL`.\n  * Same as pmpi, if  `level != PNMPI_PCONTROL_LEVEL`.\n* `typed <tlevel> <type>`: Forward the first argument in any case, the second\n  only if the level matches `<tlevel>`. In this case, assume that the second\n  argument is of type `<type>`.\n\nThe PnMPI internal format for Pcontrol arguments is as follows:\n\n```\nint level (same semantics as for MPI_Pcontrol itself)\nint type = PNMPI_PCONTROL_SINGLE or PNMPI_PCONTROL_MULTIPLE\n               (target one or more modules) |\n               PNMPI_PCONTROL_VARG or PNMPI_PCONTROL_PTR\n               (arguments as vargs or one pointer)\nint mod = target module (if SINGLE)\nint modnum = number of modules (if MULTIPLE)\nint *mods = pointer to array of modules\nint size = length of all variable arguments (if VARG)\nvoid *buf = pointer to argument block (if PTR)\n```\n\n\n#### Known issues:\n\nForwarding the variable argument list as done in `pmpi` and `mixed` is only\nimplemented in a highly experimental version and disabled by default. To enable,\ncompile PnMPI with the flag `EXPERIMENTAL_UNWIND` and link PnMPI with the\nlibunwind library. Note that this is not extensively tested and not portable\nacross platforms.\n\n\nH) References\n=============\nMore documentation on PnMPI can be found in the following two published articles:\n\n* Martin Schulz and Bronis R. de Supinski.\n  **PnMPI Tools: A Whole Lot Greater Than the Sum of Their Parts**.\n  *Supercomputing 2007*.\n  November 2007, Reno, NV, USA.\n\n  Available [here](http://sc07.supercomputing.org/schedule/pdf/pap224.pdf).\n\n* Martin Schulz and Bronis R. de Supinski.\n  **A Flexible and Dynamic Infrastructure for MPI Tool Interoperability**.\n  *International Conference on Parallel Processing (ICPP)*.\n  August 2005, Columbus, OH, USA.\n  Published by IEEE Press\n\n  Available [here](http://ieeexplore.ieee.org/iel5/11126/35641/01690620.pdf?isnumber=35641&prod=CNF&arnumber=1690620&arSt=193&ared=202&arAuthor=Martin+Schulz%3B+Bronis+R.+de+Supinski).\n\n\nI) Contact\n==========\nFor more information or in case of questions, please contact\n[Martin Schulz](schulzm@llnl.gov) or\n[file an issue](https://github.com/LLNL/PnMPI/issues/new).\n\n\nCopyright\n===========\nCopyright &copy; 2008-2017 Lawrence Livermore National Security, LLC.<br/>\nCopyright &copy; 2011-2017 ZIH, Technische Universitaet Dresden, Federal\nRepublic of Germany<br/>\nCopyright &copy; 2013-2017 RWTH Aachen University, Federal Republic of Germany\n\nAll rights reserved - please read the information in the [LICENSE](LICENSE)\nfile.\n",
        "/tmp/vanessa/spack-stage/spack-stage-pnmpi-1.7-cy5e2kw6o5gvmxhwxfpv2boxamuhrwdo/spack-src/src/pnmpi/core.c": "/* This file is part of P^nMPI.\n *\n * Copyright (c)\n *  2008-2017 Lawrence Livermore National Laboratories, United States of America\n *  2011-2017 ZIH, Technische Universitaet Dresden, Federal Republic of Germany\n *  2013-2017 RWTH Aachen University, Federal Republic of Germany\n *\n *\n * P^nMPI is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation version 2.1 dated February 1999.\n *\n * P^nMPI is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with P^nMPI; if not, write to the\n *\n *   Free Software Foundation, Inc.\n *   51 Franklin St, Fifth Floor\n *   Boston, MA 02110, USA\n *\n *\n * Written by Martin Schulz, schulzm@llnl.gov.\n *\n * LLNL-CODE-402774\n */\n\n#include <alloca.h>\n#include <ctype.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"core.h\"\n#include \"pnmpi-config.h\"\n#include <pnmpi/debug_io.h>\n#include <pnmpi/private/attributes.h>\n#include <pnmpi/private/modules.h>\n\n#ifdef HAVE_ADEPT_UTILS\n#include \"link_utils.h\"\n#endif // HAVE_ADEPT_UTILS\n\n\n/* Map the old debug macros to the new debug functions and macros.\n *\n * WARNING:\n * - These macros are not portable to non-GCC compatible compilers, as\n *   ##__VA_ARGS__ is a GNU extension.\n * - These macros are for legacy support only. Use the functions and macros\n *   defined in debug_io.h for new code!\n */\n#define WARNPRINT(format, ...) PNMPI_Warning(format \"\\n\", ##__VA_ARGS__);\n#define DBGPRINT2(format, ...) \\\n  PNMPI_Debug(PNMPI_DEBUG_MODULE, format \"\\n\", ##__VA_ARGS__);\n#define DBGPRINT3(format, ...) \\\n  PNMPI_Debug(PNMPI_DEBUG_CALL, format \"\\n\", ##__VA_ARGS__);\n#define DBGPRINT4(format, ...) \\\n  PNMPI_Debug(PNMPI_DEBUG_INIT, format \"\\n\", ##__VA_ARGS__);\n\n/* Enable all debug levels, as checking the debug level to print is part of\n * pnmpi_debug now. */\n#define DBGLEVEL\n\n\npnmpi_cell_t pnmpi_activated[NUM_MPI_CELLS];\npnmpi_functions_t pnmpi_function_ptrs;\n\nint pnmpi_mpi_level = 0;\nint pnmpi_max_level;\nint pnmpi_initialization_complete;\nint pnmpi_init_done = 0;\npnmpi_compiler_tls_keyword int pnmpi_level = 0;\npnmpi_compiler_tls_keyword int initial_thread = 0;\n\n\nmodules_t modules;\n\n// array of paths to directories to search for libraries in.\ntypedef char **path_array_t;\n\n// This parses a :-separated path into strings for each component, and returns\n// a null-terminated array of those strings.\nstatic path_array_t parse_path(const char *path)\n{\n  char *pathdup = strdup(path);\n  char *start, *end;\n  int pos, path_size;\n  path_array_t path_array;\n\n  // start with one element plus null terminator\n  path_size = 2;\n  for (start = pathdup; *start; start++)\n    {\n      if (*start == ':')\n        {\n          path_size++;\n        }\n    }\n  path_array = (path_array_t)malloc(path_size * sizeof(char *));\n\n  start = pathdup;\n  pos = 0;\n  do\n    {\n      end = strchr(start, ':');\n      if (end)\n        *end = '\\0';\n\n      path_array[pos] = strdup(start);\n      pos++;\n      start = end + 1;\n    }\n  while (end);\n\n  path_array[pos] = NULL;\n  free(pathdup);\n  return path_array;\n}\n\nstatic void free_path(path_array_t path_array)\n{\n  if (!path_array)\n    return;\n\n  path_array_t cur = path_array;\n  while (*cur)\n    {\n      free(*cur);\n      cur++;\n    }\n  free(path_array);\n}\n\n\n// This finds a module in a particular library path, given by an array of\n// directories\n// to search in order.\nstatic int find_module(const char *lib_name, path_array_t library_path,\n                       void **handle, char *mod_path)\n{\n  path_array_t path;\n  module_name_t location;\n  dlerror();\n\n  if (!library_path)\n    {\n      DBGPRINT2(\"ERROR: no module path defined\\n\");\n      *handle = NULL;\n      return 1;\n    }\n\n  for (path = library_path; *path; path++)\n    {\n      snprintf(location, PNMPI_MODULE_FILENAMELEN, \"%s/%s\", *path, lib_name);\n      if (access(location, R_OK) != -1)\n        {\n          *handle = dlopen(location, RTLD_LAZY);\n          if (*handle)\n            {\n              DBGPRINT2(\"Loading module %s\\n\", lib_name);\n              strcpy(mod_path, location);\n              return 0;\n            }\n          WARNPRINT(\"Loading error for module %s in %s ( Error %s )\", lib_name,\n                    *path, dlerror());\n        }\n      else if (access(location, F_OK) != -1)\n        {\n          WARNPRINT(\"Can't load module %s at %s, no reading permissions\",\n                    lib_name, *path);\n        }\n    }\n  WARNPRINT(\"Can't find module %s in PNMPI_LIB_PATH\", lib_name);\n  return 1;\n}\n\n\nPNMPI_INTERNAL\nvoid *find_symbol(const module_def_p module, const char *symbol_name)\n{\n  void *symbol = dlsym(module->handle, symbol_name);\n\n#ifdef HAVE_ADEPT_UTILS\n  /* In some situations the found symbol is not part of the loaded module but\n   * one of its dependencies. If adept utils is available, check if the symbol\n   * is really in the module's symbol table. */\n  struct link_map *module_lmap = get_module_by_full_path(module->path);\n  struct link_map *symbol_lmap = get_module_for_address(symbol);\n  if (symbol_lmap != module_lmap)\n    {\n      DBGPRINT2(\"WARNING: Ignoring symbol %s found in '%s' while loading '%s'.\",\n                symbol_name, symbol_lmap->l_name, module_lmap->l_name);\n      return NULL;\n    }\n#endif // HAVE_ADEPT_UTILS\n\n  return symbol;\n}\n\n\n/* Core functionality for PNMPI */\nPNMPI_INTERNAL\nvoid pnmpi_PreInit(void)\n{\n  path_array_t library_path;\n  char *lib_path_string, *confdir;\n  module_name_t filename, modname;\n  FILE *conffile = NULL;\n  char line[MAX_LINE], c, lastc;\n  int pos, err;\n  char *cmdargv[MAX_CMDARGS + 1];\n  int cmdargc, comment, i;\n\n  /* setup vars */\n\n  pnmpi_max_level = 0;\n  pnmpi_initialization_complete = 0;\n\n  /* set global defaults */\n  /* none at this moment */\n\n  modules.module = NULL;\n  modules.num = 0;\n  modules.numalloc = 0;\n  modules.pcontrol = PNMPI_PCONTROL_INT;\n\n  /* locate library */\n\n  lib_path_string = getenv(\"PNMPI_LIB_PATH\");\n  if (lib_path_string == NULL)\n    {\n      // no user lib_path_string; just use the install destination's module\n      // path.\n      lib_path_string = PNMPI_MODULES_DIR;\n    }\n  else\n    {\n      // concat the user lib_path_string with the install destination's module\n      // path.\n      size_t len = strlen(lib_path_string) + strlen(PNMPI_MODULES_DIR) + 2;\n      const char *old_lib_path_string = lib_path_string;\n      lib_path_string = (char *)alloca(len * sizeof(char));\n      sprintf(lib_path_string, \"%s:%s\", old_lib_path_string, PNMPI_MODULES_DIR);\n    }\n  library_path = parse_path(lib_path_string);\n  DBGPRINT2(\"Library path is: %s\", lib_path_string);\n\n  /* locate and open file */\n\n  /* check the environment variable first */\n  confdir = getenv(\"PNMPI_CONF\");\n  if (confdir != NULL)\n    {\n      /* try to open it */\n      conffile = fopen(confdir, \"r\");\n      if (conffile == NULL)\n        {\n          int error = errno;\n          if (error == ENOENT)\n            {\n              WARNPRINT(\n                \"Configuration file not found at %s - reverting to defaults.\",\n                confdir);\n            }\n          else\n            {\n              WARNPRINT(\"Can't open configuration file %s (Error %i) - not \"\n                        \"loading any PNMPI modules.\",\n                        confdir, error);\n              free_path(library_path);\n              return;\n            }\n        }\n      else\n        {\n          DBGPRINT2(\"Open file via environment variable - %s\", confdir);\n        }\n    }\n\n  if (conffile == NULL)\n    {\n      /* now check the local directory */\n\n      size_t confsize = 1024;\n      confdir = malloc(confsize * sizeof(char));\n      while (NULL == getcwd(confdir, confsize))\n        {\n          if (errno != ERANGE)\n            {\n              free(confdir);\n              confdir = NULL;\n              break;\n            }\n          confsize *= 2;\n          confdir = realloc(confdir, confsize);\n        }\n\n      if (confdir == NULL)\n        {\n          WARNPRINT(\n            \"Can't find local directory - not loading any PNMPI modules.\");\n          free_path(library_path);\n          return;\n        }\n\n      snprintf(filename, PNMPI_MODULE_FILENAMELEN, \"%s/%s\", confdir, CONFNAME);\n      free(confdir);\n      conffile = fopen(filename, \"r\");\n      if (conffile == NULL)\n        {\n          int error = errno;\n          if (error != ENOENT)\n            {\n              WARNPRINT(\"Can't open configuration file %s (Error %i) - not \"\n                        \"loading any PNMPI modules.\",\n                        filename, error);\n              free_path(library_path);\n              return;\n            }\n        }\n      else\n        {\n          DBGPRINT2(\"Open file via local directory - %s\", filename);\n        }\n    }\n\n\n  if (conffile == NULL)\n    {\n      /* now check the home directory */\n\n      confdir = getenv(\"HOME\");\n      if (confdir == NULL)\n        {\n          WARNPRINT(\n            \"Can't find local directory - not loading any PNMPI modules.\");\n          free_path(library_path);\n          return;\n        }\n\n      snprintf(filename, PNMPI_MODULE_FILENAMELEN, \"%s/%s\", confdir, CONFNAME);\n      conffile = fopen(filename, \"r\");\n      if (conffile == NULL)\n        {\n          int error = errno;\n          if (error != ENOENT)\n            {\n              WARNPRINT(\"Can't open configuration file %s (Error %i) - not \"\n                        \"loading any PNMPI modules.\",\n                        filename, error);\n              free_path(library_path);\n              return;\n            }\n          else\n            {\n              /* WARNPRINT(\"Can't find any configuration file - not loading any\n               * PNMPI modules.\"); */\n              free_path(library_path);\n              return;\n            }\n        }\n      else\n        {\n          DBGPRINT2(\"Open file via home directory - %s\", filename);\n        }\n    }\n\n  if (conffile == NULL)\n    PNMPI_Error(\"Config file not open.\\n\");\n\n  /* read configuration file and load modules */\n\n  DBGPRINT2(\"Starting to read config file\");\n\n  if (conffile != NULL)\n    {\n      while (!feof(conffile))\n        {\n          /* read next command */\n\n          pos = 0;\n          comment = 0;\n          lastc = ' ';\n          c = ' ';\n          while ((!feof(conffile)) && (c != '\\n'))\n            {\n              c = (char)getc(conffile);\n              if ((c == '#') || (c == (char)255))\n                comment = 1;\n              if (!comment)\n                {\n                  if (pos == MAX_LINE - 1)\n                    {\n                      WARNPRINT(\"Line too long - ignoring the rest\");\n                      comment = 1;\n                    }\n                  else\n                    {\n                      if ((!(isspace(c))) || (!(isspace(lastc))))\n                        {\n                          if (isspace(c))\n                            line[pos] = ' ';\n                          else\n                            line[pos] = c;\n                          lastc = c;\n                          pos++;\n                        }\n                    }\n                }\n            }\n\n          if (pos > 0)\n            {\n              if (isspace(line[pos - 1]))\n                pos--;\n            }\n\n          line[pos] = (char)0;\n\n          DBGPRINT2(\"Read a line: %s### - first is %i - pos %i\", line,\n                    (int)line[0], pos);\n\n          /* decode the line */\n\n          for (i = 0; i < MAX_CMDARGS + 1; i++)\n            cmdargv[i] = NULL;\n\n          if (strcmp(line, \"\") == 0)\n            cmdargv[0] = NULL;\n          else\n            cmdargv[0] = line;\n\n          cmdargc = 0;\n          while (cmdargv[cmdargc] != NULL)\n            {\n              cmdargv[cmdargc + 1] = strchr(cmdargv[cmdargc], ' ');\n              if ((cmdargc == 2) && (strcmp(cmdargv[0], \"argument\") == 0))\n                cmdargv[cmdargc + 1] = NULL;\n              if (cmdargv[cmdargc + 1])\n                {\n                  *cmdargv[cmdargc + 1] = (char)0;\n                  cmdargv[cmdargc + 1]++;\n                }\n              if (cmdargc == MAX_CMDARGS - 1)\n                {\n                  WARNPRINT(\"Too many arguments - ignoring the rest\");\n                  cmdargv[cmdargc] = NULL;\n                }\n              cmdargc++;\n            }\n\n#ifdef DBGLEVEL\n          DBGPRINT2(\"CMDARGC = %i\", cmdargc);\n          for (i = 0; i < cmdargc; i++)\n            {\n              DBGPRINT2(\"  %i: %s\", i, cmdargv[i]);\n            }\n#endif\n\n          /* now that we all components, interprete them */\n\n          if (cmdargc == 0)\n            {\n              /* do nothing */\n            }\n          else if ((cmdargc == 2) && (strcmp(cmdargv[0], \"stack\") == 0))\n            {\n              /* new substack */\n\n              if (modules.num == modules.numalloc)\n                {\n                  DBGPRINT2(\"Getting new memory for names\");\n                  modules.module =\n                    realloc(modules.module, (modules.numalloc + MODULE_SKIP) *\n                                              sizeof(module_def_p));\n                  if (modules.module == NULL)\n                    {\n                      WARNPRINT(\"Out memory to load configuration file - not \"\n                                \"loading any PNMPI modules.\");\n                      modules.num = 0;\n                      modules.numalloc = 0;\n                      fclose(conffile);\n                      return;\n                    }\n                  modules.numalloc += MODULE_SKIP;\n                }\n\n              /* now allocate the actual memory */\n\n              modules.module[modules.num] =\n                (module_def_p)malloc(sizeof(module_def_t));\n              if (modules.module[modules.num] == NULL)\n                {\n                  WARNPRINT(\n                    \"Out memory to load stack defintion - ignoring delimiter.\");\n                }\n              else\n                {\n                  module_def_t empty = { { 0 } };\n                  *(modules.module[modules.num]) = empty;\n\n                  /* now we have space and can store the information */\n\n                  DBGPRINT2(\"Found stack %i: %s\", modules.num + 1, cmdargv[1]);\n                  if (strlen(cmdargv[1]) >= PNMPI_MODULE_FILENAMELEN)\n                    {\n                      WARNPRINT(\"Stack name too long - shortening it\");\n                    }\n                  strncpy(modules.module[modules.num]->name, cmdargv[1],\n                          PNMPI_MODULE_FILENAMELEN - 4);\n                  modules.module[modules.num]\n                    ->name[PNMPI_MODULE_FILENAMELEN - 5] = (char)0;\n\n                  /* I don't think we need this - seems copy and paste error\n                     sprintf(modname,\"%s/%s.so\",libdir,modules.module[modules.num]->name);\n                     */\n\n                  modules.module[modules.num]->stack_delimiter = 1;\n                  modules.module[modules.num]->registered = 0;\n                  modules.module[modules.num]->services = NULL;\n                  modules.module[modules.num]->username[0] = (char)0;\n                  modules.num++;\n                }\n            }\n          else if ((cmdargc == 2) && (strcmp(cmdargv[0], \"module\") == 0))\n            {\n              /* start a new module */\n\n              if (modules.num == modules.numalloc)\n                {\n                  DBGPRINT2(\"Getting new memory for names\");\n                  modules.module =\n                    realloc(modules.module, (modules.numalloc + MODULE_SKIP) *\n                                              sizeof(module_def_p));\n                  if (modules.module == NULL)\n                    {\n                      WARNPRINT(\"Out memory to load configuration file - not \"\n                                \"loading any PNMPI modules.\");\n                      modules.num = 0;\n                      modules.numalloc = 0;\n                      fclose(conffile);\n                      return;\n                    }\n                  modules.numalloc += MODULE_SKIP;\n                }\n\n              /* now allocate the actual memory */\n\n              modules.module[modules.num] =\n                (module_def_p)malloc(sizeof(module_def_t));\n              if (modules.module[modules.num] == NULL)\n                {\n                  WARNPRINT(\n                    \"Out memory to load module defintion - ignoring module.\");\n                }\n              else\n                {\n                  module_def_t empty_module = { { 0 } };\n                  *(modules.module[modules.num]) = empty_module;\n\n                  /* now we have space and can store the information */\n\n                  DBGPRINT2(\"Found module %i: %s\", modules.num + 1, cmdargv[1]);\n                  if (strlen(cmdargv[1]) >= PNMPI_MODULE_FILENAMELEN)\n                    {\n                      WARNPRINT(\"Module name too long - shortening it\");\n                    }\n                  strncpy(modules.module[modules.num]->name, cmdargv[1],\n                          PNMPI_MODULE_FILENAMELEN - 4);\n                  modules.module[modules.num]\n                    ->name[PNMPI_MODULE_FILENAMELEN - 5] = (char)0;\n                  snprintf(modname, PNMPI_MODULE_FILENAMELEN, \"%s.so\",\n                           modules.module[modules.num]->name);\n\n                  /* The first module gets the pcontrol by default */\n\n                  if (modules.num == 0)\n                    {\n                      modules.module[modules.num]->pcontrol = 1;\n                    }\n                  else\n                    {\n                      modules.module[modules.num]->pcontrol = 0;\n                    }\n\n                  find_module(modname, library_path,\n                              &modules.module[modules.num]->handle,\n                              modules.module[modules.num]->path);\n                  if (modules.module[modules.num]->handle == NULL)\n                    {\n                      WARNPRINT(\"Can't load module %s at all!\", modname);\n                    }\n                  else\n                    {\n                      /* we could open the module - hence we are good to go */\n                      DBGPRINT2(\"dlopen successful\");\n\n                      modules.module[modules.num]->stack_delimiter = 0;\n                      modules.module[modules.num]->registered = 0;\n                      modules.module[modules.num]->services = NULL;\n                      modules.module[modules.num]->globals = NULL;\n                      modules.module[modules.num]->args = NULL;\n                      modules.module[modules.num]->username[0] = (char)0;\n\n                      /* Check, if the module provides a module name, so it can\n                       * be registered. */\n                      const char **module_name = find_symbol(\n                        modules.module[modules.num], \"PNMPI_ModuleName\");\n                      if (module_name != NULL)\n                        {\n                          pnmpi_level = modules.num;\n                          PNMPI_Service_RegisterModule(*module_name);\n                        }\n\n                      /* PNMPI_RegistrationPoint will be called later */\n\n                      pnmpi_level = modules.num;\n                      modules.num++;\n                    }\n                }\n            }\n          else if (((cmdargc == 1) || (cmdargc == 2)) &&\n                   (strcmp(cmdargv[0], \"pcontrol\") == 0))\n            {\n              /* check if module is active */\n\n              if (modules.num > 0)\n                {\n                  int turnon;\n\n                  /* mark the module as receiving pcontrol commands */\n\n                  if (cmdargc == 1)\n                    turnon = 1;\n                  else\n                    {\n                      if (strcmp(cmdargv[1], \"on\") == 0)\n                        turnon = 1;\n                      else if (strcmp(cmdargv[1], \"off\") == 0)\n                        turnon = 0;\n                      else\n                        {\n                          WARNPRINT(\"Can't understand pcontrol argument - \"\n                                    \"turning pcontrol off\");\n                          turnon = 0;\n                        }\n                    }\n                  modules.module[modules.num - 1]->pcontrol = turnon;\n                }\n              else\n                {\n                  WARNPRINT(\n                    \"No module active - ignoring local command pcontrol\");\n                }\n            }\n          else if ((cmdargc == 2) &&\n                   (strcmp(cmdargv[0], \"globalpcontrol\") == 0))\n            {\n              /* find global pcontrol setting with no extra argument */\n\n              if (strcmp(cmdargv[1], \"on\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_ON;\n              else if (strcmp(cmdargv[1], \"off\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_OFF;\n              else if (strcmp(cmdargv[1], \"pmpi\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_PMPI;\n              else if (strcmp(cmdargv[1], \"pnmpi\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_PNMPI;\n              else if (strcmp(cmdargv[1], \"mixed\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_MIXED;\n              else if (strcmp(cmdargv[1], \"int\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_INT;\n              else\n                {\n                  WARNPRINT(\n                    \"Can't understand globalpcontrol argument - ignoring it\");\n                }\n            }\n          else if ((cmdargc == 4) &&\n                   (strcmp(cmdargv[0], \"globalpcontrol\") == 0))\n            {\n              /* find global pcontrol setting with two extra arguments */\n\n              if (strcmp(cmdargv[1], \"typed\") == 0)\n                {\n                  modules.pcontrol = PNMPI_PCONTROL_TYPED;\n                  modules.pcontrol_typed_level = atoi(cmdargv[2]);\n                  if (strcmp(cmdargv[3], \"int\") == 0)\n                    modules.pcontrol_typed_type = PNMPI_PCONTROL_TYPE_INT;\n                  else if (strcmp(cmdargv[3], \"pointer\") == 0)\n                    modules.pcontrol_typed_type = PNMPI_PCONTROL_TYPE_PTR;\n                  else if (strcmp(cmdargv[3], \"double\") == 0)\n                    modules.pcontrol_typed_type = PNMPI_PCONTROL_TYPE_DOUBLE;\n                  else if (strcmp(cmdargv[3], \"long\") == 0)\n                    modules.pcontrol_typed_type = PNMPI_PCONTROL_TYPE_LONG;\n                  else\n                    {\n                      WARNPRINT(\"Can't understand globalpcontrol argument - \"\n                                \"ignoring it\");\n                    }\n                }\n              else\n                {\n                  WARNPRINT(\n                    \"Can't understand globalpcontrol argument - ignoring it\");\n                }\n            }\n          else if ((cmdargc >= 3) && (strcmp(cmdargv[0], \"argument\") == 0))\n            {\n              /* check if module is active */\n\n              if (modules.num > 0)\n                {\n                  module_arg_p arg, argl;\n\n                  /* record argumemt */\n\n                  arg = (module_arg_p)malloc(sizeof(module_arg_t));\n                  if (arg == NULL)\n                    {\n                      WARNPRINT(\"No memory to allocate argument - ignoring it\");\n                    }\n                  else\n                    {\n                      if (strlen(cmdargv[1]) >= MAX_ARG_NAME)\n                        WARNPRINT(\"Argument name too long - trunacting it\");\n                      if (strlen(cmdargv[2]) >= MAX_ARG_VALUE)\n                        WARNPRINT(\"Argument value too long - trunacting it\");\n                      strncpy(arg->name, cmdargv[1], MAX_ARG_NAME);\n                      strncpy(arg->value, cmdargv[2], MAX_ARG_VALUE);\n                      arg->name[MAX_ARG_NAME - 1] = (char)0;\n                      arg->value[MAX_ARG_VALUE - 1] = (char)0;\n                      argl = modules.module[modules.num - 1]->args;\n                      arg->next = NULL;\n                      if (argl)\n                        {\n                          while (argl->next)\n                            argl = argl->next;\n                          argl->next = arg;\n                        }\n                      else\n                        modules.module[modules.num - 1]->args = arg;\n                    }\n                }\n              else\n                {\n                  WARNPRINT(\n                    \"No module active - ignoring local command argument\");\n                }\n            }\n          else\n            {\n              WARNPRINT(\"Illegal command %s - ignoring it\", cmdargv[0]);\n            }\n        } /* while eof */\n    }     /* if file open */\n\n  /*Free what we allocated*/\n  if (conffile)\n    fclose(conffile);\n\n  /*\n   * Call the module registration point functions\n   * (done now as to load arguments first)\n   */\n  pnmpi_call_hook(PNMPI_REGISTRATION_POINT, PNMPI_CALL_HOOK_ALL_MODULES, 0);\n\n  /* After all hooks have been registered, call the module initialization hook.\n   * Modules may access other modules in this hook. */\n  pnmpi_call_hook(\"PNMPI_Init\", PNMPI_CALL_HOOK_ALL_MODULES, 0);\n\n/* if we are debugging, print the parsed information */\n\n#ifdef DBGLEVEL\n  {\n    int _i, _j;\n    module_arg_p arg;\n    DBGPRINT4(\"Parsed information from configuration file\");\n    for (_i = 0; _i < modules.num; _i++)\n      {\n        DBGPRINT4(\"- Module %s (pcontrol %i)\", modules.module[_i]->name,\n                  modules.module[_i]->pcontrol);\n        _j = 1;\n        arg = modules.module[_i]->args;\n        while (arg != NULL)\n          {\n            DBGPRINT4(\"\\t Argument %2i: %s = %s\", _j, arg->name, arg->value);\n            arg = arg->next;\n            _j++;\n          }\n      }\n    DBGPRINT4(\"\\n\");\n  }\n#endif /* DBGLEVEL */\n\n\n  /* Initialize and load the indirection arrays */\n\n  if (modules.num > 0)\n    {\n      INITIALIZE_ALL_FUNCTION_STACKS(modules);\n    }\n\n#ifdef DBGLEVEL\n  {\n    int _i;\n    for (_i = 0; _i < NUM_MPI_CELLS; _i++)\n      {\n        DBGPRINT3(\"Cell %i = %lx\", _i, pnmpi_activated[_i]);\n      }\n  }\n#endif\n\n  free_path(library_path);\n\n  /* fix variables */\n  pnmpi_max_level = modules.num;\n  pnmpi_level = 0;\n}\n"
    },
    "skipped": [],
    "total_files": 294
}