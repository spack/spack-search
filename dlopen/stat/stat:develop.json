{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/src/dysect/DysectAPI/DysectAPI.C": "/*\nCopyright (c) 2013-2014, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory.\nWritten by Niklas Nielsen, Gregory Lee [lee218@llnl.gov], Dong Ahn.\nLLNL-CODE-645136.\nAll rights reserved.\n\nThis file is part of DysectAPI. For details, see https://github.com/lee218llnl/DysectAPI. Please also read dysect/LICENSE\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License (as published by the Free Software Foundation) version 2.1 dated February 1999.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and conditions of the GNU General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple\nPlace, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"DysectAPI/DysectAPI.h\"\n\nusing namespace DysectAPI;\n\nDysectErrorCode SessionLibrary::loadLibrary(const char *path) {\n  libraryHandle = dlopen(path, RTLD_LAZY);\n\n  if (!libraryHandle) {\n    fprintf(stderr, \"Cannot open library: %s\\n\", dlerror());\n    return LibraryNotLoaded;\n  }\n\n  return OK;\n}\n\nSessionLibrary::SessionLibrary(const char* libPath, bool broadcast) {\n  loaded = (loadLibrary(libPath) == OK);\n}\n\nbool SessionLibrary::isLoaded() {\n  return loaded;\n}\n\nbool DysectAPI::isDysectTag(int tag) {\n  int topPos = (sizeof(int) * 8) - (sizeof(char) * 8);\n\n  int topSignature = 0x7e << topPos;\n  int mask = 0xff << topPos;\n\n  return ((tag & mask) == topSignature);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/examples/scripts/script_test.py": "# STAT test suite\n# invoke with ${prefix}/bin/stat-script\n\nimport sys, DLFCN\nsys.setdlopenflags(DLFCN.RTLD_NOW | DLFCN.RTLD_GLOBAL)\nimport os, time, subprocess\nimport traceback\nimport argparse\n\nfrom STAT import STAT_FrontEnd, intArray, STAT_LOG_NONE, STAT_LOG_FE, STAT_LOG_BE, STAT_LOG_CP, STAT_LOG_MRN, STAT_LOG_SW, STAT_LOG_SWERR, STAT_LOG_NONE, STAT_OK, STAT_APPLICATION_EXITED, STAT_VERBOSE_ERROR, STAT_VERBOSE_FULL, STAT_VERBOSE_STDOUT, STAT_TOPOLOGY_AUTO, STAT_TOPOLOGY_DEPTH, STAT_TOPOLOGY_FANOUT, STAT_TOPOLOGY_USER, STAT_PENDING_ACK, STAT_LAUNCH, STAT_ATTACH, STAT_SERIAL_ATTACH, STAT_SAMPLE_FUNCTION_ONLY, STAT_SAMPLE_LINE, STAT_SAMPLE_PC, STAT_SAMPLE_COUNT_REP, STAT_SAMPLE_THREADS, STAT_SAMPLE_CLEAR_ON_SAMPLE, STAT_SAMPLE_PYTHON, STAT_SAMPLE_MODULE_OFFSET, STAT_CP_NONE, STAT_CP_EXCLUSIVE, STAT_CP_SHAREAPPNODES\nfrom STAT import attach, launch, serial_attach, sample, detach, pause, resume, get_stat_fe, STATerror\nfrom STAThelper import ProcTab, get_proctab\n\ntest_name = ''\n\nclass STATapp:\n    def __init__(self, launcher, exe, launcher_args = [], exe_args = []):\n        self.launcher = launcher\n        self.exe = exe\n        self.launcher_args = launcher_args\n        self.exe_args = exe_args\n\n    def launch(self):\n        global test_name\n        launch_args = [self.launcher] + self.launcher_args + [self.exe] + self.exe_args\n        try:\n            launch(launch_args)\n            self.stat_fe = get_stat_fe()\n            self.pid = self.stat_fe.getLauncherPid()\n            out_dir = self.stat_fe.getOutDir()\n            file_prefix = self.stat_fe.getFilePrefix()\n            self.proctab_file_path = out_dir + '/' + file_prefix + '.ptab'\n            sample(alt_dot_filename = test_name.replace(' ', '_'))\n            detach()\n            del self.stat_fe\n        except Exception as e:\n            sys.stderr.write('launch %s failed: %s\\n' %(repr(launch_args), e))\n            self.terminate()\n            return False\n        return True\n\n    def terminate(self):\n        if hasattr(self, 'pid'):\n            subprocess.call(['kill', '-TERM', str(self.pid)])\n        return True\n\n\nclass STATtest:\n    def __init__(self, name, app, attach_options = (), sample_options_list = [{}], sleep_time = 3):\n        self.name = name\n        self.app = app\n        self.attach_options = attach_options\n        self.sample_options_list = sample_options_list\n        self.sleep_time = sleep_time\n\n    def run(self):\n        global test_name\n        attached = False\n        try:\n            attach_args, attach_kw_args, attach_function = self.attach_options\n            sys.stdout.write('%s test beginning...\\n' %(self.name))\n            time.sleep(self.sleep_time)\n            pid_arg = str(self.app.pid)\n            if (attach_function == serial_attach):\n                proctab = get_proctab(self.app.proctab_file_path)\n                pid_list = []\n                for rank, host, serial_pid, exe_index in proctab.process_list:\n                    if rank % 3 == 0:\n                        pid_list.append('%s@%s:%d' %(proctab.executable_paths[exe_index], host, serial_pid))\n                pid_arg = pid_list\n            attach_args = (pid_arg,) + attach_args\n            apply(attach_function, attach_args, attach_kw_args)\n            attached = True\n            resume()\n            for kw_args in self.sample_options_list:\n                kw_args['alt_dot_filename'] = test_name.replace(' ', '_')\n                ret = apply(sample, (), kw_args)\n            detach()\n        except Exception as e:\n            sys.stderr.write('%s test failed: %s\\n' %(self.name, repr(e)))\n            traceback.print_exc()\n            if attached == True:\n                detach()\n            return False\n        sys.stdout.write('%s test complete\\n' %(self.name))\n        return True\n\ndef run_tests(test_suites, launcher, launcher_args):\n    global test_name\n    failed_list = []\n    count = 0\n    for exe, tests in test_suites:\n        count += 1\n        if os.path.exists(exe) != True:\n            msg = 'exe %s does not exist\\n' %exe\n            sys.stderr.write(msg)\n            failed_list.append(msg)\n            continue\n        test_name = 'launch and sample %s' %(os.path.basename(exe))\n        sys.stdout.write('\\n%s test beginning...\\n' %(test_name))\n        app = STATapp(launcher, exe, launcher_args = num_tasks_args)\n        ret = app.launch()\n        if ret == False:\n            failed_list.append(test_name)\n            continue\n        sys.stdout.write('%s test complete\\n' %(test_name))\n\n        test_name = 'basic samples %s' %(os.path.basename(exe))\n        sample_options = [{}, {\"sample_type\":STAT_SAMPLE_FUNCTION_ONLY + STAT_SAMPLE_THREADS}, {\"num_traces\":10}, {\"sample_type\":STAT_SAMPLE_FUNCTION_ONLY + STAT_SAMPLE_COUNT_REP}, {\"sample_type\":STAT_SAMPLE_FUNCTION_ONLY + STAT_SAMPLE_LINE}]\n        attach_options = ((app.pid,), {}, attach)\n        tests.insert(0, (test_name, attach_options, sample_options))\n\n        for test in tests:\n            count += 1\n            test_name, attach_options, sample_options = test\n            test = STATtest(test_name, app, attach_options = attach_options, sample_options_list = sample_options)\n            ret = test.run()\n            if ret == False:\n                failed_list.append(test_name)\n                continue\n\n        sys.stdout.write(\"\\n%s tests complete, terminating application\\n\\n\" %os.path.basename(exe))\n        app.terminate()\n        time.sleep(3)\n\n    if len(failed_list) != 0:\n        sys.stdout.write('\\n%d of %d tests failed:\\n' %(len(failed_list), count))\n        for failure in failed_list:\n            sys.stdout.write('\\t%s\\n' %failure)\n    else:\n        sys.stdout.write('\\nAll %d tests passed!\\n\\n' %(count))\n    \n    return True\n\nif __name__ == \"__main__\":\n\n    os.environ['STAT_USAGE_LOG'] = '/dev/null'\n    os.environ['STAT_CHECK_NODE_ACCESS'] = '1'\n    os.environ['STAT_CONNECT_TIMEOUT'] = '30'\n    os.environ['LMON_FE_ENGINE_TIMEOUT'] = '30'\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-l\", \"--launcher\", help=\"the job launcher to use (i.e., mpirun, srun, etc.), default=mpirun\", default=\"mpirun\")\n    parser.add_argument(\"-n\", \"--numtasks\", help=\"The number of MPI tasks, default=16\", type=int, default=16)\n    args = parser.parse_args()\n    launcher = args.launcher\n    num_tasks = args.numtasks\n    num_tasks_args = ['-n', str(num_tasks)]\n    temp_fe = STAT_FrontEnd()\n    version = intArray(3)\n    install_prefix = temp_fe.getInstallPrefix()\n    temp_fe.getVersion(version)\n    del temp_fe\n    sys.stdout.write(\"STAT version %d.%d.%d installed in %s\\n\" %(version[0], version[1], version[2], install_prefix))\n\n    test_suites = []\n    exe = '%s/share/stat/examples/bin/hw' %(install_prefix)\n    tests = []\n    test_suites.append((exe, tests))\n\n    exe = '%s/share/stat/examples/bin/rank_test' %(install_prefix)\n    tests = []\n    test_suites.append((exe, tests))\n\n    exe = '%s/share/stat/examples/bin/mpi_ringtopo' %(install_prefix)\n    tests = []\n\n    test_name = 'serial attach %s' %(os.path.basename(exe))\n    attach_options = ((), {}, serial_attach)\n    sample_options = [{}]\n    tests.append((test_name, attach_options, sample_options))\n\n    test_name = 'various samples %s' %(os.path.basename(exe))\n    attach_options = ((), {}, attach)\n    sample_options = [{}, {\"sample_type\":STAT_SAMPLE_FUNCTION_ONLY + STAT_SAMPLE_THREADS}, {\"num_traces\":10}, {\"sample_type\":STAT_SAMPLE_CLEAR_ON_SAMPLE, \"num_traces\":10}, {\"sample_type\":STAT_SAMPLE_FUNCTION_ONLY + STAT_SAMPLE_COUNT_REP}, {\"sample_type\":STAT_SAMPLE_MODULE_OFFSET}, {\"sample_type\":STAT_SAMPLE_FUNCTION_ONLY + STAT_SAMPLE_LINE}]\n    tests.append((test_name, attach_options, sample_options))\n\n    test_name = \"depth topology %s\" %(os.path.basename(exe))\n    attach_options = ((), {\"topology_type\":STAT_TOPOLOGY_DEPTH, \"topology\":\"2\"}, attach)\n    sample_options = [{}]\n    tests.append((test_name, attach_options, sample_options))\n\n    test_name = \"user topology %s\" %(os.path.basename(exe))\n    attach_options = ((), {\"topology_type\":STAT_TOPOLOGY_USER, \"topology\":\"1-1\"}, attach)\n    sample_options = [{}]\n    tests.append((test_name, attach_options, sample_options))\n\n    test_name = \"insufficient nodes %s\" %(os.path.basename(exe))\n    attach_options = ((), {\"topology_type\":STAT_TOPOLOGY_USER, \"topology\":\"1-1\", \"cp_policy\":STAT_CP_NONE}, attach)\n    sample_options = [{}]\n    tests.append((test_name, attach_options, sample_options))\n\n    test_name = \"localhost topology %s\" %(os.path.basename(exe))\n    attach_options = ((), {\"topology_type\":STAT_TOPOLOGY_USER, \"topology\":\"1\", \"cp_policy\":STAT_CP_NONE, \"node_list\":\"localhost\", \"logging_tuple\":(STAT_LOG_FE | STAT_LOG_BE | STAT_LOG_CP | STAT_LOG_MRN, os.environ['HOME'])}, attach)\n    sample_options = [{}]\n    tests.append((test_name, attach_options, sample_options))\n\n    test_suites.append((exe, tests))\n\n    run_tests(test_suites, launcher, num_tasks_args)\n",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/scripts/STATview.py": "#!/bin/env python\n\n\"\"\"@package STATview\nVisualizes dot graphs outputted by STAT.\"\"\"\n\n__copyright__ = \"\"\"Copyright (c) 2007-2020, Lawrence Livermore National Security, LLC.\"\"\"\n__license__ = \"\"\"Produced at the Lawrence Livermore National Laboratory\nWritten by Gregory Lee <lee218@llnl.gov>, Dorian Arnold, Matthew LeGendre, Dong Ahn, Bronis de Supinski, Barton Miller, Martin Schulz, Niklas Nielson, Nicklas Bo Jensen, Jesper Nielson, and Sven Karlsson.\nLLNL-CODE-750488.\nAll rights reserved.\n\nThis file is part of STAT. For details, see http://www.github.com/LLNL/STAT. Please also read STAT/LICENSE.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        Redistributions of source code must retain the above copyright notice, this list of conditions and the disclaimer below.\n        Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the disclaimer (as noted below) in the documentation and/or other materials provided with the distribution.\n        Neither the name of the LLNS/LLNL nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"\n__author__ = [\"Gregory Lee <lee218@llnl.gov>\", \"Dorian Arnold\", \"Matthew LeGendre\", \"Dong Ahn\", \"Bronis de Supinski\", \"Barton Miller\", \"Martin Schulz\", \"Niklas Nielson\", \"Nicklas Bo Jensen\", \"Jesper Nielson\"]\n__version_major__ = 4\n__version_minor__ = 0\n__version_revision__ = 3\n__version__ = \"%d.%d.%d\" %(__version_major__, __version_minor__, __version_revision__)\n\nimport string\nimport sys\nimport shutil\nimport os\nimport math\nimport re\nimport subprocess\nimport traceback\nimport shelve\nfrom collections import defaultdict\nimport copy\nimport ctypes\n\nHAVE_DLOPEN = hasattr(sys, 'getdlopenflags')\nif HAVE_DLOPEN is True:\n    dlflags = sys.getdlopenflags()\n    new_dlflags = ctypes.RTLD_GLOBAL | dlflags\n    sys.setdlopenflags(new_dlflags)\n\n(MODEL_INDEX_HIDE, MODEL_INDEX_NAME, MODEL_INDEX_CASESENSITIVE, MODEL_INDEX_REGEX, MODEL_INDEX_EDITABLE, MODEL_INDEX_NOTEDITABLE, MODEL_INDEX_CALLBACK, MODEL_INDEX_ICON, MODEL_INDEX_BUTTONNAME) = range(9)\n\n# Make sure $DISPLAY is set (not good for Windows!)\nif os.name != 'nt':\n    if not \"DISPLAY\" in os.environ:\n        raise Exception('$DISPLAY is not set.  Ensure that X11 forwarding is enabled.\\n')\n\n# Check for required modules\n\ntry:\n    import xdot\nexcept:\n    raise Exception('STATview requires xdot\\nxdot can be downloaded from https://github.com/jrfonseca/xdot.py\\n')\n# old xdot vs new xdot compatibility wrapper\ntry:\n    xdot_ui_actions = xdot.ui.actions\n    xdot_ui_elements = xdot.ui.elements\n    xdot_ui_window = xdot.ui.window\n    xdot_dot_parser = xdot.dot.parser\n    xdot_dot_lexer = xdot.dot.lexer\nexcept:\n    xdot_ui_actions = xdot\n    xdot_ui_elements = xdot\n    xdot_ui_window = xdot\n    xdot_dot_parser = xdot\n    xdot_dot_lexer = xdot\n\nhas_gtk = False\nimport_error = ''\ntry:\n    import gtk\n    import gobject\n    import pango\n    gtk_wrap_new_with_label_from_widget = gtk.RadioButton\n    gtk_wrap_new_from_widget = gtk.RadioButton\n    has_gtk = True\nexcept ImportError as e:\n    import_error = e\n    pass #raise Exception('%s\\nSTATview requires gtk and gobject\\n' % repr(e))\nexcept RuntimeError as e:\n    import_error = e\n    pass #raise Exception('%s\\nThere was a problem loading the gtk and gobject module.\\nIs X11 forwarding enabled?\\n' % repr(e))\nexcept Exception as e:\n    import_error = e\n    pass #raise Exception('%s\\nThere was a problem loading the gtk module.\\n' % repr(e))\n\nif has_gtk == False:\n    try:\n        import gi\n        gi.require_version('Gtk', '3.0')\n        from gi.repository import Gtk as gtk\n        from gi.repository import Gdk as gdk\n        from gi.repository import GObject as gobject\n\n        # wrap some old functionality\n        gtk.FILE_CHOOSER_ACTION_OPEN = gtk.FileChooserAction.OPEN\n        gtk.FILE_CHOOSER_ACTION_SAVE = gtk.FileChooserAction.SAVE\n        gtk.RESPONSE_CANCEL = gtk.ResponseType.CANCEL\n        gtk.RESPONSE_OK = gtk.ResponseType.OK\n        gtk.WRAP_CHAR = gtk.WrapMode.CHAR\n        gtk.WRAP_WORD = gtk.WrapMode.WORD\n        gtk.STATE_SELECTED = gtk.StateType.SELECTED\n        gtk.STATE_NORMAL = gtk.StateType.NORMAL\n        gtk.STATE_PRELIGHT = gtk.StateType.PRELIGHT\n        gtk.SHADOW_ETCHED_IN = gtk.ShadowType.ETCHED_IN\n        gtk.SHADOW_ETCHED_OUT = gtk.ShadowType.ETCHED_OUT\n        gtk.SHADOW_OUT = gtk.ShadowType.OUT\n        gtk.CELL_RENDERER_PRELIT = gtk.CellRendererState.PRELIT\n        gtk.POLICY_AUTOMATIC = gtk.PolicyType.AUTOMATIC\n        gtk.SELECTION_SINGLE = gtk.SelectionMode.SINGLE\n        gtk.CELL_RENDERER_MODE_ACTIVATABLE = gtk.CellRendererMode.ACTIVATABLE\n        gtk.TREE_VIEW_COLUMN_FIXED = gtk.TreeViewColumnSizing.FIXED\n        gdk.BUTTON_PRESS = gdk.EventType.BUTTON_PRESS\n        gtk.FILE_CHOOSER_ACTION_OPEN = gtk.FileChooserAction.OPEN\n        gtk.POS_TOP = gtk.PositionType.TOP\n        gtk.combo_box_new_text = gtk.ComboBoxText\n        gtk.gdk = gdk\n        gtk_wrap_new_with_label_from_widget = gtk.RadioButton.new_with_label_from_widget\n        gtk_wrap_new_from_widget = gtk.RadioButton.new_from_widget\n    except Exception as e2:\n        raise Exception('%s\\n%s\\nThere was a problem loading the gtk module.\\n' % (repr(import_error), repr(e2)))\n\ntry:\n    import STAThelper\n    from STAThelper import which, color_to_string, DecomposedNode, decompose_node, HAVE_PYGMENTS, is_mpi, escaped_label, has_source_and_not_collapsed, has_module_offset_and_not_collapsed, label_has_source, label_has_module_offset, label_collapsed, translate, expr, node_attr_to_label, edge_attr_to_label, get_truncated_edge_label, get_num_tasks\nexcept Exception as e:\n    raise Exception('%s\\nThere was a problem loading the STAThelper module.\\n' % repr(e))\nif HAVE_PYGMENTS:\n    import pygments\n    from pygments.lexers import CLexer\n    from pygments.lexers import CppLexer\n    from pygments.lexers import FortranLexer\n    from STAThelper import STATviewFormatter\n# Check for optional modules\n## A variable to determine whether we have the temporal ordering module\nHAVE_TOMOD = True\ntry:\n    import tomod\nexcept Exception as e:\n    HAVE_TOMOD = False\n\n## A variable to determine wehther we have the lru_cache decorator\nHAVE_FUNCTOOLS=True\ntry:\n    from functools import lru_cache\nexcept ImportError:\n    HAVE_FUNCTOOLS=False\nif HAVE_FUNCTOOLS==False:\n    try:\n        from backports.functools_lru_cache import lru_cache\n        HAVE_FUNCTOOLS=True\n    except:\n        pass\n\n## The location of the STAT logo image\ntry:\n    STAT_LOGO = os.path.join(os.path.dirname(__file__), '../../../share/stat/STATlogo.gif')\nexcept:\n    STAT_LOGO = 'STATlogo.gif'\n\n## A variable to enable or disable scroll bars (not 100% functional)\nuse_scroll_bars = False\n\n## A global variable to track the main window object\nwindow = None\n\n## The global map of source line info to lexicographical string\nlex_map = {}\n\n## The source and include search paths for temporal ordering and source view\nsearch_paths = {}\nsearch_paths['source'] = []\nsearch_paths['source'].append(os.getcwd())\nsearch_paths['include'] = [\"/usr/local/tools/mvapich-gnu/include\"]\n#search_paths['include'] = []\n\n## A global table to avoid redundant task list generation\ntask_label_to_list = {}\n\n## A global table to avoid unnecessary parsing of long label strings\ntask_label_id_to_list = {}\n\n## A global table to avoid unnecessary parsing of long label strings\ntask_label_to_id = {}\n\n## A counter to keep track of unique label IDs\nnext_label_id = -1\n\n## A default name for the source cache directory\ncache_directory = 'stat_source_cache'\n\ndef my_lower(text):\n    return text.lower()\nstring.lower = my_lower\n\n## A decorator that uses the requested decorator upon a condition\nclass conditional_decorator(object):\n    def __init__(self, dec, condition):\n        self.decorator = dec\n        self.condition = condition\n\n    def __call__(self, func):\n        if not self.condition:\n            return func\n        return self.decorator(func)\n\n\n## \\param label - the edge label\n#  \\return the list of ranks\n#\n#  \\n\n@conditional_decorator(lambda func: lru_cache(maxsize=None, typed=True)(func), (HAVE_FUNCTOOLS is True))\ndef get_task_list(label):\n    try:\n        label = label.decode('utf-8')\n    except:\n        pass\n    if label == '' or label == None:\n        return []\n    if label[0] != '[':\n        # this is just a count and representative\n        label = label[label.find(':') + 2:label.find(']')]\n        return [int(label)]\n    ret = []\n    if label in task_label_to_list:\n        ret = task_label_to_list[label]\n    else:\n        ret = STAThelper.get_task_list(label)\n        task_label_to_list[label] = ret\n        global next_label_id\n        next_label_id += 1\n        task_label_id_to_list[next_label_id] = ret\n        task_label_to_id[label] = next_label_id\n    return ret\n\n\n## \\param task_list - the list of tasks\n#  \\return the string representation\n#\n#  \\n\ndef list_to_string(task_list):\n    \"\"\"Translate a list of tasks into a range string.\"\"\"\n    global next_label_id\n    for key, value in task_label_to_list.items():\n        if task_list == value:\n            return key\n    ret = ''\n    in_range = False\n    first_iteration = True\n    last_val = -1\n    for task in task_list:\n        if in_range:\n            ret += '%d,%d' % (last_val, task)\n            in_range = False\n        else:\n            if first_iteration:\n                ret += '%d' % (task)\n                first_iteration = False\n            else:\n                if task == last_val + 1:\n                    in_range = True\n                    ret += '-'\n                else:\n                    ret += ',%d' % (task)\n        last_val = task\n    if in_range:\n        ret += '%d' % (task)\n    task_label_to_list['[' + ret + ']'] = task_list\n    next_label_id += 1\n    task_label_id_to_list[next_label_id] = task_list\n    task_label_to_id['[' + ret + ']'] = next_label_id\n    return ret\n\n\n## \\param dot_filename - the input .dot file\n## \\param truncate - whether to truncate from \"front\" or \"back\"\n## \\param max_node_name - the max length of the node name to output\n#  \\return the created temporary dot file name\n#\n#  \\n\ndef create_temp(dot_filename, truncate, max_node_name):\n    \"\"\"Create a temporary dot file with \"...\" truncated edge labels\n    and compressed node labels.\"\"\"\n    temp_dot_filename = '_temp.dot'\n    try:\n        temp_dot_file = open(temp_dot_filename, 'w')\n    except:\n        home_dir = os.environ.get(\"HOME\")\n        temp_dot_filename = '%s/_temp.dot' % home_dir\n        try:\n            temp_dot_file = open(temp_dot_filename, 'w')\n        except Exception as e:\n            show_error_dialog('Failed to open temp dot file %s for writing' % temp_dot_filename, exception=e)\n            return None\n    temp_dot_file.write('digraph G {\\n\\tnode [shape=record,style=filled,labeljust=c,height=0.2];\\n')\n    try:\n        with open(dot_filename, 'r') as dot_file:\n            contents = dot_file.read()\n            try:\n                dot_code = bytes(contents, 'utf-8')\n            except:\n                dot_code = contents\n            parser = STATDotParser(dot_code)\n            parser.parse()\n            for i, attr in enumerate(parser.graph_attrs.keys()):\n                if i == 0:\n                    temp_dot_file.write('\\tgraph [')\n                else:\n                    temp_dot_file.write(', ')\n                temp_dot_file.write('%s=\"%s\"' %(attr, parser.graph_attrs[attr]))\n                if i == len(parser.graph_attrs.keys()) - 1:\n                    temp_dot_file.write('];\\n')\n            for node in parser.nodes:\n                id, attrs = node\n                attrs[\"label\"] = node_attr_to_label(attrs, False)\n                output_line = '\\t%s [' % id\n                for key in attrs.keys():\n                    if key == 'function' or key == 'label':\n                        if attrs[key].find('{') != -1:\n                            attrs[key] = attrs[key].replace('{', '\\{').replace('}', '\\}')\n                    if key == 'label':\n                        label = escaped_label(attrs[key])\n                        original_label = label\n                        final_label = ''\n                        label_lines = label.split('\\\\n')\n                        for i, label in enumerate(label_lines):\n                            if len(label) > max_node_name and truncate == \"front\":\n                                # clip long node names at the front (preserve most significant characters)\n                                if label[2 - max_node_name] == '\\\\':\n                                    label = '...\\\\%s' % label[3 - max_node_name:]\n                                else:\n                                    label = '...%s' % label[3 - max_node_name:]\n                            if len(label) > max_node_name and truncate == \"rear\":\n                                # clip long node names at the rear (preserve least significant characters)\n                                if label[max_node_name - 1] == '\\\\':\n                                    label = '%s' % label[:max_node_name - 2]\n                                else:\n                                    label = '%s...' % label[:max_node_name - 3]\n                            final_label += label\n                            if i != len(label_lines) - 1:\n                                final_label += '\\\\n'\n                        output_line += '%s=\"%s\",' % (key, final_label)\n                    else:\n                        output_line += '%s=\"%s\",' % (key, attrs[key])\n                output_line += 'originallabel=\"%s\"];\\n' % original_label\n                temp_dot_file.write(output_line)\n            for edge in parser.edges:\n                src_id, dst_id, attrs = edge\n                attrs[\"label\"] = edge_attr_to_label(attrs)\n                output_line = '\\t%s -> %s [' % (src_id, dst_id)\n                for key in attrs.keys():\n                    if key == 'label':\n                        if attrs[\"label\"] == '':\n                            pass\n                        original_label = attrs[\"label\"]\n                        label = get_truncated_edge_label(attrs)\n                        output_line += '%s=\"%s\",' % (key, label)\n                    else:\n                        output_line += '%s=\"%s\",' % (key, attrs[key])\n                output_line += 'originallabel=\"%s\"]\\n' % original_label\n                temp_dot_file.write(output_line)\n    except IOError as e:\n        show_error_dialog('Failed to open dot file %s' % dot_filename, exception=e)\n        return None\n    except Exception as e:\n        show_error_dialog('Failed to create temporary dot file %s\\n %s' % (dot_filename, repr(e)), exception=e)\n        return None\n    finally:\n        temp_dot_file.write('}\\n')\n        temp_dot_file.close()\n\n    return temp_dot_filename\n\n\n## \\param file_dir - the .dot file directory\n## \\param source - the source file name\n#  \\return the cache file path\n#\n#  \\n\ndef get_cache_file_path(file_dir, source):\n    cache_directory_path = os.path.abspath(os.path.join(file_dir, cache_directory))\n    cache_file_path = cache_directory_path + '/' + source\n    return cache_file_path\n\n\n## \\param current_graph - the currently opened graph object\n#  \\return directory and filename of the current graph's .dot file\n#\n#  \\n\ndef dot_file_path_split(current_graph):\n    file_path = current_graph.cur_filename\n    if file_path is None or file_path == '':\n        return (None, None)\n    elif file_path == 'redraw.dot':\n        return (None, None)\n    file_dir, file_name = os.path.split(file_path)\n    return (file_dir, file_name)\n\ndef run_gtk_main_loop(iters = 100):\n    iter = 0\n    while gtk.events_pending() and iter < iters:\n        iter += 1\n        try:\n            gtk.main_iteration(False)\n        except:\n            gtk.main_iteration()\n\n\nclass CellRendererButtonPixbuf(gtk.CellRendererPixbuf):\n    __gproperties__ = {\"callable\": (gobject.TYPE_PYOBJECT, \"callable property\", \"callable property\", gobject.PARAM_READWRITE)}\n    _button_width = 20\n    _button_height = 30\n\n    def __init__(self):\n        if hasattr(self, '__gobject_init__'):\n            self.__gobject_init__()\n        gtk.CellRendererPixbuf.__init__(self)\n        self.set_property(\"xalign\", 0.5)\n        self.set_property(\"mode\", gtk.CELL_RENDERER_MODE_ACTIVATABLE)\n        self.callable = None\n        self.table = None\n\n    def do_set_property(self, pspec, value):\n        if pspec.name == \"callable\":\n            if callable(value):\n                self.callable = value\n            else:\n                raise TypeError(\"callable property must be callable!\")\n        else:\n            raise AttributeError(\"Unknown property %s\" % pspec.name)\n\n    def do_get_property(self, pspec):\n        if pspec.name == \"callable\":\n            return self.callable\n        else:\n            raise AttributeError(\"Unknown property %s\" % pspec.name)\n\n    def do_get_size(self, wid, cell_area):\n        xpad = self.get_property(\"xpad\")\n        ypad = self.get_property(\"ypad\")\n        if not cell_area:\n            x, y = 0, 0\n            w = 2 * xpad + self._button_width\n            h = 2 * ypad + self._button_height\n        else:\n            w = 2 * xpad + cell_area.width\n            h = 2 * ypad + cell_area.height\n            xalign = self.get_property(\"xalign\")\n            yalign = self.get_property(\"yalign\")\n            x = max(0, xalign * (cell_area.width - w))\n            y = max(0, yalign * (cell_area.height - h))\n        return (x, y, w, h)\n\n    def do_activate(self, event, wid, path, bg_area, cell_area, flags):\n        cb = self.get_property(\"callable\")\n        if cb is not None:\n            cb(path)\n        return True\n\n\nclass CellRendererButtonText(gtk.CellRendererText):\n    __gproperties__ = {\"callable\": (gobject.TYPE_PYOBJECT, \"callable property\", \"callable property\", gobject.PARAM_READWRITE)}\n    _button_width = 40\n    _button_height = 30\n\n    def __init__(self):\n        self.__gobject_init__()\n        gtk.CellRendererText.__init__(self)\n        self.set_property(\"xalign\", 0.5)\n        self.set_property(\"mode\", gtk.CELL_RENDERER_MODE_ACTIVATABLE)\n        self.callable = None\n        self.table = None\n\n    def do_set_property(self, pspec, value):\n        if pspec.name == \"callable\":\n            if callable(value):\n                self.callable = value\n            else:\n                raise TypeError(\"callable property must be callable!\")\n        else:\n            raise AttributeError(\"Unknown property %s\" % pspec.name)\n\n    def do_get_property(self, pspec):\n        if pspec.name == \"callable\":\n            return self.callable\n        else:\n            raise AttributeError(\"Unknown property %s\" % pspec.name)\n\n    def do_get_size(self, wid, cell_area):\n        xpad = self.get_property(\"xpad\")\n        ypad = self.get_property(\"ypad\")\n        if not cell_area:\n            x, y = 0, 0\n            w = 2 * xpad + self._button_width\n            h = 2 * ypad + self._button_height\n        else:\n            w = 2 * xpad + cell_area.width\n            h = 2 * ypad + cell_area.height\n            xalign = self.get_property(\"xalign\")\n            yalign = self.get_property(\"yalign\")\n            x = max(0, xalign * (cell_area.width - w))\n            y = max(0, yalign * (cell_area.height - h))\n        return (x, y, w, h)\n\n    def do_activate(self, event, wid, path, bg_area, cell_area, flags):\n        cb = self.get_property(\"callable\")\n        if cb is not None:\n            cb(path)\n        return True\n\n\n## STAT GUI's wait dialog.\nclass STAT_wait_dialog(object):\n    \"\"\"STAT GUI's wait dialog.\n\n    List subtasks with progress/activity bars and overall progress.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"The constructor\"\"\"\n        self.tasks = []\n        self.task_progress_bars = []\n        self.current_task = 0\n        self.wait_dialog = None\n        self.cancelled = False\n        self.timer = None\n        self.progress_bar = None\n\n    ## \\param self - the instance\n    #  \\param fun - the function to run\n    #  \\param args - the argument list for the function\n    #  \\param task_list - [optional] the list of subtasks\n    #  \\param parent - [optional] the parent dialog\n    #  \\param cancelable - [optional] whether to allow a cancel action\n    #  \\return the return value of the function that was run\n    #\n    #  \\n\n    def show_wait_dialog_and_run(self, fun, args, task_list=[], parent=None, cancelable=False):\n        \"\"\"Display a wait dialog and run the specified function.\n\n        Note, the specified function should NOT create any new windows or do\n        any drawing, otherwise it will hang.\n        \"\"\"\n        if self.wait_dialog != None:\n            self.wait_dialog.destroy()\n        self.wait_dialog = gtk.Dialog('Please Wait', parent)\n        self.current_task = 0\n        self.tasks = []\n        self.task_progress_bars = []\n        if len(task_list) != 0:\n            self.timer = gobject.timeout_add(75, self.update_active_bar)\n        for task in task_list:\n            task_label = gtk.Label(task)\n            task_label.set_line_wrap(False)\n            hbox = gtk.HBox()\n            hbox.pack_start(task_label, True, False, 0)\n            active_bar = gtk.ProgressBar()\n            active_bar.set_fraction(0.0)\n            self.task_progress_bars.append(active_bar)\n            hbox.pack_start(active_bar, False, False, 5)\n            self.wait_dialog.vbox.pack_start(hbox, True, True, 0)\n        if len(task_list) != 1:\n            if len(task_list) == 0:\n                label = gtk.Label(\"Please Wait...\")\n            else:\n                separator = gtk.HSeparator()\n                self.wait_dialog.vbox.pack_start(separator, False, False, 5)\n                label = gtk.Label(\"Overall Progress\")\n            label.set_line_wrap(False)\n            hbox = gtk.HBox()\n            hbox.pack_start(label, True, False, 0)\n            self.progress_bar = gtk.ProgressBar()\n            self.progress_bar.set_fraction(0.0)\n            hbox.pack_start(self.progress_bar, False, False, 5)\n            self.wait_dialog.vbox.pack_start(hbox, True, True, 0)\n        if cancelable is True:\n            self.wait_dialog.vbox.pack_start(gtk.HSeparator(), False, False, 5)\n            hbox = gtk.HButtonBox()\n            button = gtk.Button(stock=gtk.STOCK_CANCEL)\n            button.connect(\"clicked\", lambda w: self.on_cancel(w))\n            hbox.pack_end(button, False, False, 0)\n            self.wait_dialog.vbox.pack_start(hbox, True, True, 0)\n        self.wait_dialog.show_all()\n        ret = self.run_and_destroy_wait_dialog(fun, (args), parent)\n        return ret\n\n    def on_cancel(self, widget):\n        \"\"\"Callback to handle clicking of cancel button.\"\"\"\n        self.cancelled = True\n\n    def destroy(self):\n        if self.wait_dialog is not None:\n            self.wait_dialog.destroy()\n            self.wait_dialog = None\n\n    ## \\param self - the instance\n    #  \\param fun - the function to run\n    #  \\param args - the tuple arguments for the \\a fun function\n    #  \\param parent - [optional] the parent dialog\n    #  \\return the return value of the function that was run\n    #\n    #  \\n\n    def run_and_destroy_wait_dialog(self, fun, args, parent=None):\n        \"\"\"Run the specified command and destroy any pending wait dialog.\"\"\"\n        try:\n            ret = fun(*args)\n        except Exception as e:\n            ret = False\n            show_error_dialog('Unexpected error:  %s\\n%s\\n%s\\n' % (sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]), exception=e)\n        if len(self.task_progress_bars) != 0:\n            gobject.source_remove(self.timer)\n        self.destroy()\n        return ret\n\n    ## \\param self - the instance\n    #  \\param fraction - the new fraction\n    #\n    #  \\n\n    def update(self, fraction):\n        \"\"\"Mark the current task as complete and advance to the next task.\"\"\"\n        if self.current_task >= len(self.task_progress_bars):\n            return True\n        self.task_progress_bars[self.current_task].set_fraction(1.0)\n        self.current_task += 1\n        self.progress_bar.set_fraction(fraction)\n        run_gtk_main_loop()\n\n    ## \\param self - the instance\n    #  \\param fraction - the new fraction\n    #\n    #  \\n\n    def update_progress_bar(self, fraction):\n        \"\"\"Update the fraction of the progress bar.\"\"\"\n        self.progress_bar.set_fraction(fraction)\n        run_gtk_main_loop()\n\n    def update_active_bar(self):\n        \"\"\"Register activity on the active bar.\"\"\"\n        if self.current_task >= len(self.task_progress_bars):\n            return True\n        self.task_progress_bars[self.current_task].pulse()\n        return True\n\n## The globally available STAT wait dialog\nstat_wait_dialog = STAT_wait_dialog()\n\n\n## \\param text - the error text\n#  \\param parent - [optional] the parent dialog\n#  \\param exception - [optional] the exception object\n#\n#  \\n\ndef show_error_dialog(text, parent=None, exception=None):\n    \"\"\"Display an error dialog.\"\"\"\n\n    # print traceback information to the terminal\n    if exception is not None:\n        traceback.print_exc()\n\n    # create error dialog with error message\n    if parent == None:\n        global window\n        parent = window\n    error_dialog = gtk.Dialog('Error', parent)\n    label = gtk.Label(text)\n    label.set_line_wrap(True)\n    error_dialog.vbox.pack_start(label, True, True, 0)\n    button = gtk.Button(stock=gtk.STOCK_OK)\n    button.connect(\"clicked\", lambda w, d: error_dialog.destroy(), \"ok\")\n    error_dialog.vbox.pack_start(button, True, True, 0)\n    error_dialog.show_all()\n    error_dialog.run()\n\n\ndef load_model_cuts(filename):\n    models = {}\n    models_case_sensitive = {}\n    model_name = None\n    try:\n        with open(filename, 'r') as model_file:\n            for line in model_file:\n                line = line.strip('\\n')\n                if line == '':\n                    continue\n                if line[0] == '#':\n                    continue\n                if line.find(\"model =\") == 0 or line.find(\"model=\") == 0:\n                    model_name = line[line.find('\"') + 1:line.rfind('\"')]\n                    line = line[line.rfind('\"') + 1:].split()\n                    case_sensitive = line[0].lower()\n                    models[model_name] = ''\n                    models_case_sensitive[model_name] = False\n                    if case_sensitive == \"true\":\n                        models_case_sensitive[model_name] = True\n                    continue\n                if model_name is not None:\n                    models[model_name] += line + ';'\n    except IOError as e:\n        #sys.stderr.write('%s\\nfailed to open models file %s\\n' % (repr(e), filename))\n        pass\n    except Exception as e:\n        traceback.print_exc()\n        sys.stderr.write('%s\\nfailed to process models file %s\\n' % (repr(e), filename))\n    model_list = []\n    for model in models:\n        # toggled, name, case sensitive, regexs, editable, not editable\n        model_list.append([False, model, models_case_sensitive[model], models[model], False, True])\n    return model_list\n\n\ndef re_search(function_name, search_text_and_match_case):\n    search_text, match_case = search_text_and_match_case\n    \"\"\"Function to test whether a search string matches a re\"\"\"\n    if match_case is False:\n        search_text = string.lower(search_text)\n        function_name = string.lower(function_name)\n    if re.search(search_text, function_name) is not None:\n        return True\n    return False\n\n\n## Overloaded DragAction for use with scroll bars.\nclass STATPanAction(xdot_ui_actions.DragAction):\n    \"\"\"Overloaded DragAction for use with scroll bars.\"\"\"\n\n    def drag(self, deltax, deltay):\n        \"\"\"Update the scroll bars.\"\"\"\n        if use_scroll_bars:\n            if hasattr(self, 'last_deltax') and hasattr(self, 'last_deltay'):\n                deltax = deltax + self.last_deltax\n                deltay = deltay + self.last_deltay\n            self.last_deltax = deltax\n            self.last_deltay = deltay\n            x = self.dot_widget.hadj.get_value()\n            y = self.dot_widget.vadj.get_value()\n            rect = self.dot_widget.get_allocation()\n            allocation = self.dot_widget.dotsw.get_allocation()\n            hspan = allocation[2]\n            x += deltax\n            if x < 0:\n                x = 0\n            elif x + hspan > rect.width:\n                x = rect.width - hspan\n            self.dot_widget.dotsw.get_hscrollbar().emit('change-value', gtk.SCROLL_JUMP, x)\n            vspan = allocation[3]\n            y += deltay\n            if y < 0:\n                y = 0\n            elif y + vspan > rect.height:\n                y = rect.height - vspan\n            self.dot_widget.dotsw.get_vscrollbar().emit('change-value', gtk.SCROLL_JUMP, y)\n        else:\n            xdot_ui_actions.DragAction.drag(self, deltax, deltay)\n\n\n## A shape composed of multiple sub shapes.\nclass STATCompoundShape(xdot_ui_elements.CompoundShape):\n    \"\"\"A shape composed of multiple sub shapes.\n\n    Adds a hide attribute to the CompoundShape class.\n    \"\"\"\n\n    def __init__(self, shapes):\n        \"\"\"The constructor\"\"\"\n        xdot_ui_elements.CompoundShape.__init__(self, shapes)\n        self.hide = False\n\n    def draw(self, cr, highlight=False):\n        \"\"\"Draw the compound shape if not hidden.\n\n        Hidden shapes are not completely hidden, rather they are made opaque.\n        \"\"\"\n        a_val = 1.0\n        if self.hide is True:\n            a_val = 0.07\n        for shape in self.shapes:\n            color = shape.pen.color\n            r, g, b, p = color\n            shape.pen.color = (r, g, b, a_val)\n            color = shape.pen.fillcolor\n            r, g, b, p = color\n            shape.pen.fillcolor = (r, g, b, a_val)\n        xdot_ui_elements.CompoundShape.draw(self, cr, highlight)\n\n\n## A new object to gather the edge label.\nclass EdgeLabel(object):\n    \"\"\"A new object to gather the edge label.\"\"\"\n\n    def __init__(self, item, edge_label, highlight=None):\n        \"\"\"The constructor\"\"\"\n        self.item = item\n        self.edge_label = edge_label\n        if highlight is None:\n            highlight = set([item])\n        self.highlight = highlight\n\n\n## A new object to gather the node label.\nclass Label(object):\n    \"\"\"A new object to gather the node label.\"\"\"\n\n    def __init__(self, item, label, highlight=None):\n        \"\"\"The constructor\"\"\"\n        self.item = item\n        if highlight is None:\n            highlight = set([item])\n        self.highlight = highlight\n\n\n## The base class for STAT graph nodes and edges.\nclass STATElement(STATCompoundShape):\n    \"\"\"The base class for STAT graph nodes and edges.\"\"\"\n\n    def __init__(self, shapes):\n        \"\"\"The constructor\"\"\"\n        STATCompoundShape.__init__(self, shapes)\n\n    def get_edge_label(self, x, y):\n        \"\"\"Get the edge label (should be overloaded by derrived class).\"\"\"\n        return None\n\n    def get_label(self, x, y):\n        \"\"\"Get the label (should be overloaded by derrived class).\"\"\"\n        return None\n\n    def get_jump(self, x, y):\n        \"\"\"Get the jump (should be overloaded by derrived class).\"\"\"\n        return None\n\n    def draw(self, cr, highlight=False):\n        \"\"\"Draw the object.\"\"\"\n        STATCompoundShape.draw(self, cr, highlight)\n\n\n## A node in the STAT graph.\nclass STATNode(STATElement):\n    \"\"\"A node in the STAT graph.\n\n    Derrived from the STATElement to include the hide attribute.\n    It adds several STAT specific members to the xdot Node class.\n    \"\"\"\n\n    def __init__(self, x, y, x1, y1, x2, y2, shapes, label, attrs):\n        \"\"\"The constructor\"\"\"\n        STATElement.__init__(self, shapes)\n        self.x = x\n        self.y = y\n        self.x1 = x1\n        self.y1 = y1\n        self.x2 = x2\n        self.y2 = y2\n        self.attrs = {}\n        for key in attrs:\n            try:\n                self.attrs[key] = attrs[key].decode('utf-8')\n            except:\n                self.attrs[key] = attrs[key]\n        try:\n            label = label.decode('utf-8')\n        except:\n            pass\n        self.attrs[\"label\"] = label\n        self.source_dir = None\n        self.edge_label = None\n        self.edge_label_id = -2\n        self.hide = False\n        self.in_edge = None\n        self.out_edges = []\n        self.node_name = None\n        self.num_tasks = -1\n        self.num_leaf_tasks = -1\n        self.undo = []\n        self.redo = []\n        self.is_leaf = False\n        self.depth = -1\n        self.eq_depth = -1\n        self.to_color_index = -1\n        self.temporally_ordered = False\n\n    def __repr__(self):\n        ret = \"STAT Node:\\n\"\n        ret += \"node_name(%s)\\n\" % self.node_name\n        ret += \"edge_label(%d: %s)\\n\" % (self.edge_label_id, self.edge_label)\n        ret += \"hide(%s)\\n\" % str(self.hide)\n        ret += \"num_tasks(%d)\\n\" % self.num_tasks\n        ret += \"attrs:\\n\"\n        for key in self.attrs.keys():\n            ret += \"\\tattrs[%s] = %s\\n\" % (key, self.attrs[key])\n        ret += \"\\nin_edge:\\n%s\\n\" % str(self.in_edge)\n        for edge in self.out_edges:\n            ret += \"\\nout_edge:\\n%s\\n\" % str(edge)\n        return ret\n\n    def is_inside(self, x, y):\n        \"\"\"Determine if the specified coordinates are in this node.\"\"\"\n        return self.x1 <= x and x <= self.x2 and self.y1 <= y and y <= self.y2\n\n    def get_label(self, x, y):\n        \"\"\"Get the node's label.\"\"\"\n        if self.attrs[\"label\"] is None:\n            return None\n        if self.is_inside(x, y):\n            return Label(self, self.attrs[\"label\"])\n        return None\n\n    def get_url(self, x, y):\n        \"\"\"Dummy function to satisfy xdot motion notify.\"\"\"\n        return None\n\n    def get_edge_label(self, x, y):\n        \"\"\"Get the node's incoming edge label.\"\"\"\n        if self.edge_label is None:\n            return None\n        if self.is_inside(x, y):\n            return EdgeLabel(self, self.edge_label)\n        return None\n\n    def get_jump(self, x, y):\n        \"\"\"Get the jump object if specified coordintes are in the node.\"\"\"\n        if self.hide is True:\n            return None\n        if self.is_inside(x, y):\n            return xdot_ui_elements.Jump(self, self.x, self.y)\n        return None\n\n    def draw(self, cr, highlight=False):\n        \"\"\"Draw the node.\"\"\"\n        STATElement.draw(self, cr, highlight)\n\n    def get_text(self):\n        \"\"\"Return the text shape for the node.\"\"\"\n        for shape in self.shapes:\n            if isinstance(shape, xdot_ui_elements.TextShape):\n                return shape.t\n        return ''\n\n    def set_text(self, text):\n        \"\"\"Set the text for the text shape of this node.\"\"\"\n        for shape in self.shapes:\n            if isinstance(shape, xdot_ui_elements.TextShape):\n                shape.t = text\n                try:\n                    shape.layout.set_text(text)\n                except:\n                    pass\n                return True\n        return False\n\n    #  \\return the task list\n    #\n    #  \\n\n    def get_node_task_list(self):\n        \"\"\"Get the task list corresponding to the node's edge label.\n\n        First see if we have this label indexed to avoid duplicate generation.\"\"\"\n\n        if self.edge_label_id in task_label_id_to_list:\n            return task_label_id_to_list[self.edge_label_id]\n        ret = get_task_list(self.edge_label)\n        if self.edge_label != '' and self.edge_label[0] == '[': # not the head node and not count + rep\n            self.edge_label_id = task_label_to_id[self.edge_label]\n        return get_task_list(self.edge_label)\n\n    #  \\return the task list\n    #\n    #  \\n\n    def get_leaf_tasks(self):\n        \"\"\"Get the list of tasks that ended on this node.\"\"\"\n        in_set = set(self.get_node_task_list())\n        out_set = set([])\n        for edge in self.out_edges:\n            out_set |= set(edge.dst.get_node_task_list())\n        return sorted(list(in_set - out_set))\n\n    #  \\return the task count\n    #\n    #  \\n\n    def get_num_leaf_tasks(self):\n        \"\"\"Get the number of tasks that ended on this node.\"\"\"\n        if self.num_leaf_tasks == -1:\n            out_sum = 0\n            for edge in self.out_edges:\n                out_sum += get_num_tasks(edge.attrs[\"label\"])\n            num_tasks = get_num_tasks(self.edge_label)\n            if out_sum < num_tasks:\n                self.num_leaf_tasks = num_tasks - out_sum\n            else:\n                self.num_leaf_tasks = 0\n        return self.num_leaf_tasks\n\n    #  \\return the task count\n    #\n    #  \\n\n    def get_num_visual_leaf_tasks(self):\n        \"\"\"Get the number of tasks that ended on this node.\"\"\"\n        out_sum = 0\n        for edge in self.out_edges:\n            if edge.hide is False:\n                out_sum += get_num_tasks(edge.attrs[\"label\"])\n        num_tasks = get_num_tasks(self.edge_label)\n        if out_sum < num_tasks:\n            return num_tasks - out_sum\n        else:\n            return 0\n\n    def can_join_eq_c(self):\n        if self.hide is True:\n            return False\n        ret = False\n        if len(self.out_edges) == 1 and self.in_edge is not None:\n            if self.out_edges[0].attrs[\"label\"] == self.in_edge.attrs[\"label\"] and self.out_edges[0].hide is False:\n                ret = True\n        return ret\n\n\n## An edge in the STAT graph.\nclass STATEdge(STATElement):\n    \"\"\"An edge in the STAT graph.\n\n    Derrived from the STATElement to include the hide attribute.\n    It adds several STAT specific members to the xdot Edge class.\n    \"\"\"\n\n    def __init__(self, src, dst, points, shapes, label, attrs):\n        \"\"\"The constructor.\"\"\"\n        STATElement.__init__(self, shapes)\n        self.src = src\n        self.dst = dst\n        self.points = points\n        self.attrs = {}\n        for key in attrs:\n            try:\n                self.attrs[key] = attrs[key].decode('utf-8')\n            except:\n                self.attrs[key] = attrs[key]\n        self.attrs[\"label\"] = label\n        self.hide = False\n        self.undo = []\n        self.redo = []\n\n    RADIUS = 10\n\n    def __repr__(self):\n        ret = \"STATEdge:\\n\"\n        try:\n            ret += \"src(%s)\\n\" % str(self.src.attrs[\"label\"])\n        except:\n            ret += \"src(?)\\n\"\n        try:\n            ret += \"dst(%s)\\n\" % str(self.dst.attrs[\"label\"])\n        except:\n            ret += \"dst(%s)\\n\" % str(self.dst.attrs[\"label\"])\n        ret += \"hide(%s)\\n\" % str(self.hide)\n        ret += \"attrs:\\n\"\n        for key in self.attrs.keys():\n            ret += \"\\tattrs[%s] = %s\\n\" % (key, self.attrs[key])\n        return ret\n\n    def get_jump(self, x, y):\n        \"\"\"Get the jump object if specified coordintes are in the edge.\"\"\"\n        if xdot_ui_elements.square_distance(x, y, *self.points[0]) <= self.RADIUS*self.RADIUS:\n            return xdot_ui_elements.Jump(self, self.dst.x, self.dst.y, highlight=set([self, self.dst]))\n        if xdot_ui_elements.square_distance(x, y, *self.points[-1]) <= self.RADIUS*self.RADIUS:\n            return xdot_ui_elements.Jump(self, self.src.x, self.src.y, highlight=set([self, self.dst]))\n        return None\n\n\n## A STAT graph object.\nclass STATGraph(xdot_ui_elements.Graph):\n    \"\"\"A STAT graph object.\n\n    Derrived from xdot's Graph class and adds several STAT specific\n    operations for tree manipulation and traversal.\n    \"\"\"\n\n    def __init__(self, width=1, height=1, shapes=(), nodes=(), edges=()):\n        \"\"\"The constructor.\"\"\"\n        xdot_ui_elements.Graph.__init__(self, width, height, shapes, nodes, edges)\n        for node in self.nodes:\n            if self.is_leaf(node):\n                node.is_leaf = True\n            node.depth = self.get_node_depth(node)\n            node.eq_depth = self.get_node_eq_depth(node)\n        self.action_history = []\n        self.undo_action_history = []\n        self.cur_filename = ''\n        self.to_var_visit_list = []\n        self.source_view_window = None\n        self.source_view_notebook = None\n        self.source_view_tabs = []\n\n    def get_node(self, x, y):\n        \"\"\"Get the node that the specified coordinates fall into.\"\"\"\n        for node in self.nodes:\n            if node.is_inside(x, y):\n                return node\n        return None\n\n    def get_edge_label(self, x, y):\n        \"\"\"Get the edge label of the node that the coordinates fall into.\"\"\"\n        for node in self.nodes:\n            edge_label = node.get_edge_label(x, y)\n            if edge_label is not None:\n                return edge_label\n        return None\n\n    def get_label(self, x, y):\n        \"\"\"Get the label of the node that the coordinates fall into.\"\"\"\n        for node in self.nodes:\n            if not hasattr(node, \"get_label\"):\n                return None\n            label = node.get_label(x, y)\n            if label is not None:\n                return label\n        return None\n\n    def set_undo_list(self):\n        \"\"\"Save modifiable node attributes to a list for undo operations.\"\"\"\n        for node in self.nodes:\n            node_text = node.get_text()\n            node.undo.append((node.hide, node_text, node.to_color_index, node.attrs.get(\"lex_string\"), node.temporally_ordered))\n            node.redo = []\n        for edge in self.edges:\n            edge_colors = []\n            for shape in edge.shapes:\n                r, g, b, p = shape.pen.color\n                r2, g2, b2, p2 = shape.pen.fillcolor\n                edge_colors.append((r, g, b, p, r2, g2, b2, p2))\n            edge.undo.append((edge.hide, edge_colors))\n            edge.redo = []\n\n    def undo(self, update_redo=True):\n        \"\"\"Undo the modifications of the previous operation.\n\n        Restore previous attributes.\n        \"\"\"\n        if len(self.nodes) == 0:\n            return True\n        if len(self.nodes[0].undo) == 0:\n            return True\n        if update_redo:\n            op = self.action_history.pop()\n            self.undo_action_history.append(op)\n        for node in self.nodes:\n            hide, node_text, to_color_index, lex_string, temporally_ordered = node.undo.pop()\n            old_node_text = node.get_text()\n            node.set_text(node_text)\n            if update_redo:\n                node.redo.append((node.hide, old_node_text, node.to_color_index, node.attrs.get(\"lex_string\"), node.temporally_ordered))\n            node.hide = hide\n            node.to_color_index = to_color_index\n            if lex_string is not None:\n                node.attrs[\"lex_string\"] = lex_string\n            node.temporally_ordered = temporally_ordered\n            if hasattr(node, 'eq_collapsed_out_edges'):\n                del node.eq_collapsed_out_edges\n            if \"eq_collapsed_label\" in node.attrs:\n                del node.attrs[\"eq_collapsed_label\"]\n        for edge in self.edges:\n            edge_colors = []\n            for shape in edge.shapes:\n                r, g, b, p = shape.pen.color\n                r2, g2, b2, p2 = shape.pen.fillcolor\n                edge_colors.append((r, g, b, p, r2, g2, b2, p2))\n            if update_redo:\n                edge.redo.append((edge.hide, edge_colors))\n            if len(edge.undo) > 0:\n                hide, edge_colors = edge.undo.pop()\n            for i in range(len(edge.shapes)):\n                r, g, b, p, r2, g2, b2, p2 = edge_colors[i]\n                edge.shapes[i].pen.color = (r, g, b, p)\n                edge.shapes[i].pen.fillcolor = (r2, g2, b2, p2)\n            edge.hide = hide\n        return True\n\n    def redo(self, widget):\n        \"\"\"Redo the modifications of the previous operation.\n\n        Restore previous undo attributes.\n        \"\"\"\n        if len(self.nodes) == 0:\n            return True\n        if len(self.nodes[0].redo) == 0:\n            return True\n        op = self.undo_action_history.pop()\n        self.action_history.append(op)\n        for node in self.nodes:\n            hide, node_text, to_color_index, lex_string, temporally_ordered = node.redo.pop()\n            old_node_text = node.get_text()\n            node.set_text(node_text)\n            node.undo.append((node.hide, old_node_text, node.to_color_index, node.attrs.get(\"lex_string\"), node.temporally_ordered))\n            node.hide = hide\n            node.to_color_index = to_color_index\n            if lex_string is not None:\n                node.attrs[\"lex_string\"] = lex_string\n            node.temporally_ordered = temporally_ordered\n        for edge in self.edges:\n            shapes = []\n            for shape in edge.shapes:\n                r, g, b, p = shape.pen.color\n                r2, g2, b2, p2 = shape.pen.fillcolor\n                shapes.append((r, g, b, p, r2, g2, b2, p2))\n            edge.undo.append((edge.hide, shapes))\n            hide, shapes = edge.redo.pop()\n            for i in range(len(edge.shapes)):\n                r, g, b, p, r2, g2, b2, p2 = shapes[i]\n                edge.shapes[i].pen.color = (r, g, b, p)\n                edge.shapes[i].pen.fillcolor = (r2, g2, b2, p2)\n            edge.hide = hide\n        return True\n\n    def expand(self, node):\n        \"\"\"Show any children nodes of the specified node.\"\"\"\n        modified = False\n        if node is None:\n            return False\n        for edge in node.out_edges:\n            if edge.dst.hide is True:\n                edge.dst.hide = False\n                modified = True\n            edge.hide = False\n        return modified\n\n    def collapse(self, node, orig=False):\n        \"\"\"Hide any children nodes of the specified node.\"\"\"\n        modified = False\n        if node is None:\n            return False\n        if orig is False:\n            if node.hide is False:\n                node.hide = True\n                modified = True\n        if node.in_edge is not None and orig is False:\n            if node.in_edge.hide is False:\n                node.in_edge.hide = True\n                modified = True\n        for edge in node.out_edges:\n            edge.hide = True\n            ret = self.collapse(edge.dst)\n            if ret is True:\n                modified = True\n        return modified\n\n    def collapse_depth(self, node):\n        \"\"\"Hide all nodes below the depth of the specified node.\"\"\"\n        modified = False\n        if node is None:\n            return False\n        for cnode in self.nodes:\n            if cnode.depth == node.depth:\n                ret = self.collapse(cnode, True)\n                if ret is True:\n                    modified = True\n        return modified\n\n    def join_eq_c(self, node, root=False):\n        \"\"\"Collapse descendent nodes of the same eq class into a single node.\"\"\"\n        modified = False\n        if node is None or node.hide is True:\n            return False, (None, {})\n        if not node.can_join_eq_c():\n            node.hide = True\n            node.in_edge.hide = True\n            return True, (node, node.attrs)\n        modified, (leaf_node, attrs) = self.join_eq_c(node.out_edges[0].dst)\n        if root is True:\n            #node.out_edges[0].hide\n            node.eq_collapsed_out_edges = []\n            if leaf_node is not None:\n                for edge in leaf_node.out_edges:\n                    new_edge = STATEdge(node, edge.dst, edge.points, edge.shapes, edge.attrs[\"label\"], edge.attrs)\n                    new_edge.hide = edge.hide\n                    edge.hide = True\n                    node.eq_collapsed_out_edges.append(new_edge)\n                    new_edge.dst.eq_collapsed_in_edge = new_edge\n                    self.edges.append(new_edge)\n                node.attrs[\"eq_collapsed_label\"] = node.attrs[\"label\"] + '\\\\n' + attrs[\"label\"]\n        else:\n            node.hide = True\n            node.in_edge.hide = True\n        for attr in [\"label\", \"function\", \"source\", \"line\", \"module\", \"offset\", \"pc\", \"vars\"]:\n            if attr in node.attrs:\n                node.attrs[attr] = node.attrs[attr] + '\\\\n' + attrs[attr]\n        return modified, (leaf_node, node.attrs)\n\n    def expand_all(self, node):\n        \"\"\"Show all descendents of the specified node.\"\"\"\n        modified = False\n        if node is None:\n            return False\n        if node.hide is True:\n            node.hide = False\n            modified = True\n        if node.in_edge is not None:\n            node.in_edge.hide = False\n        for edge in node.out_edges:\n            edge.hide = False\n            ret = self.expand_all(edge.dst)\n            if ret is True:\n                modified = True\n        return modified\n\n    def visible_children(self, node):\n        \"\"\"Find all visible (not hidden) children of the specified node.\"\"\"\n        ret_nodes = []\n        ret_edges = []\n        if node is not None:\n            if node.hide is False:\n                ret_nodes.append(node)\n                if node.in_edge is not None:\n                    ret_edges.append(node.in_edge)\n            for edge in node.out_edges:\n                if edge.hide is False:\n                    n, e = self.visible_children(edge.dst)\n                    ret_nodes += n\n                    ret_edges += e\n        return ret_nodes, ret_edges\n\n    def focus(self, node):\n        \"\"\"Focus on a node\n\n        Hide all nodes that are neither descendents nor ancestors of the\n        specified node.\n        \"\"\"\n        if node is None:\n            return False\n        show_nodes, show_edges = self.visible_children(node)\n        num_hidden_nodes = 0\n        for temp in self.nodes:\n            if temp.hide is True:\n                num_hidden_nodes += 1\n            temp.hide = True\n        for temp in self.edges:\n            temp.hide = True\n        temp_node = node\n        while 1:\n            temp_node.hide = False\n            if temp_node.in_edge is not None:\n                temp_node.in_edge.hide = False\n                temp_node = temp_node.in_edge.src\n            else:\n                break\n        for temp in show_nodes:\n            temp.hide = False\n        for temp in show_edges:\n            temp.hide = False\n        num_hidden_nodes2 = 0\n        for temp in self.nodes:\n            if temp.hide is True:\n                num_hidden_nodes2 += 1\n        if num_hidden_nodes == num_hidden_nodes2:\n            return False\n        else:\n            return True\n\n    def view_source(self, node, item=0):\n        \"\"\"Generate a window that displays the source code for the node.\"\"\"\n        # find the source file name and line number\n        if not \"source\" in node.attrs.keys():\n            show_error_dialog('Cannot determine source file, please run STAT with the -i option to get source file and line number information\\n')\n            return\n        if node.attrs[\"source\"] == \"(null)\" or node.attrs[\"source\"] == \"?\":\n            show_error_dialog('Cannot determine source file, please run STAT with the -i option to get source file and line number information\\n')\n            return\n\n        source = node.attrs[\"source\"].split('\\\\n')[item]\n        cur_line_num = int(node.attrs[\"line\"].split('\\\\n')[item].strip(\":\"))\n\n        # get the node font and background colors\n        for shape in node.shapes:\n            if isinstance(shape, xdot_ui_elements.TextShape):\n                font_color = shape.pen.color\n            else:\n                fill_color = shape.pen.fillcolor\n        font_color_string = color_to_string(font_color)\n        fill_color_string = color_to_string(fill_color)\n\n        # find all nodes that are in this source file\n        line_nums = []\n        line_nums.append((cur_line_num, fill_color_string, font_color_string))\n        for node_iter in self.nodes:\n            if not \"source\" in node_iter.attrs:\n                continue\n            sources = node_iter.attrs[\"source\"].split('\\\\n')\n            for i, this_source in enumerate(sources):\n                if this_source in [\"(null)\", \"?\"]:\n                    continue\n                if this_source == source:\n                    for shape in node_iter.shapes:\n                        if isinstance(shape, xdot_ui_elements.TextShape):\n                            font_color = shape.pen.color\n                        else:\n                            fill_color = shape.pen.fillcolor\n                    font_color_string = color_to_string(font_color)\n                    fill_color_string = color_to_string(fill_color)\n                    line_nums.append((int(node_iter.attrs[\"line\"].split('\\\\n')[i].strip(\":\")), fill_color_string, font_color_string))\n        error_msg = ''\n        file_dir, file_name = dot_file_path_split(self)\n        source_full_path = None\n        if file_dir is not None and file_name is not None:\n            cache_file_path = get_cache_file_path(file_dir, source)\n            if os.path.exists(cache_file_path):\n                source_full_path = cache_file_path\n        if source_full_path == None:\n            if os.path.isabs(source):\n                if os.path.exists(source):\n                    source_full_path = source\n                else:\n                    error_msg = 'Full path %s does not exist\\n' % source\n            if source_full_path is None:\n                # find the full path to the file\n                source = os.path.basename(source)\n                for sp in search_paths['source']:\n                    if not os.path.exists(sp):\n                        continue\n                    tmp_source_full_path = sp + '/' + source\n                    if os.path.exists(tmp_source_full_path):\n                        source_full_path = tmp_source_full_path\n                        break\n                if source_full_path is None:\n                    show_error_dialog('%sFailed to find file \"%s\" in search paths.  Please add the source file search path for this file\\n' % (error_msg, source))\n                    return True\n\n        # create the source view window\n        if self.source_view_window is None:\n            self.source_view_window = gtk.Window()\n            self.source_view_window.set_default_size(800, 600)\n            self.source_view_window.set_title('Source View %s' % source)\n            self.source_view_window.connect('destroy', self.on_source_view_destroy)\n        if self.source_view_notebook is None:\n            self.source_view_notebook = gtk.Notebook()\n            self.source_view_window.add(self.source_view_notebook)\n        frame = gtk.Frame(label=\"\")\n        source_view = gtk.TextView()\n        source_view.set_wrap_mode(False)\n        source_view.set_editable(False)\n        source_view.set_cursor_visible(False)\n        source_string = ''\n        count = 0\n        source_view.get_buffer().create_tag(\"monospace\", family=\"monospace\")\n        iterator = source_view.get_buffer().get_iter_at_offset(0)\n\n        # determine the max number of ==> pointers so we can make space\n        line_count_map = {}\n        line_num_tuples = []\n        for lineNum, fill_color_string, font_color_string in line_nums:\n            if lineNum in line_count_map:\n                if not (lineNum, fill_color_string, font_color_string) in line_num_tuples:\n                    line_count_map[lineNum] += 1\n            else:\n                line_count_map[lineNum] = 1\n            line_num_tuples.append((lineNum, fill_color_string, font_color_string))\n        max_count = 0\n        for line_count in line_count_map.values():\n            if line_count > max_count:\n                max_count = line_count\n\n        # print the actual text with line nums and ==> arrows\n        try:\n            if HAVE_PYGMENTS:\n                STAThelper.pygments_lines = []\n            with open(source_full_path, 'r') as file:\n                if HAVE_PYGMENTS:\n                    cpp_file_patterns = ['.C', '.cpp', '.c++', '.cc', '.cxx', '.hpp', '.h++', '.hh', '.hxx']\n                    fortran_file_patterns = ['.f', '.F', '.f90', '.F90']\n                    source_extension = os.path.splitext(os.path.basename(source_full_path))[1]\n                    if source_extension in cpp_file_patterns:\n                        pygments.highlight(file.read(), CppLexer(), STATviewFormatter())\n                    elif source_extension in fortran_file_patterns:\n                        pygments.highlight(file.read(), FortranLexer(), STATviewFormatter())\n                    else:  # default to C\n                        pygments.highlight(file.read(), CLexer(), STATviewFormatter())\n                    lines = STAThelper.pygments_lines\n                    source_view.get_buffer().create_tag('bold_tag', weight=pango.WEIGHT_BOLD)\n                    source_view.get_buffer().create_tag('italics_tag', style=pango.STYLE_ITALIC)\n                    source_view.get_buffer().create_tag('underline_tag', underline=pango.UNDERLINE_SINGLE)\n                else:\n                    lines = file.readlines()\n        except IOError as e:\n            show_error_dialog('%s\\nFailed to open file \"%s\"\\n' % (repr(e), source_full_path), exception=e)\n        except Exception as e:\n            show_error_dialog('%s\\nFailed to process source file \"%s\"\\n' % (repr(e), source_full_path), exception=e)\n        width = len(str(len(lines)))\n        cur_line_iter = source_view.get_buffer().get_iter_at_offset(0)\n        cur_line_mark = source_view.get_buffer().create_mark('cur_line', cur_line_iter, True)\n        for line in lines:\n            count += 1\n            line_count = 0\n            line_num_tuples = []\n            if count == cur_line_num:\n                cur_line_iter = source_view.get_buffer().get_iter_at_offset(0)\n                cur_line_iter.set_line(cur_line_num)\n                cur_line_mark = source_view.get_buffer().create_mark('cur_line', cur_line_iter, True)\n            for lineNum, fill_color_string, font_color_string in line_nums:\n                if count == lineNum and not (lineNum, fill_color_string, font_color_string) in line_num_tuples:\n                    line_count += 1\n                    line_num_tuples.append((lineNum, fill_color_string, font_color_string))\n            for i in range(max_count - line_count):\n                source_string = \"   \"\n                source_view.get_buffer().insert_with_tags_by_name(iterator, source_string, \"monospace\")\n            line_num_tuples = []\n            for lineNum, fill_color_string, font_color_string in line_nums:\n                if count == lineNum and not (lineNum, fill_color_string, font_color_string) in line_num_tuples:\n                    foreground = gtk.gdk.color_parse(font_color_string)\n                    background = gtk.gdk.color_parse(fill_color_string)\n                    fore_color_tag = \"color_fore%d%s\" % (lineNum, font_color_string)\n                    try:\n                        source_view.get_buffer().create_tag(fore_color_tag, foreground_gdk=foreground)\n                    except:\n                        pass\n                    back_color_tag = \"color_back%d%s\" % (lineNum, fill_color_string)\n                    try:\n                        source_view.get_buffer().create_tag(back_color_tag, background_gdk=background)\n                    except:\n                        pass\n                    source_string = \"==>\"\n                    source_view.get_buffer().insert_with_tags_by_name(iterator, source_string, fore_color_tag, back_color_tag, \"monospace\")\n                    line_num_tuples.append((lineNum, fill_color_string, font_color_string))\n            if HAVE_PYGMENTS:\n                source_string = \"%0*d| \" % (width, count)\n                source_view.get_buffer().insert_with_tags_by_name(iterator, source_string, \"monospace\")\n                for item in line:\n                    source_string, format_tuple = item\n                    pygments_color, bold, italics, underline = format_tuple\n                    foreground = gtk.gdk.color_parse(pygments_color)\n                    fore_color_tag = \"color_fore%d%s\" % (lineNum, pygments_color)\n                    try:\n                        source_view.get_buffer().create_tag(fore_color_tag, foreground_gdk=foreground)\n                    except:\n                        pass\n                    args = [iterator, source_string, fore_color_tag, \"monospace\"]\n                    if bold:\n                        args.append('bold_tag')\n                    if italics:\n                        args.append('italics_tag')\n                    if underline:\n                        args.append('underline_tag')\n                    source_view.get_buffer().insert_with_tags_by_name(*tuple(args))\n            else:\n                source_string = \"%0*d| \" % (width, count)\n                source_string += line\n                source_view.get_buffer().insert_with_tags_by_name(iterator, source_string, \"monospace\")\n\n        # create the tab label box\n        tab_label_box = gtk.EventBox()\n        label = gtk.Label(os.path.basename(source))\n        tab_label_box.add(label)\n        self.source_view_tabs.append(tab_label_box)\n        tab_label_box.connect('event', self.on_source_tab_clicked, tab_label_box)\n        label.show()\n\n        # add the sw to the notebook and set current page\n        self.source_view_notebook.append_page(frame, tab_label_box)\n        sw = gtk.ScrolledWindow()\n        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n        sw.add(source_view)\n        frame.add(sw)\n        self.source_view_window.show_all()\n        self.source_view_window.present()\n        pages = self.source_view_notebook.get_n_pages()\n        self.source_view_notebook.set_current_page(pages - 1)\n\n        # run iterations to get sw generated so we can scroll\n        run_gtk_main_loop()\n        try:\n            source_view.scroll_to_mark(cur_line_mark, 0.0, True)\n        except:\n            source_view.scroll_to_mark(cur_line_mark, 0.0, True, 0.0, 0.0)\n\n    def on_source_view_destroy(self, action):\n        \"\"\"Clean up source view state.\"\"\"\n        self.source_view_window = None\n        self.source_view_notebook = None\n        self.source_view_tabs = []\n\n    def on_source_tab_clicked(self, widget, event, child):\n        \"\"\"Switch the focus to the clicked tab.\"\"\"\n        if event.type == gtk.gdk.BUTTON_PRESS:\n            n = -1\n            for tab in self.source_view_tabs:\n                n += 1\n                if child == tab:\n                    break\n            self.source_view_notebook.set_current_page(n)\n            if event.button == 3:\n                options = ['Close Tab']\n                menu = gtk.Menu()\n                for option in options:\n                    menu_item = gtk.MenuItem(option)\n                    menu.append(menu_item)\n                    menu_item.connect('activate', self.menu_item_response, option)\n                    menu_item.show()\n                try:\n                    menu.popup(None, None, None, None, event.button, event.time)\n                except:\n                    menu.popup(None, None, None, event.button, event.time)\n\n    def menu_item_response(self, widget, string):\n        \"\"\"Handle tab menu responses.\"\"\"\n        if string == \"Close Tab\":\n            if len(self.source_view_tabs) == 1:\n                self.source_view_window.destroy()\n            else:\n                page = self.source_view_notebook.get_current_page()\n                self.source_view_notebook.remove_page(page)\n                self.source_view_tabs.remove(self.source_view_tabs[page])\n\n    def get_lex(self, node, just_add=False):\n        \"\"\"Generate a lexicographical string for the specified node.\"\"\"\n        if node is None:\n            return False\n        if not has_source_and_not_collapsed(node.attrs[\"label\"]):\n            return False\n        if node.attrs[\"label\"].find('libc_start') != -1:\n            node.attrs[\"lex_string\"] = \"(null)\"\n            return True\n        if is_mpi(node.attrs[\"function\"]):\n            node.attrs[\"lex_string\"] = \"(null)\"\n            return True\n        lex_map_index = node.attrs[\"source\"] + node.attrs[\"line\"]\n        if node.attrs.get(\"lex_string\") is None:\n            if node.attrs[\"source\"] == \"(null)\":\n                return False\n            if lex_map_index in lex_map.keys():\n                lex_string = lex_map[lex_map_index]\n                if lex_string.find('$') != -1 and node.attrs[\"vars\"] != '(null)':\n                    input_val = node.attrs[\"vars\"][node.attrs[\"vars\"].find('=') + 1:]\n                    lex_string = lex_string[:lex_string.find('$')] + input_val + lex_string[lex_string.find(')') + 1:]\n                node.attrs[\"lex_string\"] = lex_string\n                return True\n            source = node.attrs[\"source\"]\n            line = node.attrs[\"line\"].strip(\":\")\n            if os.path.isabs(source):\n                node.source_dir, source = os.path.split(source)\n                node.source_dir += '/'\n            else:\n                found = False\n                for sp in search_paths['source']:\n                    if not os.path.exists(sp):\n                        continue\n                    if os.path.exists(sp + '/' + source):\n                        found = True\n                        break\n                if found is False:\n                    show_error_dialog('Failed to find file \"%s\" in search paths.  Please add the source file search path for this file\\n' % source)\n                    return False\n                node.source_dir = sp + '/'\n            to_input = tomod.to_tuple()\n            to_input.basepath = node.source_dir\n            to_input.filename = source\n            to_input.line = int(line)\n            if just_add is True:\n                tomod.add_program_point(to_input)\n                return True\n            lex_string = tomod.get_lex_string(to_input)\n            if lex_string.find('$') != -1 and node.attrs[\"vars\"] != '(null)':\n                input_val = node.attrs[\"vars\"][node.attrs[\"vars\"].find('=') + 1:]\n                lex_string = lex_string[:lex_string.find('$')] + input_val + lex_string[lex_string.find(')') + 1:]\n            node.attrs[\"lex_string\"] = lex_string\n            lex_map[lex_map_index] = lex_string\n            if lex_string == '':\n                return True\n\n    def get_children_temporal_order(self, node):\n        \"\"\"Generate temporal strings for the children of the specified node.\"\"\"\n        if node is None:\n            return False\n        if node.out_edges == []:\n            return False\n        found = False\n        for edge in node.out_edges:\n            if self.get_to_string(edge.dst) == '':\n                found = True\n                break\n        if found is False:\n            return False\n        source_map = defaultdict(list)\n        progress = 0.0\n        #import time\n        #t11 = time.time()\n        error_nodes = []\n        tomod.clear_program_points()\n        for edge in node.out_edges:\n            temp_node = edge.dst\n            ret = self.get_lex(temp_node, True)\n            if ret is False:\n                return False\n        tomod.run_to()\n        for edge in node.out_edges:\n            temp_node = edge.dst\n            if temp_node.hide is True:\n                temp_node.hide = False\n                temp_node.in_edge.hide = False\n            #t1 = time.time()\n            ret = self.get_lex(temp_node)\n            if ret is False:\n                return False\n            #t2 = time.time()\n            #print t2 - t1\n            if temp_node.attrs.get(\"lex_string\") is None or ret is False:\n                error_nodes.append(temp_node.attrs[\"label\"])\n                continue\n            if not has_source_and_not_collapsed(temp_node.attrs[\"label\"]):\n                error_nodes.append(temp_node.attrs[\"label\"])\n                continue\n            if temp_node.attrs[\"source\"] in [\"(null)\", \"?\"] or temp_node.attrs[\"line\"] in [\"(null)\", \":?\"]:\n                error_nodes.append(temp_node.attrs[\"label\"])\n                continue\n            source = temp_node.attrs[\"source\"]\n            line = temp_node.attrs[\"line\"].strip(\":\")\n            if not \"lex_string\" in node.attrs.keys():\n                temp_node.attrs[\"lex_string\"] = \"\"\n            temp_string = temp_node.attrs[\"lex_string\"][temp_node.attrs[\"lex_string\"].find('#') + 1:]\n            temp_string = temp_string[:temp_string.find('#')]\n            # temp_string is now the line number offset of the function\n            index_string = source + '#' + temp_string\n            to_input = tomod.to_tuple()\n            to_input.basepath = temp_node.attrs[\"lex_string\"]\n            to_input.filename = source\n            to_input.line = int(line)\n            source_map[index_string].append((to_input, temp_node))\n            progress += 1.0 / len(node.out_edges)\n            if progress > 1.0:\n                progress = 1.0\n            stat_wait_dialog.update_progress_bar(progress)\n        #t12 = time.time()\n        #print t12 - t11\n        #t1 = time.time()\n        if error_nodes != []:\n            show_error_dialog('Failed to create lexicographical string for %s.  Please be sure to gather stack traces with line number information and be sure to include the appropriate search paths\\n' % str(error_nodes))\n            return False\n        for key, source in source_map.items():\n            tomod.clear_program_points()\n            found = False\n            skip_node_rename_list = []\n            for to_input_tuple, node in source:\n                if node.attrs[\"lex_string\"].find('$') != -1 or node.attrs[\"label\"].find('$') != -1:\n                    # check if this is the first time visiting this variable\n                    if node not in self.to_var_visit_list:\n                        if node.attrs[\"label\"].find('=') != -1:\n                            found = True\n                        else:\n                            temp = node.attrs[\"lex_string\"][node.attrs[\"lex_string\"].find('$') + 1:]\n                            var = temp[:temp.find('(')]\n                            if var != 'iter#':\n                                skip_node_rename_list.append(node)\n                        self.to_var_visit_list.append(node)\n                tomod.add_program_point(to_input_tuple)\n            if found is True:\n                for to_input_tuple, node in source:\n                    # set lex string to None so we visit this next time around\n                    if \"lex_string\" in node.attrs.keys():\n                        del node.attrs[\"lex_string\"]\n                return False\n            for to_input_tuple, node in source:\n                if node in skip_node_rename_list:\n                    continue\n                temporal_string = tomod.get_temporal_string(to_input_tuple)\n                parent = node.in_edge.src\n                parent_temporal_string = ''\n                if parent is not None:\n                    parent_temporal_string = self.get_to_string(parent)\n                node.temporally_ordered = True\n                if parent_temporal_string == '':\n                    node.attrs[\"temporal_string\"] = node.attrs[\"function\"] + \"@T\" + temporal_string\n                    node.set_text(node.attrs[\"temporal_string\"])\n                    node.attrs[\"label\"] = node.attrs[\"temporal_string\"]\n                else:\n                    node.attrs[\"temporal_string\"] = node.attrs[\"function\"] + \"@T\" + parent_temporal_string + '.' + temporal_string\n                    node.set_text(node.attrs[\"temporal_string\"])\n                    node.attrs[\"label\"] = node.attrs[\"temporal_string\"]\n        self.color_temporally_ordered_edges()\n        #t2 = time.time()\n        #print t2 - t1\n        return True\n\n# TODO\n#    def update_children_temporal_string(self, node, temporal_string):\n#        if not self.has_to_descendents():\n#            return True\n#        for edge in node.out_edges:\n#            return False\n\n    def get_to_string(self, node):\n        \"\"\"Get the temporal string from the specified node.\"\"\"\n        temporal_string = node.attrs.get(\"temporal_string\", \"\")\n        ret_string = temporal_string[temporal_string.find('@T') + 2:]\n        return ret_string\n\n    def has_to_descendents(self, node):\n        \"\"\"Determine whether the specified node has children that have been temporally ordered.\"\"\"\n        for edge in node.out_edges:\n            temp_node = edge.dst\n            name = self.get_to_string(temp_node)\n            if name != '':\n                return True\n            if self.has_to_descendents(temp_node):\n                return True\n        return False\n\n    ## \\param self - the instance\n    #  \\param color_index - a value from 0 to 255\n    #  \\return a tuple of (red, blue) color values from 0.0 to 1.0\n    #\n    #  \\n\n    def to_color_index_to_rb(self, color_index):\n        \"\"\"Translate a color index into red and blue color values.\"\"\"\n        red = 255.0/255.0\n        blue = 255.0/255.0\n        if color_index <= 255:\n            blue = float(color_index)/255.0\n        else:\n            red = float(511 - color_index)/255.0\n        return red, blue\n\n    ## \\param self - the instance\n    #  \\param nodes - a list of nodes to check\n    #  \\param leaves_only - [optional] only find leaf nodes\n    #  \\return a tuple of (TO leaves, TO strings, TO node ancestors)\n    #\n    #  \\n\n    def get_to_list(self, nodes, leaves_only=False):\n        \"\"\"Find all temporally ordered nodes and their ancestors.\"\"\"\n        to_leaves = []  # list of (node, to_leaf_string) tuples\n        temporal_string_list = []\n        node_list = []\n        # generate list of all to leafs\n        max_len = 1\n        duplicates = 0\n        for node in nodes:\n            if self.has_to_descendents(node) is False or leaves_only is False:\n                temporal_string = self.get_to_string(node)\n                if temporal_string == '':\n                    continue\n                temporal_string = temporal_string.replace('.?', '')\n                for num_string in temporal_string.split('.'):\n                    if len(num_string) > max_len:\n                        max_len = len(num_string)\n                if temporal_string in temporal_string_list:\n                    duplicates += 1\n                else:\n                    temporal_string_list.append(temporal_string)\n                to_leaves.append((temporal_string, node))\n                node_list.append(node)\n        # sort the list by temporal_strings\n        if max_len > 1:\n            # pad with leading zeros if necessary\n            for i in range(len(to_leaves)):\n                temporal_string, node = to_leaves[i]\n                new_temporal_string = ''\n                for num_string in temporal_string.split('.'):\n                    new_temporal_string += '%0*d' % (max_len, int(num_string))\n                to_leaves[i] = new_temporal_string, node\n                temporal_string_list[temporal_string_list.index(temporal_string)] = new_temporal_string\n        to_leaves.sort()\n        temporal_string_list.sort()\n        return to_leaves, temporal_string_list, node_list\n\n    def color_temporally_ordered_edges(self):\n        \"\"\"Color the edges based on temporal ordering.\n\n        From red (least progress) to blue (most progress).\n        \"\"\"\n        to_leaves, temporal_string_list, node_list = self.get_to_list(self.nodes, True)\n        # assign colors\n        maxDepth = 0\n        for i in range(len(to_leaves)):\n            temporal_string, node = to_leaves[i]\n            if node.depth > maxDepth:\n                maxDepth = node.depth\n        depths = range(maxDepth + 1)\n        depths.remove(0)\n        try:\n            depths.remove(1)\n        except:\n            pass\n        depths.reverse()\n        for i in depths:\n            for j in range(len(to_leaves)):\n                temporal_string, node = to_leaves[j]\n                if node.depth != i:\n                    continue\n                if (len(temporal_string_list) == 1):\n                    node.to_color_index = 0\n                else:\n                    node.to_color_index = 511 * temporal_string_list.index(temporal_string) / (len(temporal_string_list) - 1)\n                red, blue = self.to_color_index_to_rb(node.to_color_index)\n                green = 0.0\n                for shape in node.in_edge.shapes:\n                    r, g, b, p = shape.pen.color\n                    shape.pen.color = (red, green, blue, p)\n                    r, g, b, p = shape.pen.fillcolor\n                    shape.pen.fillcolor = (red, green, blue, p)\n            # assign colors up the tree too\n            for node in self.nodes:\n                if node.depth == i and not node in node_list and self.has_to_descendents(node):\n                    min_to_color_index = 511\n                    for edge in node.out_edges:\n                        temp_node = edge.dst\n                        if temp_node is None:\n                            continue\n                        if temp_node.to_color_index == -1:\n                            continue\n                        if temp_node.to_color_index < min_to_color_index:\n                            min_to_color_index = temp_node.to_color_index\n                    node.to_color_index = min_to_color_index\n                    if node.to_color_index == -1:\n                        continue\n                    red, blue = self.to_color_index_to_rb(node.to_color_index)\n                    green = 0.0\n                    for shape in node.in_edge.shapes:\n                        r, g, b, p = shape.pen.color\n                        shape.pen.color = (red, 0, blue, p)\n                        r, g, b, p = shape.pen.fillcolor\n                        shape.pen.fillcolor = (red, 0, blue, p)\n\n    def get_node_depth(self, node):\n        \"\"\"Determine the depth of the specified node.\"\"\"\n        if not hasattr(node, \"in_edge\"):\n            return 1\n        if node.in_edge is not None:\n            return 1 + self.get_node_depth(node.in_edge.src)\n        else:\n            return 1\n\n    def get_node_eq_depth(self, node):\n        \"\"\"Determine the equivalence class depth.\n\n        i.e., number of colors along the path of the specified node.\"\"\"\n        if not hasattr(node, \"in_edge\"):\n            return 1\n        if node.in_edge is not None:\n            parent_node = node.in_edge.src\n            if parent_node.in_edge is None:\n                return 1\n            if node.in_edge.attrs[\"label\"] != parent_node.in_edge.attrs[\"label\"]:\n                return 1 + self.get_node_eq_depth(node.in_edge.src)\n            return self.get_node_eq_depth(node.in_edge.src)\n        else:\n            return 1\n\n    ## \\param self - the instance\n    #  \\param filename - the output file name\n    #\n    #  \\n\n    def save_folded_trace(self, filename):\n        \"\"\"Save the current graph as a folded trace.\n        The folded trace can then be used to generate a\n        flame graph (https://github.com/brendangregg/FlameGraph)\"\"\"\n\n        try:\n            with open(filename, 'w') as f:\n                for node in self.nodes:\n                    if node.hide:\n                        continue\n                    #if node.is_leaf:\n                    if self.node_is_visual_leaf(node):\n                        temp_node = node\n                        count = node.get_num_visual_leaf_tasks()\n                        #count = node.get_num_leaf_tasks()\n                        trace = node.attrs[\"label\"]\n                        x = 0\n                        while 1:\n                            if temp_node.in_edge == None:\n                                break\n                            temp_node = temp_node.in_edge.src\n                            if temp_node == None:\n                                break\n                            trace = temp_node.attrs[\"label\"] + \";\" + trace\n                        f.write(trace + \" \" + str(count) + \"\\n\")\n        except IOError as e:\n            show_error_dialog('%s\\nFailed to open file \"%s\" for writing' % (repr(e), filename), exception=e)\n            return False\n        except Exception as e:\n            show_error_dialog('%s\\nFailed to process file \"%s\" for writing' % (repr(e), filename), exception=e)\n            return False\n        return True\n\n    ## \\param self - the instance\n    #  \\param filename - the output file name\n    #  \\param full_edge_label - [optional] whether to save full edge labels, defaults to True\n    #  \\param full_node_label - [optional] whether to save full node labels, defaults to True\n    #  \\param translate_module_offset - [optional] whether to translate module offset traces to source + line, defaults to False\n    #\n    #  \\n\n    def save_dot(self, filename, full_edge_label=True, full_node_label=True, translate_module_offset=False):\n        \"\"\"Save the current graph as a dot file.\"\"\"\n        try:\n            f2 = open(\"test.perf-folded\", \"w\")\n            with open(filename, 'w') as f:\n                f.write('digraph G {\\n')\n                f.write('\\tgraph [type=\"stat_%d_%d\"];\\n' %(__version_major__, __version_minor__))\n                f.write('\\tnode [shape=record,style=filled,labeljust=c,height=0.2];\\n')\n                for node in self.nodes:\n                    if node.hide:\n                        continue\n                    for shape in node.shapes:\n                        if isinstance(shape, xdot_ui_elements.TextShape):\n                            font_color = shape.pen.color\n                            node_text = shape.t\n                        else:\n                            fill_color = shape.pen.fillcolor\n\n                    if translate_module_offset is True and node.attrs[\"module\"] != \"(null)\":\n                        eq_collapsed_label = ''\n                        for i, label in enumerate(node.attrs[\"label\"].split('\\\\n')):\n                            module_offset = \"%s%s\" %(node.attrs[\"module\"].split('\\\\n')[i], node.attrs[\"offset\"].split('\\\\n')[i])\n                            node_text = re.sub(expr, translate, module_offset)\n                            function = node_text[0:node_text.rfind('@')]\n                            source = node_text[node_text.rfind('@') + 1:node_text.rfind(':')]\n                            line = node_text[node_text.rfind(':') + 1:]\n                            if i == 0:\n                                node.attrs[\"function\"] = function\n                                node.attrs[\"source\"] = source\n                                node.attrs[\"line\"] = line\n                                eq_collapsed_label = function + '@' + source + ':' + line\n                            else:\n                                node.attrs[\"function\"] += '\\\\n' + function\n                                node.attrs[\"source\"] += '\\\\n' + source\n                                node.attrs[\"line\"] += '\\\\n' + line\n                                eq_collapsed_label += '\\\\n' + function + '@' + source + ':' + line\n                        if \"eq_collapsed_label\" in node.attrs.keys():\n                            node.attrs[\"eq_collapsed_label\"] = eq_collapsed_label\n                    elif full_node_label is True:\n                        node_text = node_attr_to_label(node.attrs)\n                        if \"eq_collapsed_label\" in node.attrs.keys():\n                            node.attrs[\"eq_collapsed_label\"] = node_text\n                    f.write('\\t%s [pos=\"0,0\", label=\"%s\"' % (node.node_name, escaped_label(node_text)))\n                    for attr in node.attrs.keys():\n                        if attr not in [\"pos\", \"label\", \"_draw_\", \"_ldraw_\", \"width\", \"height\", \"rects\", \"temporal_string\", \"lex_string\"]:\n                            f.write(', %s=\"%s\"' %(attr, node.attrs[attr]))\n                    f.write('];\\n')\n                for edge in self.edges:\n                    if edge.hide:\n                        continue\n                    if full_edge_label is True:\n                        output_label = edge.dst.edge_label\n                    else:\n                        output_label = get_truncated_edge_label(edge.attrs)\n                    if output_label.find(':') == -1:\n                        num_threads = -1\n                        if \"tbv\" in edge.attrs and edge.attrs[\"tbv\"] != \"(null)\":\n                            num_threads = int(edge.attrs[\"tbv\"])\n                        elif \"tcount\" in edge.attrs and edge.attrs[\"tcount\"] != \"(null)\":\n                            num_threads = int(edge.attrs[\"tcount\"])\n                        counts_string = '%d' %num_threads\n                        if num_threads != -1:\n                            counts_string += '(%d)' %num_threads\n                        counts_string += ':'\n                        output_label = counts_string + output_label\n                    f.write('\\t%s -> %s [label=\"%s\"' % (edge.src.node_name, edge.dst.node_name, output_label))\n                    for attr in edge.attrs.keys():\n                        if attr not in [\"label\", \"_draw_\", \"_ldraw_\", \"_hdraw_\", \"pos\", \"lp\"]:\n                            f.write(', %s=\"%s\"' %(attr, edge.attrs[attr]))\n                    f.write(']\\n')\n                f.write('}\\n')\n        except IOError as e:\n            show_error_dialog('%s\\nFailed to open file \"%s\" for writing' % (repr(e), filename), exception=e)\n            return False\n        except Exception as e:\n            show_error_dialog('%s\\nFailed to process file \"%s\" for writing' % (repr(e), filename), exception=e)\n            return False\n        return True\n\n    def save_file(self, filename):\n        \"\"\"Save the current graph into a dot file or image file.\"\"\"\n        if os.path.splitext(filename)[1] == '.dot':\n            ret = self.save_dot(filename)\n        elif os.path.splitext(filename)[1] == '.perf-folded':\n            ret = self.save_folded_trace(filename)\n        else:\n            temp_dot_filename = os.path.splitext(filename)[0] + '_tmp.dot'\n            ret = self.save_dot(temp_dot_filename, False, False)\n            if ret is True:\n                file_format = '-T' + os.path.splitext(filename)[1][1:]\n                proc = subprocess.Popen([\"dot\", file_format, temp_dot_filename, \"-o\", filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n                stdout_output, stderr_output = proc.communicate()\n                if stderr_output != '':\n                    sys.stderr.write('dot outputted error message: %s\\n' % stderr_output)\n                if proc.returncode != 0:\n                    show_error_dialog('Failed to process file \"%s\" for writing: %s' % (temp_dot_filename, stderr_output))\n            os.remove(temp_dot_filename)\n        return ret\n\n    def on_original_graph(self, widget):\n        \"\"\"Restore the call prefix tree to its original state.\"\"\"\n        widget.user_zoom = False\n        modified = False\n        for node in self.nodes:\n            if \"lex_string\" in node.attrs:\n                del node.attrs[\"lex_string\"]\n            if \"temporal_string\" in node.attrs:\n                del node.attrs[\"temporal_string\"]\n            node.temporally_ordered = False\n            if node.hide is True:\n                node.hide = False\n                modified = True\n        for edge in self.edges:\n            if edge.hide is True:\n                edge.hide = False\n                modified = True\n            for shape in edge.shapes:\n                r, g, b, p = shape.pen.color\n                shape.pen.color = (0.0, 0.0, 0.0, p)\n                r, g, b, p = shape.pen.fillcolor\n                shape.pen.fillcolor = (0.0, 0.0, 0.0, p)\n        return modified\n\n    def hide_mpi(self):\n        \"\"\"Hide the MPI implementation frames.\"\"\"\n        return self.hide_generic(is_mpi)\n\n    def hide_re(self, search_text, match_case):\n        return self.hide_generic(re_search, search_text, match_case)\n\n    def hide_generic(self, func, *args):\n        \"\"\"Hide frames that match the specified function.\"\"\"\n        modified = False\n        for node in self.nodes:\n\n            function_names = node.attrs[\"function\"].split('\\\\n')\n            for i, function_name in enumerate(function_names):\n                if args != ():\n                    hide = func(function_name, args)\n                else:\n                    hide = func(function_name)\n                if hide is True:\n                    ret = self.collapse(node, True)\n                    if ret is True:\n                        modified = True\n                        break\n        return modified\n\n    def traverse(self, widget, traversal_depth):\n        \"\"\"Traverse the call prefix tree by equivalence class depth.\"\"\"\n        show_list = []\n        max_eq_depth = 0\n        for node in self.nodes:\n            if node.eq_depth > max_eq_depth:\n                max_eq_depth = node.eq_depth\n            if node.eq_depth <= traversal_depth:\n                show_list.append(node)\n        if traversal_depth > max_eq_depth:\n            return False\n        for node in self.nodes:\n            node.hide = True\n        for edge in self.edges:\n            edge.hide = True\n        for node in show_list:\n            temp_node = node\n            while 1:\n                temp_node.hide = False\n                if temp_node.in_edge is not None:\n                    temp_node.in_edge.hide = False\n                    temp_node = temp_node.in_edge.src\n                else:\n                    break\n        return True\n\n    def to_traverse_least_progress(self, widget, traversal_depth):\n        \"\"\"Traverse the call prefix tree by least progress.\"\"\"\n        if traversal_depth == 1:\n            for node in self.nodes:\n                node.hide = True\n            for edge in self.edges:\n                edge.hide = True\n        for node in self.nodes:\n            if node.in_edge is None:\n                root = node\n                node.hide = False\n#                for edge in root.out_edges:\n#                    edge.hide = False\n                if root.out_edges is not None:\n                    if root.out_edges[0].dst.attrs[\"label\"].find('start') != -1 and root.out_edges[0].dst.attrs[\"label\"].find('libc') == -1:\n                        root = root.out_edges[0].dst\n                        root.temporally_ordered = True\n                break\n        ret = self._traverse_progress(root, 'least')\n        return ret\n\n    def to_traverse_most_progress(self, widget, traversal_depth):\n        \"\"\"Traverse the call prefix tree by most progress.\"\"\"\n        if traversal_depth == 1:\n            for node in self.nodes:\n                node.hide = True\n            for edge in self.edges:\n                edge.hide = True\n        for node in self.nodes:\n            if node.in_edge is None:\n                root = node\n                node.hide = False\n                for edge in root.out_edges:\n                    edge.hide = False\n                if root.out_edges is not None:\n                    for edge in root.out_edges:\n                        if edge.dst.attrs[\"label\"].find('start') != -1 and edge.dst.attrs[\"label\"].find('libc') == -1:\n                            edge.dst.temporally_ordered = True\n                            root = edge.dst\n                            edge.hide = False\n                            break\n#                    if root.out_edges[0].dst.attrs[\"label\"].find('start') != -1 and root.out_edges[0].dst.attrs[\"label\"].find('libc') == -1:\n#                        root = root.out_edges[0].dst\n                break\n        ret = self._traverse_progress(root, 'most')\n        return ret\n\n    def _traverse_progress(self, node, least_or_most):\n        \"\"\"Generic implementation for traversal by progress.\"\"\"\n        node.hide = False\n        if node.in_edge != None:\n            node.in_edge.hide = False\n        if node.out_edges is None or node.out_edges == []:\n            return False\n        if len(node.out_edges) == 0:\n            return True\n        found_lex_string = False\n        for edge in node.out_edges:\n            if edge.dst.temporally_ordered is True:\n                edge.hide = False\n                edge.dst.hide = False\n                found_lex_string = True\n        if found_lex_string is False:\n            if is_mpi(node.attrs[\"function\"]):\n                return False\n            # we want to TO this node's children\n            ret = self.get_children_temporal_order(node)\n            if ret is False:\n                return ret\n            if len(node.out_edges) == 1:\n                if node.out_edges[0].dst.attrs[\"lex_string\"].find('$') != -1:\n                    return True\n                self._traverse_progress(node.out_edges[0].dst, least_or_most)\n            else:\n                #print 'multiple children => done'\n                return True\n        else:\n            # we need to traverse down the tree further\n            if len(node.out_edges) == 1:\n                #print 'one child, keep going'\n                ret = self._traverse_progress(node.out_edges[0].dst, least_or_most)\n                return ret\n            elif len(node.out_edges) != 0:\n                #print 'multiple children... choose'\n                dst_nodes = []\n                for edge in node.out_edges:\n                    dst_nodes.append(edge.dst)\n                to_leaves, temporal_string_list, node_list = self.get_to_list(dst_nodes)\n                if least_or_most == 'most':\n                    to_leaves.reverse()\n                for temporal_string, temp_node in to_leaves:\n                    ret = self._traverse_progress(temp_node, least_or_most)\n                    if ret is True:\n                        return ret\n                return False\n        return True\n\n    def focus_tasks(self, task):\n        \"\"\"Hide all call paths that are not taken by the specified tasks.\"\"\"\n        task = task.strip(' ')\n        task = '[' + task + ']'\n        task_list_set = set(get_task_list(task))\n        for node in self.nodes:\n            if node.node_name == '0':\n                continue\n            if task_list_set & set(node.get_node_task_list()) == set([]):\n                node.hide = True\n        for edge in self.edges:\n            if task_list_set & set(edge.dst.get_node_task_list()) == set([]):\n                edge.hide = True\n        return True\n\n    def focus_text(self, text, case_sensitive=True):\n        \"\"\"Hide all call paths that do not contain the search text.\"\"\"\n        for node in self.nodes:\n            if node.node_name == '0':\n                self.depth_first_search_text(node, text, case_sensitive)\n        return True\n\n    def depth_first_search_text(self, node, text, case_sensitive=True):\n        \"\"\"search for specified text in a depth first order.\"\"\"\n        ret = False\n        if node.hide is True:\n            return False\n        for edge in node.out_edges:\n            if self.depth_first_search_text(edge.dst, text, case_sensitive):\n                ret = True\n        search_text = text\n        node_text = node.attrs[\"label\"]\n        if case_sensitive is False:\n            search_text = string.lower(text)\n            node_text = string.lower(node.attrs[\"label\"])\n        if re.search(search_text, node_text) is not None:\n            ret = True\n        if ret is False and node.node_name != '0':\n            node.hide = True\n            node.in_edge.hide = True\n        return ret\n\n    def longest_path(self, widget, longest_depth):\n        \"\"\"Traverse the call prefix tree by longest path.\"\"\"\n        longest_map = {}\n        for node in self.nodes:\n            if node.is_leaf:\n                try:\n                    longest_map[node.depth].append(node)\n                except:\n                    longest_map[node.depth] = []\n                    longest_map[node.depth].append(node)\n        keys = list(longest_map.keys())\n        if len(keys) < longest_depth:\n            return False\n        keys.sort()\n        keys.reverse()\n        for node in self.nodes:\n            node.hide = True\n        for edge in self.edges:\n            edge.hide = True\n        for node in longest_map[keys[longest_depth - 1]]:\n            temp_node = node\n            while 1:\n                temp_node.hide = False\n                if temp_node.in_edge is not None:\n                    temp_node.in_edge.hide = False\n                    temp_node = temp_node.in_edge.src\n                else:\n                    break\n        return True\n\n#    def longest_path(self, widget):\n#        longest = 0\n#        long_list = []\n#        for node in self.nodes:\n#            if node.hide is True:\n#                continue\n#            if node.depth == longest:\n#                long_list.append(node)\n#            elif node.depth > longest:\n#                longest = node.depth\n#                long_list = []\n#                long_list.append(node)\n#        for node in self.nodes:\n#            node.hide = True\n#        for edge in self.edges:\n#            edge.hide = True\n#        for node in long_list:\n#            temp_node = node\n#            while 1:\n#                temp_node.hide = False\n#                if temp_node.in_edge is not None:\n#                    temp_node.in_edge.hide = False\n#                    temp_node = temp_node.in_edge.src\n#                else:\n#                    break\n\n    def is_leaf(self, node):\n        \"\"\"Determine if the node is the leaf of any task's call path.\"\"\"\n        if not hasattr(node, \"node_name\"):\n            return False\n        if node.node_name == '0':\n            return False\n        child_task_list = []\n        for edge in node.out_edges:\n            if edge.dst is not None:\n                child_task_list += edge.dst.get_node_task_list()\n        if set(child_task_list) == set(node.get_node_task_list()):\n            return False\n        return True\n\n    def shortest_path(self, widget, shortest_depth):\n        \"\"\"Traverse the call prefix tree by shortest path.\"\"\"\n        shortest_map = {}\n        for node in self.nodes:\n            if node.is_leaf:\n                try:\n                    shortest_map[node.depth].append(node)\n                except:\n                    shortest_map[node.depth] = []\n                    shortest_map[node.depth].append(node)\n        keys = list(shortest_map.keys())\n        if len(keys) < shortest_depth:\n            return False\n        keys.sort()\n        for node in self.nodes:\n            node.hide = True\n        for edge in self.edges:\n            edge.hide = True\n        for node in shortest_map[keys[shortest_depth - 1]]:\n            temp_node = node\n            while 1:\n                temp_node.hide = False\n                if temp_node.in_edge is not None:\n                    temp_node.in_edge.hide = False\n                    temp_node = temp_node.in_edge.src\n                else:\n                    break\n        return True\n\n#    def shortest_path(self, widget):\n#        shortest = 999999\n#        short_list = []\n#        for node in self.nodes:\n#            if node.hide is True:\n#                continue\n#            if node.is_leaf:\n#                if node.depth == shortest:\n#                    short_list.append(node)\n#                elif node.depth < shortest:\n#                    shortest = node.depth\n#                    short_list = []\n#                    short_list.append(node)\n#        for node in self.nodes:\n#            node.hide = True\n#        for edge in self.edges:\n#            edge.hide = True\n#        for node in short_list:\n#            temp_node = node\n#            while 1:\n#                temp_node.hide = False\n#                if temp_node.in_edge is not None:\n#                    temp_node.in_edge.hide = False\n#                    temp_node = temp_node.in_edge.src\n#                else:\n#                    break\n\n    def least_tasks(self, widget, least_tasks):\n        \"\"\"Traverse the call prefix tree by least tasks.\"\"\"\n        least_map = {}\n        for node in self.nodes:\n            task_count = node.get_num_leaf_tasks()\n            if task_count == 0:\n                continue\n            try:\n                least_map[task_count].append(node)\n            except:\n                least_map[task_count] = []\n                least_map[task_count].append(node)\n        keys = list(least_map.keys())\n        if len(keys) < least_tasks:\n            return False\n        keys.sort()\n        for node in self.nodes:\n            node.hide = True\n        for edge in self.edges:\n            edge.hide = True\n        for node in least_map[keys[least_tasks - 1]]:\n            temp_node = node\n            while 1:\n                temp_node.hide = False\n                if temp_node.in_edge is not None:\n                    temp_node.in_edge.hide = False\n                    temp_node = temp_node.in_edge.src\n                else:\n                    break\n        return True\n\n    def most_tasks(self, widget, most_tasks):\n        \"\"\"Traverse the call prefix tree by most tasks.\"\"\"\n        most_map = {}\n        for node in self.nodes:\n            task_count = node.get_num_leaf_tasks()\n            if task_count == 0:\n                continue\n            try:\n                most_map[task_count].append(node)\n            except:\n                most_map[task_count] = []\n                most_map[task_count].append(node)\n        keys = list(most_map.keys())\n        if len(keys) < most_tasks:\n            return False\n        keys.sort()\n        keys.reverse()\n        for node in self.nodes:\n            node.hide = True\n        for edge in self.edges:\n            edge.hide = True\n        for node in most_map[keys[most_tasks - 1]]:\n            temp_node = node\n            while 1:\n                temp_node.hide = False\n                if temp_node.in_edge is not None:\n                    temp_node.in_edge.hide = False\n                    temp_node = temp_node.in_edge.src\n                else:\n                    break\n        return True\n\n    def single_task_path(self, widget):\n        \"\"\"Hides any call path whose leaf was visited by multpile tasks.\"\"\"\n        single_task_list = []\n        hide_count = 0\n        for node in self.nodes:\n            if node.hide is True:\n                hide_count += 1\n            if node.num_tasks == 1 and node.hide is False:\n                single_task_list.append(node)\n        for node in self.nodes:\n            node.hide = True\n        for edge in self.edges:\n            edge.hide = True\n        for node in single_task_list:\n            temp_node = node\n            while 1:\n                temp_node.hide = False\n                if temp_node.in_edge is not None:\n                    temp_node.in_edge.hide = False\n                    temp_node = temp_node.in_edge.src\n                else:\n                    break\n        hide_count2 = 0\n        for node in self.nodes:\n            if node.hide is True:\n                hide_count2 += 1\n        if hide_count == hide_count2:\n            return False\n        else:\n            return True\n        return True\n\n    def adjust_dims(self):\n        \"\"\"Readjust the viewing area based on visible nodes.\"\"\"\n        minx = 999999.9\n        miny = 999999.9\n        maxx = -999999.9\n        maxy = -999999.9\n        for node in self.nodes:\n            if node.x1 < minx and node.hide is False:\n                minx = node.x1\n            if node.y1 < miny and node.hide is False:\n                miny = node.y1\n        if use_scroll_bars:\n            for node in self.nodes:\n                if node.x2 > maxx and node.hide is False:\n                    maxx = node.x2\n                if node.y2 > maxy and node.hide is False:\n                    maxy = node.y2\n            self.visible_width = int(math.ceil(maxx) - math.floor(minx))\n            self.visible_height = int(math.ceil(maxy) - math.floor(miny))\n            self.maxx = maxx\n            self.maxy = maxy\n            #self.width = int(math.ceil(maxx))\n            #self.height = int(math.ceil(maxy))\n        else:\n            for node in self.nodes:\n                node.x1 = node.x1 - minx\n                node.x2 = node.x2 - minx\n                node.y1 = node.y1 - miny\n                node.y2 = node.y2 - miny\n                node.x = node.x - minx\n                node.y = node.y - miny\n                for shape in node.shapes:\n                    try:\n                        shape.x = shape.x - minx\n                        shape.y = shape.y - miny\n                    except:\n                        pass\n                    try:\n                        points = []\n                        for x, y in shape.points:\n                            points.append((x - minx, y - miny))\n                        shape.points = points\n                    except:\n                        pass\n                    if node.x2 > maxx and node.hide is False:\n                        maxx = node.x2\n                    if node.y2 > maxy and node.hide is False:\n                        maxy = node.y2\n            for edge in self.edges:\n                points = []\n                for x, y in edge.points:\n                    points.append((x - minx, y - miny))\n                edge.points = points\n                for shape in edge.shapes:\n                    try:\n                        shape.x = shape.x - minx\n                        shape.y = shape.y - miny\n                    except:\n                        pass\n                    try:\n                        points = []\n                        for x, y in shape.points:\n                            points.append((x - minx, y - miny))\n                        shape.points = points\n                    except:\n                        pass\n            self.width = int(math.ceil(maxx))\n            self.height = int(math.ceil(maxy))\n\n    def node_is_visual_leaf(self, node):\n        \"\"\"Determine if the node is a leaf of the visible tree.\"\"\"\n        if node.hide is True:\n            return False\n        for edge in node.out_edges:\n            if edge.dst.hide is False:\n                return False\n        return True\n\n    def node_is_visual_eq_leaf(self, node):\n        \"\"\"Determine if the node is an eq class leaf of the visible tree.\"\"\"\n        if node.hide is True or node.node_name == '0':\n            return False\n\n        task_list = []\n        if node.edge_label.find(':') != -1:\n            num_leaf_tasks = node.get_num_visual_leaf_tasks()\n            if num_leaf_tasks != 0:\n                return True\n            else:\n                return False\n        else:\n            for edge in node.out_edges:\n                if edge.dst.hide is False:\n                    task_list += edge.dst.get_node_task_list()\n            if set(node.get_node_task_list()) == set(task_list):\n                return False\n            return True\n\n    def identify_num_eq_classes(self, widget):\n        \"\"\"Find all equivalence classes (based on color) of the call tree.\"\"\"\n        leaves = []\n        for node in self.nodes:\n            if self.node_is_visual_eq_leaf(node):\n                leaves.append(node)\n        task_leaf_list = []\n        leaf_task_sets = []\n        for node in leaves:\n            leaf_task_sets.append(set(node.get_node_task_list()))\n        for node in leaves:\n            # get the node font and background colors\n            for shape in node.shapes:\n                if isinstance(shape, xdot_ui_elements.TextShape):\n                    font_color = shape.pen.color\n                else:\n                    fill_color = shape.pen.fillcolor\n            font_color_string = color_to_string(font_color)\n            fill_color_string = color_to_string(fill_color)\n\n            # adjust task list for eq class leaves with children\n            task_list = node.get_node_task_list()\n            task_list_set = set(task_list)\n            for edge in node.out_edges:\n                if edge.dst.hide is True:\n                    continue\n                if set(edge.dst.get_node_task_list()) in leaf_task_sets:\n                    task_list_set = task_list_set - set(edge.dst.get_node_task_list())\n            task_list = list(task_list_set)\n            if (task_list, fill_color_string, font_color_string) not in task_leaf_list:\n                task_leaf_list.append((task_list, fill_color_string, font_color_string))\n        return task_leaf_list\n\n    def identify_real_num_eq_classes(self, widget):\n        \"\"\"Finds all equivalence classes (based on visited paths) of the call tree.\"\"\"\n        leaves = []\n        for node in self.nodes:\n            if node.hide is False:\n                leaves.append(node)\n        task_leaf_map = {}\n        for node in leaves:\n            task_list = node.get_node_task_list()\n            for task in task_list:\n                try:\n                    task_leaf_map[task] += '#%s' % node.node_name\n                except:\n                    task_leaf_map[task] = node.node_name\n        num_eq_classes = {}\n        for task in task_leaf_map:\n            try:\n                num_eq_classes[task_leaf_map[task]].append(task)\n            except:\n                num_eq_classes[task_leaf_map[task]] = [task]\n        return num_eq_classes\n\n\nclass STATDotParser(xdot_dot_parser.DotParser):\n\n    def __init__(self, dot_code):\n        self.nodes = []\n        self.edges = []\n        self.graph_attrs = {}\n        xdot_dot_parser.DotParser.__init__(self, xdot_dot_lexer.DotLexer(buf=dot_code))\n\n    def handle_graph(self, attrs):\n        new_attrs = {}\n        for key in attrs:\n            if type(attrs[key]) != bytes:\n                self.graph_attrs.update(attrs)\n                return\n            new_attrs[key] = attrs[key].decode(\"utf-8\")\n        self.graph_attrs.update(new_attrs)\n\n    def handle_node(self, id, attrs):\n        new_attrs = {}\n        for key in attrs:\n            if type(attrs[key]) != bytes:\n                self.nodes.append((id, attrs))\n                return\n            new_attrs[key] = attrs[key].decode(\"utf-8\")\n        self.nodes.append((id.decode(\"utf-8\"), new_attrs))\n\n    def handle_edge(self, src_id, dst_id, attrs):\n        new_attrs = {}\n        for key in attrs:\n            if type(attrs[key]) != bytes:\n                self.edges.append((src_id, dst_id, attrs))\n                return\n            new_attrs[key] = attrs[key].decode(\"utf-8\")\n        self.edges.append((src_id.decode(\"utf-8\"), dst_id.decode(\"utf-8\"), new_attrs))\n\n\n## The STAT XDot Parser.\nclass STATXDotParser(xdot_dot_parser.XDotParser):\n    \"\"\"The STAT XDot Parser.\n\n    Derrived form the XDotParser and overrides some XDotParser methods\n    to build a STATGraph.\n    \"\"\"\n    # TODO: use attrs to add STAT-specific values to nodes and edges\n\n    def __init__(self, xdotcode):\n        \"\"\"The constructor.\"\"\"\n        self.graph_attrs = {}\n        xdot_dot_parser.XDotParser.__init__(self, xdotcode)\n\n    def parse(self):\n        \"\"\"Parse the dot file.\"\"\"\n        xdot_dot_parser.DotParser.parse(self)\n        if (\"type\" in self.graph_attrs.keys()) and (self.graph_attrs[\"type\"] == \"dysect\"):\n            raise Exception('This is a DySectAPI .dot graph, open with dysect-view')\n        return STATGraph(self.width, self.height, (), self.nodes, self.edges)\n\n    def handle_graph(self, attrs):\n        self.graph_attrs.update(attrs)\n\n        new_attrs = {}\n        for key in attrs:\n            if type(attrs[key]) != bytes:\n                xdot_dot_parser.XDotParser.handle_graph(self, attrs)\n                return\n            new_attrs[key] = attrs[key].decode(\"utf-8\")\n        xdot_dot_parser.XDotParser.handle_graph(self, attrs)\n\n    def handle_node(self, node_id, attrs):\n        \"\"\"Handle a node attribute to create a STATNode.\"\"\"\n        try:\n            node_id = node_id.decode('utf-8')\n        except:\n            pass\n        new_id = node_id.strip('\"')\n        xdot_dot_parser.XDotParser.handle_node(self, new_id, attrs)\n        node = self.node_by_name[new_id]\n        label = attrs.get('originallabel', None)\n        if label == None:\n            return False\n        stat_node = STATNode(node.x, node.y, node.x1, node.y1, node.x2, node.y2, node.shapes, label, attrs)\n        stat_node.node_name = new_id\n        self.node_by_name[new_id] = stat_node\n        self.nodes.pop()\n        self.nodes.append(stat_node)\n\n    def handle_edge(self, src_id, dst_id, attrs):\n        \"\"\"Handle an edge attribute to create a STATNode.\"\"\"\n        try:\n            src_id = src_id.decode('utf-8')\n            dst_id = dst_id.decode('utf-8')\n        except:\n            pass\n        new_src_id = src_id.strip('\"')\n        new_dst_id = dst_id.strip('\"')\n        xdot_dot_parser.XDotParser.handle_edge(self, new_src_id, new_dst_id, attrs)\n        label = attrs.get('label', None)\n        if label == None:\n            return False\n        try:\n            label = label.decode('utf-8')\n        except:\n            pass\n        edge = self.edges.pop()\n        stat_edge = STATEdge(edge.src, edge.dst, edge.points, edge.shapes, label, attrs)\n        self.edges.append(stat_edge)\n        stat_edge.src.out_edges.append(stat_edge)\n        stat_edge.dst.in_edge = stat_edge\n        new_dst_label = attrs.get('originallabel', None)\n        try:\n            new_dst_label = new_dst_label.decode('utf-8')\n        except:\n            pass\n        if new_dst_label == None:\n            new_dst_label = label# attrs[\"label\"]\n        if src_id == '0':\n            self.node_by_name[new_src_id].edge_label = ''\n            self.node_by_name[new_src_id].num_tasks = get_num_tasks(new_dst_label)\n        stat_edge.attrs[\"label\"] = new_dst_label\n        self.node_by_name[new_dst_id].edge_label = new_dst_label\n        self.node_by_name[new_dst_id].num_tasks = get_num_tasks(new_dst_label)\n\n\n## The STATNullAction overloads the xdot NullAction.\nclass STATNullAction(xdot_ui_actions.DragAction):\n    \"\"\"The STATNullAction overloads the xdot NullAction.\n\n    Allows highlighting the entire call path of a given node.\n    \"\"\"\n\n    def on_motion_notify(self, event):\n        \"\"\"Highlight the call path of the node/edge that is moused over.\"\"\"\n        dot_widget = self.dot_widget\n        item = dot_widget.get_label(event.x, event.y)\n        if item is None:\n            item = dot_widget.get_jump(event.x, event.y)\n        if item is not None:\n            node = dot_widget.get_node(event.x, event.y)\n            if node is not None:\n                if not hasattr(node, \"hide\"):\n                    return False\n                if node.hide is False:\n                    if hasattr(dot_widget.window, \"set_cursor\"):\n                        dot_widget.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.ARROW))\n                    else:\n                        dot_widget.get_window().set_cursor(gdk.Cursor(gdk.CursorType.ARROW))\n                    highlight_list = []\n                    while node is not None:\n                        #highlight_list.append(node)\n                        edge = node.in_edge\n                        if edge is None:\n                            break\n                        highlight_list.append(edge)\n                        node = edge.src\n                    dot_widget.set_highlight(highlight_list)\n            else:\n                if hasattr(dot_widget.window, \"set_cursor\"):\n                    dot_widget.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.ARROW))\n                else:\n                    dot_widget.get_window().set_cursor(gdk.Cursor(gdk.CursorType.ARROW))\n                dot_widget.set_highlight(None)\n        else:\n            if hasattr(dot_widget.window, \"set_cursor\"):\n                dot_widget.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.ARROW))\n            else:\n                dot_widget.get_window().set_cursor(gdk.Cursor(gdk.CursorType.ARROW))\n            dot_widget.set_highlight(None)\n\n\n## PyGTK widget that draws STAT generated dot graphs.\nclass STATDotWidget(xdot_ui_window.DotWidget):\n    \"\"\"PyGTK widget that draws STAT generated dot graphs.\n\n    Derrived from xdot's DotWidget class.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"The constructor.\"\"\"\n        xdot_ui_window.DotWidget.__init__(self)\n        self.graph = STATGraph()\n        try:\n            self.window = self\n        except:\n            # TODO: for some reason python 2 + xdot.py doesn't like this\n            pass\n        self.drag_action = STATNullAction(self)\n        self.user_zoom = False\n\n    def set_dotcode(self, dotcode, filename='<stdin>', truncate=\"front\", max_node_name=64, center=True):\n        \"\"\"Set the dotcode for the widget.\n\n        Create a temporary dot file with truncated edge labels from the\n        specified dotcode and generates xdotcode with layout information.\n        \"\"\"\n        if filename != '<stdin>':\n            temp_dot_filename = create_temp(filename, truncate, max_node_name)\n            if temp_dot_filename is None:\n                return False\n        try:\n            f = open(temp_dot_filename, 'r')\n            contents = f.read()\n            # We need to break lines so they are no longer than 16K characters\n            new_contents = ''\n            for line in contents.split('\\n'):\n                while len(line) > 16000:\n                    new_contents += line[:16000] + '\\\\\\n'\n                    line = line[16000:]\n                new_contents += line + '\\n'\n            try:\n                dotcode2 = bytes(new_contents, 'utf-8')\n            except:\n                dotcode2 = new_contents\n            f.close()\n        except Exception as e:\n            show_error_dialog('Failed to read temp dot file %s' % temp_dot_filename, self, exception=e)\n            return False\n        os.remove(temp_dot_filename)\n        xdot_ui_window.DotWidget.set_dotcode(self, dotcode2, filename)\n        self.graph.cur_filename = filename\n        return True\n\n    def set_xdotcode(self, xdotcode, center=True):\n        \"\"\"Parse the xdot code to create a STAT Graph.\"\"\"\n        parser = STATXDotParser(xdotcode)\n        self.graph = parser.parse()\n        self.graph.visible_width = self.graph.width\n        self.graph.visible_height = self.graph.height\n        self.zoom_image(self.zoom_ratio, center=True)\n\n    def update(self):\n        pass\n\n    def on_area_button_release(self, area, event):\n        \"\"\"Handle the clicking of a node.\"\"\"\n        self.drag_action.on_button_release(event)\n        self.drag_action = STATNullAction(self)\n        if event.button == 1 and self.is_click(event):\n            x, y = int(event.x), int(event.y)\n            label = self.get_label(x, y)\n            if label is not None:\n                self.emit('clicked', 'left', event)\n            else:\n                jump = self.get_jump(x, y)\n                if jump is not None:\n                    self.animate_to(jump.x, jump.y)\n            return True\n        if event.button == 2 and self.is_click(event):\n            x, y = int(event.x), int(event.y)\n            jump = self.get_jump(x, y)\n            if jump is not None:\n                self.animate_to(jump.x, jump.y)\n            return True\n        if event.button == 3 and self.is_click(event):\n            x, y = int(event.x), int(event.y)\n            label = self.get_label(x, y)\n            if label is not None:\n                self.emit('clicked', 'right', event)\n            else:\n                jump = self.get_jump(x, y)\n                if jump is not None:\n                    self.animate_to(jump.x, jump.y)\n            return True\n        if event.button == 1 or event.button == 2 or event.button == 3:\n            return True\n        return False\n\n    def get_node(self, x, y):\n        \"\"\"Get the node that contains the specified coordinates.\"\"\"\n        x, y = self.window2graph(x, y)\n        return self.graph.get_node(x, y)\n\n    def get_edge(self, x, y):\n        \"\"\"Get the edge that contains the specified coordinates.\"\"\"\n        x, y = self.window2graph(x, y)\n        return self.graph.get_edge(x, y)\n\n    def get_edge_label(self, x, y):\n        \"\"\"Get the edge label that contains the specified coordinates.\"\"\"\n        x, y = self.window2graph(x, y)\n        return self.graph.get_edge_label(x, y)\n\n    def get_label(self, x, y):\n        \"\"\"Get the label that contains the specified coordinates.\"\"\"\n        x, y = self.window2graph(x, y)\n        return self.graph.get_label(x, y)\n\n    def queue_draw(self):\n        \"\"\"Overloaded queue_draw to set size request for scroll window.\"\"\"\n        if use_scroll_bars:\n            width = int(math.ceil(self.graph.width * self.zoom_ratio)) + 2 * self.ZOOM_TO_FIT_MARGIN\n            height = int(math.ceil(self.graph.height * self.zoom_ratio)) + 2 * self.ZOOM_TO_FIT_MARGIN\n            self.set_size_request(max(width, 1), max(height, 1))\n        xdot_ui_window.DotWidget.queue_draw(self)\n\n    def is_click(self, event, click_fuzz=4, click_timeout=1.0):\n        if event.x != self.pressx or event.y != self.pressy:\n            self.user_zoom = True\n        return xdot_ui_window.DotWidget.is_click(self, event, click_fuzz, click_timeout)\n\n    def get_drag_action(self, event):\n        \"\"\"Overloaded get_drag_action for scroll window.\"\"\"\n        if use_scroll_bars:\n            state = event.state\n            if event.button in (1, 2):  # left or middle button\n                if state & gtk.gdk.CONTROL_MASK:\n                    return xdot_ui_actions.ZoomAction\n                elif state & gtk.gdk.SHIFT_MASK:\n                    return xdot_ui_actions.ZoomAreaAction\n                else:\n                    return STATPanAction\n            return xdot_ui_actions.NullAction\n        else:\n            return xdot_ui_window.DotWidget.get_drag_action(self, event)\n\n    def zoom_to_fit(self):\n        \"\"\"Overloaded zoom_to_fit for scroll window.\"\"\"\n        self.user_zoom = False\n        if use_scroll_bars:\n            #rect = self.dotsw.get_allocation()\n            rect = self.viewport.get_allocation()\n            rect.x += self.ZOOM_TO_FIT_MARGIN\n            rect.y += self.ZOOM_TO_FIT_MARGIN\n            rect.width -= 2 * self.ZOOM_TO_FIT_MARGIN\n            rect.height -= 2 * self.ZOOM_TO_FIT_MARGIN\n            zoom_ratio = min(\n                float(rect.width)/float(self.graph.visible_width),\n                float(rect.height)/float(self.graph.visible_height)\n            )\n            if self.graph.width == self.graph.visible_width and self.graph.height == self.graph.visible_height:\n                self.zoom_image(zoom_ratio, center=True)\n            else:\n                x = zoom_ratio * (self.graph.maxx - self.graph.visible_width / 2)\n                y = zoom_ratio * (self.graph.maxy - self.graph.visible_height / 2)\n                self.zoom_image(zoom_ratio, False, (x, y))\n            self.zoom_to_fit_on_resize = True\n        else:\n            return xdot_ui_window.DotWidget.zoom_to_fit(self)\n\n    def on_zoom_fit(self, action):\n        self.user_zoom = False\n        self.graph.adjust_dims()\n        self.zoom_to_fit()\n\n    def on_area_scroll_event(self, area, event):\n        self.user_zoom = True\n        return xdot_ui_window.DotWidget.on_area_scroll_event(self, area, event)\n\n    def on_key_press_event(self, widget, event):\n        if event.keyval in (gtk.keysyms.Page_Up, gtk.keysyms.plus, gtk.keysyms.equal, gtk.keysyms.KP_Add, gtk.keysyms.Page_Down, gtk.keysyms.minus, gtk.keysyms.KP_Subtract, gtk.keysyms.Left, gtk.keysyms.Right, gtk.keysyms.Up, gtk.keysyms.Down):\n            self.user_zoom = True\n        if event.keyval == gtk.keysyms.r:\n            global window\n            window.on_toolbar_action(None, 'Reset', self.graph.on_original_graph, (widget,))\n            return\n        ret = xdot_ui_window.DotWidget.on_key_press_event(self, widget, event)\n        if event.keyval == gtk.keysyms.r:\n            self.user_zoom = False\n            self.zoom_to_fit()\n        return ret\n\n    def on_zoom_in(self, action):\n        self.user_zoom = True\n        return xdot_ui_window.DotWidget.on_zoom_in(self, action)\n\n    def on_zoom_out(self, action):\n        self.user_zoom = True\n        return xdot_ui_window.DotWidget.on_zoom_out(self, action)\n\n    def zoom_image(self, zoom_ratio, center=False, pos=None):\n        \"\"\"Overloaded zoom_image for scroll window.\"\"\"\n        if use_scroll_bars:\n            old_hadj_value = self.hadj.get_value()\n            old_vadj_value = self.vadj.get_value()\n            adj_zoom_ratio = zoom_ratio / self.zoom_ratio\n            self.zoom_ratio = zoom_ratio\n            self.zoom_to_fit_on_resize = False\n            self.queue_draw()\n            if center is False and pos is None:\n                allocation = self.viewport.get_allocation()\n                hspan = allocation[2]\n                hcenter = old_hadj_value + hspan / 2 - self.ZOOM_TO_FIT_MARGIN\n                vspan = allocation[3]\n                vcenter = old_vadj_value + vspan / 2 - self.ZOOM_TO_FIT_MARGIN\n                pos = (hcenter, vcenter)\n            if center is True:\n                self.x = self.graph.visible_width/2\n                self.y = self.graph.visible_height/2\n            elif pos is not None:\n                x, y = pos\n                allocation = self.viewport.get_allocation()\n                hspan = allocation[2]\n                vspan = allocation[3]\n                hpos = x * adj_zoom_ratio - hspan / 2.0 + self.ZOOM_TO_FIT_MARGIN\n                self.dotsw.get_hscrollbar().get_adjustment().set_value(hpos)\n                vpos = y * adj_zoom_ratio - vspan / 2.0 + self.ZOOM_TO_FIT_MARGIN\n                self.dotsw.get_vscrollbar().get_adjustment().set_value(vpos)\n        else:\n            return xdot_ui_window.DotWidget.zoom_image(self, zoom_ratio, center, pos)\n\n\n## The window object containing the STATDotWidget\nclass STATDotWindow(xdot_ui_window.DotWindow):\n    \"\"\"The window object containing the STATDotWidget\n\n    The STATDotWindow is derrived from xdot's DotWindow class.\n    It adds STAT specific operations to manipulate the graph.\n    \"\"\"\n\n    ## A notebook tab within the window, contains the STAT widget.\n    class Tab(object):\n        \"\"\"A notebook tab within the window, contains the STAT widget.\"\"\"\n\n        def __init__(self):\n            \"\"\"The constructor.\"\"\"\n            self.widget = STATDotWidget()\n            frame = gtk.Frame()\n            frame.set_size_request(60, 60)\n            if use_scroll_bars:\n                self.widget.dotsw = gtk.ScrolledWindow()\n                self.widget.dotsw.set_policy(gtk.POLICY_ALWAYS, gtk.POLICY_ALWAYS)\n                self.widget.viewport = gtk.Viewport()\n                self.widget.viewport.add(self.widget)\n                self.widget.dotsw.add(self.widget.viewport)\n                self.widget.hadj = self.widget.dotsw.get_hadjustment()\n                self.widget.vadj = self.widget.dotsw.get_vadjustment()\n                frame.add(self.widget.dotsw)\n            else:\n                frame.add(self.widget)\n            self.hpaned = gtk.HPaned()\n            self.hpaned.pack1(frame, True, True)\n            self.history_view = gtk.TextView()\n            self.history_view.set_wrap_mode(False)\n            self.history_view.set_editable(False)\n            self.history_view.set_cursor_visible(False)\n            self.history_view.get_buffer().set_text('')\n            sw = gtk.ScrolledWindow()\n            sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n            sw.add(self.history_view)\n            frame = gtk.Frame(label=\"Command History\")\n            frame.set_size_request(150, 60)\n            frame.add(sw)\n            self.hpaned.pack2(frame, False, True)\n            self.label = gtk.Label('new tab')\n\n    ui = ''\n    ui += '<ui>\\n'\n    ui += '    <menubar name=\"MenuBar\">\\n'\n    ui += '        <menu action=\"FileMenu\">\\n'\n    ui += '            <menuitem action=\"Open\"/>\\n'\n    ui += '            <menuitem action=\"SaveAs\"/>\\n'\n    ui += '            <separator/>\\n'\n    ui += '            <menuitem action=\"Prefs\"/>\\n'\n    ui += '            <menuitem action=\"SavePrefs\"/>\\n'\n    ui += '            <menuitem action=\"LoadPrefs\"/>\\n'\n    ui += '            <separator/>\\n'\n    ui += '            <menuitem action=\"SearchPath\"/>\\n'\n    ui += '            <menuitem action=\"CacheSources\"/>\\n'\n    ui += '            <separator/>\\n'\n    ui += '            <menuitem action=\"NewTab\"/>\\n'\n    ui += '            <menuitem action=\"ResetLayout\"/>\\n'\n    ui += '            <menuitem action=\"CloseTab\"/>\\n'\n    ui += '            <separator/>\\n'\n    ui += '            <menuitem action=\"Quit\"/>\\n'\n    ui += '        </menu>\\n'\n    ui += '        <menu action=\"EditMenu\">\\n'\n    ui += '            <menuitem action=\"Undo\"/>\\n'\n    ui += '            <menuitem action=\"Redo\"/>\\n'\n    ui += '        </menu>\\n'\n    ui += '        <menu action=\"ViewMenu\">\\n'\n    ui += '            <menuitem action=\"ZoomIn\"/>\\n'\n    ui += '            <menuitem action=\"ZoomOut\"/>\\n'\n    ui += '            <menuitem action=\"ZoomFit\"/>\\n'\n    ui += '            <menuitem action=\"Zoom100\"/>\\n'\n    ui += '        </menu>\\n'\n    ui += '        <menu action=\"HelpMenu\">\\n'\n    ui += '            <menuitem action=\"UserGuide\"/>\\n'\n    ui += '            <menuitem action=\"About\"/>\\n'\n    ui += '        </menu>\\n'\n    ui += '    </menubar>\\n'\n    ui += '    <toolbar name=\"ToolBar\">\\n'\n    ui += '        <toolitem action=\"Open\"/>\\n'\n    ui += '        <toolitem action=\"SaveAs\"/>\\n'\n    ui += '        <separator/>\\n'\n    ui += '        <toolitem action=\"Undo\"/>\\n'\n    ui += '        <toolitem action=\"Redo\"/>\\n'\n    ui += '        <toolitem action=\"OriginalGraph\"/>\\n'\n    ui += '        <toolitem action=\"ResetLayout\"/>\\n'\n#    ui += '        <toolitem action=\"HideMPI\"/>\\n'\n    ui += '        <toolitem action=\"HideModel\"/>\\n'\n#    ui += '        <toolitem action=\"HideText\"/>\\n'\n    ui += '        <toolitem action=\"Join\"/>\\n'\n    ui += '        <toolitem action=\"TraverseGraph\"/>\\n'\n    ui += '        <toolitem action=\"ShortestPath\"/>\\n'\n    ui += '        <toolitem action=\"LongestPath\"/>\\n'\n    ui += '        <toolitem action=\"LeastTasks\"/>\\n'\n    ui += '        <toolitem action=\"MostTasks\"/>\\n'\n    if HAVE_TOMOD:\n        ui += '        <toolitem action=\"TOTraverseLeastProgress\"/>\\n'\n        ui += '        <toolitem action=\"TOTraverseMostProgress\"/>\\n'\n    ui += '        <toolitem action=\"Search\"/>\\n'\n    ui += '        <toolitem action=\"IdentifyEqClasses\"/>\\n'\n    ui += '    </toolbar>\\n'\n    ui += '</ui>\\n'\n\n    def __init__(self, input_actions=None):\n        \"\"\"The constructor.\"\"\"\n        gtk.Window.__init__(self)\n        self.set_title('STATview')\n        self.set_default_size(1048, 600)\n        uimanager = gtk.UIManager()\n        accelgroup = uimanager.get_accel_group()\n        self.add_accel_group(accelgroup)\n        actiongroup = gtk.ActionGroup('Actions')\n        actions = []\n        actions.append(('FileMenu', None, '_File'))\n        actions.append(('EditMenu', None, '_Edit'))\n        actions.append(('ViewMenu', None, '_View'))\n        actions.append(('HelpMenu', None, '_Help'))\n        actions.append(('Open', gtk.STOCK_OPEN, '_Open', '<control>O', 'Open a file', self.on_open))\n        actions.append(('SaveAs', gtk.STOCK_SAVE_AS, '_SaveAs', '<control>S', 'Save current view as a file', self.on_save_as))\n        actions.append(('Prefs', gtk.STOCK_PROPERTIES, 'Preferences', '<control>P', 'Load saved preference settings', self.on_prefs))\n        actions.append(('SavePrefs', gtk.STOCK_SAVE_AS, 'Save Pr_eferences', '<control>E', 'Load saved preference settings', self.on_save_prefs))\n        actions.append(('LoadPrefs', gtk.STOCK_OPEN, '_Load Preferences', '<control>L', 'Save current preference settings', self.on_load_prefs))\n        actions.append(('SearchPath', gtk.STOCK_ADD, '_Add Search Paths', '<control>A', 'Add search paths for application source and header files', self.on_modify_search_paths))\n        actions.append(('CacheSources', gtk.STOCK_ADD, '_Cache Source Files', '<control>U', 'Cache all source files', self.on_cache_sources))\n        actions.append(('NewTab', gtk.STOCK_NEW, '_New Tab', '<control>T', 'Create new tab', lambda x: self.menu_item_response(gtk.STOCK_NEW, 'New Tab')))\n        actions.append(('CloseTab', gtk.STOCK_CLOSE, 'Close Tab', '<control>W', 'Close current tab', lambda x: self.menu_item_response(None, 'Close Tab')))\n        actions.append(('Quit', gtk.STOCK_QUIT, '_Quit', '<control>Q', 'Quit', self.on_destroy))\n        actions.append(('Undo', gtk.STOCK_UNDO, '_Undo', '<control>Z', 'Undo operation', lambda a: self.on_toolbar_action(a, None, self.get_current_graph().undo, ())))\n        actions.append(('Redo', gtk.STOCK_REDO, '_Redo', '<control>R', 'Redo operation', lambda a: self.on_toolbar_action(a, None, self.get_current_graph().redo, (self.get_current_widget(), ))))\n        actions.append(('OriginalGraph', gtk.STOCK_HOME, 'Reset', None, 'Revert to original graph', lambda a: self.on_toolbar_action(a, 'Original Graph', self.get_current_graph().on_original_graph, (self.get_current_widget(), ))))\n        actions.append(('ResetLayout', gtk.STOCK_REFRESH, 'Layout', None, 'Reset the layout of the current graph and open in a new tab', lambda a: self.on_reset_layout()))\n        actions.append(('HideModel', gtk.STOCK_CUT, 'Cut', None, 'Hide the details of various programming models', self.on_hide_model))\n#        actions.append(('HideMPI', gtk.STOCK_CUT, 'MPI', None, 'Hide the MPI implementation', lambda a: self.on_toolbar_action(a, 'Hide MPI', self.get_current_graph().hide_mpi, ())))\n        actions.append(('Join', gtk.STOCK_GOTO_TOP, 'Join', None, 'Join consecutive nodes of the same equivalence class into a single node and render in a new tab', self.on_join_eq_classes))\n        actions.append(('TraverseGraph', gtk.STOCK_GO_DOWN, 'Eq C', None, 'Traverse the graphs equivalence classes', self.on_traverse_graph))\n        if HAVE_TOMOD:\n            actions.append(('TOTraverseMostProgress', gtk.STOCK_MEDIA_NEXT, 'TO', None, 'Traverse the graph based on the most progressed temporal ordering', self.on_to_traverse_most_progress))\n            actions.append(('TOTraverseLeastProgress', gtk.STOCK_MEDIA_PREVIOUS, 'TO', None, 'Traverse the graph based on the least progressed temporal ordering', self.on_to_traverse_least_progress))\n        actions.append(('ShortestPath', gtk.STOCK_GOTO_TOP, 'Path', None, 'Traverse the [next] shortest path', self.on_shortest_path))\n        actions.append(('LongestPath', gtk.STOCK_GOTO_BOTTOM, 'Path', None, 'Traverse the [next] longest path', self.on_longest_path))\n        actions.append(('Search', gtk.STOCK_FIND, 'Search', None, 'Search for callpaths by text, tasks, or hosts', self.on_search))\n#        actions.append(('HideText', gtk.STOCK_CUT, 'Text', None, 'Cut the call graph based on a regular expression', self.on_hide_text))\n        actions.append(('LeastTasks', gtk.STOCK_GOTO_FIRST, 'Tasks', None, 'Traverse the path with the [next] least tasks visited', self.on_least_tasks))\n        actions.append(('MostTasks', gtk.STOCK_GOTO_LAST, 'Tasks', None, 'Traverse the path with the [next] most tasks visited', self.on_most_tasks))\n        actions.append(('IdentifyEqClasses', gtk.STOCK_SELECT_COLOR, 'Eq C', None, 'Identify the equivalence classes of the current graph', self.on_identify_num_eq_classes))\n        actions.append(('ZoomIn', gtk.STOCK_ZOOM_IN, None, None, None, self.on_zoom_in))\n        actions.append(('ZoomOut', gtk.STOCK_ZOOM_OUT, None, None, None, self.on_zoom_out))\n        actions.append(('ZoomFit', gtk.STOCK_ZOOM_FIT, None, None, None, self.on_zoom_fit))\n        actions.append(('Zoom100', gtk.STOCK_ZOOM_100, None, None, None, self.on_zoom_100))\n        actions.append(('UserGuide', gtk.STOCK_HELP, None, None, None, self.on_user_guide))\n        actions.append(('About', gtk.STOCK_ABOUT, None, None, None, self.on_about))\n        if input_actions is not None:\n            for action in input_actions:\n                action_text = action[0]\n                for a in actions:\n                    if a[0] == action_text:\n                        actions.remove(a)\n                        break\n                actions.append(action)\n        actiongroup.add_actions(actions)\n        uimanager.insert_action_group(actiongroup, 0)\n        uimanager.add_ui_from_string(self.ui)\n        toolbar = uimanager.get_widget('/ToolBar')\n        menubar = uimanager.get_widget('/MenuBar')\n        self.vbox = gtk.VBox()\n        self.add(self.vbox)\n        self.vbox.pack_start(menubar, False, True, 0)\n        hbox = gtk.HBox()\n        hbox.pack_start(toolbar, True, True, 0)\n        image = gtk.Image()\n        try:\n            if hasattr(gtk.gdk, \"pixbuf_new_from_file\"):\n                pixbuf = gtk.gdk.pixbuf_new_from_file(STAT_LOGO)\n            elif hasattr(gtk, \"Image\"):\n                image = gtk.Image()\n                image.set_from_file(STAT_LOGO)\n                pixbuf = image.get_pixbuf()\n            image.set_from_pixbuf(pixbuf)\n            hbox.pack_start(image, False, True, 0)\n        except gobject.GError:\n            pass\n        self.vbox.pack_start(hbox, False, True, 0)\n        self.tabs = []\n        self.notebook = gtk.Notebook()\n        self.create_new_tab()\n        self.notebook.set_tab_pos(gtk.POS_TOP)\n        self.notebook.set_scrollable(True)\n        try:\n            self.hbox.pack_start(self.notebook, True, True, 0)\n        except:\n            self.hbox = gtk.HBox()\n            self.hbox.pack_start(self.notebook, True, True, 0)\n        self.vbox.pack_start(self.hbox, True, True, 0)\n        if HAVE_TOMOD is True:\n            for path in search_paths['include']:\n                tomod.add_include_path(path)\n        self.search_types = []\n        help_string = \"\"\"Search for a specified task, range\nof tasks, or comma-separated list\nof tasks.  Example task lists:\n0\n0-10\n0-10,12,15-20\"\"\"\n        self.search_types.append(('tasks', self.search_tasks, help_string))\n        help_string = \"\"\"Search for callpaths containing the\nspecified text, which may be\nentered as a regular expression\"\"\"\n        self.search_types.append(('text', self.search_for_text, 'Search for callpaths containing the\\nspecified text, which may be\\nentered as a regular expression'))\n        if not hasattr(self, \"types\"):\n            self.types = {}\n        self.types[\"truncate\"] = [\"front\", \"rear\"]\n        if not hasattr(self, \"options\"):\n            self.options = {}\n        self.options[\"truncate\"] = \"front\"\n        self.options[\"max node name\"] = 64\n        self.options[\"maintain user zoom\"] = True\n        self.combo_boxes = {}\n        self.spinners = {}\n        self.entries = {}\n        self.show_all()\n\n    def update_option(self, w, label, parent_window, option):\n        \"\"\"Generate text entry dialog to update the specified option.\"\"\"\n        dialog = gtk.Dialog('Update %s' % option, parent_window)\n        entry = gtk.Entry()\n        entry.set_max_length(1024)\n        entry.set_text(self.options[option])\n        entry.connect(\"activate\", lambda w: self.on_update_option(w, entry, label, dialog, option))\n        dialog.vbox.pack_start(entry, True, True, 0)\n        hbox = gtk.HButtonBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: dialog.destroy())\n        hbox.pack_start(button, False, False, 0)\n        button = gtk.Button(stock=gtk.STOCK_OK)\n        button.connect(\"clicked\", lambda w: self.on_update_option(w, entry, label, dialog, option))\n        hbox.pack_start(button, False, False, 0)\n        dialog.vbox.pack_start(hbox, False, False, 0)\n        dialog.show_all()\n        dialog.run()\n\n    def on_update_option(self, w, entry, label, dialog, option):\n        \"\"\"Callback to update the specified option.\"\"\"\n        self.options[option] = entry.get_text()\n        entry.set_text('')\n        label.set_text('%s: %s' % (option, self.options[option]))\n        dialog.destroy()\n\n    def pack_entry_and_button(self, entry_text, function, frame, dialog, button_text, box, fill=False, center=False, pad=0):\n        \"\"\"Generates a text entry and activation button.\"\"\"\n        hbox = gtk.HBox()\n        entry = gtk.Entry()\n        entry.set_max_length(1024)\n        entry.set_text(entry_text)\n        entry.connect(\"activate\", lambda w: function(*(w, frame, dialog, entry)))\n        hbox.pack_start(entry, True, True, 0)\n        button = gtk.Button(button_text)\n        button.connect(\"clicked\", lambda w: function(*(w, frame, dialog, entry)))\n        hbox.pack_start(button, False, False, 0)\n        box.pack_start(hbox, fill, center, pad)\n        return entry\n\n    def pack_radio_buttons(self, box, option):\n        \"\"\"Pack a set of radio buttons for a specified option.\"\"\"\n        for option_type in self.types[option]:\n            if option_type == self.types[option][0]:\n                radio_button = gtk_wrap_new_with_label_from_widget(None, option_type)\n            else:\n                radio_button = gtk_wrap_new_with_label_from_widget(radio_button, option_type)\n            if option_type == self.options[option]:\n                radio_button.set_active(True)\n                self.toggle_radio_button(None, (option, option_type))\n            radio_button.connect('toggled', self.toggle_radio_button, (option, option_type))\n            box.pack_start(radio_button, False, False, 0)\n\n    def toggle_radio_button(self, action, data):\n        \"\"\"Callback to toggle on/off a radio button.\"\"\"\n        option, option_type = data\n        self.options[option] = option_type\n\n    def pack_spinbutton(self, box, option):\n        \"\"\"Pack a spin button into the spcified box for the specified option.\"\"\"\n        hbox = gtk.HBox()\n        label = gtk.Label(option)\n        hbox.pack_start(label, False, False, 0)\n        adj = gtk.Adjustment(1.0, 0.0, 1000000.0, 1.0, 100.0, 0.0)\n        spinner = gtk.SpinButton(adjustment=adj, climb_rate=0, digits=0)\n        spinner.set_value(self.options[option])\n        hbox.pack_start(spinner, False, False, 0)\n        box.pack_start(hbox, False, False, 0)\n        self.spinners[option] = spinner\n\n    def pack_combo_box(self, box, option):\n        \"\"\"Pack a combo box into the spcified box for the specified option.\"\"\"\n        hbox = gtk.HBox()\n        hbox.pack_start(gtk.Label(\"Specify %s:\" % option), False, False, 0)\n        combo_box = gtk.combo_box_new_text()\n        for type in self.types[option]:\n            combo_box.append_text(type)\n        combo_box.set_active(self.types[option].index(self.options[option]))\n        hbox.pack_start(combo_box, False, False, 10)\n        self.combo_boxes[option] = combo_box\n        box.pack_start(hbox, False, False, 0)\n\n    def pack_check_button(self, box, option, center=False, expand=False, pad=0):\n        \"\"\"Pack a check button into the specified box for the specified option.\"\"\"\n        check_button = gtk.CheckButton(option)\n        if self.options[option] is True:\n            check_button.set_active(True)\n        else:\n            check_button.set_active(False)\n        check_button.connect('toggled', lambda w: self.on_toggle_check_button(w, option))\n        box.pack_start(check_button, center, expand, pad)\n\n    def on_toggle_check_button(self, widget, option):\n        \"\"\"Callback to toggle on/off a check button.\"\"\"\n        if self.options[option] is True:\n            self.options[option] = False\n        else:\n            self.options[option] = True\n\n    def pack_string_option(self, box, option, parent_window):\n        \"\"\"Pack a button into the specified box that generates a text entry dialog for the specified option.\"\"\"\n        hbox = gtk.HBox()\n        label = gtk.Label('%s: %s' % (option, self.options[option]))\n        hbox.pack_start(label, False, False, 0)\n        box.pack_start(hbox, False, False, 10)\n        button = gtk.Button('Modify %s' % option)\n        button.connect(\"clicked\", lambda w: self.update_option(w, label, parent_window, option))\n        box.pack_start(button, False, False, 0)\n\n    def update_prefs_cb(self, w, dialog):\n        dialog.hide()\n        try:\n            self.options['max node name'] = int(self.spinners['max node name'].get_value())\n            self.options['truncate'] = self.types[\"truncate\"][self.combo_boxes['truncate'].get_active()]\n        except:\n            pass\n\n    def on_prefs(self, action):\n        dialog = gtk.Dialog('Preferences', self)\n        options = [\"truncate\", \"max node name\", \"maintain user zoom\"]\n        for option in options:\n            if type(self.options[option]) == int:\n                self.pack_spinbutton(dialog.vbox, option)\n            elif type(self.options[option]) == bool:\n                self.pack_check_button(dialog.vbox, option)\n            elif type(self.options[option]) == str:\n                if option in self.types:\n                    self.pack_combo_box(dialog.vbox, option)\n                else:\n                    self.pack_string_option(dialog.vbox, option, dialog)\n        hbox = gtk.HButtonBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: dialog.destroy())\n        hbox.pack_start(button, False, True, 0)\n        button = gtk.Button(stock=gtk.STOCK_OK)\n        button.connect(\"clicked\", lambda w: self.update_prefs_cb(w, dialog))\n        hbox.pack_start(button, False, True, 0)\n        dialog.vbox.pack_start(hbox, False, False, 0)\n        dialog.show_all()\n        dialog.run()\n\n    def on_load_prefs(self, action):\n        \"\"\"Load user-saved preferences from a file.\"\"\"\n        myaction = gtk.FILE_CHOOSER_ACTION_OPEN\n        chooser = gtk.FileChooserDialog(title=\"Load Preferences\", action=myaction, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_SAVE_AS, gtk.RESPONSE_OK))\n        chooser.set_default_response(gtk.RESPONSE_OK)\n        file_filter = gtk.FileFilter()\n        file_filter.set_name('STAT Prefs File')\n        file_filter.add_pattern(\"*.SPF\")\n        chooser.add_filter(file_filter)\n        file_filter = gtk.FileFilter()\n        file_filter.set_name('All files')\n        file_filter.add_pattern(\"*\")\n        chooser.add_filter(file_filter)\n        chooser.set_current_folder('%s/.STAT' % os.environ['HOME'])\n        if chooser.run() == gtk.RESPONSE_OK:\n            filename = chooser.get_filename()\n            try:\n                shelf = shelve.open(filename)\n                for key in self.options.keys():\n                    self.options[key] = shelf[key]\n                shelf.close()\n            except IOError as e:\n                show_error_dialog('%s\\nFailed to load preferences file %s\\n' % (repr(e), filename), self)\n            except Exception as e:\n                show_error_dialog('%s\\nFailed to process preferences file %s\\n' % (repr(e), filename), self)\n        chooser.destroy()\n\n    def on_save_prefs(self, action):\n        \"\"\"Save user preferences to a file.\"\"\"\n        chooser = gtk.FileChooserDialog(title=\"Save Preferences\", action=gtk.FILE_CHOOSER_ACTION_SAVE, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_SAVE_AS, gtk.RESPONSE_OK))\n        chooser.set_default_response(gtk.RESPONSE_OK)\n        chooser.set_do_overwrite_confirmation(True)\n        file_filter = gtk.FileFilter()\n        file_filter.set_name('STAT Prefs File')\n        file_filter.add_pattern(\"*.SPF\")\n        chooser.add_filter(file_filter)\n        file_filter = gtk.FileFilter()\n        file_filter.set_name('All files')\n        file_filter.add_pattern(\"*\")\n        chooser.add_filter(file_filter)\n        chooser.set_current_folder('%s/.STAT' % os.environ['HOME'])\n        if chooser.run() == gtk.RESPONSE_OK:\n            file_filter = chooser.get_filter()\n            ext = ''\n            if file_filter.get_name() == 'STAT Prefs File':\n                ext = '.SPF'\n            filename = chooser.get_filename()\n            if filename[-4:] != \".SPF\":\n                filename = filename + ext\n            saved_options = {}\n            if os.path.exists(filename):\n                # do not delete options that aren't currently set\n                try:\n                    shelf = shelve.open(filename)\n                    for key in self.options.keys():\n                        if not key in self.options:\n                            saved_options[key] = shelf[key]\n                    shelf.close()\n                except:\n                    pass\n            try:\n                shelf = shelve.open(filename)\n                for key in saved_options.keys():\n                    shelf[key] = self.options[key]\n                for key in self.options.keys():\n                    shelf[key] = self.options[key]\n                shelf.close()\n            except IOError as e:\n                show_error_dialog('%s\\nFailed to save preferences file %s\\n' % (repr(e), filename), self)\n            except Exception as e:\n                show_error_dialog('%s\\nFailed to save preferences file %s\\n' % (repr(e), filename), self)\n        chooser.destroy()\n\n    def on_destroy(self, action):\n        \"\"\"Destroy the window.\"\"\"\n        gtk.main_quit()\n\n    def create_new_tab(self, page=-1):\n        \"\"\"Create a new notebook tab.\"\"\"\n        new_tab = STATDotWindow.Tab()\n        tab_label_box = gtk.EventBox()\n        tab_label_box.add(new_tab.label)\n        tab_label_box.connect('event', self.on_tab_clicked, new_tab.widget)\n        new_tab.label.show()\n        new_tab.widget.connect('clicked', self.on_node_clicked)\n        if page == -1:\n            page = len(self.tabs)\n        self.notebook.insert_page(new_tab.hpaned, tab_label_box, page)\n        self.tabs.insert(page, new_tab)\n        self.set_focus(new_tab.widget)\n        self.show_all()\n\n    def on_tab_clicked(self, widget, event, child):\n        \"\"\"Switch the focus to the clicked tab.\"\"\"\n        if event.type == gtk.gdk.BUTTON_PRESS:\n            n = -1\n            for tab in self.tabs:\n                n += 1\n                if child == tab.widget:\n                    break\n            self.notebook.set_current_page(n)\n            if hasattr(event.button, 'button'):\n                button = event.button.button\n            else:\n                button = event.button\n            if button == 3:\n                options = ['New Tab', 'Close Tab']\n                menu = gtk.Menu()\n                for option in options:\n                    menu_item = gtk.MenuItem(option)\n                    menu.append(menu_item)\n                    menu_item.connect('activate', self.menu_item_response, option)\n                    menu_item.show()\n                try:\n                    menu.popup(None, None, None, None, button, event.time)\n                except:\n                    menu.popup(None, None, None, event.button, event.time)\n\n    def get_current_widget(self):\n        \"\"\"Get the widget of the current tab.\"\"\"\n        return self.tabs[self.notebook.get_current_page()].widget\n\n    def get_current_graph(self):\n        \"\"\"Get the graph of the current tab.\"\"\"\n        return self.tabs[self.notebook.get_current_page()].widget.graph\n\n    def menu_item_response(self, widget, option):\n        \"\"\"Handle tab menu responses.\"\"\"\n        if option == \"New Tab\":\n            page = self.notebook.get_current_page()\n            self.create_new_tab(page + 1)\n            self.notebook.set_current_page(page + 1)\n        elif option == \"Close Tab\":\n            if len(self.tabs) == 1:\n                self.create_new_tab()\n                page = 0\n            else:\n                page = self.notebook.get_current_page()\n            self.notebook.remove_page(page)\n            self.tabs.remove(self.tabs[page])\n\n    def on_user_guide(self, action):\n        \"\"\"Display the user guide.\"\"\"\n        user_guide_path = os.path.join(os.path.dirname(__file__), '../../../doc/stat_userguide.pdf')\n        if not os.path.exists(user_guide_path):\n            show_error_dialog('Failed to find STAT user guide %s' % user_guide_path, self)\n            return False\n        pdfviewer = which('evince')\n        if pdfviewer is None:\n            pdfviewer = which('xpdf')\n            if pdfviewer is None:\n                pdfviewer = which('acroread')\n                if pdfviewer is None:\n                    show_error_dialog('Failed to find PDF viewer', self)\n                return False\n        if os.fork() == 0:\n            subprocess.call([pdfviewer, user_guide_path])\n            sys.exit(0)\n\n    def on_about(self, action):\n        \"\"\"Display info about STAT\"\"\"\n        about_dialog = gtk.AboutDialog()\n        about_dialog.set_name('STATview')\n        about_dialog.set_authors(__author__)\n        about_dialog.set_copyright(__copyright__)\n        about_dialog.set_license(__license__)\n        about_dialog.set_wrap_license(80)\n        try:\n            if hasattr(gtk.gdk, \"pixbuf_new_from_file\"):\n                pixbuf = gtk.gdk.pixbuf_new_from_file(STAT_LOGO)\n            elif hasattr(gtk, \"Image\"):\n                image = gtk.Image()\n                image.set_from_file(STAT_LOGO)\n                pixbuf = image.get_pixbuf()\n            about_dialog.set_logo(pixbuf)\n        except gobject.GError:\n            pass\n        about_dialog.set_website('https://github.com/lee218llnl/STAT')\n        about_dialog.show_all()\n        about_dialog.run()\n        about_dialog.destroy()\n\n    def on_zoom_in(self, action):\n        \"\"\"Zoom in on the current tab's graph.\"\"\"\n        self.get_current_widget().on_zoom_in(action)\n\n    def on_zoom_out(self, action):\n        \"\"\"Zoom out of the current tab's graph.\"\"\"\n        self.get_current_widget().on_zoom_out(action)\n\n    def on_zoom_fit(self, action):\n        \"\"\"Zoom to best fit of the current tab's graph.\"\"\"\n        self.get_current_widget().on_zoom_fit(action)\n\n    def on_zoom_100(self, action):\n        \"\"\"Zoom to full size of the current tab's graph.\"\"\"\n        self.get_current_widget().on_zoom_100(action)\n\n    def set_dotcode(self, dotcode, filename='<stdin>', page=-1):\n        \"\"\"Set the dotcode of the specified tab's widget.\"\"\"\n        try:\n            if self.tabs[page].widget.set_dotcode(dotcode, filename, self.options[\"truncate\"], self.options[\"max node name\"]):\n                self.tabs[page].label.set_text(os.path.basename(filename))\n                self.tabs[page].widget.zoom_to_fit()\n        except Exception as e:\n            show_error_dialog('%s\\nFailed to open file:\\n\\n%s\\n\\nPlease be sure the file exists and is a valid STAT outputted dot file.' % (repr(e), filename), exception=e)\n\n    def open_file(self, filename):\n        \"\"\"Open a dot file and set the dotcode for the current tab.\"\"\"\n        try:\n            with open(filename, 'r') as f:\n                stat_wait_dialog.show_wait_dialog_and_run(self.set_dotcode, (f.read(), filename, self.notebook.get_current_page()), ['Opening DOT File'], self)\n        except IOError as e:\n            show_error_dialog('%s\\nFailed to open file:\\n\\n%s\\n\\nPlease be sure the file exists and is a valid STAT outputted dot file.' % (repr(e), filename), exception=e)\n        except Exception as e:\n            show_error_dialog('%s\\nFailed to process file:\\n\\n%s\\n\\nPlease be sure the file exists and is a valid STAT outputted dot file.' % (repr(e), filename), exception=e)\n        self.show_all()\n        self.update_history()\n\n    def on_open(self, action):\n        \"\"\"Callback to generate an open file dialog.\"\"\"\n        chooser = gtk.FileChooserDialog(title=\"Open dot File\",\n                                        action=gtk.FILE_CHOOSER_ACTION_OPEN,\n                                        buttons=(gtk.STOCK_CANCEL,\n                                                 gtk.RESPONSE_CANCEL,\n                                                 gtk.STOCK_OPEN,\n                                                 gtk.RESPONSE_OK))\n        chooser.set_default_response(gtk.RESPONSE_OK)\n        chooser.set_current_folder(os.getcwd())\n        chooser.set_select_multiple(True)\n        file_filter = gtk.FileFilter()\n        file_filter.set_name(\"Graphviz dot files\")\n        file_filter.add_pattern(\"*.dot\")\n        chooser.add_filter(file_filter)\n        file_filter = gtk.FileFilter()\n        file_filter.set_name(\"All files\")\n        file_filter.add_pattern(\"*\")\n        chooser.add_filter(file_filter)\n        if chooser.run() == gtk.RESPONSE_OK:\n            filenames = chooser.get_filenames()\n            chooser.destroy()\n            for filename in filenames:\n                if filename != filenames[0]:\n                    self.create_new_tab(self.notebook.get_current_page() + 1)\n                self.notebook.set_current_page(self.notebook.get_current_page() + 1)\n                self.open_file(filename)\n        else:\n            chooser.destroy()\n\n    def update_history(self):\n        \"\"\"Update the action history of the current tab.\"\"\"\n        history_string = ''\n        for command in self.get_current_graph().action_history:\n            history_string += command + '\\n'\n        self.tabs[self.notebook.get_current_page()].history_view.get_buffer().set_text(history_string)\n        self.show_all()\n\n    def save_file(self, filename):\n        \"\"\"Save the current graph to a dot or image file.\"\"\"\n        ret = self.get_current_graph().save_file(filename)\n        return ret\n\n    def save_type_toggle_cb(self, widget, data=None):\n        \"\"\"Callback to toggle the file format.\"\"\"\n        self.ext_type = data\n\n    def file_extension_ok_cb(self, widget, data=None):\n        \"\"\"Callback to confirm the file format.\"\"\"\n        self.ext_dialog.destroy()\n        self.chooser.destroy()\n        self.on_save_as(None, data[0], os.path.basename('%s.%s' % (data[1], self.ext_type)))\n\n    def on_save_as(self, action, directory='', filename=''):\n        \"\"\"Callback to generate save dialog.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        file_extensions = ['dot graph file', 'gif image file', 'pdf document file', 'png image file', 'jpg image file', 'fig figure file', 'ps image file', 'perf-folded trace file']\n        short_file_extensions = []\n        for file_extension in file_extensions:\n            short_file_extensions.append('.' + file_extension.split()[0])\n        self.chooser = gtk.FileChooserDialog(title=\"Save File\",\n                                             action=gtk.FILE_CHOOSER_ACTION_SAVE,\n                                             buttons=(gtk.STOCK_CANCEL,\n                                                      gtk.RESPONSE_CANCEL,\n                                                      gtk.STOCK_SAVE_AS,\n                                                      gtk.RESPONSE_OK))\n        self.chooser.set_default_response(gtk.RESPONSE_OK)\n        self.chooser.set_current_folder(os.getcwd())\n        self.chooser.set_do_overwrite_confirmation(True)\n        for extension in file_extensions:\n            file_filter = gtk.FileFilter()\n            file_filter.set_name(extension)\n            file_filter.add_pattern(\"*.%s\" % extension.split()[0])\n            self.chooser.add_filter(file_filter)\n        file_filter = gtk.FileFilter()\n        file_filter.set_name(\"All files\")\n        file_filter.add_pattern(\"*\")\n        self.chooser.add_filter(file_filter)\n        if directory != '':\n            self.chooser.set_current_folder(directory)\n        if filename != '':\n            self.chooser.set_current_name(filename)\n        if self.chooser.run() == gtk.RESPONSE_OK:\n            file_filter = self.chooser.get_filter()\n            file_type = file_filter.get_name()\n            folder = self.chooser.get_current_folder()\n            filename = self.chooser.get_filename()\n            if not os.path.splitext(filename)[1] in short_file_extensions and file_type == 'All files':\n                self.ext_type = 'dot'\n                self.ext_dialog = gtk.Dialog(\"Choose Extension\", self)\n                self.ext_dialog.set_default_size(300, 80)\n                ext_frame = gtk.Frame(label=\"File type explanation\")\n                explanation = 'Saving as an AT&T dot format graph file allows the file to be reopened by this application.  Saving as an image or document file generates a file that can be easily viewed by other users and on other systems, but can not be manipulated by this application.'\n                ext_explanation = gtk.Label(explanation)\n                ext_explanation.set_line_wrap(True)\n                ext_frame.add(ext_explanation)\n                self.ext_dialog.vbox.pack_start(ext_frame, False, False, 0)\n                ext_vbox2 = gtk.VBox(False, 0)\n                for extension in file_extensions:\n                    if extension == file_extensions[0]:\n                        radio_button = gtk_wrap_new_with_label_from_widget(None, extension)\n                        radio_button.set_active(True)\n                    else:\n                        radio_button = gtk_wrap_new_with_label_from_widget(radio_button, extension)\n                    radio_button.connect(\"toggled\", self.save_type_toggle_cb, extension.split()[0])\n                    ext_vbox2.pack_start(radio_button, False, True, 5)\n\n                self.ext_dialog.vbox.pack_start(ext_vbox2, False, False, 0)\n                ext_hbox2 = gtk.HBox(False, 0)\n                ok_button = gtk.Button(stock=gtk.STOCK_OK)\n                ok_button.connect(\"clicked\", self.file_extension_ok_cb, [folder, filename])\n                ext_hbox2.pack_end(ok_button, False, False, 0)\n                self.ext_dialog.vbox.pack_end(ext_hbox2, False, False, 0)\n                self.ext_dialog.show_all()\n            elif not os.path.splitext(filename)[1] in short_file_extensions and file_type != 'All files':\n                ret = self.save_file(filename + '.' + file_type.split()[0])\n                if ret is False:\n                    show_error_dialog('failed to save file \"%s\"' % filename + '.' + file_type.split()[0], self)\n                self.chooser.destroy()\n            else:\n                ret = self.save_file(filename)\n                if ret is False:\n                    show_error_dialog('failed to save file \"%s\"' % filename + '.' + file_type.split()[0], self)\n                self.chooser.destroy()\n        else:\n            self.chooser.destroy()\n\n    def on_reset_layout(self):\n        temp_dot_filename = 'redraw.dot'\n        try:\n            temp_dot_file = open(temp_dot_filename, 'w')\n        except:\n            home_dir = os.environ.get(\"HOME\")\n            temp_dot_filename = '%s/redraw.dot' % home_dir\n            try:\n                temp_dot_file = open(temp_dot_filename, 'w')\n            except Exception as e:\n                show_error_dialog('Failed to open temp dot file %s for writing' % temp_dot_filename, exception=e)\n                return False\n        temp_dot_file.close()\n        self.get_current_graph().save_dot(temp_dot_filename)\n        page = self.notebook.get_current_page()\n        self.create_new_tab(page + 1)\n        self.notebook.set_current_page(page + 1)\n        self.open_file(temp_dot_filename)\n        os.remove(temp_dot_filename)\n        return True\n\n    def on_translate(self):\n        if hasattr(self, \"my_dialog\"):\n            self.my_dialog.destroy()\n        temp_dot_filename = 'translated.dot'\n        try:\n            temp_dot_file = open(temp_dot_filename, 'w')\n        except:\n            home_dir = os.environ.get(\"HOME\")\n            temp_dot_filename = '%s/tranlsated.dot' % home_dir\n            try:\n                temp_dot_file = open(temp_dot_filename, 'w')\n            except Exception as e:\n                show_error_dialog('Failed to open temp dot file %s for writing' % temp_dot_filename, exception=e)\n                return False\n        temp_dot_file.close()\n        self.get_current_graph().save_dot(temp_dot_filename, True, True, True)\n        page = self.notebook.get_current_page()\n        self.create_new_tab(page + 1)\n        self.notebook.set_current_page(page + 1)\n        self.open_file(temp_dot_filename)\n        os.remove(temp_dot_filename)\n        return True\n\n    def on_cache_sources(self, action):\n        \"\"\"Callback to cache all source files found in this .dot file.\"\"\"\n        current_graph = self.get_current_graph()\n        file_dir, file_name = dot_file_path_split(current_graph)\n        if file_dir is None or file_dir == '':\n            show_error_dialog('unable to determine directory of .dot file, STAT will not cache sources')\n            return False\n        source_files = set()\n        for node in current_graph.nodes:\n            source_file_path = node.attrs['source']\n            if source_file_path != '' and os.path.exists(source_file_path):\n                source_files.add(source_file_path)\n        cache_directory_path = os.path.abspath(os.path.join(file_dir, cache_directory))\n        if not os.path.exists(cache_directory_path):\n            try:\n                os.makedirs(cache_directory_path)\n            except Exception as e:\n                show_error_dialog('Failed to create cache directory %s' % cache_directory_path, exception=e)\n                return False\n        for source_file in source_files:\n            cache_file_path = cache_directory_path + '/' + source_file\n            cache_file_dir, cache_file_name = os.path.split(cache_file_path)\n            if not os.path.exists(cache_file_path):\n                try:\n                    if not os.path.exists(cache_file_dir):\n                        os.makedirs(cache_file_dir)\n                    shutil.copyfile(source_file, cache_file_path)\n                except Exception as e:\n                    show_error_dialog('Failed to copy %s to %s' % (source_file, cache_file_path), exception=e)\n                    return False\n\n\n    def on_modify_search_paths(self, action):\n        \"\"\"Callback to generate dialog to modify search paths.\"\"\"\n        search_dialog = gtk.Dialog('add file search path', self)\n        frame = gtk.Frame(label=\"Current Search Paths\")\n        hpaned = gtk.HPaned()\n        path_views = {}\n        for path_type2 in [\"source\", \"include\"]:\n            frame2 = gtk.Frame(label=path_type2)\n            path_view = gtk.TextView()\n            path_view.set_size_request(400, 200)\n            path_view.set_wrap_mode(False)\n            path_view.set_editable(False)\n            path_view.set_cursor_visible(False)\n            paths_string = ''\n            for path in search_paths[path_type2]:\n                paths_string += path + '\\n'\n            path_view.get_buffer().set_text(paths_string)\n            sw = gtk.ScrolledWindow()\n            sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n            sw.add(path_view)\n            path_views[path_type2] = path_view\n            frame2.add(sw)\n            if path_type2 == \"source\":\n                hpaned.pack1(frame2, True, True)\n            else:\n                hpaned.pack2(frame2, True, True)\n        frame.add(hpaned)\n        search_dialog.vbox.pack_start(frame, True, True, 0)\n        separator = gtk.HSeparator()\n        search_dialog.vbox.pack_start(separator, False, True, 5)\n        vbox = gtk.VBox(False, 0)\n        frame = gtk.Frame(label=\"Add Search Paths\")\n        entry = gtk.Entry()\n        entry.set_max_length(65536)\n        check_buttons = {}\n        source_check_button = gtk.CheckButton(\"Add to Source search path\")\n        source_check_button.set_active(True)\n        source_check_button.connect('toggled', lambda x: x)\n        vbox.pack_start(source_check_button, False, False, 0)\n        check_buttons[\"source\"] = source_check_button\n        include_check_button = gtk.CheckButton(\"Add to Include search path\")\n        include_check_button.set_active(False)\n        include_check_button.connect('toggled', lambda x: x)\n        vbox.pack_start(include_check_button, False, False, 0)\n        check_buttons[\"include\"] = include_check_button\n        recurse_check_button = gtk.CheckButton(\"Recursively add sub directories\")\n        recurse_check_button.set_active(False)\n        recurse_check_button.connect('toggled', lambda x: x)\n        vbox.pack_start(recurse_check_button, False, False, 0)\n        check_buttons[\"recurse\"] = recurse_check_button\n        entry.connect(\"activate\", self.on_search_path_enter_cb, entry, path_views, check_buttons, search_dialog)\n        vbox.pack_start(entry, False, False, 0)\n        hbox = gtk.HButtonBox()\n        button = gtk.Button(\" Add \")\n        button.connect(\"clicked\", self.on_search_path_enter_cb, entry, path_views, check_buttons, search_dialog)\n        hbox.pack_start(button, False, False, 0)\n        vbox.pack_end(hbox, False, False, 0)\n        frame.add(vbox)\n        search_dialog.vbox.pack_start(frame, False, False, 0)\n        hbox = gtk.HButtonBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: search_dialog.destroy())\n        hbox.pack_end(button, False, False, 0)\n        button = gtk.Button(stock=gtk.STOCK_OK)\n        button.connect(\"clicked\", lambda w: self.on_search_path_enter_cb(w, entry, path_views, check_buttons, search_dialog, True))\n        hbox.pack_end(button, False, False, 0)\n        search_dialog.vbox.pack_end(hbox, False, False, 0)\n        search_dialog.set_focus(entry)\n        search_dialog.show_all()\n\n    def on_search_path_enter_cb(self, widget, entry, path_views, check_buttons, search_dialog, destroy=False):\n        \"\"\"Callback to handle activation of search path text entry.\"\"\"\n        path = entry.get_text()\n        entry.set_text('')\n        paths = []\n        if path == '' and destroy is True:\n            search_dialog.hide()\n            return\n        elif path == '' and destroy is False:\n            return\n        if not os.path.exists(path):\n            show_error_dialog('directory \"%s\" does not exist' % path, self)\n            return\n        if check_buttons[\"recurse\"].get_active():\n            for p, d, f in os.walk(path):\n                paths.append(p)\n        else:\n            paths.append(path)\n        for path in paths:\n            for path_type2 in [\"source\", \"include\"]:\n                if not check_buttons[path_type2].get_active():\n                    continue\n                if path_type2 == 'include':\n                    tomod.add_include_path(path)\n                search_paths[path_type2].append(path)\n                paths_string = ''\n                for path in search_paths[path_type2]:\n                    paths_string += path + '\\n'\n                path_views[path_type2].get_buffer().set_text(paths_string)\n        if destroy is True:\n            search_dialog.hide()\n            return\n        search_dialog.show_all()\n\n    def on_toolbar_action(self, action, name, function, args):\n        \"\"\"Callback to handle action initiated from the toolbar.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        if name is not None:\n            self.get_current_graph().set_undo_list()\n        ret = function(*args)\n        if ret is True:\n            if name is not None:\n                self.get_current_graph().action_history.append(name)\n            self.update_history()\n            global window\n            if self.get_current_widget().user_zoom is True and window.options[\"maintain user zoom\"] is True and (function == self.get_current_graph().undo or function == self.get_current_graph().redo):\n                self.get_current_widget().queue_draw()\n            else:\n                self.get_current_graph().adjust_dims()\n                self.get_current_widget().zoom_to_fit()\n        else:\n            self.get_current_graph().undo(False)\n        return True\n\n    def on_traverse_graph(self, action):\n        \"\"\"Callback to handle pressing of eq class traversal button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        self.get_current_graph().set_undo_list()\n        traversal_depth = 1\n        try:\n            action_history_top = self.get_current_graph().action_history[-1]\n            if action_history_top.find('Traverse Graph ') != -1:\n                traversal_depth = int(action_history_top.strip('Traverse Graph ')) + 1\n        except:\n            traversal_depth = 1\n        ret = self.get_current_graph().traverse(self.get_current_widget(), traversal_depth)\n        if ret is True:\n            self.get_current_graph().action_history.append('Traverse Graph %d' % traversal_depth)\n            self.update_history()\n            self.get_current_graph().adjust_dims()\n            self.get_current_widget().zoom_to_fit()\n        else:\n            self.get_current_graph().undo(False)\n        return ret\n\n    def on_to_traverse_least_progress(self, action):\n        \"\"\"Callback to handle pressing of least progress traversal button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        self.get_current_graph().set_undo_list()\n        traversal_depth = 1\n        try:\n            action_history_top = self.get_current_graph().action_history[-1]\n            if action_history_top.find('Traverse Least Progress ') != -1:\n                traversal_depth = int(action_history_top.strip('Traverse Least Progress ')) + 1\n        except:\n            traversal_depth = 1\n        ret = self.get_current_graph().to_traverse_least_progress(self.get_current_widget(), traversal_depth)\n        self.get_current_graph().action_history.append('Traverse Least Progress %d' % traversal_depth)\n        self.update_history()\n        self.get_current_graph().adjust_dims()\n        self.get_current_widget().zoom_to_fit()\n        return ret\n\n    def on_to_traverse_most_progress(self, action):\n        \"\"\"Callback to handle pressing of most progress traversal button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        self.get_current_graph().set_undo_list()\n        traversal_depth = 1\n        try:\n            action_history_top = self.get_current_graph().action_history[-1]\n            if action_history_top.find('Traverse Most Progress ') != -1:\n                traversal_depth = int(action_history_top.strip('Traverse Most Progress ')) + 1\n        except:\n            traversal_depth = 1\n        ret = self.get_current_graph().to_traverse_most_progress(self.get_current_widget(), traversal_depth)\n        self.get_current_graph().action_history.append('Traverse Most Progress %d' % traversal_depth)\n        self.update_history()\n        self.get_current_graph().adjust_dims()\n        self.get_current_widget().zoom_to_fit()\n        return ret\n\n    def search_tasks(self, text, dummy=None):\n        self.get_current_graph().focus_tasks(text)\n\n    def search_for_text(self, text, match_case_check_box):\n        self.get_current_graph().focus_text(text, match_case_check_box.get_active())\n        highlight_list = []\n        search_text = text\n        if match_case_check_box.get_active() is False:\n            search_text = string.lower(text)\n        for node in self.get_current_graph().nodes:\n            node_text = node.attrs[\"label\"]\n            if match_case_check_box.get_active() is False:\n                node_text = string.lower(node.attrs[\"label\"])\n            if node_text.find(search_text) != -1 and node.hide is False:\n                highlight_list.append(node)\n        self.tabs[self.notebook.get_current_page()].widget.set_highlight(highlight_list)\n\n    def on_search_enter_cb(self, widget, arg):\n        \"\"\"Callback to handle activation of focus task text entry.\"\"\"\n        entry, combo_box, match_case_check_box = arg\n        text = entry.get_text()\n        s_type, search_cb, search_help = self.search_types[combo_box.get_active()]\n        self.get_current_graph().set_undo_list()\n        self.get_current_graph().action_history.append('Search for %s: %s' % (s_type, text))\n        self.update_history()\n        search_cb(text, match_case_check_box)\n        self.get_current_graph().adjust_dims()\n        self.get_current_widget().zoom_to_fit()\n        self.task_dialog.destroy()\n        return True\n\n    def on_search_type_toggled(self, combo_box, label):\n        s_type, search_cb, search_help = self.search_types[combo_box.get_active()]\n        label.set_text(search_help)\n\n    def on_hide_model(self, action):\n        \"\"\"Callback to handle pressing of cut model button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        if not hasattr(self, 'programming_models'):\n            self.programming_models = []\n            site_models_path = os.path.dirname(os.path.realpath(__file__)) + '/../../../etc/STAT/STATview_models.conf'\n            self.programming_models += load_model_cuts(site_models_path)\n            user_models_path = '%s/.STATview_models.conf' % (os.environ.get('HOME'))\n            self.programming_models += load_model_cuts(user_models_path)\n        self.model_dialog = gtk.Dialog('Hide Programming Model Frames', self)\n        self.model_dialog.set_default_size(400, 400)\n        frame = gtk.Frame(label=\"Programming Models\")\n        vbox = gtk.VBox()\n\n        sw = gtk.ScrolledWindow()\n        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)\n        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n        list_store = gtk.ListStore(gobject.TYPE_BOOLEAN, gobject.TYPE_STRING, gobject.TYPE_BOOLEAN, gobject.TYPE_STRING, gobject.TYPE_BOOLEAN, gobject.TYPE_BOOLEAN, gobject.TYPE_PYOBJECT, gobject.TYPE_STRING, gobject.TYPE_STRING, gobject.TYPE_STRING)\n        for programming_model in self.programming_models:\n            iterator = list_store.append()\n            list_store.set(iterator, MODEL_INDEX_NAME, programming_model[MODEL_INDEX_NAME], MODEL_INDEX_CASESENSITIVE, programming_model[MODEL_INDEX_CASESENSITIVE], MODEL_INDEX_REGEX, programming_model[MODEL_INDEX_REGEX], MODEL_INDEX_EDITABLE, programming_model[MODEL_INDEX_EDITABLE], MODEL_INDEX_NOTEDITABLE, programming_model[MODEL_INDEX_NOTEDITABLE], MODEL_INDEX_CALLBACK, self.hide_model_callback, MODEL_INDEX_ICON, gtk.STOCK_CUT)\n        treeview = gtk.TreeView(list_store)\n        treeview.set_rules_hint(False)\n        treeview.set_enable_search(False)\n        treeview.get_selection().set_mode(gtk.SELECTION_SINGLE)\n\n        # column for the hide button\n        renderer = CellRendererButtonPixbuf()\n        renderer.set_property('cell-background', 'grey')\n        column = gtk.TreeViewColumn(\" Click\\nto hide\")\n        column.set_fixed_width(20)\n        column.pack_start(renderer, True)\n        column.set_attributes(renderer, stock_id=MODEL_INDEX_ICON, callable=MODEL_INDEX_CALLBACK, cell_background_set=MODEL_INDEX_NOTEDITABLE)\n        treeview.append_column(column)\n\n        # name column\n        renderer = gtk.CellRendererText()\n        renderer.connect(\"edited\", self.on_cell_edited, list_store, MODEL_INDEX_NAME)\n        renderer.set_property('cell-background', 'grey')\n        column = gtk.TreeViewColumn(\"Programming\\n     Model\", renderer, text=MODEL_INDEX_NAME, editable=MODEL_INDEX_EDITABLE, cell_background_set=MODEL_INDEX_NOTEDITABLE)\n        treeview.append_column(column)\n\n        # column for case sensitive toggles\n        renderer = gtk.CellRendererToggle()\n        renderer.connect('toggled', self.case_sensitive_toggled, list_store)\n        renderer.set_property('cell-background', 'grey')\n        column = gtk.TreeViewColumn('   Case\\nSensitive', renderer, active=MODEL_INDEX_CASESENSITIVE, cell_background_set=MODEL_INDEX_NOTEDITABLE)\n        column.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)\n        column.set_fixed_width(70)\n        treeview.append_column(column)\n\n        # regex column\n        renderer = gtk.CellRendererText()\n        renderer.connect(\"edited\", self.on_cell_edited, list_store, MODEL_INDEX_REGEX)\n        renderer.set_property('cell-background', 'grey')\n        column = gtk.TreeViewColumn(\"Regex\", renderer, text=MODEL_INDEX_REGEX, editable=MODEL_INDEX_EDITABLE, cell_background_set=MODEL_INDEX_NOTEDITABLE)\n        treeview.append_column(column)\n\n        sw.add(treeview)\n        vbox.pack_start(sw, True, True, 0)\n        hbox = gtk.HBox(True, 4)\n        button = gtk.Button(\"_Add Model\")\n        button.connect(\"clicked\", self.on_add_item_clicked, list_store)\n        hbox.pack_start(button, True, True, 0)\n        button = gtk.Button(\"_Remove Model\")\n        button.connect(\"clicked\", self.on_remove_item_clicked, treeview)\n        hbox.pack_start(button, True, True, 0)\n        vbox.pack_start(hbox, False, False, 0)\n        frame.add(vbox)\n        self.model_dialog.vbox.pack_start(frame, True, True, 0)\n\n        separator = gtk.HSeparator()\n        self.model_dialog.vbox.pack_start(separator, False, False, 10)\n        hbox = gtk.HBox(True, 4)\n        button = gtk.Button(\"_Done\")\n        button.connect(\"clicked\", lambda w: self.model_dialog.destroy())\n        hbox.pack_start(button, True, True, 0)\n        self.model_dialog.vbox.pack_start(hbox, False, False, 0)\n\n        self.model_dialog.show_all()\n        return True\n\n    def hide_model_callback(self, path):\n        \"\"\"Callback to handle activation of hide model button.\"\"\"\n        path = int(path)\n        self.get_current_graph().set_undo_list()\n        self.get_current_graph().action_history.append('Hide Model: %s' % self.programming_models[path][MODEL_INDEX_NAME])\n        self.update_history()\n        for regex in self.programming_models[path][MODEL_INDEX_REGEX].split(';'):\n            if regex == '':\n                continue\n            self.tabs[self.notebook.get_current_page()].widget.graph.hide_re(regex, self.programming_models[path][MODEL_INDEX_CASESENSITIVE])\n        self.get_current_graph().adjust_dims()\n        self.get_current_widget().zoom_to_fit()\n        return True\n\n    def case_sensitive_toggled(self, cell, path, list_store):\n        iterator = list_store.get_iter((int(path),))\n        if iterator:\n            path = list_store.get_path(iterator)[0]\n            if self.programming_models[path][MODEL_INDEX_EDITABLE] is False:\n                return True\n        toggled = list_store.get_value(iterator, MODEL_INDEX_CASESENSITIVE)\n        toggled = not toggled\n        self.programming_models[int(path)][MODEL_INDEX_CASESENSITIVE] = toggled\n        list_store.set(iterator, MODEL_INDEX_CASESENSITIVE, toggled)\n\n    def on_add_item_clicked(self, button, list_store):\n        new_item = [False, \"Name\", True, \"Regex\", True, False]\n        self.programming_models.append(new_item)\n        iterator = list_store.append()\n        list_store.set(iterator, MODEL_INDEX_NAME, new_item[MODEL_INDEX_NAME], MODEL_INDEX_CASESENSITIVE, new_item[MODEL_INDEX_CASESENSITIVE], MODEL_INDEX_REGEX, new_item[MODEL_INDEX_REGEX], MODEL_INDEX_EDITABLE, new_item[MODEL_INDEX_EDITABLE], MODEL_INDEX_NOTEDITABLE, new_item[MODEL_INDEX_NOTEDITABLE], MODEL_INDEX_CALLBACK, self.hide_model_callback, MODEL_INDEX_ICON, gtk.STOCK_CUT)\n\n    def on_remove_item_clicked(self, button, treeview):\n        selection = treeview.get_selection()\n        list_store, iterator = selection.get_selected()\n        if iterator:\n            path = list_store.get_path(iterator)[0]\n            if self.programming_models[path][MODEL_INDEX_EDITABLE] is True:\n                list_store.remove(iterator)\n                del self.programming_models[path]\n\n    def on_cell_edited(self, widget, path, new_text, list_store, column):\n        list_store[int(path)][column] = new_text\n        self.programming_models[int(path)][column] = new_text\n\n    def on_search(self, action):\n        \"\"\"Callback to handle pressing of focus task button.\"\"\"\n        #TODO-count-rep: does not work if we just have count + 1 representative\n        if self.get_current_graph().cur_filename == '':\n            return False\n        self.task_dialog = gtk.Dialog('Search', self)\n        hbox = gtk.HBox()\n        hbox.pack_start(gtk.Label(\"Search for:\"), False, False, 0)\n        label = gtk.Label()\n        combo_box = gtk.combo_box_new_text()\n        for search_type in self.search_types:\n            s_type, search_cb, search_help = search_type\n            combo_box.append_text(s_type)\n        combo_box.set_active(0)\n        combo_box.connect('changed', lambda w: self.on_search_type_toggled(w, label))\n        hbox.pack_start(combo_box, False, False, 10)\n        self.task_dialog.vbox.pack_start(hbox, False, False, 0)\n        match_case_check_box = gtk.CheckButton(\"Match Case\")\n        match_case_check_box.set_active(True)\n        match_case_check_box.connect('toggled', lambda x: x)\n        entry = gtk.Entry()\n        entry.set_max_length(65536)\n        entry.connect(\"activate\", self.on_search_enter_cb, (entry, combo_box, match_case_check_box))\n        self.task_dialog.vbox.pack_start(entry, False, False, 0)\n        self.task_dialog.vbox.pack_start(match_case_check_box, False, False, 0)\n        separator = gtk.HSeparator()\n        self.task_dialog.vbox.pack_start(separator, False, False, 0)\n        s_type, search_cb, search_help = self.search_types[combo_box.get_active()]\n        label.set_text(search_help)\n        self.task_dialog.vbox.pack_start(label, True, True, 0)\n        hbox = gtk.HButtonBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: self.task_dialog.destroy())\n        hbox.pack_start(button, False, False, 0)\n        button = gtk.Button(stock=gtk.STOCK_OK)\n        button.connect(\"clicked\", self.on_search_enter_cb, (entry, combo_box, match_case_check_box))\n        hbox.pack_start(button, False, False, 0)\n        self.task_dialog.vbox.pack_end(hbox, False, False, 0)\n        self.task_dialog.show_all()\n        return True\n\n    def on_hide_text_enter_cb(self, widget, arg):\n        \"\"\"Callback to handle activation of focus task text entry.\"\"\"\n        entry, match_case_check_box = arg\n        text = entry.get_text()\n        self.get_current_graph().set_undo_list()\n        self.get_current_graph().action_history.append('Cut text: %s' % (text))\n        self.update_history()\n        self.get_current_graph().hide_re(text, match_case_check_box.get_active())\n        self.get_current_graph().adjust_dims()\n        self.get_current_widget().zoom_to_fit()\n        self.task_dialog.destroy()\n        return True\n\n    def on_hide_text(self, action):\n        \"\"\"Callback to handle pressing of cut text button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        self.task_dialog = gtk.Dialog('Cut', self)\n        hbox = gtk.HBox()\n        hbox.pack_start(gtk.Label(\"Cut below:\"), False, False, 0)\n        match_case_check_box = gtk.CheckButton(\"Match Case\")\n        match_case_check_box.set_active(True)\n        match_case_check_box.connect('toggled', lambda x: x)\n        entry = gtk.Entry()\n        entry.set_max_length(65536)\n        entry.connect(\"activate\", self.on_hide_text_enter_cb, (entry, match_case_check_box))\n        self.task_dialog.vbox.pack_start(entry, False, False, 0)\n        self.task_dialog.vbox.pack_start(match_case_check_box, False, False, 0)\n        help_string = \"\"\"Cut the tree below frames matching\nthe specified text, which may be\nenterered as a regular expression.\n        \"\"\"\n        separator = gtk.HSeparator()\n        self.task_dialog.vbox.pack_start(separator, False, False, 0)\n        label = gtk.Label()\n        label.set_text(help_string)\n        self.task_dialog.vbox.pack_start(label, True, True, 0)\n        hbox = gtk.HButtonBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: self.task_dialog.destroy())\n        hbox.pack_start(button, False, False, 0)\n        button = gtk.Button(stock=gtk.STOCK_OK)\n        button.connect(\"clicked\", self.on_hide_text_enter_cb, (entry, match_case_check_box))\n        hbox.pack_start(button, False, False, 0)\n        self.task_dialog.vbox.pack_end(hbox, False, False, 0)\n        self.task_dialog.show_all()\n        return True\n\n    def on_longest_path(self, action):\n        \"\"\"Callback to handle pressing of longest path button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        self.get_current_graph().set_undo_list()\n        longest_depth = 1\n        try:\n            action_history_top = self.get_current_graph().action_history[-1]\n            if action_history_top.find('Longest Path ') != -1:\n                longest_depth = int(action_history_top.strip('Longest Path ')) + 1\n        except:\n            longest_depth = 1\n        ret = self.get_current_graph().longest_path(self.get_current_widget(), longest_depth)\n        if ret is True:\n            self.get_current_graph().action_history.append('Longest Path %d' % longest_depth)\n            self.update_history()\n            self.get_current_graph().adjust_dims()\n            self.get_current_widget().zoom_to_fit()\n        else:\n            self.get_current_graph().undo(False)\n        return ret\n\n    def on_shortest_path(self, action):\n        \"\"\"Callback to handle pressing of shortest path button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        self.get_current_graph().set_undo_list()\n        shortest_depth = 1\n        try:\n            action_history_top = self.get_current_graph().action_history[-1]\n            if action_history_top.find('Shortest Path ') != -1:\n                shortest_depth = int(action_history_top.strip('Shortest Path ')) + 1\n        except:\n            shortest_depth = 1\n        ret = self.get_current_graph().shortest_path(self.get_current_widget(), shortest_depth)\n        if ret is True:\n            self.get_current_graph().action_history.append('Shortest Path %d' % shortest_depth)\n            self.update_history()\n            self.get_current_graph().adjust_dims()\n            self.get_current_widget().zoom_to_fit()\n        else:\n            self.get_current_graph().undo(False)\n        return ret\n\n    def on_least_tasks(self, action):\n        \"\"\"Callback to handle pressing of least tasks button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        self.get_current_graph().set_undo_list()\n        least_tasks = 1\n        try:\n            action_history_top = self.get_current_graph().action_history[-1]\n            if action_history_top.find('Least Tasks ') != -1:\n                least_tasks = int(action_history_top.strip('Least Tasks ')) + 1\n        except:\n            least_tasks = 1\n        ret = self.get_current_graph().least_tasks(self.get_current_widget(), least_tasks)\n        if ret is True:\n            self.get_current_graph().action_history.append('Least Tasks %d' % least_tasks)\n            self.update_history()\n            self.get_current_graph().adjust_dims()\n            self.get_current_widget().zoom_to_fit()\n        else:\n            self.get_current_graph().undo(False)\n        return ret\n\n    def on_most_tasks(self, action):\n        \"\"\"Callback to handle pressing of most tasks button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        self.get_current_graph().set_undo_list()\n        most_tasks = 1\n        try:\n            action_history_top = self.get_current_graph().action_history[-1]\n            if action_history_top.find('Most Tasks ') != -1:\n                most_tasks = int(action_history_top.strip('Most Tasks ')) + 1\n        except:\n            most_tasks = 1\n        ret = self.get_current_graph().most_tasks(self.get_current_widget(), most_tasks)\n        if ret is True:\n            self.get_current_graph().action_history.append('Most Tasks %d' % most_tasks)\n            self.update_history()\n            self.get_current_graph().adjust_dims()\n            self.get_current_widget().zoom_to_fit()\n        else:\n            self.get_current_graph().undo(False)\n        return ret\n\n    def on_join_eq_classes(self, action):\n        \"\"\"Callback to handle pressing of collapse equivalence classes button.\"\"\"\n        graph = self.get_current_graph()\n        if graph.cur_filename == '':\n            return False\n        num_edges = len(graph.edges)\n        graph.set_undo_list()\n        old_attrs = {}\n        for node in graph.nodes:\n            old_attrs[node.node_name] = (copy.copy(node.attrs))\n        for node in graph.nodes:\n            if node.node_name == '0':\n                ret = self.join_eq_classes(node)\n                break\n        if ret is True:\n            self.on_reset_layout()\n            for node in graph.nodes:\n                node.attrs = copy.copy(old_attrs[node.node_name])\n            for i in range(len(graph.edges) - num_edges):\n                graph.edges.pop()\n            graph.undo(False)\n        return ret\n\n    def join_eq_classes(self, node):\n        \"\"\"Recursively collapse equivalence classes.\"\"\"\n        found = False\n        if node.hide is True:\n            return False\n        if node.can_join_eq_c() and node.node_name != '0':\n            self.get_current_graph().join_eq_c(node, True)\n            found = True\n        if found:\n            edges = node.eq_collapsed_out_edges\n        else:\n            edges = node.out_edges\n        for edge in edges:\n            ret = self.join_eq_classes(edge.dst)\n            if ret is True:\n                found = True\n        return found\n\n    def on_identify_num_eq_classes(self, action):\n        \"\"\"Callback to handle pressing of equivalence classes button.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        num_eq_classes = self.get_current_graph().identify_real_num_eq_classes(self.get_current_widget())\n        #num_eq_classes = self.get_current_graph().identify_num_eq_classes(self.get_current_widget())\n        eq_dialog = gtk.Dialog(\"Equivalence Classes\", self)\n        my_frame = gtk.Frame(label=\"%d Equivalence Classes:\" % (len(num_eq_classes)))\n        sw = gtk.ScrolledWindow()\n        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n        task_view = gtk.TextView()\n        task_view.set_editable(False)\n        task_view.set_cursor_visible(False)\n        task_view_buffer = task_view.get_buffer()\n        task_view.set_wrap_mode(gtk.WRAP_WORD)\n        eq_string = ''\n        for eq_class in num_eq_classes:\n            current_class = '['\n            prev = -2\n            in_range = False\n            task_count = 0\n            for num in num_eq_classes[eq_class]:\n                task_count += 1\n                if num == prev + 1:\n                    in_range = True\n                else:\n                    if in_range is True:\n                        current_class += '-%d' % prev\n                    if prev != -2:\n                        current_class += ','\n                    current_class += '%d' % num\n                    in_range = False\n                prev = num\n            if in_range is True:\n                current_class += '-%d' % num\n            current_class += ']\\n'\n            if task_count == 1:\n                eq_string += '%d task: %s' % (task_count, current_class)\n            else:\n                eq_string += '%d tasks: %s' % (task_count, current_class)\n        task_view_buffer.set_text(eq_string.replace(\",\", \", \"))\n        sw.add(task_view)\n        my_frame.add(sw)\n        eq_dialog.vbox.pack_start(my_frame, True, True, 5)\n        self.separator = gtk.HSeparator()\n        eq_dialog.vbox.pack_start(self.separator, False, True, 5)\n        box2 = gtk.HButtonBox()\n        button = gtk.Button(stock=gtk.STOCK_OK)\n        button.connect(\"clicked\", lambda w, d: eq_dialog.destroy(), \"ok\")\n        box2.pack_end(button, False, True, 5)\n        eq_dialog.vbox.pack_end(box2, False, False, 0)\n        eq_dialog.show_all()\n        return True\n\n    def on_node_clicked(self, widget, button_clicked, event):\n        \"\"\"Callback to handle clicking of a node.\"\"\"\n        if isinstance(event, STATNode):\n            node = event\n        else:\n            node = widget.get_node(int(event.x), int(event.y))\n        try:\n            label = node.attrs[\"label\"].decode('utf-8')\n            tasks = node.edge_label.decode('utf-8')\n        except:\n            label = node.attrs[\"label\"]\n            tasks = node.edge_label\n        label = label.replace('\\\\n', '\\n').replace('\\\\<', '<').replace('\\\\>', '>')\n        if node.hide is True:\n            return True\n        options = ['Join Equivalence Class', 'Collapse', 'Collapse Depth', 'Hide', 'Expand', 'Expand All', 'Focus', 'View Source', 'Translate']\n\n        if HAVE_TOMOD is True:\n            options.append('Temporally Order Children')\n        if button_clicked == 'left':\n            if hasattr(self, 'get_full_edge_label') and tasks.find(':') != -1:\n                options.append('Get Full Edge Label')\n            try:\n                self.my_dialog.destroy()\n            except:\n                pass\n            self.my_dialog = gtk.Dialog(\"Node\", self)\n            vpaned1 = gtk.VPaned()\n            my_frame = gtk.Frame(label=\"Stack Frame:\")\n            sw = gtk.ScrolledWindow()\n            sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n            text_view = gtk.TextView()\n            for shape in node.shapes:\n                if isinstance(shape, xdot_ui_elements.TextShape):\n                    font_color = shape.pen.color\n                else:\n                    fill_color = shape.pen.fillcolor\n            font_color_string = color_to_string(font_color)\n            fill_color_string = color_to_string(fill_color)\n            text_view.set_editable(False)\n            text_view.set_cursor_visible(False)\n            text_view_buffer = text_view.get_buffer()\n            text_view.set_wrap_mode(gtk.WRAP_CHAR)\n            text_view_buffer.create_tag(\"monospace\", family=\"monospace\")\n            iterator = text_view_buffer.get_iter_at_offset(0)\n            fore_color_tag = \"color_fore%s\" % (font_color_string)\n            foreground = gtk.gdk.color_parse(font_color_string)\n            text_view_buffer.create_tag(fore_color_tag, foreground_gdk=foreground)\n            background = gtk.gdk.color_parse(fill_color_string)\n            back_color_tag = \"color_back%s\" % (fill_color_string)\n            text_view_buffer.create_tag(back_color_tag, background_gdk=background)\n            text_view_buffer.insert_with_tags_by_name(iterator, label, fore_color_tag, back_color_tag, \"monospace\")\n            sw.add(text_view)\n            my_frame.add(sw)\n            vpaned1.add1(my_frame)\n            #TODO: make frames resizable\n            if tasks.find(':') == -1:\n                leaf_tasks = node.get_leaf_tasks()\n                num_leaf_tasks = node.get_num_leaf_tasks()\n                num_tasks = node.num_tasks\n                if num_leaf_tasks != 0 and num_leaf_tasks == len(leaf_tasks):\n                    vpaned2 = gtk.VPaned()\n                    if num_leaf_tasks == 1:\n                        my_frame = gtk.Frame(label=\"%d Leaf Task:\" % (num_leaf_tasks))\n                    else:\n                        my_frame = gtk.Frame(label=\"%d Leaf Tasks:\" % (num_leaf_tasks))\n                    sw = gtk.ScrolledWindow()\n                    sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n                    task_view = gtk.TextView()\n                    task_view.set_editable(False)\n                    task_view.set_cursor_visible(False)\n                    task_view_buffer = task_view.get_buffer()\n                    task_view.set_wrap_mode(gtk.WRAP_WORD)\n                    x = list_to_string(leaf_tasks)\n                    task_view_buffer.set_text(list_to_string(leaf_tasks).replace(\",\", \", \").strip('[').strip(']'))\n                    sw.add(task_view)\n                    my_frame.add(sw)\n                    if num_tasks != num_leaf_tasks:\n                        vpaned2.add1(my_frame)\n                    else:\n                        vpaned1.add2(my_frame)\n                if num_tasks != num_leaf_tasks:\n                    if num_tasks == 1:\n                        my_frame = gtk.Frame(label=\"%d Total Task:\" % (num_tasks))\n                    else:\n                        my_frame = gtk.Frame(label=\"%d Total Tasks:\" % (num_tasks))\n                    sw = gtk.ScrolledWindow()\n                    sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n                    task_view = gtk.TextView()\n                    task_view.set_editable(False)\n                    task_view.set_cursor_visible(False)\n                    task_view_buffer = task_view.get_buffer()\n                    task_view.set_wrap_mode(gtk.WRAP_WORD)\n                    task_view_buffer.set_text(tasks.replace(\",\", \", \").strip('[').strip(']'))\n                    sw.add(task_view)\n                    my_frame.add(sw)\n                    try:\n                        vpaned2.add2(my_frame)\n                        vpaned1.add2(vpaned2)\n                    except:\n                        vpaned1.add2(my_frame)\n            else:\n                num_tasks = node.num_tasks\n                num_leaf_tasks = node.get_num_leaf_tasks()\n                my_frame = gtk.Frame(label=\"Node summary:\")\n                sw = gtk.ScrolledWindow()\n                sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n                summary_view = gtk.TextView()\n                summary_view.set_editable(False)\n                summary_view.set_cursor_visible(False)\n                task_view_buffer = summary_view.get_buffer()\n                summary_view.set_wrap_mode(gtk.WRAP_WORD)\n                task_view_buffer.set_text(\"%d total tasks, %d leaf tasks, representative = %d\" % (num_tasks, num_leaf_tasks, get_task_list(tasks)[0]))\n                sw.add(summary_view)\n                my_frame.add(sw)\n                vpaned1.add2(my_frame)\n            self.my_dialog.vbox.pack_start(vpaned1, True, True, 5)\n\n            expander = gtk.Expander()\n            expander.set_label(label=\"Advanced\")\n            sw = gtk.ScrolledWindow()\n            sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n            attributes_view = gtk.TextView()\n            attributes_view.set_editable(False)\n            attributes_view.set_cursor_visible(False)\n            attributes_view_buffer = attributes_view.get_buffer()\n            attributes_view.set_wrap_mode(gtk.WRAP_WORD)\n            attributes_text = str(node)\n            attributes_view_buffer.set_text(attributes_text)\n            sw.add(attributes_view)\n            #expander.add(sw)\n            #self.my_dialog.vbox.pack_start(expander, True, True, 5)\n            # TODO: When the sw is in an expander, it doesn't resize\n            self.my_dialog.vbox.pack_start(sw, True, True, 5)\n\n            self.separator = gtk.HSeparator()\n            self.my_dialog.vbox.pack_start(self.separator, False, True, 5)\n            box2 = gtk.HButtonBox()\n            for option in options:\n                button = gtk.Button(option.replace(' ', '\\n'))\n                if option != 'View Source' and option != 'Get Full Edge Label' and option != 'Translate':\n                    button.connect(\"clicked\", self.manipulate_cb, option, node)\n                if option == 'View Source':\n                    if not label_has_source(node.attrs[\"label\"]):\n                        button.set_sensitive(False)\n                    elif label_has_source(node.attrs[\"label\"]) and label_collapsed(node.attrs[\"label\"]):\n                        button.connect(\"clicked\", lambda w, n: self.select_source(n), node)\n                    else:\n                        button.connect(\"clicked\", self.manipulate_cb, option, node)\n                elif option == 'Translate':\n                    if (\"offset\" in node.attrs and node.attrs[\"offset\"].find(\"(null)\") != -1) or (\"module\" in node.attrs and node.attrs[\"module\"].find(\"(null)\") != -1) or (\"source\" in node.attrs and node.attrs[\"source\"].find(\"(null)\") == -1):\n                        button.set_sensitive(False)\n                    else:\n                        button.connect(\"clicked\", lambda x:self.on_translate())\n                elif option == 'Join Equivalence Class':\n                    if not node.can_join_eq_c():\n                        button.set_sensitive(False)\n                elif option == 'Get Full Edge Label':\n                    button.connect(\"clicked\", lambda x, w, l, n: self.get_full_edge_label(w, l, n), widget, button_clicked, node)\n                box2.pack_start(button, False, True, 5)\n            button = gtk.Button(stock=gtk.STOCK_OK)\n            button.connect(\"clicked\", lambda w, d: self.my_dialog.destroy(), \"ok\")\n            box2.pack_end(button, False, True, 5)\n            self.my_dialog.vbox.pack_end(box2, False, False, 0)\n            self.my_dialog.show_all()\n        elif button_clicked == 'right':\n            menu = gtk.Menu()\n            for option in options:\n                menu_item = gtk.MenuItem(option)\n                menu.append(menu_item)\n                if option != 'View Source' and option != 'Get Full Edge Label' and option != 'Translate':\n                    menu_item.connect('activate', self.manipulate_cb, option, node)\n                if option == 'View Source':\n                    if label_has_source(node.attrs[\"label\"]):\n                        if not label_collapsed(node.attrs[\"label\"]):\n                            menu_item.connect('activate', self.manipulate_cb, option, node)\n                        else:\n                            sub_menu = gtk.Menu()\n                            sources = node.attrs[\"source\"].split('\\\\n')\n                            for i, source in enumerate(sources):\n                                if source == \"(null)\":\n                                    source = \"?\"\n                                else:\n                                    source = os.path.basename(source)\n                                cur_line_num = node.attrs[\"line\"].split('\\\\n')[i]\n                                if cur_line_num == \"(null)\":\n                                    cur_line_num = \"?\"\n                                sub_menu_item = gtk.MenuItem(source + cur_line_num)\n                                sub_menu_item.connect('button-release-event', lambda w, e, o, n, i2: self.get_current_graph().view_source(n, i2), option, node, i)\n                                sub_menu.append(sub_menu_item)\n                                sub_menu_item.show()\n\n                            menu_item.set_submenu(sub_menu)\n                    else:\n                        menu_item.set_sensitive(False)\n                elif option == 'Translate':\n                    if label_has_module_offset(node.attrs[\"label\"]):\n                        menu_item.connect('activate', lambda w: self.on_translate())\n                    else:\n                        menu_item.set_sensitive(False)\n                elif option == 'Join Equivalence Class':\n                    if not node.can_join_eq_c():\n                        menu_item.set_sensitive(False)\n                menu_item.show()\n            try:\n                menu.popup(None, None, None, None, event.button, event.time)\n            except:\n                menu.popup(None, None, None, event.button, event.time)\n        return True\n\n    def on_select_source_enter_cb(self, combo_box, node):\n        \"\"\"Callback to handle activation of source selection.\"\"\"\n        index = combo_box.get_active()\n        self.my_dialog.destroy()\n        self.get_current_graph().view_source(node, index)\n\n    def select_source(self, node):\n        self.my_dialog.destroy()\n        frames = node.attrs[\"label\"].split('\\\\n')\n        if len(frames) == 1:\n            self.get_current_graph().view_source(node)\n        else:\n            self.my_dialog = gtk.Dialog(\"Select Frame\", self)\n            hbox = gtk.HBox()\n            hbox.pack_start(gtk.Label(\"Select a frame\"), False, False, 0)\n            combo_box = gtk.combo_box_new_text()\n            for i, frame in enumerate(frames):\n                source = node.attrs[\"source\"].split('\\\\n')[i]\n                if source == \"(null)\":\n                    source = \"?\"\n                else:\n                    source = os.path.basename(source)\n                cur_line_num = node.attrs[\"line\"].split('\\\\n')[i]\n                if cur_line_num == \"(null)\":\n                    cur_line_num = \"?\"\n                combo_box.append_text(source + cur_line_num)\n            combo_box.set_active(0)\n            hbox.pack_start(combo_box, False, False, 10)\n            self.my_dialog.vbox.pack_start(hbox, True, True, 0)\n            hbox = gtk.HButtonBox()\n            button = gtk.Button(stock=gtk.STOCK_CANCEL)\n            button.connect(\"clicked\", lambda w: self.my_dialog.destroy())\n            hbox.pack_end(button, False, False, 0)\n            button = gtk.Button(stock=gtk.STOCK_OK)\n            button.connect(\"clicked\", lambda w: self.on_select_source_enter_cb(combo_box, node))\n            hbox.pack_end(button, False, False, 0)\n            self.my_dialog.vbox.pack_end(hbox, False, False, 0)\n            self.my_dialog.show_all()\n\n    def manipulate_cb(self, widget, data, node):\n        \"\"\"Callback to handle the request of a manipulation operation.\"\"\"\n        ret = True\n        # setup\n        if data != 'View Source':\n            ret = self.get_current_graph().set_undo_list()\n\n        # process command\n        if data == 'Collapse':\n            ret = self.get_current_graph().collapse(node, True)\n        elif data == 'Collapse Depth':\n            ret = self.get_current_graph().collapse_depth(node)\n        elif data == 'Join Equivalence Class':\n            old_attrs = copy.copy(node.attrs)\n            num_edges = len(self.get_current_graph().edges)\n            ret, (leaf_node, attrs) = self.get_current_graph().join_eq_c(node, True)\n        elif data == 'Expand':\n            ret = self.get_current_graph().expand(node)\n        elif data == 'Expand All':\n            ret = self.get_current_graph().expand_all(node)\n        elif data == 'Hide':\n            ret = self.get_current_graph().collapse(node)\n        elif data == 'Focus':\n            ret = self.get_current_graph().focus(node)\n        elif data == 'View Source':\n            ret = self.get_current_graph().view_source(node)\n        elif data == 'Temporally Order Children':\n            ret = stat_wait_dialog.show_wait_dialog_and_run(self.get_current_graph().get_children_temporal_order, (node,), [], self)\n\n        # post process\n        if data not in ['View Source', 'Join Equivalence Class']:\n            if ret is True:\n                self.get_current_graph().action_history.append('%s: %s' % (data, node.attrs[\"label\"]))\n                self.update_history()\n            else:\n                self.get_current_graph().undo(False)\n        if data not in ['Temporally Order Children', 'View Source', 'Join Equivalence Class'] and ret is True:\n            global window\n            if self.get_current_widget().user_zoom is True and window.options[\"maintain user zoom\"] is True:\n                self.get_current_widget().queue_draw()\n            else:\n                self.get_current_graph().adjust_dims()\n                self.get_current_widget().zoom_to_fit()\n        if data == 'Join Equivalence Class' and ret is True:\n            old_graph = self.get_current_graph()\n            self.on_reset_layout()\n            node.attrs = copy.copy(old_attrs)\n            for i in range(len(old_graph.edges) - num_edges):\n                old_graph.edges.pop()\n            old_graph.undo(False)\n        try:\n            self.my_dialog.destroy()\n        except:\n            pass\n\n\ndef STATview_main(args):\n    \"\"\"The STATview main.\"\"\"\n    global window\n    window = STATDotWindow()\n    if args.files:\n        i = -1\n        for filename in args.files:\n            i += 1\n            try:\n                with open(filename, 'r') as f:\n                    if i != 0:\n                        window.create_new_tab()\n                    stat_wait_dialog.show_wait_dialog_and_run(window.set_dotcode, (f.read(), filename, i), ['Opening DOT file'], window)\n            except IOError as e:\n                sys.stderr.write('\\n%s\\nfailed to open file %s\\n\\n' % (repr(e), filename))\n                sys.stderr.write('usage:\\n\\tSTATview [<your_STAT_generated_graph.dot>]*\\n\\n')\n                sys.exit(-1)\n            except Exception as e:\n                sys.stderr.write('\\n%s\\nfailed to proess file %s\\n\\n' % (repr(e), filename))\n                sys.stderr.write('usage:\\n\\tSTATview [<your_STAT_generated_graph.dot>]*\\n\\n')\n                sys.exit(-1)\n    window.connect('destroy', window.on_destroy)\n    #gtk.gdk.threads_init()\n    gtk.main()\n\n\nif __name__ == '__main__':\n    sys.stderr.write('WARNING: STATview.py should not be directly invoked. This has been replaced by STATmain.py and the \"view\" subcommand.\\n')\n    sys.exit(1)\n",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/scripts/STATGUI.py": "#!/bin/env python\n\n\"\"\"@package STATGUI\nA GUI for driving the Stack Trace Analysis Tool.\"\"\"\n\n__copyright__ = \"\"\"Copyright (c) 2007-2020, Lawrence Livermore National Security, LLC.\"\"\"\n__license__ = \"\"\"Produced at the Lawrence Livermore National Laboratory\nWritten by Gregory Lee <lee218@llnl.gov>, Dorian Arnold, Matthew LeGendre, Dong Ahn, Bronis de Supinski, Barton Miller, Martin Schulz, Niklas Nielson, Nicklas Bo Jensen, Jesper Nielson, and Sven Karlsson.\nLLNL-CODE-750488.\nAll rights reserved.\n\nThis file is part of STAT. For details, see http://www.github.com/LLNL/STAT. Please also read STAT/LICENSE.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        Redistributions of source code must retain the above copyright notice, this list of conditions and the disclaimer below.\n        Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the disclaimer (as noted below) in the documentation and/or other materials provided with the distribution.\n        Neither the name of the LLNS/LLNL nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"\n__author__ = [\"Gregory Lee <lee218@llnl.gov>\", \"Dorian Arnold\", \"Matthew LeGendre\", \"Dong Ahn\", \"Bronis de Supinski\", \"Barton Miller\", \"Martin Schulz\", \"Niklas Nielson\", \"Nicklas Bo Jensen\", \"Jesper Nielson\"]\n__version_major__ = 4\n__version_minor__ = 0\n__version_revision__ = 3\n__version__ = \"%d.%d.%d\" %(__version_major__, __version_minor__, __version_revision__)\n\nimport STAThelper\nfrom STAThelper import var_spec_to_string, get_task_list, get_proctab, HAVE_PYGMENTS, exec_and_exit\nif HAVE_PYGMENTS:\n    import pygments\n    import pango\n    from pygments.lexers import CLexer\n    from pygments.lexers import CppLexer\n    from pygments.lexers import FortranLexer\n    from STAThelper import STATviewFormatter\nimport STATview\nfrom STATview import STATDotWindow, stat_wait_dialog, show_error_dialog, search_paths, STAT_LOGO, run_gtk_main_loop\n\nimport sys\nimport os\nimport ctypes\n\nHAVE_DLOPEN = hasattr(sys, 'getdlopenflags')\nif HAVE_DLOPEN is True:\n    dlflags = sys.getdlopenflags()\n    new_dlflags = ctypes.RTLD_GLOBAL | dlflags\n    sys.setdlopenflags(new_dlflags)\n\nfrom STAT import STAT_FrontEnd, intArray, STAT_LOG_NONE, STAT_LOG_FE, STAT_LOG_BE, STAT_LOG_CP, STAT_LOG_MRN, STAT_LOG_SW, STAT_LOG_SWERR, STAT_OK, STAT_APPLICATION_EXITED, STAT_VERBOSE_ERROR, STAT_VERBOSE_FULL, STAT_VERBOSE_STDOUT, STAT_TOPOLOGY_AUTO, STAT_TOPOLOGY_DEPTH, STAT_TOPOLOGY_FANOUT, STAT_TOPOLOGY_USER, STAT_PENDING_ACK, STAT_LAUNCH, STAT_ATTACH, STAT_SERIAL_ATTACH, STAT_GDB_ATTACH, STAT_SERIAL_GDB_ATTACH, STAT_SAMPLE_FUNCTION_ONLY, STAT_SAMPLE_LINE, STAT_SAMPLE_PC, STAT_SAMPLE_COUNT_REP, STAT_SAMPLE_THREADS, STAT_SAMPLE_CLEAR_ON_SAMPLE, STAT_SAMPLE_PYTHON, STAT_SAMPLE_MODULE_OFFSET, STAT_CP_NONE, STAT_CP_SHAREAPPNODES, STAT_CP_EXCLUSIVE\nHAVE_OPENMP_SUPPORT = True\ntry:\n    from STAT import STAT_SAMPLE_OPENMP\nexcept:\n    HAVE_OPENMP_SUPPORT = False\nHAVE_GDB_SUPPORT = True\ntry:\n    from STAT import STAT_SAMPLE_CUDA_QUICK\nexcept:\n    HAVE_GDB_SUPPORT = False\nHAVE_DYSECT = True\ntry:\n    from STAT import DysectAPI_OK, DysectAPI_Error, DysectAPI_InvalidSystemState, DysectAPI_LibraryNotLoaded, DysectAPI_SymbolNotFound, DysectAPI_SessionCont, DysectAPI_SessionQuit, DysectAPI_DomainNotFound, DysectAPI_NetworkError, DysectAPI_DomainExpressionError, DysectAPI_StreamError, DysectAPI_OptimizedOut\n    import DysectView\n    from DysectView import DysectDotWindow\nexcept:\n    HAVE_DYSECT = False\nHAVE_ATTACH_HELPER = True\ntry:\n    import attach_helper\nexcept:\n    HAVE_ATTACH_HELPER = False\nHAVE_PSUTIL = True\ntry:\n    import psutil\nexcept:\n    HAVE_PSUTIL = False\nimport subprocess\nHAVE_COMMANDS=True\ntry:\n    import commands\nexcept:\n    HAVE_COMMANDS=False\n    commands = subprocess\nimport time\nimport string\nimport re\nimport argparse\n\ntry:\n    import xdot\nexcept:\n    raise Exception('STATview requires xdot\\nxdot can be downloaded from https://github.com/jrfonseca/xdot.py\\n')\ntry:\n    # xdot 0.9: compatibility wrapper\n    xdot_ui_actions = xdot.ui.actions\n    xdot_ui_elements = xdot.ui.elements\n    xdot_ui_window = xdot.ui.window\n    xdot_dot_parser = xdot.dot.parser\n    xdot_dot_lexer = xdot.dot.lexer\nexcept:\n    # STAT-shipped xdot.py wrapper\n    xdot_ui_actions = xdot\n    xdot_ui_elements = xdot\n    xdot_ui_window = xdot\n    xdot_dot_parser = xdot\n    xdot_dot_lexer = xdot\n\nhas_gtk = False\nimport_error = ''\ntry:\n    import gtk\n    import gobject\n    import pango\n    gtk_wrap_new_with_label_from_widget = gtk.RadioButton\n    gtk_wrap_new_from_widget = gtk.RadioButton\n    has_gtk = True\nexcept ImportError as e:\n    import_error = e\n    pass #raise Exception('%s\\nSTATview requires gtk and gobject\\n' % repr(e))\nexcept RuntimeError as e:\n    import_error = e\n    pass #raise Exception('%s\\nThere was a problem loading the gtk and gobject module.\\nIs X11 forwarding enabled?\\n' % repr(e))\nexcept Exception as e:\n    import_error = e\n    pass #raise Exception('%s\\nThere was a problem loading the gtk module.\\n' % repr(e))\n\nif has_gtk == False:\n    try:\n        import gi\n        gi.require_version('Gtk', '3.0')\n        from gi.repository import Gtk as gtk\n        from gi.repository import Gdk as gdk\n        from gi.repository import GObject as gobject\n        from gi.repository import GdkPixbuf\n        gtk.POLICY_AUTOMATIC = gtk.PolicyType.AUTOMATIC\n        gtk.POLICY_NEVER = gtk.PolicyType.NEVER\n        gtk.Orientation.VERTICAL = gtk.Orientation.VERTICAL\n        gtk.POS_TOP = gtk.PositionType.TOP\n        gtk.gdk = gdk\n        gtk.ORIENTATION_VERTICAL = gtk.Orientation.VERTICAL\n        gtk.gdk.pixbuf_new_from_file = GdkPixbuf.Pixbuf.new_from_file\n        gtk_wrap_new_with_label_from_widget = gtk.RadioButton.new_with_label_from_widget\n        gtk_wrap_new_from_widget = gtk.RadioButton.new_from_widget\n    except Exception as e2:\n        raise Exception('%s\\n%s\\nThere was a problem loading the gtk module.\\n' % (repr(import_error), repr(e2)))\n\n\n## The STATGUI window adds STAT operations to the STATview window.\nclass STATGUI(STATDotWindow):\n    \"\"\"The STATGUI window adds STAT operations to the STATview window.\"\"\"\n\n    ui2 = ''\n    ui2 += '<ui>\\n'\n    ui2 += '    <toolbar name=\"STAT_Actions\">\\n'\n    ui2 += '        <toolitem action=\"Attach\"/>\\n'\n    ui2 += '        <toolitem action=\"ReAttach\"/>\\n'\n    ui2 += '        <toolitem action=\"Detach\"/>\\n'\n    ui2 += '        <toolitem action=\"Pause\"/>\\n'\n    ui2 += '        <toolitem action=\"Resume\"/>\\n'\n#    ui2 += '        <toolitem action=\"Kill\"/>\\n'\n    ui2 += '        <toolitem action=\"Sample\"/>\\n'\n    ui2 += '        <toolitem action=\"SampleMultiple\"/>\\n'\n    ui2 += '    </toolbar>\\n'\n    ui2 += '</ui>\\n'\n\n    def __init__(self, args):\n        \"\"\"The constructor.\n\n        Initializes all instance varaibles and creates the GUI window.\n        \"\"\"\n        if not os.path.exists('%s/.STAT' % os.environ['HOME']):\n            try:\n                os.mkdir('%s/.STAT' % os.environ['HOME'])\n            except:\n                pass\n        self.STAT = STAT_FrontEnd()\n        self.properties_window = None\n        self.proctab_file_path = None\n        self.proctab = None\n        self.marked_line_number = None\n        self.attached = False\n        self.reattach = False\n        self.serial_attach = False\n        self.visualizer_window = None\n        self.sample_task_list = ['Sample Stack Traces', 'Gather Stack Traces', 'Render Stack Traces']\n        self.attach_task_list = ['Launch Daemons', 'Connect to Daemons', 'Attach to Application']\n        self.attach_task_list += self.sample_task_list\n        types = {'Topology Type':     ['automatic', 'depth', 'max fanout', 'custom'],\n                 'Verbosity Type':    ['error', 'stdout', 'full'],\n                 'Sample Type':       ['function only', 'function and pc', 'module offset', 'function and line'],\n                 'Edge Type':         ['full list', 'count and representative'],\n                 'Remote Host Shell': ['rsh', 'ssh'],\n                 'Serial Remote Host Shell': ['rsh', 'ssh'],\n                 'Resource Manager':  ['Auto', 'Alps', 'Slurm'],\n                 'CP Policy':         ['none', 'share app nodes', 'exclusive']}\n        if not hasattr(self, \"types\"):\n            self.types = {}\n        for opt in types:\n            self.types[opt] = types[opt]\n        try:\n            gdb_path = os.environ['STAT_GDB']\n        except:\n            gdb_path = 'gdb'\n        options = {'Remote Host':                      \"localhost\",\n                   'Remote Host Shell':                \"rsh\",\n                   'Serial Remote Host Shell':                \"rsh\",\n                   'Resource Manager':                 \"Auto\",\n                   'PID':                              None,\n                   'Launcher Exe':                     '',\n                   'Serial PID':                       None,\n                   'Serial Exe':                       '',\n                   'Serial Process List':              '',\n                   'Topology Type':                    'automatic',\n                   'Topology':                         '1',\n                   'Check Node Access':                False,\n                   'CP Policy':                        'share app nodes',\n                   'Daemons per Node':                 1,\n                   'Tool Daemon Path':                 self.STAT.getToolDaemonExe(),\n                   'Filter Path':                      self.STAT.getFilterPath(),\n                   'Job Launcher':                     'mpirun|srun|sattach|orterun|aprun|runjob|wreckrun|mpiexec|jsrun',\n                   'Job ID':                           '',\n                   'Filter Ranks':                     '',\n                   'Filter Hosts':                     '',\n                   'Filter Full Command Line':         False,\n                   'Filter Full Command Line ':        False, # this option is for serial attach and adds a space at the end to avoid conflict\n                   'Log Dir':                          os.environ['HOME'],\n                   'Log Frontend':                     False,\n                   'Log Backend':                      False,\n                   'Log CP':                           False,\n                   'Log SW':                           False,\n                   'Log SWERR':                        False,\n                   'Use MRNet Printf':                 False,\n                   'GDB BE':                           False,\n                   'GDB Path':                         gdb_path,\n                   'With CUDA Quick':                  False,\n                   'Verbosity Type':                   'error',\n                   'Communication Nodes':              '',\n                   'Communication Processes per Node': 8,\n                   'Num Traces':                       10,\n                   'Trace Frequency (ms)':             1000,\n                   'Num Retries':                      5,\n                   'Retry Frequency (us)':             10,\n                   'Max Threads Per Daemon':           512,\n                   'With Threads':                     False,\n                   'With OpenMP':                      False,\n                   'Gather Python Traces':             False,\n                   'Clear On Sample':                  True,\n                   'Gather Individual Samples':        False,\n                   'Run Time Before Sample (sec)':     0,\n                   'Enable DySectAPI':                 False,\n                   'DySectAPI Session':                '',\n                   'DySectAPI Session Args':           '',\n                   'DySectAPI Show Default Probes':    False,\n                   'Sample Type':                      'function only',\n                   'Edge Type':                        'full list',\n                   'DDT Path':                         STAThelper.which('ddt'),\n                   'DDT LaunchMON Prefix':             '/usr/local',\n                   'TotalView Path':                   STAThelper.which('totalview'),\n                   'Additional Debugger Args':         ''}\n        if not hasattr(self, \"options\"):\n            self.options = {}\n        for option in options:\n            self.options[option] = options[option]\n        if 'STAT_CHECK_NODE_ACCESS' in os.environ:\n            self.options['Check Node Access'] = True\n        if 'STAT_LMON_DEBUG_BES' in os.environ:\n            self.options['Debug Backends'] = True\n        else:\n            self.options['Debug Backends'] = False\n\n        # Check for site default options then for user default options\n        site_options_path = '%s/etc/STAT/STAT.conf' % self.STAT.getInstallPrefix()\n        user_options_path = '%s/.STATrc' % (os.environ.get('HOME'))\n        for path in [site_options_path, user_options_path]:\n            if os.path.exists(path):\n                try:\n                    with open(path, 'r') as f:\n                        for line in f:\n                            if line[0] == '#' or line.strip() == '':\n                                continue\n                            split_line = line.split('=')\n                            if len(split_line) != 2:\n                                sys.stderr.write('invalid preference specification %s in file %s\\n' % (line.strip('\\n'), path))\n                                continue\n                            option = split_line[0].strip()\n                            value = split_line[1].strip()\n                            if option in self.options.keys():\n                                if type(self.options[option]) == int:\n                                    value = int(value)\n                                elif type(self.options[option]) == bool:\n                                    if value.lower() == 'true':\n                                        value = True\n                                    elif value.lower() == 'false':\n                                        value = False\n                                    else:\n                                        sys.stderr.write('invalid value %s for option %s as specified in file %s.  Expecting either \"true\" or \"false\".\\n' % (value, option, path))\n                                        continue\n                                self.options[option] = value\n                            elif option == 'Source Search Path':\n                                if os.path.exists(value):\n                                    search_paths['source'].append(value)\n                                else:\n                                    sys.stderr.write('search path %s specified in %s is not accessible\\n' % (value, path))\n                            elif option == 'Include Search Path':\n                                if os.path.exists(value):\n                                    search_paths['include'].append(value)\n                                else:\n                                    sys.stderr.write('search path %s specified in %s is not accessible\\n' % (value, path))\n                            else:\n                                sys.stderr.write('invalid option %s in file %s\\n' % (option, path))\n                except IOError as e:\n                    sys.stderr.write('%s\\nfailed to open preferences file %s\\n' % (repr(e), path))\n                    continue\n                except Exception as e:\n                    import traceback\n                    traceback.print_exc()\n                    sys.stderr.write('%s\\nfailed to process preferences file %s\\n' % (repr(e), path))\n                    continue\n\n        if args is not None:\n            if args.withmoduleoffset is True:\n                self.options['Sample Type'] = 'module offset'\n            elif args.withpc is True:\n                self.options['Sample Type'] = 'function and pc'\n            elif args.withline is True:\n                self.options['Sample Type'] = 'function and line'\n            if args.countrep is True:\n                self.options['Edge Type'] = 'count and representative'\n            if args.pythontrace is True:\n                self.options['Gather Python Traces'] = True\n            if args.withthreads is True:\n                self.options['With Threads'] = True\n            if args.withopenmp is True:\n                self.options['With Threads'] = True\n                self.options['With OpenMP'] = True\n            if args.debugdaemons is True:\n                self.options['Debug Backends'] = True\n            if args.logdir is not None:\n                self.options['Log Dir'] = args.logdir\n            if HAVE_GDB_SUPPORT:\n                if args.gdb is True:\n                    self.options['GDB BE'] = True\n                if args.cudaquick is True:\n                    self.options['With CUDA Quick'] = True\n            if args.log is not None:\n                if 'CP' in args.log:\n                    self.options['Log CP'] = True\n                if 'FE' in args.log:\n                    self.options['Log Frontend'] = True\n                if 'BE' in args.log:\n                    self.options['Log Backend'] = True\n            if args.mrnetprintf is True:\n                self.options['Use MRNet Printf'] = True\n            if args.sleep is not None:\n                sys.stdout.write('sleeping for %d seconds\\n' % (args.sleep))\n                time.sleep(args.sleep)\n        self.var_spec = []\n        self.filter_entry = None\n        self.serial_filter_entry = None\n        uimanager = gtk.UIManager()\n        self.actiongroup = gtk.ActionGroup('Commands')\n        actions = []\n        actions.append(('Attach', gtk.STOCK_CONNECT, 'Attach', None, 'Attach to an application', self.on_attach))\n        actions.append(('ReAttach', gtk.STOCK_CONNECT, 'ReAttach', None, 'Attach to the last application STAT detached from', lambda a: stat_wait_dialog.show_wait_dialog_and_run(self.on_reattach, (a,), self.attach_task_list, self)))\n        actions.append(('Detach', gtk.STOCK_DISCONNECT, 'Detach', None, 'Detach from the application', lambda a: stat_wait_dialog.show_wait_dialog_and_run(self.on_detach, (a,), [\"Detach From Application\"], self)))\n        actions.append(('Pause', gtk.STOCK_MEDIA_PAUSE, 'Pause', None, 'Pause the application', lambda a: stat_wait_dialog.show_wait_dialog_and_run(self.on_pause, (a,), [\"Pause Application\"], self)))\n        actions.append(('Resume', gtk.STOCK_MEDIA_PLAY, 'Resume', None, 'Resume the application', lambda a: stat_wait_dialog.show_wait_dialog_and_run(self.on_resume, (a,), ['Resume Application'], self)))\n#        actions.append(('Kill', gtk.STOCK_STOP, 'Kill', None, 'Kill the application', lambda a: stat_wait_dialog.show_wait_dialog_and_run(self.on_kill, (a,), ['Terminating Application'], self)))\n        actions.append(('Sample', gtk.STOCK_FIND, 'Sample', None, 'Gather a stack trace sample from the application', lambda a: self.on_sample(a, False)))\n        actions.append(('SampleMultiple', gtk.STOCK_ZOOM_IN, 'Sample\\nMultiple', None, 'Gather the merged stack traces accumulated over time', lambda a: self.on_sample(a, True)))\n        self.actiongroup.add_actions(actions)\n        uimanager.insert_action_group(self.actiongroup, 0)\n        self.set_action_sensitivity('new')\n        uimanager.add_ui_from_string(self.ui2)\n        toolbar = uimanager.get_widget('/STAT_Actions')\n        toolbar.set_orientation(gtk.ORIENTATION_VERTICAL)\n        self.hbox = gtk.HBox()\n        self.hbox.pack_start(toolbar, False, False, 0)\n        lines = STATDotWindow.ui.split('\\n')\n        count = 0\n        for line in lines:\n            count += 1\n            if line.find('menuitem action=\"SaveAs') != -1:\n                break\n        lines.insert(count, '            <menuitem action=\"Properties\"/>')\n        lines.insert(count, '            <separator/>')\n        STATDotWindow.ui = ''\n        for line in lines:\n            STATDotWindow.ui += line + '\\n'\n        menu_actions = []\n        menu_actions.append(('Properties', gtk.STOCK_PROPERTIES, 'P_roperties', '<control>R', 'View application properties', self.on_properties))\n        menu_actions.append(('About', gtk.STOCK_ABOUT, None, None, None, self.on_about))\n        STATDotWindow.__init__(self, menu_actions)\n        self.set_title('STAT')\n        help_text = \"\"\"Search for processes on a\nspecified host, range of hosts, or\nsemi-colon separated list of hosts.\nExample specifications:\nhost1\nhost1;host2\nhost[1-10]\nhost[1-10,12,15-20]\nhost[1-10,12,15-20];otherhost[30]\n\"\"\"\n        self.search_types.append(('hosts', self.search_hosts, help_text))\n\n        if args is not None:\n            if args.attach is not None:\n                self.options['PID'] = int(args.attach.split(':')[-1])\n                if args.attach.find(':') != -1:\n                    self.options['Remote Host'] = args.attach.split(':')[0]\n                if args.gdb is not None:\n                    self.options['GDB BE'] = True\n                stat_wait_dialog.show_wait_dialog_and_run(self.attach_cb, (None, False, False, STAT_ATTACH), self.attach_task_list)\n                return\n            elif args.serial is not None:\n                self.serial_attach = True\n                stat_wait_dialog.show_wait_dialog_and_run(self.attach_serial_processes_cb, (None, None, args.serial), self.attach_task_list)\n                return\n            elif args.create is not None:\n                stat_wait_dialog.show_wait_dialog_and_run(self.launch_application_cb, (None, None, args.create), self.attach_task_list)\n                return\n        self.on_attach(None)\n\n    def search_hosts(self, text, match_case_check_box):\n        \"\"\"Callback to handle activation of focus task text entry.\"\"\"\n        if match_case_check_box.get_active() is False:\n            text = text.lower()\n        temp_host_list = text.replace(' ', '').split(';')\n        host_list = []\n        for host in temp_host_list:\n            if host.find('[') != -1:\n                prefix = host[0:host.find('[')]\n                host_range = host[host.find('['):host.find(']') + 1]\n                node_list = get_task_list(host_range)\n                for node in node_list:\n                    node_name = '%s%d' % (prefix, node)\n                    host_list.append(node_name)\n            else:\n                host_list.append(host)\n        ret = self.set_proctab()\n        if ret is False:\n            return False\n        tasks = ''\n        for rank, host, pid, exe_index in self.proctab.process_list:\n            if match_case_check_box.get_active() is False:\n                host = host.lower()\n            if host in host_list:\n                tasks += str(rank) + ','\n        tasks = tasks[0:-1]\n        self.get_current_graph().focus_tasks(tasks)\n        return True\n\n    def on_about(self, action):\n        \"\"\"Display info about STAT.\"\"\"\n        about_dialog = gtk.AboutDialog()\n        about_dialog.set_name('STAT')\n        about_dialog.set_authors(__author__)\n        about_dialog.set_copyright(__copyright__)\n        about_dialog.set_license(__license__)\n        about_dialog.set_wrap_license(80)\n        version = intArray(3)\n        if self.STAT is None:\n            self.STAT = STAT_FrontEnd()\n        self.STAT.getVersion(version)\n        about_dialog.set_version('%d.%d.%d' % (version[0], version[1], version[2]))\n        try:\n            pixbuf = gtk.gdk.pixbuf_new_from_file(STAT_LOGO)\n            about_dialog.set_logo(pixbuf)\n        except Exception as e:\n            pass\n        about_dialog.set_website('https://github.com/lee218llnl/STAT')\n        about_dialog.show_all()\n        about_dialog.run()\n        about_dialog.destroy()\n\n    def set_action_sensitivity(self, state):\n        \"\"\"Set the sensitivity of the buttons.\"\"\"\n        for action in self.actiongroup.list_actions():\n            action.set_sensitive(True)\n            if action.get_name() in ['ReAttach', 'Detach', 'Pause', 'Resume', 'Kill', 'Sample', 'SampleMultiple', 'SampleMultiple'] and state == 'new':\n                action.set_sensitive(False)\n            elif action.get_name() in ['Detach', 'Pause', 'Resume', 'Kill', 'Sample', 'SampleMultiple', 'SampleMultiple'] and state == 'detached':\n                action.set_sensitive(False)\n            elif action.get_name() in ['Attach', 'ReAttach', 'Pause'] and state == 'paused':\n                action.set_sensitive(False)\n            elif action.get_name() in ['Attach', 'ReAttach', 'Resume'] and state == 'running':\n                action.set_sensitive(False)\n            elif state == 'busy':\n                action.set_sensitive(False)\n\n    def on_properties(self, action):\n        \"\"\"Display a window with application properties.\"\"\"\n        if self.attached is False:\n            show_error_dialog('Application properties only available after attaching\\n', self)\n            return False\n        if self.properties_window is not None:\n            self.properties_window.present()\n            return True\n        self.options['Filter Ranks'] = ''\n        self.options['Filter Hosts'] = ''\n        self.ptab_sw = None\n\n        # gather application properties\n        num_nodes = self.STAT.getNumApplNodes()\n        num_procs = self.STAT.getNumApplProcs()\n        ret = self.set_proctab()\n        if ret is False:\n            show_error_dialog('Failed to set process table file\\n', self)\n            return False\n\n        job_launcher = \"%s:%d\" % (self.proctab.launcher_host, self.proctab.launcher_pid)\n        entries = range(len(self.proctab.process_list))\n        entries = list(entries)\n        for rank, host, pid, exe_index in self.proctab.process_list:\n            entries[rank] = '%d %s:%d %d\\n' % (rank, host, pid, exe_index)\n\n        self.properties_window = gtk.Window()\n        self.properties_window.set_title('Properties')\n        self.properties_window.connect('destroy', self.on_properties_destroy)\n        vbox = gtk.VBox()\n\n        frame = gtk.Frame(label='Application Executable(s) (index:path)')\n        text_view = gtk.TextView()\n        text_buffer = gtk.TextBuffer()\n        exes = ''\n        for i in range(len(self.proctab.executable_paths)):\n            exes += ('%d:%s\\n' % (i, self.proctab.executable_paths[i]))\n        text_buffer.set_text(exes)\n        text_view.set_buffer(text_buffer)\n        text_view.set_wrap_mode(False)\n        text_view.set_editable(False)\n        text_view.set_cursor_visible(False)\n        frame.add(text_view)\n        vbox.pack_start(frame, False, False, 0)\n\n        frame = gtk.Frame(label='Number of application nodes')\n        text_view = gtk.TextView()\n        text_buffer = gtk.TextBuffer()\n        text_buffer.set_text('%d' % num_nodes)\n        text_view.set_buffer(text_buffer)\n        text_view.set_wrap_mode(False)\n        text_view.set_editable(False)\n        text_view.set_cursor_visible(False)\n        frame.add(text_view)\n        vbox.pack_start(frame, False, False, 0)\n\n        frame = gtk.Frame(label='Number of application processes')\n        text_view = gtk.TextView()\n        text_buffer = gtk.TextBuffer()\n        text_buffer.set_text('%d' % num_procs)\n        text_view.set_buffer(text_buffer)\n        text_view.set_wrap_mode(False)\n        text_view.set_editable(False)\n        text_view.set_cursor_visible(False)\n        frame.add(text_view)\n        vbox.pack_start(frame, False, False, 0)\n\n        if self.STAT.getApplicationOption() != STAT_SERIAL_ATTACH and self.STAT.getApplicationOption() != STAT_SERIAL_GDB_ATTACH:\n            frame = gtk.Frame(label='Job Launcher (host:PID)')\n            text_view = gtk.TextView()\n            text_buffer = gtk.TextBuffer()\n            text_buffer.set_text(job_launcher)\n            text_view.set_buffer(text_buffer)\n            text_view.set_wrap_mode(False)\n            text_view.set_editable(False)\n            text_view.set_cursor_visible(False)\n            frame.add(text_view)\n            vbox.pack_start(frame, False, False, 0)\n\n        proctab_frame = gtk.Frame(label='Process Table (rank host:PID exe_index)')\n        hbox = gtk.HBox()\n        hbox.pack_start(gtk.Label('Filter Ranks'), False, False, 5)\n        self.rank_filter_entry = self.pack_entry_and_button(self.options['Filter Ranks'], self.on_update_filter_ranks, proctab_frame, self.properties_window, \"Filter Ranks\", hbox, True, True, 0)\n        vbox.pack_start(hbox, False, False, 0)\n        hbox = gtk.HBox()\n        hbox.pack_start(gtk.Label('Filter Hosts'), False, False, 5)\n        self.host_filter_entry = self.pack_entry_and_button(self.options['Filter Hosts'], self.on_update_filter_hosts, proctab_frame, self.properties_window, \"Filter Hosts\", hbox, True, True, 0)\n        vbox.pack_start(hbox, False, False, 0)\n        self.on_update_proctab(None, proctab_frame, self.properties_window)\n        vbox.pack_start(proctab_frame, True, True, 0)\n\n        #frame = gtk.Frame(label='Process Table (rank host:PID exe_index)')\n        #text_view = gtk.TextView()\n        #text_view.set_size_request(400, 200)\n        #text_buffer = gtk.TextBuffer()\n        #text_buffer.set_text(process_table)\n        #text_view.set_buffer(text_buffer)\n        #text_view.set_wrap_mode(False)\n        #text_view.set_editable(False)\n        #text_view.set_cursor_visible(False)\n        #sw = gtk.ScrolledWindow()\n        #sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n        #sw.add(text_view)\n        #frame.add(sw)\n        #vbox.pack_start(frame, True, True, 0)\n\n        self.properties_window.add(vbox)\n        self.properties_window.show_all()\n\n    def on_properties_destroy(self, action):\n        \"\"\"Clean up the properties window.\"\"\"\n        self.properties_window = None\n\n    def pid_toggle_cb(self, action, pid, command):\n        \"\"\"A callback to modify the PID option.\"\"\"\n        self.options['PID'] = pid\n        self.options['Launcher Exe'] = command\n\n    def serial_pid_toggle_cb(self, action, pid, command):\n        \"\"\"A callback to modify the PID option.\"\"\"\n        self.options['Serial PID'] = pid\n        self.options['Serial Exe'] = command\n\n    def on_add_serial_process(self, widget, attach_dialog, serial_process_list_entry):\n        text = serial_process_list_entry.get_text()\n        exe = self.options['Serial Exe']\n        if (exe.find(' \\\\_') != -1):\n            exe = exe.split()[1]\n        else:\n            exe = exe.split()[0]\n        text += ' %s@%s:%s ' % (exe, self.options['Remote Host'], self.options['Serial PID'])\n        text = serial_process_list_entry.set_text(text)\n        attach_dialog.show_all()\n\n    def on_update_filter_hosts(self, w, proctab_frame, parent, entry):\n        self.options['Filter Hosts'] = entry.get_text()\n        entry.set_text(self.options['Filter Hosts'])\n        self.on_update_proctab(w, proctab_frame, parent)\n\n    def on_update_filter_ranks(self, w, proctab_frame, parent, entry):\n        self.options['Filter Ranks'] = entry.get_text()\n        entry.set_text(self.options['Filter Ranks'])\n        self.on_update_proctab(w, proctab_frame, parent)\n\n    def on_update_proctab(self, widget, proctab_frame, proctab_window):\n        try:\n            if self.ptab_sw is not None:\n                proctab_frame.remove(self.ptab_sw)\n        except:\n            pass\n        rank_filter = get_task_list('[%s]' %self.options['Filter Ranks'])\n        host_filter = []\n        temp_host_list = self.options['Filter Hosts'].replace(' ', '').split(';')\n        for host in temp_host_list:\n            if host.find('[') != -1:\n                prefix = host[0:host.find('[')]\n                host_range = host[host.find('['):host.find(']') + 1]\n                node_list = get_task_list(host_range)\n                for node in node_list:\n                    node_name = '%s%d' % (prefix, node)\n                    host_filter.append(node_name)\n            elif host != '':\n                host_filter.append(host)\n        self.ptab_sw = gtk.ScrolledWindow()\n        self.ptab_sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)\n        self.ptab_sw.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)\n        (PTAB_INDEX_RANK, PTAB_INDEX_HOST, PTAB_INDEX_PID, PTAB_INDEX_EXE) = range(4)\n        list_store = gtk.ListStore(gobject.TYPE_UINT, gobject.TYPE_STRING, gobject.TYPE_UINT, gobject.TYPE_UINT)\n        for rank, host, pid, exe_index in self.proctab.process_list:\n            if rank_filter != [] and rank not in rank_filter:\n                continue\n            if host_filter != [] and host not in host_filter:\n                continue\n            iterator = list_store.append()\n            item = (rank, host, pid, exe_index)\n            list_store.set(iterator, PTAB_INDEX_RANK, item[PTAB_INDEX_RANK], PTAB_INDEX_HOST, item[PTAB_INDEX_HOST], PTAB_INDEX_PID, item[PTAB_INDEX_PID], PTAB_INDEX_EXE, item[PTAB_INDEX_EXE])\n        treeview = gtk.TreeView(list_store)\n        treeview.set_rules_hint(True)\n        treeview.set_search_column(PTAB_INDEX_RANK)\n        treeview.set_size_request(400, 400)\n        self.ptab_sw.add(treeview)\n        proctab_frame.add(self.ptab_sw)\n\n        column = gtk.TreeViewColumn('Rank', gtk.CellRendererText(), text=PTAB_INDEX_RANK)\n        column.set_sort_column_id(PTAB_INDEX_RANK)\n        treeview.append_column(column)\n        column = gtk.TreeViewColumn('Host', gtk.CellRendererText(), text=PTAB_INDEX_HOST)\n        column.set_sort_column_id(PTAB_INDEX_HOST)\n        treeview.append_column(column)\n        column = gtk.TreeViewColumn('PID', gtk.CellRendererText(), text=PTAB_INDEX_PID)\n        column.set_sort_column_id(PTAB_INDEX_PID)\n        treeview.append_column(column)\n        column = gtk.TreeViewColumn('EXE', gtk.CellRendererText(), text=PTAB_INDEX_EXE)\n        column.set_sort_column_id(PTAB_INDEX_EXE)\n        treeview.append_column(column)\n        self.properties_window.show_all()\n\n    def on_update_process_listing(self, widget, frame, attach_dialog, listing_filter=None):\n        \"\"\"Generate a wait dialog and search for user processes.\"\"\"\n        stat_wait_dialog.show_wait_dialog_and_run(self._on_update_process_listing, (widget, frame, attach_dialog, listing_filter), [], attach_dialog)\n\n    def on_update_serial_process_listing(self, widget, frame, attach_dialog, listing_filter=None):\n        \"\"\"Generate a wait dialog and search for user processes.\"\"\"\n        stat_wait_dialog.show_wait_dialog_and_run(self._on_update_serial_process_listing, (widget, frame, attach_dialog, listing_filter), [], attach_dialog)\n\n    def _on_update_process_listing2(self, attach_dialog, listing_filter, vbox, is_parallel):\n        \"\"\"Search for user processes.\"\"\"\n        self.options['Remote Host Shell'] = self.types['Remote Host Shell'][self.combo_boxes['Remote Host Shell'].get_active()]\n        self.options['Serial Remote Host Shell'] = self.types['Serial Remote Host Shell'][self.combo_boxes['Serial Remote Host Shell'].get_active()]\n        if is_parallel is True:\n            my_rsh = self.options['Remote Host Shell']\n        else:\n            my_rsh = self.options['Serial Remote Host Shell']\n        pid_list = ''\n        if listing_filter is not None:\n            filter_compiled_re = re.compile(listing_filter.get_text())\n        if HAVE_ATTACH_HELPER and self.options['Job ID'] != '':\n            self.options['Remote Host'], rm_exe, pids = attach_helper.jobid_to_hostname_pid(self.options['Resource Manager'], self.options['Job ID'], my_rsh)\n            self.options['Job Launcher'] = rm_exe\n            if self.options['Remote Host'] == None:\n                show_error_dialog('Failed to find host for job ID %s' % self.options['Job ID'], attach_dialog)\n                self.options['Job ID'] = ''\n                return False\n            self.options['Job ID'] = ''\n            for i, pid in enumerate(pids):\n                if i != 0:\n                    pid_list += ','\n                pid_list += str(pid)\n            self.filter_entry.set_text(self.options['Job Launcher'])\n            self.rh_entry.set_text(self.options['Remote Host'])\n        psutil_success = False\n        process_list = [] # format of item = (pid, cmd_line)\n        if HAVE_PSUTIL is True and (self.options['Remote Host'] == 'localhost' or self.options['Remote Host'] == ''):\n            my_procs = []\n            pid_depth = {}\n            for pid in psutil.pids():\n                try:\n                    proc = psutil.Process(pid)\n                    if proc.username() == os.getlogin():\n                        my_procs.append(proc)\n                except:\n                    pass\n            handled_procs = []\n            for proc in my_procs:\n                if proc in handled_procs:\n                    continue\n                cmd_line =  ' '.join(proc.cmdline())\n                pid = proc.pid\n                try:\n                    exe = os.path.realpath(proc.exe())\n                except:\n                    continue\n                if listing_filter is not None:\n                    if listing_filter.get_text() != '':\n                        if (not self.options[\"Filter Full Command Line\"] and is_parallel) or (not self.options[\"Filter Full Command Line \"] and not is_parallel):\n                            my_filter = filter_compiled_re.search(exe)\n                        else:\n                            my_filter = filter_compiled_re.search(cmd_line)\n                        if my_filter is None:\n                            continue\n                try:\n                    pid_depth[pid] = pid_depth[proc.parent().pid] + 1\n                except Exception as e:\n                    pid_depth[pid] = 0\n                handled_procs.append(proc)\n                if pid_depth[pid] > 0:\n                    cmd_line = ' \\\\_ '.rjust(pid_depth[pid] * 3 + 3) + cmd_line\n                output = commands.getoutput('file %s' % (exe))\n                process_list.append((pid, cmd_line))\n            psutil_success = True\n        if psutil_success == False:\n            if self.options['Remote Host'] == 'localhost' or self.options['Remote Host'] == '':\n                output = commands.getoutput('ps xww')\n            else:\n                if pid_list != '':\n                    output = commands.getoutput('%s %s ps ww -p %s' % (self.options['Remote Host Shell'], self.options['Remote Host'], pid_list))\n                else:\n                    output = commands.getoutput('%s %s ps xww' % (self.options['Remote Host Shell'], self.options['Remote Host']))\n                if output.find('Hostname not found') != -1 or output.find('PID') == -1:\n                    show_error_dialog('Failed to get process listing for %s:\\n\\t %s' % (self.options['Remote Host'], output), attach_dialog)\n                    return False\n            output = output.split('\\n')\n            pid_index = 0\n            for line in output:\n                if line.find('PID') != -1:\n                    break\n                pid_index += 1\n            output = output[pid_index:]\n            line = output[0].split()\n            pid_index = 0\n            command_index = 0\n            for counter, token in enumerate(line):\n                if token == 'PID':\n                    pid_index = counter\n                elif token == 'COMMAND':\n                    command_index = counter\n            for line in output[1:]:\n                try:\n                    cmd_line = ''\n                    for token in line.split()[command_index:]:\n                        cmd_line += ' %s' % token\n                except:\n                    continue\n                if listing_filter is not None:\n                    if listing_filter.get_text() != '':\n                        if (not self.options[\"Filter Full Command Line\"] and is_parallel) or (not self.options[\"Filter Full Command Line \"] and not is_parallel):\n                            my_filter = filter_compiled_re.search(cmd_line.split()[0])\n                        else:\n                            my_filter = filter_compiled_re.search(cmd_line)\n                        if my_filter is None:\n                            continue\n                process_list.append((int(line.split()[pid_index]), cmd_line))\n\n        started = False\n        for (pid, cmd_line) in process_list:\n            text = '% 5d %s' %(pid, cmd_line)\n            if started is False:\n                started = True\n                first_radio_button = gtk_wrap_new_with_label_from_widget(None, text)\n                first_radio_button.set_active(True)\n                radio_button = first_radio_button\n                if is_parallel:\n                    self.options['PID'] = pid\n                    self.options['Launcher Exe'] = cmd_line\n                else:\n                    self.options['Serial PID'] = pid\n                    self.options['Serial Exe'] = cmd_line\n            else:\n                radio_button = gtk_wrap_new_with_label_from_widget(first_radio_button, text)\n                radio_button.set_active(False)\n            if is_parallel:\n                radio_button.connect(\"toggled\", self.pid_toggle_cb, pid, cmd_line)\n            else:\n                radio_button.connect(\"toggled\", self.serial_pid_toggle_cb, pid, cmd_line)\n            vbox.pack_start(radio_button, False, False, 0)\n\n    def _on_update_process_listing(self, widget, frame, attach_dialog, listing_filter=None):\n        vbox = gtk.VBox()\n        self._on_update_process_listing2(attach_dialog, listing_filter, vbox, True)\n        try:\n            if self.sw is not None:\n                frame.remove(self.sw)\n        except:\n            pass\n        self.sw = gtk.ScrolledWindow()\n        self.sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n        self.sw.add_with_viewport(vbox)\n        frame.add(self.sw)\n        attach_dialog.show_all()\n\n    def _on_update_serial_process_listing(self, widget, frame, attach_dialog, listing_filter=None):\n        vbox = gtk.VBox()\n        self._on_update_process_listing2(attach_dialog, listing_filter, vbox, False)\n        try:\n            if self.serial_sw is not None:\n                frame.remove(self.serial_sw)\n        except:\n            pass\n        self.serial_sw = gtk.ScrolledWindow()\n        self.serial_sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n        self.serial_sw.add_with_viewport(vbox)\n        frame.add(self.serial_sw)\n        attach_dialog.show_all()\n\n    def on_update_job_id(self, w, frame, attach_dialog, entry):\n        \"\"\"Callback to search a job id for resource manager processes.\"\"\"\n        self.options['Job ID'] = entry.get_text()\n        entry.set_text(self.options['Job ID'])\n        self.options['Resource Manager'] = self.types['Resource Manager'][self.combo_boxes['Resource Manager'].get_active()]\n        self.on_update_process_listing(w, frame, attach_dialog, None)\n\n\n    def on_update_remote_host(self, w, frame, attach_dialog, entry):\n        \"\"\"Callback to search a remote host for processes.\"\"\"\n        self.options['Remote Host'] = entry.get_text()\n        entry.set_text(self.options['Remote Host'])\n        self.on_update_process_listing(w, frame, attach_dialog, self.filter_entry)\n\n    def on_update_serial_remote_host(self, w, frame, attach_dialog, entry):\n        \"\"\"Callback to search a remote host for processes.\"\"\"\n        self.options['Remote Host'] = entry.get_text()\n        entry.set_text(self.options['Remote Host'])\n        self.on_update_serial_process_listing(w, frame, attach_dialog, self.serial_filter_entry)\n\n    def on_cancel_attach(self, widget, dialog):\n        \"\"\"Callback to handle canceling of attach dialog.\"\"\"\n        dialog.hide()\n\n    def manipulate_cb(self, widget, data, node):\n        \"\"\"Overloaded manipulate callback to handle variable search.\"\"\"\n        STATDotWindow.manipulate_cb(self, widget, data, node)\n        if data == 'Temporally Order Children':\n            self.check_for_loop_variable()\n\n    def on_to_traverse_least_progress(self, action):\n        \"\"\"Overloaded traverse callback to handle variable search.\"\"\"\n        STATDotWindow.on_to_traverse_least_progress(self, action)\n        self.check_for_loop_variable()\n\n    def on_to_traverse_most_progress(self, action):\n        \"\"\"Overloaded traverse callback to handle variable search.\"\"\"\n        STATDotWindow.on_to_traverse_most_progress(self, action)\n        self.check_for_loop_variable()\n\n    def clear_var_spec_and_destroy_dialog(self, dialog):\n        \"\"\"Handle case where we don't want to gather loop variable.\"\"\"\n        self.var_spec = []\n        dialog.hide()\n\n    def check_for_loop_variable(self):\n        \"\"\"Searches for loop ordering variables.\n\n        If found, prompt user to gather stack trace with variable values.\"\"\"\n        found = False\n        for node in self.get_current_graph().nodes:\n            if node.attrs.get(\"lex_string\") is not None:\n                if node.attrs[\"lex_string\"].find('$') != -1 and node.attrs[\"lex_string\"].find('=') == -1:\n                    source = node.attrs[\"source\"]\n                    line = int(node.attrs[\"line\"].strip(\":\"))\n                    temp = node.attrs[\"lex_string\"][node.attrs[\"lex_string\"].find('$') + 1:]\n                    while 1:\n                        var = temp[:temp.find('(')]\n                        if var == 'iter#':\n                            break\n                        found = True\n                        self.var_spec.append((source, line, node.depth, var))\n                        if temp.find('$') != -1:\n                            temp = temp[temp.find('$') + 1:]\n                        else:\n                            break\n        if found is True:\n            dialog = gtk.Dialog('Gather Loop Order Variable(s)?', self)\n            label = gtk.Label('Temporal ordering requires STAT\\nto fetch loop ordering variables.\\nDo you want STAT to gather these variables?\\nNote, this generates a new call prefix tree.')\n            dialog.vbox.pack_start(label, False, False, 0)\n            hbox = gtk.HButtonBox()\n            button = gtk.Button(stock=gtk.STOCK_YES)\n\n            #button.connect(\"clicked\", lambda w: self.run_and_destroy_dialog(stat_wait_dialog.show_wait_dialog_and_run, (self.sample, (True,), self), self.sample_task_list, dialog))\n            button.connect(\"clicked\", lambda w: stat_wait_dialog.show_wait_dialog_and_run(self.run_and_destroy_dialog, (self.hacky_sample_keep_state, (), dialog), self.sample_task_list))\n\n            hbox.pack_start(button, True, True, 0)\n            button = gtk.Button('Open in\\nnew tab')\n\n            #button.connect(\"clicked\", lambda w: self.run_and_destroy_dialog(self.new_tab_and_sample, (), dialog))\n            button.connect(\"clicked\", lambda w: stat_wait_dialog.show_wait_dialog_and_run(self.run_and_destroy_dialog, (self.hacky_sample_keep_state, (True,), dialog), self.sample_task_list))\n\n            hbox.pack_start(button, True, True, 0)\n            button = gtk.Button(stock=gtk.STOCK_NO)\n            button.connect(\"clicked\", lambda w: self.clear_var_spec_and_destroy_dialog(dialog))\n            hbox.pack_start(button, True, True, 0)\n            dialog.vbox.pack_start(hbox, False, False, 0)\n            dialog.show_all()\n            dialog.run()\n\n    def new_tab_and_sample(self):\n        \"\"\"Create a new tab and gather a stack sample\"\"\"\n        page = self.notebook.get_current_page()\n        self.create_new_tab(page + 1)\n        self.notebook.set_current_page(page + 1)\n        self.sample(True)\n\n    def hacky_sample_keep_state(self, new_tab=False):\n        \"\"\"Gather a new stack trace.\n\n        Also perform TO operations from previous trace.\n        \"\"\"\n        actions = self.get_current_graph().action_history\n        if new_tab is True:\n            page = self.notebook.get_current_page()\n            self.create_new_tab(page + 1)\n            self.notebook.set_current_page(page + 1)\n        self.sample(True)\n        for action in actions:\n            if action.find('Traverse Most Progress') != -1:\n                self.on_to_traverse_most_progress(None)\n            if action.find('Traverse Least Progress') != -1:\n                self.on_to_traverse_least_progress(None)\n        self.get_current_graph().adjust_dims()\n        self.get_current_widget().zoom_to_fit()\n\n    def run_and_destroy_dialog(self, function, args, dialog):\n        \"\"\"Run the specified function and destroys the specified dialog.\"\"\"\n        function(*args)\n        dialog.hide()\n\n    def on_reattach(self, action):\n        \"\"\"Attach to the same job as the previous session.\n\n        Also gather a stack trace.\n        \"\"\"\n        if self.serial_attach is True:\n            if self.STAT is None:\n                self.STAT = STAT_FrontEnd()\n            for process in self.process_list.split():\n                self.STAT.addSerialProcess(process)\n            if self.options['GDB BE'] is True:\n                self.attach_cb(None, False, True, STAT_SERIAL_GDB_ATTACH)\n            else:\n                self.attach_cb(None, False, True, STAT_SERIAL_ATTACH)\n        else:\n            self.attach_cb(None, False, False, STAT_ATTACH)\n        return True\n\n    def on_choose_dysect_session(self, attach_dialog, widget):\n        \"\"\"Callback to generate an open file dialog.\"\"\"\n        chooser = gtk.FileChooserDialog(title=\"Select a DySectAPI session\",\n                                        action=gtk.FILE_CHOOSER_ACTION_OPEN,\n                                        buttons=(gtk.STOCK_CANCEL,\n                                                 gtk.RESPONSE_CANCEL,\n                                                 gtk.STOCK_OPEN,\n                                                 gtk.RESPONSE_OK))\n        chooser.set_default_response(gtk.RESPONSE_OK)\n        chooser.set_current_folder(os.getcwd())\n        chooser.set_select_multiple(False)\n        file_filter = gtk.FileFilter()\n        file_filter.set_name(\"DySectAPI session source file\")\n        file_filter.add_pattern(\"*.cpp\")\n        file_filter.add_pattern(\"*.cxx\")\n        file_filter.add_pattern(\"*.CXX\")\n        file_filter.add_pattern(\"*.c\")\n        file_filter.add_pattern(\"*.C\")\n        chooser.add_filter(file_filter)\n        file_filter = gtk.FileFilter()\n        file_filter.set_name(\"All files\")\n        file_filter.add_pattern(\"*\")\n        chooser.add_filter(file_filter)\n        if chooser.run() == gtk.RESPONSE_OK:\n            filenames = chooser.get_filenames()\n            chooser.destroy()\n            self.options['DySectAPI Session'] = filenames[0]\n            vbox = gtk.VBox()\n            children = widget.get_children()\n            for child in children:\n                if type(child) == type(gtk.CheckButton()):\n                    child.set_active(True)\n                if type(child) == type(gtk.Label()):\n                    child.set_text('Session: %s' % self.options['DySectAPI Session'])\n            attach_dialog.show_all()\n            self.options['Enable DySectAPI'] = True\n        else:\n            chooser.destroy()\n\n    def on_attach(self, action):\n        \"\"\"Generate a dialog to attach to a new job.\"\"\"\n        if self.reattach is True and self.STAT is not None:\n            self.STAT.shutDown()\n            self.STAT = None\n        if self.STAT is None:\n            self.STAT = STAT_FrontEnd()\n        self.options['PID'] = None\n        self.options['Launcher Exe'] = ''\n        self.options['Serial PID'] = None\n        self.options['Serial Exe'] = ''\n        attach_dialog = gtk.Dialog('Attach', self)\n        attach_dialog.set_default_size(400, 400)\n        notebook = gtk.Notebook()\n        notebook.set_tab_pos(gtk.POS_TOP)\n        notebook.set_scrollable(False)\n\n        # parallel attach\n        process_frame = gtk.Frame(label='Current Process List')\n        vbox = gtk.VBox()\n\n        self.rm_expander = gtk.Expander(label=\"Search for job by Resource Manager job ID\")\n        hbox = gtk.HBox()\n        self.jobid_entry = self.pack_entry_and_button(self.options['Job ID'], self.on_update_job_id, process_frame, attach_dialog, \"Search for Job\", hbox, True, True, 0)\n        hbox.pack_start(gtk.VSeparator(), False, False, 5)\n        self.pack_combo_box(hbox, 'Resource Manager')\n        self.rm_expander.add(hbox)\n        vbox.pack_start(self.rm_expander, False, False, 0)\n\n        self.hn_expander = gtk.Expander(label=\"Search for job by hostname\")\n        hbox = gtk.HBox()\n        self.rh_entry = self.pack_entry_and_button(self.options['Remote Host'], self.on_update_remote_host, process_frame, attach_dialog, \"Search Remote Host\", hbox)\n        self.hn_expander.add(hbox)\n        self.hn_expander.set_expanded(True)\n        vbox.pack_start(self.hn_expander, False, False, 0)\n\n        self.rm_expander.connect(\"activate\", lambda w: self.hn_expander.set_expanded(self.rm_expander.get_expanded()))\n        self.hn_expander.connect(\"activate\", lambda w: self.rm_expander.set_expanded(self.hn_expander.get_expanded()))\n\n        vbox.pack_start(gtk.HSeparator(), False, False, 0)\n        hbox = gtk.HBox()\n        self.pack_combo_box(hbox, 'Remote Host Shell')\n        vbox.pack_start(hbox, False, False, 0)\n        vbox.pack_start(process_frame, True, True, 0)\n        self.pack_check_button(vbox, 'Filter Full Command Line', False, False, 5)\n        hbox = gtk.HBox()\n        hbox.pack_start(gtk.Label('Filter Process List'), False, False, 5)\n        self.filter_entry = self.pack_entry_and_button(self.options['Job Launcher'], self.on_update_process_listing, process_frame, attach_dialog, \"Filter\", hbox, True, True, 0)\n        vbox.pack_start(hbox, False, False, 0)\n        hbox = gtk.HBox()\n        button = gtk.Button(\"Refresh Process List\")\n        button.connect(\"clicked\", lambda w: self.on_update_process_listing(w, process_frame, attach_dialog, self.filter_entry))\n        hbox.pack_start(button, True, True, 10)\n        vbox.pack_start(hbox, False, False, 0)\n        vbox.pack_start(gtk.HSeparator(), False, False, 10)\n        hbox = gtk.HBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: self.on_cancel_attach(w, attach_dialog))\n        hbox.pack_start(button, False, False, 0)\n        button = gtk.Button(\"Attach\")\n        button.connect(\"clicked\", lambda w: stat_wait_dialog.show_wait_dialog_and_run(self.attach_cb, (attach_dialog, False, False, STAT_ATTACH), self.attach_task_list, attach_dialog))\n        hbox.pack_start(button, True, True, 0)\n        vbox.pack_start(hbox, False, False, 0)\n        label = gtk.Label('Attach')\n        notebook.append_page(vbox, label)\n\n        # launch\n        vbox = gtk.VBox()\n        hbox = gtk.HBox()\n        hbox.pack_start(gtk.Label('Enter application launch string:'), False, False, 0)\n        vbox.pack_start(hbox, False, False, 10)\n        entry = gtk.Entry()\n        entry.set_max_length(8192)\n        entry.connect(\"activate\", lambda w: stat_wait_dialog.show_wait_dialog_and_run(self.launch_application_cb, (entry, attach_dialog), self.attach_task_list, attach_dialog))\n        vbox.pack_start(entry, False, False, 0)\n        hbox = gtk.HButtonBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: self.on_cancel_attach(w, attach_dialog))\n        hbox.pack_end(button, False, False, 0)\n        button = gtk.Button(\"Launch\")\n        button.connect(\"clicked\", lambda w: stat_wait_dialog.show_wait_dialog_and_run(self.launch_application_cb, (entry, attach_dialog), self.attach_task_list, attach_dialog))\n        hbox.pack_start(button, False, False, 0)\n        vbox.pack_end(hbox, False, False, 0)\n        label = gtk.Label('Launch')\n        notebook.append_page(vbox, label)\n\n        # serial attach tab\n        serial_process_frame = gtk.Frame(label='Current Process List')\n        vbox = gtk.VBox()\n        hbox = gtk.HBox()\n        hbox.pack_start(gtk.Label('Search Host'), False, False, 5)\n        self.pack_entry_and_button(self.options['Remote Host'], self.on_update_serial_remote_host, serial_process_frame, attach_dialog, \"Search\", hbox)\n        hbox.pack_start(gtk.VSeparator(), False, False, 5)\n        self.pack_combo_box(hbox, 'Serial Remote Host Shell')\n        vbox.pack_start(hbox, False, False, 0)\n        vbox.pack_start(serial_process_frame, True, True, 0)\n        self.pack_check_button(vbox, 'Filter Full Command Line ', False, False, 5)\n        hbox = gtk.HBox()\n        hbox.pack_start(gtk.Label('Filter Process List'), False, False, 5)\n        self.serial_filter_entry = self.pack_entry_and_button(\"\", self.on_update_serial_process_listing, serial_process_frame, attach_dialog, \"Filter\", hbox, True, True, 0)\n        vbox.pack_start(hbox, False, False, 0)\n        hbox = gtk.HBox()\n        button = gtk.Button(\"Refresh Process List\")\n        button.connect(\"clicked\", lambda w: self.on_update_serial_process_listing(w, serial_process_frame, attach_dialog, self.serial_filter_entry))\n        hbox.pack_start(button, False, False, 10)\n        button = gtk.Button(\"Add Process to Attach List\")\n        hbox.pack_start(button, True, True, 10)\n        self.serial_process_list_entry = gtk.Entry()\n        self.serial_process_list_entry.set_max_length(8192)\n        self.serial_process_list_entry.set_text(self.options['Serial Process List'])\n        button.connect(\"clicked\", lambda w: self.on_add_serial_process(w, attach_dialog, self.serial_process_list_entry))\n        vbox.pack_start(hbox, False, False, 10)\n        hbox = gtk.HBox()\n        label = gtk.Label(\"Attach List\")\n        hbox.pack_start(label, False, False, 10)\n        self.serial_process_list_entry.connect(\"activate\", lambda w: stat_wait_dialog.show_wait_dialog_and_run(self.attach_serial_processes_cb, (self.serial_process_list_entry, attach_dialog), self.attach_task_list, attach_dialog))\n        hbox.pack_start(self.serial_process_list_entry, True, True, 0)\n        vbox.pack_start(hbox, False, False, 0)\n        vbox.pack_start(gtk.HSeparator(), False, False, 10)\n        hbox = gtk.HBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: self.on_cancel_attach(w, attach_dialog))\n        hbox.pack_start(button, False, False, 10)\n        button = gtk.Button(\"Attach to Attach List\")\n        button.connect(\"clicked\", lambda w: stat_wait_dialog.show_wait_dialog_and_run(self.attach_serial_processes_cb, (self.serial_process_list_entry, attach_dialog), self.attach_task_list, attach_dialog))\n        hbox.pack_start(button, True, True, 0)\n        vbox.pack_start(hbox, False, False, 0)\n        label = gtk.Label('Serial Attach')\n        notebook.append_page(vbox, label)\n\n        # DySect options\n        if HAVE_DYSECT:\n            vbox = gtk.VBox()\n            frame = gtk.Frame(label='DySectAPI Options')\n            dysect_vbox = gtk.VBox()\n            self.pack_check_button(dysect_vbox, 'Enable DySectAPI', False, False, 5)\n            label = gtk.Label('Session: %s' % self.options['DySectAPI Session'])\n            label.set_alignment(0, .5)\n            dysect_vbox.pack_start(label, True, True, 0)\n            button = gtk.Button('Select DySectAPI Session')\n            button.connect(\"clicked\", lambda w: self.on_choose_dysect_session(attach_dialog, dysect_vbox))\n            dysect_vbox.pack_start(button, False, False, 0)\n            self.pack_string_option(dysect_vbox, 'DySectAPI Session Args', attach_dialog)\n            frame.add(dysect_vbox)\n            vbox.pack_start(frame, False, False, 0)\n            hbox = gtk.HBox()\n            button = gtk.Button(stock=gtk.STOCK_CANCEL)\n            button.connect(\"clicked\", lambda w: self.on_cancel_attach(w, attach_dialog))\n            hbox.pack_start(button, False, False, 0)\n            vbox.pack_end(hbox, False, False, 0)\n            label = gtk.Label('DySect')\n            notebook.append_page(vbox, label)\n\n        # sample options\n        vbox = gtk.VBox()\n        self.pack_sample_options(vbox, False, True)\n        hbox = gtk.HBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: self.on_cancel_attach(w, attach_dialog))\n        hbox.pack_start(button, False, False, 0)\n        vbox.pack_end(hbox, False, False, 0)\n        label = gtk.Label('Sample Options')\n        notebook.append_page(vbox, label)\n\n        # topology options\n        vbox = gtk.VBox()\n        frame = gtk.Frame(label='Topology Options')\n        vbox2 = gtk.VBox()\n        self.pack_combo_box(vbox2, 'Topology Type')\n        self.pack_string_option(vbox2, 'Topology', attach_dialog)\n        self.pack_string_option(vbox2, 'Communication Nodes', attach_dialog)\n        self.pack_check_button(vbox2, 'Check Node Access', False, False, 5)\n        self.pack_combo_box(vbox2, 'CP Policy')\n        self.pack_spinbutton(vbox2, 'Communication Processes per Node')\n        self.pack_spinbutton(vbox2, 'Daemons per Node')\n        frame.add(vbox2)\n        vbox.pack_start(frame, False, False, 0)\n        hbox = gtk.HBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: self.on_cancel_attach(w, attach_dialog))\n        hbox.pack_start(button, False, False, 0)\n        vbox.pack_end(hbox, False, False, 0)\n        label = gtk.Label('Topology')\n        notebook.append_page(vbox, label)\n\n        # misc options\n        vbox = gtk.VBox()\n        frame = gtk.Frame(label='Tool Paths')\n        vbox2 = gtk.VBox()\n        self.pack_string_option(vbox2, 'Tool Daemon Path', attach_dialog)\n        self.pack_string_option(vbox2, 'Filter Path', attach_dialog)\n        if HAVE_GDB_SUPPORT:\n            self.pack_check_button(vbox2, 'GDB BE')\n            self.pack_string_option(vbox2, 'GDB Path', attach_dialog)\n        frame.add(vbox2)\n        vbox.pack_start(frame, False, False, 5)\n        frame = gtk.Frame(label='Debug Logs')\n        vbox2 = gtk.VBox()\n        self.pack_check_button(vbox2, 'Log Frontend')\n        self.pack_check_button(vbox2, 'Log Backend')\n        self.pack_check_button(vbox2, 'Log CP')\n        self.pack_check_button(vbox2, 'Log SW')\n        self.pack_check_button(vbox2, 'Log SWERR')\n        self.pack_string_option(vbox2, 'Log Dir', attach_dialog)\n        self.pack_check_button(vbox2, 'Use MRNet Printf')\n        frame.add(vbox2)\n        vbox.pack_start(frame, False, False, 5)\n        frame = gtk.Frame(label='Misc')\n        vbox2 = gtk.VBox()\n        self.pack_combo_box(vbox2, 'Verbosity Type')\n        self.pack_check_button(vbox2, 'Debug Backends')\n        frame.add(vbox2)\n        vbox.pack_start(frame, False, False, 5)\n        hbox = gtk.HBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: self.on_cancel_attach(w, attach_dialog))\n        hbox.pack_start(button, False, False, 0)\n        vbox.pack_end(hbox, False, False, 0)\n        label = gtk.Label('Advanced')\n        notebook.append_page(vbox, label)\n\n        self.on_update_process_listing(None, process_frame, attach_dialog, self.filter_entry)\n        self.on_update_serial_process_listing(None, serial_process_frame, attach_dialog, self.serial_filter_entry)\n        attach_dialog.vbox.pack_start(notebook, True, True, 0)\n        attach_dialog.show_all()\n        attach_dialog.run()\n        self.sw = None\n        self.serial_sw = None\n        return True\n\n    def attach_serial_processes_cb(self, entry=None, attach_dialog=None, in_processes=None):\n        \"\"\"Callback to attach to serial processes.\"\"\"\n        processes = in_processes\n        if processes == None:\n            processes = entry.get_text()\n            processes = processes.split()\n        self.process_list = ' '.join(processes)\n        self.serial_attach = True\n        if len(processes) <= 0:\n            show_error_dialog('No processes selected.  Please select processes\\nto attach to by selecting the desired radio\\nbuttons and clicking \"Add Serial Process\" or by\\nmanually entering host:pid pairs in the text entry.', self)\n            return False\n        if self.STAT is None:\n            self.STAT = STAT_FrontEnd()\n        for process in processes:\n            self.STAT.addSerialProcess(process)\n        if self.options['GDB BE'] is True:\n            self.attach_cb(attach_dialog, False, True, STAT_SERIAL_GDB_ATTACH)\n        else:\n            self.attach_cb(attach_dialog, False, True, STAT_SERIAL_ATTACH)\n        return True\n\n    def launch_application_cb(self, entry=None, attach_dialog=None, in_args=None):\n        \"\"\"Callback to launch an application under STAT's control.\"\"\"\n        args = in_args\n        if args == None:\n            args = entry.get_text()\n            args = args.split()\n        if len(args) <= 0:\n            show_error_dialog('No launch string specified.  Please enter\\nthe application launch string.\\n', self)\n            return False\n        self.options['Launcher Exe'] = args[0]\n        for arg in args:\n            self.STAT.addLauncherArgv(arg)\n        self.attach_cb(attach_dialog, True, False, STAT_LAUNCH)\n        return True\n\n    def destroy_dysect_dialog(self, dialog):\n        self.dysect_dialog = None\n        self.close_visualizer(None)\n        self.on_detach(dialog)\n\n    def update_dysect_active_bar(self):\n        \"\"\"Register activity on the active bar.\"\"\"\n        if self.dysect_timer != None:\n            self.dysect_progress_bar.pulse()\n        return True\n\n    def close_visualizer(self, action):\n        if self.visualizer_window:\n            self.visualizer_window.destroy()\n            self.visualizer_window = None\n\n    def open_visualizer(self):\n        \"\"\" Open a visualization window \"\"\"\n        DysectView.show_default_probes = self.options[\"DySectAPI Show Default Probes\"]\n        if self.visualizer_window == None:\n            if hasattr(self, \"out_dir\"):\n                self.visualizer_window = DysectDotWindow(os.path.join(self.out_dir, 'dysect_session.dot'), self)\n            elif self.STAT != None:\n                self.visualizer_window = DysectDotWindow(os.path.join(self.STAT.getOutDir(), 'dysect_session.dot'), self)\n            else:\n                sys.stderr.write('could not determine dysect session dot file path\\n')\n                return False\n            self.visualizer_window.connect('destroy', self.close_visualizer)\n        else:\n            self.visualizer_window.present()\n\n    def scroll_probe_window(self, filename, line):\n        if line == None:\n            return\n        (session_file_directory, session_filename) = os.path.split(self.options['DySectAPI Session'])\n        if filename != session_filename and filename != self.options['DySectAPI Session']:\n            return\n        text_buffer = self.probe_text_view.get_buffer()\n        if text_buffer == None:\n            return\n        if self.marked_line_number != None:\n            (marked_line_start, marked_line_end) = self.marked_line_number\n            text_buffer.remove_tag_by_name(\"bold_tag\", marked_line_start, marked_line_end)\n        probe_line_start = text_buffer.get_iter_at_line(int(line) - 1)\n        self.probe_text_view.scroll_to_iter(probe_line_start, 0.0, True, 0.0, 0.7)\n        probe_line_end = text_buffer.get_iter_at_line_offset(int(line) - 1, self.line_number_width + 2)\n        text_buffer.apply_tag_by_name(\"bold_tag\", probe_line_start, probe_line_end)\n        self.marked_line_number = (probe_line_start, probe_line_end)\n\n    def stop_dysect_session(self, button):\n        self.dysect_session = False\n        button.set_sensitive(False)\n        if self.STAT:\n            self.STAT.dysectStop()\n        self.on_detach(button)\n\n    def attach_cb(self, attach_dialog, launch, serial, application_option=STAT_ATTACH):\n        \"\"\"Callback to attach to a job and gather a stack trace.\"\"\"\n        if serial is False:\n            self.serial_attach = False\n            self.process_list = None\n        else:\n            self.serial_attach = True\n        if attach_dialog is not None:\n            run_gtk_main_loop()\n            attach_dialog.hide()\n        stat_wait_dialog.update_progress_bar(0.01)\n        try:\n            self.options['Topology Type'] = self.types['Topology Type'][self.combo_boxes['Topology Type'].get_active()]\n            self.options['CP Policy'] = self.types['CP Policy'][self.combo_boxes['CP Policy'].get_active()]\n            self.options['Verbosity Type'] = self.types['Verbosity Type'][self.combo_boxes['Verbosity Type'].get_active()]\n            self.options['Communication Processes per Node'] = int(self.spinners['Communication Processes per Node'].get_value())\n            self.options['Daemons per Node'] = int(self.spinners['Daemons per Node'].get_value())\n        except Exception as e:\n            pass\n        if self.options['Check Node Access'] == True:\n            os.environ['STAT_CHECK_NODE_ACCESS'] = '1'\n        if self.STAT is None:\n            self.STAT = STAT_FrontEnd()\n        if launch is False and serial is False:\n            if self.options['PID'] is None:\n                show_error_dialog('No job selected.  Please select a valid\\njob launcher process to attach to.\\n', self)\n                return False\n\n        self.STAT.setToolDaemonExe(self.options['Tool Daemon Path'])\n        self.STAT.setFilterPath(self.options['Filter Path'])\n        os.environ['STAT_GDB'] = self.options['GDB Path']\n        log_type = STAT_LOG_NONE\n        if self.options['GDB BE'] and application_option != STAT_SERIAL_GDB_ATTACH:\n            application_option = STAT_GDB_ATTACH\n        if self.options['Log Frontend']:\n            log_type |= STAT_LOG_FE\n        if self.options['Log Backend']:\n            log_type |= STAT_LOG_BE\n        if self.options['Log CP']:\n            log_type |= STAT_LOG_CP\n        if self.options['Log SW']:\n            log_type |= STAT_LOG_SW\n        if self.options['Log SWERR']:\n            log_type |= STAT_LOG_SWERR\n        if self.options['Use MRNet Printf']:\n            log_type |= STAT_LOG_MRN\n        if log_type != STAT_LOG_NONE:\n            ret = self.STAT.startLog(log_type, self.options['Log Dir'])\n            if ret != STAT_OK:\n                show_error_dialog('Failed to Start Log:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return False\n        if self.options['Verbosity Type'] == 'error':\n            self.STAT.setVerbose(STAT_VERBOSE_ERROR)\n        elif self.options['Verbosity Type'] == 'stdout':\n            self.STAT.setVerbose(STAT_VERBOSE_STDOUT)\n        elif self.options['Verbosity Type'] == 'full':\n            self.STAT.setVerbose(STAT_VERBOSE_FULL)\n        if self.options['Debug Backends']:\n            os.environ['LMON_DEBUG_BES'] = \"1\"\n        else:\n            if 'LMON_DEBUG_BES' in os.environ:\n                del os.environ['LMON_DEBUG_BES']\n        if HAVE_DYSECT is True and self.options['Enable DySectAPI'] is True:\n            os.environ['STAT_GROUP_OPS'] = \"1\"\n        self.STAT.setProcsPerNode(self.options['Communication Processes per Node'])\n        self.STAT.setNDaemonsPerNode(self.options['Daemons per Node'])\n        stat_wait_dialog.update_progress_bar(0.05)\n\n        self.STAT.setApplicationOption(application_option)\n        if launch is False:\n            if serial is False:\n                if self.options['Remote Host'] != \"localhost\":\n                    ret = self.STAT.attachAndSpawnDaemons(self.options['PID'], self.options['Remote Host'])\n                else:\n                    ret = self.STAT.attachAndSpawnDaemons(self.options['PID'])\n            else:\n                ret = self.STAT.setupForSerialAttach()\n        else:\n            if self.options['Remote Host'] != \"localhost\":\n                ret = self.STAT.launchAndSpawnDaemons(self.options['Remote Host'])\n            else:\n                ret = self.STAT.launchAndSpawnDaemons()\n            if self.options['PID'] is None:\n                self.set_proctab()\n                self.options['PID'] = self.proctab.launcher_pid\n        if 'LMON_DEBUG_BES' in os.environ:\n            del os.environ['LMON_DEBUG_BES']\n        if ret != STAT_OK:\n            show_error_dialog('Failed to Launch Daemons:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return False\n        stat_wait_dialog.update(0.10)\n\n        topology_type = STAT_TOPOLOGY_AUTO\n        if self.options['Topology Type'] == 'automatic':\n            topology_type = STAT_TOPOLOGY_AUTO\n        elif self.options['Topology Type'] == 'depth':\n            topology_type = STAT_TOPOLOGY_DEPTH\n        elif self.options['Topology Type'] == 'max fanout':\n            topology_type = STAT_TOPOLOGY_FANOUT\n        elif self.options['Topology Type'] == 'custom':\n            topology_type = STAT_TOPOLOGY_USER\n\n        cp_policy = STAT_CP_NONE\n        if self.options['CP Policy'] == 'share app nodes':\n            cp_policy = STAT_CP_SHAREAPPNODES\n        elif self.options['CP Policy'] == 'exclusive':\n            cp_policy = STAT_CP_EXCLUSIVE\n\n        if self.options['Communication Nodes'] != '':\n            ret = self.STAT.launchMrnetTree(topology_type, self.options['Topology'], self.options['Communication Nodes'], False, cp_policy)\n        else:\n            ret = self.STAT.launchMrnetTree(topology_type, self.options['Topology'], '', False, cp_policy)\n        if ret != STAT_OK:\n            show_error_dialog('Failed to Launch MRNet Tree:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return False\n\n        if application_option != STAT_SERIAL_ATTACH and application_option != STAT_SERIAL_GDB_ATTACH:\n            while 1:\n                run_gtk_main_loop()\n                ret = self.STAT.connectMrnetTree(False)\n                if ret == STAT_OK:\n                    break\n                elif ret != STAT_PENDING_ACK:\n                    show_error_dialog('Failed to connect to MRNet tree:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                    self.on_fatal_error()\n                    return ret\n        ret = self.STAT.setupConnectedMrnetTree()\n        if ret != STAT_OK:\n            show_error_dialog('Failed to setup STAT:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return False\n\n        stat_wait_dialog.update(0.15)\n        ret = self.STAT.attachApplication(False)\n        if ret != STAT_OK:\n            show_error_dialog('Failed to attach to application:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return False\n        while 1:\n            run_gtk_main_loop()\n            ret = self.STAT.receiveAck(False)\n            if ret == STAT_OK:\n                break\n            elif ret != STAT_PENDING_ACK:\n                show_error_dialog('Failed to attach:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return ret\n        stat_wait_dialog.update(0.20)\n        self.attached = True\n\n        if HAVE_DYSECT is True and self.options['Enable DySectAPI'] is True:\n            stat_wait_dialog.destroy()\n            self.run_dysect_session()\n        else:\n            ret = self.sample()\n            if ret != STAT_OK:\n                return ret\n            self.set_action_sensitivity('paused')\n            stat_wait_dialog.update_progress_bar(1.0)\n\n    def on_detach(self, widget, stop_list=intArray(0), stop_list_len=0):\n        \"\"\"Determine the process state and detach from the current job.\"\"\"\n        self.proctab_file_path = None\n        self.proctab = None\n        if self.attached is False:\n            self.STAT = None\n            self.reattach = False\n            return True\n        self.var_spec = []\n        self.show_all()\n\n        ret = self.STAT.detachApplication(stop_list, stop_list_len, False)\n        if ret != STAT_OK:\n            show_error_dialog('Failed to detach from application:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return ret\n        while 1:\n            run_gtk_main_loop()\n            ret = self.STAT.receiveAck(False)\n            if ret == STAT_OK:\n                break\n            elif ret != STAT_PENDING_ACK:\n                show_error_dialog('Failed to sample stack trace:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return ret\n        if ret != STAT_OK:\n            show_error_dialog('Failed to detach from application:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return False\n        self.STAT.shutDown()\n        self.STAT = None\n        self.reattach = True\n        self.attached = False\n        self.set_action_sensitivity('detached')\n\n    def on_destroy(self, action):\n        \"\"\"Callback to quit.\"\"\"\n        if self.STAT is not None:\n            if self.attached:\n                ret = self.STAT.detachApplication(True)\n                if ret != STAT_OK:\n                    sys.stderr.write('Failed to detach from application:\\n%s\\n' % self.STAT.getLastErrorMessage())\n                self.STAT.shutDown()\n            self.STAT = None\n        gtk.main_quit()\n\n    def on_pause(self, action=None):\n        \"\"\"Callback to pause the job.\"\"\"\n        self.set_action_sensitivity('paused')\n        ret = self.STAT.pause()\n        if ret != STAT_OK:\n            show_error_dialog('Failed to pause application:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return ret\n        while 1:\n            run_gtk_main_loop()\n            ret = self.STAT.receiveAck(False)\n            if ret == STAT_OK:\n                break\n            elif ret != STAT_PENDING_ACK:\n                show_error_dialog('Failed to pause application:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return ret\n        return ret\n\n    def on_resume(self, action=None):\n        \"\"\"Callback to resume the job.\"\"\"\n        self.set_action_sensitivity('running')\n        ret = self.STAT.resume()\n        if ret != STAT_OK:\n            show_error_dialog('Failed to resume application:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return ret\n        while 1:\n            run_gtk_main_loop()\n            ret = self.STAT.receiveAck(False)\n            if ret == STAT_OK:\n                break\n            elif ret != STAT_PENDING_ACK:\n                show_error_dialog('Failed to resume application:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return ret\n        return ret\n\n    def on_kill(self, action):\n        \"\"\"Callback to kill the job.\"\"\"\n        self.set_action_sensitivity('new')\n\n    def update_sample_options(self):\n        \"\"\"Update sample options.\"\"\"\n        for option in ['Num Retries', 'Retry Frequency (us)', 'Max Threads Per Daemon', 'Run Time Before Sample (sec)', 'Num Traces', 'Trace Frequency (ms)']:\n            try:\n                self.options[option] = int(self.spinners[option].get_value())\n            except:\n                pass\n\n    def sleep(self, seconds):\n        \"\"\"Sleep for specified time with a progress bar.\"\"\"\n        for i in range(int(seconds * 100)):\n            stat_wait_dialog.update_progress_bar(float(i) / seconds / 100)\n            time.sleep(.01)\n\n    def update_prefs_and_sample_cb(self, sample_function, widget, dialog, action):\n        \"\"\"Callback to update sample preferences and sample traces.\"\"\"\n        dialog.hide()\n        self.update_sample_options()\n        if self.options['Run Time Before Sample (sec)'] != 0:\n            if self.STAT.isRunning() is False:\n                ret = self.on_resume()\n                if ret != STAT_OK:\n                    return False\n            stat_wait_dialog.show_wait_dialog_and_run(self.sleep, (self.options['Run Time Before Sample (sec)'],), [], self)\n        if sample_function == self.sample_multiple:\n            stat_wait_dialog.show_wait_dialog_and_run(sample_function, (), self.sample_task_list, self, True)\n        else:\n            stat_wait_dialog.show_wait_dialog_and_run(sample_function, (), self.sample_task_list, self)\n\n    def on_sample(self, action, multiple):\n        \"\"\"Callback to sample stack traces.\"\"\"\n        dialog = gtk.Dialog('Stack Sample Preferences', self)\n        vbox = gtk.VBox()\n        self.pack_sample_options(vbox, multiple)\n        dialog.vbox.pack_start(vbox, False, False, 0)\n        hbox = gtk.HButtonBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: dialog.destroy())\n        hbox.pack_start(button, False, True, 0)\n        button = gtk.Button(stock=gtk.STOCK_OK)\n        if multiple is True:\n            button.connect(\"clicked\", lambda w: self.update_prefs_and_sample_cb(self.sample_multiple, w, dialog, 'OK'))\n        else:\n            button.connect(\"clicked\", lambda w: self.update_prefs_and_sample_cb(self.sample, w, dialog, 'OK'))\n        hbox.pack_start(button, False, True, 0)\n        dialog.vbox.pack_start(hbox, False, False, 0)\n        dialog.show_all()\n        dialog.run()\n\n    def sample(self, keep_var_spec=False):\n        \"\"\"Sample stack traces.\"\"\"\n        ret_val = STAT_OK\n        if keep_var_spec is False:\n            self.var_spec = []\n            # below is a test for local variables:\n            #self.var_spec.append((\"/g/g0/lee218/src/STAT/examples/src/to_test.c\", 38, 5, \"i\"))\n            #self.var_spec.append((\"/g/g0/lee218/src/STAT/examples/src/to_test.c\", 38, 4, \"i\"))\n        self.update_sample_options()\n        ret = self.STAT.pause()\n        stat_wait_dialog.update_progress_bar(0.35)\n        self.set_action_sensitivity('paused')\n        if ret != STAT_OK:\n            show_error_dialog('Failed to pause application during sample stack trace operation:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return ret\n\n        sample_type = 0\n        if self.options['Sample Type'] == 'function and pc':\n            sample_type += STAT_SAMPLE_PC\n        if self.options['Sample Type'] == 'module offset':\n            sample_type += STAT_SAMPLE_MODULE_OFFSET\n        if self.options['Sample Type'] == 'function and line':\n            sample_type += STAT_SAMPLE_LINE\n        if self.options['Edge Type'] != 'full list':\n            sample_type += STAT_SAMPLE_COUNT_REP\n        if self.options['With Threads']:\n            sample_type += STAT_SAMPLE_THREADS\n        if self.options['With OpenMP'] and HAVE_OPENMP_SUPPORT:\n            sample_type += STAT_SAMPLE_OPENMP\n        if self.options['With CUDA Quick'] and HAVE_GDB_SUPPORT:\n            sample_type += STAT_SAMPLE_CUDA_QUICK\n        if self.options['Gather Python Traces']:\n            sample_type += STAT_SAMPLE_PYTHON\n        if self.options['Clear On Sample']:\n            sample_type += STAT_SAMPLE_CLEAR_ON_SAMPLE\n        ret = self.STAT.sampleStackTraces(sample_type, 1, 1, self.options['Num Retries'], self.options['Retry Frequency (us)'], self.options['Max Threads Per Daemon'], False, var_spec_to_string(self.var_spec))\n\n        if ret != STAT_OK:\n            show_error_dialog('Failed to sample stack trace:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return ret\n        while 1:\n            run_gtk_main_loop()\n            ret = self.STAT.receiveAck(False)\n            if ret == STAT_OK:\n                break\n            elif ret != STAT_PENDING_ACK:\n                show_error_dialog('Failed to sample stack trace:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return ret\n        stat_wait_dialog.update(0.60)\n        ret = self.STAT.gatherLastTrace(False)\n        if ret != STAT_OK:\n            show_error_dialog('Failed to gather stack trace:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return ret\n        while 1:\n            run_gtk_main_loop()\n            ret = self.STAT.receiveAck(False)\n            if ret == STAT_OK:\n                break\n            elif ret != STAT_PENDING_ACK:\n                show_error_dialog('Failed to sample stack trace:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return ret\n        stat_wait_dialog.update(0.70)\n        filename = self.STAT.getLastDotFilename()\n        try:\n            with open(filename, 'r') as f:\n                self.tabs[self.notebook.get_current_page()].history_view.get_buffer().set_text('')\n                self.set_dotcode(f.read(), filename, self.notebook.get_current_page())\n        except IOError as e:\n            show_error_dialog('%s\\nFailed to open file %s' % (repr(e), filename), self)\n            return ret\n        except Exception as e:\n            show_error_dialog('%s\\nFailed to process file %s' % (repr(e), filename), self)\n            return ret\n        stat_wait_dialog.update(1.0)\n        if ret_val != STAT_OK:\n            show_error_dialog('An error was detected:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n        return ret_val\n\n    def sample_multiple(self):\n        \"\"\"Sample multiple stack traces.\"\"\"\n\n        ret_val = STAT_OK\n        self.update_sample_options()\n        stat_wait_dialog.update_progress_bar(0.01)\n\n        previous_clear = self.options['Clear On Sample']\n        for i in range(self.options['Num Traces']):\n            if stat_wait_dialog.cancelled is True:\n                stat_wait_dialog.cancelled = False\n                break\n            if i == 1:\n                self.options['Clear On Sample'] = False\n            ret = self.STAT.pause()\n            if ret == STAT_APPLICATION_EXITED:\n                ret_val = STAT_APPLICATION_EXITED\n                break\n            if ret != STAT_OK:\n                show_error_dialog('Failed to pause application during sample multiple operation:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return ret\n            self.set_action_sensitivity('paused')\n\n            sample_type = 0\n            if self.options['Sample Type'] == 'function and pc':\n                sample_type += STAT_SAMPLE_PC\n            if self.options['Sample Type'] == 'module offset':\n                sample_type += STAT_SAMPLE_MODULE_OFFSET\n            if self.options['Sample Type'] == 'function and line':\n                sample_type += STAT_SAMPLE_LINE\n            if self.options['Edge Type'] != 'full list':\n                sample_type += STAT_SAMPLE_COUNT_REP\n            if self.options['With Threads']:\n                sample_type += STAT_SAMPLE_THREADS\n            if self.options['With OpenMP'] and HAVE_OPENMP_SUPPORT:\n                sample_type += STAT_SAMPLE_OPENMP\n            if self.options['With CUDA Quick'] and HAVE_GDB_SUPPORT:\n                sample_type += STAT_SAMPLE_CUDA_QUICK\n            if self.options['Gather Python Traces']:\n                sample_type += STAT_SAMPLE_PYTHON\n            if self.options['Clear On Sample']:\n                sample_type += STAT_SAMPLE_CLEAR_ON_SAMPLE\n            ret = self.STAT.sampleStackTraces(sample_type, 1, 0, self.options['Num Retries'], self.options['Retry Frequency (us)'], self.options['Max Threads Per Daemon'], False, var_spec_to_string(self.var_spec))\n            if ret != STAT_OK:\n                if ret == STAT_APPLICATION_EXITED:\n                    ret_val = STAT_APPLICATION_EXITED\n                    break\n                show_error_dialog('Failed to sample stack trace:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return ret\n            while 1:\n                run_gtk_main_loop()\n                ret = self.STAT.receiveAck(False)\n                if ret == STAT_OK:\n                    break\n                elif ret == STAT_APPLICATION_EXITED:\n                    ret_val = STAT_APPLICATION_EXITED\n                    break\n                elif ret != STAT_PENDING_ACK:\n                    show_error_dialog('Failed to receive ack from sample operation:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                    self.on_fatal_error()\n                    return ret\n            if ret == STAT_APPLICATION_EXITED:\n                ret_val = STAT_APPLICATION_EXITED\n                break\n\n            if self.options['Gather Individual Samples'] is True:\n                ret = self.STAT.gatherLastTrace(False)\n                if ret != STAT_OK:\n                    show_error_dialog('Failed to gather last stack trace:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                    self.on_fatal_error()\n                    return ret\n                while 1:\n                    run_gtk_main_loop()\n                    ret = self.STAT.receiveAck(False)\n                    if ret == STAT_OK:\n                        break\n                    elif ret != STAT_PENDING_ACK:\n                        show_error_dialog('Failed to receive last stack trace:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                        self.on_fatal_error()\n                        return ret\n                filename = self.STAT.getLastDotFilename()\n                try:\n                    with open(filename, 'r') as f:\n                        page = self.notebook.get_current_page()\n                        self.create_new_tab(page + 1)\n                        self.notebook.set_current_page(page + 1)\n                        self.tabs[self.notebook.get_current_page()].history_view.get_buffer().set_text('')\n                        self.set_dotcode(f.read(), filename, self.notebook.get_current_page())\n                except IOError as e:\n                    show_error_dialog('%s\\nFailed to open file %s' % (repr(e), filename), self)\n                    return False\n                except Exception as e:\n                    show_error_dialog('%s\\nFailed to process file %s' % (repr(e), filename), self)\n                    return False\n\n            stat_wait_dialog.update_progress_bar(float(i) / self.options['Num Traces'])\n            if ret_val != STAT_OK:\n                break\n            if i != self.options['Num Traces'] - 1:\n                ret = self.STAT.resume()\n                if ret == STAT_APPLICATION_EXITED:\n                    ret_val = STAT_APPLICATION_EXITED\n                    break\n                elif ret != STAT_OK:\n                    return ret\n                self.set_action_sensitivity('running')\n                for i in range(int(self.options['Trace Frequency (ms)'] / 10)):\n                    time.sleep(.01)\n                    run_gtk_main_loop()\n        self.options['Clear On Sample'] = previous_clear\n        stat_wait_dialog.update(0.91)\n        ret = self.STAT.gatherTraces(False)\n        if ret != STAT_OK:\n            show_error_dialog('Failed to gather stack traces:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n            return ret\n        while 1:\n            run_gtk_main_loop()\n            ret = self.STAT.receiveAck(False)\n            if ret == STAT_OK:\n                break\n            elif ret != STAT_PENDING_ACK:\n                show_error_dialog('Failed to gather stack traces:\\n%s' % self.STAT.getLastErrorMessage(), self)\n                self.on_fatal_error()\n                return ret\n        stat_wait_dialog.update(0.95)\n        filename = self.STAT.getLastDotFilename()\n        try:\n            with open(filename, 'r') as f:\n                if self.options['Gather Individual Samples'] is True:\n                    page = self.notebook.get_current_page()\n                    self.create_new_tab(page + 1)\n                    self.notebook.set_current_page(page + 1)\n                else:\n                    self.tabs[self.notebook.get_current_page()].history_view.get_buffer().set_text('')\n                self.set_dotcode(f.read(), filename, self.notebook.get_current_page())\n        except IOError as e:\n            show_error_dialog('%s\\nFailed to open file %s' % (repr(e), filename), self)\n            return False\n        except Exception as e:\n            show_error_dialog('%s\\nFailed to process file %s' % (repr(e), filename), self)\n            return False\n        stat_wait_dialog.update(1.0)\n        if ret_val != STAT_OK:\n            show_error_dialog('An error was detected:\\n%s' % self.STAT.getLastErrorMessage(), self)\n            self.on_fatal_error()\n\n        return ret_val\n\n    def run_dysect_session(self):\n        \"\"\"Run the dysect session.\"\"\"\n\n        self.set_action_sensitivity('busy')\n        self.STAT.resume()\n        dysect_c = '%s/bin/dysectc' % self.STAT.getInstallPrefix()\n        if not os.path.exists(dysect_c):\n            show_error_dialog('DySect compiler %s not found' % dysect_c, self)\n            self.on_fatal_error()\n            return -1\n        proc = subprocess.Popen([dysect_c, self.options['DySectAPI Session']], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n        stdout_output, stderr_output = proc.communicate()\n        if stderr_output != '':\n            sys.stderr.write('dysectc outputted error message: %s\\n' % stderr_output)\n        if proc.returncode != 0:\n            show_error_dialog('Failed to compile session %s:\\n\\n%s' % (self.options['DySectAPI Session'], stderr_output))\n            self.on_fatal_error()\n            return proc.returncode\n        session_so = os.path.join(os.getcwd(), 'lib' + os.path.basename(self.options['DySectAPI Session']).strip('.cpp') + '.so')\n        if not os.path.exists(session_so):\n            show_error_dialog('Compiled session %s not found' % session_so)\n            self.on_fatal_error()\n            return -1\n        dysect_args = self.options[\"DySectAPI Session Args\"].split()\n        ret = self.STAT.dysectSetup(session_so, -1, len(dysect_args), dysect_args)\n        if ret != STAT_OK:\n            show_error_dialog('Failed to setup DySect Session %s:\\n%s' % (session_so, self.STAT.getLastErrorMessage()), self)\n            self.on_fatal_error()\n            return ret\n        self.dysect_session = True\n\n        self.dysect_dialog = gtk.Dialog(\"DySectAPI Console\", self)\n        self.dysect_dialog.set_default_size(1048, 630)\n        self.dysect_dialog.set_destroy_with_parent(True)\n        self.dysect_dialog.connect('destroy', lambda w: self.destroy_dysect_dialog(w))\n        vpaned = gtk.VPaned()\n        my_frame = gtk.Frame(label=\"Session %s:\" % self.options['DySectAPI Session'])\n        sw = gtk.ScrolledWindow()\n        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n        text_view = gtk.TextView()\n        self.probe_text_view = text_view\n        text_view.set_editable(False)\n        text_view.set_cursor_visible(False)\n        text_view_buffer = text_view.get_buffer()\n        text_view.set_wrap_mode(gtk.WRAP_NONE)\n        sw.add(text_view)\n        my_frame.add(sw)\n        with open(self.options['DySectAPI Session'], \"r\") as dysect_session_file:\n            if HAVE_PYGMENTS:\n                text_view_buffer.create_tag(\"monospace\", family=\"monospace\")\n                pygments.highlight(dysect_session_file.read(), CppLexer(), STATviewFormatter())\n                text_view_buffer.create_tag('bold_tag', weight=pango.WEIGHT_BOLD)\n                text_view_buffer.create_tag('italics_tag', style=pango.STYLE_ITALIC)\n                text_view_buffer.create_tag('underline_tag', underline=pango.UNDERLINE_SINGLE)\n                lines = STAThelper.pygments_lines\n                iterator = text_view_buffer.get_iter_at_offset(0)\n                width = len(str(len(lines)))\n                self.line_number_width = width\n                for i, line in enumerate(lines):\n                    source_string = \"%0*d| \" % (width, i + 1)\n                    text_view_buffer.insert_with_tags_by_name(iterator, source_string, \"monospace\")\n                    for item in line:\n                        source_string, format_tuple = item\n                        pygments_color, bold, italics, underline = format_tuple\n                        foreground = gtk.gdk.color_parse(pygments_color)\n                        fore_color_tag = \"color_fore%s\" % (pygments_color)\n                        try:\n                            text_view_buffer.create_tag(fore_color_tag, foreground_gdk=foreground)\n                        except:\n                            pass\n                        args = [iterator, source_string, fore_color_tag, \"monospace\"]\n                        if bold:\n                            args.append('bold_tag')\n                        if italics:\n                            args.append('italics_tag')\n                        if underline:\n                            args.append('underline_tag')\n                        text_view_buffer.insert_with_tags_by_name(*tuple(args))\n            else:\n                text_view_buffer.set_text(dysect_session_file.read())\n        vpaned.pack1(my_frame, True, True)\n        self.separator = gtk.HSeparator()\n        self.dysect_dialog.vbox.pack_start(self.separator, False, True, 5)\n\n        self.out_dir = self.STAT.getOutDir()\n        dysect_outfile = os.path.join(self.out_dir, 'dysect_output.txt')\n        my_frame = gtk.Frame(label=\"Output %s:\" % dysect_outfile)\n        sw = gtk.ScrolledWindow()\n        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n        text_view = gtk.TextView()\n        text_view.set_editable(False)\n        text_view.set_cursor_visible(False)\n        text_view_buffer = text_view.get_buffer()\n        iterator = text_view_buffer.get_iter_at_offset(0)\n        text_view_buffer.create_tag(\"monospace\", family=\"monospace\")\n        text_view.set_wrap_mode(gtk.WRAP_NONE)\n        sw.add(text_view)\n        my_frame.add(sw)\n        vpaned.pack2(my_frame, True, True)\n        self.dysect_dialog.vbox.pack_start(vpaned, True, True, 5)\n        self.separator = gtk.HSeparator()\n        self.dysect_dialog.vbox.pack_start(self.separator, False, True, 5)\n\n        # Visualization button\n        vis_box = gtk.HButtonBox()\n        vis_button = gtk.Button(\"_Visualize Probe Tree\")\n        vis_button.connect(\"clicked\", lambda w: self.open_visualizer())\n        vis_box.pack_end(vis_button, False, True, 5)\n\n        box2 = gtk.HButtonBox()\n        stop_button = gtk.Button(stock=gtk.STOCK_STOP)\n        stop_button.connect(\"clicked\", lambda w: self.stop_dysect_session(w))\n        box2.pack_end(stop_button, False, True, 5)\n        self.dysect_timer = gobject.timeout_add(75, self.update_dysect_active_bar)\n        self.dysect_progress_bar = gtk.ProgressBar()\n        self.dysect_progress_bar.set_fraction(0.0)\n        self.dysect_progress_bar.set_text('session running')\n        box2.pack_start(self.dysect_progress_bar, True, True, 5)\n        dyysect_ok_button = gtk.Button(stock=gtk.STOCK_OK)\n        dyysect_ok_button.connect(\"clicked\", lambda w: self.dysect_dialog.destroy())\n        dyysect_ok_button.set_sensitive(False)\n        box2.pack_end(dyysect_ok_button, False, True, 5)\n        self.dysect_dialog.vbox.pack_end(box2, False, False, 0)\n        self.dysect_dialog.vbox.pack_end(vis_box, False, False, 5)\n        self.dysect_dialog.show_all()\n\n        if not os.path.exists(dysect_outfile):\n            sys.stderr.write('DySect session output file %s not found\\n' % dysect_outfile)\n            self.on_fatal_error()\n            return -1\n        with open(dysect_outfile, \"r\") as dysect_output_file:\n            prev = ''\n            dot_file_list = []\n            break_next_iter = False\n            while 1 and self.dysect_session is True and self.STAT != None:\n                filename = self.STAT.getLastDotFilename()\n                if filename != \"NULL\" and filename != prev:\n                    prev = filename\n                    for file in os.listdir(self.out_dir):\n                        if file.find('.dot') == -1 or file in dot_file_list or file == \"dysect_session.dot\":\n                            continue\n                        dot_file_list.append(file)\n                        filename = os.path.join(self.out_dir, file)\n                        if len(dot_file_list) > 1:\n                            page = self.notebook.get_current_page()\n                            self.create_new_tab(page + 1)\n                            self.notebook.set_current_page(page + 1)\n                        try:\n                            with open(filename, 'r') as dot_file:\n                                self.tabs[self.notebook.get_current_page()].history_view.get_buffer().set_text('')\n                                self.set_dotcode(dot_file.read(), filename, self.notebook.get_current_page())\n                        except IOError as e:\n                            show_error_dialog('%s\\nFailed to open file %s' % (repr(e), filename), self)\n                        except Exception as e:\n                            show_error_dialog('%s\\nFailed to process file %s' % (repr(e), filename), self)\n                text = dysect_output_file.read()\n                if text != '' and self.dysect_dialog != None:\n                    text_view_buffer.insert_with_tags_by_name(iterator, text, \"monospace\")\n                    self.dysect_dialog.show_all()\n\n                run_gtk_main_loop()\n                if break_next_iter is True:\n                    break\n                if self.dysect_session and self.STAT:\n                    ret = self.STAT.dysectListen(False)\n                    if ret != DysectAPI_SessionCont and ret != STAT_PENDING_ACK:\n                        break_next_iter = True\n        dyysect_ok_button.set_sensitive(True)\n        if self.dysect_timer != None:\n            gobject.source_remove(self.dysect_timer)\n            self.dysect_timer = None\n        self.dysect_progress_bar.set_fraction(1.0)\n        self.dysect_progress_bar.set_text('session complete')\n        if self.dysect_dialog != None:\n            self.dysect_dialog.show_all()\n        run_gtk_main_loop()\n        if self.STAT:\n            self.STAT.dysectStop()\n        stop_button.set_sensitive(False)\n        return STAT_OK\n\n    def on_identify_num_eq_classes(self, action):\n        \"\"\"Callback to identify equivalence classes.\"\"\"\n        if self.get_current_graph().cur_filename == '':\n            return False\n        num_eq_classes = self.get_current_graph().identify_num_eq_classes(self.get_current_widget())\n        self.eq_state = {}\n        self.dont_recurse = False\n        eq_dialog = gtk.Dialog(\"Equivalence Classes\", self)\n        eq_dialog.set_default_size(400, 400)\n        my_frame = gtk.Frame(label=\"%d Equivalence Classes:\" % (len(num_eq_classes)))\n        sw = gtk.ScrolledWindow()\n        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n        classes = []\n        for eq_class in num_eq_classes:\n            current_class = '['\n            prev = -2\n            in_range = False\n            task_count = 0\n            task_list, fill_color_string, font_color_string = eq_class\n            for num in task_list:\n                task_count += 1\n                if num == prev + 1:\n                    in_range = True\n                else:\n                    if in_range is True:\n                        current_class += '-%d' % prev\n                    if prev != -2:\n                        current_class += ', '\n                    current_class += '%d' % num\n                    in_range = False\n                prev = num\n            if in_range is True:\n                current_class += '-%d' % num\n            current_class += ']\\n'\n            item = {}\n            item['class'] = task_list\n            item['fill_color_string'] = fill_color_string\n            item['font_color_string'] = font_color_string\n            item['string'] = current_class.strip('\\n').replace(',', ', ')\n            classes.append(item)\n        hbox = gtk.HBox()\n        label = gtk.Label(' Rep  All  None  tasks')\n        hbox.pack_start(label, False, False, 0)\n        vbox = gtk.VBox()\n        vbox.pack_start(hbox, False, False, 0)\n        hbox = gtk.HBox()\n        rep_button = gtk.CheckButton()\n        all_button = gtk.CheckButton()\n        none_button = gtk.CheckButton()\n        rep_button.set_active(True)\n        hbox.pack_start(rep_button, False, False, 0)\n        hbox.pack_start(all_button, False, False, 7)\n        hbox.pack_start(none_button, False, False, 9)\n        label = gtk.Label(' select all')\n        hbox.pack_start(label, False, False, 0)\n        vbox.pack_start(hbox, False, False, 0)\n        self.eq_state['rep_button'] = rep_button\n        self.eq_state['all_button'] = all_button\n        self.eq_state['none_button'] = none_button\n        rep_button.connect('toggled', lambda w: self.on_toggle_eq(w, 'all', 'rep_button'))\n        all_button.connect('toggled', lambda w: self.on_toggle_eq(w, 'all', 'all_button'))\n        none_button.connect('toggled', lambda w: self.on_toggle_eq(w, 'all', 'none_button'))\n        for item in classes:\n            hbox = gtk.HBox()\n            rep_button = gtk_wrap_new_from_widget(None)\n            all_button = gtk_wrap_new_from_widget(rep_button)\n            none_button = gtk_wrap_new_from_widget(rep_button)\n            rep_button.connect('toggled', lambda w: self.on_toggle_eq(w, classes.index(item), 'rep_button'))\n            all_button.connect('toggled', lambda w: self.on_toggle_eq(w, classes.index(item), 'all_button'))\n            none_button.connect('toggled', lambda w: self.on_toggle_eq(w, classes.index(item), 'none_button'))\n            rep_button.set_active(True)\n            item['rep_button'] = rep_button\n            item['all_button'] = all_button\n            item['none_button'] = none_button\n            hbox.pack_start(rep_button, False, False, 0)\n            hbox.pack_start(all_button, False, False, 7)\n            hbox.pack_start(none_button, False, False, 9)\n            list_view = gtk.TextView()\n            list_view.set_wrap_mode(True)\n            list_view.set_editable(False)\n            list_view.set_cursor_visible(False)\n            iterator = list_view.get_buffer().get_iter_at_offset(0)\n            list_view.get_buffer().create_tag(\"monospace\", family=\"monospace\")\n            foreground = gtk.gdk.color_parse(item['font_color_string'])\n            background = gtk.gdk.color_parse(item['fill_color_string'])\n            fore_color_tag = 'fore%s%s' % (item['font_color_string'], item['fill_color_string'])\n            back_color_tag = 'back%s%s' % (item['font_color_string'], item['fill_color_string'])\n            list_view.get_buffer().create_tag(fore_color_tag, foreground_gdk=foreground)\n            list_view.get_buffer().create_tag(back_color_tag, background_gdk=background)\n            list_view.get_buffer().insert_with_tags_by_name(iterator, item['string'], fore_color_tag, back_color_tag, \"monospace\")\n            hbox.pack_start(list_view, True, True, 5)\n            vbox.pack_start(gtk.HSeparator(), False, False, 0)\n            vbox.pack_start(hbox, False, False, 0)\n        self.eq_state['classes'] = classes\n        sw.add_with_viewport(vbox)\n        my_frame.add(sw)\n        eq_dialog.vbox.pack_start(my_frame, True, True, 5)\n        my_frame = gtk.Frame(label=\"Manually Specify Additional Tasks:\")\n        entry = gtk.Entry()\n        entry.set_max_length(65536)\n        my_frame.add(entry)\n        self.eq_state['entry'] = entry\n        eq_dialog.vbox.pack_start(my_frame, False, False, 5)\n        self.separator = gtk.HSeparator()\n        eq_dialog.vbox.pack_start(self.separator, False, True, 5)\n        box2 = gtk.HButtonBox()\n\n        debuggers = ['TotalView', 'DDT']\n        for debugger in debuggers:\n            button = gtk.Button(\" Attach %s \\n to Subset \" % debugger)\n            button.connect(\"clicked\", self.launch_debugger_cb, (debugger, eq_dialog))\n            box2.pack_start(button, False, True, 5)\n        button = gtk.Button(\" Debugger \\n Options \")\n        button.connect(\"clicked\", self.set_debugger_options_cb, eq_dialog)\n        box2.pack_start(button, False, True, 5)\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w, d: eq_dialog.destroy(), \"ok\")\n        box2.pack_end(button, False, True, 5)\n        eq_dialog.vbox.pack_end(box2, False, False, 0)\n        eq_dialog.show_all()\n        return True\n\n    def set_debugger_options_cb(self, w, parent):\n        \"\"\"Callback to update debugger options.\"\"\"\n        dialog = gtk.Dialog('Debugger Options', parent)\n        frame = gtk.Frame(label='Options')\n        vbox = gtk.VBox()\n        self.pack_string_option(vbox, 'DDT Path', dialog)\n        self.pack_string_option(vbox, 'DDT LaunchMON Prefix', dialog)\n        self.pack_string_option(vbox, 'TotalView Path', dialog)\n        self.pack_string_option(vbox, 'Additional Debugger Args', dialog)\n        frame.add(vbox)\n        dialog.vbox.pack_start(frame, True, True, 0)\n        hbox = gtk.HButtonBox()\n        button = gtk.Button(stock=gtk.STOCK_CANCEL)\n        button.connect(\"clicked\", lambda w: dialog.destroy())\n        hbox.pack_start(button, True, True, 0)\n        button = gtk.Button(stock=gtk.STOCK_OK)\n        button.connect(\"clicked\", lambda w: dialog.destroy())\n        hbox.pack_start(button, True, True, 0)\n        dialog.vbox.pack_start(hbox, False, False, 10)\n        dialog.show_all()\n        dialog.run()\n\n    def on_toggle_eq(self, w, button, button_type):\n        \"\"\"Callback to toggle equivalence class representatives.\"\"\"\n        if self.dont_recurse is True:\n            return True\n        self.dont_recurse = True\n        self.eq_state['rep_button'].set_active(False)\n        self.eq_state['all_button'].set_active(False)\n        self.eq_state['none_button'].set_active(False)\n        if button == 'all':\n            for item in self.eq_state['classes']:\n                item[button_type].set_active(True)\n            self.eq_state[button_type].set_active(True)\n        self.dont_recurse = False\n        return True\n\n    def set_proctab(self):\n        if self.proctab_file_path is not None and self.proctab is not None:\n            return True\n        if self.STAT is None:\n            return False\n\n        self.proctab_file_path = ''\n        out_dir = self.STAT.getOutDir()\n        file_prefix = self.STAT.getFilePrefix()\n        self.proctab_file_path = out_dir + '/' + file_prefix + '.ptab'\n        if not os.path.exists(self.proctab_file_path):\n            failed_ptab_path = self.proctab_file_path\n            directory = os.path.dirname(os.path.abspath(self.get_current_graph().cur_filename))\n            self.proctab_file_path = ''\n            for filename in os.listdir(directory):\n                if filename.find('.ptab') != -1:\n                    self.proctab_file_path = directory + '/' + filename\n                    break\n        if self.proctab_file_path == '':\n            show_error_dialog('Failed to find process table file %s or .ptab file in %s.' % (failed_ptab_path, directory), self)\n            return False\n\n        try:\n            self.proctab = get_proctab(self.proctab_file_path)\n        except IOError as e:\n            show_error_dialog('%s\\nfailed to open process table file:\\n\\n%s\\n\\nPlease be sure that it is a valid process table file outputted from STAT.' % (repr(e), self.proctab_file_path), self)\n            return False\n        except Exception as e:\n            show_error_dialog('%s\\nfailed to process process table file:\\n\\n%s\\n\\nPlease be sure that it is a valid process table file outputted from STAT.' % (repr(e), self.proctab_file_path), self)\n            return False\n        return True\n\n    def launch_debugger_cb(self, widget, args):\n        \"\"\"Callback to launch full-featured debugger on a subset of tasks.\"\"\"\n        if self.attached is False:\n            show_error_dialog('Subset attach is only available when STAT is attached to the application.  Please (re)attach to the application.', self)\n            return False\n        debugger, eq_dialog = args\n        subset_list = []\n        for item in self.eq_state['classes']:\n            if item['rep_button'].get_active() is True and len(item['class']) > 0:\n                subset_list.append(item['class'][0])\n            elif item['all_button'].get_active() is True and len(item['class']) > 0:\n                subset_list += item['class']\n        additional_tasks = '[' + self.eq_state['entry'].get_text().strip(' ').strip('[').strip(']') + ']'\n        task_list_set = set(get_task_list(additional_tasks) + subset_list)\n        subset_list = list(task_list_set)\n        if subset_list == []:\n            show_error_dialog('No tasks selected.  Please choose a subset of tasks to debug', self)\n            return False\n        eq_dialog.destroy()\n        # use current STAT session to determine job launcher PID\n        ret = self.set_proctab()\n        if ret is False:\n            return False\n        executable = self.proctab.executable_path\n        self.executable_path = executable\n        self.cancel = False\n        while os.path.exists(self.executable_path) is False and self.cancel is False:\n            # Open dialog prompting for base path\n            dialog = gtk.Dialog('Please enter the full path for the executable')\n            label = gtk.Label('Failed to find executable:\\n%s\\nPlease enter the executable full path' % self.executable_path)\n            dialog.vbox.pack_start(label, True, True, 0)\n            entry = gtk.Entry()\n            entry.set_max_length(8192)\n\n            def activate_entry(entry, dialog):\n                self.executable_path = entry.get_text()\n                dialog.destroy()\n            entry.connect(\"activate\", lambda w: activate_entry(entry, dialog))\n            dialog.vbox.pack_start(entry, True, True, 0)\n            hbox = gtk.HButtonBox()\n            button = gtk.Button(stock=gtk.STOCK_CANCEL)\n\n            def cancel_entry(dialog):\n                entry.set_text('cancel_operation')\n                self.cancel = True\n                dialog.destroy()\n            button.connect(\"clicked\", lambda w: cancel_entry(dialog))\n            hbox.pack_start(button, False, False, 0)\n            button = gtk.Button(stock=gtk.STOCK_OK)\n            button.connect(\"clicked\", lambda w: activate_entry(entry, dialog))\n            hbox.pack_start(button, False, False, 0)\n            dialog.vbox.pack_start(hbox, False, False, 0)\n            dialog.show_all()\n            dialog.run()\n            if entry.get_text() == 'cancel_operation':\n                dialog.destroy()\n                return False\n        if self.cancel is True:\n            return False\n        pids = []\n        hosts = []\n        exes = []\n        for rank, host, pid, exe_index in self.proctab.process_list:\n            if rank in subset_list:\n                pids.append(pid)\n                hosts.append(host)\n                exes.append(self.proctab.executable_paths[exe_index])\n        arg_list = []\n        if debugger == 'TotalView':\n            filepath = self.options['TotalView Path']\n            if not filepath or not os.access(filepath, os.X_OK):\n                show_error_dialog('Failed to locate executable totalview\\ndefault: %s\\n' % filepath, self)\n                return\n            arg_list.append(filepath)\n            cli_attach = False\n            if self.STAT is not None:\n                if self.STAT.getApplicationOption() == STAT_SERIAL_ATTACH or self.STAT.getApplicationOption() != STAT_SERIAL_GDB_ATTACH:\n                    cli_attach = True\n            if cli_attach is True:\n                arg_list.append('-e')\n                for counter, rank in enumerate(subset_list):\n                    if counter == 0:\n                        cli_command = \"set new_pid [dattach -r %s -e %s %d] ;\" % (hosts[counter], exes[counter], pids[counter])\n                    else:\n                        cli_command += \" dattach -r %s -g $CGROUP($new_pid) -e %s %d ;\" % (hosts[counter], exes[counter], pids[counter])\n                arg_list.append(cli_command)\n            else:\n                arg_list.append('-parallel_attach')\n                arg_list.append('yes')\n                if self.options['Remote Host'] not in ['localhost', '']:\n                    arg_list.append('-remote')\n                    arg_list.append(self.options['Remote Host'])\n                arg_list.append('-pid')\n                arg_list.append(str(self.proctab.launcher_pid))\n                str_list = ''\n                for rank in subset_list:\n                    str_list += '%s ' % (rank)\n                arg_list.append('-default_parallel_attach_subset=%s' % (str_list))\n                exe = self.options['Launcher Exe']\n                if (exe.find(' \\\\_') != -1):\n                    exe = exe.split()[1]\n                else:\n                    exe = exe.split()[0]\n                arg_list.append(exe)\n        elif debugger == 'DDT':\n            filepath = self.options['DDT Path']\n            if not filepath or not os.access(filepath, os.X_OK):\n                show_error_dialog('Failed to locate executable ddt\\ndefault: %s\\n' % filepath, self)\n                return\n\n            arg_list.append(filepath)\n            arg_list.append(\"--attach-mpi\")\n            arg_list.append(str(self.proctab.launcher_pid))\n            arg_list.append(\"--subset\")\n            rank_list_arg = ''\n            for rank in subset_list:\n                if rank == subset_list[0]:\n                    rank_list_arg += '%d' % rank\n                else:\n                    rank_list_arg += ',%d' % rank\n            arg_list.append(rank_list_arg)\n            arg_list.append(self.executable_path)\n\n        for arg in self.options['Additional Debugger Args'].split():\n            arg_list.insert(-1, arg)\n\n        # First Detach STAT!!!\n        if self.STAT is not None:\n            stop_list = intArray(len(subset_list))\n            i = -1\n            for rank in subset_list:\n                i += 1\n                stop_list[i] = rank\n            self.on_detach(None, stop_list, len(subset_list))\n\n        sys.stdout.write('fork exec %s %s\\n' % (debugger, arg_list))\n        if os.fork() == 0:\n            exec_and_exit(arg_list)\n\n    def get_full_edge_label(self, widget, button_clicked, node):\n        edge_label = self.STAT.getNodeInEdge(int(node.node_name))\n        old_label = node.edge_label\n        node.edge_label = edge_label\n        task_list = get_task_list(edge_label)\n        node.num_leaf_tasks = -1\n        if node.edge_label_id in STATview.task_label_id_to_list:\n            STATview.task_label_id_to_list[node.edge_label_id] = task_list\n        if old_label in STATview.task_label_to_list:\n            del STATview.task_label_to_list[old_label]\n        for inode in self.get_current_graph().nodes:\n            if inode.edge_label == old_label:\n                inode.edge_label = edge_label\n                inode.num_leaf_tasks = -1\n                if inode.edge_label_id in STATview.task_label_id_to_list:\n                    STATview.task_label_id_to_list[inode.edge_label_id] = task_list\n        try:\n            self.my_dialog.destroy()\n        except:\n            pass\n        self.on_node_clicked(widget, button_clicked, node)\n\n    def on_fatal_error(self):\n        \"\"\"Handle fatal error.\"\"\"\n        self.set_action_sensitivity('new')\n        self.STAT.shutDown()\n        self.STAT = None\n        self.reattach = False\n        self.attached = False\n        self.show_all()\n\n    def pack_sample_options(self, vbox, multiple, attach=False):\n        \"\"\"Pack the sample options into the specified vbox.\"\"\"\n        frame = gtk.Frame(label='Per Sample Options')\n        vbox2 = gtk.VBox()\n        self.pack_check_button(vbox2, 'With Threads', False, False, 0)\n        self.pack_spinbutton(vbox2, 'Max Threads Per Daemon')\n        if HAVE_OPENMP_SUPPORT:\n            self.pack_check_button(vbox2, 'With OpenMP', False, False, 0)\n        if HAVE_GDB_SUPPORT:\n            self.pack_check_button(vbox2, 'With CUDA Quick', False, False, 0)\n        self.pack_check_button(vbox2, 'Gather Python Traces', False, False, 5)\n        frame2 = gtk.Frame(label='Stack Frame (node) Sample Options')\n        vbox3 = gtk.VBox()\n        self.pack_radio_buttons(vbox3, 'Sample Type')\n        frame2.add(vbox3)\n        vbox2.pack_start(frame2, False, False, 5)\n        frame2 = gtk.Frame(label='Process Set (edge) Sample Options')\n        vbox3 = gtk.VBox()\n        self.pack_radio_buttons(vbox3, 'Edge Type')\n        frame2.add(vbox3)\n        vbox2.pack_start(frame2, False, False, 5)\n\n        if attach is False:\n            self.pack_spinbutton(vbox2, 'Run Time Before Sample (sec)')\n        expander = gtk.Expander(label=\"Advanced\")\n        hbox = gtk.HBox()\n        self.pack_spinbutton(hbox, 'Num Retries')\n        self.pack_spinbutton(hbox, 'Retry Frequency (us)')\n        expander.add(hbox)\n        vbox2.pack_start(expander, False, False, 5)\n        frame.add(vbox2)\n        vbox.pack_start(frame, False, False, 5)\n        if multiple:\n            frame = gtk.Frame(label='Multiple Sample Options')\n            vbox2 = gtk.VBox()\n            hbox = gtk.HBox()\n            self.pack_spinbutton(hbox, 'Num Traces')\n            self.pack_spinbutton(hbox, 'Trace Frequency (ms)')\n            vbox2.pack_start(hbox, False, False, 5)\n            self.pack_check_button(vbox2, 'Gather Individual Samples')\n            self.pack_check_button(vbox2, 'Clear On Sample')\n            frame.add(vbox2)\n            vbox.pack_start(frame, False, False, 5)\n\n\ndef STATGUI_main(args):\n    \"\"\"The STATGUI main.\"\"\"\n    window = STATGUI(args)\n    STATview.window = window\n    window.connect('destroy', window.on_destroy)\n    #gtk.gdk.threads_init()\n    gtk.main()\n\nif __name__ == '__main__':\n    sys.stderr.write('WARNING: STATGUI.py should not be directly invoked. This has been replaced by STATmain.py and the \"view\" subcommand.\\n')\n    sys.exit(1)\n",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/scripts/STATmain.py": "#!/bin/env python\n\n\"\"\"@package STATview\nVisualizes dot graphs outputted by STAT.\"\"\"\n\n__copyright__ = \"\"\"Copyright (c) 2007-2020, Lawrence Livermore National Security, LLC.\"\"\"\n__license__ = \"\"\"Produced at the Lawrence Livermore National Laboratory\nWritten by Gregory Lee <lee218@llnl.gov>, Dorian Arnold, Matthew LeGendre, Dong Ahn, Bronis de Supinski, Barton Miller, Martin Schulz, Niklas Nielson, Nicklas Bo Jensen, Jesper Nielson, and Sven Karlsson.\nLLNL-CODE-750488.\nAll rights reserved.\n\nThis file is part of STAT. For details, see http://www.github.com/LLNL/STAT. Please also read STAT/LICENSE.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        Redistributions of source code must retain the above copyright notice, this list of conditions and the disclaimer below.\n        Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the disclaimer (as noted below) in the documentation and/or other materials provided with the distribution.\n        Neither the name of the LLNS/LLNL nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"\n__author__ = [\"Gregory Lee <lee218@llnl.gov>\", \"Dorian Arnold\", \"Matthew LeGendre\", \"Dong Ahn\", \"Bronis de Supinski\", \"Barton Miller\", \"Martin Schulz\", \"Niklas Nielson\", \"Nicklas Bo Jensen\", \"Jesper Nielson\"]\n__version_major__ = 4\n__version_minor__ = 0\n__version_revision__ = 3\n__version__ = \"%d.%d.%d\" % (__version_major__, __version_minor__, __version_revision__)\n\nimport sys\nimport ctypes\nimport os\nimport argparse\n\nHAVE_DLOPEN = hasattr(sys, 'getdlopenflags')\nif HAVE_DLOPEN is True:\n    dlflags = sys.getdlopenflags()\n    new_dlflags = ctypes.RTLD_GLOBAL | dlflags\n    sys.setdlopenflags(new_dlflags)\n\nHAVE_GDB_SUPPORT = True\ntry:\n    from STAT import STAT_SAMPLE_CUDA_QUICK\nexcept:\n    HAVE_GDB_SUPPORT = False\nHAVE_STATVIEW = True\nimport_exception = None\ntry:\n    from STATview import STATview_main\nexcept Exception as e:\n    HAVE_STATVIEW = False\n    import_exception = e\nHAVE_STATGUI = True\ntry:\n    from STATGUI import STATGUI_main\nexcept Exception as e:\n    HAVE_STATGUI = False\n    import_exception = e\nfrom STAThelper import exec_and_exit\nfrom core_file_merger import STATmerge_main\n\ndef STATmain_main(in_arg_list, command=None):\n    env_var = 'STAT_BIN'\n    if command == 'bench':\n        env_var = 'STATBENCH_BIN'\n    try:\n        stat_bin = os.environ[env_var]\n    except:\n        sys.stderr.write('%s environment variable not set. Please ensure that you are running through the STAT, stat-cl, stat-view, stat-gui, STATBench, or stat-bench script\\n' % (env_var))\n        sys.exit(1)\n    arg_list = [stat_bin]\n    arg_list += in_arg_list\n    exec_and_exit(arg_list)\n\n\nif __name__ == '__main__':\n    args = None\n    arg_parser = argparse.ArgumentParser(prog='STAT')\n    subparsers = arg_parser.add_subparsers()\n\n\n    if sys.argv[1] in ['gui', 'view'] and import_exception is not None:\n        raise import_exception\n\n    # argument parsing for the stat-view command or STAT view subcommand\n    if HAVE_STATVIEW:\n        view_parser = subparsers.add_parser('view')\n        view_parser.add_argument(\"files\", nargs='*', help=\"optional list of .dot files\")\n        view_parser.set_defaults(func=STATview_main)\n\n    # argument parsing for the stat-gui command or STAT gui subcommand\n    if HAVE_STATGUI:\n        gui_parser = subparsers.add_parser('gui')\n        trace_group = gui_parser.add_mutually_exclusive_group()\n        trace_group.add_argument(\"-P\", \"--withpc\", help=\"sample program counter in addition to function name\", action=\"store_true\")\n        trace_group.add_argument(\"-m\", \"--withmoduleoffset\", help=\"sample module offset only\", action=\"store_true\")\n        trace_group.add_argument(\"-i\", \"--withline\", help=\"sample source line number in addition to function name\", action=\"store_true\")\n        gui_parser.add_argument(\"-s\", \"--sleep\", help=\"sleep for the specified number of seconds before attaching\", metavar=\"SLEEPTIME\", type=int)\n        gui_parser.add_argument(\"-o\", \"--withopenmp\", help=\"translate OpenMP stacks to logical application view\", action=\"store_true\")\n        gui_parser.add_argument(\"-w\", \"--withthreads\", help=\"sample helper threads in addition to the main thread\", action=\"store_true\")\n        gui_parser.add_argument(\"-y\", \"--pythontrace\", help=\"gather Python script level stack traces\", action=\"store_true\")\n        gui_parser.add_argument(\"-U\", \"--countrep\", help=\"only gather count and a single representative\", action=\"store_true\")\n        gui_parser.add_argument(\"-d\", \"--debugdaemons\", help=\"launch the daemons under the debugger\", action=\"store_true\")\n        gui_parser.add_argument(\"-L\", \"--logdir\", help=\"logging output directory\")\n        gui_parser.add_argument(\"-l\", \"--log\", help=\"enable debug logging\", choices=['FE', 'BE', 'CP'], action=\"append\")\n        if HAVE_GDB_SUPPORT:\n            gui_parser.add_argument(\"-G\", \"--gdb\", help=\"use (cuda) gdb to drive the daemons\", action=\"store_true\")\n            gui_parser.add_argument(\"-Q\", \"--cudaquick\", help=\"gather less comprehensive, but faster cuda traces\", action=\"store_true\")\n        trace_group.add_argument(\"-M\", \"--mrnetprintf\", help=\"use MRNet's print for logging\", action=\"store_true\")\n        gui_parser.add_argument('--version', action='version', version='%(prog)s {version}'.format(version=__version__))\n        attach_group = gui_parser.add_mutually_exclusive_group()\n        attach_group.add_argument(\"-a\", \"--attach\", help=\"attach to the specified [hostname:]PID\", metavar='LAUNCHERPID')\n        attach_group.add_argument(\"-C\", \"--create\", help=\"launch the application under STAT's control. All args after -C are used to launch the app\", nargs=argparse.REMAINDER)\n        attach_group.add_argument(\"-I\", \"--serial\", help=\"attach to the specified [<exe>@<host>:<pid>]+. All args after -I are interpreted as serial processes to attach to\", nargs=argparse.REMAINDER)\n        gui_parser.set_defaults(func=STATGUI_main)\n\n    # argument parsing for the stat-cl command or STAT cl subcommand\n    cl_parser = subparsers.add_parser('cl')\n\n    # argument parsing for the stat-bench command or STAT bench subcommand\n    bench_parser = subparsers.add_parser('bench')\n\n    # argument parsing for the stat-merge command or STAT merge subcommand\n    merge_parser = subparsers.add_parser('merge')\n\n    # TODO: ultimately the subcommands below should be parsed here an not in their own files\n    if len(sys.argv) > 1 and sys.argv[1] == 'cl':\n        # TODO: this will work best if STAT.C functionality is completely replaced and implemented here\n        STATmain_main(['-r', '5', '-c', '-A'] + sys.argv[2:], 'cl')\n        sys.exit(0)\n    elif len(sys.argv) > 1 and sys.argv[1] == 'bench':\n        STATmain_main(sys.argv[2:], 'bench')\n        sys.exit(0)\n    elif len(sys.argv) > 1 and sys.argv[1] == 'merge':\n        # TODO: this will be the hardest to modify since the argument parsing is done with internal classes\n        STATmerge_main(sys.argv[1:])\n        sys.exit(0)\n\n    args = arg_parser.parse_args(sys.argv[1:])\n    args.func(args)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/STATlogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/src/dysect/dysect-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/.git/objects/pack/pack-201cb85991551eaa29861bde8de1709ef59f04c0.idx",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/.git/objects/pack/pack-201cb85991551eaa29861bde8de1709ef59f04c0.pack",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/stat_to_example.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/bgl4k_2d.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statview_screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/single_trace.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statbench_1m_3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/trace_and_merge.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statgui_source_view.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statgui_toolbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statgui_attach_dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statgui_sample_multiple_dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statgui_eq_classes.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/stat_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statview_toolbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statgui_proc_tab.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statgui_node_dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statgui_bgl208k_screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statgui_screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/statview_prog_model.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/merged_traces.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/src/figs/bgl4k_3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/userguide/stat_userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-stat-develop-bx46vy6j5wsochqkyxok4xykjgcmbkb2/spack-src/doc/quickstart/stat_quickstart.pdf"
    ],
    "total_files": 341
}