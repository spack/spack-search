{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/CMakeLists.txt": "################################################################################\n# Copyright (c) 2014-2018 Krell Institute. All Rights Reserved.\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 2 of the License, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n# details.\n#\n# You should have received a copy of the GNU General Public License along with\n# this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n# Place, Suite 330, Boston, MA  02111-1307  USA\n################################################################################\n\ncmake_minimum_required(VERSION 2.8.0)\n\nproject(cbtf-krell C CXX)\n\nset(CBTF_KRELL_VERSION 1.9.0)\nset(CBTF_KRELL_VERSION_MAJOR 1)\nset(CBTF_KRELL_VERSION_MINOR 9)\nset(CBTF_KRELL_VERSION_PATCH 0)\nset(CBTF_KRELL_VERSION_TWEAK 0)\nadd_definitions(-DVERSION=\"${CBTF_KRELL_VERSION}\")\n\nset(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${PROJECT_SOURCE_DIR}/cmake)\n\n# NOTE related to the following C++11 feature checks:\n#    This include: CheckCXX11Features.cmake is projected to be in a future version of CMake.\n#    When this does get included into the new CMake version, we will update our\n#    required CMake version and remove cmake/CheckCXX11Features* files from the cbtf repository.\n#\ninclude(cmake/CheckCXX11Features.cmake)\nif(NOT HAS_CXX11_AUTO)\n  message(STATUS \"No support for C++11 found.\")\nelse()\n  message(STATUS \"C++11 support found, required flags are: ${CXX11_COMPILER_FLAGS}\")\nendif()\n\ninclude(CheckIncludeFile)\ninclude(CheckIncludeFileCXX)\ninclude(CheckFunctionExists)\ninclude(CheckLibraryExists)\n\ncheck_include_file(\"stdint.h\" STDINT_H_FOUND)\nif (STDINT_H_FOUND)\n    add_definitions(-DHAVE_STDINT_H=1)\nendif()\n\ncheck_include_file(\"stat.h\" STAT_H_FOUND)\nif (STAT_H_FOUND)\n    add_definitions(-DHAVE_STAT_H=1)\nendif()\n\ncheck_include_file(\"sys/stat.h\" SYS_STAT_H_FOUND)\nif (SYS_STAT_H_FOUND)\n    add_definitions(-DHAVE_SYS_STAT_H=1)\nendif()\n\ncheck_include_file(dirent.h HAVE_DIRENT_H)\ncheck_include_file(dlfcn.h HAVE_DLFCN_H)\ncheck_include_file(errno.h HAVE_ERRNO_H)\ncheck_include_file(execinfo.h HAVE_EXECINFO_H)\ncheck_include_file(fcntl.h HAVE_FCNTL_H)\ncheck_include_file(inttypes.h HAVE_INTTYPES_H)\ncheck_include_file(limits.h HAVE_LIMITS_H)\ncheck_include_file(link.h HAVE_LINK_H)\ncheck_include_file(malloc.h HAVE_MALLOC_H)\ncheck_include_file(malloc/malloc.h HAVE_MALLOC_MALLOC_H)\ncheck_function_exists(fork HAVE_FORK)\n\nfind_library(DL_LIBRARIES NAMES dl)\nif(DL_LIBRARIES)\n  #set(HAVE_DLOPEN)\n  add_definitions(-DHAVE_DLOPEN)\n  add_definitions(-DHAVE_TARGET_DLOPEN)\nelse(DL_LIBRARIES)\n  check_function_exists(dlopen HAVE_TARGET_DLOPEN)\n  if (HAVE_TARGET_DLOPEN)\n    add_definitions(-DHAVE_DLOPEN)\n  endif()\n  # If dlopen can be found without linking in dl then dlopen is part\n  # of libc, so don't need to link extra libs.\n  set(DL_LIBRARIES \"\")\nendif(DL_LIBRARIES)\n\n#-----------------------------------------------------------------------------\n# This MACRO checks IF the symbol exists in the library and IF it\n# does, allow it.\n#-----------------------------------------------------------------------------\n#MACRO (CHECK_LIBRARY_EXISTS_CONCAT LIBRARY SYMBOL VARIABLE)\n#  CHECK_LIBRARY_EXISTS (\"${LIBRARY}\" ${SYMBOL} \"\" ${VARIABLE})\n#ENDMACRO (CHECK_LIBRARY_EXISTS_CONCAT)\n\n#cmake -DVARNAME:STRING=value\n\n# Set the cbtf_hardware_platform which is used in finding mpi implementation install directories\n# Note: this is also in the openspeedshop repository but is named oss_hardware_platform there.\n# This is mainly needed to find mpich libraries on some mpich installations\nexecute_process(COMMAND uname -i\n        OUTPUT_VARIABLE local_arch OUTPUT_STRIP_TRAILING_WHITESPACE)\nset(cbtf_hardware_platform \"${local_arch}\")\nmessage(STATUS \"cbtf_hardware_platform: \" ${cbtf_hardware_platform} )\n\nset(TLS_MODEL \"implicit\" CACHE STRING \"cbtf-krell tls model: [implicit,explicit]\")\n#\n#--------------------------------------------------------------------------------\n# Handle the TLS options for building the runtimes\n#    - explicit means the tool allocates and manages the thread local storage\n#    - implicit means the tool uses the systems thread local storage\n#--------------------------------------------------------------------------------\n#\nif (TLS_MODEL MATCHES \"explicit\")\n    # Builder requsted explicit tls to be used in the runtimes and collectors\n    set(TLS_DEFINES \"USE_EXPLICIT_TLS\" )\n    message(STATUS \"Build runtimes using explicit TLS model.\")\nelseif (TLS_MODEL MATCHES \"implicit\")\n    # Builder requsted implicit tls to be used in the runtimes and collectors\n    set(TLS_DEFINES \"USE_IMPLICIT_TLS\" )\n    message(STATUS \"Build runtimes using implicit TLS model.\")\nelse()\n    # Default to implicit tls in the runtimes and collectors\n    set(TLS_DEFINES \"USE_IMPLICIT_TLS\" )\n    message(STATUS \"Build runtimes using implicit TLS model.\")\nendif()\n\nset(CBTF_FILTERS_RUN_ON \"\" CACHE STRING \"cbtf-krell filters run on native compute node or on host processor on compute node: [native or host]\")\nset(RUNTIME_PLATFORM \"\" CACHE STRING \"cbtf-krell runtime platform: none or [bgq,bgp,arm,mic]\")\nset(CN_RUNTIME_PLATFORM \"\" CACHE STRING \"cbtf-krell runtime platform: none or [bgq,bgp,arm,mic]\")\n#\n#--------------------------------------------------------------------------------\n# Handle the target specific build options for building the runtimes for specific\n# platform compute nodes\n#--------------------------------------------------------------------------------\n#\nif (RUNTIME_PLATFORM MATCHES \"bgq\")\n    add_definitions(-DRUNTIME_PLATFORM=bgq)\n    message(STATUS \"Build runtimes for target bgq platform.\")\nelseif (RUNTIME_PLATFORM MATCHES \"bgp\")\n    add_definitions(-DRUNTIME_PLATFORM=bgp)\n    message(STATUS \"Build runtimes for target bgp platform.\")\nelseif (RUNTIME_PLATFORM MATCHES \"mic\")\n    add_definitions(-DRUNTIME_PLATFORM=mic)\n    set(RUNTIME_PLATFORM_MIC 1)\n    set(CBTF_FILTERS_RUN_ON \"host\")\n    message(STATUS \"Build runtimes for target mic platform.\")\nelseif (RUNTIME_PLATFORM MATCHES \"cray\")\n    set(RUNTIME_PLATFORM_CRAY 1)\n    set(CBTF_FILTERS_RUN_ON \"native\")\n    message(STATUS \"Build runtimes for target cray platform.\")\nelseif (RUNTIME_PLATFORM MATCHES \"cray-xk\")\n    set(RUNTIME_PLATFORM_CRAYXK 1)\n    set(CBTF_FILTERS_RUN_ON \"native\")\n    message(STATUS \"Build runtimes for target cray-xk platform.\")\nelseif (RUNTIME_PLATFORM MATCHES \"cray-xe\")\n    set(RUNTIME_PLATFORM_CRAYXE 1)\n    set(CBTF_FILTERS_RUN_ON \"native\")\n    message(STATUS \"Build runtimes for target cray-xe platform.\")\nelseif (RUNTIME_PLATFORM MATCHES \"arm\")\n    message(STATUS \"Build for the ARM platform (32 bit or 64 bit).\")\n    set(CBTF_FILTERS_RUN_ON \"native\")\nelse()\n    message(STATUS \"Build runtimes for localhost.\")\n    set(CBTF_FILTERS_RUN_ON \"native\")\nendif()\n#\n#--------------------------------------------------------------------------------\n# In the case of building the front-end to a targeted compute node version of\n# cbtf-krell we need to know what platform the target is, in order to generate\n# the correct cbtfAutoTopology file.  In the case of the cray there are special\n# considerations to account for.  One of these is the ALPS_XT_NID value.\n#--------------------------------------------------------------------------------\n#\nif (CN_RUNTIME_PLATFORM MATCHES \"mic\")\n    add_definitions(-DCN_RUNTIME_PLATFORM=mic)\n    message(STATUS \"Indicate that runtimes are for the compute node mic platform.\")\n    set(CBTF_FILTERS_RUN_ON \"host\")\nelseif (CN_RUNTIME_PLATFORM MATCHES \"cray\")\n    add_definitions(-DCN_RUNTIME_PLATFORM_CRAY=1)\n    message(STATUS \"Indicate that runtimes are for the compute node cray platform.\")\n    set(CBTF_FILTERS_RUN_ON \"native\")\nelseif (CN_RUNTIME_PLATFORM MATCHES \"cray-xk\")\n    add_definitions(-DCN_RUNTIME_PLATFORM_CRAY=1)\n    message(STATUS \"Indicate that runtimes are for the compute node cray (-xk) platform.\")\n    set(CBTF_FILTERS_RUN_ON \"native\")\nelseif (CN_RUNTIME_PLATFORM MATCHES \"cray-xe\")\n    add_definitions(-DCN_RUNTIME_PLATFORM_CRAY=1)\n    message(STATUS \"Indicate that runtimes are for the compute node cray (-xe) platform.\")\n    set(CBTF_FILTERS_RUN_ON \"native\")\nendif()\n#\n# Are we only building the runtime portions of CBTF-KRELL, that is not building the client\n# portions?  RUNTIME_ONLY indicates that we want to only build the compute node portions\n# of cbtf-krell.\n#\nif (RUNTIME_ONLY MATCHES \"true\")\n    message(STATUS \"Build runtime libraries and components only for compute node platform.\")\nelse()\n    message(STATUS \"Build full cbtf-krell libraries, components, and clients.\")\nendif()\n\n#\n#--------------------------------------------------------------------------------\n# Try to determine where the libraries created by this build should be stored.\n# The choices are lib or lib64.  Set the appropriate variables based on checking\n# the system processor type.\n#--------------------------------------------------------------------------------\n#\nset(CMAKE_INSTALL_LIBDIR ${CMAKE_INSTALL_PREFIX}/lib)\nif(CMAKE_SYSTEM_PROCESSOR MATCHES \"ppc64*\")\n    set(CMAKE_INSTALL_LIBDIR ${CMAKE_INSTALL_PREFIX}/lib64)\n    set(LIB_SUFFIX 64)\n    set(SUFFIX 64)\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"ppc*\")\n    set(CMAKE_INSTALL_LIBDIR ${CMAKE_INSTALL_PREFIX}/lib)\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"aarch64*\")\n    set(CMAKE_INSTALL_LIBDIR ${CMAKE_INSTALL_PREFIX}/lib)\nelseif(EXISTS /usr/lib64)\n    set(LIB_SUFFIX 64)\n    set(SUFFIX 64)\n    set(CMAKE_INSTALL_LIBDIR ${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX})\nendif()\n\n#\n# Handle the case where we are building a FRONT-END version of cbtf-krell that\n# interfaces with a compute node targeted backend version of cbtf-krell.\n#\n# We determine if that is the case if we find a target cbtf-krell define specified\n# for the cmake build.   If not, we proceed to build the vanilla cluster like version\n# of cbtf-krell.  If there is a target cbtf-krell define specified then we proceed \n# with looking for the other compute node libraries that need to be specified in\n# core/scripts when building cbtfrun, cbtflink, cbtf_libcbtf_mrnet_commnode, and\n# cbtf_mrnet_commnode.\n#\n\nset(BUILD_FE_USING_CN_RUNTIMES \"false\" CACHE STRING \"Special front-end build where the compute node components are passed to the build in addition to the FE related components.\")\n#\n#--------------------------------------------------------------------------------\n# If CBTF_KRELL_CN_RUNTIME_DIR exists, then we have built a separate version of the portion of\n# CBTF-KRELL that runs with the application: runtime libraries and data collectors.\n# This is done/needed when the processor type of the compute node (where the application\n# executes) is different from the front-end node (where the CBTF-KRELL client \n# components run).  We call that building compute node runtimes, and this is accomplished\n# by using the \"-DRUNTIME_ONLY\" cmake argument in a separate build.\n#--------------------------------------------------------------------------------\n\nif (NOT \"${CBTF_KRELL_CN_RUNTIME_DIR}\" STREQUAL \"\")\n    if(EXISTS \"${CBTF_KRELL_CN_RUNTIME_DIR}\" AND IS_DIRECTORY \"${CBTF_KRELL_CN_RUNTIME_DIR}\")\n        # This setting of BUILD_FE_USING_CN_RUNTIMES will persist if all the compute node versions of the component are found\n        # One component failure will set the BUILD_FE_USING_CN_RUNTIMES flag false and the build will fail.\n        set (BUILD_FE_USING_CN_RUNTIMES \"true\")\n        if( EXISTS \"${CBTF_KRELL_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" AND IS_DIRECTORY \"${CBTF_KRELL_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" \n            AND EXISTS \"${CBTF_KRELL_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}/KrellInstitute/Collectors/pcsamp-collector-monitor-mrnet.so\" )\n            set (CBTF_KRELL_CN_RUNTIME_LIBDIR  ${CBTF_KRELL_CN_RUNTIME_DIR}/lib${LIB_SUFFIX})\n        elseif ( EXISTS \"${CBTF_KRELL_CN_RUNTIME_DIR}/lib\" AND IS_DIRECTORY \"${CBTF_KRELL_CN_RUNTIME_DIR}/lib\" \n                 AND EXISTS \"${CBTF_KRELL_CN_RUNTIME_DIR}/lib/KrellInstitute/Collectors/pcsamp-collector-monitor-mrnet.so\" )\n            set (CBTF_KRELL_CN_RUNTIME_LIBDIR  ${CBTF_KRELL_CN_RUNTIME_DIR}/lib)\n        else()\n            # Override the settings we had up until now.  We need to find all the targeted libraries to succeed.\n            set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n        endif()\n    else()\n        set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n    endif()\nelse()\n    set (BUILD_FE_USING_CN_RUNTIMES \"false\")\nendif()\n\n#\n# Check to see if we have a frontend build that references a targeted cbtf-krell build\n# by verifying the necessary compute node packages required to create the proper \n# references in the cbtfrun, cbtflink, cbtf_libcbtf_mrnet_backend and cbtf_mrnet_commnode.\n#\n\n#\n# Look for cbtf target libraries\n#\nif (BUILD_FE_USING_CN_RUNTIMES AND CBTF_FILTERS_RUN_ON MATCHES \"native\")\nif (NOT \"${CBTF_CN_RUNTIME_DIR}\" STREQUAL \"\")\n    if(EXISTS ${CBTF_CN_RUNTIME_DIR} AND IS_DIRECTORY \"${CBTF_CN_RUNTIME_DIR}\")\n        if( EXISTS ${CBTF_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} AND IS_DIRECTORY \"${CBTF_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" AND EXISTS \"${CBTF_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}/libcbtf.so\")\n           # CBTF_CN_RUNTIME_DIR/lib64 was recognized.\")\n           set (CBTF_CN_RUNTIME_LIBDIR ${CBTF_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} CACHE PATH \"Location of compute node cbtf libraries.\")\n        elseif ( EXISTS ${CBTF_CN_RUNTIME_DIR}/lib AND IS_DIRECTORY \"${CBTF_CN_RUNTIME_DIR}/lib\" AND EXISTS \"${CBTF_CN_RUNTIME_DIR}/lib/libcbtf.so\")\n           # CBTF_CN_RUNTIME_DIR/lib was recognized.\")\n           set (CBTF_CN_RUNTIME_LIBDIR ${CBTF_CN_RUNTIME_DIR}/lib CACHE PATH \"Location of compute node cbtf libraries.\")\n        else()\n           # Override the settings we had up until now.  We need to find all the targeted libraries to succeed.\n           set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n        endif()\n    else()\n        set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n    endif()\nelse()\n    set (BUILD_FE_USING_CN_RUNTIMES \"false\")\nendif()\nendif() # CBTF_FILTERS_RUN_ON matches native\n\n#\n# Look for libmonitor libraries\n#\nif (NOT \"${LIBMONITOR_CN_RUNTIME_DIR}\" STREQUAL \"\")\n    if(EXISTS ${LIBMONITOR_CN_RUNTIME_DIR} AND IS_DIRECTORY \"${LIBMONITOR_CN_RUNTIME_DIR}\")\n        if( EXISTS ${LIBMONITOR_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} AND IS_DIRECTORY \"${LIBMONITOR_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" AND EXISTS \"${LIBMONITOR_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}/libmonitor.so\")\n           # LIBMONITOR_CN_RUNTIME_DIR/lib64 was recognized.\n           set (LIBMONITOR_CN_RUNTIME_LIBDIR ${LIBMONITOR_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} CACHE PATH \"Location of compute node libmonitor libraries.\")\n        elseif ( EXISTS ${LIBMONITOR_CN_RUNTIME_DIR}/lib AND IS_DIRECTORY \"${LIBMONITOR_CN_RUNTIME_DIR}/lib\" AND EXISTS \"${LIBMONITOR_CN_RUNTIME_DIR}/lib/libmonitor.so\")\n           # LIBMONITOR_CN_RUNTIME_DIR/lib was recognized.\n           set (LIBMONITOR_CN_RUNTIME_LIBDIR ${LIBMONITOR_CN_RUNTIME_DIR}/lib CACHE PATH \"Location of compute node libmonitor libraries.\")\n        else()\n           # Override the settings we had up until now.  We need to find all the targeted libraries to succeed.\n           set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n        endif()\n    else()\n        set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n    endif()\nelse()\n    set (BUILD_FE_USING_CN_RUNTIMES \"false\")\nendif()\n\n#\n# Look for libunwind target libraries\n#\nif (NOT \"${LIBUNWIND_CN_RUNTIME_DIR}\" STREQUAL \"\")\n    if(EXISTS ${LIBUNWIND_CN_RUNTIME_DIR} AND IS_DIRECTORY \"${LIBUNWIND_CN_RUNTIME_DIR}\")\n        if( EXISTS ${LIBUNWIND_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} AND IS_DIRECTORY \"${LIBUNWIND_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" AND EXISTS \"${LIBUNWIND_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}/libunwind.so\")\n           # LIBUNWIND_CN_RUNTIME_DIR/lib64 was recognized\n           set (LIBUNWIND_CN_RUNTIME_LIBDIR ${LIBUNWIND_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} CACHE PATH \"Location of compute node libunwind libraries.\")\n        elseif ( EXISTS ${LIBUNWIND_CN_RUNTIME_DIR}/lib AND IS_DIRECTORY \"${LIBUNWIND_CN_RUNTIME_DIR}/lib\" AND EXISTS \"${LIBUNWIND_CN_RUNTIME_DIR}/lib/libunwind.so\")\n           # LIBUNWIND_CN_RUNTIME_DIR/lib was recognized\n           set (LIBUNWIND_CN_RUNTIME_LIBDIR ${LIBUNWIND_CN_RUNTIME_DIR}/lib CACHE PATH \"Location of compute node libunwind libraries.\")\n        else()\n           # Override the settings we had up until now.  We need to find all the targeted libraries to succeed.\n           set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n        endif()\n    else()\n        set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n    endif()\nelse()\n    set (BUILD_FE_USING_CN_RUNTIMES \"false\")\nendif()\n\n#\n# Look for papi target libraries\n#\nif (NOT \"${PAPI_CN_RUNTIME_DIR}\" STREQUAL \"\")\n    if(EXISTS ${PAPI_CN_RUNTIME_DIR} AND IS_DIRECTORY \"${PAPI_CN_RUNTIME_DIR}\")\n        if( EXISTS ${PAPI_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} AND IS_DIRECTORY \"${PAPI_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" AND EXISTS \"${PAPI_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}/libpapi.so\")\n           # PAPI_CN_RUNTIME_DIR/lib64 was recognized\n           set (PAPI_CN_RUNTIME_LIBDIR ${PAPI_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} CACHE PATH \"Location of compute node papi libraries.\")\n        elseif ( EXISTS ${PAPI_CN_RUNTIME_DIR}/lib AND IS_DIRECTORY \"${PAPI_CN_RUNTIME_DIR}/lib\" AND EXISTS \"${PAPI_CN_RUNTIME_DIR}/lib/libpapi.so\")\n           # PAPI_CN_RUNTIME_DIR/lib was recognized\n           set (PAPI_CN_RUNTIME_LIBDIR ${PAPI_CN_RUNTIME_DIR}/lib CACHE PATH \"Location of compute node papi libraries.\")\n        else()\n           # Override the settings we had up until now.  We need to find all the targeted libraries to succeed.\n           set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n        endif()\n    else()\n        set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n    endif()\nelse()\n    set (BUILD_FE_USING_CN_RUNTIMES \"false\")\nendif()\n\n#\n# Look for mrnet target libraries\n#\nif (NOT \"${MRNET_CN_RUNTIME_DIR}\" STREQUAL \"\")\n    if(EXISTS ${MRNET_CN_RUNTIME_DIR} AND IS_DIRECTORY \"${MRNET_CN_RUNTIME_DIR}\")\n        if( EXISTS ${MRNET_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} AND \n            IS_DIRECTORY \"${MRNET_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" AND \n            EXISTS \"${MRNET_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}/libmrnet_lightweight_r.so\")\n           # MRNET_CN_RUNTIME_DIR/lib64 was recognized\n           set (MRNET_CN_RUNTIME_LIBDIR ${MRNET_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} CACHE PATH \"Location of compute node mrnet libraries.\")\n        elseif ( EXISTS ${MRNET_CN_RUNTIME_DIR}/lib AND \n                 IS_DIRECTORY \"${MRNET_CN_RUNTIME_DIR}/lib\" AND \n                 EXISTS \"${MRNET_CN_RUNTIME_DIR}/lib/libmrnet_lightweight_r.so\")\n           # MRNET_CN_RUNTIME_DIR/lib was recognized\n           set (MRNET_CN_RUNTIME_LIBDIR ${MRNET_CN_RUNTIME_DIR}/lib CACHE PATH \"Location of compute node mrnet libraries.\")\n        else()\n           # Override the settings we had up until now.  We need to find all the targeted libraries to succeed.\n           set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n        endif()\n    else()\n        set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n    endif()\nelse()\n    set (BUILD_FE_USING_CN_RUNTIMES \"false\")\nendif()\n\n#\n# Look for boost target libraries\n#\nif (BUILD_FE_USING_CN_RUNTIMES AND CBTF_FILTERS_RUN_ON MATCHES \"native\")\nif (NOT \"${BOOST_CN_RUNTIME_DIR}\" STREQUAL \"\")\n    if(EXISTS ${BOOST_CN_RUNTIME_DIR} AND IS_DIRECTORY \"${BOOST_CN_RUNTIME_DIR}\")\n        if( EXISTS ${BOOST_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} AND IS_DIRECTORY \"${BOOST_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" AND EXISTS \"${BOOST_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}/libboost_system.so\")\n           # BOOST_CN_RUNTIME_DIR/lib64 was recognized\n           set (BOOST_CN_RUNTIME_LIBDIR ${BOOST_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} CACHE PATH \"Location of compute node boost libraries.\")\n        elseif( EXISTS ${BOOST_CN_RUNTIME_DIR}/lib AND IS_DIRECTORY \"${BOOST_CN_RUNTIME_DIR}/lib\" AND EXISTS \"${BOOST_CN_RUNTIME_DIR}/lib/libboost_system.so\")\n           # BOOST_CN_RUNTIME_DIR/lib was recognized\n           set (BOOST_CN_RUNTIME_LIBDIR ${BOOST_CN_RUNTIME_DIR}/lib CACHE PATH \"Location of compute node boost libraries.\")\n        else()\n           # Override the settings we had up until now.  We need to find all the targeted libraries to succeed.\n           set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n        endif()\n    else()\n        set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n    endif()\nelse()\n    set (BUILD_FE_USING_CN_RUNTIMES \"false\")\nendif()\nendif() # CBTF_FILTERS_RUN_ON matches native\n\n#\n# Look for xercesc target libraries\n#\nif (BUILD_FE_USING_CN_RUNTIMES AND CBTF_FILTERS_RUN_ON MATCHES \"native\")\nif (NOT \"${XERCESC_CN_RUNTIME_DIR}\" STREQUAL \"\")\n    if(EXISTS ${XERCESC_CN_RUNTIME_DIR} AND IS_DIRECTORY \"${XERCESC_CN_RUNTIME_DIR}\")\n        if( EXISTS ${XERCESC_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} AND IS_DIRECTORY \"${XERCESC_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" AND EXISTS \"${XERCESC_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}/libxerces-c.so\")\n           # XERCESC_CN_RUNTIME_DIR/lib64 was recognized\n           set (XERCESC_CN_RUNTIME_LIBDIR ${XERCESC_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} CACHE PATH \"Location of compute node xercesc libraries.\")\n        elseif ( EXISTS ${XERCESC_CN_RUNTIME_DIR}/lib AND IS_DIRECTORY \"${XERCESC_CN_RUNTIME_DIR}/lib\" AND EXISTS \"${XERCESC_CN_RUNTIME_DIR}/lib/libxerces-c.so\")\n           # XERCESC_CN_RUNTIME_DIR/lib was recognized\n           set (XERCESC_CN_RUNTIME_LIBDIR ${XERCESC_CN_RUNTIME_DIR}/lib CACHE PATH \"Location of compute node xercesc libraries.\")\n        else()\n           # Override the settings we had up until now.  We need to find all the targeted libraries to succeed.\n           set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n        endif()\n    else()\n        set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n    endif()\nelse()\n    set (BUILD_FE_USING_CN_RUNTIMES \"false\")\nendif()\nendif() # CBTF_FILTERS_RUN_ON matches native\n\n#\n# Look for dyninst target libraries\n#\nif (BUILD_FE_USING_CN_RUNTIMES AND CBTF_FILTERS_RUN_ON MATCHES \"native\")\nif (NOT \"${DYNINST_CN_RUNTIME_DIR}\" STREQUAL \"\")\n    if(EXISTS ${DYNINST_CN_RUNTIME_DIR} AND IS_DIRECTORY \"${DYNINST_CN_RUNTIME_DIR}\")\n        if( EXISTS ${DYNINST_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} AND IS_DIRECTORY \"${DYNINST_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}\" AND EXISTS \"${DYNINST_CN_RUNTIME_DIR}/lib${LIB_SUFFIX}/libdyninstAPI.so\")\n           # DYNINST_CN_RUNTIME_DIR/lib64 was recognized\n           set (DYNINST_CN_RUNTIME_LIBDIR ${DYNINST_CN_RUNTIME_DIR}/lib${LIB_SUFFIX} CACHE PATH \"Location of compute node boost libraries.\")\n        elseif ( EXISTS ${DYNINST_CN_RUNTIME_DIR}/lib AND IS_DIRECTORY \"${DYNINST_CN_RUNTIME_DIR}/lib\" AND EXISTS \"${DYNINST_CN_RUNTIME_DIR}/lib/libdyninstAPI.so\")\n           # DYNINST_CN_RUNTIME_DIR/lib was recognized\n           set (DYNINST_CN_RUNTIME_LIBDIR ${DYNINST_CN_RUNTIME_DIR}/lib CACHE PATH \"Location of compute node boost libraries.\")\n        else()\n           # Override the settings we had up until now.  We need to find all the targeted libraries to succeed.\n           set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n        endif()\n    else()\n        set (BUILD_FE_USING_CN_RUNTIMES \"false\")\n    endif()\nelse()\n    set (BUILD_FE_USING_CN_RUNTIMES \"false\")\nendif()\nendif() # CBTF_FILTERS_RUN_ON matches native\n\nmessage(STATUS \"BUILD_FE_USING_CN_RUNTIMES=${BUILD_FE_USING_CN_RUNTIMES}.\")\n#\n#--------------------------------------------------------------------------------\n# Do find package calls for the dependency packages that are commonly needed for \n# cbtf.\n#--------------------------------------------------------------------------------\n#\nfind_package(Doxygen)\nfind_package(OpenMP)\n\nfind_package(OpenMPI)\nfind_package(Mpich)\nfind_package(Mpich2)\nfind_package(Mpt)\n#find_package(MPI)\nfind_package(Mvapich2)\nfind_package(Mvapich)\n\nfind_package(PythonInterp)\nfind_package(PythonLibs)\nfind_package(Binutils)\nfind_package(Threads)\nfind_package(Sqlite3)\nfind_package(LTDL)\nfind_package(SymtabAPI)\nfind_package(DyninstAPI)\n\nif (DYNINSTAPI_FOUND)\n  set(HAVE_DYNINST \"true\")\nendif()\n\nfind_package(LibMonitor)\nfind_package(LibUnwind)\nfind_package(Papi)\n\nfind_package(Boost 1.39.0 REQUIRED\n    COMPONENTS date_time filesystem system thread unit_test_framework program_options\n    )\nfind_package(CUDA)\nfind_package(MRNet 4.0.0)\nfind_package(XercesC 3.0)\nfind_package(CrayAlps)\n\nif (CRAYALPS_FOUND)\n  set(HAVE_CRAYALPS \"true\")\n  set(CRAYALPS_DEFINES \"HAVE_CRAYALPS=1\")\nendif()\n\nfind_package(LibIomp)\n\nif (LIBIOMP_FOUND)\n  # This does not work for c++ libs. libiomp is compiled under the covers with c++.\n  #CHECK_LIBRARY_EXISTS(${LibIomp_LIBRARY_SHARED} \"ompt_init\" \"\" HAVE_OMPT) \n  if (EXISTS \"${LibIomp_INCLUDE_DIR}/ompt.h\")\n    set(OMPT_DEFINES \"HAVE_OMPT=1\")\n    set(OMPT_FOUND \"true\")\n  else()\n    set(OMPT_FOUND \"false\")\n  endif()\nendif()\n#\n#--------------------------------------------------------------------------------\n# After looking for the DyninstAPI and SymtabAPI packages, reconsile that with\n# whether or not the RESOLVE_SYMBOLS request by the builded can be met.\n#--------------------------------------------------------------------------------\n#\n#On arm/aarch64 systems, dyninst/symtabapi are not ready so default to bfd\nset(RESOLVE_SYMBOLS \"symtabapi\" CACHE STRING \"resolve symbols using: [bfd,symtabapi]\")\n\nif (RESOLVE_SYMBOLS MATCHES \"symtabapi\")\n    if(DYNINSTAPI_FOUND)\n      message(STATUS \"Resolve symbols using SymtabAPI.\")\n    else()\n      message(STATUS \"Resolve symbols using bfd. No Dyninst package was found.\")\n    endif()\nelseif (RESOLVE_SYMBOLS MATCHES \"bfd\")\n    message(STATUS \"Resolve symbols using bfd.\")\nelse()\n    # No user specified choice for resolving symbol tables.  By default choose symtabapi, if available\n    if(DYNINSTAPI_FOUND)\n      message(STATUS \"Resolve symbols using SymtabAPI.\")\n    else()\n      message(STATUS \"Resolve symbols using bfd.\")\n    endif()\nendif()\n\n#\n#--------------------------------------------------------------------------------\n# Handle MPI settings here.  Set the appropriate flags for the rest of the tool\n# to use when building MPI related libraries (collectors).\n#--------------------------------------------------------------------------------\n#\nset(all_mpi_names \"\")\n\nif (OPENMPI_FOUND)\n  # This is needed by the mpi collectors\n  set(HAVE_OPENMPI \"true\")\n  set(HAVE_MPI \"true\")\n  set(DEFAULT_MPI_IMPL_NAME \"openmpi\")\n  set(DEFAULT_MPI_IMPL \"OPENMPI\")\n  set(all_mpi_names ${all_mpi_names} \" openmpi \")\nendif()\n\nif (MPICH2_FOUND)\n  # This is needed by the mpi collectors\n  set(HAVE_MPICH2 \"true\")\n  set(HAVE_MPI \"true\")\n  set(DEFAULT_MPI_IMPL_NAME \"mpich2\")\n  set(DEFAULT_MPI_IMPL \"MPICH2\")\n  set(all_mpi_names ${all_mpi_names} \" mpich2 \")\nendif()\n\nif (MPICH_FOUND)\n  # This is needed by the mpi collectors\n  set(HAVE_MPICH \"true\")\n  set(HAVE_MPI \"true\")\n  set(DEFAULT_MPI_IMPL_NAME \"mpich\")\n  set(DEFAULT_MPI_IMPL \"MPICH\")\n  set(all_mpi_names ${all_mpi_names} \" mpich \")\nendif()\n\nif (MPT_FOUND)\n  # This is needed by the mpi collectors\n  set(HAVE_MPT \"true\")\n  set(HAVE_MPI \"true\")\n  set(DEFAULT_MPI_IMPL_NAME \"mpt\")\n  set(DEFAULT_MPI_IMPL \"MPT\")\n  set(all_mpi_names ${all_mpi_names} \" mpt \")\nendif()\n\nif (MVAPICH_FOUND)\n  # This is needed by the mpi collectors\n  set(HAVE_MVAPICH \"true\")\n  set(HAVE_MPI \"true\")\n  set(DEFAULT_MPI_IMPL_NAME \"mvapich\")\n  set(DEFAULT_MPI_IMPL \"MVAPICH\")\n  set(all_mpi_names ${all_mpi_names} \" mvapich \")\nendif()\n\nif (MVAPICH2_FOUND)\n  # This is needed by the mpi collectors\n  set(HAVE_MVAPICH2 \"true\")\n  set(HAVE_MPI \"true\")\n  set(DEFAULT_MPI_IMPL_NAME \"mvapich2\")\n  set(DEFAULT_MPI_IMPL \"MVAPICH2\")\n  set(all_mpi_names ${all_mpi_names} \" mvapich2 \")\nendif()\n\nset(ALL_MPI_IMPL_NAMES ${all_mpi_names})\n#\n#--------------------------------------------------------------------------------\n# Look for the base CBTF package which is required in order for this build to be\n# successful.\n#--------------------------------------------------------------------------------\n#\n# If building the FE for the Intel MIC compute node runtimes (MRNet filters run on compute node \n# host processor not on the native compute node processor then do not look for CBTF\n#\nfind_package(CBTF)\n\n#--------------------------------------------------------------------------------\n# Build the major components for cbtf-krell if CBTF is found\n# Required external packages are checked for in the sub-directories' cmake files\n#--------------------------------------------------------------------------------\n#\nif(CBTF_FOUND OR (CBTF_FILTERS_RUN_ON MATCHES \"host\" AND RUNTIME_ONLY MATCHES \"true\" ))\n    if (RUNTIME_ONLY MATCHES \"true\")\n        add_subdirectory(messages)\n        add_subdirectory(services)\n        add_subdirectory(core)\n    else()\n        add_subdirectory(messages)\n        if (BUILD_FE_USING_CN_RUNTIMES MATCHES \"false\")\n            add_subdirectory(services)\n        endif()\n        add_subdirectory(core)\n        add_subdirectory(test)\n    endif()\nendif()\n\n#\n#--------------------------------------------------------------------------------\n# Create the package configuration file for the CBTF-Krell project so that other\n# external builds/builders can find the libraries and binaries created by this build.\n#--------------------------------------------------------------------------------\n#\nset(INCLUDE_INSTALL_DIR include )\nset(LIBRARY_INSTALL_DIR lib${SUFFIX} )\n\n#\n# FIXME: Nothing here worked for attempting to find cbtf-krell using these files.\n#\n#include(CMakePackageConfigHelpers)\n#configure_package_config_file(CBTF-KrellConfig.cmake.in\n#    ${CMAKE_CURRENT_BINARY_DIR}/CBTF-KrellConfig.cmake\n#    INSTALL_DESTINATION ${LIB_INSTALL_DIR}/CBTF-Krell/cmake\n#    PATH_VARS INCLUDE_INSTALL_DIR LIBRARY_INSTALL_DIR)\n#write_basic_package_version_file(\n#    ${CMAKE_CURRENT_BINARY_DIR}/CBTF-KrellConfigVersion.cmake\n#    VERSION ${CBTF_KRELL_VERSION}\n#    COMPATIBILITY SameMajorVersion )\n#install(FILES ${CMAKE_CURRENT_BINARY_DIR}/CBTF-KrellConfig.cmake\n#              ${CMAKE_CURRENT_BINARY_DIR}/CBTF-KrellConfigVersion.cmake\n#    DESTINATION share/CBTF-Krell/cmake )\n\ninstall(FILES cmake/FindBinutils.cmake\n\tcmake/FindPapi.cmake\n\tcmake/FindDyninstAPI.cmake\n\tcmake/FindLibDwarf.cmake\n\tcmake/FindLibElf.cmake\n\tcmake/FindLibMonitor.cmake\n\tcmake/FindLibIomp.cmake\n        DESTINATION share/KrellInstitute/cmake\n)\n\ninstall(FILES cmake/FindCBTF-Krell.cmake cmake/CBTF-KrellConfig.cmake\n        DESTINATION share/CBTF-Krell/cmake\n)\n\n#--------------------------------------------------------------------------------\n# Build the CBTF/MRNet playback executables as needed.\n#--------------------------------------------------------------------------------\nif(ENABLE_CBTF_MRNET_PLAYBACK)\n    add_subdirectory(utils/cbtf-mrnet-playback)\n    if(HAVE_MPI)\n        add_subdirectory(utils/cbtf-mrnet-playback-mpi)\n    endif()\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/services/configure.ac": "################################################################################\n# Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 2 of the License, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n# details.\n#\n# You should have received a copy of the GNU General Public License along with\n# this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n# Place, Suite 330, Boston, MA  02111-1307  USA\n################################################################################\n\nAC_INIT([services], [1.0])\nAC_COPYRIGHT([[Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.]])\n\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE\nAM_CONFIG_HEADER([config.h])\n\nAH_TOP([\n/*******************************************************************************\n** Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n])\n\nAC_GNU_SOURCE\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_LIBTOOL\nAC_PROG_INSTALL\n\nLT_CONFIG_LTDL_DIR([libltdl])\nLT_INIT([dlopen])\nLTDL_INIT([recursive])\n\nAC_PATH_PROG([RPCGEN], rpcgen)\nAC_PROG_LN_S\n\n################################################################################\n# Handle PowerPC and X86-64 Special Cases\n################################################################################\nAC_ARG_WITH(ppc64_bitmode,\n            AC_HELP_STRING([--with-ppc64-bitmode=<32,64>],\n                           [Specify ppc64 library bit mode @<:@64@:>@]),\n            ppc64_bitmode=$withval, ppc64_bitmode=\"64\")\n\nAC_MSG_CHECKING([Configuring for host = $host  with ppc64_bitmode = $ppc64_bitmode])\n\ncase \"$host\" in\n    powerpc-*-linux*)\n        AC_MSG_CHECKING([Configuring for powerpc-star-linux])\n\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n            libdir='${exec_prefix}/lib'\n        fi\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\n    powerpc64-*-*)\n\n        AC_MSG_CHECKING([Configuring for powerpc64-star-linux with ppc64_bitmode = $ppc64_bitmode])\n        if test \"$ppc64_bitmode\" = \"64\" ; then\n                AC_MSG_CHECKING([Configuring for 64 bit powerpc64-star-linux host])\n                abi_libdir=\"lib64\"\n                alt_abi_libdir=\"lib\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n                    libdir='${exec_prefix}/lib64'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib64 $LDFLAGS\"\n                CFLAGS=\"-m64 $CFLAGS\"\n                CXXFLAGS=\"-m64 $CXXFLAGS\"\n                CPPFLAGS=\"-m64 $CPPFLAGS\"\n        elif test \"$ppc64_bitmode\" = \"32\" ; then\n                AC_MSG_CHECKING([Configuring for 32 bit powerpc64-star-linux host])\n                abi_libdir=\"lib\"\n                alt_abi_libdir=\"lib64\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n                    libdir='${exec_prefix}/lib'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        fi\n        ;;\n\n    x86_64-*-linux*)\n        AC_MSG_CHECKING([Configuring for x86_64--star-linux host])\n        if test -d /usr/lib/x86_64-linux-gnu ; then\n          if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n            libdir='${exec_prefix}/lib'\n          fi\n          abi_libdir=\"lib\"\n          alt_abi_libdir=\"lib64\"\n          LDFLAGS=\"$LDFLAGS\"\n        else\n          if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n            libdir='${exec_prefix}/lib64'\n          fi\n          abi_libdir=\"lib64\"\n          alt_abi_libdir=\"lib\"\n          LDFLAGS=\"$LDFLAGS\"\n        fi\n        ;;\n\n    *)\n        AC_MSG_CHECKING([Configuring for default host])\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\nesac\ntopdir_execprefix=${exec_prefix}\nAC_SUBST(topdir_execprefix)\n\nabi_libdir_name=${abi_libdir}\nAC_SUBST(abi_libdir_name)\nalt_abi_libdir_name=${alt_abi_libdir}\nAC_SUBST(alt_abi_libdir_name)\n\ncbtf_platform=`uname -i`\ncbtf_hardware_platform=$cbtf_platform\nAC_MSG_CHECKING([Checking for cbtf_hardware_platform=$cbtf_hardware_platform])\nAC_SUBST(cbtf_hardware_platform)\n\n\n################################################################################\n# Check for POSIX Threads (ISO/IEC 9945-1:1996)\n################################################################################\n\nAC_CHECK_HEADER(pthread.h, [ AC_CHECK_LIB(pthread, pthread_create, [\n    AC_DEFINE(HAVE_POSIX_THREADS, 1, [Define to 1 if you have POSIX threads.])\n], [\n    AC_MSG_FAILURE([cannot locate POSIX thread library and/or headers.])\n]) ])\n\n\n################################################################################\n# Check for TLS option, default to implicit\n################################################################################\n\nAC_ARG_WITH(tls,\n            AC_HELP_STRING([--with-tls=TYPE],\n                           [tls (implicit, explicit) @<:@implicit@:>@]),\n            TLS=$withval, TLS=\"implicit\")\n\ncase \"$TLS\" in\n    implicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, false)\n        ;;\n\n    explicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, true)\n        AC_DEFINE(USE_EXPLICIT_TLS, 1, [Define to 1 if you want to use an explicit TLS implementation instead of the __thread keyword.])\n        ;;\n\n    *)\n        AC_MSG_ERROR([invalid tls specification \"$TLS\".])\n        ;;\nesac\n\n################################################################################\n# Begin Target O/S Specification\n################################################################################\n\ntarget_os=$host\nAC_MSG_CHECKING(for Target O/S)\nAC_ARG_WITH(target-os,\n    AC_HELP_STRING([--with-target-os=TARGET_OS],\n                   [target os specification @<:@$host@:>@]),\n                    TARGET_OS=$withval, TARGET_OS=\"$host\")\n\n\nAM_CONDITIONAL(HAVE_TARGET_STATIC, false)\nAM_CONDITIONAL(BUILD_TARGETED, false)\nbuild_targeted=0\ncase \"$TARGET_OS\" in\n    cray-xk)\n\tAC_DEFINE(TARGET_OS_CRAYXK, 1, [Do not define if not building for targeted cray-xk.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xk,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xe)\n\tAC_DEFINE(TARGET_OS_CRAYXE, 1, [Do not define if not building for targeted cray-xe.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xe,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt5)\n\tAC_DEFINE(TARGET_OS_CRAYXT5, 1, [Do not define if not building for targeted cray-xt5.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt5,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt4)\n\tAC_DEFINE(TARGET_OS_CRAYXT4, 1, [Do not define if not building for targeted cray-xt4.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt4,\n\t\t\t[Name targeted OS])\n\t;;\n    bgl)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGL, 1, [Do not define if not building for targeted bgl.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgl,\n\t\t\t[Name targeted OS])\n\t;;\n    bgp)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGP, 1, [Do not define if not building for targeted bgp.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgp,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=1\n\t;; \n    bgq)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n        AM_CONDITIONAL(BUILD_TARGETED, true)\n        AC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n        AC_DEFINE(TARGET_OS_BGQ, 1, [Do not define if not building for targeted bgq.])\n        AC_DEFINE_UNQUOTED(TARGET_OS,bgq,\n                           [Name targeted OS])\n\tbuild_targeted=1\n        ;;\n    *)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, false)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [0],[Define to 0 for targeted non-static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, false)\n\tAC_DEFINE(BUILD_TARGETED, 0, [Define to 1 if building a targeted runtime.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,$host,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=0\n\t;; \nesac\n\nAC_SUBST(BUILD_TARGETED)\nAC_SUBST(TARGET_OS)\n\n################################################################################\n# Runtime Target PTHREADS Availability Specification (libmonitor callbacks)\n################################################################################\n#\n# Option: --enable-target-pthreads=yes\n# Requires libpthread.\n#\nAC_MSG_CHECKING(for target pthread support specification)\nAC_ARG_ENABLE([target-pthreads],\n    [AS_HELP_STRING([--enable-target-pthreads],\n        [Enable support on target architecture for pthreads [default=yes]])],\n    [], [enable_target_pthreads=yes])\n\nAM_CONDITIONAL([HAVE_TARGET_TEST_POSIX_THREADS],\n    [test x$enable_target_pthreads = xyes])\n\nif test \"x$enable_target_pthreads\" = xyes ; then\n    AC_MSG_RESULT(yes)\n    AC_DEFINE([HAVE_TARGET_POSIX_THREADS], [1],\n        [Enable support on the target architecture for pthreads.])\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_SUBST(HAVE_TARGET_POSIX_THREADS)\n\n################################################################################\n# Runtime Target DLOPEN Availability Specification (libmonitor callbacks)\n################################################################################\n#\n# Option: --enable-target_dlopen=yes\n#\nAC_MSG_CHECKING(for target dlopen support specification)\nAC_ARG_ENABLE([target_dlopen],\n    [AS_HELP_STRING([--enable-target_dlopen],\n        [include support on the target architecture for dlopen [default=yes]])],\n    [], [enable_target_dlopen=yes])\n\nif test \"x$enable_target_dlopen\" = xyes ; then\n    AC_DEFINE([HAVE_TARGET_DLOPEN], [1],\n        [Enable support on the target architecture for dlopen.])\n    AC_MSG_RESULT(yes)\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_SUBST(HAVE_TARGET_DLOPEN)\n\n################################################################################\n# Runtime Target SIGNALS Availability Specification\n################################################################################\n#\n# Option: --enable-target-signals=yes\n#\nAC_MSG_CHECKING(for target signal support specification)\nAC_ARG_ENABLE([target-signals],\n    [AS_HELP_STRING([--enable-target-signals],\n        [Enable support on target architecture for signals [default=yes]])],\n    [],\n    [enable_target_signals=yes])\n\nif test \"x$enable_target_signals\" = xyes ; then\n    AC_MSG_RESULT(yes)\n    AC_DEFINE([HAVE_TARGET_SIGNALS], [1],\n        [Enable support on target architecture for signals.])\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_SUBST(HAVE_TARGET_SIGNALS)\n\n################################################################################\n# Runtime Target FORK Availability Specification (libmonitor callbacks)\n################################################################################\n#\n# Option: --enable-target-fork=yes\n# Requires fork and exec families.\n#\nAC_MSG_CHECKING(for target fork support specification)\nAC_ARG_ENABLE([target-fork],\n    [AS_HELP_STRING([--enable-target-fork],\n        [Enable support on target architecture for fork and exec families [default=yes]])],\n    [], [enable_target_fork=yes])\n\nif test \"x$enable_target_fork\" = xyes ; then\n    AC_DEFINE([HAVE_TARGET_FORK], [1],\n        [Enable support on target architecture for fork and exec families.])\n    AC_MSG_RESULT(yes)\nelse\n    AC_MSG_RESULT(no)\nfi\n\nAC_SUBST(HAVE_TARGET_FORK)\n\n################################################################################\n# Runtime Target SHARED LIBRARY BUILD Specification (libmonitor callbacks)\n################################################################################\n#\n# Option: --enable-target-shared=yes\n#\nAC_MSG_CHECKING(for target shared libraries build specification)\nAC_ARG_ENABLE([target-shared],\n    [AS_HELP_STRING([--enable-target-shared],\n        [Enable support on target architecture for building shared libraries [default=no]])],\n    [enable_target_shared=yes],\n    [enable_target_shared=no])\n\nif test \"x$enable_target_shared\" = xyes ; then\n    AC_MSG_RESULT(yes)\n    AM_CONDITIONAL(HAVE_TARGET_SHARED, true)\n    AC_DEFINE([HAVE_TARGET_SHARED], [1],\n        [Enable support on target architecture for shared libraries.])\nelse\n    AC_MSG_RESULT(no)\n    AM_CONDITIONAL(HAVE_TARGET_SHARED, false)\nfi\n\nAC_SUBST(HAVE_TARGET_SHARED)\n\n################################################################################\n# Check for Additional Packages\n################################################################################\n\nAX_BINUTILS()\nAX_LIBMONITOR()\nAX_LIBUNWIND()\nAX_PAPI()\nAX_LW_MRNET()\nAX_CBTF()\nAX_CBTF_MRNET()\nAX_MESSAGES()\nAX_LIBIOMP()\n\nAC_CONFIG_FILES([\n    Makefile\n    libltdl/Makefile\n    include/Makefile\n    src/Makefile\n    src/binutils/Makefile\n    src/common/Makefile\n    src/data/Makefile\n    src/fileio/Makefile\n    src/fpe/Makefile\n    src/monitor/Makefile\n    src/mrnet/Makefile\n    src/offline/Makefile\n    src/ompt/Makefile\n    src/papi/Makefile\n    src/timer/Makefile\n    src/unwind/Makefile\n    src/xdr/Makefile\n    test/Makefile\n    collector/Makefile\n])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/services/src/offline/offline.x": "/*******************************************************************************\n** Copyright (c) 2007-2011 The Krell Institue. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file\n *\n * Specification of the offline collector's object blobs.\n *\n */\n\n/** Structure of the blob containing our file objects. */\nstruct cbtf_objects {\n    string   objname<>;   /** < Name of the object. */\n    uint64_t addr_begin;  /** < begin address of object */\n    uint64_t addr_end;    /** < end address of object */\n    uint64_t time_begin;  /** < load time of object */\n    uint64_t time_end;    /** < close time of object */\n    uint8_t  is_open;     /** < flag to indicate dlopen or dlclose */\n};\n\nstruct cbtf_offline_data {\n    cbtf_objects objs<>;\n};\n\n/** Structure of the blob containing our process info. */\nstruct cbtf_expinfo {\n    string   collector<>;  /** < Name of the collector. */\n    string   exename<>;    /** < Name of the executable. */\n    string   traced<>;     /** < list of colon separated traceable functions.*/\n    string   event<>;      /** < list of colon separated traceable events. */\n    int32_t rank;\t   /** < mpi rank for this object */\n    uint32_t omptid;\t   /** < openmp tid for this object */\n    uint32_t rate;\t   /** < rate or threshold parameter for this object */\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/services/src/offline/GetDLInfo.c": "/*******************************************************************************\n * ** Copyright (c) 2006-201a The Krell Institue. All Rights Reserved.\n * **\n * ** This library is free software; you can redistribute it and/or modify it under\n * ** the terms of the GNU Lesser General Public License as published by the Free\n * ** Software Foundation; either version 2.1 of the License, or (at your option)\n * ** any later version.\n * **\n * ** This library is distributed in the hope that it will be useful, but WITHOUT\n * ** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * ** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n * ** details.\n * **\n * ** You should have received a copy of the GNU Lesser General Public License\n * ** along with this library; if not, write to the Free Software Foundation, Inc.,\n * ** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n * *******************************************************************************/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#if defined(RUNTIME_PLATFORM_BGP) || defined(RUNTIME_PLATFORM_BGQ)\n#define BLUEGENE 1\n#endif\n\n#define _ISOC99_SOURCE\n\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <limits.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <link.h>\n#include \"KrellInstitute/Services/monlibs.h\"\n\n\n/* TODO: allow configuration to fallback to sscanf method. */\n#define CBTF_USE_STROULL_FOR_MAPPINGS 1\n/* hmm. maybe control this at build time? */\n/* FIXME: While we do set this here it is negated later to force\n * using /proc/self/maps methods.\n */\n#define CBTF_USE_DL_ITERATE 1\n\nextern void cbtf_offline_record_dso(const char* dsoname, uint64_t begin, uint64_t end, uint8_t is_dlopen);\nextern void cbtf_offline_record_dlopen(const char* dsoname, uint64_t begin, uint64_t end, uint64_t b_time, uint64_t e_time);\n\nextern const char* CBTF_GetExecutablePath();\n\n#if defined(RUNTIME_PLATFORM_BGP) || defined(RUNTIME_PLATFORM_BGQ)\n#include <link.h>\nextern etext;\nextern edata;\n\nconst char *monlibs_vdso_name = \"[vdso]\";\nconst char *monlibs_exe_name = \"[exe]\";\nstatic struct dl_phdr_info *cur_list = NULL;\nstatic unsigned int cur_list_size = 0;\nstatic struct dl_phdr_info *new_list = NULL;\nstatic unsigned int new_list_size = 0;\n#define LIST_INITIAL_SIZE 32\nstatic unsigned int lists_max_size = 0;\n\nstatic int checked_for_static = 0;\nstatic int is_static = 0;\n\n#if (_LP64)\n#define ElfX_auxv_t Elf64_auxv_t\n#define ElfX_phdr Elf64_Phdr\n#else\n#define ElfX_auxv_t Elf32_auxv_t\n#define ElfX_phdr Elf32_Phdr\n#endif\n\nextern char **environ;\n\nstatic int exe_is_static()\n{\n   char **walk_environ = environ;\n   ElfX_auxv_t *auxv;\n   ElfX_phdr *phdr = NULL;\n\n   /* AuxV vector comes after environment */\n   while (*walk_environ) walk_environ++;\n   walk_environ++;\n\n   /* Extract phdrs from auxv */\n   for (auxv = (Elf32_auxv_t *) walk_environ; auxv->a_type != AT_NULL; auxv++) {\n      if (auxv->a_type == AT_PHDR) {\n         phdr = (ElfX_phdr *) auxv->a_un.a_val;\n      }\n   }\n\n   if (!phdr) {\n      fprintf(stderr, \"Error - expected to find program headers\\n\");\n   }\n\n   /* If phdrs have a INTERP, then dynamic */\n   for (; phdr->p_type != PT_NULL; phdr++) {\n      if (phdr->p_type == PT_INTERP)\n         return 0;\n   }\n   return 1;\n}\n#endif\n\n#if defined(CBTF_USE_DL_ITERATE) && defined(JUNK)\nstatic int dl_cb(struct dl_phdr_info *info, size_t size, void *data)\n{\n   if (new_list_size >= lists_max_size) {\n      if (lists_max_size)\n         lists_max_size *= 2;\n      else\n         lists_max_size = LIST_INITIAL_SIZE;\n      cur_list = (struct dl_phdr_info *) realloc(cur_list, sizeof(struct dl_phdr_info) * lists_max_size);\n      new_list = (struct dl_phdr_info *) realloc(new_list, sizeof(struct dl_phdr_info) * lists_max_size);\n   }\n\n   memcpy(new_list + new_list_size, info, sizeof(struct dl_phdr_info));\n   new_list_size++;\n   return 0;\n}\n\nstatic int dl_phdr_cmp(const void *a, const void *b)\n{\n   struct dl_phdr_info *first = (struct dl_phdr_info *) a;\n   struct dl_phdr_info *second = (struct dl_phdr_info *) b;\n   return first->dlpi_phdr > second->dlpi_phdr;\n}\n\nstatic void report(struct dl_phdr_info *pinfo, int is_load, library_cb cb,\n\t\t   uint64_t b_time, uint64_t e_time)\n{\n   mem_region mr[MAX_LOAD_SEGMENTS];\n   unsigned int i, j = 0;\n   ElfW(Addr) base_addr = pinfo->dlpi_addr;\n   const char *name = NULL;\n\n   if (is_load)\n   {\n      for (i = 0; i < pinfo->dlpi_phnum; i++) {\n\n         const ElfW(Phdr) *phdr = pinfo->dlpi_phdr + i;\n         if (phdr->p_type != PT_LOAD)\n            continue;\n\n         mr[j].mem_addr = base_addr + phdr->p_vaddr;\n         mr[j].mem_size = phdr->p_memsz;\n         mr[j].file_offset = phdr->p_offset;\n         mr[j].file_size = phdr->p_filesz;\n         mr[j].premissions = (phdr->p_flags & 7);\n         j++;\n      }\n\n      if (pinfo->dlpi_name[0] == '\\0') {\n         /* Both the executable and vdso names are given as empty strings.  Fill in with constant strings */\n         if (j == 1 && mr[0].mem_size <= 0x1000) {\n            /* One segment less than a single page in size implies VDSO on linux */\n            name = monlibs_vdso_name;\n         }\n         else {\n            name = CBTF_GetExecutablePath();\n         }\n      }\n      else {\n         name = strdup(pinfo->dlpi_name);\n      }\n\n      pinfo->dlpi_name = name;\n   }\n   else {\n      name = pinfo->dlpi_name;\n   }\n\n   cb(base_addr, name, mr, j, is_load, b_time, e_time);\n\n   if (!is_load) {\n      if (name != monlibs_vdso_name && name != monlibs_exe_name) {\n         free((void *) name);\n      }\n   }\n}\n\nvoid monlibs_getLibraries(library_cb cb, uint64_t b_time, uint64_t e_time)\n{\n   unsigned c = 0, n = 0;\n   struct dl_phdr_info *temp;\n\n   /* Fill in the new list with the current libraries. */\n   new_list_size = 0;\n   dl_iterate_phdr(dl_cb, NULL);\n\n   /* Sort the new list for fast comparison */\n   qsort(new_list, new_list_size, sizeof(struct dl_phdr_info), dl_phdr_cmp);\n\n   /* Look for differences between orig and new list */\n   for (;;) {\n      if (c == cur_list_size && n == new_list_size) {\n         /* End of both lists */\n         break;\n      }\n      else if (c == cur_list_size) {\n         /* End of cur list, but still have new list.   New object. */\n         report(new_list + n++, 1, cb, b_time, e_time);\n      }\n      else if (n == new_list_size) {\n         /* End of new list, but still have cur list.  Deleted object */\n         report(cur_list + c++, 0, cb, b_time, e_time);\n      }\n      else if (cur_list[c].dlpi_phdr == new_list[n].dlpi_phdr) {\n         /* Same element in old and new list.  No change here. */\n         new_list[n++].dlpi_name = cur_list[c++].dlpi_name;\n      }\n      else if (cur_list[c].dlpi_phdr < new_list[n].dlpi_phdr) {\n         /* There's an element in the cur list that we didn't see in the new list.  Deleted object */\n         report(cur_list + c++, 0, cb, b_time, e_time);\n      }\n      else if (cur_list[c].dlpi_phdr > new_list[n].dlpi_phdr) {\n         /* There's an element in the new list that we didn't see in the cur list.  New object */\n         report(new_list + n++, 1, cb, b_time, e_time);\n      }\n   }\n\n   /* Swap the new list with the cur list.  Empty (but leave allocated) the new list */\n   temp = cur_list;\n   cur_list = new_list;\n   new_list = temp;\n   cur_list_size = new_list_size;\n   new_list_size = 0;\n}\n\nstatic void lc(ElfW(Addr) base_address, const char *name, mem_region *regions,\n\t\tunsigned int num_regions, int is_load,\n\t\tuint64_t b_time, uint64_t e_time)\n\n{\n#ifndef NDEBUG\n    if ( (getenv(\"CBTF_DEBUG_COLLECTOR_DSOS\") != NULL)) {\n\tfprintf(stderr, \"CBTF_GetDLInfo: %s %s at [%#lx, %#lx]\\n\",\n\t\tis_load ? \"Loaded\" : \"Unloaded\", name,\n\t\tregions[0].mem_addr,\n\t\tregions[0].mem_addr + regions[0].mem_size);\n   }\n#endif\n   \n    if (is_load) {\n\tcbtf_offline_record_dlopen(name, regions[0].mem_addr,\n\t\t\t      regions[0].mem_addr + regions[0].mem_size,\n\t\t\t      b_time, e_time);\n    } else {\n\tcbtf_offline_record_dso(name, regions[0].mem_addr, regions[0].mem_addr + regions[0].mem_size, is_load);\n    }\n}\n#endif\n\n/*\n * Get the address map of executable and dsos loaded. Default to processing\n * /proc/self/maps. Can optionaly build to use linkmap info via defining\n * CBTF_USE_DL_ITERATE at build time.  The CBTF_USE_DL_ITERATE method may not\n * be safe to use within a signalhandler so care would be needed to call\n * that mathod with collection paused.\n */\nint CBTF_GetDLInfo(pid_t pid, char *path, uint64_t b_time, uint64_t e_time)\n{\n#if defined(RUNTIME_PLATFORM_BGP) || defined(RUNTIME_PLATFORM_BGQ)\n    if (checked_for_static == 0) {\n\tis_static = exe_is_static();\n\tchecked_for_static = 1;\n    }\n    if (is_static) {\n\tcbtf_offline_record_dso(CBTF_GetExecutablePath(),(uint64_t)0x01000000,(uint64_t)&etext,0);\n    } else {\n\tmonlibs_getLibraries(lc,b_time,e_time);\n    }\n#else\n\n    /* Process address range and mapped filename using dl_iterate methods. */\n#if defined(CBTF_USE_DL_ITERATE) && defined(JUNK)\n    monlibs_getLibraries(lc,b_time,e_time);\n#else\n\n    /* Process /proc/self/maps for address range and mapped filename. */\n    char mapfile_name[PATH_MAX];\n    FILE *mapfile;\n\n    sprintf(mapfile_name, \"/proc/%ld/maps\", (long)pid);\n    mapfile = fopen(mapfile_name, \"r\");\n\n    if(!mapfile) {\n\tfprintf(stderr,\"Error opening%s: %s\\n\", mapfile_name, strerror(errno));\n\treturn(1);\n    }\n\n    while(!feof(mapfile)) {\n\tchar buf[PATH_MAX+100], perm[5], dev[6], mappedpath[PATH_MAX];\n\tunsigned long long begin, end;\n\n\t/* read in one line from the /proc maps file for this pid. */\n\tif(fgets(buf, sizeof(buf), mapfile) == 0) {\n\t    break;\n\t}\n\n\t/* skip any entry that does not have 'x' permissions. */\n\tchar *permstring = strchr(buf, (int) ' ');\n\tif (!(*(permstring+3) == 'x' && strchr(buf, (int) '/'))) {\n\t    continue;\n\t}\n\n#if 0\n\tif ( (getenv(\"CBTF_DEBUG_COLLECTOR_DSOS\") != NULL)) {\n\t    fprintf(stderr,\"CBTF_GetDLInfo examine maps line: %s\",buf);\n\t}\n#endif\n\n\t/* process line with 'x' permissions. */\n\t/* Read in the /proc/<pid>/maps file as it is formatted. */\n\t/* All fields are strings. The fields are as follows. */\n\t/* addressrange  perms offset  dev  inode  pathname */\n\t/* The addressrange field is begin-end in hex. */\n\t/* We record these later as uint64_t. */\n\t/* We record the mappedpath as is and ignore the rest of the fields. */\n\t/* example maps line for the executable: */\n\t/* 20000000-20003000 r-xp 00000000 e7a:390e 1 /home/foo/bar.exe */\n\n#if defined(CBTF_USE_STROULL_FOR_MAPPINGS)\n\t/* process mapping with strtoull for begin and end addresses. */\n\tchar *end_addr, *mpath;\n\t/* Find the end address from buf. buf will now contain*/\n\tend_addr = strchr(buf, '-');\n\t/* Find the full path to exe or dso from buf. */\n\tmpath = strrchr(buf, (int) ' ');\n\t/* null terminate end_addr and mpath. */\n\t*end_addr = '\\0';\n\tend_addr++;\n\t*mpath = '\\0';\n\tmpath++;\n\n\t/* TODO: check errno on these strtoull calls if addresses\n \t*  do not fit into a uint64_t.\n \t*/\n\tbegin = strtoull(buf, NULL, 16);\n\tend = strtoull(end_addr, NULL, 16);\n\tsscanf(mpath, \"%s\", mappedpath);\n\n#ifndef NDEBUG\n\tif ( (getenv(\"CBTF_DEBUG_DSO_DETAILS\") != NULL)) {\n\t    fprintf(stderr,\"CBTF_GetDLInfo resolves %s with begin:%08Lx end:%08Lx\\n\",mappedpath,begin,end);\n\t}\n#endif\n\n#else   /* sscanf method for whole maps line. */\n\tchar perm[5], dev[6];\n\tunsigned long long offset;\n\tuint64_t inode;\n\n        int sval = sscanf(buf, \"%Lx-%Lx %s %Lx %s %ld %s\", &begin, &end, perm,\n                &offset, dev, &inode, mappedpath);\n\n#ifndef NDEBUG\n\tif ( (getenv(\"CBTF_DEBUG_DSO_DETAILS\") != NULL)) {\n\t    fprintf(stderr,\"CBTF_GetDLInfo sval from sscanf:%d begin:%Lx end:%Lx\\n\",sval,begin,end);\n\t}\n#endif\n\n#endif\n\n\t/* Now we record the address range and mappedpath. */\n\t/* If a dso is passed in the path argument we only want to record */\n\t/* this particular dso into the openss-raw file. This happens when */\n\t/* the victim application has performed a dlopen. */\n\tif (path != NULL &&\n\t    mappedpath != NULL &&\n\t    (strncmp(basename(path), basename(mappedpath), strlen(basename(path))) == 0) ) {\n#ifndef NDEBUG\n\t    if ( (getenv(\"CBTF_DEBUG_COLLECTOR_DSOS\") != NULL)) {\n\t\tfprintf(stderr,\"CBTF_GetDLInfo DLOPEN RECORD: %s [%08Lx, %08Lx]\\n\",\n\t\t    mappedpath, begin, end);\n\t    }\n#endif\n\t    cbtf_offline_record_dlopen(mappedpath, begin, end, b_time, e_time);\n\t    break;\n\t}\n\n\t/* Record the address range and mappedfile for non dlopened objects. */\n\telse if (path == NULL) {\n#ifndef NDEBUG\n\t    if ( (getenv(\"CBTF_DEBUG_COLLECTOR_DSOS\") != NULL)) {\n\t\tfprintf(stderr,\"CBTF_GetDLInfo LD RECORD %s [%08Lx, %08Lx]\\n\", mappedpath, begin, end);\n\t    }\n#endif\n\t    cbtf_offline_record_dso(mappedpath, begin, end, 0);\n\t}\n    } /* end while feof mapfile */\n    fclose(mapfile);\n\n#endif  /* ifdef CBTF_USE_DL_ITERATE */\n\n#endif  /* ifdef BGP or BGQ */\n\n    return(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/services/src/monitor/Monitor.c": "/*******************************************************************************\n** Copyright (c) 2007-2018 The Krell Institue. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file\n *\n * Declaration and definition of the offline libmonitor callbacks\n * that we will override.\n *\n */\n\n/*\n * The Rice libmonitor package defines _MONITOR_H_\n * and these callbacks we can use to monitor a process.\n *\n * monitor_init_library(void)\n * monitor_fini_library(void)\n * monitor_pre_fork(void)\n * monitor_post_fork(pid_t child, void *data)\n * monitor_init_process(int *argc, char **argv, void *data)  SERVICE callback.\n * monitor_fini_process(int how, void *data)  SERVICE callback.\n * monitor_thread_pre_create(void)\n * monitor_thread_post_create(void *data)\n * monitor_init_thread_support(void)\n * monitor_init_thread(int tid, void *data)\n * monitor_fini_thread(void *data)  SERVICE callback.\n * monitor_dlopen(const char *path, int flags, void *handle)  SERVICE callback.\n * monitor_dlclose(void *handle)\n * monitor_init_mpi(int *argc, char ***argv)\n                  monitor_mpi_comm_size(), monitor_mpi_comm_rank(), *argc);\n * monitor_fini_mpi(void)\n * monitor_mpi_pcontrol(int level)\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"monitor.h\"\n\n#include \"KrellInstitute/Services/Monitor.h\"\n#include \"KrellInstitute/Services/Offline.h\"\n#include \"KrellInstitute/Services/Time.h\"\n#include \"KrellInstitute/Services/TLS.h\"\n\n/** Type defining the items stored in thread-local storage. */\ntypedef struct {\n    bool in_mpi_pre_init;\n    int mpi_pcontrol, start_enabled;\n    CBTF_Monitor_Status sampling_status;\n    int process_is_terminating;\n    int thread_is_terminating;\n    bool  collector_started;\n    CBTF_Monitor_Type CBTF_monitor_type;\n\n    // FIXME: MOVE THIS to collector services.\n    cbtf_dlinfoList *cbtf_dllist_curr, *cbtf_dllist_head;\n} TLS;\n\n/* debug support */\nstatic bool IsMonitorDebugEnabled = false;\nstatic pid_t thePid;\n\n/* This global controls defering of an monitor callbacks while\n * in mpi startup.  In particular we do not monitor any threads\n * started by the mpi library for it's own use.  The cuda collector\n * seems to have a dependency on cupti callback threads that are\n * started by some mpi libraries. So we need an override for this.\n */\nbool CBTF_in_mpi_startup = false;\nbool  init_mpi_comm_rank = false;\n\n#ifdef USE_EXPLICIT_TLS\n\n/**\n * Thread-local storage key.\n *\n * Key used for looking up our thread-local storage. This key <em>must</em>\n * be globally unique across the entire Open|SpeedShop code base.\n */\nstatic const uint32_t TLSKey = 0x0000FAB1;\n\n#else\n\n/** Thread-local storage. */\nstatic __thread TLS the_tls;\n\n#endif\n\n\n/*\n * callbacks for handling of PROCESS\n */\nvoid monitor_fini_process(int how, void *data)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    /* An assert here can cause libmonitor to hang with mpt.\n     * We may have forked a process which then did not call\n     * monitor_init_process and allocate TLS.\n     */\n    if (tls == NULL) {\n\tfprintf(stderr,\"Warning. monitor_fini_process called with no TLS.\\n\");\n\treturn;\n    }\n\n    if (tls->sampling_status == CBTF_Monitor_Finished) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_fini_process ALREADY FINISHED\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    if (tls->sampling_status == CBTF_Monitor_Not_Started) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_fini_process SAMPLING NOT STARTED\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_fini_process FINISHED SAMPLING\\n\",\n\t\tthePid,monitor_get_thread_num());\n    }\n\n    static int f = 0;\n    if (f > 0)\n      raise(SIGSEGV);\n    f++;\n\n    /* collector stop_sampling does not use the arguments param */\n    tls->sampling_status = CBTF_Monitor_Finished;\n    if(how == MONITOR_EXIT_EXEC) {\n\ttls->process_is_terminating = 1;\n\tcbtf_offline_stop_sampling(NULL, true);\n    } else {\n\ttls->process_is_terminating = 1;\n\tcbtf_offline_stop_sampling(NULL, true);\n    }\n\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_fini_process process_is_terminating %d\\n\",\n\t\tthePid,monitor_get_thread_num(),tls->process_is_terminating);\n    }\n\n    // The following call handles mrnet specific activity.\n    cbtf_offline_notify_event(CBTF_Monitor_fini_process_event);\n}\n\nvoid *monitor_init_process(int *argc, char **argv, void *data)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = malloc(sizeof(TLS));\n    Assert(tls != NULL);\n    CBTF_SetTLS(TLSKey, tls);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n#if 0\n    if (monitor_is_threaded()) {\n\tmonitor_get_thread_num() = monitor_get_thread_num();\n    } else {\n\tmonitor_get_thread_num() = 0;\n    }\n#endif\n\n    IsMonitorDebugEnabled = (getenv(\"CBTF_DEBUG_COLLECTOR\") != NULL);\n\n    short debug_mpi_pcontrol=0;\n    if ( (getenv(\"CBTF_DEBUG_MPI_PCONTROL\") != NULL)) {\n\tdebug_mpi_pcontrol=1;\n    }\n\n    thePid = getpid();\n    tls->cbtf_dllist_head = NULL;\n    tls->cbtf_dllist_curr = NULL;\n    tls->collector_started = false;\n    tls->in_mpi_pre_init = false;\n\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_init_process ENTERED\\n\",\n\t\tthePid,monitor_get_thread_num());\n    }\n\n    if (CBTF_in_mpi_startup || tls->in_mpi_pre_init) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_init_process returns early due to in mpi init\\n\",thePid,monitor_get_thread_num());\n\t}\n\ttls->sampling_status = CBTF_Monitor_Not_Started;\n\tcbtf_offline_sampling_status(CBTF_Monitor_init_process_event,CBTF_Monitor_Not_Started);\n\treturn NULL;\n    }\n\n    tls->CBTF_monitor_type = CBTF_Monitor_Proc;\n\n    tls->mpi_pcontrol = 0, tls->start_enabled = 0;\n    if (getenv(\"OPENSS_ENABLE_MPI_PCONTROL\") != NULL) tls->mpi_pcontrol = 1;\n    if (getenv(\"OPENSS_START_ENABLED\") != NULL) tls->start_enabled = 1;\n    if (getenv(\"CBTF_ENABLE_MPI_PCONTROL\") != NULL) tls->mpi_pcontrol = 1;\n    if (getenv(\"CBTF_START_ENABLED\") != NULL) tls->start_enabled = 1;\n\n    /* \n     * Always start the collector via cbtf_offline_start_sampling.\n     * In the presence of active mpi_pcontrol and start with the\n     * collector disabled, we issue a cbtf_offline_sampling_statuspaused call.\n     */\n    tls->sampling_status = CBTF_Monitor_Started;\n    tls->collector_started = true;\n    cbtf_offline_start_sampling(NULL);\n    cbtf_offline_notify_event(CBTF_Monitor_init_process_event);\n    if ( tls->mpi_pcontrol && !tls->start_enabled) {\n\tif (debug_mpi_pcontrol) {\n            fprintf(stderr,\"[%d,%d] monitor_init_process CBTF_START_ENABLED NOT SET. Defer sampling at start-up time.\\n\",\n\t\tthePid,monitor_get_thread_num());\n\t}\n\ttls->sampling_status = CBTF_Monitor_Paused;\n\tcbtf_offline_sampling_status(CBTF_Monitor_init_process_event,CBTF_Monitor_Paused);\n    } else if ( tls->mpi_pcontrol && tls->start_enabled) {\n\tif (debug_mpi_pcontrol) {\n            fprintf(stderr,\"[%d,%d] monitor_init_process CBTF_START_ENABLED SET. START SAMPLING\\n\",\n                thePid,monitor_get_thread_num());\n\t}\n    } else {\n\tif (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_init_process START SAMPLING\\n\",\n\t\tthePid,monitor_get_thread_num());\n\t}\n    }\n    return (data);\n}\n\n/*\n * callbacks for handling of monitor init\n */\nvoid monitor_init_library(void)\n{\n#if 0\n    if ( (getenv(\"CBTF_DEBUG_MONITOR_SERVICE\") != NULL)) {\n\tfprintf(stderr,\"cbtf callback monitor_init_library entered\\n\");\n    }\n#endif\n}\n\nvoid monitor_fini_library(void)\n{\n#if 0\n    if ( (getenv(\"CBTF_DEBUG_MONITOR_SERVICE\") != NULL)) {\n\tfprintf(stderr,\"cbtf callback monitor_fini_library entered\\n\");\n    }\n#endif\n    static int f = 0;\n    if (f > 0)\n      raise(SIGSEGV);\n    f++;\n}\n\n#ifdef HAVE_TARGET_POSIX_THREADS\n/*\n * callbacks for handling of THREADS\n */\nvoid monitor_fini_thread(void *ptr)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    if (!tls->collector_started) {\n\tif (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_fini_thread collector never started.\\n\",\n\t\tthePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_fini_thread STOP SAMPLING\\n\",\n\t\tthePid,monitor_get_thread_num());\n    }\n    cbtf_offline_stop_sampling(NULL,true);\n\n    tls->sampling_status = CBTF_Monitor_Finished;\n    tls->thread_is_terminating = 1;\n    // The following call will handle any mrnet specific activity.\n    cbtf_offline_notify_event(CBTF_Monitor_fini_thread_event);\n}\n\nvoid *monitor_init_thread(int tid, void *data)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = malloc(sizeof(TLS));\n    Assert(tls != NULL);\n    CBTF_SetTLS(TLSKey, tls);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    thePid = getpid();\n#if 0\n    if (monitor_is_threaded()) {\n\tmonitor_get_thread_num() = monitor_get_thread_num();\n    } else {\n\tmonitor_get_thread_num() = 0;\n    }\n#endif\n\n    short debug_mpi_pcontrol=0;\n    if ( (getenv(\"CBTF_DEBUG_MPI_PCONTROL\") != NULL)) {\n\tdebug_mpi_pcontrol=1;\n    }\n\n    tls->collector_started = false;\n    tls->cbtf_dllist_head = NULL;\n    tls->cbtf_dllist_curr = NULL;\n\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_init_thread BEGIN SAMPLING\\n\",\n\t\tthePid,monitor_get_thread_num());\n    }\n\n    tls->in_mpi_pre_init = false;\n    tls->CBTF_monitor_type = CBTF_Monitor_Thread;\n\n    tls->mpi_pcontrol = 0, tls->start_enabled = 0;\n    if (getenv(\"OPENSS_ENABLE_MPI_PCONTROL\") != NULL) tls->mpi_pcontrol = 1;\n    if (getenv(\"OPENSS_START_ENABLED\") != NULL) tls->start_enabled = 1;\n    if (getenv(\"CBTF_ENABLE_MPI_PCONTROL\") != NULL) tls->mpi_pcontrol = 1;\n    if (getenv(\"CBTF_START_ENABLED\") != NULL) tls->start_enabled = 1;\n\n    /* \n     * Always start the collector via cbtf_offline_start_sampling.\n     * In the presence of active mpi_pcontrol and start with the\n     * collector disabled, we issue a cbtf_offline_sampling_status paused call.\n     */\n\n#if 0\n    if (CBTF_in_mpi_startup) {\n\tif (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_init_thread IN MPI STARTUP - DEFER SAMPLING\\n\",\n                thePid,monitor_get_thread_num());\n\t}\n\treturn (data);\n    }\n#endif\n\n    tls->collector_started = true;\n    tls->sampling_status = CBTF_Monitor_Started;\n    cbtf_offline_start_sampling(NULL);\n    cbtf_offline_notify_event(CBTF_Monitor_init_thread_event);\n    if ( tls->mpi_pcontrol && !tls->start_enabled) {\n\tif (debug_mpi_pcontrol) {\n            fprintf(stderr,\"[%d,%d] monitor_init_thread CBTF_START_ENABLED NOT SET. Defer sampling at start-up time.\\n\",\n\t\tthePid,monitor_get_thread_num());\n\t}\n\ttls->sampling_status = CBTF_Monitor_Paused;\n\tcbtf_offline_sampling_status(CBTF_Monitor_init_thread_event,CBTF_Monitor_Paused);\n    } else if ( tls->mpi_pcontrol && tls->start_enabled) {\n\tif (debug_mpi_pcontrol) {\n            fprintf(stderr,\"[%d,%d] monitor_init_thread CBTF_START_ENABLED SET. START SAMPLING\\n\",\n                thePid,monitor_get_thread_num());\n\t}\n    } else {\n\tif (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_init_thread START SAMPLING\\n\",\n\t\tthePid,monitor_get_thread_num());\n\t}\n    }\n\n    return(data);\n}\n\nvoid monitor_init_thread_support(void)\n{\n#if 0\n    if ( (getenv(\"CBTF_DEBUG_MONITOR_SERVICE\") != NULL)) {\n\tfprintf(stderr,\"Entered cbtf monitor_init_thread_support callback\\n\");\n    }\n#endif\n}\n\n// these are preventing spawned threads from collecting if the\n// cbtf_offline_sampling_status pause,resume calls are used.\n#if 0\nvoid*\nmonitor_thread_pre_create(void)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n    cbtf_offline_notify_event(CBTF_Monitor_thread_pre_create_event);\n    /* Stop sampling prior to real thread_create. */\n    if (tls->sampling_status != CBTF_Monitor_Paused) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_thread_pre_create PAUSE SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\ttls->sampling_status = CBTF_Monitor_Paused;\n\tcbtf_offline_sampling_status(CBTF_Monitor_thread_pre_create_event,CBTF_Monitor_Paused);\n    } else if (tls->sampling_status == CBTF_Monitor_Paused) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_thread_pre_create ALREADY PAUSED\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n    }\n    return (NULL);\n}\n\nvoid\nmonitor_thread_post_create(void* data)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] Entered cbtf monitor_thread_post_create callback sampling_status:%d\\n\",\n\t\tthePid,monitor_get_thread_num(),tls->sampling_status);\n    }\n\n    if (tls->sampling_status != CBTF_Monitor_Resumed) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_thread_post_create RESUME SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\ttls->sampling_status = CBTF_Monitor_Resumed;\n\tcbtf_offline_sampling_status(CBTF_Monitor_thread_post_create_event,CBTF_Monitor_Resumed);\n    } else if (tls->sampling_status == CBTF_Monitor_Paused) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_thread_pre_create ALREADY RESUMED\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n    }\n}\n#endif // if 0\n\n#endif\n\n#ifdef HAVE_TARGET_DLOPEN\n/*\n * callbacks for handling of DLOPEN/DLCLOSE.\n */\nvoid monitor_dlopen(const char *library, int flags, void *handle)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    // FIXME: sampling_status is an enum.\n    if (tls == NULL || (tls && tls->sampling_status == CBTF_Monitor_Finished) ) {\n\treturn;\n    }\n\n    if (CBTF_in_mpi_startup || tls->in_mpi_pre_init) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_dlopen returns early due to in mpi init\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    if (library == NULL) {\n\tif (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_dlopen ignores null library name\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    /* TODO:\n     * if CBTF_GetDLInfo does not handle errors do so here.\n     */\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_dlopen called with %s\\n\",\n\t    thePid,monitor_get_thread_num(),library);\n    }\n\n    tls->cbtf_dllist_curr = (cbtf_dlinfoList*)calloc(1,sizeof(cbtf_dlinfoList));\n    tls->cbtf_dllist_curr->cbtf_dlinfo_entry.load_time = CBTF_GetTime();\n    tls->cbtf_dllist_curr->cbtf_dlinfo_entry.unload_time = CBTF_GetTime() + 1;\n    tls->cbtf_dllist_curr->cbtf_dlinfo_entry.name = strdup(library);\n    tls->cbtf_dllist_curr->cbtf_dlinfo_entry.handle = handle;\n    tls->cbtf_dllist_curr->cbtf_dlinfo_next = tls->cbtf_dllist_head;\n    tls->cbtf_dllist_head = tls->cbtf_dllist_curr;\n\n    if ((tls->sampling_status == CBTF_Monitor_Paused) && !tls->in_mpi_pre_init) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_dlopen RESUME SAMPLING\\n\",\n\t\tthePid,monitor_get_thread_num());\n        }\n\ttls->sampling_status = CBTF_Monitor_Resumed;\n\tcbtf_offline_sampling_status(CBTF_Monitor_dlopen_event,CBTF_Monitor_Resumed);\n    }\n}\n\nvoid\nmonitor_pre_dlopen(const char *path, int flags)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    // FIXME: sampling_status is an enum.\n    if (tls == NULL || (tls && tls->sampling_status == CBTF_Monitor_Finished) ) {\n\treturn;\n    }\n\n    if (tls->in_mpi_pre_init) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_pre_dlopen returns early due to in mpi init\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    if (path == NULL) {\n\tif (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_pre_dlopen ignores null path\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_pre_dlopen %s\\n\",thePid,monitor_get_thread_num(),path);\n    }\n\n    if ((tls->sampling_status == CBTF_Monitor_Started ||\n\t tls->sampling_status == CBTF_Monitor_Resumed) && !tls->in_mpi_pre_init) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_pre_dlopen PAUSE SAMPLING\\n\",\n\t\tthePid,monitor_get_thread_num());\n        }\n\ttls->sampling_status = CBTF_Monitor_Paused;\n\tcbtf_offline_sampling_status(CBTF_Monitor_pre_dlopen_event,CBTF_Monitor_Paused);\n    }\n}\n\nvoid\nmonitor_dlclose(void *handle)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n\n    // FIXME: sampling_status is an enum.\n    if (tls == NULL || (tls && tls->sampling_status == CBTF_Monitor_Finished) ) {\n\treturn;\n    }\n\n    if (tls->in_mpi_pre_init) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_dlclose returns early due to in mpi init\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    while (tls->cbtf_dllist_curr) {\n\tif (tls->cbtf_dllist_curr->cbtf_dlinfo_entry.handle == handle) {\n\t   tls->cbtf_dllist_curr->cbtf_dlinfo_entry.unload_time = CBTF_GetTime();\n\n            if (IsMonitorDebugEnabled) {\n\t        fprintf(stderr,\"FOUND %p %s\\n\",handle, tls->cbtf_dllist_curr->cbtf_dlinfo_entry.name);\n\t        fprintf(stderr,\"loaded at %ld, unloaded at %ld\\n\",\n\t\t               tls->cbtf_dllist_curr->cbtf_dlinfo_entry.load_time,\n\t\t               tls->cbtf_dllist_curr->cbtf_dlinfo_entry.unload_time);\n\t    }\n\n\t   /* On some systems (NASA) it appears that dlopen can be called\n\t    * before monitor_init_process (or even monitor_early_init).\n\t    * So we need to use getpid() directly here.\n\t    */ \n\n\t   /* FIXME: Handle return value? */\n\t   int retval = CBTF_GetDLInfo(getpid(),\n\t\t\t\t\t tls->cbtf_dllist_curr->cbtf_dlinfo_entry.name,\n\t\t\t\t\t tls->cbtf_dllist_curr->cbtf_dlinfo_entry.load_time,\n\t\t\t\t\t tls->cbtf_dllist_curr->cbtf_dlinfo_entry.unload_time\n\t\t\t\t\t);\n\t   if (retval) {\n\t   }\n\t   break;\n\t}\n\ttls->cbtf_dllist_curr = tls->cbtf_dllist_curr->cbtf_dlinfo_next;\n    }\n\n    if (!tls->thread_is_terminating || !tls->process_is_terminating) {\n\tif ((tls->sampling_status == CBTF_Monitor_Started ||\n\t     tls->sampling_status == CBTF_Monitor_Resumed) && !tls->in_mpi_pre_init) {\n            if (IsMonitorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] monitor_dlclose PAUSE SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n            }\n\t    tls->sampling_status = CBTF_Monitor_Paused;\n\t    cbtf_offline_sampling_status(CBTF_Monitor_dlclose_event,CBTF_Monitor_Paused);\n\t}\n    }\n}\n\nvoid\nmonitor_post_dlclose(void *handle, int ret)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    // FIXME: sampling_status is an enum.\n    if (tls == NULL || (tls && tls->sampling_status == CBTF_Monitor_Finished) ) {\n\treturn;\n    }\n\n    if (tls->in_mpi_pre_init) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_post_dlclose returns early due to in mpi init\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    if (!tls->thread_is_terminating || !tls->process_is_terminating) {\n\tif (tls->sampling_status == CBTF_Monitor_Paused && !tls->in_mpi_pre_init) {\n            if (IsMonitorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] monitor_post_dlclose RESUME SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n            }\n\t    tls->sampling_status = CBTF_Monitor_Resumed;\n\t    cbtf_offline_sampling_status(CBTF_Monitor_post_dlclose_event,CBTF_Monitor_Resumed);\n\t}\n    }\n}\n\n#endif\n\n#ifdef HAVE_TARGET_FORK\n/* \n * callbacks for handling of FORK.\n * NOTE that this callback can return a void pointer if desired.\n */\nvoid * monitor_pre_fork(void)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    /* The sgi MPT mpi startup apparently can fork\n     * a process such that monitor does not go\n     * through its normal path and our tls is not\n     * allocated as we expect.\n     */\n    TLS* tls = CBTF_GetTLS(TLSKey);\n    if (tls == NULL) {\n\ttls = malloc(sizeof(TLS));\n    }\n    Assert(tls != NULL);\n    CBTF_SetTLS(TLSKey, tls);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n\n    if (CBTF_in_mpi_startup || tls->in_mpi_pre_init) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_pre_fork returns early due to in mpi init\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn (NULL);\n    }\n\n    /* Stop sampling prior to real fork. */\n    if (tls->sampling_status == CBTF_Monitor_Paused ||\n\ttls->sampling_status == CBTF_Monitor_Started) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_pre_fork PAUSE SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\ttls->sampling_status = CBTF_Monitor_Paused;\n\tcbtf_offline_sampling_status(CBTF_Monitor_pre_fork_event,CBTF_Monitor_Paused);\n    }\n    return (NULL);\n}\n\nvoid monitor_post_fork(pid_t child, void *data)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    if (CBTF_in_mpi_startup || tls->in_mpi_pre_init) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_post_fork returns early due to in mpi init\\n\",thePid,monitor_get_thread_num());\n\t}\n\treturn;\n    }\n\n    /* Resume/start sampling forked process. */\n    if (tls->sampling_status == CBTF_Monitor_Paused ||\n\ttls->sampling_status == CBTF_Monitor_Finished) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_post_fork RESUME SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\ttls->CBTF_monitor_type = CBTF_Monitor_Proc;\n\ttls->sampling_status = CBTF_Monitor_Resumed;\n\tcbtf_offline_sampling_status(CBTF_Monitor_post_fork_event,CBTF_Monitor_Resumed);\n    }\n}\n#endif\n\n/*\n * callbacks for handling of MPI programs.\n */\n\nvoid monitor_mpi_pre_init(void)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    tls->in_mpi_pre_init = true;\n    CBTF_in_mpi_startup = true;\n    init_mpi_comm_rank = false;\n\n    cbtf_offline_notify_event(CBTF_Monitor_MPI_pre_init_event);\n    if (tls->sampling_status == CBTF_Monitor_Started) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_mpi_pre_init PAUSE SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\ttls->sampling_status = CBTF_Monitor_Paused;\n\tcbtf_offline_sampling_status(CBTF_Monitor_MPI_pre_init_event,CBTF_Monitor_Paused);\n    } else {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_mpi_pre_init IS PAUSED\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n    }\n}\n\nvoid\nmonitor_init_mpi(int *argc, char ***argv)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    bool resume_sampling = false;\n    if (tls->sampling_status == CBTF_Monitor_Paused) {\n\tif (tls->mpi_pcontrol && tls->start_enabled) {\n\t    if (IsMonitorDebugEnabled) {\n\t\tfprintf(stderr,\"[%d,%d] monitor_init_mpi SAMPLING pcontrol start enabled rank:%d\\n\",\n\t\t    thePid,monitor_get_thread_num(), monitor_mpi_comm_rank());\n\t    }\n\t    resume_sampling = true;\n\t} else if(tls->mpi_pcontrol && !tls->start_enabled) {\n\t    if (IsMonitorDebugEnabled) {\n\t\tfprintf(stderr,\"[%d,%d] monitor_init_mpi SAMPLING pcontrol start disabled rank:%d\\n\",\n\t\t    thePid,monitor_get_thread_num(), monitor_mpi_comm_rank());\n\t    }\n\t} else {\n\t    if (IsMonitorDebugEnabled) {\n\t\tfprintf(stderr,\"[%d,%d] monitor_init_mpi SAMPLING enabled rank:%d\\n\",\n\t\t    thePid,monitor_get_thread_num(), monitor_mpi_comm_rank());\n\t    }\n\t    resume_sampling = true;\n\t}\n    }\n\n    cbtf_offline_notify_event(CBTF_Monitor_MPI_init_event);\n    if (resume_sampling) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_init_mpi RESUME SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\ttls->sampling_status = CBTF_Monitor_Resumed;\n\tcbtf_offline_sampling_status(CBTF_Monitor_MPI_init_event,CBTF_Monitor_Resumed);\n    } else {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_init_mpi is SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\t// this is the case where start collection was disabled util at\n\t// the first (if any) mpi_pcontrol(1) is encountered.\n\t// We need to make this available to any code downstream that\n\t// may temporarily disable the collector via cbtf_offline_service_stop_timer\n\t// and later reenable the collector via cbtf_offline_service_start_timer.\n\t// Both of those live in services/collector/collector.c.\n\t// the disable and reenable is used internaly in collector.c to\n\t// protect one CBTF_MRNet_Send of attached threads from being\n\t// sampled. The other use is in the services/collector/monitor.c\n\t// code where we need to disable,reenable for similar reasons.\n\t// Could check tls->sampling_status for this from both\n\t// cbtf_offline_service_stop_timer and cbtf_offline_service_start_timer.\n\t// Provide this as util function that returns this value.\n    }\n\n    tls->in_mpi_pre_init = false;\n    CBTF_in_mpi_startup = false;\n}\n\nvoid monitor_fini_mpi(void)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_fini_mpi CALLED\\n\",\n\t\tthePid,monitor_get_thread_num());\n    }\n\n    cbtf_offline_notify_event(CBTF_Monitor_MPI_fini_event);\n    if (tls->sampling_status == CBTF_Monitor_Started ||\n\ttls->sampling_status == CBTF_Monitor_Resumed) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_fini_mpi PAUSE SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\ttls->sampling_status = CBTF_Monitor_Paused;\n\tcbtf_offline_sampling_status(CBTF_Monitor_MPI_fini_event,CBTF_Monitor_Paused);\n    }\n}\n\nvoid monitor_mpi_post_fini(void)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_mpi_post_fini CALLED\\n\",\n\t\tthePid,monitor_get_thread_num());\n    }\n\n    cbtf_offline_notify_event(CBTF_Monitor_MPI_post_fini_event);\n    // FIXME: remove always true if block?\n    if (1 || tls->sampling_status == CBTF_Monitor_Paused) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_mpi_post_fini RESUME SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\ttls->sampling_status = CBTF_Monitor_Resumed;\n\tcbtf_offline_sampling_status(CBTF_Monitor_MPI_post_fini_event,CBTF_Monitor_Resumed);\n    }\n}\n\n\n// This callback should is only needed during mpi startup and mrnet connection.\n// Once connected, this should just return as early as possible.\n// Since we do not really want mrnet specific info here, we rely on the fact\n// that we only use this callback the first time mpi_comm_rank is called\n// so that the underlying common collector code can aquire the rank which\n// is need for mrnet connections.  Therefore we should never do anything\n// except in the first call.\nvoid monitor_mpi_post_comm_rank(void)\n{\n\n    /* We do not even want to aquire the tls if mpi_comm_rank has\n     * been called already. */\n    if (init_mpi_comm_rank) {\n\treturn;\n    }\n    init_mpi_comm_rank = true;\n\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n\n#ifndef NDEBUG\n    char* statusstr = \"UNKNOWNSTATUS\";\n    if (IsMonitorDebugEnabled) {\n        switch(tls->sampling_status) {\n            case CBTF_Monitor_Resumed:\n                statusstr = \"RESUME\";\n                break;\n            case CBTF_Monitor_Paused:\n                statusstr = \"PAUSE\";\n                break;\n            case CBTF_Monitor_Started:\n                statusstr = \"STARTED\";\n                break;\n            case CBTF_Monitor_Not_Started:\n                statusstr = \"NOTSTARTED\";\n                break;\n            case CBTF_Monitor_Finished:\n                statusstr = \"FINISHED\";\n                break;\n        }\n    }\n#endif\n\n\n#ifndef NDEBUG\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_mpi_post_comm_rank sampling_status:%s\\n\",\n\t\tthePid,monitor_get_thread_num(),statusstr);\n    }\n#endif\n\n    // NOTE: For post_comm_rank, we always need to resume since\n    // that is where mrnet connection is made.  Therefore that\n    // resume should not resume if we are not start enabled.\n    bool resume_sampling = false;\n\n    // FIXME: commented out if test remove?\n    //if (tls->sampling_status == CBTF_Monitor_Paused) {\n\tif (tls->mpi_pcontrol && tls->start_enabled) {\n\t    if (IsMonitorDebugEnabled) {\n\t\tfprintf(stderr,\"[%d,%d] monitor_mpi_post_comm_rank SAMPLING pcontrol start enabled rank:%d\\n\",\n\t\t    thePid,monitor_get_thread_num(), monitor_mpi_comm_rank());\n\t    }\n\t    resume_sampling = true;\n\t    tls->sampling_status = CBTF_Monitor_Resumed;\n\t} else if(tls->mpi_pcontrol && !tls->start_enabled) {\n\t    if (IsMonitorDebugEnabled) {\n\t\tfprintf(stderr,\"[%d,%d] monitor_mpi_post_comm_rank SAMPLING pcontrol start disabled rank:%d\\n\",\n\t\t    thePid,monitor_get_thread_num(), monitor_mpi_comm_rank());\n\t    }\n\t    // FORCE THIS HERE FOR NOW.\n\t    resume_sampling = true;\n\t    // tell collector service that start was deferred\n\t    //cbtf_offline_service_start_deferred();\n\t} else {\n\t    if (IsMonitorDebugEnabled) {\n\t\tfprintf(stderr,\"[%d,%d] monitor_mpi_post_comm_rank SAMPLING enabled rank:%d\\n\",\n\t\t    thePid,monitor_get_thread_num(), monitor_mpi_comm_rank());\n\t    }\n\t    resume_sampling = true;\n\t    tls->sampling_status = CBTF_Monitor_Resumed;\n\t}\n    //}\n\n    if (resume_sampling) {\n        if (IsMonitorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] monitor_mpi_post_comm_rank RESUME SAMPLING\\n\",\n\t\t    thePid,monitor_get_thread_num());\n        }\n\t//tls->sampling_status = CBTF_Monitor_Resumed;\n\tcbtf_offline_sampling_status(CBTF_Monitor_MPI_post_comm_rank_event,CBTF_Monitor_Resumed);\n    }\n}\n\n/* monitor_mpi_pcontrol is reponsible for starting and stopping data\n * collection based on the user coding:\n *\n *     MPI_Pcontrol(0) to disable collection\n *     and\n *     MPI_Pcontrol(1) to reenable data collection\n *\n*/\nvoid monitor_mpi_pcontrol(int level)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n  TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n  TLS* tls = &the_tls;\n#endif\n  Assert(tls != NULL);\n\n  if ( tls->mpi_pcontrol ) {\n\n    if (IsMonitorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] monitor_mpi_pcontrol CALLED level:%d\\n\", thePid,monitor_get_thread_num(),level);\n    }\n\n\n    if (level == 0) {\n\tif ((tls->sampling_status == CBTF_Monitor_Started ||\n   \t    tls->sampling_status == CBTF_Monitor_Resumed) && !tls->in_mpi_pre_init) {\n\n\t   tls->sampling_status = CBTF_Monitor_Paused;\n\t   cbtf_offline_sampling_status(CBTF_Monitor_mpi_pcontrol_event,CBTF_Monitor_Paused);\n\n           if (IsMonitorDebugEnabled) {\n\t       fprintf(stderr,\"monitor_mpi_pcontrol level 0 collector started, PAUSE SAMPLING %d,%d\\n\", thePid,monitor_get_thread_num());\n           }\n\t}\n    } else if (level == 1) {\n\t// this should not happen now.\n\tif (tls->sampling_status == CBTF_Monitor_Not_Started ) {\n\n\t    // should handle mrnet connection for cbtf-mrnet case.\n\t    cbtf_offline_notify_event(CBTF_Monitor_mpi_pcontrol_event);\n\n\t    tls->CBTF_monitor_type = CBTF_Monitor_Proc;\n\t    tls->sampling_status = CBTF_Monitor_Started;\n\t    cbtf_offline_start_sampling(NULL);\n\n\t} else if (tls->sampling_status == CBTF_Monitor_Paused && !tls->in_mpi_pre_init) {\n\n\t    if (IsMonitorDebugEnabled) {\n\t\tfprintf(stderr,\"monitor_mpi_pcontrol level 1 collector started RESUME SAMPLING %d,%d\\n\", thePid,monitor_get_thread_num());\n\t    }\n\t    tls->sampling_status = CBTF_Monitor_Resumed;\n\t    cbtf_offline_sampling_status(CBTF_Monitor_mpi_pcontrol_event,CBTF_Monitor_Resumed);\n\n\t} else  if (tls->sampling_status == CBTF_Monitor_Resumed && !tls->in_mpi_pre_init) {\n\t    if (IsMonitorDebugEnabled) {\n\t\tfprintf(stderr,\"monitor_mpi_pcontrol level 1 collector ALREADY RESUMED %d,%d\\n\", thePid,monitor_get_thread_num());\n\t    }\n\t}\n    } else {\n\tfprintf(stderr,\"monitor_mpi_pcontrol CALLED with unsupported level=%d\\n\", level);\n    }\n  } else {\n      /* early return - do not honor mpi_pcontrol */\n      if (IsMonitorDebugEnabled) {\n  \tfprintf(stderr,\"monitor_mpi_pcontrol ENABLE_MPI_PCONTROL **NOT** SET IGNORING MPI_PCONTROL CALL %d,%d\\n\", thePid,monitor_get_thread_num());\n      }\n      return;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/services/include/KrellInstitute/Services/Offline.h": "/*******************************************************************************\n** Copyright (c) 2010-13 The Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file\n *\n * Declaration of the CBTFW Runtime Offline.\n *\n */\n\n#ifndef _CBTF_Runtime_Offline_\n#define _CBTF_Runtime_Offline_\n\n#include \"KrellInstitute/Messages/OfflineEvents.h\"\n\ntypedef struct cbtf_dlinfo_t cbtf_dlinfo;\ntypedef struct cbtf_dlinfoList_t cbtf_dlinfoList;\n\nstruct cbtf_dlinfo_t {\n    uint64_t load_time;\n    uint64_t unload_time;\n    uint64_t addr_begin;\n    uint64_t addr_end;\n    char *name;\n    void *handle;\n};\n\nstruct cbtf_dlinfoList_t {\n    cbtf_dlinfo cbtf_dlinfo_entry;\n    cbtf_dlinfoList *cbtf_dlinfo_next;\n};\n\n\n/* Size of buffer (dso blob) to hold the dsos loaded into victim addressspace.\n * Computed in collector offline code as:\n * number of dso objects * sizeof dso object + the string lengths of the dso paths.\n * The collectors will send the current dsos buffer (blob) when ever\n * CBTF_OBJBufferSize is exceeded and start a new buffer.\n */\n#define CBTF_OBJBufferSize (8*1024)\n#define CBTF_MAXLINKEDOBJECTS 512\n\nvoid cbtf_offline_start_sampling(const char* arguments);\nvoid cbtf_offline_stop_sampling(const char* arguments, const bool finished);\nvoid cbtf_offline_record_dso(const char* dsoname, uint64_t begin, uint64_t end,\n                        uint8_t is_dlopen);\nvoid cbtf_offline_defer_sampling(const int flag);\nvoid cbtf_offline_sampling_status(CBTF_Monitor_Event_Type event, CBTF_Monitor_Status status);\nvoid cbtf_offline_service_sampling_control(CBTF_Monitor_Status);\nvoid cbtf_offline_notify_event(CBTF_Monitor_Event_Type event);\n\nint CBTF_GetDLInfo(pid_t pid, char *path, uint64_t b_time, uint64_t e_time);\nvoid CBTF_InitializeParameters (CBTF_Protocol_Offline_Parameters *info);\n\n#endif /*_CBTF_Runtime_Offline_*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/services/include/KrellInstitute/Services/Monitor.h": "/*******************************************************************************\n** Copyright (c) 2010-13 The Krell Institue. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file\n *\n * Declaration of Offline Monitor specifc utility functions\n *\n */\n\n#ifndef _CBTF_Runtime_Monitor_\n#define _CBTF_Runtime_Monitor_\n\n#include \"monitor.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\ntypedef enum {\n    CBTF_Monitor_Proc,\n    CBTF_Monitor_Thread,\n    CBTF_Monitor_Default\n} CBTF_Monitor_Type;\n\ntypedef enum {\n    CBTF_Monitor_Started = 1,\n    CBTF_Monitor_Finished,\n    CBTF_Monitor_Paused,\n    CBTF_Monitor_Resumed,\n    CBTF_Monitor_Not_Started\n} CBTF_Monitor_Status;\n\ntypedef enum {\n    CBTF_Monitor_MPI_pre_init_event,\n    CBTF_Monitor_MPI_init_event,\n    CBTF_Monitor_MPI_post_fini_event,\n    CBTF_Monitor_MPI_fini_event,\n    CBTF_Monitor_MPI_post_comm_rank_event,\n    CBTF_Monitor_pre_dlopen_event,\n    CBTF_Monitor_dlopen_event,\n    CBTF_Monitor_dlclose_event,\n    CBTF_Monitor_post_dlclose_event,\n    CBTF_Monitor_init_process_event,\n    CBTF_Monitor_fini_process_event,\n    CBTF_Monitor_init_thread_event,\n    CBTF_Monitor_fini_thread_event,\n    CBTF_Monitor_pre_fork_event,\n    CBTF_Monitor_post_fork_event,\n    CBTF_Monitor_thread_pre_create_event,\n    CBTF_Monitor_thread_post_create_event,\n    CBTF_Monitor_mpi_pcontrol_event,\n    CBTF_Monitor_Default_event\n} CBTF_Monitor_Event_Type;\n\n\n\n#ifdef  __cplusplus\n}\n#endif\n#endif /*_CBTF_Runtime_Monitor_*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/services/collector/monitor.c": "/*******************************************************************************\n** Copyright (c) The Krell Institute 2007-2018. All Rights Reserved.\n** Copyright (c) 2012 Argo Navis Technologies. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file One half of the CBTF collector service API implementation. */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdbool.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"KrellInstitute/Messages/EventHeader.h\"\n#include \"KrellInstitute/Messages/LinkedObjectEvents.h\"\n#include \"KrellInstitute/Messages/OfflineEvents.h\"\n#include \"KrellInstitute/Messages/ToolMessageTags.h\"\n#include \"KrellInstitute/Messages/Thread.h\"\n#include \"KrellInstitute/Messages/ThreadEvents.h\"\n\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Collector.h\"\n#include \"KrellInstitute/Services/Monitor.h\"\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI) || defined(CBTF_SERVICE_USE_MRNET)\n#include \"KrellInstitute/Services/MRNet.h\"\n#endif\n\n#include \"KrellInstitute/Services/Offline.h\"\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n#include \"KrellInstitute/Services/Path.h\"\n#endif\n\n#include \"KrellInstitute/Services/Send.h\"\n#include \"KrellInstitute/Services/Time.h\"\n#include \"KrellInstitute/Services/TLS.h\"\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI) || defined(CBTF_SERVICE_USE_MRNET)\nextern void send_attached_to_threads_message();\n#endif\n\n// forward declarations.\nvoid cbtf_offline_finish();\n\n/** Type defining the items stored in thread-local storage. */\ntypedef struct {\n\n    bool started;\n    int  finished; // is this needed.\n    int  sent_data; // is this needed.\n\n    // marker if ANY collector is connected to mrnet.\n    // this applies to the non mrnet builds.\n\n} TLS;\n\nstatic bool mpi_init_done;\nstatic bool connected_to_mrnet;\n\n/* debug flags */\n#ifndef NDEBUG\nstatic bool IsCollectorDebugEnabled = false;\n#endif\n\n#ifdef USE_EXPLICIT_TLS\n\n/**\n * Thread-local storage key.\n *\n * Key used for looking up our thread-local storage. This key <em>must</em>\n * be globally unique across the entire Open|SpeedShop code base.\n  */\n\nstatic const uint32_t TLSKey = 0x0000FEF3;\n\n#else\n\n/** Thread-local storage. */\nstatic __thread TLS the_tls;\n\n#endif\n\n// non mrnet builds just refurn true here..\nbool cbtf_connected_to_mrnet() {\n#if defined(CBTF_SERVICE_USE_MRNET)\n    /* Access our thread-local storage */\n    return connected_to_mrnet;\n#else\n    return true;\n#endif\n}\n\n// non mrnet builds just refurn true here..\nbool cbtf_mpi_init_done() {\n    /* Access our thread-local storage */\n    return mpi_init_done;\n}\n\nvoid cbtf_set_connected_to_mrnet( bool flag)\n{\n    connected_to_mrnet = flag;\n}\n\n\n/**\n * This is visable to offline (fileio) and cbtf based collection.\n */\nvoid cbtf_offline_sampling_status(CBTF_Monitor_Event_Type event, CBTF_Monitor_Status status)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    //Assert(tls != NULL);\n\n\n#ifndef NDEBUG\n    char* statusstr = \"UNKNOWNSTATUS\";\n    if (IsCollectorDebugEnabled) {\n\tswitch(status) {\n\t    case CBTF_Monitor_Resumed:\n\t\tstatusstr = \"RESUME\";\n\t\tbreak;\n\t    case CBTF_Monitor_Paused:\n\t\tstatusstr = \"PAUSE\";\n\t\tbreak;\n\t    case CBTF_Monitor_Started:\n\t\tstatusstr = \"STARTED\";\n\t\tbreak;\n\t    case CBTF_Monitor_Not_Started:\n\t\tstatusstr = \"NOTSTARTED\";\n\t\tbreak;\n\t    case CBTF_Monitor_Finished:\n\t\tstatusstr = \"FINISHED\";\n\t\tbreak;\n\t}\n    }\n#endif\n\n    if (tls == NULL) {\n#ifndef NDEBUG\n        if (IsCollectorDebugEnabled) {\n\t   fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status NO TLS passed status:%s\\n\",\n\t\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t}\n#endif\n\treturn;\n    }\n\n    switch( event ) {\n\tcase CBTF_Monitor_MPI_pre_init_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_MPI_pre_init_event status:%s\\n\",\n\t\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\t    } else if (status == CBTF_Monitor_Resumed && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n\t    }\n\t    break;\n\tcase CBTF_Monitor_MPI_init_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_MPI_init_event status:%s\\n\",\n\t\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\t    } else if (status == CBTF_Monitor_Resumed && tls->started) {\n\t\tmpi_init_done = true;\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n\t    }\n\t    break;\n\tcase CBTF_Monitor_MPI_post_comm_rank_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\n\t\t\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_MPI_post_comm_rank_event status:%s tls->started:%d\\n\"\n\t\t,getpid(),monitor_get_thread_num(),statusstr,tls->started);\n\t    }\n#endif\n\t    if ( !cbtf_connected_to_mrnet() && ( monitor_mpi_comm_rank() >= 0 || mpi_init_done)) {\n\t        if (tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\t\t}\n#ifndef NDEBUG\n\t\tif (IsCollectorDebugEnabled) {\n\t            fprintf(stderr,\n\t\t    \"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_MPI_post_comm_rank_event calls connect_to_mrnet\\n\",\n\t\t    getpid(),monitor_get_thread_num());\n\t\t}\n#endif\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n\t        bool connect_success = connect_to_mrnet();\n\t\t// The sending of attached threads was previously\n\t\t// defered until mpi job was terminating. For large\n\t\t// mpi jobs it is more efficient to send this message\n\t\t// as soon as mpi init has provided a rank and there\n\t\t// is not as much message traffic over mrnet.\n\t\t// We do not send the dso list (addressspace) until\n\t\t// the job has terminated since that list will be pruned\n\t\t// of dsos for which no sample or callstack addresses\n\t\t// are found.\n\t\tif (connect_success) {\n\t\t    cbtf_set_connected_to_mrnet(true);\n\t\t    send_attached_to_threads_message();\n\t\t} else {\n\t\t    cbtf_set_connected_to_mrnet(false);\n\t\t}\n#endif\n\t\t// FIXME: verify pcontrol...\n\t\t// we really do not want to resume here IFF not start_enabled.\n\t        if (tls->started) {\n\t\t    cbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n\t\t}\n\t    }\n\t    break;\n\tcase CBTF_Monitor_MPI_fini_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_MPI_fini_event status:%s\\n\",\n\t\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\t    } else if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n\t    }\n\t    break;\n\tcase CBTF_Monitor_MPI_post_fini_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr, \"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_MPI_post_fini_event status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\t    } else if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n\t    }\n\t    break;\n\tcase CBTF_Monitor_init_thread_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_init_thread_event status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\t    } else if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n\t    }\n\t    break;\n\tcase CBTF_Monitor_mpi_pcontrol_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_mpi_pcontrol_event status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\t    } else if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n\t    }\n\t    break;\n\tcase CBTF_Monitor_pre_dlopen_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_pre_dlopen_event NOOP status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    break;\n\tcase CBTF_Monitor_dlopen_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_dlopen_event NOOP status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    break;\n\tcase CBTF_Monitor_dlclose_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_dlclose_event NOOP status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    break;\n\tcase CBTF_Monitor_post_dlclose_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_post_dlclose_event NOOP status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    break;\n\tcase CBTF_Monitor_post_fork_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_post_fork_event status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\t    } else if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n\t    }\n\t    break;\n\n// pause and resume from CBTF_Monitor_thread_pre_create_event and\n// CBTF_Monitor_thread_post_create_event callbacks are preventing the\n// created threads from collecting data.\n//\n\tcase CBTF_Monitor_Default_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status CBTF_Monitor_Default_event status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\t    } else if (status == CBTF_Monitor_Paused && tls->started) {\n\t\tcbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n\t    }\n\t    break;\n\tdefault:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_sampling_status passed unknown event status:%s\\n\",\n\t\tgetpid(),monitor_get_thread_num(),statusstr);\n\t    }\n#endif\n\t    break;\n    }\n}\n\nvoid cbtf_offline_sent_data(int sent_data)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    tls->sent_data = sent_data;\n}\n\n/**\n * Start offline sampling.\n *\n * Starts program counter (PC) sampling for the thread executing this function.\n * Writes descriptive information for the thread to the appropriate file and\n * calls pcsamp_start_sampling() with the environment-specified arguments.\n *\n * @param in_arguments    Encoded function arguments. Always null.\n */\nvoid cbtf_offline_start_sampling(const char* in_arguments)\n{\n    /* Create and access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n    if (tls == NULL) {\n\ttls = malloc(sizeof(TLS));\n\tAssert(tls != NULL);\n\tCBTF_SetTLS(TLSKey, tls);\n    }\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n#ifndef NDEBUG\n    IsCollectorDebugEnabled = (getenv(\"CBTF_DEBUG_COLLECTOR\") != NULL);\n#endif\n\n    mpi_init_done = false;\n\n    /* Start sampling */\n    tls->sent_data = 0;\n    tls->finished = false;\n    tls->started = false;\n\n/* SEQUENTIAL cbtf mrnet collection */\n#if defined(CBTF_SERVICE_USE_MRNET) && !defined(CBTF_SERVICE_USE_MRNET_MPI)\n /* FIXME: should query this from collector.c where connection\n * is made.\n */\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_offline_start_sampling BEGINS mrnet collection for sequential program\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n    }\n#endif\n\n/* MPI cbtf mrnet collection */\n#elif defined(CBTF_SERVICE_USE_MRNET) && defined(CBTF_SERVICE_USE_MRNET_MPI)\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_offline_start_sampling BEGINS mrnet collection for MPI program\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n    }\n#endif\n/* OFFLINE collection */\n#else\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_offline_start_sampling BEGINS fileio collection.\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n    }\n#endif\n#endif\n\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_offline_start_sampling calls cbtf_timer_service_start_sampling\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n    }\n#endif\n    cbtf_timer_service_start_sampling(NULL);\n    tls->started = true;\n}\n\n\n\n/**\n * Stop offline sampling.\n *\n * Stops program counter (PC) sampling for the thread executing this function. \n * Calls pcsamp_stop_sampling() and writes descriptive information for the\n * thread to the appropriate file.\n *\n * @param in_arguments    Encoded function arguments. Always null.\n */\nvoid cbtf_offline_stop_sampling(const char* in_arguments, const bool finished)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    if (!tls) {\n#ifndef NDEBUG\n\tif (IsCollectorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] warn: cbtf_offline_stop_sampling has no TLS\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n\t}\n#endif\n\treturn;\n    }\n\n    if (!tls->started) {\n#ifndef NDEBUG\n\tif (IsCollectorDebugEnabled) {\n\t    fprintf(stderr,\"[%d,%d] cbtf_offline_stop_sampling was not started. finished:%d\\n\",\n\t\tgetpid(),monitor_get_thread_num(),finished);\n\t}\n#endif\n\treturn;\n    }\n\n    // fall though to stop sampling...\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_offline_stop_sampling was started. finished:%d\\n\",\n\t\tgetpid(),monitor_get_thread_num(),finished);\n    }\n#endif\n\n    /* Stop sampling */\n    cbtf_timer_service_stop_sampling(NULL);\n\n    // FIXME. is this finished flag needed anymore?\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_offline_stop_sampling finished:%d\\n\",\n                getpid(), monitor_get_thread_num(), finished);\n    }\n#endif\n\n    tls->finished = finished;\n}\n\n/**\n * This is visable to offline (fileio) and cbtf based collection.\n */\nvoid cbtf_offline_notify_event(CBTF_Monitor_Event_Type event)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n    switch( event ) {\n#if 0\n\tcase CBTF_Monitor_MPI_pre_init_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_notify_event passed event CBTF_Monitor_MPI_pre_init_event\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n\t    }\n#endif\n\t    // used to set an mpi flag.\n\t    break;\n#endif\n\tcase CBTF_Monitor_init_process_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_notify_event passed event CBTF_Monitor_init_process_event\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n\t    }\n#endif\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n\t    // We can not connect in the MPI case until after the mpi program\n\t    // has call mpi_comm_rank.\n\t    cbtf_set_connected_to_mrnet(false);\n#endif\n\t    break;\n\n\tcase CBTF_Monitor_init_thread_event:\n\t    // threads share process wide mrnet connection.\n#if defined(CBTF_SERVICE_USE_MRNET) || defined(CBTF_SERVICE_USE_MRNET_MPI)\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_notify_event CBTF_Monitor_init_thread_event mrnet.\\n\",\n\t\t\tgetpid(),monitor_get_thread_num());\n\t    }\n#endif\n\t    if (cbtf_connected_to_mrnet()) {\n\t\t// We are potentially called early in an mpi program and\n\t\t// there is only an mrnet connection AFTER the mpi rank is\n\t\t// set in the master thread.  Therefore the send of thread attached needs to\n\t\t// really check that a connection exists.\n\t\tsend_attached_to_threads_message();\n\t    }\n#else\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_notify_event CBTF_Monitor_init_thread_event non mrnet.\\n\",\n\t\t\tgetpid(),monitor_get_thread_num());\n\t    }\n#endif\n#endif\n\t    break;\n\tcase CBTF_Monitor_mpi_pcontrol_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_notify_event CBTF_Monitor_mpi_pcontrol_event.\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n\t    }\n#endif\n\t    /* We must connect to mrnet if we are using mrnet collection */\n\t    if (!cbtf_connected_to_mrnet()) {\n\t\tif (IsCollectorDebugEnabled) {\n\t\t    fprintf(stderr,\n\t\t\t\"[%d,%d] cbtf_offline_notify_event CBTF_Monitor_mpi_pcontrol_event. level 1 collector not started, connect...\\n\",\n\t\t\tgetpid(),monitor_get_thread_num());\n\t\t}\n\t\t// Moved here from monitor services since it is not\n\t\t// mrnet aware. monitor services is never built for\n\t\t// fileio,mrnet,mrnet-mpi. Just one service for all.\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n\t        bool connect_success = connect_to_mrnet();\n                // The sending of attached threads was previously\n                // defered until mpi job was terminating. For large\n                // mpi jobs it is more efficient to send this message\n                // as soon as mpi init has provided a rank and there\n                // is not as much message traffic over mrnet.\n                // We do not send the dso list (addressspace) until\n                // the job has terminated since that list will be pruned\n                // of dsos for which no sample or callstack addresses\n                // are found.\n\t\tif (connect_success) {\n\t\t    cbtf_set_connected_to_mrnet(true);\n\t\t    send_attached_to_threads_message();\n\t\t} else {\n\t\t    cbtf_set_connected_to_mrnet(false);\n\t\t}\n#endif\n\t    }\n\t    break;\n#if 0\n\tcase CBTF_Monitor_fini_process_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_notify_event CBTF_Monitor_fini_process_event. NOOP\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n\t    }\n#endif\n\t    break;\n\tcase CBTF_Monitor_fini_thread_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_notify_event CBTF_Monitor_fini_thread_event. NOOP\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n\t    }\n#endif\n\t    break;\n#endif\n\tcase CBTF_Monitor_MPI_init_event:\n#ifndef NDEBUG\n\t    if (IsCollectorDebugEnabled) {\n\t        fprintf(stderr,\"[%d,%d] cbtf_offline_notify_event CBTF_Monitor_MPI_init_event sets mpi_init_done true.\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n\t    }\n#endif\n\t    // this is only meaningfull in the master thread for a rank.\n\t    mpi_init_done = true;\n\t    break;\n\tdefault:\n\t    break;\n    }\n}\n\n// this is called for fileio based collection...\n// FIXME: it could be factored out if tls->started is available\n// in collector.c. see collector.c\nvoid cbtf_offline_finish()\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n        fprintf(stderr, \"[%d,%d] cbtf_offline_finish entered. started:%d\\n\",\n\t\tgetpid(),monitor_get_thread_num(),tls->started);\n    }\n#endif\n\n    if (!tls->started) {\n\treturn;\n    }\n\n    cbtf_record_dsos();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/services/collector/collector.c": "/*******************************************************************************\n** Copyright (c) 2005 Silicon Graphics, Inc. All Rights Reserved.\n** Copyright (c) 2007,2008 William Hachfeld. All Rights Reserved.\n** Copyright (c) 2007-2018 Krell Institute.  All Rights Reserved.\n** Copyright (c) 2012 Argo Navis Technologies. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file One half of the CBTF collector service API implementation. */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdbool.h>\n#include <unistd.h>\n#include <sys/types.h>\n\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Collector.h\"\n#include \"KrellInstitute/Services/TLS.h\"\n\n#include \"KrellInstitute/Messages/DataHeader.h\"\n#include \"KrellInstitute/Messages/EventHeader.h\"\n#include \"KrellInstitute/Messages/LinkedObjectEvents.h\"\n#include \"KrellInstitute/Messages/OfflineEvents.h\"\n#include \"KrellInstitute/Messages/ToolMessageTags.h\"\n#include \"KrellInstitute/Messages/Thread.h\"\n#include \"KrellInstitute/Messages/ThreadEvents.h\"\n\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Collector.h\"\n#include \"KrellInstitute/Services/Data.h\"\n#include \"KrellInstitute/Services/Monitor.h\"\n#if defined(CBTF_SERVICE_USE_MRNET)\n#include \"KrellInstitute/Services/MRNet.h\"\n#endif\n#include \"KrellInstitute/Services/Offline.h\"\n#include \"KrellInstitute/Services/Path.h\"\n#if defined(CBTF_SERVICE_USE_FILEIO)\n#include \"KrellInstitute/Services/Fileio.h\"\n#include \"KrellInstitute/Services/Send.h\"\n#endif\n#include \"KrellInstitute/Services/Time.h\"\n#include \"KrellInstitute/Services/TLS.h\"\n#include \"KrellInstitute/Services/Monitor.h\"\n#include \"monitor.h\" // monitor_get_thread_num\n\n/* forward declaration */\nvoid cbtf_reset_header_begin_time();\n\nextern void cbtf_offline_finish();\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n#include <pthread.h>\n/**\n * Checks that the given pthread function call returns the value \"0\". If the\n * call was unsuccessful, the returned error is reported on the standard error\n * stream and the application is aborted.\n *\n * @param x    Pthread function call to be checked.\n **/\n#define PTHREAD_CHECK(x)                                    \\\n    do {                                                    \\\n        int RETVAL = x;                                     \\\n        if (RETVAL != 0)                                    \\\n        {                                                   \\\n            fprintf(stderr, \"[CUDA %d:%d] %s(): %s = %d\\n\", \\\n                    getpid(), monitor_get_thread_num(),     \\\n                    __func__, #x, RETVAL);                  \\\n            fflush(stderr);                                 \\\n            abort();                                        \\\n        }                                                   \\\n    } while (0)\n\n/**\n * The number of threads for which are are collecting data (actively or not).\n * This value is atomically incremented in cbtf_timer_service_start_sampling,\n * decremented in cbtf_timer_service_stop_sampling, and is used by those functions\n * to determine when to call cbtf_waitfor_shutdown.\n */\nstatic struct {\n    int value;\n    pthread_mutex_t mutex;\n} NumThreads = { 0, PTHREAD_MUTEX_INITIALIZER };\n#endif\n\n/**\n * Only the master thread sets the connection that is shared by\n * any and all threads of a process. This is now global.\n */\nbool connected_to_mrnet;\n\n/* debug flags */\n#ifndef NDEBUG\nstatic bool IsCollectorDebugEnabled = false;\nstatic bool IsMRNetDebugEnabled = false;\n#endif\n\n/** Type defining the items stored in thread-local storage. */\ntypedef struct {\n\n    CBTF_DataHeader header;  /**< Header for data blobs. */\n    CBTF_EventHeader dso_header;   /**< Header for following dso blob. */\n    CBTF_Monitor_Status sampling_status;\n\n    uint64_t time_started;\n    int  dsoname_len;\n    int  sent_data;\n\n    // marker if ANY collector is connected to mrnet.\n    // this applies to the non mrnet builds.\n\n    bool ompt_thread_finished;\n    bool has_ompt;\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n\n    /** These are only valid with mrnet based collection. */\n    CBTF_Protocol_ThreadNameGroup tgrp;\n    CBTF_Protocol_ThreadName tname;\n    CBTF_Protocol_AttachedToThreads attached_to_threads_message;\n    CBTF_Protocol_ThreadsStateChanged thread_state_changed_message;\n\n    bool sent_attached_to_threads;\n\n    struct {\n        CBTF_Protocol_ThreadName tnames[4096];\n    } tgrpbuf;\n\n#endif\n\n// TODO:  Adjust the OfflineExperiment class in OSS to use the\n// same linkedobject code as the mrnet cbtf code.\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_Protocol_Offline_LinkedObjectGroup data; /**< Actual dso data blob. */\n\n    struct {\n\tCBTF_Protocol_Offline_LinkedObject objs[CBTF_MAXLINKEDOBJECTS];\n    } buffer;\n#else\n    CBTF_Protocol_LinkedObjectGroup data; /**< Actual dso data blob. */\n\n    struct {\n\tCBTF_Protocol_LinkedObject objs[CBTF_MAXLINKEDOBJECTS];\n    } buffer;\n#endif\n\n} TLS;\n\n#ifdef USE_EXPLICIT_TLS\n\n/**\n * Thread-local storage key.\n *\n * Key used for looking up our thread-local storage. This key <em>must</em>\n * be globally unique across the entire Open|SpeedShop code base.\n */\nstatic const uint32_t TLSKey = 0x0000EEF3;\n\n#else\n\n/** Thread-local storage. */\nstatic __thread TLS the_tls;\n\n#endif\n\n#if defined (CBTF_SERVICE_USE_OFFLINE)\n\nchar* statusTostring (CBTF_Monitor_Status status)\n{\n    char* statusstr = \"UNKNOWNSTATUS\";\n        switch(status) {\n            case CBTF_Monitor_Resumed:\n                statusstr = \"RESUME\";\n                break;\n            case CBTF_Monitor_Paused:\n                statusstr = \"PAUSE\";\n                break;\n            case CBTF_Monitor_Started:\n                statusstr = \"STARTED\";\n                break;\n            case CBTF_Monitor_Not_Started:\n                statusstr = \"NOTSTARTED\";\n                break;\n            case CBTF_Monitor_Finished:\n                statusstr = \"FINISHED\";\n                break;\n        }\n    return statusstr;\n}\n\nvoid cbtf_offline_service_sampling_control(CBTF_Monitor_Status current_status)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    if (tls == NULL)\n\treturn;\n\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n\t//char* statusstr = current_status == CBTF_Monitor_Resumed ? \"RESUME\" : \"PAUSE\";\n        fprintf(stderr,\"[%d,%d] cbtf_offline_service_sampling_control passed_status:%s previous_status:%s\\n\",\n\t\t     getpid(),monitor_get_thread_num(),\n\t\t     statusTostring(current_status),statusTostring(tls->sampling_status));\n    }\n#endif\n\n    if (current_status == CBTF_Monitor_Resumed && tls->sampling_status != CBTF_Monitor_Resumed) {\n\tcbtf_collector_resume();\n    } else if (current_status == CBTF_Monitor_Paused && tls->sampling_status != CBTF_Monitor_Paused) {\n\tcbtf_collector_pause();\n    } else {\n    }\n    tls->sampling_status = current_status;\n}\n\n#endif // defined CBTF_SERVICE_USE_OFFLINE\n\n\n\n/** init_process_thread only valid with mrnet based collection. */\nvoid init_process_thread()\n{\n#if defined(CBTF_SERVICE_USE_MRNET)\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    if (tls == NULL)\n\treturn;\n\n    tls->tname.rank = monitor_mpi_comm_rank();\n    tls->header.rank = monitor_mpi_comm_rank();\n    tls->header.omp_tid = monitor_get_thread_num();\n    tls->tname.omp_tid = monitor_get_thread_num();\n\n    tls->tgrp.names.names_len = 0;\n    tls->tgrp.names.names_val = tls->tgrpbuf.tnames;\n    memset(tls->tgrpbuf.tnames, 0, sizeof(tls->tgrpbuf.tnames));\n\n    memcpy(&(tls->tgrpbuf.tnames[tls->tgrp.names.names_len]),\n           &tls->tname, sizeof(tls->tname));\n    tls->tgrp.names.names_len++;\n\n    tls->attached_to_threads_message.threads = tls->tgrp;\n#ifndef NDEBUG\n        if (IsMRNetDebugEnabled) {\n\t    fprintf(stderr,\n\t    \"[%d,%d] init_process_thread [%d] INIT THREAD OR PROCESS %s:%lld:%lld:%d:%d\\n\",\n\t\t     getpid(),monitor_get_thread_num(),\n\t\t     tls->tgrp.names.names_len,\n                     tls->header.host, (long long)tls->header.pid,\n                     (long long)tls->header.posix_tid,\n\t\t     tls->header.rank,\n\t\t     tls->header.omp_tid\n\t    );\n        }\n#endif\n#endif\n}\n\n/** send_attached_to_threads_message only valid with mrnet based collection. */\nvoid send_attached_to_threads_message()\n{\n#if defined(CBTF_SERVICE_USE_MRNET)\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    if (tls == NULL)\n\treturn;\n\n    if (connected_to_mrnet && ! tls->sent_attached_to_threads) {\n\tinit_process_thread();\n#ifndef NDEBUG\n        if (IsMRNetDebugEnabled) {\n    \t     fprintf(stderr,\n\t   \"[%d,%d] SEND CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS, for %s:%lld:%lld:%d:%d\\n\",\n\t\t     getpid(),monitor_get_thread_num(),\n                     tls->header.host, (long long)tls->header.pid,\n                     (long long)tls->header.posix_tid,\n\t\t     tls->header.rank,\n\t\t     tls->header.omp_tid\n\t    );\n        }\n#endif\n\t// disable collector while doing internal work\n\t// Due to mpi_pcontrol we already may be stopped.\n\t// No harm to issue this again\n\tcbtf_offline_service_sampling_control(CBTF_Monitor_Paused);\n\tCBTF_MRNet_Send( CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS,\n\t\t\t(xdrproc_t) xdr_CBTF_Protocol_AttachedToThreads,\n\t\t\t&tls->attached_to_threads_message);\n\ttls->sent_attached_to_threads = true;\n\t// reenable collector\n\t// Due to mpi_pcontrol we already may already be stopped\n\t// due to the env var CBTF_START_ENABLE and need to check the \n\t// the value set by the monitor service code.\n\tcbtf_offline_service_sampling_control(CBTF_Monitor_Resumed);\n    }\n#endif\n}\n\n/** connect_to_mrnet only valid with mrnet based collection.\n *  Since the master thread is the only connection to mrnet and\n *  and subsequent threads share that connection we use a global\n *  to maintain connection status.\n */\nbool connect_to_mrnet()\n{\n#if defined(CBTF_SERVICE_USE_MRNET)\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    if (tls == NULL) {\n\tfprintf(stderr,\"[%d,%d] Entered connect_to_mrnet with NO TLS! returning...\\n\",getpid(),monitor_get_thread_num());\n\treturn false;\n    }\n\n    if (connected_to_mrnet) {\n#ifndef NDEBUG\n    if (IsMRNetDebugEnabled) {\n        fprintf(stderr,\"[%d,%d] ALREADY connected  connect_to_mrnet\\n\",getpid(),monitor_get_thread_num());\n    }\n#endif\n\treturn true;\n    }\n\n#ifndef NDEBUG\n    if (IsMRNetDebugEnabled) {\n\t fprintf(stderr,\"[%d,%d] connect_to_mrnet() calling CBTF_MRNet_LW_connect for rank %d\\n\",\n\tgetpid(),monitor_get_thread_num(),monitor_mpi_comm_rank());\n    }\n#endif\n\n    // FIXME: CBTF_MRNet_LW_connect really should return a bool connect status\n    // and connected_to_mrnet should be set based on that.\n    CBTF_MRNet_LW_connect( monitor_mpi_comm_rank() );\n    tls->header.rank = monitor_mpi_comm_rank();\n    tls->header.omp_tid = monitor_get_thread_num();\n    connected_to_mrnet = true;\n\n#ifndef NDEBUG\n    if (IsMRNetDebugEnabled) {\n\t fprintf(stderr,\n        \"connect_to_mrnet reports connection successful for %s:%ld:%ld:%d:%d\\n\",\n             tls->header.host, tls->header.pid,tls->header.posix_tid,tls->header.rank,tls->header.omp_tid);\n    }\n#endif\n    cbtf_reset_header_begin_time();\n    return true;\n#endif\n    return true;\n}\n\nvoid cbtf_collector_set_openmp_threadid(int32_t omptid)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    if (tls == NULL)\n\treturn;\n\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n    /* mrnet collectors send a threadname message that requires\n     * it's own omp identifier.\n    */\n    tls->tname.omp_tid = omptid;\n#endif\n    tls->header.omp_tid = omptid;\n    tls->has_ompt = true;\n    tls->ompt_thread_finished = false;\n}\n\nint32_t cbtf_collector_get_openmp_threadid()\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    if (tls == NULL)\n\treturn -1;\n\n    // valid openmp thread id is 0 or greater...\n    if (tls->header.omp_tid >= 0)\n\treturn tls->header.omp_tid;\n    else\n\treturn -1;\n}\n\nvoid set_ompt_flag(bool flag)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    if (tls == NULL)\n\treturn;\n\n    tls->has_ompt = flag;\n}\n\nbool get_ompt_flag()\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    if (tls == NULL)\n\treturn false;\n\n    return tls->has_ompt;\n}\n\nvoid set_ompt_thread_finished(bool flag)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    if (tls == NULL)\n\treturn;\n\n    tls->ompt_thread_finished = flag;\n}\n\n// noop for non mrnet collection.\n/** send_thread_state_changed_message only valid with mrnet based collection. */\nvoid send_thread_state_changed_message()\n{\n#if defined(CBTF_SERVICE_USE_MRNET)\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    if (tls == NULL) {\n#ifndef NDEBUG\n        fprintf(stderr,\"[%d,%d] EARLY EXIT send_thread_state_changed_message NO TLS for rank %d\\n\",\n\t\tgetpid(),monitor_get_thread_num(),monitor_mpi_comm_rank());\n#endif\n\treturn;\n    }\n\n    //CBTF_Protocol_ThreadsStateChanged message;\n    tls->thread_state_changed_message.threads = tls->tgrp;\n    tls->thread_state_changed_message.state = Terminated; \n    if (connected_to_mrnet) {\n#ifndef NDEBUG\n\tif (IsMRNetDebugEnabled) {\n            fprintf(stderr,\n\t    \"[%d,%d] SEND CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED for %s:%lld:%lld:%d:%d\\n\",\n\t\t     getpid(),monitor_get_thread_num(),\n                     tls->header.host, (long long)tls->header.pid,\n                     (long long)tls->header.posix_tid,\n\t\t     tls->header.rank,\n\t\t     tls->header.omp_tid\n\t\t);\n\t}\n#endif\n\tCBTF_MRNet_Send( CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED,\n                  (xdrproc_t) xdr_CBTF_Protocol_ThreadsStateChanged,\n\t\t  &tls->thread_state_changed_message);\n    }\n#endif\n}\n\nvoid cbtf_collector_send(const CBTF_DataHeader* header,\n                         const xdrproc_t xdrproc, const void* data)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    Assert(tls != NULL);\n\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n        fprintf(stderr,\"[%d,%d] cbtf_collector_send DATA for %s:%lld:%lld:%d:%d\\n\",\n\t\tgetpid(),monitor_get_thread_num(),\n                tls->header.host, (long long)tls->header.pid,\n                (long long)tls->header.posix_tid, tls->header.rank,\n\t\ttls->header.omp_tid);\n        fprintf(stderr,\"[%d,%d] time_range[%lu, %lu) addr range [%#lx, %#lx]\\n\",\n\t    getpid(),monitor_get_thread_num(),\n            (uint64_t)header->time_begin, (uint64_t)header->time_end,\n\t    header->addr_begin, header->addr_end);\n    }\n#endif\n\n/** The data send routines for performance data are specific to\n *  the data collection method.  Only one will be defined at build time.\n */\n/** Data send support for --offline (fileio) mode of collection. */\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_Data_Send(header, xdrproc, data);\n#endif\n\n/** Data send support for ltwt mrnet mode of collection. */\n#if defined(CBTF_SERVICE_USE_MRNET)\n\tif (connected_to_mrnet) {\n\t    if (!tls->sent_attached_to_threads) {\n\t        send_attached_to_threads_message();\n\t        tls->sent_attached_to_threads = true;\n\t    }\n\n\t    CBTF_MRNet_Send_PerfData(header, xdrproc, data);\n\t} else {\n#ifndef NDEBUG\n\t    /** There are cases where a collector (eg. mem) can\n             *  collect data from the mrnet connection code itself.\n             *  We are not interested in such data.\n             */\n\t    if (IsMRNetDebugEnabled) {\n\t\tfprintf(stderr,\"[%d,%d] cbtf_collector_send called with no mrnet connection!\\n\"\n\t\t,getpid(),monitor_get_thread_num());\n\t    }\n#endif\n\t}\n#endif\n\n#if defined(CBTF_SERVICE_USE_OFFLINE)\n    cbtf_offline_sent_data(1);\n#endif\n}\n\n\n\n/**\n * Start collection.\n *\n * Starts collection for the thread executing this function.\n * Initializes the appropriate thread-local data structures and then enables the\n * sampling timer.\n *\n * @param arguments    Encoded function arguments.\n */\nvoid cbtf_timer_service_start_sampling(const char* arguments)\n{\n    /* Create and access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = malloc(sizeof(TLS));\n    Assert(tls != NULL);\n    CBTF_SetTLS(TLSKey, tls);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    /* All collectors start with collection enabled.  For mpi programs\n     * this flag can be changed to reflect mpi_pcontrol calls and the\n     * related mpi_pcontrol environment variables.\n     */\n    tls->sampling_status=CBTF_Monitor_Not_Started;\n\n#ifndef NDEBUG\n    IsCollectorDebugEnabled = (getenv(\"CBTF_DEBUG_COLLECTOR\") != NULL);\n    IsMRNetDebugEnabled = (getenv(\"CBTF_DEBUG_LW_MRNET\") != NULL);\n#endif\n\n    /* \n     * Initialize the data blob's header\n     *\n     * Passing &tls->header to CBTF_InitializeDataHeader() was found\n     * to not be safe on IA64 systems. Hopefully the extra copy can be\n     * removed eventually.\n     */\n    \n    CBTF_DataHeader local_data_header;\n    CBTF_InitializeDataHeader(0 /* Experiment */, 1 /* Collector */,\n\t\t\t\t&local_data_header);\n    memcpy(&tls->header, &local_data_header, sizeof(CBTF_DataHeader));\n\n    tls->header.id = strdup(cbtf_collector_unique_id);\n\n    // init DSOS data\n    tls->data.linkedobjects.linkedobjects_len = 0;\n    tls->data.linkedobjects.linkedobjects_val = tls->buffer.objs;\n    tls->dsoname_len = 0;\n    memset(tls->buffer.objs, 0, sizeof(tls->buffer.objs));\n\n#if defined (CBTF_SERVICE_USE_MRNET)\n    PTHREAD_CHECK(pthread_mutex_lock(&NumThreads.mutex));\n    NumThreads.value++;\n#ifndef NDEBUG\n    if (IsMRNetDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_timer_service_start_sampling NumThreads:%d\\n\",getpid(),monitor_get_thread_num(),NumThreads.value);\n    }\n#endif\n    PTHREAD_CHECK(pthread_mutex_unlock(&NumThreads.mutex));\n\n    tls->tname.experiment = 0;\n    tls->tname.host = strdup(local_data_header.host);\n    tls->tname.pid = local_data_header.pid;\n    tls->tname.has_posix_tid = true;\n    tls->tname.posix_tid = local_data_header.posix_tid;\n    tls->tname.rank = local_data_header.rank;\n    tls->tname.omp_tid = monitor_get_thread_num();\n\n    tls->tgrp.names.names_len = 0;\n    tls->tgrp.names.names_val = tls->tgrpbuf.tnames;\n    memset(tls->tgrpbuf.tnames, 0, sizeof(tls->tgrpbuf.tnames));\n\n    memcpy(&(tls->tgrpbuf.tnames[tls->tgrp.names.names_len]),\n           &tls->tname, sizeof(tls->tname));\n    tls->tgrp.names.names_len++;\n\n    tls->sent_attached_to_threads = false;\n\n#if !defined (CBTF_SERVICE_USE_MRNET_MPI)\n    // Non-mpi sequential applications connect here in cbtf mode.\n    // Only the master thread makes mrnet connection.\n    if (NumThreads.value == 1) {\n#ifndef NDEBUG\n\tif (IsMRNetDebugEnabled) {\n\t    fprintf(stderr,\n\t\t\"[%d,%d] cbtf_timer_service_start_sampling calls connect_to_mrnet for sequential program\\n\",\n\t\tgetpid(),monitor_get_thread_num());\n\t}\n#endif\n        connected_to_mrnet = false;\n\tconnected_to_mrnet = connect_to_mrnet();\n    }\n\n    if (connected_to_mrnet) {\n#ifndef NDEBUG\n\tif (IsMRNetDebugEnabled) {\n\t    fprintf(stderr,\n\t\t\"[%d,%d] cbtf_timer_service_start_sampling sequential program connected_to_mrnet:%d\\n\",\n\t\tgetpid(),monitor_get_thread_num(),connected_to_mrnet);\n\t}\n#endif\n\tcbtf_set_connected_to_mrnet(true); /* inform monitor callbacks */\n\tif (!tls->sent_attached_to_threads) {\n\t    send_attached_to_threads_message();\n\t    tls->sent_attached_to_threads = true;\n\t}\n    }\n#endif\n\n#endif // defined CBTF_SERVICE_USE_MRNET\n\n    tls->header.posix_tid = local_data_header.posix_tid;\n    tls->header.rank = local_data_header.rank;\n    tls->header.omp_tid = monitor_get_thread_num();\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n/* NOTE: this happens at process startup. mpi rank is not set yet\n * so the header info for mpi rank is incorrect in this header.\n * For FILEIO this must happen here since it uses async unsafe calls\n * like malloc.\n */\n    CBTF_SetSendToFile(&(tls->header), cbtf_collector_unique_id, \"openss-data\");\n#endif\n\n#ifndef NDEBUG\n    if (IsMRNetDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_timer_service_start_sampling calls cbtf_collector_start.\\n\",getpid(),monitor_get_thread_num());\n    }\n#endif\n    /* Begin collection */\n    tls->sampling_status = CBTF_Monitor_Started;\n    cbtf_collector_start(&tls->header);\n}\n\n\n\n/**\n * Stop collection.\n *\n * Stops collection for the thread executing this function.\n *\n * @param arguments    Encoded (unused) function arguments.\n */\nvoid cbtf_timer_service_stop_sampling(const char* arguments)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    /* used to Assert(tls != NULL); */\n    if (tls == NULL) {\n\treturn;\n    }\n\n    if (tls->has_ompt && !tls->ompt_thread_finished) {\n#ifndef NDEBUG\n\tif (IsMRNetDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_timer_service_stop_sampling returns ACTIVE OMP THREAD. has_ompt:%d ompt_thread_finished:%d\\n\"\n\t\t,getpid(),monitor_get_thread_num(),tls->has_ompt,tls->ompt_thread_finished);\n\t}\n#endif\n\treturn;\n    } else {\n#ifndef NDEBUG\n\tif (IsMRNetDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_timer_service_stop_sampling calls cbtf_collector_stop. has_ompt:%d ompt_thread_finished:%d\\n\"\n\t\t,getpid(),monitor_get_thread_num(),tls->has_ompt,tls->ompt_thread_finished);\n\t}\n#endif\n\n    }\n\n    /* Stop collection */\n    cbtf_collector_stop();\n    tls->sampling_status = CBTF_Monitor_Finished;\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    cbtf_offline_finish();\n#else\n\n    if (tls->sent_attached_to_threads) {\n    // FIXME: Only record these if we sent data!\n    cbtf_record_dsos();\n    // FIXME: Only send this if we sent data and sent attached message!\n    // send thread_state message ONLY after recording dsos\n    send_thread_state_changed_message();\n    }\n\n    PTHREAD_CHECK(pthread_mutex_lock(&NumThreads.mutex));\n    NumThreads.value--;\n#ifndef NDEBUG\n    if (IsMRNetDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_timer_service_stop_sampling NumThreads:%d\\n\",getpid(),monitor_get_thread_num(),NumThreads.value);\n    }\n#endif\n\n    if (NumThreads.value == 0) {\n\tCBTF_Waitfor_MRNet_Shutdown();\n    }\n    PTHREAD_CHECK(pthread_mutex_unlock(&NumThreads.mutex));\n#endif\n\n    /* Destroy our thread-local storage */\n#ifdef CBTF_SERVICE_USE_EXPLICIT_TLS\n    free(tls);\n    CBTF_SetTLS(TLSKey, NULL);\n#endif\n}\n\n/**\n * When running with the cbtf intrumentation we incur overhead\n * from the mrnet connection time.  Since our data headers are\n * created when monitor_init_process first calls our collector\n * we therefore have this overhead in the performance data span.\n * To eliminate this overhead we need to reset our data header\n * time_begin to the time right after the mrnet connection completes.\n * For mpi programs this is actually just after the mpi rank is\n * set for the process.  This does not affect threads with in a\n * process since they share the process wide mrnet connection.\n */\nvoid cbtf_reset_header_begin_time()\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    Assert(tls != NULL);\n    tls->header.time_begin = CBTF_GetTime();\n}\n\n// DSOS\n\nvoid cbtf_offline_send_dsos(TLS *tls)\n{\n    /* Send the offline \"dsos\" blob or message */\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n        fprintf(stderr,\n\t\t\"[%d,%d] cbtf_offline_send_dsos SENDS DSOS for %s:%lld:%lld:%d:%d\\n\",\n\t\tgetpid(),monitor_get_thread_num(),\n                tls->dso_header.host, (long long)tls->dso_header.pid, \n                (long long)tls->dso_header.posix_tid, tls->dso_header.rank,tls->dso_header.omp_tid);\n    }\n#endif\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_Event_Send(&(tls->dso_header),\n\t\t(xdrproc_t)xdr_CBTF_Protocol_Offline_LinkedObjectGroup,\n\t\t&(tls->data));\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    tls->data.thread = tls->tname;\n    if (connected_to_mrnet) {\n        CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP,\n                  (xdrproc_t) xdr_CBTF_Protocol_LinkedObjectGroup,&(tls->data));\n    }\n#elif defined(CBTF_SERVICE_USE_MRNET)\n    tls->data.thread = tls->tname;\n    if (connected_to_mrnet) {\n        CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP,\n                  (xdrproc_t) xdr_CBTF_Protocol_LinkedObjectGroup,&(tls->data));\n    }\n#endif\n\n    tls->data.linkedobjects.linkedobjects_len = 0;\n    tls->data.linkedobjects.linkedobjects_val = tls->buffer.objs;\n    tls->dsoname_len = 0;\n    memset(tls->buffer.objs, 0, sizeof(tls->buffer.objs));\n}\n\nvoid cbtf_record_dsos()\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    /* If this thread did not record performance data then\n     * there is no need to find dsos\n     */\n    if (!tls->sent_data) {\n\t//return;\n    }\n#endif\n\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n        fprintf(stderr, \"[%d,%d] cbtf_record_dsos entered.\\n\",getpid(),monitor_get_thread_num());\n    }\n#endif\n\n    /* Initialize header */\n    CBTF_EventHeader local_header;\n    CBTF_InitializeEventHeader(&local_header);\n    local_header.rank = monitor_mpi_comm_rank();\n    local_header.omp_tid = monitor_get_thread_num();\n\n    /* Write the thread's initial address space to the appropriate buffer */\n#ifndef NDEBUG\n    if (IsCollectorDebugEnabled) {\n\tfprintf(stderr,\"[%d,%d] cbtf_record_dsos calls GETDLINFO for %s:%lld:%lld:%d:%d\\n\",\n\t\tgetpid(),monitor_get_thread_num(),\n\t\tlocal_header.host, (long long)local_header.pid,\n\t\t(long long)local_header.posix_tid, local_header.rank, local_header.omp_tid);\n    }\n#endif\n    CBTF_GetDLInfo(getpid(), NULL, 0, 0);\n\n    if(tls->data.linkedobjects.linkedobjects_len > 0) {\n#ifndef NDEBUG\n\tif (IsCollectorDebugEnabled) {\n           fprintf(stderr,\n            \"[%d,%d] cbtf_record_dsos HAS %d OBJS for %s:%lld:%lld:%d:%d\\n\",\n\t\tgetpid(),monitor_get_thread_num(),\n\t\t   tls->data.linkedobjects.linkedobjects_len,\n                   local_header.host, (long long)local_header.pid, \n                   (long long)local_header.posix_tid, local_header.rank, local_header.omp_tid);\n\t}\n#endif\n\tcbtf_offline_send_dsos(tls);\n    }\n}\n\n\n/**\n * Record a DSO operation.\n *\n * Writes information regarding a DSO being loaded or unloaded in the thread\n * to the appropriate file.\n *\n * @param dsoname      Name of the DSO's file.\n * @param begin        Beginning address at which this DSO was loaded.\n * @param end          Ending address at which this DSO was loaded.\n * @param is_dlopen    Boolean \"true\" if this DSO was just opened,\n *                     or \"false\" if it was just closed.\n */\nvoid cbtf_offline_record_dso(const char* dsoname,\n\t\t\tuint64_t begin, uint64_t end,\n\t\t\tuint8_t is_dlopen)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n\n    if (is_dlopen) {\n\t//cbtf_offline_pause_sampling(CBTF_Monitor_Default_event);\n    }\n\n    //fprintf(stderr,\"cbtf_offline_record_dso called for %s, is_dlopen = %d\\n\",dsoname, is_dlopen);\n\n    /* Initialize the offline \"dso\" blob's header */\n    CBTF_EventHeader local_header;\n    CBTF_InitializeEventHeader(&local_header);\n    local_header.rank = monitor_mpi_comm_rank();\n    local_header.omp_tid = monitor_get_thread_num();\n    memcpy(&tls->dso_header, &local_header, sizeof(CBTF_EventHeader));\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_Protocol_Offline_LinkedObject objects;\n\n    if (is_dlopen) {\n\tobjects.time_begin = CBTF_GetTime();\n    } else {\n\tobjects.time_begin = tls->time_started;\n    }\n    objects.time_end = is_dlopen ? -1ULL : CBTF_GetTime();\n    \n\n    /* Initialize the offline \"dso\" blob */\n    objects.objname = strdup(dsoname);\n    objects.addr_begin = begin;\n    objects.addr_end = end;\n    objects.is_open = is_dlopen;\n    if (strcmp(CBTF_GetExecutablePath(),dsoname)) {\n\tobjects.is_executable = false;\n    } else {\n\tobjects.is_executable = true;\n    }\n\n#else\n    /* Initialize the \"dso\" message */\n    /* this is only for the initial dsos loaded into thread\n     * and not intended for dlopen/dlclose callbacks\n     */ \n    CBTF_Protocol_LinkedObject objects;\n\n    if (is_dlopen) {\n\tobjects.time_begin = CBTF_GetTime();\n    } else {\n\tobjects.time_begin = tls->time_started;\n    }\n    objects.time_end = is_dlopen ? -1ULL : CBTF_GetTime();\n\n    CBTF_Protocol_FileName dsoFilename;\n    dsoFilename.path = strdup(dsoname);\n    objects.linked_object = dsoFilename;\n\n    objects.range.begin = begin;\n    objects.range.end = end;\n\n    if (strcmp(CBTF_GetExecutablePath(),dsoname)) {\n\tobjects.is_executable = false;\n    } else {\n\tobjects.is_executable = true;\n    }\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n    /*\n     * intended ONLY for dlopen/dlclose callbacks\n     */\n    CBTF_Protocol_ThreadName tname;\n    tname.experiment = 0;\n    tname.host = strdup(local_header.host);\n    tname.pid = local_header.pid;\n    tname.has_posix_tid = true;\n    tname.posix_tid = local_header.posix_tid;\n    tname.rank = monitor_mpi_comm_rank();\n    tname.omp_tid = monitor_get_thread_num();\n    memcpy(&(tls->tname), &tname, sizeof(tname));\n\n    tls->tgrp.names.names_len = 0;\n    tls->tgrp.names.names_val = tls->tgrpbuf.tnames;\n    memset(tls->tgrpbuf.tnames, 0, sizeof(tls->tgrpbuf.tnames));\n\n    memcpy(&(tls->tgrpbuf.tnames[tls->tgrp.names.names_len]),\n           &tname, sizeof(tname));\n    tls->tgrp.names.names_len++;\n\n\n    /*\n     * intended ONLY for dlopen/dlclose callbacks\n     * Message tag: CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT\n     * xdr_CBTF_Protocol_LoadedLinkedObject\n     */\n    CBTF_Protocol_LoadedLinkedObject message;\n    memset(&message, 0, sizeof(message));\n\n    message.threads = tls->tgrp;\n    message.time = objects.time_begin;\n    message.range.begin =  begin;\n    message.range.end = end;\n    message.linked_object = dsoFilename;\n\n    if (strcmp(CBTF_GetExecutablePath(),dsoname)) {\n\tmessage.is_executable = false;\n    } else {\n\tmessage.is_executable = true;\n    }\n\n\n//FIXME: verify that mrnet collections works for dlopen/dlclose.\n#if 0\n#if defined(CBTF_SERVICE_USE_MRNET)\n#ifndef NDEBUG\n    if (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n            fprintf(stderr,\n\t\t\"cbtf_offline_record_dso SENDS CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT for dso %s from %s %lld %lld\\n\",\n                    dsoFilename.path, tls->dso_header.host,\n                    (long long)tls->dso_header.pid,\n                    (long long)tls->dso_header.posix_tid);\n    }\n#endif\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    if (connected_to_mrnet) {\n        CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT,\n                  (xdrproc_t) xdr_CBTF_Protocol_LoadedLinkedObject, &message);\n    }\n#else\n    CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT,\n                  (xdrproc_t) xdr_CBTF_Protocol_LoadedLinkedObject, &message);\n#endif\n#endif\n#endif\n\n    int dsoname_len = strlen(dsoname);\n    int newsize = (tls->data.linkedobjects.linkedobjects_len * sizeof(objects))\n\t\t  + (tls->dsoname_len + dsoname_len);\n\n    if(newsize > CBTF_MAXLINKEDOBJECTS * sizeof(objects)) {\n#ifndef NDEBUG\n\tif (IsCollectorDebugEnabled) {\n            fprintf(stderr,\"[%d,%d] cbtf_offline_record_dso SENDS OBJS for %s:%lld:%lld:%d:%d\\n\",\n\t\t    getpid(),monitor_get_thread_num(),\n                    tls->dso_header.host, (long long)tls->dso_header.pid, \n                    (long long)tls->dso_header.posix_tid,\n\t\t    tls->dso_header.rank,\n                    tls->dso_header.omp_tid);\n\t}\n#endif\n\tcbtf_offline_send_dsos(tls);\n    }\n\n\n// DEBUG.\n#if defined(CBTF_SERVICE_USE_MRNET) && 0\n    fprintf(stderr,\"RECORD OBJ to tls->buffer.objs INDEX %d\\n\",\n\ttls->data.linkedobjects.linkedobjects_len);\n    fprintf(stderr,\"RECORD OBJ objname = %s\\n\",objects.linked_object);\n    fprintf(stderr,\"RECORD OBJ addresses = %#lx,%#lx\\n\",objects.range.begin, objects.range.end);\n    fprintf(stderr,\"RECORD OBJ times = %lu,%lu\\n\",objects.time_begin, objects.time_end);\n#endif\n\n    memcpy(&(tls->buffer.objs[tls->data.linkedobjects.linkedobjects_len]),\n           &objects, sizeof(objects));\n    tls->data.linkedobjects.linkedobjects_len++;\n    tls->dsoname_len += dsoname_len;\n\n    if (is_dlopen) {\n//\tcbtf_offline_sampling_status(CBTF_Monitor_Default_event,CBTF_Monitor_Resumed);\n    }\n}\n\n/**\n * Record a dlopened library.\n *\n * Writes information regarding a DSO that was dlopened/dlclosed  in the thread\n * to the appropriate file.\n *\n * @param dsoname      Name of the DSO's file.\n * @param begin        Beginning address at which this DSO was loaded.\n * @param end          Ending address at which this DSO was loaded.\n * @param b_time       Load time\n * @param e_time       Unload time\n */\nvoid cbtf_offline_record_dlopen(const char* dsoname,\n\t\t\tuint64_t begin, uint64_t end,\n\t\t\tuint64_t b_time, uint64_t e_time)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    //cbtf_offline_pause_sampling(CBTF_Monitor_Default_event);\n\n    /* Initialize the offline \"dso\" blob's header */\n    CBTF_EventHeader local_header;\n    CBTF_InitializeEventHeader(&local_header);\n    local_header.rank = monitor_mpi_comm_rank();\n    local_header.omp_tid = monitor_get_thread_num();\n    memcpy(&tls->dso_header, &local_header, sizeof(CBTF_EventHeader));\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_Protocol_Offline_LinkedObject objects;\n\n    /* Initialize the offline \"dso\" blob */\n    objects.objname = strdup(dsoname);\n    objects.addr_begin = begin;\n    objects.addr_end = end;\n    objects.time_begin = b_time;\n    objects.time_end = e_time;\n    objects.is_open = true;\n\n#else\n    /* Initialize the \"dso\" message */\n    /* this is only for the initial dsos loaded into thread\n     * and not intended for dlopen/dlclose callbacks\n     */ \n    CBTF_Protocol_LinkedObject objects;\n\n\n    CBTF_Protocol_FileName dsoFilename;\n    dsoFilename.path = strdup(dsoname);\n    objects.linked_object = dsoFilename;\n\n    objects.range.begin = begin;\n    objects.range.end = end;\n    objects.time_begin = b_time;\n    objects.time_end = e_time;\n\n    if (strcmp(CBTF_GetExecutablePath(),dsoname)) {\n\tobjects.is_executable = false;\n    } else {\n\tobjects.is_executable = true;\n    }\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n    /*\n     * intended ONLY for dlopen/dlclose callbacks\n     */\n    CBTF_Protocol_ThreadName tname;\n    tname.experiment = 0;\n    tname.host = strdup(local_header.host);\n    tname.pid = local_header.pid;\n    tname.has_posix_tid = true;\n    tname.posix_tid = local_header.posix_tid;\n    tname.rank = monitor_mpi_comm_rank();\n    tname.omp_tid = monitor_get_thread_num();\n    memcpy(&(tls->tname), &tname, sizeof(tname));\n\n    tls->tgrp.names.names_len = 0;\n    tls->tgrp.names.names_val = tls->tgrpbuf.tnames;\n    memset(tls->tgrpbuf.tnames, 0, sizeof(tls->tgrpbuf.tnames));\n\n    memcpy(&(tls->tgrpbuf.tnames[tls->tgrp.names.names_len]),\n           &tname, sizeof(tname));\n    tls->tgrp.names.names_len++;\n\n\n    /*\n     * intended ONLY for dlopen/dlclose callbacks\n     * Message tag: CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT\n     * xdr_CBTF_Protocol_LoadedLinkedObject\n     */\n    CBTF_Protocol_LoadedLinkedObject message;\n    memset(&message, 0, sizeof(message));\n\n    message.threads = tls->tgrp;\n    message.time = objects.time_begin;\n    message.range.begin =  begin;\n    message.range.end = end;\n    message.linked_object = dsoFilename;\n\n    if (strcmp(CBTF_GetExecutablePath(),dsoname)) {\n\tmessage.is_executable = false;\n    } else {\n\tmessage.is_executable = true;\n    }\n\n#endif\n\n    int dsoname_len = strlen(dsoname);\n    int newsize = (tls->data.linkedobjects.linkedobjects_len * sizeof(objects))\n\t\t  + (tls->dsoname_len + dsoname_len);\n\n    if(newsize > CBTF_MAXLINKEDOBJECTS * sizeof(objects)) {\n#ifndef NDEBUG\n\tif (IsCollectorDebugEnabled) {\n            fprintf(stderr,\"[%d,%d] cbtf_offline_record_dlopen SENDS OBJS for %s:%lld:%lld:%d:%d\\n\",\n\t\t    getpid(),monitor_get_thread_num(),\n                    tls->dso_header.host, (long long)tls->dso_header.pid, \n                    (long long)tls->dso_header.posix_tid,\n\t\t    tls->dso_header.rank,\n\t\t    tls->dso_header.omp_tid\n\t\t    );\n\t}\n#endif\n\tcbtf_offline_send_dsos(tls);\n    }\n\n    memcpy(&(tls->buffer.objs[tls->data.linkedobjects.linkedobjects_len]),\n           &objects, sizeof(objects));\n    tls->data.linkedobjects.linkedobjects_len++;\n    tls->dsoname_len += dsoname_len;\n\n    //cbtf_offline_sampling_status(CBTF_Monitor_Default_event,CBTF_Monitor_Resumed);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/configure.ac": "################################################################################\n# Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 2 of the License, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n# details.\n#\n# You should have received a copy of the GNU General Public License along with\n# this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n# Place, Suite 330, Boston, MA  02111-1307  USA\n################################################################################\n\nAC_INIT([core], [1.0])\nAC_COPYRIGHT([[Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.]])\n\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE\nAM_CONFIG_HEADER([config.h])\n\nAH_TOP([\n/*******************************************************************************\n** Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n])\n\nAC_GNU_SOURCE\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_LIBTOOL\nAC_PROG_INSTALL\n\nLT_CONFIG_LTDL_DIR([libltdl])\nLT_INIT([dlopen])\nLTDL_INIT([recursive])\n\nAC_PATH_PROG([RPCGEN], rpcgen)\nAC_PROG_LN_S\n\n################################################################################\n# Handle PowerPC and X86-64 Special Cases\n################################################################################\nAC_ARG_WITH(ppc64_bitmode,\n            AC_HELP_STRING([--with-ppc64-bitmode=<32,64>],\n                           [Specify ppc64 library bit mode @<:@64@:>@]),\n            ppc64_bitmode=$withval, ppc64_bitmode=\"64\")\n\nAC_MSG_CHECKING([Configuring for host = $host  with ppc64_bitmode = $ppc64_bitmode])\n\ncase \"$host\" in\n    powerpc-*-linux*)\n        AC_MSG_CHECKING([Configuring for powerpc-star-linux])\n\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n            libdir='${exec_prefix}/lib'\n        fi\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\n    powerpc64-*-*)\n\n        AC_MSG_CHECKING([Configuring for powerpc64-star-linux with ppc64_bitmode = $ppc64_bitmode])\n        if test \"$ppc64_bitmode\" = \"64\" ; then\n                AC_MSG_CHECKING([Configuring for 64 bit powerpc64-star-linux host])\n                abi_libdir=\"lib64\"\n                alt_abi_libdir=\"lib\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n                    libdir='${exec_prefix}/lib64'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib64 $LDFLAGS\"\n                CFLAGS=\"-m64 $CFLAGS\"\n                CXXFLAGS=\"-m64 $CXXFLAGS\"\n                CPPFLAGS=\"-m64 $CPPFLAGS\"\n        elif test \"$ppc64_bitmode\" = \"32\" ; then\n                AC_MSG_CHECKING([Configuring for 32 bit powerpc64-star-linux host])\n                abi_libdir=\"lib\"\n                alt_abi_libdir=\"lib64\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n                    libdir='${exec_prefix}/lib'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        fi\n        ;;\n\n    x86_64-*-linux*)\n        AC_MSG_CHECKING([Configuring for x86_64--star-linux host])\n        if test -d /usr/lib/x86_64-linux-gnu ; then\n          if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n            libdir='${exec_prefix}/lib'\n          fi\n          abi_libdir=\"lib\"\n          alt_abi_libdir=\"lib64\"\n          LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        else\n          if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n            libdir='${exec_prefix}/lib64'\n          fi\n          abi_libdir=\"lib64\"\n          alt_abi_libdir=\"lib\"\n          LDFLAGS=\"-DLIB_DIR=lib64 $LDFLAGS\"\n        fi\n        ;;\n\n    *)\n        AC_MSG_CHECKING([Configuring for default host])\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\nesac\ntopdir_execprefix=${exec_prefix}\nAC_SUBST(topdir_execprefix)\n\nabi_libdir_name=${abi_libdir}\nAC_SUBST(abi_libdir_name)\nalt_abi_libdir_name=${alt_abi_libdir}\nAC_SUBST(alt_abi_libdir_name)\n\ncbtf_platform=`uname -i`\ncbtf_hardware_platform=$cbtf_platform\nAC_MSG_CHECKING([Checking for cbtf_hardware_platform=$cbtf_hardware_platform])\nAC_SUBST(cbtf_hardware_platform)\n\n\n################################################################################\n# Check for POSIX Threads (ISO/IEC 9945-1:1996)\n################################################################################\n\nAC_CHECK_HEADER(pthread.h, [ AC_CHECK_LIB(pthread, pthread_create, [\n    AC_DEFINE(HAVE_POSIX_THREADS, 1, [Define to 1 if you have POSIX threads.])\n], [\n    AC_MSG_FAILURE([cannot locate POSIX thread library and/or headers.])\n]) ])\n\n################################################################################\n# Check for TLS option, default to implicit\n################################################################################\n\nAC_ARG_WITH(tls,\n            AC_HELP_STRING([--with-tls=TYPE],\n                           [tls (implicit, explicit) @<:@implicit@:>@]),\n            TLS=$withval, TLS=\"implicit\")\n\ncase \"$TLS\" in\n    implicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, false)\n        ;;\n\n    explicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, true)\n        AC_DEFINE(USE_EXPLICIT_TLS, 1, [Define to 1 if you want to use an explicit TLS implementation instead of the __thread keyword.])\n        ;;\n\n    *)\n        AC_MSG_ERROR([invalid tls specification \"$TLS\".])\n        ;;\nesac\n\n################################################################################\n# Begin Target O/S Specification\n################################################################################\n\ntarget_os=$host\nAC_MSG_CHECKING(for Target O/S)\nAC_ARG_WITH(target-os,\n    AC_HELP_STRING([--with-target-os=TARGET_OS],\n                   [target os specification @<:@$host@:>@]),\n                    TARGET_OS=$withval, TARGET_OS=\"$host\")\n\n\nAM_CONDITIONAL(HAVE_TARGET_STATIC, false)\nAM_CONDITIONAL(BUILD_TARGETED, false)\n\nbuild_targeted=0\ncase \"$TARGET_OS\" in\n    cray-xk)\n\tAC_DEFINE(TARGET_OS_CRAYXK, 1, [Do not define if not building for targeted cray-xk.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xk,\n\t\t\t   [Name targeted OS])\n\t;; \n    cray-xe)\n\tAC_DEFINE(TARGET_OS_CRAYXE, 1, [Do not define if not building for targeted cray-xe.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xe,\n\t\t\t   [Name targeted OS])\n\t;; \n    cray-xt5)\n\tAC_DEFINE(TARGET_OS_CRAYXT5, 1, [Do not define if not building for targeted cray-xt5.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt5,\n\t\t\t   [Name targeted OS])\n\t;; \n    cray-xt4)\n\tAC_DEFINE(TARGET_OS_CRAYXT4, 1, [Do not define if not building for targeted cray-xt4.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt4,\n\t\t\t   [Name targeted OS])\n\t;; \n    bgl)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGL, 1, [Do not define if not building for targeted bgl.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgl,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=1\n\t;; \n    bgp)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGP, 1, [Do not define if not building for targeted bgp.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgp,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=1\n\t;; \n    bgq)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n        AM_CONDITIONAL(BUILD_TARGETED, true)\n        AC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n        AC_DEFINE(TARGET_OS_BGQ, 1, [Do not define if not building for targeted bgq.])\n        AC_DEFINE_UNQUOTED(TARGET_OS,bgq,\n                           [Name targeted OS])\n\tbuild_targeted=1\n        ;;\n    *)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, false)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [0],[Define to 0 for targeted non-static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, false)\n\tAC_DEFINE(BUILD_TARGETED, 0, [Define to 1 if building a targeted runtime.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,$host,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=0\n\t;; \nesac\n\nAC_SUBST(BUILD_TARGETED)\nAC_SUBST(TARGET_OS)\n################################################################################\n# End Target O/S Specification\n################################################################################\n\n################################################################################\n# build runtime collector software only\n################################################################################\n#\n# Option: \n#\nAC_MSG_CHECKING(for building runtime collectors only)\nAC_ARG_ENABLE([runtime-only],\n    [AS_HELP_STRING([--enable-runtime-only],\n        [Enable support building just the runtime collectors with no client [default=no]])],\n    [], [enable_runtime_only=no])\n\nif test \"x$enable_runtime_only\" = xyes ; then\n    AM_CONDITIONAL(BUILD_RUNTIME, true)\n    AC_DEFINE(BUILD_RUNTIME, 1, [Define to 1 if you do want only collector runtime support built.])\nelse\n    AM_CONDITIONAL(BUILD_RUNTIME, false)\n    AC_DEFINE(BUILD_RUNTIME, 0, [Define to 1 if you do not want only collector runtime support built.])\nfi\nAC_SUBST(BUILD_RUNTIME)\n\n\n################################################################################\n# Check for Additional Packages\n################################################################################\n\nAX_BINUTILS()\nAX_LIBMONITOR()\nAX_LIBUNWIND()\nAX_PAPI()\n\nAX_ALPS()\n\nAX_BOOST_BASE([1.35.0])\nAX_BOOST_SYSTEM()\nAX_BOOST_THREAD()\nAX_BOOST_DATE_TIME()\nAX_BOOST_FILESYSTEM()\nAX_BOOST_PROGRAM_OPTIONS()\n\nAX_XERCESC()\n# This helps with targeted builds when there is no xercesc\nif test \"$LIBXERCES_C\" = \"-lxerces-c\" ; then\n  AX_XERCESC_VERSION()\nfi\n\nAX_MRNET()\nAX_CBTF()\nAX_CBTF_XML()\nAX_CBTF_MRNET()\nAX_LIBELF()\nAX_LIBDWARF()\nAX_DYNINST()\nAX_PKG_MPI()\n\nAX_MESSAGES()\nAX_CBTF_SERVICES()\nAX_LIBIOMP()\n\nAC_CONFIG_FILES([\n    Makefile\n    include/Makefile\n    libltdl/Makefile\n    collectionTool/Makefile\n    collectors/Makefile\n    collectors/pcsamp/Makefile\n    collectors/usertime/Makefile\n    collectors/io/Makefile\n    collectors/hwc/Makefile\n    collectors/hwcsamp/Makefile\n    collectors/hwctime/Makefile\n    collectors/mem/Makefile\n    collectors/mpi/Makefile\n    collectors/pthreads/Makefile\n    components/Makefile\n    daemonTool/Makefile\n    scripts/Makefile\n    src/Makefile\n])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/components/LinkedObjectComponent.cpp": "////////////////////////////////////////////////////////////////////////////////\n// Copyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n//\n// This library is free software; you can redistribute it and/or modify it under\n// the terms of the GNU Lesser General Public License as published by the Free\n// Software Foundation; either version 2.1 of the License, or (at your option)\n// any later version.\n//\n// This library is distributed in the hope that it will be useful, but WITHOUT\n// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n// FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n// details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this library; if not, write to the Free Software Foundation, Inc.,\n// 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\n/** @file LinkedObjectComponent. */\n\n#include <boost/bind.hpp>\n#include <boost/make_shared.hpp>\n#include <boost/operators.hpp>\n#include <mrnet/MRNet.h>\n#include <typeinfo>\n#include <algorithm>\n#include <sstream>\n\n#include <KrellInstitute/CBTF/Component.hpp>\n#include <KrellInstitute/CBTF/Type.hpp>\n#include <KrellInstitute/CBTF/Version.hpp>\n#include <KrellInstitute/CBTF/Impl/MRNet.hpp>\n\n#include \"KrellInstitute/Core/Address.hpp\"\n#include \"KrellInstitute/Core/AddressBuffer.hpp\"\n#include \"KrellInstitute/Core/AddressRange.hpp\"\n#include \"KrellInstitute/Core/AddressSpace.hpp\"\n#include \"KrellInstitute/Core/LinkedObject.hpp\"\n#include \"KrellInstitute/Core/LinkedObjectEntry.hpp\"\n#include \"KrellInstitute/Core/Path.hpp\"\n#include \"KrellInstitute/Core/Time.hpp\"\n#include \"KrellInstitute/Core/TimeInterval.hpp\"\n#include \"KrellInstitute/Core/ThreadName.hpp\"\n\n#include \"KrellInstitute/Messages/Address.h\"\n#include \"KrellInstitute/Messages/EventHeader.h\"\n#include \"KrellInstitute/Messages/File.h\"\n#include \"KrellInstitute/Messages/LinkedObjectEvents.h\"\n#include \"KrellInstitute/Messages/Thread.h\"\n#include \"KrellInstitute/Messages/ThreadEvents.h\"\n\n\nusing namespace KrellInstitute::CBTF;\nusing namespace KrellInstitute::Core;\n\n/** requires std::ostringstream debug_prefix in namespace **/\n#define DEBUGPREFIX(x,y) \\\n\tif (debug_prefix.str().empty()) { \\\n\t    if (x) debug_prefix << \"FE:\"; \\\n\t    else  if (y == 1) debug_prefix << \"LCP:\"; \\\n\t    else  debug_prefix << \"ICP:\"; \\\n\t    debug_prefix << getpid() << \" \"; \\\n\t}\n\nnamespace { \n\n    std::ostringstream debug_prefix;\n    void flushOutput(std::stringstream &output) {\n\tif ( !output.str().empty() ) {\n\t    std::cerr << output.str();\n\t    output.str(std::string());\n\t    output.clear();\n\t}\n    }\n\n/** count indicating number of linked object group messages handled. */\n    int handled_threads = 0;\n\n#ifndef NDEBUG\n/** Flag indicating if debuging for LinkedObjects is enabled. */\n    bool is_debug_linkedobject_events_enabled =\n\t(getenv(\"CBTF_DEBUG_LINKEDOBJECT_EVENTS\") != NULL);\n    bool is_trace_linkedobject_events_enabled =\n\t(getenv(\"CBTF_TRACE_LINKEDOBJECT_EVENTS\") != NULL);\n#endif\n\n    bool is_defer_emit = (getenv(\"CBTF_DEFER_LINKEDOBJECT_EMIT\") != NULL);\n    long numTerminated = 0;\n    long numThreads = 0;\n\n    int _MaxLeafDistance = 0;\n    int _NumChildren = 0;\n\n    bool isFrontend() {\n\treturn Impl::TheTopologyInfo.IsFrontend;\n    }\n    bool isLeafCP() {\n\treturn (!Impl::TheTopologyInfo.IsFrontend && _MaxLeafDistance == 1);\n    }\n    bool isNonLeafCP() {\n\treturn (!Impl::TheTopologyInfo.IsFrontend && _MaxLeafDistance > 1);\n    }\n    int getNumChildren() {\n\t return _NumChildren;\n    }\n    int getMaxLeafDistance() {\n\t return _MaxLeafDistance;\n    }\n\n    bool initialized_topology_info = false;\n\n    void init_TopologyInfo() {\n\n\tif (initialized_topology_info) return;\n\n\tbool initMaxLeafDistance = false;\n\tbool initNumChildren = false;\n\tif (_MaxLeafDistance == 0 && Impl::TheTopologyInfo.MaxLeafDistance > 0) {\n\t    _MaxLeafDistance = Impl::TheTopologyInfo.MaxLeafDistance;\n\t    initMaxLeafDistance = true;\n\t}\n\tif (_NumChildren == 0 && Impl::TheTopologyInfo.NumChildren > 0) {\n\t    _NumChildren = Impl::TheTopologyInfo.NumChildren;\n\t    initNumChildren = true;\n\t}\n\tinitialized_topology_info = (initMaxLeafDistance && initNumChildren);\n    }\n\n    /**\n     * Convert std::string for mrnet use.\n     *\n     * @note    The caller assumes responsibility for releasing all allocated\n     *          memory when it is no longer needed.\n     *\n     * @param in      std::string to be converted.\n     * @retval out    Structure to hold the results.\n     */\n    void convert(const std::string& in, char*& out)\n    {\n        out = reinterpret_cast<char*>(malloc((in.size() + 1) * sizeof(char)));\n        strcpy(out, in.c_str());\n    }\n\n    /**\n     * Convert threadname for mrnet use.\n     *\n     * @note    The caller assumes responsibility for releasing all allocated\n     *          memory when it is no longer needed.\n     *\n     * @param in      ThreadName to be converted.\n     * @retval out    Structure to hold the results.\n     */\n    void convert(const ThreadName& in, CBTF_Protocol_ThreadName& out)\n    {\n\tout.experiment = 1;\n\tconvert(in.getHost(), out.host);\n\tout.pid = in.getPid();\n\tstd::pair<bool, pthread_t> posix_tid = in.getPosixThreadId();\n\tout.has_posix_tid = posix_tid.first;\n\tif(posix_tid.first)\n\t    out.posix_tid = posix_tid.second;\n\tout.rank = in.getMPIRank();\n\tout.omp_tid = in.getOmpTid();\n    }\n\n    void convert(const LinkedObject& in, CBTF_Protocol_LinkedObject& out)\n    {\n\tconvert(in.getPath(), out.linked_object.path);\n\tout.is_executable = in.is_executable;\n\tout.is_executable = in.isExecutable();\n\tout.time_begin = in.getTimeInterval().getBegin().getValue();\n\tout.time_end = in.getTimeInterval().getEnd().getValue();\n\tout.range.begin = in.getAddressRange().getBegin().getValue();\n\tout.range.end = in.getAddressRange().getEnd().getValue();\n    }\n\n}\n\n/**\n * Component that records linked objects.\n */\nclass __attribute__ ((visibility (\"hidden\"))) LinkedObjectComponent :\n    public Component\n{\n\npublic:\n\n    /** Factory function for this component type. */\n    static Component::Instance factoryFunction()\n    {\n        return Component::Instance(\n            reinterpret_cast<Component*>(new LinkedObjectComponent())\n            );\n    }\n\nprivate:\n\n    /** Default constructor. */\n    LinkedObjectComponent() :\n        Component(Type(typeid(LinkedObjectComponent)), Version(0, 0, 1))\n    {\n        declareInput<int>(\n            \"numBE\", boost::bind(&LinkedObjectComponent::numBEHandler, this, _1)\n            );\n        declareInput<ThreadNameVec>(\n            \"threadnames\", boost::bind(&LinkedObjectComponent::threadnamesHandler, this, _1)\n            );\n\tdeclareInput<AddressBuffer>(\n\t    \"abufferin\", boost::bind(&LinkedObjectComponent::AddressBufferHandler, this, _1)\n\t    );\n        declareInput<boost::shared_ptr<CBTF_Protocol_LoadedLinkedObject> >(\n            \"loaded\", boost::bind(&LinkedObjectComponent::loadedHandler, this, _1)\n            );\n        declareInput<boost::shared_ptr<CBTF_Protocol_UnloadedLinkedObject> >(\n            \"unloaded\", boost::bind(&LinkedObjectComponent::unloadedHandler, this, _1)\n            );\n        declareInput<boost::shared_ptr<CBTF_Protocol_LinkedObjectGroup> >(\n            \"group\", boost::bind(&LinkedObjectComponent::groupHandler, this, _1)\n            );\n\tdeclareInput<long>(\n\t    \"numTerminatedIn\", boost::bind(&LinkedObjectComponent::numTerminatedHandler, this, _1)\n\t);\n\n\tdeclareOutput<boost::shared_ptr<CBTF_Protocol_LoadedLinkedObject> >(\"loaded_xdr_out\");\n\tdeclareOutput<boost::shared_ptr<CBTF_Protocol_UnloadedLinkedObject> >(\"unloaded_xdr_out\");\n\tdeclareOutput<boost::shared_ptr<CBTF_Protocol_LinkedObjectGroup> >(\"group_xdr_out\");\n\tdeclareOutput<LinkedObjectEntryVec>(\"linkedobjectvec_out\");\n\tdeclareOutput<AddressSpace>(\"linkedobject_threadmap_out\");\n\n\tinit_TopologyInfo();\n    }\n\n    /** Handlers for the inputs.*/\n\n    void numBEHandler(const int& in)\n    {\n        init_TopologyInfo();\n#ifndef NDEBUG\n        std::stringstream output;\n        DEBUGPREFIX(Impl::TheTopologyInfo.IsFrontend,Impl::TheTopologyInfo.MaxLeafDistance);\n#endif\n\n#ifndef NDEBUG\n        if (is_trace_linkedobject_events_enabled) {\n            output << debug_prefix.str()\n            << \"ENTERED LinkedObjectComponent::numBEHandler number backends \" << in\n            << \" numChildren:\" << getNumChildren()\n            << std::endl;\n            flushOutput(output);\n        }\n#endif\n\n#ifndef NDEBUG\n        //flushOutput(output);\n#endif\n\n    }\n\n\n    // Is this running just at the leafCP?\n    // What does it do at the FE and intermediate CP levels?\n    void numTerminatedHandler(const long& in)\n    {\n\tinit_TopologyInfo();\n\n\tnumTerminated += in;\n\n#ifndef NDEBUG\n\tstd::stringstream output;\n\tDEBUGPREFIX(Impl::TheTopologyInfo.IsFrontend,getMaxLeafDistance());\n#endif\n\n#ifndef NDEBUG\n\tif (is_trace_linkedobject_events_enabled) {\n            output << debug_prefix.str()\n                << \"ENTERED LinkedObjectComponent::numTerminatedHandler\"\n\t\t<< \" numTerminated:\" << numTerminated\n\t\t<< \" numThreads:\" << numThreads\n\t\t<< \" addressspace size:\" << addressspace.size()\n\t\t<< \" numChildren:\" << getNumChildren()\n\t\t<< std::endl;\n\t    flushOutput(output);\n\t}\n#endif\n\n        if (numTerminated == numThreads && addressspace.size() == numThreads) {\n\n\n\t    AddressCounts ac = abuffer.addresscounts;\n\t    // ICP and FE levels do not have counts. Possibly due to no buffer yet?\n\t    bool havecounts = (ac.size() > 0) ? true : false ;\n\t    AddressSpace found;\n\n\t    AddressSpace::iterator i;\n\t    for (AddressSpace::iterator i = addressspace.begin(); i != addressspace.end(); ++i) {\n\n\t\tLinkedObjectVec tmp;\n\t\tfor (LinkedObjectVec::iterator k = (*i).second.begin();\n\t\t\t     k != (*i).second.end(); ++k) {\n\n\t\t    bool has_sample = false;\n\t\t    AddressRange addr_range((*k).getAddressRange());\n\t\t    AddressCounts::const_iterator aci;\n\t\t    for (aci=ac.equal_range(addr_range.getBegin()).first;\n\t\t\t aci!=ac.equal_range(addr_range.getEnd()).second;aci++) {\n\t\t\thas_sample = true;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    if(has_sample || !havecounts) {\n#ifndef NDEBUG\n\t\t\tif (is_trace_linkedobject_events_enabled) {\n    \t\t\t    output << debug_prefix.str()\n\t\t\t\t<< \"\\t HAS SAMPLE name:\" << (*k).getPath()\n\t\t\t\t<< \" range:\" << (*k).getAddressRange()\n\t\t\t\t<< std::endl;\n\t\t\t}\n#endif\n\t\t\ttmp.push_back(*k);\n\t\t    }\n\t\t}\n\n#ifndef NDEBUG\n\t\tif (is_trace_linkedobject_events_enabled) {\n\t\t    output << debug_prefix.str()\n\t\t    << \"LinkedObjectComponent::numTerminatedHandler CONVERT\"\n\t\t    << \" addressspace thread:\" << (*i).first << std::endl;\n\t\t}\n#endif\n\n\t\tif(tmp.size() > 0) {\n\t\t    found.insert( std::make_pair((*i).first,tmp) );\n\t\t}\n\t    }\n\n\t    for (AddressSpace::iterator i = found.begin(); i != found.end(); ++i) {\n\n\t\tboost::shared_ptr<CBTF_Protocol_LinkedObjectGroup> logroup(\n\t\t    new CBTF_Protocol_LinkedObjectGroup()\n\t\t    );\n\n\t\tCBTF_Protocol_ThreadName* ptr = &logroup->thread;\n\t\tconvert((*i).first, *ptr);\n\n\t\tlogroup->linkedobjects.linkedobjects_len = (*i).second.size();\n\t\tlogroup->linkedobjects.linkedobjects_val =\n\t\t    reinterpret_cast<CBTF_Protocol_LinkedObject*>(\n\t\t    malloc((*i).second.size() * sizeof(CBTF_Protocol_LinkedObject))\n\t\t    );\n\n\t\tint j = 0;\n\t\tfor (LinkedObjectVec::iterator k = (*i).second.begin();\n\t\t\t     k != (*i).second.end(); ++k) {\n\t\t    CBTF_Protocol_LinkedObject* destination =\n\t\t\t&logroup->linkedobjects.linkedobjects_val[j];\n\t\t\tconvert((*k), *destination);\n\t\t    ++j;\n\t\t}\n\n#ifndef NDEBUG\n\t\tif (is_trace_linkedobject_events_enabled) {\n\t\t    output << debug_prefix.str()\n\t\t    << \"LinkedObjectComponent::numTerminatedHandler\"\n\t\t    << \" EMIT CBTF_Protocol_LinkedObjectGroup size:\"\n\t\t    << logroup->linkedobjects.linkedobjects_len << std::endl;\n\t\t    flushOutput(output);\n\t\t}\n#endif\n\t\temitOutput<boost::shared_ptr<CBTF_Protocol_LinkedObjectGroup> >(\"group_xdr_out\", logroup);\n\t    }\n\n#ifndef NDEBUG\n\t    if (is_trace_linkedobject_events_enabled) {\n\t    \toutput << debug_prefix.str()\n\t        << \"LinkedObjectComponent::numTerminatedHandler EMIT AddressSpace size:\" << found.size() << std::endl;\n\t\tflushOutput(output);\n\t    }\n#endif\n\t    emitOutput<AddressSpace>(\"linkedobject_threadmap_out\",found);\n\t}\n\t\n#ifndef NDEBUG\n\t//flushOutput(output);\n#endif\n    }\n\n    // Handler for the \"abuffer\" input. The input buffer is used\n    // to reduce the addressspace to only those linked objects that\n    // contain a buffer address in the addressrange the object was\n    // loaded into at runtime.\n    void AddressBufferHandler(const AddressBuffer& in)\n    {\n\tinit_TopologyInfo();\n#ifndef NDEBUG\n\tstd::stringstream output;\n\tDEBUGPREFIX(Impl::TheTopologyInfo.IsFrontend,getMaxLeafDistance());\n        if (is_trace_linkedobject_events_enabled) {\n\t    output << debug_prefix.str()\n\t    << \"ENTERED LinkedObjectComponent::AddressBufferHandler\"\n\t    << \" with \" << in.addresscounts.size() << \" addresses\"\n\t    << \" numChildren:\" << getNumChildren()\n\t    << std::endl;\n\t    flushOutput(output);\n\t}\n#endif\n\tabuffer = in;\n\n#ifndef NDEBUG\n\t//flushOutput(output);\n#endif\n    }\n\n    // This message can only arrive on a local component network\n    // as it currently has no mrnet converter to pass it on to other nodes.\n    // Arrives on the \"threadnames\" input and exists here to inform\n    // this component of existing threads.\n    void threadnamesHandler(const ThreadNameVec& in)\n    {\n\tinit_TopologyInfo();\n#ifndef NDEBUG\n\tstd::stringstream output;\n\tDEBUGPREFIX(Impl::TheTopologyInfo.IsFrontend,getMaxLeafDistance());\n\tif (is_trace_linkedobject_events_enabled) {\n\t    output << debug_prefix.str()\n\t    << \"ENTERED LinkedObjectComponent::threadnamesHandler with threads:\"\n\t    << in.size()\n\t    << \" numChildren:\" << getNumChildren()\n\t    << std::endl;\n\t    flushOutput(output);\n\t}\n#endif\n\tthreadnames = in;\n\tnumThreads = threadnames.size();\n    }\n\n\n    // This message contains a threadname and a list of linkedobjects.\n    // At the LeafCP level it is reduced to only the linkedobjects for\n    // which a matching address in the addressbuffer is found. The LeafCP\n    // does not emit the reduced groups here.\n    //\n    // At the FE and Intermediate CP level we just place the passed group\n    // into an AddressSpace object and once all expected groups have\n    // arrived (addressspace.size == threads.size == numTerminated) this\n    // handler will emit all the groups one at a time. Can this be done\n    // in one larger CBTF_Protocol_AddressSpace message?\n    void groupHandler(const boost::shared_ptr<CBTF_Protocol_LinkedObjectGroup>& in)\n    {\n\tinit_TopologyInfo();\n\n        CBTF_Protocol_LinkedObjectGroup *message = in.get();\n\tThreadName tname(message->thread);\n\thandled_threads++;\n\n#ifndef NDEBUG\n\tstd::stringstream output;\n\tDEBUGPREFIX(Impl::TheTopologyInfo.IsFrontend,getMaxLeafDistance());\n\tif (is_trace_linkedobject_events_enabled) {\n\t    output << debug_prefix.str()\n\t    << \"ENTERED LinkedObjectComponent::groupHandler linked objects num:\"\n\t    << message->linkedobjects.linkedobjects_len\n\t    << \" handled_threads:\" << handled_threads\n\t    << \" of:\" << threadnames.size()\n\t    << \" numChildren:\" << getNumChildren()\n\t    << std::endl;\n\t    output << debug_prefix.str()\n\t    << \"LinkedObjectComponent::groupHandler message thread:\" << tname\n\t    << std::endl;\n\t    flushOutput(output);\n\t}\n#endif\n\n\n        LinkedObjectVec linkedobjectvec;\n\t\n\tfor(int i = 0; i < message->linkedobjects.linkedobjects_len; ++i) {\n\t        const CBTF_Protocol_LinkedObject& msg_lo =\n\t\t\t\tmessage->linkedobjects.linkedobjects_val[i];\n\t\tLinkedObject e;\n\t\te.path = msg_lo.linked_object.path;\n\t\te.is_executable = msg_lo.is_executable;\n\t\te.time = TimeInterval(msg_lo.time_begin,msg_lo.time_end);\n\t\te.range = AddressRange(msg_lo.range.begin,msg_lo.range.end);\n\t        linkedobjectvec.push_back(e);\n\t}\n\taddressspace.insert(std::make_pair(tname,linkedobjectvec));\n\n#ifndef NDEBUG\n\tif (is_trace_linkedobject_events_enabled) {\n\t    output << debug_prefix.str()\n\t        << \"LinkedObjectComponent::groupHandler\"\n\t        << \" addressspace size:\" << addressspace.size()\n\t        << \" threads:\" << threadnames.size()\n\t        << \" numTerminated:\" << numTerminated\n\t\t<< std::endl;\n\t    flushOutput(output);\n\t}\n#endif\n\n\tif ( !isLeafCP() &&\n\t     (addressspace.size() == threadnames.size()) &&\n\t     (numTerminated == threadnames.size()) ) {\n\t    for (AddressSpace::iterator i = addressspace.begin(); i != addressspace.end(); ++i) {\n\n\t\tboost::shared_ptr<CBTF_Protocol_LinkedObjectGroup> logroup(\n\t\t    new CBTF_Protocol_LinkedObjectGroup()\n\t\t    );\n\n\t\tCBTF_Protocol_ThreadName* ptr = &logroup->thread;\n\t\tconvert((*i).first, *ptr);\n\n\t\tlogroup->linkedobjects.linkedobjects_len = (*i).second.size();\n\t\tlogroup->linkedobjects.linkedobjects_val =\n\t\t    reinterpret_cast<CBTF_Protocol_LinkedObject*>(\n\t\t    malloc((*i).second.size() * sizeof(CBTF_Protocol_LinkedObject))\n\t\t    );\n\n\t\tint j = 0;\n\t\tfor (LinkedObjectVec::iterator k = (*i).second.begin();\n\t\t\t     k != (*i).second.end(); ++k) {\n\t\t    CBTF_Protocol_LinkedObject* destination =\n\t\t\t&logroup->linkedobjects.linkedobjects_val[j];\n\t\t\tconvert((*k), *destination);\n\t\t    ++j;\n\t\t}\n\n#ifndef NDEBUG\n\t\tif (is_trace_linkedobject_events_enabled) {\n\t\t    output << debug_prefix.str()\n\t\t    << \"LinkedObjectComponent::groupHandler\"\n\t\t    << \" EMIT CBTF_Protocol_LinkedObjectGroup size:\"\n\t\t    << logroup->linkedobjects.linkedobjects_len << std::endl;\n\t\t    flushOutput(output);\n\t\t}\n#endif\n\t\temitOutput<boost::shared_ptr<CBTF_Protocol_LinkedObjectGroup> >(\"group_xdr_out\", logroup);\n\t    }\n\t}\n\n#ifndef NDEBUG\n        //flushOutput(output);\n#endif\n    }\n\n    // Handler for dlopen events.\n    void loadedHandler(const boost::shared_ptr<CBTF_Protocol_LoadedLinkedObject>& in)\n    {\n\tinit_TopologyInfo();\n        CBTF_Protocol_LoadedLinkedObject *message = in.get();\n#ifndef NDEBUG\n\tstd::stringstream output;\n\tDEBUGPREFIX(Impl::TheTopologyInfo.IsFrontend,getMaxLeafDistance());\n\tif (is_trace_linkedobject_events_enabled) {\n\t    output << debug_prefix.str()\n\t     << \"ENTERED LinkedObjectComponent::loadedHandler\" << std::endl;\n            flushOutput(output);\n\t}\n#endif\n\tLinkedObjectEntry entry;\n\n\tfor(int i = 0; i < message->threads.names.names_len; ++i) {\n\t    const CBTF_Protocol_ThreadName& msg_thread =\n\t\t\t\tmessage->threads.names.names_val[i];\n\n\t    ThreadName tname(msg_thread);\n\t    entry.tname = tname;\n\t    entry.path = message->linked_object.path;\n\t    entry.addr_begin = message->range.begin;\n\t    entry.addr_end = message->range.end;\n\t    entry.is_executable = message->is_executable;\n\t    entry.time_loaded = message->time;\n\t    entry.time_unloaded = Time::Now();\n\n\t    linkedobjectentryvec.push_back(entry);\n\n// used to show the linkedobject information sent.\n#ifndef NDEBUG\n\t    if (is_debug_linkedobject_events_enabled) {\n\t    output << \"path \" << entry.path\n\t    << \" loaded at time \" << entry.time_loaded.getValue()\n\t    << \" unloaded at time \" << entry.time_unloaded.getValue()\n\t    << \" at \" << AddressRange(entry.addr_begin,entry.addr_end)\n\t    << \" in thread \" << entry.tname.getHost()\n\t    << \":\" << entry.tname.getPid()\n\t    << \":\" <<  entry.tname.getPosixThreadId().second\n\t    << std::endl;\n\t    }\n#endif\n\t}\n\n#ifndef NDEBUG\n\tif (is_debug_linkedobject_events_enabled) {\n\t    output << debug_prefix.str()\n\t     << \"LinkedObjectComponent::loadedHandler EMIT CBTF_Protocol_LoadedLinkedObject\" << std::endl;\n\t    flushOutput(output);\n\t}\n#endif\n\temitOutput<boost::shared_ptr<CBTF_Protocol_LoadedLinkedObject> >(\"loaded_xdr_out\", in);\n\n#ifndef NDEBUG\n        //flushOutput(output);\n#endif\n    }\n\n    // Handler for dlclose events.\n    void unloadedHandler(const boost::shared_ptr<CBTF_Protocol_UnloadedLinkedObject>& in)\n    {\n\tinit_TopologyInfo();\n#ifndef NDEBUG\n\tstd::stringstream output;\n\tDEBUGPREFIX(Impl::TheTopologyInfo.IsFrontend,getMaxLeafDistance());\n\tif (is_trace_linkedobject_events_enabled) {\n\t    output << debug_prefix.str()\n\t     << \"ENTERED LinkedObjectComponent::unloadedHandler\" << std::endl;\n\t    flushOutput(output);\n\t}\n#endif\n\n#ifndef NDEBUG\n\tif (is_debug_linkedobject_events_enabled) {\n\t    output << debug_prefix.str()\n\t     << \"LinkedObjectComponent::unloadedHandler EMIT CBTF_Protocol_UnloadedLinkedObject\" << std::endl;\n\t    flushOutput(output);\n\t}\n#endif\n\temitOutput<boost::shared_ptr<CBTF_Protocol_UnloadedLinkedObject> >(\"unloaded_xdr_out\", in);\n\n#ifndef NDEBUG\n        //flushOutput(output);\n#endif\n    }\n\n    // address buffer used to reduce incoming linkedobject groups\n    // from the ltwt BEs.\n    AddressBuffer abuffer;\n\n    // vector of linkedobjectentry with thread info.\n    LinkedObjectEntryVec linkedobjectentryvec;\n    // vector of linkedobject info.\n    LinkedObjectVec linkedobjectvec;\n    // map of threadname to linkedobjectvec.\n    AddressSpace addressspace;\n\n    // vector of incoming threadnames.\n    ThreadNameVec threadnames;\n\n}; // class LinkedObjectComponent\n\nKRELL_INSTITUTE_CBTF_REGISTER_FACTORY_FUNCTION(LinkedObjectComponent)\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/template.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2014 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>@collector_name@</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Stream>\n    <Name>ThreadsFinished</Name>\n    <Tag>1130</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare outputs of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>maxfunctionvalues_xdr_out</Name>\n      <From><Output>maxfunctionvalues_xdr_out_from_frontend</Output></From>\n  </Output>\n  <Output>\n      <Name>minfunctionvalues_xdr_out</Name>\n      <From><Output>minfunctionvalues_xdr_out_from_frontend</Output></From>\n  </Output>\n  <Output>\n      <Name>avgfunctionvalues_xdr_out</Name>\n      <From><Output>avgfunctionvalues_xdr_out_from_frontend</Output></From>\n  </Output>\n \n  <Frontend>\n\n<!--\n     FRONTEND NETWORK\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>@collector_name@_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@fe_component_location@</SearchPath>\n\n      <Plugin>@aggregation_plugin@</Plugin>\n      <Plugin>LinkedObjectPlugin.so</Plugin>\n      <Plugin>MRNetConvertorsPlugin.so</Plugin>\n      <Plugin>SymbolPlugin.so</Plugin>\n      <Plugin>ThreadPlugin.so</Plugin>\n\n<!--\n     The Frontend @aggregation_type@ component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>@aggregation_type@</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObjectComponent</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numBE</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>numBE</Input>\n        </To>\n      </Connection>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numBE</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>numBE</Input>\n        </To>\n      </Connection>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>numBE</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingThreadsFinished</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>finished</Input>\n        </To>\n      </Input>\n\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingSymbolTable</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>symboltable_xdr_in</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     DPM 42315 disabled\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     DPM 42615 added\n-->\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numTerminatedOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>numTerminatedIn</Input>\n        </To>\n      </Connection>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numTerminatedOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>numTerminatedIn</Input>\n        </To>\n      </Connection>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numTerminatedOut</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>numTerminatedIn</Input>\n        </To>\n      </Connection>\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numTerminatedOut</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>numTerminatedIn</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n-->\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n        <Name>maxfunctionvalues_xdr_out_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>maxfunctionvalues_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n        <Name>minfunctionvalues_xdr_out_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>minfunctionvalues_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n        <Name>avgfunctionvalues_xdr_out_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>avgfunctionvalues_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n-->\n      <Output>\n        <Name>OutgoingNumBE</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>numBE</Output>\n        </From>\n      </Output>\n\n    </Network>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming signal that threads have terminated.\n-->\n    <IncomingUpstream>\n      <Name>ThreadsFinished</Name>\n      <To><Input>IncomingThreadsFinished</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>SymbolTable</Name>\n      <To><Input>IncomingSymbolTable</Input></To>\n    </IncomingUpstream>\n\n<!--\n-->\n    <OutgoingDownstream>\n      <Name>DownstreamNumBE</Name>\n      <From><Output>OutgoingNumBE</Output></From>\n    </OutgoingDownstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    LEAF CP NETWORK\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n    cp:bottom\n    try cp for the moment...\n-->\n    <Depth>\n\t<Expression>\n\t    cp\n\t</Expression>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>@collector_name@_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@cn_component_location@</SearchPath>\n\n      <Plugin>@aggregation_plugin@</Plugin>\n      <Plugin>LinkedObjectPlugin.so</Plugin>\n      <Plugin>MRNetConvertorsPlugin.so</Plugin>\n      <Plugin>SymbolPlugin.so</Plugin>\n      <Plugin>ThreadPlugin.so</Plugin>\n\n<!--\n     The @aggregation_type@ component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>@aggregation_type@</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObjectComponent</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>IncomingNumBE</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numBE</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>numBE</Input>\n        </To>\n      </Connection>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numBE</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>numBE</Input>\n        </To>\n      </Connection>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>numBE</Input>\n        </To>\n      </Connection>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsFinished</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>finished</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingSymbolTable</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>symboltable_xdr_in</Input>\n        </To>\n      </Input>\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     DPM ADDED BACK IN 42915\n-->\n     Notify Aggregator that all threads are terminated.\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobject_threadmap_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobject_threadmap_in</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numTerminatedOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>numTerminatedIn</Input>\n        </To>\n      </Connection>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numTerminatedOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>numTerminatedIn</Input>\n        </To>\n      </Connection>\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numTerminatedOut</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>numTerminatedIn</Input>\n        </To>\n      </Connection>\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>numTerminatedOut</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>numTerminatedIn</Input>\n        </To>\n      </Connection>\n-->\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsFinished</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingSymbolTable</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>symboltable_xdr_out</Output>\n         </From>\n      </Output>\n \n<!--\n-->\n      <Output>\n        <Name>OutgoingNumBE</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>numBE</Output>\n        </From>\n      </Output>\n\n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For @collector_name@, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming signal that threads have terminated.\n-->\n    <IncomingUpstream>\n      <Name>ThreadsFinished</Name>\n      <To><Input>IncomingThreadsFinished</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming events intended for no leaf CPs.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>SymbolTable</Name>\n      <To><Input>IncomingSymbolTable</Input></To>\n    </IncomingUpstream>\n\n    <IncomingDownstream>\n      <Name>DownstreamNumBE</Name>\n      <To><Input>IncomingNumBE</Input></To>\n    </IncomingDownstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For @collector_name@, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>ThreadsFinished</Name>\n      <From><Output>OutgoingThreadsFinished</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>SymbolTable</Name>\n      <From><Output>OutgoingSymbolTable</Output></From>\n    </OutgoingUpstream>\n\n<!--\n-->\n    <OutgoingDownstream>\n      <Name>DownstreamNumBE</Name>\n      <From><Output>OutgoingNumBE</Output></From>\n    </OutgoingDownstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/mem/monitor.c": "/*******************************************************************************\n** Copyright (c) The Krell Institute 2011. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file\n *\n * Declaration and definition of the Mem collector's monitor runtime.\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"KrellInstitute/Messages/EventHeader.h\"\n#include \"KrellInstitute/Messages/LinkedObjectEvents.h\"\n#include \"KrellInstitute/Messages/OfflineEvents.h\"\n#include \"KrellInstitute/Messages/Mem.h\"\n#include \"KrellInstitute/Messages/Mem_data.h\"\n#include \"KrellInstitute/Messages/ToolMessageTags.h\"\n#include \"KrellInstitute/Messages/Thread.h\"\n#include \"KrellInstitute/Messages/ThreadEvents.h\"\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Monitor.h\"\n#include \"KrellInstitute/Services/Offline.h\"\n//#include \"KrellInstitute/Services/Unwind.h\"\n#include \"KrellInstitute/Services/Path.h\"\n#include \"KrellInstitute/Services/TLS.h\"\n#include \"MemTraceableFunctions.h\"\n\n#define true 1\n#define false 0\n\n#if !defined (TRUE)\n#define TRUE true\n#endif\n\n#if !defined (FALSE)\n#define FALSE false\n#endif\n\n/** Type defining the items stored in thread-local storage. */\ntypedef struct {\n\n    uint64_t time_started;\n\n    CBTF_EventHeader dso_header;   /**< Header for following dso blob. */\n    CBTF_EventHeader info_header;  /**< Header for following info blob. */\n    CBTF_Protocol_Offline_LinkedObjectGroup data; /**< Actual dso data blob. */\n\n    struct {\n\tCBTF_Protocol_Offline_LinkedObject objs[CBTF_OBJBufferSize];\n    } buffer;\n\n    CBTF_Protocol_ThreadNameGroup tgrp;\n    struct {\n        CBTF_Protocol_ThreadName tnames[4096];\n    } tgrpbuf;\n\n    int  dsoname_len;\n    int  started;\n    int  finished;\n    int  sent_data;\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    bool_t  mpi_init_done;\n    bool_t  connected_to_mrnet;\n#endif\n\n} TLS;\n\n#ifdef USE_EXPLICIT_TLS\n\n/**\n * Thread-local storage key.\n *\n * Key used for looking up our thread-local storage. This key <em>must</em>\n * be globally unique across the entire Open|SpeedShop code base.\n  */\n\nstatic const uint32_t TLSKey = 0x0000FEF4;\n\n#else\n\n/** Thread-local storage. */\nstatic __thread TLS the_tls;\n\n#endif\n\nextern void defer_trace(int);\nextern void set_mpi_flag(int);\n\n#if defined(CBTF_SERVICE_USE_MRNET)\nextern void connect_to_mrnet();\nextern void send_thread_state_changed_message();\n#endif\n\nvoid cbtf_offline_finish();\n\nvoid cbtf_offline_pause_sampling(CBTF_Monitor_Event_Type event)\n{\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    switch( event ) {\n\tcase CBTF_Monitor_MPI_pre_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_pre_init_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    defer_trace(1);\n\t    break;\n\tcase CBTF_Monitor_MPI_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_init_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    defer_trace(1);\n\t    break;\n\tcase CBTF_Monitor_MPI_post_comm_rank_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_post_com_rank_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    break;\n\tdefault:\n\t    break;\n    }\n#endif\n}\n\nvoid cbtf_offline_resume_sampling(CBTF_Monitor_Event_Type event)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    switch( event ) {\n\tcase CBTF_Monitor_MPI_pre_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_resume_sampling passed event CBTF_Monitor_MPI_pre_init_event\\n\");\n\t    }\n#endif\n\t    break;\n\tcase CBTF_Monitor_MPI_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_resume_sampling passed event CBTF_Monitor_MPI_init_event\\n\");\n\t    }\n#endif\n\t    tls->mpi_init_done = TRUE;\n\t    defer_trace(0);\n\t    break;\n\tcase CBTF_Monitor_MPI_post_comm_rank_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_resume_sampling passed event CBTF_Monitor_MPI_post_com_rank_event\\n\");\n\t    }\n#endif\n\t    if (!tls->connected_to_mrnet && ( monitor_mpi_comm_rank() >= 0 || tls->mpi_init_done)) {\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_resume_sampling CBTF_Monitor_MPI_post_com_rank_event connecting to mrnet!\\n\");\n\t    }\n#endif\n\t        connect_to_mrnet();\n\t\ttls->connected_to_mrnet = TRUE;\n\t        defer_trace(0);\n\t    }\n\t    break;\n\tdefault:\n\t    break;\n    }\n#endif\n}\n\nvoid cbtf_offline_sent_data(int sent_data)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    tls->sent_data = sent_data;\n}\n\nvoid cbtf_offline_send_dsos(TLS *tls)\n{\n\n    defer_trace(1);\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_EventSetSendToFile(&(tls->dso_header), \"mem\", \"cbtf-dsos\");\n    CBTF_Send(&(tls->dso_header),\n\t\t(xdrproc_t)xdr_CBTF_Protocol_Offline_LinkedObjectGroup,\n\t\t&(tls->data));\n    \n    /* Send the offline \"info\" blob */\n#ifndef NDEBUG\n    if (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n        fprintf(stderr,\"cbtf_offline_send_dsos SENDS DSOS for HOST %s, PID %d, POSIX_TID %lu\\n\",\n        tls->dso_header.host, tls->dso_header.pid, tls->dso_header.posix_tid);\n    }\n#endif\n\n#endif\n\n    tls->data.linkedobjects.linkedobjects_len = 0;\n    tls->dsoname_len = 0;\n    memset(tls->buffer.objs, 0, sizeof(tls->buffer.objs));\n    defer_trace(0);\n}\n\n/**\n * Start offline sampling.\n *\n * Starts sampling/tracing for the thread executing this function.\n * Writes descriptive information for the thread to the appropriate file and\n * calls the underlying collector specific start_sampling() function\n * with the environment-specified arguments.\n *\n * @param in_arguments    Encoded function arguments. Always null.\n */\nvoid cbtf_offline_start_sampling(const char* in_arguments)\n{\n    /* Create and access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = malloc(sizeof(TLS));\n    Assert(tls != NULL);\n    CBTF_SetTLS(TLSKey, tls);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    tls->mpi_init_done = FALSE;\n    tls->connected_to_mrnet = FALSE;\n#endif\n\n    CBTF_mem_start_sampling_args args;\n    char arguments[3 * sizeof(CBTF_mem_start_sampling_args)];\n\n    args.collector = 1;\n    CBTF_EncodeParameters(&args,\n\t\t\t    (xdrproc_t)xdr_CBTF_mem_start_sampling_args,\n\t\t\t    arguments);\n        \n    tls->time_started = CBTF_GetTime();\n\n    tls->dsoname_len = 0;\n    tls->data.linkedobjects.linkedobjects_len = 0;\n    tls->data.linkedobjects.linkedobjects_val = tls->buffer.objs;\n    memset(tls->buffer.objs, 0, sizeof(tls->buffer.objs));\n\n    /* Start sampling */\n    cbtf_offline_sent_data(0);\n    tls->finished = 0;\n    tls->started = 1;\n    mem_start_tracing(arguments);\n}\n\n\n\n/**\n * Stop offline sampling.\n *\n * Stops program counter (PC) sampling for the thread executing this function. \n * Calls mem_stop_sampling() and writes descriptive information for the\n * thread to the appropriate file.\n *\n * @param in_arguments    Encoded function arguments. Always null.\n */\nvoid cbtf_offline_stop_sampling(const char* in_arguments, const int finished)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    if (!tls) {\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n\t    fprintf(stderr,\"warn: cbtf_offline_stop_sampling has no TLS for %d\\n\",getpid());\n\t}\n#endif\n\treturn;\n    }\n\n    if (!tls->started) {\n\treturn;\n    }\n\n    defer_trace(1);\n\n    /* Stop sampling */\n    mem_stop_tracing(NULL);\n\n    tls->finished = finished;\n\n    if (finished && tls->sent_data) {\n\tcbtf_offline_finish();\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n\t    fprintf(stderr,\"cbtf_offline_stop_sampling FINISHED for %d, %lu\\n\",\n\t\ttls->dso_header.pid, tls->dso_header.posix_tid);\n\t}\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n\t     fprintf(stderr,\"cbtf_offline_stop_sampling %d, %lu calls send_thread_state_changed_message\\n\",\n\t\ttls->dso_header.pid, tls->dso_header.posix_tid);\n\t}\n#endif\n\tsend_thread_state_changed_message();\n\tCBTF_Waitfor_MRNet_Shutdown();\n#endif\n    }\n}\n\nvoid cbtf_offline_notify_event(CBTF_Monitor_Event_Type event)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n    switch( event ) {\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n\tcase CBTF_Monitor_MPI_pre_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_pre_init_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    break;\n\tcase CBTF_Monitor_MPI_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t         fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_init_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    break;\n\tcase CBTF_Monitor_MPI_post_comm_rank_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_notify_event CBTF_Monitor_MPI_post_comm_rank_event for rank %d\\n\",\n\t\t\tmonitor_mpi_comm_rank());\n\t    }\n\t    set_mpi_flag(1);\n#endif\n\t    break;\n#endif\n\tdefault:\n\t    break;\n    }\n}\n\nvoid cbtf_offline_finish()\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    if (!tls->finished) {\n\treturn;\n    }\n\n    defer_trace(1);\n\n    /* Initialize the offline \"info\" blob's header */\n    CBTF_EventHeader local_header;\n    CBTF_InitializeEventHeader(&local_header);\n    \n    /* Initialize the offline \"info\" blob */\n    CBTF_Protocol_Offline_Parameters info;\n    CBTF_InitializeParameters(&info);\n    info.collector = strdup(\"mem\");\n    const char* myexe = (const char*) CBTF_GetExecutablePath();\n    info.exename = strdup(myexe);\n    //info.rank = monitor_mpi_comm_rank();\n\n    /* Access the environment-specified arguments */\n    const char* mem_traced = getenv(\"OPENSS_MEM_TRACED\");\n\n    if (mem_traced != NULL && strcmp(mem_traced,\"\") != 0) {\n        info.traced = strdup(mem_traced);\n    } else {\n        info.traced = strdup(traceable);\n    }\n    \n    /* Send the offline \"info\" blob */\n#ifndef NDEBUG\n    if (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n        fprintf(stderr,\"cbtf_offline_stop_sampling SENDS INFO for HOST %s, PID %d, POSIX_TID %lu\\n\",\n        local_header.host, local_header.pid, local_header.posix_tid);\n    }\n#endif\n\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_EventSetSendToFile(&local_header, \"mem\", \"cbtf-info\");\n    CBTF_Send(&local_header, (xdrproc_t)xdr_CBTF_Protocol_Offline_Parameters, &info);\n#endif\n\n    /* Write the thread's initial address space to the appropriate file */\n    CBTF_GetDLInfo(getpid(), NULL);\n    if(tls->data.linkedobjects.linkedobjects_len > 0) {\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n           fprintf(stderr,\"cbtf_offline_stop_sampling SENDS OBJS for HOST %s, PID %d, POSIX_TID %lu\\n\",\n        \t   local_header.host, local_header.pid, local_header.posix_tid);\n\t}\n#endif\n#if !defined(CBTF_SERVICE_USE_MRNET)\n\tcbtf_offline_send_dsos(tls);\n#endif\n    }\n    defer_trace(0);\n}\n\n\n\n/**\n * Record a DSO operation.\n *\n * Writes information regarding a DSO being loaded or unloaded in the thread\n * to the appropriate file.\n *\n * @param dsoname      Name of the DSO's file.\n * @param begin        Beginning address at which this DSO was loaded.\n * @param end          Ending address at which this DSO was loaded.\n * @param is_dlopen    Boolean \"true\" if this DSO was just opened,\n *                     or \"false\" if it was just closed.\n */\nvoid cbtf_offline_record_dso(const char* dsoname,\n\t\t\tuint64_t begin, uint64_t end,\n\t\t\tuint8_t is_dlopen)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n\n    if (is_dlopen) {\n\tcbtf_offline_pause_sampling(0);\n    }\n\n    //fprintf(stderr,\"cbtf_offline_record_dso called for %s, is_dlopen = %d\\n\",dsoname, is_dlopen);\n\n    /* Initialize the offline \"dso\" blob's header */\n    CBTF_EventHeader local_header;\n    CBTF_InitializeEventHeader(&local_header);\n    memcpy(&tls->dso_header, &local_header, sizeof(CBTF_EventHeader));\n\n    CBTF_Protocol_Offline_LinkedObject objects;\n\n    if (is_dlopen) {\n\tobjects.time_begin = CBTF_GetTime();\n    } else {\n\tobjects.time_begin = tls->time_started;\n    }\n    objects.time_end = is_dlopen ? -1ULL : CBTF_GetTime();\n    \n\n    /* Initialize the offline \"dso\" blob */\n    objects.objname = strdup(dsoname);\n    objects.addr_begin = begin;\n    objects.addr_end = end;\n    objects.is_open = is_dlopen;\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n    CBTF_Protocol_ThreadName tname;\n    tname.experiment = 0;\n    tname.host = strdup(local_header.host);\n    tname.pid = local_header.pid;\n    tname.has_posix_tid = true;\n    tname.posix_tid = local_header.posix_tid;\n\n    tls->tgrp.names.names_len = 0;\n    tls->tgrp.names.names_val = tls->tgrpbuf.tnames;\n    memset(tls->tgrpbuf.tnames, 0, sizeof(tls->tgrpbuf.tnames));\n\n    memcpy(&(tls->tgrpbuf.tnames[tls->tgrp.names.names_len]),\n           &tname, sizeof(tname));\n    tls->tgrp.names.names_len++;\n\n\n// CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT\n// xdr_CBTF_Protocol_LoadedLinkedObject\n    CBTF_Protocol_LoadedLinkedObject message;\n    memset(&message, 0, sizeof(message));\n\n    message.threads = tls->tgrp;\n    message.time = objects.time_begin;\n    message.range.begin =  begin;\n    message.range.end = end;\n\n    CBTF_Protocol_FileName dsoFilename;\n    dsoFilename.path = strdup(dsoname);\n\n    message.linked_object = dsoFilename;\n\n    if (strcmp(CBTF_GetExecutablePath(),dsoname)) {\n\tmessage.is_executable = false;\n    } else {\n\tmessage.is_executable = true;\n    }\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n#ifndef NDEBUG\n    if (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n            fprintf(stderr,\n\t\t\"cbtf_offline_record_dso SENDS CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT for dso %s from %s %d %lu\\n\",\n        \tdsoFilename.path, tls->dso_header.host, tls->dso_header.pid, tls->dso_header.posix_tid);\n    }\n#endif\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    if (tls->connected_to_mrnet) {\n        CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT,\n                  (xdrproc_t) xdr_CBTF_Protocol_LoadedLinkedObject, &message);\n    }\n#else\n    CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT,\n                  (xdrproc_t) xdr_CBTF_Protocol_LoadedLinkedObject, &message);\n#endif\n#endif\n\n    int dsoname_len = strlen(dsoname);\n    int newsize = (tls->data.linkedobjects.linkedobjects_len *\n\t\t   sizeof(objects)) + (tls->dsoname_len + dsoname_len);\n\n\n    if(newsize > CBTF_OBJBufferSize) {\n#if !defined(CBTF_SERVICE_USE_MRNET)\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n            fprintf(stderr,\"cbtf_offline_record_dso SENDS OBJS for HOST %s, PID %d, POSIX_TID %lu\\n\",\n        \t   tls->dso_header.host, tls->dso_header.pid, tls->dso_header.posix_tid);\n\t}\n#endif\n\tcbtf_offline_send_dsos(tls);\n#endif\n    }\n\n    memcpy(&(tls->buffer.objs[tls->data.linkedobjects.linkedobjects_len]),\n           &objects, sizeof(objects));\n    tls->data.linkedobjects.linkedobjects_len++;\n    tls->dsoname_len += dsoname_len;\n\n    if (is_dlopen) {\n\tcbtf_offline_resume_sampling(0);\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/mem/mem.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>mem</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>mem_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>mem_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For mem, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For mem, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/pcsamp/pcsamp.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>pcsamp</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>pcsamp_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>AggregationPlugin.so</Plugin>\n      <Plugin>LinkedObjectPlugin.so</Plugin>\n      <Plugin>MRNetConvertorsPlugin.so</Plugin>\n      <Plugin>SymbolPlugin.so</Plugin>\n      <Plugin>ThreadPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>pcsamp_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>AggregationPlugin.so</Plugin>\n      <Plugin>LinkedObjectPlugin.so</Plugin>\n      <Plugin>MRNetConvertorsPlugin.so</Plugin>\n      <Plugin>SymbolPlugin.so</Plugin>\n      <Plugin>ThreadPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For pcsamp, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For pcsamp, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/pcsamp/monitor.c": "/*******************************************************************************\n** Copyright (c) The Krell Institute 2007-2011. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file\n *\n * Declaration and definition of the PC sampling collector's offline runtime.\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"KrellInstitute/Messages/EventHeader.h\"\n#include \"KrellInstitute/Messages/LinkedObjectEvents.h\"\n#include \"KrellInstitute/Messages/OfflineEvents.h\"\n#include \"KrellInstitute/Messages/PCSamp.h\"\n#include \"KrellInstitute/Messages/ToolMessageTags.h\"\n#include \"KrellInstitute/Messages/Thread.h\"\n#include \"KrellInstitute/Messages/ThreadEvents.h\"\n#include \"KrellInstitute/Services/Common.h\"\n#include \"KrellInstitute/Services/Monitor.h\"\n#include \"KrellInstitute/Services/Offline.h\"\n#include \"KrellInstitute/Services/Path.h\"\n#include \"KrellInstitute/Services/Time.h\"\n#include \"KrellInstitute/Services/TLS.h\"\n\n#define true 1\n#define false 0\n\n#if !defined (TRUE)\n#define TRUE true\n#endif\n\n#if !defined (FALSE)\n#define FALSE false\n#endif\n\n/** Type defining the items stored in thread-local storage. */\ntypedef struct {\n\n    uint64_t time_started;\n\n    CBTF_EventHeader dso_header;   /**< Header for following dso blob. */\n    CBTF_EventHeader info_header;  /**< Header for following info blob. */\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_Protocol_Offline_LinkedObjectGroup data; /**< Actual dso data blob. */\n\n    struct {\n\tCBTF_Protocol_Offline_LinkedObject objs[CBTF_MAXLINKEDOBJECTS];\n    } buffer;\n#else\n    CBTF_Protocol_LinkedObjectGroup data; /**< Actual dso data blob. */\n\n    struct {\n\tCBTF_Protocol_LinkedObject objs[CBTF_MAXLINKEDOBJECTS];\n    } buffer;\n\n    CBTF_Protocol_ThreadNameGroup tgrp;\n    CBTF_Protocol_ThreadName tname;\n\n    struct {\n        CBTF_Protocol_ThreadName tnames[4096];\n    } tgrpbuf;\n#endif\n\n\n\n    int  dsoname_len;\n    int  started;\n    int  finished;\n    int  sent_data;\n\n    // marker if ANY collector is connected to mrnet.\n    // this applies to the non mrnet builds.\n    short  connected_to_mrnet;\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    bool_t  mpi_init_done;\n#endif\n\n} TLS;\n\n#ifdef USE_EXPLICIT_TLS\n\n/**\n * Thread-local storage key.\n *\n * Key used for looking up our thread-local storage. This key <em>must</em>\n * be globally unique across the entire Open|SpeedShop code base.\n  */\n\nstatic const uint32_t TLSKey = 0x0000FEF3;\n\n#else\n\n/** Thread-local storage. */\nstatic __thread TLS the_tls;\n\n#endif\n\n// external functions for all collection types.\nextern void cbtf_offline_service_start_timer();\nextern void cbtf_offline_service_stop_timer();\nextern void set_mpi_flag(int);\nextern void started_process();\n\n// external functions for using mrnet.\n#if defined(CBTF_SERVICE_USE_MRNET)\nextern void connect_to_mrnet();\nextern void send_thread_state_changed_message();\nextern void send_process_created_message();\nextern void send_attached_to_threads_message();\n#endif\n\n// No-op for non mrnet builds.\nvoid cbtf_offline_waitforshutdown() {\n#if defined(CBTF_SERVICE_USE_MRNET)\n\tCBTF_Waitfor_MRNet_Shutdown();\n#endif\n}\n\n// non mrnet builds just refurn false here..\nshort cbtf_connected_to_mrnet() {\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n    return tls->connected_to_mrnet;\n}\n\n\n// forward declarations.\nvoid cbtf_offline_finish();\nvoid cbtf_send_info();\nvoid cbtf_record_dsos();\n\nvoid cbtf_offline_pause_sampling(CBTF_Monitor_Event_Type event)\n{\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    switch( event ) {\n\tcase CBTF_Monitor_MPI_pre_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_pre_init_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    cbtf_offline_service_stop_timer();\n\t    break;\n\tcase CBTF_Monitor_MPI_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_init_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    break;\n\tcase CBTF_Monitor_MPI_post_comm_rank_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_post_com_rank_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    break;\n\tdefault:\n\t    break;\n    }\n#endif\n}\n\nvoid cbtf_offline_resume_sampling(CBTF_Monitor_Event_Type event)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    switch( event ) {\n\tcase CBTF_Monitor_MPI_pre_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_resume_sampling passed event CBTF_Monitor_MPI_pre_init_event\\n\");\n\t    }\n#endif\n\t    break;\n\tcase CBTF_Monitor_MPI_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_resume_sampling passed event CBTF_Monitor_MPI_init_event\\n\");\n\t    }\n#endif\n\t    tls->mpi_init_done = TRUE;\n\t    break;\n\tcase CBTF_Monitor_MPI_post_comm_rank_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\n\t\t\"offline_resume_sampling passed event CBTF_Monitor_MPI_post_com_rank_event\\n\");\n\t    }\n#endif\n\t    if (!tls->connected_to_mrnet && ( monitor_mpi_comm_rank() >= 0 || tls->mpi_init_done)) {\n#ifndef NDEBUG\n\t\tif (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t            fprintf(stderr,\n\t\t    \"offline_resume_sampling CBTF_Monitor_MPI_post_com_rank_event connect to mrnet!\\n\");\n\t\t}\n#endif\n\t        connect_to_mrnet();\n\t\ttls->connected_to_mrnet = TRUE;\n                init_process_thread();\n                send_process_created_message();\n                send_attached_to_threads_message();\n\t\tcbtf_send_info();\n\t\tcbtf_record_dsos();\n\t\tcbtf_offline_service_start_timer();\n\t    }\n\t    break;\n\tdefault:\n\t    break;\n    }\n#endif\n}\n\nvoid cbtf_offline_sent_data(int sent_data)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    tls->sent_data = sent_data;\n}\n\nvoid cbtf_offline_send_dsos(TLS *tls)\n{\n    /* Send the offline \"dsos\" blob or message */\n#ifndef NDEBUG\n    if (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n        fprintf(stderr,\"cbtf_offline_send_dsos SENDS DSOS for HOST %s, PID %d, POSIX_TID %lu\\n\",\n        tls->dso_header.host, tls->dso_header.pid, tls->dso_header.posix_tid);\n    }\n#endif\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_EventSetSendToFile(&(tls->dso_header), \"pcsamp\", \"cbtf-dsos\");\n    CBTF_Send(&(tls->dso_header),\n\t\t(xdrproc_t)xdr_CBTF_Protocol_Offline_LinkedObjectGroup,\n\t\t&(tls->data));\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    tls->data.thread = tls->tname;\n    if (tls->connected_to_mrnet) {\n        CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP,\n                  (xdrproc_t) xdr_CBTF_Protocol_LinkedObjectGroup,&(tls->data));\n    }\n#elif defined(CBTF_SERVICE_USE_MRNET)\n    tls->data.thread = tls->tname;\n    if (tls->connected_to_mrnet) {\n        CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP,\n                  (xdrproc_t) xdr_CBTF_Protocol_LinkedObjectGroup,&(tls->data));\n    }\n#endif\n\n    tls->data.linkedobjects.linkedobjects_len = 0;\n    tls->dsoname_len = 0;\n    memset(tls->buffer.objs, 0, sizeof(tls->buffer.objs));\n}\n\n/**\n * Start offline sampling.\n *\n * Starts program counter (PC) sampling for the thread executing this function.\n * Writes descriptive information for the thread to the appropriate file and\n * calls pcsamp_start_sampling() with the environment-specified arguments.\n *\n * @param in_arguments    Encoded function arguments. Always null.\n */\nvoid cbtf_offline_start_sampling(const char* in_arguments)\n{\n    /* Create and access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = malloc(sizeof(TLS));\n    Assert(tls != NULL);\n    CBTF_SetTLS(TLSKey, tls);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    tls->connected_to_mrnet = FALSE;\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    tls->mpi_init_done = FALSE;\n#endif\n\n    CBTF_pcsamp_start_sampling_args args;\n    char arguments[3 * sizeof(CBTF_pcsamp_start_sampling_args)];\n\n    /* Access the environment-specified arguments */\n    const char* sampling_rate = getenv(\"CBTF_PCSAMP_RATE\");\n\n    /* Encode those arguments for pcsamp_start_sampling() */\n    args.sampling_rate = (sampling_rate != NULL) ? atoi(sampling_rate) : 100;\n    args.collector = 1;\n    CBTF_EncodeParameters(&args,\n\t\t\t    (xdrproc_t)xdr_CBTF_pcsamp_start_sampling_args,\n\t\t\t    arguments);\n        \n    tls->time_started = CBTF_GetTime();\n\n    tls->dsoname_len = 0;\n    tls->data.linkedobjects.linkedobjects_len = 0;\n    tls->data.linkedobjects.linkedobjects_val = tls->buffer.objs;\n    memset(tls->buffer.objs, 0, sizeof(tls->buffer.objs));\n\n    /* Start sampling */\n    cbtf_offline_sent_data(0);\n    tls->finished = 0;\n    tls->started = 1;\n#if defined(CBTF_SERVICE_USE_MRNET) && !defined(CBTF_SERVICE_USE_MRNET_MPI)\n /* FIXME: should query this from collector.c where connection\n * is made.\n */\n    connect_to_mrnet();\n    tls->connected_to_mrnet = TRUE;\n#endif\n    cbtf_timer_service_start_sampling(arguments);\n}\n\n\n\n/**\n * Stop offline sampling.\n *\n * Stops program counter (PC) sampling for the thread executing this function. \n * Calls pcsamp_stop_sampling() and writes descriptive information for the\n * thread to the appropriate file.\n *\n * @param in_arguments    Encoded function arguments. Always null.\n */\nvoid cbtf_offline_stop_sampling(const char* in_arguments, const int finished)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n\n    if (!tls) {\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n\t    fprintf(stderr,\"warn: cbtf_offline_stop_sampling has no TLS for %d\\n\",getpid());\n\t}\n#endif\n\treturn;\n    }\n\n    if (!tls->started) {\n\treturn;\n    }\n\n    /* Stop sampling */\n    cbtf_timer_service_stop_sampling(NULL);\n\n    tls->finished = finished;\n\n    if (finished && tls->sent_data) {\n\t// FIXME: is this cbtf_offline_finish for fileio?\n\t//cbtf_offline_finish();\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n\t    fprintf(stderr,\"cbtf_offline_stop_sampling FINISHED for %d, %lu\\n\",\n\t\ttls->dso_header.pid, tls->dso_header.posix_tid);\n\t}\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n\t     fprintf(stderr,\"cbtf_offline_stop_sampling %d, %lu calls send_thread_state_changed_message\\n\",\n\t\ttls->dso_header.pid, tls->dso_header.posix_tid);\n\t}\n#endif\n#endif\n    }\n}\n\nvoid cbtf_offline_notify_event(CBTF_Monitor_Event_Type event)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n    switch( event ) {\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n\tcase CBTF_Monitor_MPI_pre_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_pre_init_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    break;\n\tcase CBTF_Monitor_MPI_init_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t         fprintf(stderr,\"offline_pause_sampling passed event CBTF_Monitor_MPI_init_event\\n\");\n\t    }\n#endif\n\t    set_mpi_flag(1);\n\t    break;\n\tcase CBTF_Monitor_MPI_post_comm_rank_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MRNET_MPI\") != NULL) {\n\t        fprintf(stderr,\"offline_notify_event CBTF_Monitor_MPI_post_comm_rank_event for rank %d\\n\",\n\t\t\tmonitor_mpi_comm_rank());\n\t    }\n\t    set_mpi_flag(1);\n#endif\n\t    break;\n#endif\n\tcase CBTF_Monitor_init_process_event:\n#ifndef NDEBUG\n\t    if (getenv(\"CBTF_DEBUG_MONITOR_SERVICE\") != NULL) {\n\t        fprintf(stderr,\"offline_notify_event CBTF_Monitor_MPI_init_process_event for pid %d\\n\",\n\t\t\tgetpid());\n\t    }\n#endif\n\t    started_process();\n\t    break;\n\tdefault:\n\t    break;\n    }\n}\n\nvoid cbtf_offline_finish()\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    if (!tls->finished) {\n\treturn;\n    }\n\n    cbtf_send_info();\n    cbtf_record_dsos();\n}\n\nvoid cbtf_send_info()\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    /* Initialize the offline \"info\" blob's header */\n    CBTF_EventHeader local_header;\n    CBTF_InitializeEventHeader(&local_header);\n    \n    /* Initialize the offline \"info\" blob */\n    CBTF_Protocol_Offline_Parameters info;\n    CBTF_InitializeParameters(&info);\n    info.collector = strdup(\"pcsamp\");\n    const char* myexe = (const char*) CBTF_GetExecutablePath();\n    info.exename = strdup(myexe);\n    //info.rank = monitor_mpi_comm_rank();\n\n    /* Access the environment-specified arguments */\n    const char* sampling_rate = getenv(\"CBTF_PCSAMP_RATE\");\n    info.rate = (sampling_rate != NULL) ? atoi(sampling_rate) : 100;\n    \n// FIXME: does mrnet collection handle this yet?\n    /* Send the offline \"info\" blob */\n#ifndef NDEBUG\n    if (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n        fprintf(stderr,\"cbtf_send_info SENDS INFO for HOST %s, PID %d, POSIX_TID %lu\\n\",\n        local_header.host, local_header.pid, local_header.posix_tid);\n    }\n#endif\n\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_EventSetSendToFile(&local_header, \"pcsamp\", \"cbtf-info\");\n    CBTF_Send(&local_header, (xdrproc_t)xdr_CBTF_Protocol_Offline_Parameters, &info);\n#endif\n}\n\nvoid cbtf_record_dsos()\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n    /* Initialize header */\n    CBTF_EventHeader local_header;\n    CBTF_InitializeEventHeader(&local_header);\n\n    /* Write the thread's initial address space to the appropriate buffer */\n    CBTF_GetDLInfo(getpid(), NULL);\n    if(tls->data.linkedobjects.linkedobjects_len > 0) {\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n           fprintf(stderr,\"cbtf_record_dsos HAS OBJS for HOST %s, PID %d, POSIX_TID %lu\\n\",\n        \t   local_header.host, local_header.pid, local_header.posix_tid);\n\t}\n#endif\n\tcbtf_offline_send_dsos(tls);\n    }\n\n}\n\n\n/**\n * Record a DSO operation.\n *\n * Writes information regarding a DSO being loaded or unloaded in the thread\n * to the appropriate file.\n *\n * @param dsoname      Name of the DSO's file.\n * @param begin        Beginning address at which this DSO was loaded.\n * @param end          Ending address at which this DSO was loaded.\n * @param is_dlopen    Boolean \"true\" if this DSO was just opened,\n *                     or \"false\" if it was just closed.\n */\nvoid cbtf_offline_record_dso(const char* dsoname,\n\t\t\tuint64_t begin, uint64_t end,\n\t\t\tuint8_t is_dlopen)\n{\n    /* Access our thread-local storage */\n#ifdef USE_EXPLICIT_TLS\n    TLS* tls = CBTF_GetTLS(TLSKey);\n#else\n    TLS* tls = &the_tls;\n#endif\n    Assert(tls != NULL);\n\n\n    if (is_dlopen) {\n\tcbtf_offline_pause_sampling(0);\n    }\n\n    //fprintf(stderr,\"cbtf_offline_record_dso called for %s, is_dlopen = %d\\n\",dsoname, is_dlopen);\n\n    /* Initialize the offline \"dso\" blob's header */\n    CBTF_EventHeader local_header;\n    CBTF_InitializeEventHeader(&local_header);\n    memcpy(&tls->dso_header, &local_header, sizeof(CBTF_EventHeader));\n\n#if defined(CBTF_SERVICE_USE_FILEIO)\n    CBTF_Protocol_Offline_LinkedObject objects;\n\n    if (is_dlopen) {\n\tobjects.time_begin = CBTF_GetTime();\n    } else {\n\tobjects.time_begin = tls->time_started;\n    }\n    objects.time_end = is_dlopen ? -1ULL : CBTF_GetTime();\n    \n\n    /* Initialize the offline \"dso\" blob */\n    objects.objname = strdup(dsoname);\n    objects.addr_begin = begin;\n    objects.addr_end = end;\n    objects.is_open = is_dlopen;\n\n#else\n    /* Initialize the \"dso\" message */\n    /* this is only for the initial dsos loaded into thread\n     * and not intended for dlopen/dlclose callbacks\n     */ \n    CBTF_Protocol_LinkedObject objects;\n\n    objects.time_begin = CBTF_GetTime();\n    objects.time_end = -1ULL;\n\n    CBTF_Protocol_FileName dsoFilename;\n    dsoFilename.path = strdup(dsoname);\n    //objects.linked_object = strdup(dsoname);\n    objects.linked_object = dsoFilename;\n\n    objects.range.begin = begin;\n    objects.range.end = end;\n\n    if (strcmp(CBTF_GetExecutablePath(),dsoname)) {\n\tobjects.is_executable = false;\n    } else {\n\tobjects.is_executable = true;\n    }\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET)\n    /*\n     * intended ONLY for dlopen/dlclose callbacks\n     */\n    CBTF_Protocol_ThreadName tname;\n    tname.experiment = 0;\n    tname.host = strdup(local_header.host);\n    tname.pid = local_header.pid;\n    tname.has_posix_tid = true;\n    tname.posix_tid = local_header.posix_tid;\n    memcpy(&(tls->tname), &tname, sizeof(tname));\n\n    tls->tgrp.names.names_len = 0;\n    tls->tgrp.names.names_val = tls->tgrpbuf.tnames;\n    memset(tls->tgrpbuf.tnames, 0, sizeof(tls->tgrpbuf.tnames));\n\n    memcpy(&(tls->tgrpbuf.tnames[tls->tgrp.names.names_len]),\n           &tname, sizeof(tname));\n    tls->tgrp.names.names_len++;\n\n\n    /*\n     * intended ONLY for dlopen/dlclose callbacks\n     * Message tag: CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT\n     * xdr_CBTF_Protocol_LoadedLinkedObject\n     */\n    CBTF_Protocol_LoadedLinkedObject message;\n    memset(&message, 0, sizeof(message));\n\n    message.threads = tls->tgrp;\n    message.time = objects.time_begin;\n    message.range.begin =  begin;\n    message.range.end = end;\n    message.linked_object = dsoFilename;\n\n    if (strcmp(CBTF_GetExecutablePath(),dsoname)) {\n\tmessage.is_executable = false;\n    } else {\n\tmessage.is_executable = true;\n    }\n\n\n//FIXME: verify that mrnet collections works for dlopen/dlclose.\n#if 0\n#if defined(CBTF_SERVICE_USE_MRNET)\n#ifndef NDEBUG\n    if (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n            fprintf(stderr,\n\t\t\"cbtf_offline_record_dso SENDS CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT for dso %s from %s %d %lu\\n\",\n        \tdsoFilename.path, tls->dso_header.host, tls->dso_header.pid, tls->dso_header.posix_tid);\n    }\n#endif\n#endif\n\n#if defined(CBTF_SERVICE_USE_MRNET_MPI)\n    if (tls->connected_to_mrnet) {\n        CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT,\n                  (xdrproc_t) xdr_CBTF_Protocol_LoadedLinkedObject, &message);\n    }\n#else\n    CBTF_MRNet_Send( CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT,\n                  (xdrproc_t) xdr_CBTF_Protocol_LoadedLinkedObject, &message);\n#endif\n#endif\n#endif\n\n    int dsoname_len = strlen(dsoname);\n    int newsize = (tls->data.linkedobjects.linkedobjects_len * sizeof(objects))\n\t\t  + (tls->dsoname_len + dsoname_len);\n\n    if(newsize > CBTF_MAXLINKEDOBJECTS * sizeof(objects)) {\n#ifndef NDEBUG\n\tif (getenv(\"CBTF_DEBUG_OFFLINE_COLLECTOR\") != NULL) {\n            fprintf(stderr,\"cbtf_offline_record_dso BUFFERS OBJS for HOST %s, PID %d, POSIX_TID %lu\\n\",\n        \t   tls->dso_header.host, tls->dso_header.pid, tls->dso_header.posix_tid);\n\t}\n#endif\n\tcbtf_offline_send_dsos(tls);\n    }\n\n\n// FIXME: DEBUG.\n#if defined(CBTF_SERVICE_USE_MRNET) && 0\n    fprintf(stderr,\"RECORD OBJ to tls->buffer.objs INDEX %d\\n\",\n\ttls->data.linkedobjects.linkedobjects_len);\n    fprintf(stderr,\"RECORD OBJ objname = %s\\n\",objects.linked_object);\n    fprintf(stderr,\"RECORD OBJ addresses = %#lx,%#lx\\n\",objects.range.begin, objects.range.end);\n    fprintf(stderr,\"RECORD OBJ times = %lu,%lu\\n\",objects.time_begin, objects.time_end);\n#endif\n\n    memcpy(&(tls->buffer.objs[tls->data.linkedobjects.linkedobjects_len]),\n           &objects, sizeof(objects));\n    tls->data.linkedobjects.linkedobjects_len++;\n    tls->dsoname_len += dsoname_len;\n\n    if (is_dlopen) {\n\tcbtf_offline_resume_sampling(0);\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/io/io.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2014 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>io</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>io_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>io_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For io, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For io, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/io/iot.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>iot</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>iot_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>iot_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For iot, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For iot, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/io/iop.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>iop</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>iop_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>iop_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For iop, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For iop, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/hwcsamp/hwcsamp.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>hwcsamp</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>hwcsamp_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>hwcsamp_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For hwcsamp, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For hwcsamp, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/mpi/mpit.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2014 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>mpit</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>mpit_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>mpit_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For mpit, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For mpit, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/mpi/mpip.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>mpip</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>mpip_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>mpip_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For mpip, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For mpip, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/mpi/mpi.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>mpi</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>mpi_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>mpi_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For mpi, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For mpi, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/pthreads/pthreads.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>pthreads</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>pthreads_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>pthreads_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For pthreads, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For pthreads, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/hwctime/hwctime.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>hwctime</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>hwctime_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>hwctime_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For hwctime, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For hwctime, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/hwc/hwc.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>hwc</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>hwc_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>hwc_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For hwc, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For hwc, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/collectors/usertime/usertime.xml.in": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) 2011-2015 Krell Institute. All Rights Reserved.\n    \nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or (at your option)\nany later version.\n    \nThis library is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\ndetails.\n    \nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-->\n\n<MRNet xmlns=\"http://www.krellinst.org/CBTF/MRNet.xsd\">\n\n  <Type>usertime</Type>\n  <Version>1.0.0</Version>\n\n<!--\n   Declare streams used by this distributed component to communicate\n   within xml component.\n-->\n\n<!--\n  Stream representing threads that have been attached to a\n  a collection service.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n    <Tag>1101</Tag>\n  </Stream>\n<!--\n  Stream representing a process created event.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n    <Tag>1104</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been loaded\n  in to a process or thread.  This is intended to handle dlopen\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n    <Tag>1116</Tag>\n  </Stream>\n<!--\n  Stream representing a linked object (dso) has been unloaded\n  by a process or thread.  This is intended to handle dlclose\n  events.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_UNLOADED_LINKED_OBJECT</Name>\n    <Tag>1126</Tag>\n  </Stream>\n<!--\n  Stream representing a group linked objects (dso's and executable).\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n    <Tag>1128</Tag>\n  </Stream>\n<!--\n  Stream used to send performance data blobs for\n  recording in a database or further processing.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n    <Tag>10000</Tag>\n  </Stream>\n<!--\n  Stream to send thread state changed messages.\n-->\n  <Stream>\n    <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n    <Tag>1124</Tag>\n  </Stream>\n\n  <Input>\n    <Name>numBE</Name>\n    <To><Input>numBackends</Input></To>\n  </Input>\n\n<!--\n   Declare output of this distributed component. Used to communicate\n   data back to a tool client that registers this xml component and\n   has inputs to handle the datum from any of these outputs. \n-->\n\n<!--\n  FIXME. This output needs a descriptive name.  It currently\n  sends the notification that all threads are finished.\n-->\n  <Output>\n      <Name>threads_finished</Name>\n      <From><Output>threads_finished_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send process creation message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>created_process_xdr_output</Name>\n      <From><Output>created_process_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send attached to threads  message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>attached_to_threads_xdr_output</Name>\n      <From><Output>attached_threads_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send threads  state changed message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>threads_state_changed_xdr_output</Name>\n      <From><Output>threads_state_changed_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send loaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>loaded_linkedobject_xdr_output</Name>\n      <From><Output>loaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send unloaded linked object message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>unloaded_linkedobject_xdr_output</Name>\n      <From><Output>unloaded_linkedobject_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send linked objects initially loaded in to a process or thread. This\n  represents the addressspace in terms of time and address range for each\n  linkedobject.\n  The time interval is represented by the time recorded when the\n  process/thread started and the end time is expressed as the\n  largest time value that can be expressed.\n-->\n  <Output>\n      <Name>linkedobjectgroup_xdr_output</Name>\n      <From><Output>linkedobjectgroup_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send performance data xdr blob message to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>perfdata_xdr_output</Name>\n      <From><Output>perfdata_xdr_output_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send addressbuffer to a client tool that has resistered\n  this xml component and handles this message.\n-->\n  <Output>\n      <Name>addressbuffer_output</Name>\n      <From><Output>addressbuffer_from_frontend</Output></From>\n  </Output>\n\n  <Output>\n      <Name>linkedobjectentryvec_output</Name>\n      <From><Output>linkedobjectentryvec_from_frontend</Output></From>\n  </Output>\n\n<!--\n  Send symboltable message to a client tool that has resistered\n  this xml component and handles this message.\n  <Output>\n      <Name>symboltable_xdr_output</Name>\n      <From><Output>symboltable_xdr_output_from_frontend</Output></From>\n  </Output>\n-->\n \n  <Frontend>\n\n<!--\n     The operations done in this network are intended to run only on the Frontend.\n-->\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n\n      <Type>usertime_Frontend</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The Frontend AddressAggregator component.\n-->\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Frontend LinkedObject component.  The operations done\n     essentially pass on linkedobject datum to a client tool.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n-->\n\n<!--\n     The ThreadEventComponent component.  The operations done in component\n     network essentially pass on thread related events to a client tool.\n     * attached threads\n     * attached threads that have terminated.\n     This component also has a connection to the Aggregator component\n     to pass the list of currently attached threads.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n      <Input>\n        <Name>numBackends</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>numBE</Input>\n        </To>\n      </Input>\n\n<!--\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n-->\n\n<!--\n    Input to handle incoming performance data blobs.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>pass_cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming aggregated addressbuffers.  These are\n    aggregated by this FrontEnd network and a final buffer is sent\n    to a client tool.\n-->\n      <Input>\n        <Name>IncomingBuffers</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>addressBuffer</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingLoadedLinkedObject</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>loaded</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming loaded linkedobject group events.  These are\n    passed on untouched by this FrontEnd network to a client tool once\n    all threads that have attached have sent this message.\n-->\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming thread state changed events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    In addition, this input handler watches for terminated state and keeps\n    a count of terminated threads.\n-->\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n<!--\n    Input to handle incoming created process events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n    TODO: this input is not needed for OSS collection.\n-->\n      <Input>\n        <Name>IncomingCreatedProcess</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>createdprocess</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLeafCP</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>leafCPnumBE</Input>\n        </To>\n      </Input>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>leafCPnumBE</Input>\n        </To>\n      </Connection>\n\n      <Input>\n        <Name>IncomingMaxFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>maxfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingMinFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>minfunctionvalues</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingAvgFunctionValues</Name>\n        <To>\n          <Name>ResolveSymbols</Name>\n          <Input>avgfunctionvalues</Input>\n        </To>\n      </Input>\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n     TODO: this message currently is connected  internally to other components\n     within this Frontend component network. Ie. it is not sent across the\n     broader mrnet component network (off node) and would require an mrnet\n     converter to do so..\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\nthe following symbol related code is not in use in the Frontend.\nit is here as an example of resolving symbols in the Frontend.\n-->\n<!--\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notification that all attached threads known at this component level\n     have terminated and the ThreadEventComponent can finish any remaining\n     work.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>LeafCP_numBE</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>leafCP_numBE</Input>\n        </To>\n      </Connection>\n-->\n\n<!--\n     FIXME: need a descriptive name for this output.\n     Currently this sends the client tool notification that all\n     threads have terminated.\n-->\n      <Output>\n         <Name>threads_finished_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n         </From>\n      </Output>\n\n<!--\n     Output created process message to client tool that has registered\n     this distributed xml component and handles this meesage.\n     TODO: this is not in use by OSS at this time (4-29-2014)\n-->\n      <Output>\n         <Name>created_process_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>CreatedProcess_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output attached to threads message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>attached_threads_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output threads state changed message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>threads_state_changed_xdr_output_from_frontend</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>loaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>loaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output unloaded linkedobject message to client tool that has registered\n     this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>unloaded_linkedobject_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>unloaded_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output loaded linkedobject group message to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n         <Name>linkedobjectgroup_xdr_output_from_frontend</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n<!--\n     Output performance data blob messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>perfdata_xdr_output_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n<!--\n     Output addressbuffer messages to client tool that has\n     registered this distributed xml component and handles this meesage.\n-->\n      <Output>\n        <Name>addressbuffer_from_frontend</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     TODO: oss cbtf instrumentor knows about this for now.\n-->\n      <Output>\n        <Name>linkedobjectentryvec_from_frontend</Name>\n        <From>\n          <Name>LinkedObject</Name>\n          <Output>linkedobjectvec_out</Output>\n        </From>\n      </Output>\n\n<!--\n      <Output>\n        <Name>symboltable_xdr_output_from_frontend</Name>\n        <From>\n          <Name>ResolveSymbols</Name>\n          <Output>symboltable_xdr_out</Output>\n        </From>\n      </Output>\n-->\n\n    </Network>\n\n    <IncomingUpstream>\n      <Name>LeafCP</Name>\n      <To><Input>IncomingLeafCP</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming addressbuffers.\n-->\n    <IncomingUpstream>\n      <Name>Buffers</Name>\n      <To><Input>IncomingBuffers</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LOADED_LINKED_OBJECT</Name>\n      <To><Input>IncomingLoadedLinkedObject</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n<!--\n    Incoming created process events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_CREATED_PROCESS</Name>\n      <To><Input>IncomingCreatedProcess</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Frontend stream used to pass incoming perfromance data blobs\n    on to the actual client to be recorded in a database or\n    processed further by the client as desired.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n \n    <IncomingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <To><Input>IncomingMaxFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>MinFunctionValues</Name>\n      <To><Input>IncomingMinFunctionValues</Input></To>\n    </IncomingUpstream>\n\n    <IncomingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <To><Input>IncomingAvgFunctionValues</Input></To>\n    </IncomingUpstream>\n\n  </Frontend>\n\n<!--\n   This filter is intended to run on the Leaf CP nodes only.\n   It's primary purposes: \n   * handle incoming performance data blobs\n   * aggregate pc addresses and their sample counts and\n     send that aggregation upstream.\n   * aggregate thread events\n   * aggregate linkedobject events\n-->\n  <Filter>\n \n<!--\n    Run this filter only on CP's that are connected to a lightweight mrnet BE.\n-->\n    <Depth>\n\t<LeafRelative>\n\t    <Offset>1</Offset>\n\t</LeafRelative>\n    </Depth>\n\n    <Network xmlns=\"http://www.krellinst.org/CBTF/Network\">\n      <Type>usertime_Filter</Type>\n      <Version>1.0.0</Version>\n\n      <SearchPath>@component_location@</SearchPath>\n\n      <Plugin>CollectionPlugin.so</Plugin>\n\n<!--\n     The AddressAggregator component.  The operations done in this filter\n     are intended to run only at the leaf CP's in an mrnet tree.\n-->\n\n      <Component>\n        <Name>Aggregator</Name>\n        <Type>AddressAggregator</Type>\n      </Component>\n\n<!--\n     The Filter LinkedObject component.\n-->\n      <Component>\n        <Name>LinkedObject</Name>\n        <Type>LinkedObject</Type>\n      </Component>\n\n<!--\n     The Filter ThreadEventComponent component.\n-->\n      <Component>\n        <Name>ThreadEventComponent</Name>\n        <Type>ThreadEventComponent</Type>\n      </Component>\n\n<!--\n-->\n      <Component>\n        <Name>ResolveSymbols</Name>\n        <Type>ResolveSymbols</Type>\n      </Component>\n\n<!--\n    Input to handle incoming attached to thread events.  These are\n    passed on untouched by this FrontEnd network to a client tool.\n-->\n      <Input>\n        <Name>IncomingAttachedToThreads</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threads</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingThreadsStateChanged</Name>\n        <To>\n          <Name>ThreadEventComponent</Name>\n          <Input>threadstate</Input>\n        </To>\n      </Input>\n\n      <Input>\n        <Name>IncomingLinkedObjectGroup</Name>\n        <To>\n          <Name>LinkedObject</Name>\n          <Input>group</Input>\n        </To>\n      </Input>\n\n<!--\n     Any cbtf_protocol_blob on this input will be decoded and processed\n     for the aggregation of pc addresses and counts from the embedded\n     data blob.  Each cbtf_protocol_blob contains a header blob which\n     could be used later to match such pc address data to the thread\n     encoded in the header (e.g. useful for maintaining which thread\n     had the max,min counts for each address).\n-->\n      <Input>\n        <Name>IncomingBlobs</Name>\n        <To>\n          <Name>Aggregator</Name>\n          <Input>cbtf_protocol_blob</Input>\n        </To>\n      </Input>\n\n\n<!--\n     Connection to send list of attached threads to the aggregator.\n     This is a sync connection used by the aggregator to wait for\n     all attached threads to send at least one addressbuffer.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Notify Aggregator that all threads are terminated.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>Aggregator</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the linkedobject component.\n     This is a sync connection used by the linkedobject component to wait for\n     all attached threads to send a group of initially loaded linkedobjects.\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadNameVecOut</Output>\n        </From>\n        <To>\n            <Name>LinkedObject</Name>\n            <Input>threadnames</Input>\n        </To>\n      </Connection>\n\n<!--\n     Connection to send list of attached threads to the symbol component.\n-->\n      <Connection>\n        <From>\n            <Name>LinkedObject</Name>\n            <Output>linkedobjectvec_out</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>linkedobjectvecin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>Aggregatorout</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>abufferin</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>Aggregator</Name>\n            <Output>ThreadAddrBufMap</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>threadaddrbufmap</Input>\n        </To>\n      </Connection>\n\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ResolveSymbols</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n<!--\n-->\n      <Connection>\n        <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>Threads_finished</Output>\n        </From>\n        <To>\n            <Name>ThreadEventComponent</Name>\n            <Input>finished</Input>\n        </To>\n      </Connection>\n\n\n<!--\n     This ouput sends an AddressBuffer upstream. This buffer represents\n     the unique pc addresses along with their counts from the performance\n     data blobs received on the Aggregator  cbtf_protocol_blob input.\n     Currently no attempt is made to match addressbuffers to the thread\n     for which they are associated.\n-->\n      <Output>\n        <Name>OutgoingBuffers</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>Aggregatorout</Output>\n        </From>\n      </Output>\n\n<!--\n     This output sends xdr encoded perfomance data blobs to the frontend\n     client where they are enqueued into a data queue for eventual\n     writing to a database. No further processing on the actual performance\n     data in the encoded blob will be performed in the filter network\n     beyond this level of the reduction tree.\n-->\n      <Output>\n        <Name>OutgoingBlobs</Name>\n        <From>\n          <Name>Aggregator</Name>\n          <Output>datablob_xdr_out</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsAttached</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>AttachedToThreads_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingThreadsState</Name>\n         <From>\n            <Name>ThreadEventComponent</Name>\n            <Output>ThreadsStateChanged_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingLinkedObjectGroup</Name>\n         <From>\n            <Name>LinkedObject</Name>\n            <Output>group_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n        <Name>OutgoingLeafCP</Name>\n        <From>\n          <Name>ThreadEventComponent</Name>\n          <Output>LeafCP_numBE</Output>\n        </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMaxFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>maxfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingMinFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>minfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n\n      <Output>\n         <Name>OutgoingAvgFunctionValues</Name>\n         <From>\n            <Name>ResolveSymbols</Name>\n            <Output>avgfunctionvalues_xdr_out</Output>\n         </From>\n      </Output>\n \n    </Network>    \n\n<!--\n    Incoming performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For usertime, the xdr data blob is\n    the actual sample payload sent from a collection service. \n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <To><Input>IncomingBlobs</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming attached to threads events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <To><Input>IncomingAttachedToThreads</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming threads state changed events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <To><Input>IncomingThreadsStateChanged</Input></To>\n    </IncomingUpstream>\n\n<!--\n    Incoming loaded linked object group events.\n-->\n    <IncomingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <To><Input>IncomingLinkedObjectGroup</Input></To>\n    </IncomingUpstream>\n\n<!--\n    This is the stream for sending the aggregated pc addressbuffers\n    upstream to the next level of the tree for further aggregation.\n-->\n    <OutgoingUpstream>\n      <Name>Buffers</Name>\n      <From><Output>OutgoingBuffers</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>LeafCP</Name>\n      <From><Output>OutgoingLeafCP</Output></From>\n    </OutgoingUpstream>\n\n<!--\n    Outgoing performance data blobs.  These are encoded as an xdr header\n    and an actual xdr data blob.  For usertime, the xdr data blob is\n    the actual sample payload sent from a collection service. \n    This stream essentially passes on the incoming blobs upstream\n    where eventually a client can record them to a database if desired.\n-->\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_PERFORMANCE_DATA</Name>\n      <From><Output>OutgoingBlobs</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_ATTACHED_TO_THREADS</Name>\n      <From><Output>OutgoingThreadsAttached</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_THREADS_STATE_CHANGED</Name>\n      <From><Output>OutgoingThreadsState</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>CBTF_PROTOCOL_TAG_LINKED_OBJECT_GROUP</Name>\n      <From><Output>OutgoingLinkedObjectGroup</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MaxFunctionValues</Name>\n      <From><Output>OutgoingMaxFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>MinFunctionValues</Name>\n      <From><Output>OutgoingMinFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n    <OutgoingUpstream>\n      <Name>AvgFunctionValues</Name>\n      <From><Output>OutgoingAvgFunctionValues</Output></From>\n    </OutgoingUpstream>\n\n  </Filter>\n\n</MRNet>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/core/scripts/cbtflink.in": "#! /bin/bash\n# Some of this code is inspired by the libmonitor package (monitor-link).\n\ndebug_flag=0\nif [ -z \"$CBTF_DEBUG_CBTFLINK\" ] ; then\n  echo \"\"\nelse\n  debug_flag=1\nfi\n\ncbtf_target=@cbtftargetos@\n\n# TODO: handle the target prefix\ncbtfk_prefix=@cbtfkCNdir@\ncbtfk_libdir=@cbtfkCNlibdir@\ncbtfk_bindir=\"${cbtfk_prefix}/bin\"\ncbtfk_plugins=\"${cbtfk_libdir}/KrellInstitute/Collectors\"\ncbtfk_plugins_static=\"${cbtfk_libdir}/KrellInstitute/Collectors/static\"\n\nlibmonitor_libdir=@libmonitorlibdir@\nlibmonitor=\"${libmonitor_libdir}/libmonitor_wrap.a\"\n\nlibunwind_libdir=@libunwindlibdir@\nlibunwind=\"${libunwind_libdir}/libunwind.a\"\n\nlibpapi_libdir=@libpapilibdir@\nlibpapi=\"${libpapi_libdir}/libpapi.a\"\n\nlibmrnet_libdir=@libmrnetCNlibdir@\n\n# monitor always has these\n\n# for the cray-xt5 we don't want system defined by default, not sure why\n# but undefining it using the -u arguments does not work.\nif test \"${cbtf_target}\" == \"cray-xt5\" || test \"${cbtf_target}\" == \"cray-xt4\" || test \"${cbtf_target}\" == \"bgp\"  ; then\n  monitor_wrap_base_names=\"main exit _exit\"\nelse\n  monitor_wrap_base_names=\"main exit _exit system\"\nfi\n\n# monitor has --enable-fork\nmonitor_wrap_fork_names=\"fork vfork execl execlp execle execv execvp execve\"\n# monitor has --enable-dlfcn\n#monitor_wrap_dlopen_names=\"dlopen dlclose\"\nmonitor_wrap_dlopen_names=\"\"\n# monitor has --enable-pthread\nif test \"${mach_type}\" == \"ppc64\" && test \"${cbtf_target}\" == \"bgq\"  ; then\n   monitor_wrap_pthread_names=\"pthread_create pthread_exit pthread_sigmask sigwaitinfo sigtimedwait\"\nelif test \"${cbtf_target}\" == \"cray-xe\" || test \"${cbtf_target}\" == \"cray-xk\"  || test \"${cbtf_target}\" == \"cray\" ; then\n   monitor_wrap_pthread_names=\"pthread_create pthread_exit pthread_sigmask sigwaitinfo sigtimedwait\"\nelse\n   monitor_wrap_pthread_names=\"pthread_create pthread_exit pthread_sigmask\"\nfi\n\n# monitor has --enable-signals\nmonitor_wrap_signal_names=\"signal sigaction sigprocmask\"\n# monitor has mpi. These are the base names for the non mpi collectors\nmonitor_wrap_mpibase_names=\"MPI_Init MPI_Init_thread MPI_Finalize MPI_Comm_rank mpi_init mpi_init_thread mpi_finalize mpi_comm_rank mpi_init_ mpi_init_thread_ mpi_finalize_ mpi_comm_rank_ mpi_init__ mpi_init_thread__ mpi_finalize__ mpi_comm_rank__\"\n\n# The following groupings are available\nmonitor_wrap_mpi_asyncP2P=\"MPI_Cancel mpi_cancel mpi_cancel_ mpi_cancel__ MPI_Ibsend mpi_ibsend mpi_ibsend_ mpi_ibsend__ MPI_Iprobe mpi_iprobe mpi_iprobe_ mpi_iprobe__ MPI_Irecv mpi_irecv mpi_irecv_ mpi_irecv__ MPI_Irsend mpi_irsend mpi_irsend_ mpi_irsend__ MPI_Isend mpi_isend mpi_isend_ mpi_isend__ MPI_Request_free mpi_request_free mpi_request_free_ mpi_request_free__ MPI_Test mpi_test mpi_test_ mpi_test__ MPI_Testall mpi_testall mpi_testall_ mpi_testall__ MPI_Testany mpi_testany mpi_testany_ mpi_testany__ MPI_Testsome mpi_testsome mpi_testsome_ mpi_testsome__ MPI_Wait mpi_wait mpi_wait_ mpi_wait__ MPI_Waitall mpi_waitall mpi_waitall_ mpi_waitall__ MPI_Waitany mpi_waitany mpi_waitany_ mpi_waitany__ MPI_Waitsome mpi_waitsome mpi_waitsome_ mpi_waitsome__\"\nmonitor_wrap_mpi_collectives=\"MPI_Allgather mpi_allgather mpi_allgather_ mpi_allgather__ MPI_Allgatherv mpi_allgatherv mpi_allgatherv_ mpi_allgatherv_ MPI_Allreduce  mpi_allreduce mpi_allreduce_ mpi_allreduce__ MPI_Alltoall mpi_alltoall mpi_alltoall_ mpi_alltoall__ MPI_Alltoallv mpi_alltoallv mpi_alltoallv_ mpi_alltoallv__ MPI_Barrier mpi_barrier mpi_barrier_ mpi_barrier__ MPI_Bcast mpi_bcast mpi_bcast_ mpi_bcast__ MPI_Gather mpi_gather mpi_gather_ mpi_gather__ MPI_Gatherv mpi_gatherv mpi_gatherv_ mpi_gatherv__ MPI_Reduce mpi_reduce mpi_reduce_ mpi_reduce__ MPI_Reduce_scatter mpi_reduce_scatter mpi_reduce_scatter_ mpi_reduce_scatter__ MPI_Scan mpi_scan mpi_scan_ mpi_scan__ MPI_Scatter mpi_scatter mpi_scatter_ mpi_scatter__ MPI_Scatterv mpi_scatterv mpi_scatterv_ mpi_scatterv__\"\nmonitor_wrap_mpi_datatypes=\"MPI_Pack mpi_pack mpi_pack_ mpi_pack__ MPI_Unpack mpi_unpack mpi_unpack_ mpi_unpack__\"\nmonitor_wrap_mpi_environment=\"MPI_Finalize mpi_finalize mpi_finalize_ mpi_finalize__ MPI_Init mpi_init mpi_init_ mpi_init__\"\nmonitor_wrap_mpi_graphcontexts=\"MPI_Comm_create mpi_comm_create mpi_comm_create_ mpi_comm_create__ MPI_Comm_dup mpi_comm_dup mpi_comm_dup_ mpi_comm_dup__ MPI_Comm_free mpi_comm_free mpi_comm_free_ mpi_comm_free__ MPI_Comm_split mpi_comm_split mpi_comm_split_ mpi_comm_split__ MPI_Intercomm_create mpi_intercomm_create mpi_intercomm_create_ mpi_intercomm_create__ MPI_Intercomm_merge mpi_intercomm_merge mpi_intercomm_merge_ mpi_intercomm_merge__\"\nmonitor_wrap_mpi_persistent=\"MPI_Bsend_init mpi_bsend_init mpi_bsend_init_ mpi_bsend_init__ MPI_Recv_init mpi_recv_init mpi_recv_init_ mpi_recv_init__ MPI_Rsend_init mpi_rsend_init mpi_rsend_init_ mpi_rsend_init__ MPI_Send_init mpi_send_init mpi_send_init_ mpi_send_init__ MPI_Ssend_init mpi_ssend_init mpi_ssend_init_ mpi_ssend_init__ MPI_Start mpi_start mpi_start_ mpi_start__ MPI_Startall mpi_startall mpi_startall_ mpi_startall__\"\nmonitor_wrap_mpi_processtopologies=\"MPI_Cart_create MPI_Cart_sub MPI_Graph_create\"\nmonitor_wrap_mpi_syncP2P=\"MPI_Bsend mpi_bsend mpi_bsend_ mpi_bsend__ MPI_Get_count mpi_get_count mpi_get_count_ mpi_get_count__ MPI_Probe mpi_probe mpi_probe_ mpi_probe__  MPI_Recv mpi_recv mpi_recv_ mpi_recv__ MPI_Rsend mpi_rsend mpi_rsend_ mpi_rsend__ MPI_Send mpi_send mpi_send_ mpi_send__ MPI_Sendrecv mpi_sendrecv mpi_sendrecv_ mpi_sendrecv__ MPI_Sendrecv_replace mpi_sendrecv_replace mpi_sendrecv_replace_ mpi_sendrecv_replace__ MPI_Ssend mpi_ssend mpi_ssend_ mpi_ssend__\"\n\n# The default for mpi collectors.\nmonitor_wrap_mpi_all=\"${monitor_wrap_mpi_asyncP2P} ${monitor_wrap_mpi_collectives} ${monitor_wrap_mpi_datatypes} ${monitor_wrap_mpi_graphcontexts} ${monitor_wrap_mpi_persistent} ${monitor_wrap_mpi_processtopologies} ${monitor_wrap_mpi_syncP2P}\"\n\nmonitor_wrap_io_names=\"close creat creat64 dup dup2 lseek lseek64 open open64 pipe pread pread64 pwrite pwrite64 read readv write writev\"\n\nmonitor_wrap_mem_names=\"malloc free memalign posix_memalign calloc realloc\"\n\n# inititalize variables used to create final link line\nmpi_undefines=\nfork_undefines=\npthread_undefines=\nstatic_collector=\nmpi_plugin=\noutput_dir=\ninsert_files=\n\ndefault_mpi_impl=@default_mpi_impl@\n\n# Support both the CBTF_MPI_IMPLEMENTATION and\n# OPENSS_MPI_IMPLEMENTATION (for when cbtf is used\n# with OpenSpeedShop)\n#\nif [ -n \"$CBTF_MPI_IMPLEMENTATION\" ] ; then\n    mpitouse=$CBTF_MPI_IMPLEMENTATION\nelif [ -n \"$OPENSS_MPI_IMPLEMENTATION\" ] ; then\n    mpitouse=$OPENSS_MPI_IMPLEMENTATION\nelse\n    mpitouse=`echo ${default_mpi_impl} |tr '[A-Z]' '[a-z]'`\n    export CBTF_MPI_IMPLEMENTATION=$mpitouse\nfi \n\n\n# Space-separated list of extra symbol names to wrap.\nwrap_names=\n\n# Space-separated list of symbol names to force undefined.\nundef_names=\n\n# Space-separated list of extra library names, eg: \"-ldl -lm\".\nlibrary_names=\n\ndie()\n{\n    echo \"$0: error: $*\" 1>&2\n    exit 1\n}\n\nusage()\n{\n    cat <<EOF\nUsage: $0 -c collector [options] compiler file ...\n\n  -h, --help\n\n  -c, --collector  <collector name>\nWhere collector is the name of the OpenSpeedShop\ncollector to link into the application. See the\ncbtf manpage for a description of the available\nexperiments provided by OpenSpeedShop. This is a\nmandatory option.\n\n  -m, --mode  <fileio, sequential, mpi>\nwhere:\n mpi: sends data from an mpi application using MRNet.\n sequential: sends data from a sequential application using MRNet. (default)\n\nThe mrnet modes are preferred and the resulting application\nmust be run with a client tool that supports mrnet backend\nattach methods.  The cbtf collectionTool client is one such client.\nThis is a mandatory option. \n\n  -v, --verbose\n\nEOF\n    exit 0\n}\n\nverbose=no\n# Default to sequential mode (--mode will override this)\ncbtflinkMode=\"sequential\"\n\nwhile test \"x$1\" != x ; do\n    case \"$1\" in\n\n        -h | --help )\n            usage\n            ;;\n\n        -c | --collector)\n            test \"x$2\" != x || die \"missing argument: $*\"\n            case \"$2\" in\n                pcsamp )        collector=\"$2\" ;;\n                hwc )           collector=\"$2\" ;;\n                usertime )      collector=\"$2\" ;;\n                hwctime )       collector=\"$2\" ;;\n                hwcsamp )       collector=\"$2\" ;;\n                io )            collector=\"$2\" ;;\n                iop )           collector=\"$2\" ;;\n                iot )           collector=\"$2\" ;;\n                mem )           collector=\"$2\" ;;\n                mpi )           collector=\"$2\" ;;\n                mpit )          collector=\"$2\" ;;\n                mpip )          collector=\"$2\" ;;\n                pthreads )      collector=\"$2\" ;;\n                fpe )           collector=\"$2\" ;;\n            esac\n            shift ; shift\n            ;;\n\n        -i | --mpitype)\n            test \"x$2\" != x || die \"missing argument: $*\"\n            case \"$2\" in\n                mpich )        mpitouse=\"$2\" ;;\n                mpich2 )        mpitouse=\"$2\" ;;\n                mvapich )        mpitouse=\"$2\" ;;\n                mvapich2 )        mpitouse=\"$2\" ;;\n                openmpi )        mpitouse=\"$2\" ;;\n                mpt )        mpitouse=\"$2\" ;;\n                lam )        mpitouse=\"$2\" ;;\n                lampi )        mpitouse=\"$2\" ;;\n            esac\n\t    export CBTF_MPI_IMPLEMENTATION=$mpitouse\n            shift ; shift\n            ;;\n        -m | --mode)\n            test \"x$2\" != x || die \"missing argument: $*\"\n            case \"$2\" in\n                fileio )      cbtflinkMode=\"$2\" ;;\n                mpi )         cbtflinkMode=\"$2\" ;;\n                sequential )  cbtflinkMode=\"$2\" ;;\n            esac\n            shift ; shift\n            ;;\n\n        -p | --pluginpath)\n            test \"x$2\" != x || die \"missing argument: $*\"\n            case \"$2\" in\n                /* )  dir=\"$2\" ;;\n                * )   dir=\"`pwd`/$2\" ;;\n            esac\n            test -d \"$dir\" || die \"unable to find: $dir\"\n            export CBTF_PLUGIN_PATH=\"${dir}\"\n\t    cbtfk_plugins=\"${dir}\"\n\t    cbtfk_plugins_static=\"${dir}/static\"\n            shift ; shift\n            ;;\n\n\n        -v | --verbose )\n            verbose=yes\n            shift\n            ;;\n\n        -u | --undefined )\n            test \"x$2\" != x || die \"missing argument: $*\"\n            undef_names=\"${undef_names} $2\"\n            shift ; shift\n            ;;\n\n        -w | --wrap )\n            test \"x$2\" != x || die \"missing argument: $*\"\n            wrap_names=\"${wrap_names} $2\"\n            shift ; shift\n            ;;\n\n        -- )\n            shift\n            break\n            ;;\n\n        -* )\n            die \"unknown option: $1\"\n            ;;\n\n        * )\n            break\n            ;;\n    esac\ndone\n\n# services to link with\n# TODO: maybe do the same for the required message libs for\n# mrnet based collectors.\ndata_service=${cbtfk_libdir}/libcbtf-services-data.a\ncommon_service=${cbtfk_libdir}/libcbtf-services-common.a\nmonitor_service=${cbtfk_libdir}/libcbtf-services-offline.a\nmrnet_service=${cbtfk_libdir}/libcbtf-services-mrnet.a\noffline_service=${cbtfk_libdir}/libcbtf-services-offline.a\npapi_service=${cbtfk_libdir}/libcbtf-services-papi.a\ntimer_service=${cbtfk_libdir}/libcbtf-services-timer.a\nunwind_service=${cbtfk_libdir}/libcbtf-services-unwind.a\nmonitor_callbacks=${cbtfk_plugins}/cbtf_monitor.o\n\n#\n# Must have a compiler command and at least one argument.\n#\ntest \"x$2\" != x || usage\ncommand=\"$1\"\nshift\n\n#\n# Duplicate the -l<lib> arguments.\n#\nappl_libs=\nfor lib in \"$@\" ; do\n    case \"$lib\" in\n        -l?* ) appl_libs=\"$appl_libs $lib\" ;;\n    esac\ndone\n\nmonitor_has_fork=`nm ${libmonitor} | grep -i __wrap_fork`\nmonitor_has_signals=`nm ${libmonitor} | grep -i __wrap_signal`\nmonitor_has_pthreads=`nm ${libmonitor} | grep -i __wrap_pthread_create`\nmonitor_has_dlopen=`nm ${libmonitor} | grep -i __wrap_dlopen`\nmonitor_has_mpi=`nm ${libmonitor} | grep -i __wrap_mpi_init`\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  if [ -n \"$monitor_has_fork\" ] ; then\n    echo \"DEBUG: cbtflink monitor_has_fork is non-null\"\n  fi\n  if [ -n \"$monitor_has_signals\" ] ; then\n    echo \"DEBUG: cbtflink monitor_has_signals is non-null\"\n  fi\n  if [ -n \"$monitor_has_pthreads\" ] ; then\n    echo \"DEBUG: cbtflink monitor_has_pthreads is non-null\"\n  fi\n  if [ -n \"$monitor_has_dlopen\" ] ; then\n    echo \"DEBUG: cbtflink monitor_has_dlopen is non-null\"\n  fi\n  if [ -n \"$monitor_has_mpi\" ] ; then\n    echo \"DEBUG: cbtflink monitor_has_mpi = $monitor_has_mpi\"\n  fi\n  echo\nfi\n\ncollector_service_libs=\"\"\npthread_libs=\"\"\nldl_libs=\"\"\nlibm_libs=\"-lm\"\n\n# A command with *mpix* implies IBM compilers on BlueGene.\n# The -Wl,--eh-frame-hdr option is is required so that libunwind can find\n# the information generated by the compiler required for stack unwinding\n# in static binaries. \nif [[ $command == *mpix* ]] ; then\n  static_args=\"  \"\nelse\n  static_args=\" -static -Wl,--eh-frame-hdr \"\nfi\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  echo \"DEBUG: cbtflink static_args = $static_args\"\nfi\n\nwrap_args=\nfor name in $monitor_wrap_base_names $wrap_names ;  do\n    wrap_args=\"${wrap_args} -Wl,--wrap,${name}\"\ndone\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  echo \"DEBUG: cbtflink wrap_args for monitor_wrap_base_names = $wrap_args\"\nfi\n\nif [ -n \"$monitor_has_fork\" ] ; then\n    for name in $monitor_wrap_fork_names ; do\n\twrap_args=\"${wrap_args} -Wl,--wrap,${name}\"\n    done\nfi\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  echo \"DEBUG: cbtflink wrap_args for monitor_wrap_fork_names = $wrap_args\"\nfi\n\nif [ -n \"$monitor_has_signals\" ] ; then\n    for name in $monitor_wrap_signal_names ; do\n\twrap_args=\"${wrap_args} -Wl,--wrap,${name}\"\n    done\nfi\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  echo \"DEBUG: cbtflink wrap_args for monitor_wrap_signal_names = $wrap_args\"\nfi\n\nif [ -n \"$monitor_has_pthreads\" ] ; then\n    for name in $monitor_wrap_pthread_names ; do\n\twrap_args=\"${wrap_args} -Wl,--wrap,${name}\"\n    done\n    pthreads_libs=\"-lpthread\"\nfi\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  echo \"DEBUG: cbtflink wrap_args for monitor_wrap_pthread_names = $wrap_args\"\nfi\n\nif [ -n \"$monitor_has_dlopen\" ] ; then\n    for name in $monitor_wrap_dlopen_names ; do\n\twrap_args=\"${wrap_args} -Wl,--wrap,${name}\"\n    done\n    ldl_libs=\"-Wl,--no-as-needed -ldl\"\nfi\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  echo \"DEBUG: cbtflink wrap_args for monitor_wrap_dlopen_names = $wrap_args\"\n  echo \"DEBUG: cbtflink collector_service_libs for monitor_wrap_dlopen_names = $collector_service_libs\"\nfi\n\nif [ -n \"$monitor_has_mpi\" ] ; then\n    for name in $monitor_wrap_mpibase_names ; do\n\twrap_args=\"${wrap_args} -Wl,--wrap,${name}\"\n    done\nfi\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  echo \"DEBUG: cbtflink wrap_args for monitor_wrap_mpibase_names = $wrap_args\"\nfi\n\nundef_args=\nfor name in $undef_names ; do\n    undef_args=\"${undef_args} -Wl,-u,__wrap_${name}\"\ndone\n\nfor name in $mpi_undefines ; do\n    undef_args=\"${undef_args} -Wl,-u,__wrap_${name}\"\n    echo\ndone\n\nfor name in $fork_undefines ; do\n    undef_args=\"${undef_args} -Wl,-u,__wrap_${name}\"\ndone\n\nfor name in $pthread_undefines ; do\n    undef_args=\"${undef_args} -Wl,-u,__wrap_${name}\"\ndone\n\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  echo \"DEBUG: cbtflink cbtf_target = $cbtf_target\"\nfi\n\n\n# Need to undefine fork and others for cray and blue gene systems\nif test \"${cbtf_target}\" != \"\" ; then\n    if test \"${cbtf_target}\" == \"cray-xk\" || test \"${cbtf_target}\" == \"cray-xe\" || test \"${cbtf_target}\" == \"cray-xt4\" || test \"${cbtf_target}\" == \"cray\" ; then\n       undef_args=\"${undef_args} -Wl,-u,__wrap_fork\"\n       undef_args=\"${undef_args} -Wl,-u,__wrap_pthread_create\"\n    elif test \"${cbtf_target}\" == \"cray-xt5\" ; then\n       # Need to undefine system for cray-xt5\n       undef_args=\"${undef_args} -Wl,-u,__wrap_pthread_create\"\n    elif test \"${cbtf_target}\" == \"bgl\" || test \"${cbtf_target}\" == \"bgp\" || test \"${cbtf_target}\" == \"bgq\" ; then\n       # Need to undefine fork for bgl\n       undef_args=\"${undef_args} -Wl,-u,__wrap_pthread_create\"\n       undef_args=\"${undef_args} -Wl,-u,__wrap_open\"\n    fi\nfi\n\nif [ $debug_flag == 1 ] ; then\n  echo\n  echo \"DEBUG: cbtflink collector = $collector\"\nfi\n\n#\n# order of linking is important. See the exec command at the end of\n# this script to infor the ordering as implemented.\n#\n\n# monitor callbacks and libraries\nmon_args=\"${libmonitor} ${appl_libs} ${library_names}\"\n# mrnet service and libraries\nmrnet_service_libs=\"$mrnet_service -L ${libmrnet_libdir} -lmrnet_lightweight_r -lxplat_lightweight_r\"\n# cbtf message libraries\nmessage_libs=\"-L${cbtfk_libdir} -lcbtf-messages-events -lcbtf-messages-perfdata -lcbtf-messages-base -lcbtf-messages-collector\"\n# common collector service libraries\ncommon_service_libs=\"$data_service $common_service $offline_service\"\n# the unwind service and libunwind\nunwind_service_libs=\"${unwind_service} ${libunwind}\"\n# the papi service and libpapi.a\npapi_service_libs=\"${papi_service} ${libpapi}\"\n# these are common to all link steps.  the libm libs are needed for mrnet collectors.\ncommon_libs=\"-lrt ${pthreads_libs} ${ldl_libs} ${libm_libs}\"\n\n# create the extensions for the unique collector types.\n# and create common collection libs for each type\ncollector_type=\"\"\ncase \"$cbtflinkMode\" in\n    fileio )\n\tcollector_type=\"monitor-fileio\"\n\tlibm_libs=\"\"\n\tcollector_service_libs=\"${cbtfk_libdir}/libcbtf-services-collector-${collector_type}.a\"\n\t;;\n    mpi )\n\tcollector_type=\"monitor-mrnet-mpi\"\n\tcollector_service_libs=\"${cbtfk_libdir}/libcbtf-services-collector-${collector_type}.a $mrnet_service_libs\"\n\t;;\n    sequential )\n\tcollector_type=\"monitor-mrnet\"\n\tcollector_service_libs=\"${cbtfk_libdir}/libcbtf-services-collector-${collector_type}.a $mrnet_service_libs\"\n\t;;\nesac\n\n# mpi collectors need to add the specific mpi implementation to the collector.\ncase \"$collector\" in\n    mpi*|mpit*|mpip*|mpiotf* )\n        static_collector=${cbtfk_plugins_static}/lib${collector}-${mpitouse}-${collector_type}.a\n    ;;\n    *)\n        static_collector=${cbtfk_plugins_static}/lib${collector}-${collector_type}.a\n    ;;\nesac\n\n# create a blank linking command\nlink_command=\"\"\ncollector_specific_libs=\"\"\nprelink_command=\"$command $static_args $wrap_args $undef_args\"\ncollector_final_libs=\"${message_libs} ${common_libs}\"\ncollector_libs=\"$monitor_callbacks $collector_service_libs $static_collector ${common_service_libs}\"\n\n# now construct the link command for each collector.\ncase \"$collector\" in\n    mpi*|mpit*|mpip*|mpiotf* )\n    if [ -n \"$monitor_has_mpi\" ] ; then\n\tfor name in $monitor_wrap_mpi_all ; do\n\t    wrap_args=\"${wrap_args} -Wl,--wrap,${name}\"\n\tdone\n    fi\n    prelink_command=\"$command $static_args $wrap_args $undef_args\"\n    collector_specific_libs=\"${unwind_service_libs}\"\n    ;;\n\n    # The non mpi tracing experiments need to trace MPI_Init to\n    # gather the mpi rank information needed for the mpi_rank field\n    # in the THREADS table of the cbtf database.\n    pcsamp)\n    collector_specific_libs=\"${timer_service}\"\n    ;;\n\n    usertime)\n    collector_specific_libs=\"${timer_service} ${unwind_service_libs}\"\n    ;;\n\n    hwc)\n    collector_specific_libs=\"${papi_service_libs}\"\n    ;;\n\n    hwctime)\n    collector_specific_libs=\"${papi_service_libs} ${unwind_service_libs}\"\n    ;;\n\n    hwcsamp)\n    collector_specific_libs=\"${timer_service} ${papi_service_libs}\"\n    ;;\n\n    io | iop | iot)\n    for name in $monitor_wrap_io_names ; do\n\twrap_args=\"${wrap_args} -Wl,--wrap,${name}\"\n    done\n\n    # Need to undefine open for io and iot for cray-xt4\n    if test \"${cbtf_target}\" == \"cray-xt4\" ; then\n       undef_args=\"${undef_args} -Wl,-u,__wrap_open\"\n    fi\n\n    # Need to undefine open for io and iot for cray-xt5\n    if test \"${cbtf_target}\" == \"cray-xt5\" ; then\n       undef_args=\"${undef_args} -Wl,-u,__wrap_open\"\n    fi\n    prelink_command=\"$command $static_args $wrap_args $undef_args\"\n    collector_specific_libs=\"${unwind_service_libs}\"\n    ;;\n\n    mem )\n    for name in $monitor_wrap_mem_names ; do\n\twrap_args=\"${wrap_args} -Wl,--wrap,${name}\"\n    done\n    prelink_command=\"$command $static_args $wrap_args $undef_args\"\n    collector_specific_libs=\"${unwind_service_libs}\"\n\n    ;;\n\n    pthreads )\n    # TODO: placeholder for pthreads static linking.\n    ;;\n\n    fpe )\n    # NOT SUPPORTED.  Maybe in the future for fileio.\n    #collector_service_libs=\"${collector_service_libs} -lrt -L ${cbtfk_libdir} -lcbtf-services-unwind -lcbtf-services-binutils -lcbtf-services-monitor -L ${libunwind_libdir} -lunwind -lbfd -liberty -lopcodes -lz -lm\"\n    # collector_specific_libs=\"${unwind_service_libs}\"\n    ;;\nesac\n\nif test \"$verbose\" = yes ; then\n    echo \"$0, new command line: $prelink_command \\$@  $collector_libs $collector_specific_libs $collector_final_libs $mon_args\"\nfi\n\n# execute the final linking.\nexec $prelink_command \"$@\" $collector_libs $collector_specific_libs $collector_final_libs $mon_args\n\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/test/configure.ac": "################################################################################\n# Copyright (c) 2011-2013 Krell Institute. All Rights Reserved.\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 2 of the License, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n# details.\n#\n# You should have received a copy of the GNU General Public License along with\n# this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n# Place, Suite 330, Boston, MA  02111-1307  USA\n################################################################################\n\nAC_INIT([services], [1.0])\nAC_COPYRIGHT([[Copyright (c) 2011-2013 Krell Institute. All Rights Reserved.]])\n\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE\nAM_CONFIG_HEADER([config.h])\n\nAH_TOP([\n/*******************************************************************************\n** Copyright (c) 2011-2013 Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n])\n\nAC_GNU_SOURCE\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_LIBTOOL\nAC_PROG_INSTALL\n\nLT_CONFIG_LTDL_DIR([libltdl])\nLT_INIT([dlopen])\nLTDL_INIT([recursive])\n\nAC_PATH_PROG([RPCGEN], rpcgen)\nAC_PROG_LN_S\n\n################################################################################\n# Handle PowerPC and X86-64 Special Cases\n################################################################################\nAC_ARG_WITH(ppc64_bitmode,\n            AC_HELP_STRING([--with-ppc64-bitmode=<32,64>],\n                           [Specify ppc64 library bit mode @<:@64@:>@]),\n            ppc64_bitmode=$withval, ppc64_bitmode=\"64\")\n\nAC_MSG_CHECKING([Configuring for host = $host  with ppc64_bitmode = $ppc64_bitmode])\n\ncase \"$host\" in\n    powerpc-*-linux*)\n        AC_MSG_CHECKING([Configuring for powerpc-star-linux])\n\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n            libdir='${exec_prefix}/lib'\n        fi\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\n    powerpc64-*-*)\n\n        AC_MSG_CHECKING([Configuring for powerpc64-star-linux with ppc64_bitmode = $ppc64_bitmode])\n        if test \"$ppc64_bitmode\" = \"64\" ; then\n                AC_MSG_CHECKING([Configuring for 64 bit powerpc64-star-linux host])\n                abi_libdir=\"lib64\"\n                alt_abi_libdir=\"lib\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n                    libdir='${exec_prefix}/lib64'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib64 $LDFLAGS\"\n                CFLAGS=\"-m64 $CFLAGS\"\n                CXXFLAGS=\"-m64 $CXXFLAGS\"\n                CPPFLAGS=\"-m64 $CPPFLAGS\"\n        elif test \"$ppc64_bitmode\" = \"32\" ; then\n                AC_MSG_CHECKING([Configuring for 32 bit powerpc64-star-linux host])\n                abi_libdir=\"lib\"\n                alt_abi_libdir=\"lib64\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n                    libdir='${exec_prefix}/lib'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        fi\n        ;;\n\n    x86_64-*-linux*)\n        AC_MSG_CHECKING([Configuring for x86_64--star-linux host])\n        if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n            libdir='${exec_prefix}/lib64'\n        fi\n        abi_libdir=\"lib64\"\n        alt_abi_libdir=\"lib\"\n        LDFLAGS=\"$LDFLAGS\"\n        ;;\n\n    *)\n        AC_MSG_CHECKING([Configuring for default host])\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\nesac\ntopdir_execprefix=${exec_prefix}\nAC_SUBST(topdir_execprefix)\n\nabi_libdir_name=${abi_libdir}\nAC_SUBST(abi_libdir_name)\nalt_abi_libdir_name=${alt_abi_libdir}\nAC_SUBST(alt_abi_libdir_name)\n\ncbtf_platform=`uname -i`\ncbtf_hardware_platform=$cbtf_platform\nAC_MSG_CHECKING([Checking for cbtf_hardware_platform=$cbtf_hardware_platform])\nAC_SUBST(cbtf_hardware_platform)\n\n\n################################################################################\n# Check for POSIX Threads (ISO/IEC 9945-1:1996)\n################################################################################\n\nAC_CHECK_HEADER(pthread.h, [ AC_CHECK_LIB(pthread, pthread_create, [\n    AC_DEFINE(HAVE_POSIX_THREADS, 1, [Define to 1 if you have POSIX threads.])\n], [\n    AC_MSG_FAILURE([cannot locate POSIX thread library and/or headers.])\n]) ])\n\n################################################################################\n# Check for TLS option, default to implicit\n################################################################################\n\nAC_ARG_WITH(tls,\n            AC_HELP_STRING([--with-tls=TYPE],\n                           [tls (implicit, explicit) @<:@explicit@:>@]),\n            TLS=$withval, TLS=\"explicit\")\n\ncase \"$TLS\" in\n    implicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, false)\n        ;;\n\n    explicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, true)\n        AC_DEFINE(USE_EXPLICIT_TLS, 1, [Define to 1 if you want to use an explicit TLS implementation instead of the __thread keyword.])\n        ;;\n\n    *)\n        AC_MSG_ERROR([invalid tls specification \"$TLS\".])\n        ;;\nesac\n\n################################################################################\n# Begin Target O/S Specification\n################################################################################\n\ntarget_os=$host\nAC_MSG_CHECKING(for Target O/S)\nAC_ARG_WITH(target-os,\n    AC_HELP_STRING([--with-target-os=TARGET_OS],\n                   [target os specification @<:@$host@:>@]),\n                    TARGET_OS=$withval, TARGET_OS=\"$host\")\n\n\nAM_CONDITIONAL(BUILD_TARGETED, false)\nbuild_targeted=0\ncase \"$TARGET_OS\" in\n    cray-xk)\n\tAC_DEFINE(TARGET_OS_CRAYXK, 1, [Do not define if not building for targeted cray-xk.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xk,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xe)\n\tAC_DEFINE(TARGET_OS_CRAYXE, 1, [Do not define if not building for targeted cray-xe.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xe,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt5)\n\tAC_DEFINE(TARGET_OS_CRAYXT5, 1, [Do not define if not building for targeted cray-xt5.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt5,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt4)\n\tAC_DEFINE(TARGET_OS_CRAYXT4, 1, [Do not define if not building for targeted cray-xt4.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt4,\n\t\t\t[Name targeted OS])\n\t;;\n    bgl)\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGL, 1, [Do not define if not building for targeted bgl.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgl,\n\t\t\t[Name targeted OS])\n\tbuild_targeted=1\n\t;;\n    bgp)\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGP, 1, [Do not define if not building for targeted bgp.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgp,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=1\n\t;; \n    bgq)\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGQ, 1, [Do not define if not building for targeted bgq.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgq,\n                           [Name targeted OS])\n\tbuild_targeted=1\n        ;;\n    *)\n\tAM_CONDITIONAL(BUILD_TARGETED, false)\n\tAC_DEFINE(BUILD_TARGETED, 0, [Define to 1 if building a targeted runtime.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,$host,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=0\n\t;; \nesac\n\nAC_SUBST(BUILD_TARGETED)\nAC_SUBST(TARGET_OS)\n################################################################################\n# End Target O/S Specification\n################################################################################\n\n################################################################################\n# build runtime collector software only\n################################################################################\n#\n# Option: \n#\nAC_MSG_CHECKING(for building runtime collectors only)\nAC_ARG_ENABLE([runtime-only],\n    [AS_HELP_STRING([--enable-runtime-only],\n        [Enable support building just the runtime collectors with no client [default=no]])],\n    [], [enable_runtime_only=no])\n\nif test \"x$enable_runtime_only\" = xyes ; then\n    AM_CONDITIONAL(BUILD_RUNTIME, true)\n    AC_DEFINE(BUILD_RUNTIME, 1, [Define to 1 if you do want only collector runtime support built.])\nelse\n    AM_CONDITIONAL(BUILD_RUNTIME, false)\n    AC_DEFINE(BUILD_RUNTIME, 0, [Define to 1 if you do not want only collector runtime support built.])\nfi\nAC_SUBST(BUILD_RUNTIME)\n\n\n################################################################################\n# Check for Additional Packages\n################################################################################\n\nAX_BINUTILS()\nAX_LIBMONITOR()\nAX_LIBUNWIND()\nAX_PAPI()\n\n\nAX_BOOST_BASE([1.35.0])\nAX_BOOST_DATE_TIME()\nAX_BOOST_SYSTEM()\nAX_BOOST_THREAD()\nAX_BOOST_FILESYSTEM()\nAX_BOOST_UNIT_TEST_FRAMEWORK()\n\nAX_MRNET()\nAX_CBTF()\nAX_XERCESC()\n# This helps with targeted builds when there is no xercesc\nif test \"$LIBXERCES_C\" = \"-lxerces-c\" ; then\n  AX_XERCESC_VERSION()\nfi\n\nAX_CBTF_XML()\nAX_CBTF_MRNET()\n\nAX_LIBDWARF()\nAX_DYNINST()\n\nAX_MESSAGES()\nAX_CORE()\n\nAC_CONFIG_FILES([\n    Makefile\n    libltdl/Makefile\n    src/Makefile\n    src/pcsamp_xdr/Makefile\n])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/examples/configure.ac": "################################################################################\n# Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 2 of the License, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n# details.\n#\n# You should have received a copy of the GNU General Public License along with\n# this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n# Place, Suite 330, Boston, MA  02111-1307  USA\n################################################################################\n\nAC_INIT([services], [1.0])\nAC_COPYRIGHT([[Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.]])\n\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE\nAM_CONFIG_HEADER([config.h])\n\nAH_TOP([\n/*******************************************************************************\n** Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n])\n\nAC_GNU_SOURCE\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_LIBTOOL\nAC_PROG_INSTALL\n\nLT_CONFIG_LTDL_DIR([libltdl])\nLT_INIT([dlopen])\nLTDL_INIT([recursive])\n\nAC_PATH_PROG([RPCGEN], rpcgen)\nAC_PROG_LN_S\n\n################################################################################\n# Handle PowerPC and X86-64 Special Cases\n################################################################################\nAC_ARG_WITH(ppc64_bitmode,\n            AC_HELP_STRING([--with-ppc64-bitmode=<32,64>],\n                           [Specify ppc64 library bit mode @<:@64@:>@]),\n            ppc64_bitmode=$withval, ppc64_bitmode=\"64\")\n\nAC_MSG_CHECKING([Configuring for host = $host  with ppc64_bitmode = $ppc64_bitmode])\n\ncase \"$host\" in\n    powerpc-*-linux*)\n        AC_MSG_CHECKING([Configuring for powerpc-star-linux])\n\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n            libdir='${exec_prefix}/lib'\n        fi\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\n    powerpc64-*-*)\n\n        AC_MSG_CHECKING([Configuring for powerpc64-star-linux with ppc64_bitmode = $ppc64_bitmode])\n        if test \"$ppc64_bitmode\" = \"64\" ; then\n                AC_MSG_CHECKING([Configuring for 64 bit powerpc64-star-linux host])\n                abi_libdir=\"lib64\"\n                alt_abi_libdir=\"lib\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n                    libdir='${exec_prefix}/lib64'\n                fi\n        \tLDFLAGS=\"-DLIB_DIR=lib64 $LDFLAGS\"\n                CFLAGS=\"-m64 $CFLAGS\"\n                CXXFLAGS=\"-m64 $CXXFLAGS\"\n                CPPFLAGS=\"-m64 $CPPFLAGS\"\n        elif test \"$ppc64_bitmode\" = \"32\" ; then\n                AC_MSG_CHECKING([Configuring for 32 bit powerpc64-star-linux host])\n                abi_libdir=\"lib\"\n                alt_abi_libdir=\"lib64\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n                    libdir='${exec_prefix}/lib'\n                fi\n        \tLDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        fi\n        ;;\n\n    x86_64-*-linux*)\n        AC_MSG_CHECKING([Configuring for x86_64--star-linux host])\n        if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n            libdir='${exec_prefix}/lib64'\n        fi\n        abi_libdir=\"lib64\"\n        alt_abi_libdir=\"lib\"\n        LDFLAGS=\"-DLIB_DIR=lib64 $LDFLAGS\"\n\n        ;;\n\n    *)\n        AC_MSG_CHECKING([Configuring for default host])\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\nesac\ntopdir_execprefix=${exec_prefix}\nAC_SUBST(topdir_execprefix)\n\nabi_libdir_name=${abi_libdir}\nAC_SUBST(abi_libdir_name)\nalt_abi_libdir_name=${alt_abi_libdir}\nAC_SUBST(alt_abi_libdir_name)\n\ncbtf_platform=`uname -i`\ncbtf_hardware_platform=$cbtf_platform\nAC_MSG_CHECKING([Checking for cbtf_hardware_platform=$cbtf_hardware_platform])\nAC_SUBST(cbtf_hardware_platform)\n\n\n################################################################################\n# Check for POSIX Threads (ISO/IEC 9945-1:1996)\n################################################################################\n\nAC_CHECK_HEADER(pthread.h, [ AC_CHECK_LIB(pthread, pthread_create, [\n    AC_DEFINE(HAVE_POSIX_THREADS, 1, [Define to 1 if you have POSIX threads.])\n], [\n    AC_MSG_FAILURE([cannot locate POSIX thread library and/or headers.])\n]) ])\n\n################################################################################\n# Check for TLS option, default to implicit\n################################################################################\n\nAC_ARG_WITH(tls,\n            AC_HELP_STRING([--with-tls=TYPE],\n                           [tls (implicit, explicit) @<:@explicit@:>@]),\n            TLS=$withval, TLS=\"explicit\")\n\ncase \"$TLS\" in\n    implicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, false)\n        ;;\n\n    explicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, true)\n        AC_DEFINE(USE_EXPLICIT_TLS, 1, [Define to 1 if you want to use an explicit TLS implementation instead of the __thread keyword.])\n        ;;\n\n    *)\n        AC_MSG_ERROR([invalid tls specification \"$TLS\".])\n        ;;\nesac\n\n################################################################################\n# Begin Target O/S Specification\n################################################################################\n\ntarget_os=$host\nAC_MSG_CHECKING(for Target O/S)\nAC_ARG_WITH(target-os,\n    AC_HELP_STRING([--with-target-os=TARGET_OS],\n                   [target os specification @<:@$host@:>@]),\n                    TARGET_OS=$withval, TARGET_OS=\"$host\")\n\n\nAM_CONDITIONAL(BUILD_TARGETED, false)\nAM_CONDITIONAL(HAVE_TARGET_STATIC, false)\n\nbuild_targeted=0\ncase \"$TARGET_OS\" in\n    cray-xk)\n\tAC_DEFINE(TARGET_OS_CRAYXK, 1, [Do not define if not building for targeted cray-xk.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xk,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xe)\n\tAC_DEFINE(TARGET_OS_CRAYXE, 1, [Do not define if not building for targeted cray-xe.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xe,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt5)\n\tAC_DEFINE(TARGET_OS_CRAYXT5, 1, [Do not define if not building for targeted cray-xt5.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt5,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt4)\n\tAC_DEFINE(TARGET_OS_CRAYXT4, 1, [Do not define if not building for targeted cray-xt4.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt4,\n\t\t\t[Name targeted OS])\n\t;;\n    bgl)\n        AM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n        AC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGL, 1, [Do not define if not building for targeted bgl.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgl,\n\t\t\t[Name targeted OS])\n\tbuild_targeted=1\n\t;;\n    bgp)\n        AM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n        AC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGP, 1, [Do not define if not building for targeted bgp.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgp,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=1\n\t;; \n    bgq)\n        AM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n        AC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGQ, 1, [Do not define if not building for targeted bgq.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgq,\n                           [Name targeted OS])\n\tbuild_targeted=1\n        ;;\n    *)\n        AM_CONDITIONAL(HAVE_TARGET_STATIC, false)\n        AC_DEFINE([HAVE_TARGET_STATIC], [0],[Define to 0 for targeted non-static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, false)\n\tAC_DEFINE(BUILD_TARGETED, 0, [Define to 1 if building a targeted runtime.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,$host,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=0\n\t;; \nesac\n\nAC_SUBST(BUILD_TARGETED)\nAC_SUBST(TARGET_OS)\n################################################################################\n# End Target O/S Specification\n################################################################################\n\n################################################################################\n# Check for Additional Packages\n################################################################################\n\n#AX_BINUTILS()\nAX_LIBMONITOR()\n#AX_LIBUNWIND()\n#AX_PAPI()\n\nAX_BOOST_BASE([1.35.0])\nAX_BOOST_DATE_TIME()\nAX_BOOST_SYSTEM()\nAX_BOOST_THREAD()\nAX_BOOST_FILESYSTEM()\nAX_BOOST_PROGRAM_OPTIONS()\nAX_BOOST_UNIT_TEST_FRAMEWORK()\n\nAX_XERCESC()\nif test \"$LIBXERCES_C_LIBS\" = \"-lxerces-c\" ; then\n  AX_XERCESC_VERSION()\nfi\n\nAX_CBTF()\nAX_CBTF_XML()\n\nAX_LIBELF()\nAX_LIBDWARF()\nAX_DYNINST()\nAX_MRNET()\nAX_MESSAGES()\n#AX_PYTHON()\nAX_PYTHON_DEVEL([>= '2.3'])\nAX_BOOST_PYTHON()\n\nAC_CONFIG_FILES([\n    Makefile\n    include/Makefile\n    libltdl/Makefile\n    src/Makefile\n    src/daemonToolDemo/Makefile\n    src/pcsamp/Makefile\n    src/python/Makefile\n])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/examples/src/python/pyExample.cpp": "#include <boost/bind.hpp>\n#include <typeinfo>\n#include <stdio.h>\n#include <sys/param.h>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <time.h>\n#include <sys/time.h>\n#include <cmath>\n#include <boost/python.hpp>\n#include <boost/python/module.hpp>\n#include <boost/python/suite/indexing/vector_indexing_suite.hpp>\n#include <Python.h>\n#include <KrellInstitute/CBTF/Component.hpp>\n#include <KrellInstitute/CBTF/Type.hpp>\n#include <KrellInstitute/CBTF/Version.hpp>\n\n// typedefs used by this tool\ntypedef std::string ToolInputArgs;\ntypedef std::vector<std::string> PYvalues;\n\nusing namespace KrellInstitute::CBTF;\n\nnamespace {\n\nstatic bool done = false;\n\n#ifndef NO_DLFCN_HACK\n#include <dlfcn.h>\nstatic int dlopen_hacked = 0;\nint dlopen_python_hack()\n{\n    if (!dlopen_hacked) {\n        dlopen(LIBPYTHON, RTLD_NOW|RTLD_GLOBAL);\n        dlopen_hacked = 1;\n    }\n}\n#else\n#define dlopen_python_hack()\n#endif\n\n// Parses the value of the active python exception\n// NOTE SHOULD NOT BE CALLED IF NO EXCEPTION\nstd::string parse_python_exception(){\n    PyObject *type_ptr = NULL, *value_ptr = NULL, *traceback_ptr = NULL;\n    // Fetch the exception info from the Python C API\n    PyErr_Fetch(&type_ptr, &value_ptr, &traceback_ptr);\n\n    // Fallback error\n    std::string ret(\"Unfetchable Python error\");\n    // If the fetch got a type pointer, parse the type into the exception string\n    if(type_ptr != NULL){\n        boost::python::handle<> h_type(type_ptr);\n        boost::python::str type_pstr(h_type);\n        // Extract the string from the boost::python object\n        boost::python::extract<std::string> e_type_pstr(type_pstr);\n        // If a valid string extraction is available, use it \n        //  otherwise use fallback\n        if(e_type_pstr.check())\n            ret = e_type_pstr();\n        else\n            ret = \"Unknown exception type\";\n    }\n    // Do the same for the exception value (the stringification of the exception)\n    if(value_ptr != NULL){\n        boost::python::handle<> h_val(value_ptr);\n        boost::python::str a(h_val);\n        boost::python::extract<std::string> returned(a);\n        if(returned.check())\n            ret +=  \": \" + returned();\n        else\n            ret += std::string(\": Unparseable Python error: \");\n    }\n    // Parse lines from the traceback using the Python traceback module\n    if(traceback_ptr != NULL){\n        boost::python::handle<> h_tb(traceback_ptr);\n        // Load the traceback module and the format_tb function\n        boost::python::object tb(boost::python::import(\"traceback\"));\n        boost::python::object fmt_tb(tb.attr(\"format_tb\"));\n        // Call format_tb to get a list of traceback strings\n        boost::python::object tb_list(fmt_tb(h_tb));\n        // Join the traceback strings into a single string\n        boost::python::object tb_str(boost::python::str(\"\\n\").join(tb_list));\n        // Extract the string, check the extraction, and fallback in necessary\n        boost::python::extract<std::string> returned(tb_str);\n        if(returned.check())\n            ret += \": \" + returned();\n        else\n            ret += std::string(\": Unparseable Python traceback\");\n    }\n    return ret;\n}\n\nstatic void printUsageExample() {\n    std::cout << \"daemonTool --tool \\\"path to python xml tool\\\" --toolargs \\\"pyexample.py\\\"\" << std::endl;\n}\n\n} // namespace\n\n\n/**\n *\n * Component type used by the unit test for the Component class.\n */\nclass __attribute__ ((visibility (\"hidden\"))) PyExampleView :\npublic Component {\n\n    public:\n    /** Factory function for this component type. */\n    static Component::Instance factoryFunction()\n    {\n        return Component::Instance(\n                reinterpret_cast<Component*>(new PyExampleView())\n                );\n    }\n\n    private:\n    /** Default constructor. */\n    PyExampleView() :\n        Component(Type(typeid(PyExampleView)), Version(1, 0, 0))\n    {\n\t    // input here is a vector of strings of results.\n\t    declareInput<std::vector<std::string> >(\n                \"ResultVecIn\", boost::bind(&PyExampleView::resultVecHandler, this, _1)\n                );\n\t    declareOutput<bool>(\"finished\");\n    }\n\n    /** Handler for the \"in\" input.*/\n    void resultVecHandler(const std::vector<std::string> & results)\n    { \n        for(std::vector<std::string> ::const_iterator si = results.begin();\n            si != results.end(); ++si) {\n            std::cout << *si << std::endl;;\n        }\n\n\tdone = true;\n\temitOutput<bool>(\"finished\", true );\n    }\n}; // end class PyExampleView\n\nKRELL_INSTITUTE_CBTF_REGISTER_FACTORY_FUNCTION(PyExampleView)\n\n/**\n *\n * Component type used by the unit test for the Component class.\n */\nclass __attribute__ ((visibility (\"hidden\"))) PyExampleFE :\npublic Component {\n\n    public:\n\n    /** Factory function for this component type. */\n    static Component::Instance factoryFunction()\n    {\n        return Component::Instance(\n                reinterpret_cast<Component*>(new PyExampleFE())\n                );\n    }\n\n\n    private:\n\n    /** Default constructor. */\n    PyExampleFE() : Component(Type(typeid(PyExampleFE)), Version(1, 0, 0))\n    {\n\t// input arguments from client (daemonTool).\n\tdeclareInput<ToolInputArgs>(\n            \"args\", boost::bind(&PyExampleFE::argsHandler, this, _1)\n            );\n\n\t// incoming terminate signal\n\tdeclareInput<bool> (\n            \"TerminateIn\",\n            boost::bind(&PyExampleFE::terminateHandler, this, _1)\n            );\n\n\t// output got python script to run.\n\tdeclareOutput<std::string>(\"PyScriptNameOut\");\n\tdeclareOutput<bool>(\"TerminateOut\");\n\t\n    }\n\n    bool terminate;  // when true, shutdown tool.\n\n    /** Handler for the tool \"args\" input.*/\n    void argsHandler(const ToolInputArgs& toolargs)\n    { \n\t// inititialize termination value\n\tterminate = false;\n\n\t// parse input string\n\tstd::string py_script_name = \"\";\n\tstd::string tmparg = toolargs;\n\tstd::stringstream argstream(tmparg);\n\targstream >> py_script_name;\n\n\n\t// send the python script name to run downstream.\n\tif( py_script_name == \"\" ) {\n\t    std::cerr << \"Error must include vaild python script name\" << std::endl;\n\t    printUsageExample();\n\t    terminate = true;\n\t    return;\n\t} else {\n            emitOutput<std::string>(\"PyScriptNameOut\", py_script_name ); \n\t}\n\n        struct timespec tim, tim2;\n        tim.tv_sec = 0;\n        tim.tv_nsec = 250000000L;\n        while(!terminate) {\n            nanosleep(&tim , &tim2);\n        };\n\n    }\n\n    // record the termination signal.\n    void terminateHandler(const bool & terminate_signal) {\n        terminate = terminate_signal;\n    }\n\n}; // end class PyExampleFE\n\nKRELL_INSTITUTE_CBTF_REGISTER_FACTORY_FUNCTION(PyExampleFE)\n\n/**\n * Component type used by the unit test for the Component class.\n */\nclass __attribute__ ((visibility (\"hidden\"))) PyExampleBE :\npublic Component\n{\n\npublic:\n    /** Factory function for this component type. */\n    static Component::Instance factoryFunction()\n    {\n        return Component::Instance(\n                reinterpret_cast<Component*>(new PyExampleBE())\n                );\n    }\n\nprivate:\n    /** Default constructor. */\n    PyExampleBE() :\n        Component(Type(typeid(PyExampleBE)), Version(1, 0, 0))\n    {\n\t// input for executable name to aquire pid(s) for.\n        declareInput<std::string>(\n            \"PyScriptNameIn\", boost::bind(&PyExampleBE::PyScriptNameHandler, this, _1)\n            );\n\n\t// output from script as vector of strings.\n        declareOutput<std::vector<std::string> >(\"PyExampleStrVecOut\");\n\t// output for termination signal.\n        declareOutput<bool> (\"TerminateOut\");\n    }\n\n    /** Handler for the \"ExeNameIn\" input.*/\n    void PyScriptNameHandler(const std::string& in)\n    { \n        bool be_terminate;\n        std::vector<std::string>  rvecout;\n\n\tdlopen_python_hack();\n\n// Disabling this code due to installation issues with boost python and\n// python on various fedora systems. This is intended to demonstrate\n// running boost python bindings with in a component plugin.\n#if 0\n\ttry {\n\n\t    Py_Initialize();\n\t    // using boost::python objects. Generate random number from random module.\n\t    boost::python::object  main_module = boost::python::import(\"__main__\");\n\t    boost::python::object  random_module = boost::python::import(\"random\");\n\t    boost::python::object  random_func = random_module.attr(\"random\");\n\t    boost::python::object  rand_val = random_func();\n\t    std::stringstream python_output;\n\t    double tval = boost::python::extract<double>(rand_val);\n\t    python_output << \"Testing boost python bindings...\" << std::endl;\n\t    python_output << \"value from python random func: \" << tval << std::endl;\n\t    rvecout.push_back(python_output.str());\n\t    Py_Finalize();\n\n\t    // Run a script via PyRun_SimpleFile.\n\t    python_output << \"Test running passed python script \" << in << std::endl;\n\t} catch(boost::python::error_already_set const &) {\n\t    std::string perror_str = parse_python_exception();\n\t    std::cerr << \"Error in Python: \" << perror_str << std::endl;\n\t}\n#endif\n\n\tPy_Initialize();\n\n\tFILE* fp = fopen(in.c_str(), \"r\");\n\tPyRun_SimpleFile(fp, in.c_str());\n\tPy_Finalize();\n\n\t// Run passed python script via python cmd via popen.\n\tchar buffer[4096];\n\tmemset(&buffer,0,sizeof(buffer));\n\tstd::string cmd = \"/usr/bin/python \" + in;\n\tstd::string outline = \"\";\n\trvecout.push_back(\"executing python script: \" + cmd);\n\tFILE* p = popen(cmd.c_str(), \"r\");\n\tif(p != NULL) {\n\t    while(fgets(buffer, sizeof(buffer), p) != NULL)\n            {\n\t\toutline.assign(buffer);\n\t\trvecout.push_back(outline);\n            }\n            pclose(p);\n        }\n\n        if(rvecout.size() == 0) {\n\t    // no output... be_terminate.\n\t    std::cerr << \"PyExampleBE::PyScriptNameHandler outputsize is 0, be_terminate = true\" <<  std::endl;\n            be_terminate = true;\n        } else {\n\t    // emit the output\n            emitOutput<std::vector<std::string> >(\"PyExampleStrVecOut\", rvecout ); \n            be_terminate = true;\n        }\n\n\t// emit the termination signal.\n        emitOutput<bool>(\"TerminateOut\", be_terminate);\n    }\n}; // end class PyExampleBE\n\nKRELL_INSTITUTE_CBTF_REGISTER_FACTORY_FUNCTION(PyExampleBE)\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/contrib/configure.ac": "################################################################################\n# Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 2 of the License, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n# details.\n#\n# You should have received a copy of the GNU General Public License along with\n# this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n# Place, Suite 330, Boston, MA  02111-1307  USA\n################################################################################\n\nAC_INIT([contrib], [1.0])\nAC_COPYRIGHT([[Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.]])\n\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE\nAM_CONFIG_HEADER([config.h])\n\nAH_TOP([\n/*******************************************************************************\n** Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n])\n\nAC_GNU_SOURCE\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_LIBTOOL\nAC_PROG_INSTALL\n\nLT_CONFIG_LTDL_DIR([libltdl])\nLT_INIT([dlopen])\nLTDL_INIT([recursive])\n\nAC_PATH_PROG([RPCGEN], rpcgen)\nAC_PROG_LN_S\n\n################################################################################\n# Handle PowerPC and X86-64 Special Cases\n################################################################################\nAC_ARG_WITH(ppc64_bitmode,\n            AC_HELP_STRING([--with-ppc64-bitmode=<32,64>],\n                           [Specify ppc64 library bit mode @<:@64@:>@]),\n            ppc64_bitmode=$withval, ppc64_bitmode=\"64\")\n\nAC_MSG_CHECKING([Configuring for host = $host  with ppc64_bitmode = $ppc64_bitmode])\n\ncase \"$host\" in\n    powerpc-*-linux*)\n        AC_MSG_CHECKING([Configuring for powerpc-star-linux])\n\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n            libdir='${exec_prefix}/lib'\n        fi\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\n    powerpc64-*-*)\n\n        AC_MSG_CHECKING([Configuring for powerpc64-star-linux with ppc64_bitmode = $ppc64_bitmode])\n        if test \"$ppc64_bitmode\" = \"64\" ; then\n                AC_MSG_CHECKING([Configuring for 64 bit powerpc64-star-linux host])\n                abi_libdir=\"lib64\"\n                alt_abi_libdir=\"lib\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n                    libdir='${exec_prefix}/lib64'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib64 $LDFLAGS\"\n                CFLAGS=\"-m64 $CFLAGS\"\n                CXXFLAGS=\"-m64 $CXXFLAGS\"\n                CPPFLAGS=\"-m64 $CPPFLAGS\"\n        elif test \"$ppc64_bitmode\" = \"32\" ; then\n                AC_MSG_CHECKING([Configuring for 32 bit powerpc64-star-linux host])\n                abi_libdir=\"lib\"\n                alt_abi_libdir=\"lib64\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n                    libdir='${exec_prefix}/lib'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        fi\n        ;;\n\n    x86_64-*-linux*)\n        AC_MSG_CHECKING([Configuring for x86_64--star-linux host])\n        if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n            libdir='${exec_prefix}/lib64'\n        fi\n        abi_libdir=\"lib64\"\n        alt_abi_libdir=\"lib\"\n        LDFLAGS=\"$LDFLAGS\"\n        ;;\n\n    *)\n        AC_MSG_CHECKING([Configuring for default host])\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\nesac\ntopdir_execprefix=${exec_prefix}\nAC_SUBST(topdir_execprefix)\n\nabi_libdir_name=${abi_libdir}\nAC_SUBST(abi_libdir_name)\nalt_abi_libdir_name=${alt_abi_libdir}\nAC_SUBST(alt_abi_libdir_name)\n\ncbtf_platform=`uname -i`\ncbtf_hardware_platform=$cbtf_platform\nAC_MSG_CHECKING([Checking for cbtf_hardware_platform=$cbtf_hardware_platform])\nAC_SUBST(cbtf_hardware_platform)\n\n\n################################################################################\n# Check for POSIX Threads (ISO/IEC 9945-1:1996)\n################################################################################\n\nAC_CHECK_HEADER(pthread.h, [ AC_CHECK_LIB(pthread, pthread_create, [\n    AC_DEFINE(HAVE_POSIX_THREADS, 1, [Define to 1 if you have POSIX threads.])\n], [\n    AC_MSG_FAILURE([cannot locate POSIX thread library and/or headers.])\n]) ])\n\n\n\n################################################################################\n# Check for TLS option, default to implicit\n################################################################################\n\nAC_ARG_WITH(tls,\n            AC_HELP_STRING([--with-tls=TYPE],\n                           [tls (implicit, explicit) @<:@explicit@:>@]),\n            TLS=$withval, TLS=\"explicit\")\n\ncase \"$TLS\" in\n    implicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, false)\n        ;;\n\n    explicit)\n        AM_CONDITIONAL(USE_EXPLICIT_TLS, true)\n        AC_DEFINE(USE_EXPLICIT_TLS, 1, [Define to 1 if you want to use an explicit TLS implementation instead of the __thread keyword.])\n        ;;\n\n    *)\n        AC_MSG_ERROR([invalid tls specification \"$TLS\".])\n        ;;\nesac\n\n################################################################################\n# Begin Target O/S Specification\n################################################################################\n\ntarget_os=$host\nAC_MSG_CHECKING(for Target O/S)\nAC_ARG_WITH(target-os,\n    AC_HELP_STRING([--with-target-os=TARGET_OS],\n                   [target os specification @<:@$host@:>@]),\n                    TARGET_OS=$withval, TARGET_OS=\"$host\")\n\n\nAM_CONDITIONAL(HAVE_TARGET_STATIC, false)\nAM_CONDITIONAL(BUILD_TARGETED, false)\n\nbuild_targeted=0\ncase \"$TARGET_OS\" in\n    cray-xk)\n\tAC_DEFINE(TARGET_OS_CRAYXK, 1, [Do not define if not building for targeted cray-xk.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xk,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xe)\n\tAC_DEFINE(TARGET_OS_CRAYXE, 1, [Do not define if not building for targeted cray-xe.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xe,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt5)\n\tAC_DEFINE(TARGET_OS_CRAYXT5, 1, [Do not define if not building for targeted cray-xt5.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt5,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt4)\n\tAC_DEFINE(TARGET_OS_CRAYXT4, 1, [Do not define if not building for targeted cray-xt4.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt4,\n\t\t\t[Name targeted OS])\n\t;;\n    bgl)\n        AM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n        AC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGL, 1, [Do not define if not building for targeted bgl.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgl,\n\t\t\t[Name targeted OS])\n\tbuild_targeted=1\n\t;;\n    bgp)\n        AM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n        AC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGP, 1, [Do not define if not building for targeted bgp.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgp,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=1\n\t;; \n    bgq)\n        AM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n        AC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGQ, 1, [Do not define if not building for targeted bgq.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgq,\n                           [Name targeted OS])\n\tbuild_targeted=1\n        ;;\n    *)\n        AM_CONDITIONAL(HAVE_TARGET_STATIC, false)\n        AC_DEFINE([HAVE_TARGET_STATIC], [0],[Define to 0 for targeted non-static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, false)\n\tAC_DEFINE(BUILD_TARGETED, 0, [Define to 1 if building a targeted runtime.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,$host,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=0\n\t;; \nesac\n\nAC_SUBST(BUILD_TARGETED)\nAC_SUBST(TARGET_OS)\n################################################################################\n# End Target O/S Specification\n################################################################################\n\n\n################################################################################\n# build runtime collector software only\n################################################################################\n#\n# Option: \n#\nAC_MSG_CHECKING(for building runtime collectors only)\nAC_ARG_ENABLE([runtime-only],\n    [AS_HELP_STRING([--enable-runtime-only],\n        [Enable support building just the runtime collectors with no client [default=no]])],\n    [], [enable_runtime_only=no])\n\nif test \"x$enable_runtime_only\" = xyes ; then\n    AM_CONDITIONAL(BUILD_RUNTIME, true)\n    AC_DEFINE(BUILD_RUNTIME, 1, [Define to 1 if you do want only collector runtime support built.])\nelse\n    AM_CONDITIONAL(BUILD_RUNTIME, false)\n    AC_DEFINE(BUILD_RUNTIME, 0, [Define to 1 if you do not want only collector runtime support built.])\nfi\nAC_SUBST(BUILD_RUNTIME)\n\n\n################################################################################\n# Check for Additional Packages\n################################################################################\n\nAX_BINUTILS()\nAX_LIBMONITOR()\nAX_LIBUNWIND()\nAX_PAPI()\n\n\nAX_BOOST_BASE([1.35.0])\nAX_BOOST_DATE_TIME()\nAX_BOOST_SYSTEM()\nAX_BOOST_THREAD()\nAX_BOOST_FILESYSTEM()\nAX_BOOST_UNIT_TEST_FRAMEWORK()\nAX_BOOST_PROGRAM_OPTIONS()\n\nAX_XERCESC()\nif test \"$LIBXERCES_C_LIBS\" = \"-lxerces-c\" ; then\n  AX_XERCESC_VERSION()\nfi\n\nAX_CBTF()\nAX_CBTF_XML()\n\nAX_LIBDWARF()\nAX_DYNINST()\nAX_MRNET()\nAX_MESSAGES()\n\nAC_CONFIG_FILES([\n    Makefile\n    memTool/Makefile\n    psTool/Makefile\n    stack/Makefile\n    tbonFS/Makefile\n    repeatingMemTool/Makefile\n])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/messages/configure.ac": "################################################################################\n# Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 2 of the License, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n# details.\n#\n# You should have received a copy of the GNU General Public License along with\n# this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n# Place, Suite 330, Boston, MA  02111-1307  USA\n################################################################################\n\nAC_INIT([messages], [1.0])\nAC_COPYRIGHT([[Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.]])\n\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE ([foreign])\n\nAM_CONFIG_HEADER([config.h])\n\nAH_TOP([\n/*******************************************************************************\n** Copyright (c) 2010-2013 Krell Institute. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n])\n\nAC_GNU_SOURCE\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_LIBTOOL\nAC_PROG_INSTALL\n\nLT_CONFIG_LTDL_DIR([libltdl])\nLT_INIT([dlopen])\nLTDL_INIT([recursive])\n\nAC_PATH_PROG([RPCGEN], rpcgen)\nAC_PROG_LN_S\n\n################################################################################\n# Handle PowerPC and X86-64 Special Cases\n################################################################################\nAC_ARG_WITH(ppc64_bitmode,\n            AC_HELP_STRING([--with-ppc64-bitmode=<32,64>],\n                           [Specify ppc64 library bit mode @<:@64@:>@]),\n            ppc64_bitmode=$withval, ppc64_bitmode=\"64\")\n\nAC_MSG_CHECKING([Configuring for host = $host  with ppc64_bitmode = $ppc64_bitmode])\n\ncase \"$host\" in\n    powerpc-*-linux*)\n        AC_MSG_CHECKING([Configuring for powerpc-star-linux])\n\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n            libdir='${exec_prefix}/lib'\n        fi\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\n    powerpc64-*-*)\n\n        AC_MSG_CHECKING([Configuring for powerpc64-star-linux with ppc64_bitmode = $ppc64_bitmode])\n        if test \"$ppc64_bitmode\" = \"64\" ; then\n                AC_MSG_CHECKING([Configuring for 64 bit powerpc64-star-linux host])\n                abi_libdir=\"lib64\"\n                alt_abi_libdir=\"lib\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n                    libdir='${exec_prefix}/lib64'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib64 $LDFLAGS\"\n                CFLAGS=\"-m64 $CFLAGS\"\n                CXXFLAGS=\"-m64 $CXXFLAGS\"\n                CPPFLAGS=\"-m64 $CPPFLAGS\"\n        elif test \"$ppc64_bitmode\" = \"32\" ; then\n                AC_MSG_CHECKING([Configuring for 32 bit powerpc64-star-linux host])\n                abi_libdir=\"lib\"\n                alt_abi_libdir=\"lib64\"\n                if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n                    libdir='${exec_prefix}/lib'\n                fi\n                LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        fi\n        ;;\n\n    x86_64-*-linux*)\n        AC_MSG_CHECKING([Configuring for x86_64--star-linux host])\n        if test -d /usr/lib/x86_64-linux-gnu ; then\n          if test x\"$libdir\" == x'${exec_prefix}/lib64'; then\n            libdir='${exec_prefix}/lib'\n          fi\n          abi_libdir=\"lib\"\n          alt_abi_libdir=\"lib64\"\n          LDFLAGS=\"$LDFLAGS\"\n        else\n          if test x\"$libdir\" == x'${exec_prefix}/lib'; then\n            libdir='${exec_prefix}/lib64'\n          fi\n          abi_libdir=\"lib64\"\n          alt_abi_libdir=\"lib\"\n          LDFLAGS=\"$LDFLAGS\"\n        fi\n        ;;\n\n    *)\n        AC_MSG_CHECKING([Configuring for default host])\n        abi_libdir=\"lib\"\n        alt_abi_libdir=\"lib64\"\n        LDFLAGS=\"-DLIB_DIR=lib $LDFLAGS\"\n        ;;\nesac\ntopdir_execprefix=${exec_prefix}\nAC_SUBST(topdir_execprefix)\n\nabi_libdir_name=${abi_libdir}\nAC_SUBST(abi_libdir_name)\nalt_abi_libdir_name=${alt_abi_libdir}\nAC_SUBST(alt_abi_libdir_name)\n\ncbtf_platform=`uname -i`\ncbtf_hardware_platform=$cbtf_platform\nAC_MSG_CHECKING([Checking for cbtf_hardware_platform=$cbtf_hardware_platform])\nAC_SUBST(cbtf_hardware_platform)\n\n\n################################################################################\n# Check for POSIX Threads (ISO/IEC 9945-1:1996)\n################################################################################\n\nAC_CHECK_HEADER(pthread.h, [ AC_CHECK_LIB(pthread, pthread_create, [\n    AC_DEFINE(HAVE_POSIX_THREADS, 1, [Define to 1 if you have POSIX threads.])\n], [\n    AC_MSG_FAILURE([cannot locate POSIX thread library and/or headers.])\n]) ])\n\n\n\n################################################################################\n# Begin Target O/S Specification\n################################################################################\n\ntarget_os=$host\nAC_MSG_CHECKING(for Target O/S)\nAC_ARG_WITH(target-os,\n    AC_HELP_STRING([--with-target-os=TARGET_OS],\n                   [target os specification @<:@$host@:>@]),\n                    TARGET_OS=$withval, TARGET_OS=\"$host\")\n\n\nAM_CONDITIONAL(HAVE_TARGET_STATIC, false)\nAM_CONDITIONAL(BUILD_TARGETED, false)\nbuild_targeted=0\ncase \"$TARGET_OS\" in\n    cray-xk)\n\tAC_DEFINE(TARGET_OS_CRAYXK, 1, [Do not define if not building for targeted cray-xk.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xk,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xe)\n\tAC_DEFINE(TARGET_OS_CRAYXE, 1, [Do not define if not building for targeted cray-xe.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xe,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt5)\n\tAC_DEFINE(TARGET_OS_CRAYXT5, 1, [Do not define if not building for targeted cray-xt5.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt5,\n\t\t\t[Name targeted OS])\n\t;;\n    cray-xt4)\n\tAC_DEFINE(TARGET_OS_CRAYXT4, 1, [Do not define if not building for targeted cray-xt4.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,cray-xt4,\n\t\t\t[Name targeted OS])\n\t;;\n    bgl)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGL, 1, [Do not define if not building for targeted bgl.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgl,\n\t\t\t[Name targeted OS])\n\tbuild_targeted=1\n\t;;\n    bgp)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, true)\n\tAC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n\tAC_DEFINE(TARGET_OS_BGP, 1, [Do not define if not building for targeted bgp.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,bgp,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=1\n\t;; \n    bgq)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, true)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [1],[Define to 1 targeted static builds.])\n        AM_CONDITIONAL(BUILD_TARGETED, true)\n        AC_DEFINE(BUILD_TARGETED, 1, [Define to 0 if not building a targeted runtime.])\n        AC_DEFINE(TARGET_OS_BGQ, 1, [Do not define if not building for targeted bgq.])\n        AC_DEFINE_UNQUOTED(TARGET_OS,bgq,\n                           [Name targeted OS])\n\tbuild_targeted=1\n        ;;\n    *)\n\tAM_CONDITIONAL(HAVE_TARGET_STATIC, false)\n\tAC_DEFINE([HAVE_TARGET_STATIC], [0],[Define to 0 for targeted non-static builds.])\n\tAM_CONDITIONAL(BUILD_TARGETED, false)\n\tAC_DEFINE(BUILD_TARGETED, 0, [Define to 1 if building a targeted runtime.])\n\tAC_DEFINE_UNQUOTED(TARGET_OS,$host,\n\t\t\t   [Name targeted OS])\n\tbuild_targeted=0\n\t;; \nesac\n\nAC_SUBST(BUILD_TARGETED)\nAC_SUBST(TARGET_OS)\n\n################################################################################\n# End Target O/S Specification\n################################################################################\n\nAM_CONDITIONAL(HAVE_XERCES, false)\nAM_CONDITIONAL(HAVE_MRNET, false)\n\nAX_BOOST_BASE([1.35.0])\nAX_BOOST_SYSTEM()\nAX_BOOST_THREAD()\nAX_BOOST_FILESYSTEM()\nAX_XERCESC()\n# This helps with targeted builds when there is no xercesc\nif test \"$LIBXERCES_C\" = \"-lxerces-c\" ; then\n  AX_XERCESC_VERSION()\nfi\nAX_CBTF()\nAX_CBTF_XML()\nAX_MRNET()\nAX_CBTF_MRNET()\n\nAC_CONFIG_FILES([\n    Makefile\n    libltdl/Makefile\n    include/Makefile\n    src/Makefile\n    src/base/Makefile\n    src/collector/Makefile\n    src/events/Makefile\n    src/instrumentation/Makefile\n    src/perfdata/Makefile\n    src/symtab/Makefile\n    src/thread/Makefile\n    examples/Makefile\n])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/messages/src/events/LinkedObjectEvents.x": "/*******************************************************************************\n** Copyright (c) 2007,2008 William Hachfeld. All Rights Reserved.\n** Copyright (c) 2011 Krell Institute. All Rights Reserved.\n**\n** This program is free software; you can redistribute it and/or modify it under\n** the terms of the GNU General Public License as published by the Free Software\n** Foundation; either version 2 of the License, or (at your option) any later\n** version.\n**\n** This program is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n** details.\n**\n** You should have received a copy of the GNU General Public License along with\n** this program; if not, write to the Free Software Foundation, Inc., 59 Temple\n** Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file\n *\n * Specification of the linkedobject events communication protocol.\n *\n */\n\n%#include \"Address.h\"\n%#include \"Blob.h\"\n%#include \"File.h\"\n%#include \"Thread.h\"\n%#include \"Time.h\"\n\n\n/**\n * Linked object has been loaded.\n *\n * Issued by a backend to indicate that the specified linked object has\n * been loaded into the address space of the specified threads. Includes\n * the time at which the load occurred as well as a description of what\n * was loaded.\n *\n * @note    This message is always sent multiple times in conjunction with\n *          an AttachedToThreads message. But it is also sent by a backend\n *          when a linked object is loaded due to a dlopen().\n */\nstruct CBTF_Protocol_LoadedLinkedObject\n{\n    /** Threads which loaded the linked object. */\n    CBTF_Protocol_ThreadNameGroup threads;\n\n    /** Time at which the linked object was loaded. */\n    CBTF_Protocol_Time time;\n    \n    /** Address range at which this linked object was loaded. */\n    CBTF_Protocol_AddressRange range;\n\n    /** Name of the linked object's file. */\n    CBTF_Protocol_FileName linked_object;\n\n    /**\n     * Boolean \"true\" if this linked object is an\n     * executable, or \"false\" otherwise.\n     */\n    bool is_executable;\n};\n\n\n\n/**\n * Linked object has been unloaded.\n *\n * Issued by a backend to indicate that the specified linked object has\n * been unloaded from the address space of the specified threads. Includes\n * the time at which the unload occurred as well as a description of what\n * was unloaded.\n *\n * @note    This message is sent only when a linked object is unloaded\n *          due to a dlclose() in the threads.\n */\nstruct CBTF_Protocol_UnloadedLinkedObject\n{\n    /** Threads which unloaded the linked object. */\n    CBTF_Protocol_ThreadNameGroup threads;\n\n    /** Time at which the linked object was unloaded. */\n    CBTF_Protocol_Time time;\n    \n    /** Name of the linked object's file. */\n    CBTF_Protocol_FileName linked_object;\n};\n\n\n/** Structure of the blob containing our file objects.\n * Used by libmonitor based collection code.\n*/\nstruct CBTF_Protocol_LinkedObject {\n\n    /** Name of the linked object's file. */\n    CBTF_Protocol_FileName linked_object;\n\n    /** Address range at which this linked object was loaded. */\n    CBTF_Protocol_AddressRange range;\n\n    /** Time at which the linked object was loaded. */\n    CBTF_Protocol_Time time_begin;\n\n    /** Time at which the linked object was unloaded. */\n    /** For this purpose, the end time is -ULL */\n    CBTF_Protocol_Time time_end;\n\n    /**\n     * Boolean \"true\" if this linked object is an\n     * executable, or \"false\" otherwise.\n     */\n    bool is_executable;\n};\n\n/* this message is the group of linked object initially\n * loaded in a process or thread. Used by libmonitor based\n * collection code.\n */\nstruct CBTF_Protocol_LinkedObjectGroup {\n    /** Thread which contains these linked objects. */\n    CBTF_Protocol_ThreadName thread;\n    CBTF_Protocol_LinkedObject linkedobjects<>;\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/messages/src/events/OfflineEvents.x": "/*******************************************************************************\n** Copyright (c) 2011 The Krell Institue. All Rights Reserved.\n**\n** This library is free software; you can redistribute it and/or modify it under\n** the terms of the GNU Lesser General Public License as published by the Free\n** Software Foundation; either version 2.1 of the License, or (at your option)\n** any later version.\n**\n** This library is distributed in the hope that it will be useful, but WITHOUT\n** ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n** FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n** details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this library; if not, write to the Free Software Foundation, Inc.,\n** 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*******************************************************************************/\n\n/** @file\n *\n * Specification of the offline specific blobs.\n *\n */\n\n/** Structure of the blob containing our file objects. */\nstruct CBTF_Protocol_Offline_LinkedObject {\n    string   objname<>;     /** < Name of the object. */\n    uint64_t addr_begin;    /** < begin address of object */\n    uint64_t addr_end;      /** < end address of object */\n    uint64_t time_begin;    /** < load time of object */\n    uint64_t time_end;      /** < close time of object */\n    uint8_t  is_open;       /** < flag to indicate dlopen or dlclose */\n    bool  is_executable; /** < flag to indicate dlopen or dlclose */\n};\n\nstruct CBTF_Protocol_Offline_LinkedObjectGroup {\n    CBTF_Protocol_Offline_LinkedObject linkedobjects<>;\n};\n\n/** Structure of the blob containing our process info. */\nstruct CBTF_Protocol_Offline_Parameters {\n    string   collector<>;  /** < Name of the collector. */\n    string   exename<>;    /** < Name of the executable. */\n    string   traced<>;     /** < list of colon separated traceable functions.*/\n    string   event<>;      /** < list of colon separated traceable events. */\n    uint32_t rate;\t   /** < rate or threshold parameter for this object */\n};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/.git/objects/pack/pack-a70f297d1fafb329aaee6b3dc26c29e972a4365e.idx",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/.git/objects/pack/pack-a70f297d1fafb329aaee6b3dc26c29e972a4365e.pack",
        "/tmp/vanessa/spack-stage/spack-stage-cbtf-krell-1.9.1.2-pixfab2mn72oojjqpjmkowvod7ph7ldr/spack-src/contrib/XXXXtool.tar.gz"
    ],
    "total_files": 604
}