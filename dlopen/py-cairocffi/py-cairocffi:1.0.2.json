{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-cairocffi-1.0.2-hhziqiykk5ss6nwb4nzppy7smlmjcftm/spack-src/cairocffi/__init__.py": "\"\"\"\n    cairocffi\n    ~~~~~~~~~\n\n    CFFI-based cairo bindings for Python. See README for details.\n\n    :copyright: Copyright 2013-2019 by Simon Sapin\n    :license: BSD, see LICENSE for details.\n\n\"\"\"\n\nimport ctypes.util\nimport sys\nfrom pathlib import Path\n\nfrom . import constants\nfrom ._generated.ffi import ffi\n\nVERSION = __version__ = (Path(__file__).parent / 'VERSION').read_text().strip()\n# supported version of cairo, used to be pycairo version too:\nversion = '1.16.0'\nversion_info = (1, 16, 0)\n\n\ndef dlopen(ffi, *names):\n    \"\"\"Try various names for the same library, for different platforms.\"\"\"\n    for name in names:\n        for lib_name in (name, 'lib' + name):\n            try:\n                path = ctypes.util.find_library(lib_name)\n                lib = ffi.dlopen(path or lib_name)\n                if lib:\n                    return lib\n            except OSError:\n                pass\n    raise OSError(\"dlopen() failed to load a library: %s\" % ' / '.join(names))\n\n\ncairo = dlopen(ffi, 'cairo', 'cairo-2', 'cairo-gobject-2', 'cairo.so.2')\n\n\nclass _keepref(object):\n    \"\"\"Function wrapper that keeps a reference to another object.\"\"\"\n    def __init__(self, ref, func):\n        self.ref = ref\n        self.func = func\n\n    def __call__(self, *args, **kwargs):\n        self.func(*args, **kwargs)\n\n\nclass CairoError(Exception):\n    \"\"\"Raised when cairo returns an error status.\"\"\"\n    def __init__(self, message, status):\n        super(CairoError, self).__init__(message)\n        self.status = status\n\n\nError = CairoError  # pycairo compat\n\nSTATUS_TO_EXCEPTION = {\n    constants.STATUS_NO_MEMORY: MemoryError,\n    constants.STATUS_READ_ERROR: IOError,\n    constants.STATUS_WRITE_ERROR: IOError,\n    constants.STATUS_TEMP_FILE_ERROR: IOError,\n    constants.STATUS_FILE_NOT_FOUND: FileNotFoundError,\n}\n\n\ndef _check_status(status):\n    \"\"\"Take a cairo status code and raise an exception if/as appropriate.\"\"\"\n    if status != constants.STATUS_SUCCESS:\n        exception = STATUS_TO_EXCEPTION.get(status, CairoError)\n        status_name = ffi.string(ffi.cast(\"cairo_status_t\", status))\n        message = 'cairo returned %s: %s' % (\n            status_name, ffi.string(cairo.cairo_status_to_string(status)))\n        raise exception(message, status)\n\n\ndef cairo_version():\n    \"\"\"Return the cairo version number as a single integer,\n    such as 11208 for ``1.12.8``.\n    Major, minor and micro versions are \"worth\" 10000, 100 and 1 respectively.\n\n    Can be useful as a guard for method not available in older cairo versions::\n\n        if cairo_version() >= 11000:\n            surface.set_mime_data('image/jpeg', jpeg_bytes)\n\n    \"\"\"\n    return cairo.cairo_version()\n\n\ndef cairo_version_string():\n    \"\"\"Return the cairo version number as a string, such as ``1.12.8``.\"\"\"\n    return ffi.string(cairo.cairo_version_string()).decode('ascii')\n\n\ndef install_as_pycairo():\n    \"\"\"Install cairocffi so that ``import cairo`` imports it.\n\n    cairoffi\u2019s API is compatible with pycairo as much as possible.\n\n    \"\"\"\n    sys.modules['cairo'] = sys.modules[__name__]\n\n\n# Implementation is in submodules, but public API is all here.\n\nfrom .surfaces import (Surface, ImageSurface, PDFSurface, PSSurface,  # noqa\n                       SVGSurface, RecordingSurface, Win32Surface,\n                       Win32PrintingSurface)\ntry:\n    from .xcb import XCBSurface  # noqa\nexcept ImportError:\n    pass\nfrom .patterns import (Pattern, SolidPattern, SurfacePattern,  # noqa\n                       Gradient, LinearGradient, RadialGradient)\nfrom .fonts import FontFace, ToyFontFace, ScaledFont, FontOptions  # noqa\nfrom .context import Context  # noqa\nfrom .matrix import Matrix  # noqa\n\nfrom .constants import *  # noqa\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cairocffi-1.0.2-hhziqiykk5ss6nwb4nzppy7smlmjcftm/spack-src/cairocffi/pixbuf.py": "\"\"\"\n    cairocffi.pixbuf\n    ~~~~~~~~~~~~~~~~\n\n    Loading various image formats with GDK-PixBuf\n\n    :copyright: Copyright 2013-2019 by Simon Sapin\n    :license: BSD, see LICENSE for details.\n\n\"\"\"\n\nimport sys\nfrom array import array\nfrom functools import partial\nfrom io import BytesIO\n\nfrom . import Context, ImageSurface, constants, dlopen\nfrom ._generated.ffi_pixbuf import ffi\n\n__all__ = ['decode_to_image_surface']\n\ngdk_pixbuf = dlopen(ffi, 'gdk_pixbuf-2.0', 'gdk_pixbuf-2.0-0')\ngobject = dlopen(ffi, 'gobject-2.0', 'gobject-2.0-0')\nglib = dlopen(ffi, 'glib-2.0', 'glib-2.0-0')\ntry:\n    gdk = dlopen(ffi, 'gdk-3', 'gdk-x11-2.0', 'gdk-win32-2.0-0')\nexcept OSError:\n    gdk = None\n\ngobject.g_type_init()\n\n\nclass ImageLoadingError(ValueError):\n    \"\"\"PixBuf returned an error when loading an image.\n\n    The image data is probably corrupted.\n\n    \"\"\"\n\n\ndef handle_g_error(error, return_value):\n    \"\"\"Convert a :c:type:`GError**` to a Python :exception:`ImageLoadingError`,\n    and raise it.\n\n    \"\"\"\n    error = error[0]\n    assert bool(return_value) == (error == ffi.NULL)\n    if error != ffi.NULL:\n        if error.message != ffi.NULL:\n            message = ('Pixbuf error: ' +\n                       ffi.string(error.message).decode('utf8', 'replace'))\n        else:  # pragma: no cover\n            message = 'Pixbuf error'\n        glib.g_error_free(error)\n        raise ImageLoadingError(message)\n\n\nclass Pixbuf(object):\n    \"\"\"Wrap a :c:type:`GdkPixbuf` pointer and simulate methods.\"\"\"\n    def __init__(self, pointer):\n        gobject.g_object_ref(pointer)\n        self._pointer = ffi.gc(pointer, gobject.g_object_unref)\n\n    def __getattr__(self, name):\n        function = getattr(gdk_pixbuf, 'gdk_pixbuf_' + name)\n        return partial(function, self._pointer)\n\n\ndef decode_to_pixbuf(image_data, width=None, height=None):\n    \"\"\"Decode an image from memory with GDK-PixBuf.\n    The file format is detected automatically.\n\n    :param image_data: A byte string\n    :param width: Integer width in pixels or None\n    :param height: Integer height in pixels or None\n    :returns:\n        A tuple of a new :class:`PixBuf` object\n        and the name of the detected image format.\n    :raises:\n        :exc:`ImageLoadingError` if the image data is invalid\n        or in an unsupported format.\n\n    \"\"\"\n    loader = ffi.gc(\n        gdk_pixbuf.gdk_pixbuf_loader_new(), gobject.g_object_unref)\n    error = ffi.new('GError **')\n    if width and height:\n        gdk_pixbuf.gdk_pixbuf_loader_set_size(loader, width, height)\n    handle_g_error(error, gdk_pixbuf.gdk_pixbuf_loader_write(\n        loader, ffi.new('guchar[]', image_data), len(image_data), error))\n    handle_g_error(error, gdk_pixbuf.gdk_pixbuf_loader_close(loader, error))\n\n    format_ = gdk_pixbuf.gdk_pixbuf_loader_get_format(loader)\n    format_name = (\n        ffi.string(gdk_pixbuf.gdk_pixbuf_format_get_name(format_))\n        .decode('ascii')\n        if format_ != ffi.NULL else None)\n\n    pixbuf = gdk_pixbuf.gdk_pixbuf_loader_get_pixbuf(loader)\n    if pixbuf == ffi.NULL:  # pragma: no cover\n        raise ImageLoadingError('Not enough image data (got a NULL pixbuf.)')\n    return Pixbuf(pixbuf), format_name\n\n\ndef decode_to_image_surface(image_data, width=None, height=None):\n    \"\"\"Decode an image from memory into a cairo surface.\n    The file format is detected automatically.\n\n    :param image_data: A byte string\n    :param width: Integer width in pixels or None\n    :param height: Integer height in pixels or None\n    :returns:\n        A tuple of a new :class:`~cairocffi.ImageSurface` object\n        and the name of the detected image format.\n    :raises:\n        :exc:`ImageLoadingError` if the image data is invalid\n        or in an unsupported format.\n\n    \"\"\"\n    pixbuf, format_name = decode_to_pixbuf(image_data, width, height)\n    surface = (\n        pixbuf_to_cairo_gdk(pixbuf) if gdk is not None\n        else pixbuf_to_cairo_slices(pixbuf) if not pixbuf.get_has_alpha()\n        else pixbuf_to_cairo_png(pixbuf))\n    return surface, format_name\n\n\ndef pixbuf_to_cairo_gdk(pixbuf):\n    \"\"\"Convert from PixBuf to ImageSurface, using GDK.\n\n    This method is fastest but GDK is not always available.\n\n    \"\"\"\n    dummy_context = Context(ImageSurface(constants.FORMAT_ARGB32, 1, 1))\n    gdk.gdk_cairo_set_source_pixbuf(\n        dummy_context._pointer, pixbuf._pointer, 0, 0)\n    return dummy_context.get_source().get_surface()\n\n\ndef pixbuf_to_cairo_slices(pixbuf):\n    \"\"\"Convert from PixBuf to ImageSurface, using slice-based byte swapping.\n\n    This method is 2~5x slower than GDK but does not support an alpha channel.\n    (cairo uses pre-multiplied alpha, but not Pixbuf.)\n\n    \"\"\"\n    assert pixbuf.get_colorspace() == gdk_pixbuf.GDK_COLORSPACE_RGB\n    assert pixbuf.get_n_channels() == 3\n    assert pixbuf.get_bits_per_sample() == 8\n    width = pixbuf.get_width()\n    height = pixbuf.get_height()\n    rowstride = pixbuf.get_rowstride()\n    pixels = ffi.buffer(pixbuf.get_pixels(), pixbuf.get_byte_length())\n    # TODO: remove this when cffi buffers support slicing with a stride.\n    pixels = pixels[:]\n\n    # Convert GdkPixbuf\u2019s big-endian RGBA to cairo\u2019s native-endian ARGB\n    cairo_stride = ImageSurface.format_stride_for_width(\n        constants.FORMAT_RGB24, width)\n    data = bytearray(cairo_stride * height)\n    big_endian = sys.byteorder == 'big'\n    pixbuf_row_length = width * 3  # stride == row_length + padding\n    cairo_row_length = width * 4  # stride == row_length + padding\n    alpha = b'\\xff' * width  # opaque\n    for y in range(height):\n        offset = rowstride * y\n        end = offset + pixbuf_row_length\n        red = pixels[offset:end:3]\n        green = pixels[offset + 1:end:3]\n        blue = pixels[offset + 2:end:3]\n\n        offset = cairo_stride * y\n        end = offset + cairo_row_length\n        if big_endian:  # pragma: no cover\n            data[offset:end:4] = alpha\n            data[offset + 1:end:4] = red\n            data[offset + 2:end:4] = green\n            data[offset + 3:end:4] = blue\n        else:\n            data[offset + 3:end:4] = alpha\n            data[offset + 2:end:4] = red\n            data[offset + 1:end:4] = green\n            data[offset:end:4] = blue\n\n    data = array('B', data)\n    return ImageSurface(constants.FORMAT_RGB24,\n                        width, height, data, cairo_stride)\n\n\ndef pixbuf_to_cairo_png(pixbuf):\n    \"\"\"Convert from PixBuf to ImageSurface, by going through the PNG format.\n\n    This method is 10~30x slower than GDK but always works.\n\n    \"\"\"\n    buffer_pointer = ffi.new('gchar **')\n    buffer_size = ffi.new('gsize *')\n    error = ffi.new('GError **')\n    handle_g_error(error, pixbuf.save_to_buffer(\n        buffer_pointer, buffer_size, ffi.new('char[]', b'png'), error,\n        ffi.new('char[]', b'compression'), ffi.new('char[]', b'0'),\n        ffi.NULL))\n    png_bytes = ffi.buffer(buffer_pointer[0], buffer_size[0])\n    return ImageSurface.create_from_png(BytesIO(png_bytes))\n"
    },
    "skipped": [],
    "total_files": 20
}