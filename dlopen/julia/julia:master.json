{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/HISTORY.md": "Julia v1.6 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Types written with `where` syntax can now be used to define constructors, e.g.\n  `(Foo{T} where T)(x) = ...`.\n* `<--` and `<-->` are now available as infix operators, with the same precedence\n  and associativity as other arrow-like operators ([#36666]).\n* Compilation and type inference can now be enabled or disabled at the module level\n  using the experimental macro `Base.Experimental.@compiler_options` ([#37041]).\n* The library name passed to `ccall` or `@ccall` can now be an expression involving\n  global variables and function calls. The expression will be evaluated the first\n  time the `ccall` executes ([#36458]).\n* `\ua71b` (U+A71B), `\ua71c` (U+A71C) and `\ua71d` (U+A71D) can now also be used as operator\n  suffixes. They can be tab-completed from `\\^uparrow`, `\\^downarrow` and `\\^!` in the REPL\n  ([#37542]).\n* Standalone \"dotted\" operators now get parsed as `Expr(:., :op)`, which gets lowered to\n  `Base.BroadcastFunction(op)`. This means `.op` is functionally equivalent to\n  `(x...) -> (op).(x...)`, which can be useful for passing the broadcasted version of an\n  operator to higher-order functions, for example `map(.*, A, B)` for an elementwise\n  product of two arrays of arrays ([#37583]).\n* The syntax `import A as B` (plus `import A: x as y`, `import A.x as y`, and `using A: x as y`)\n  can now be used to rename imported modules and identifiers ([#1255]).\n* Unsigned literals (starting with `0x`) which are too big to fit in a `UInt128` object\n  are now interpreted as `BigInt` ([#23546]).\n* It is now possible to use `...` on the left-hand side of assignments for taking any\n  number of items from the front of an iterable collection, while also collecting the rest,\n  for example `a, b... = [1, 2, 3]`. This syntax is implemented using `Base.rest`,\n  which can be overloaded to customize its behavior for different collection types\n  ([#37410]).\n\nLanguage changes\n----------------\n\n* The postfix conjugate transpose operator `'` now accepts Unicode modifiers as\n  suffixes, so e.g. `a'\u1d40` is parsed as `var\"'\u1d40\"(a)`, which can be defined by the\n  user. `a'\u1d40` parsed as `a' * \u1d40` before, so this is a minor breaking change ([#37247]).\n* Macros that return `:quote` expressions (e.g. via `Expr(:quote, ...)`) were previously\n  able to work without escaping (`esc(...)`) their output when needed. This has been\n  corrected, and now `esc` must be used in these macros as it is in other macros ([#37540]).\n* The `-->` operator now lowers to a `:call` expression, so it can be defined as\n  a function like other operators. The dotted version `.-->` is now parsed as well.\n  For backwards compatibility, `-->` still parses using its own expression head\n  instead of `:call`.\n* The `a[begin, k]` syntax now calls `firstindex(a, 1)` rather than `first(axes(a, 1))` ([#35779]),\n  but the former now defaults to the latter for any `a` ([#38742]).\n* `\u233f` (U+233F) and `\u00a6` (U+00A6) are now infix operators with times-like and plus-like precedence,\n  respectively. Previously they were parsed as identifier characters ([#37973]).\n\nCompiler/Runtime improvements\n-----------------------------\n\n* All platforms can now use `@executable_path` within `jl_load_dynamic_library()`.\n  This allows executable-relative paths to be embedded within executables on all\n  platforms, not just MacOS, which the syntax is borrowed from ([#35627]).\n* Constant propagation now occurs through keyword arguments ([#35976]).\n* The precompilation cache is now created atomically ([#36416]). Invoking _n_\n  Julia processes simultaneously may create _n_ temporary caches.\n\nCommand-line option changes\n---------------------------\n\n* There is no longer a concept of \"home project\": starting `julia --project=dir`\n  is now exactly equivalent to starting `julia` and then doing `pkg> activate\n  $dir` and `julia --project` is exactly equivalent to doing that where\n  `dir = Base.current_project()`. In particular, this means that if you do\n  `pkg> activate` after starting `julia` with the `--project` option (or with\n  `JULIA_PROJECT` set) it will take you to the default active project, which is\n  `@v1.6` unless you have modified `LOAD_PATH` ([#36434]).\n\nMulti-threading changes\n-----------------------\n\n* Locks now automatically inhibit finalizers from running, to avoid deadlock ([#38487]).\n* New function `Base.Threads.foreach(f, channel::Channel)` for multithreaded `Channel` consumption ([#34543]).\n\nBuild system changes\n--------------------\n\n* Windows Installer now has the option to 'Add Julia to Path'. To unselect this option\n  from the commandline simply remove the tasks you do not want to be installed: e.g.\n  `./julia-installer.exe /TASKS=\"desktopicon,startmenu,addtopath\"`, adds a desktop\n  icon, a startmenu group icon, and adds Julia to system PATH.\n\nNew library functions\n---------------------\n\n* New function `Base.kron!` and corresponding overloads for various matrix types for performing Kronecker\n  product in-place ([#31069]).\n* New function `Base.readeach(io, T)` for iteratively performing `read(io, T)` ([#36150]).\n* `Iterators.map` is added. It provides another syntax `Iterators.map(f, iterators...)`\n  for writing `(f(args...) for args in zip(iterators...))`, i.e. a lazy `map` ([#34352]).\n* New function `sincospi` for simultaneously computing `sinpi(x)` and `cospi(x)` more\n  efficiently ([#35816]).\n* New function `cispi(x)` for more accurately computing `cis(pi * x)` ([#38449]).\n* New function `addenv` for adding environment mappings into a `Cmd` object, returning the new `Cmd` object.\n* New function `insorted` for determining whether an element is in a sorted collection or not ([#37490]).\n* New function `Base.rest` for taking the rest of a collection, starting from a specific\n  iteration state, in a generic way ([#37410]).\n\nNew library features\n--------------------\n\n* The `redirect_*` functions now accept `devnull` to discard all output redirected to it, and as an empty\n  input ([#36146]).\n* The `redirect_*` functions can now be called on `IOContext` objects ([#36688]).\n* `findfirst`, `findnext`, `findlast`, and `findall` now support `AbstractVector{<:Union{Int8,UInt8}}`\n  (pattern, array) arguments ([#37283]).\n* New constructor `NamedTuple(iterator)` that constructs a named tuple from a key-value pair iterator.\n* A new `reinterpret(reshape, T, a::AbstractArray{S})` reinterprets `a` to have eltype `T` while potentially\n  inserting or consuming the first dimension depending on the ratio of `sizeof(T)` and `sizeof(S)`.\n* New `append!(vector, collections...)` and `prepend!(vector, collections...)` methods accept multiple\n  collections to be appended or prepended ([#36227]).\n* The postfix operator `'\u1d40` can now be used as an alias for `transpose` ([#38062]).\n* `keys(io::IO)` has been added, which returns all keys of `io` if `io` is an `IOContext` and an empty\n  `Base.KeySet` otherwise ([#37753]).\n* `count` now accepts an optional `init` argument to control the accumulation type ([#37461]).\n* New method `occursin(haystack)` that returns a function that checks whether its argument occurs in\n  `haystack` ([#38475]).\n* New methods `\u2209(collection)`, `\u220b(item)`, and `\u220c(item)` returning corresponding containment-testing\n  functions ([#38475]).\n* The `nextprod` function now accepts tuples and other array types for its first argument ([#35791]).\n* The `reverse(A; dims)` function for multidimensional `A` can now reverse multiple dimensions at once\n  by passing a tuple for `dims`, and defaults to reversing all dimensions; there is also a multidimensional\n  in-place `reverse!(A; dims)` ([#37367]).\n* The function `isapprox(x,y)` now accepts the `norm` keyword argument also for numeric (i.e., non-array)\n  arguments `x` and `y` ([#35883]).\n* `ispow2(x)` now supports non-`Integer` arguments `x` ([#37635]).\n* `view`, `@view`, and `@views` now work on `AbstractString`s, returning a `SubString` when appropriate ([#35879]).\n* All `AbstractUnitRange{<:Integer}`s now work with `SubString`, `view`, `@view` and `@views` on strings ([#35879]).\n* `sum`, `prod`, `maximum`, and `minimum` now support `init` keyword argument ([#36188], [#35839]).\n* `unique(f, itr; seen=Set{T}())` now allows you to declare the container type used for\n  keeping track of values returned by `f` on elements of `itr` ([#36280]).\n* `first` and `last` functions now accept an integer as second argument to get that many\n  leading or trailing elements of any iterable ([#34868]).\n* `CartesianIndices` now supports step different from `1`. It can also be constructed from three\n  `CartesianIndex`es `I`, `S`, `J` using `I:S:J`. `step` for `CartesianIndices` now returns a\n  `CartesianIndex` ([#37829]).\n* `RegexMatch` objects can now be probed for whether a named capture group exists within it through `haskey()` ([#36717]).\n* For consistency `haskey(r::RegexMatch, i::Integer)` has also been added and returns if the capture group\n  for `i` exists ([#37300]).\n\nStandard library changes\n------------------------\n\n* A new standard library `TOML` has been added for parsing and printing [TOML files](https://toml.io) ([#37034]).\n* A new standard library `Downloads` has been added, which replaces the old `Base.download` function with\n  `Downloads.download`, providing cross-platform, multi-protocol, in-process download functionality implemented\n  with [libcurl](https://curl.haxx.se/libcurl/) ([#37340]).\n* `Libdl` has been moved to `Base.Libc.Libdl`, however it is still accessible as an stdlib ([#35628]).\n* To download artifacts lazily, `LazyArtifacts` now must be explicitly listed as a dependency, to avoid needing the\n  support machinery to be available when it is not commonly needed ([#37844]).\n* It is no longer possible to create a `LinRange`, `StepRange`, or `StepRangeLen` with a `<: Integer` eltype but\n  non-integer step ([#32439]).\n* `intersect` on `CartesianIndices` now returns `CartesianIndices` instead of `Vector{<:CartesianIndex}` ([#36643]).\n* `push!(c::Channel, v)` now returns channel `c`. Previously, it returned the pushed value `v` ([#34202]).\n* The composition operator `\u2218` now returns a `Base.ComposedFunction` instead of an anonymous function ([#37517]).\n* Logging (such as `@warn`) no longer catches exceptions in the logger itself ([#36600]).\n* `@time` now reports if the time presented included any compilation time, which is shown as a percentage ([#37678]).\n* `@varinfo` can now report non-exported objects within modules, look recursively into submodules, and return a sorted\n  results table ([#38042]).\n* `@testset` now supports the option `verbose` to show the test result summary\n  of the children even if they all pass ([#33755]).\n\n#### Package Manager\n\n* `pkg> precompile` is now parallelized through depth-first precompilation of dependencies. Errors will only throw for\n  direct dependencies listed in the `Project.toml`.\n* `pkg> precompile` is now automatically triggered whenever Pkg changes the active manifest. Auto-precompilation will\n  remember if a package has errored within the given environment and will not retry until it changes.\n  Auto-precompilation can be gracefully interrupted with a `ctrl-c` and disabled by setting the environment variable\n  `JULIA_PKG_PRECOMPILE_AUTO=0`.\n* The `Pkg.BinaryPlatforms` module has been moved into `Base` as `Base.BinaryPlatforms` and heavily reworked.\n  Applications that want to be compatible with the old API should continue to import `Pkg.BinaryPlatforms`,\n  however new users should use `Base.BinaryPlatforms` directly ([#37320]).\n* The `Pkg.Artifacts` module has been imported as a separate standard library.  It is still available as\n  `Pkg.Artifacts`, however starting from Julia v1.6+, packages may import simply `Artifacts` without importing\n  all of `Pkg` alongside ([#37320]).\n\n#### LinearAlgebra\n\n* New method `LinearAlgebra.issuccess(::CholeskyPivoted)` for checking whether pivoted Cholesky factorization was\n  successful ([#36002]).\n* `UniformScaling` can now be indexed into using ranges to return dense matrices and vectors ([#24359]).\n* New function `LinearAlgebra.BLAS.get_num_threads()` for getting the number of BLAS threads ([#36360]).\n* `(+)(::UniformScaling)` is now defined, making `+I` a valid unary operation ([#36784]).\n* Instances of `UniformScaling` are no longer `isequal` to matrices. Previous\n  behaviour violated the rule that `isequal(x, y)` implies `hash(x) == hash(y)`.\n* Transposing `*Triangular` matrices now returns matrices of the opposite triangular type, consistently\n  with `adjoint!(::*Triangular)` and `transpose!(::*Triangular)`. Packages containing methods with, e.g.,\n  `Adjoint{<:Any,<:LowerTriangular{<:Any,<:OwnMatrixType}}` should replace that by\n  `UpperTriangular{<:Any,<:Adjoint{<:Any,<:OwnMatrixType}}` in the method signature ([#38168]).\n\n#### Markdown\n\n\n#### Printf\n\n* Complete overhaul of internal code to use the ryu float printing algorithms (from Julia 1.4); leads to\n  consistent 2-5x performance improvements.\n* New `Printf.tofloat` function allowing custom float types to more easily integrate with Printf formatting\n  by converting their type to `Float16`, `Float32`, `Float64`, or `BigFloat`.\n* New `Printf.format\"...\"` and `Printf.Format(...)` functions that allow creating `Printf.Format` objects\n  that can be passed to `Printf.format` for easier dynamic printf formatting.\n* `Printf.format(f::Printf.Format, args...)` as a non-macro function that applies a printf format `f` to\n  provided `args`.\n\n#### Random\n\n\n#### REPL\n\n* The `AbstractMenu` extension interface of `REPL.TerminalMenus` has been extensively\n  overhauled. The new interface does not rely on global configuration variables, is more\n  consistent in delegating printing of the navigation/selection markers, and provides\n  improved support for dynamic menus.  These changes are compatible with the previous\n  (deprecated) interface, so are non-breaking.\n\n  The new API offers several enhancements:\n\n  + Menus are configured in their constructors via keyword arguments.\n  + For custom menu types, the new `Config` and `MultiSelectConfig` replace the global `CONFIG` `Dict`.\n  + `request(menu; cursor=1)` allows you to control the initial cursor position in the menu (defaults to first item).\n  + `MultiSelectMenu` allows you to pass a list of initially-selected items with the `selected` keyword argument.\n  + `writeLine` was deprecated to `writeline`, and `writeline` methods are not expected to print the cursor indicator.\n    The old `writeLine` continues to work, and any of its method extensions should print the cursor indicator as before.\n  + `printMenu` has been deprecated to `printmenu`, and it both accepts a state input and returns a state output\n    that controls the number of terminal lines erased when the menu is next refreshed. This plus related changes\n    makes `printmenu` work properly when the number of menu items might change depending on user choices.\n  + `numoptions`, returning the number of items in the menu, has been added as an alternative to implementing `options`.\n  + `suppress_output` (primarily a testing option) has been added as a keyword argument to `request`,\n    rather than a configuration option.\n* Tab completion now supports runs of consecutive sub/superscript characters,\n  e.g. `\\^(3)` tab-completes to `\u207d\u00b3\u207e` ([#38649]).\n* Windows REPL now supports 24-bit colors, by correctly interpreting virtual terminal escapes.\n\n#### SparseArrays\n\n* Display large sparse matrices with a Unicode \"spy\" plot of their nonzero patterns,\n  and display small sparse matrices by an `Matrix`-like 2d layout of their contents ([#33821]).\n* New convenient `spdiagm([m, n,] v::AbstractVector)` methods which call\n  `spdiagm([m, n,] 0 => v)`, consistently with their dense `diagm` counterparts ([#37684]).\n\n#### Dates\n\n* `Quarter` period is defined ([#35519]).\n* `canonicalize` can now take `Period` as an input ([#37391]).\n* Zero-valued `FixedPeriod`s and `OtherPeriod`s now compare equal, e.g.,\n  `Year(0) == Day(0)`. The behavior of non-zero `Period`s is not changed ([#37486]).\n\n#### Statistics\n\n\n#### Sockets\n\n\n#### Distributed\n\n* Now supports invoking Windows workers via ssh (via new keyword argument `shell=:wincmd` in `addprocs`) ([#30614]).\n* Other new keyword arguments in `addprocs`: `ssh` to specify the ssh client path, `env` to pass environment\n  variables to workers, and `cmdline_cookie` to work around an ssh problem with Windows workers that run older\n  (pre-ConPTY) versions of Windows, Julia or OpenSSH ([#30614]).\n\n#### UUIDs\n\n* Change `uuid1` and `uuid4` to use `Random.RandomDevice()` as default random number generator ([#35872]).\n* Added `parse(::Type{UUID}, ::AbstractString)` method.\n\n#### Mmap\n\n* On Unix systems, the `Mmap.madvise!` function (along with OS-specific `Mmap.MADV_*`\n  constants) has been added to give advice on handling of memory-mapped arrays ([#37369]).\n\nDeprecated or removed\n---------------------\n\n* The `Base.download` function has been deprecated (silently, by default) in favor of the new `Downloads.download`\n  standard library function ([#37340]).\n* The `Base.Grisu` code has been officially removed (float printing was switched to the ryu algorithm code in 1.4).\n  The code is available from [JuliaAttic](https://github.com/JuliaAttic/Grisu.jl) if needed.\n\nExternal dependencies\n---------------------\n\n\nTooling Improvements\n---------------------\n\n\n<!--- generated by NEWS-update.jl: -->\n[#1255]: https://github.com/JuliaLang/julia/issues/1255\n[#23546]: https://github.com/JuliaLang/julia/issues/23546\n[#24359]: https://github.com/JuliaLang/julia/issues/24359\n[#30614]: https://github.com/JuliaLang/julia/issues/30614\n[#31069]: https://github.com/JuliaLang/julia/issues/31069\n[#32439]: https://github.com/JuliaLang/julia/issues/32439\n[#33755]: https://github.com/JuliaLang/julia/issues/33755\n[#33821]: https://github.com/JuliaLang/julia/issues/33821\n[#34202]: https://github.com/JuliaLang/julia/issues/34202\n[#34352]: https://github.com/JuliaLang/julia/issues/34352\n[#34543]: https://github.com/JuliaLang/julia/issues/34543\n[#34868]: https://github.com/JuliaLang/julia/issues/34868\n[#35519]: https://github.com/JuliaLang/julia/issues/35519\n[#35627]: https://github.com/JuliaLang/julia/issues/35627\n[#35628]: https://github.com/JuliaLang/julia/issues/35628\n[#35779]: https://github.com/JuliaLang/julia/issues/35779\n[#35791]: https://github.com/JuliaLang/julia/issues/35791\n[#35816]: https://github.com/JuliaLang/julia/issues/35816\n[#35839]: https://github.com/JuliaLang/julia/issues/35839\n[#35872]: https://github.com/JuliaLang/julia/issues/35872\n[#35879]: https://github.com/JuliaLang/julia/issues/35879\n[#35883]: https://github.com/JuliaLang/julia/issues/35883\n[#35976]: https://github.com/JuliaLang/julia/issues/35976\n[#36002]: https://github.com/JuliaLang/julia/issues/36002\n[#36146]: https://github.com/JuliaLang/julia/issues/36146\n[#36150]: https://github.com/JuliaLang/julia/issues/36150\n[#36188]: https://github.com/JuliaLang/julia/issues/36188\n[#36227]: https://github.com/JuliaLang/julia/issues/36227\n[#36280]: https://github.com/JuliaLang/julia/issues/36280\n[#36360]: https://github.com/JuliaLang/julia/issues/36360\n[#36416]: https://github.com/JuliaLang/julia/issues/36416\n[#36434]: https://github.com/JuliaLang/julia/issues/36434\n[#36458]: https://github.com/JuliaLang/julia/issues/36458\n[#36600]: https://github.com/JuliaLang/julia/issues/36600\n[#36643]: https://github.com/JuliaLang/julia/issues/36643\n[#36666]: https://github.com/JuliaLang/julia/issues/36666\n[#36688]: https://github.com/JuliaLang/julia/issues/36688\n[#36717]: https://github.com/JuliaLang/julia/issues/36717\n[#36784]: https://github.com/JuliaLang/julia/issues/36784\n[#37034]: https://github.com/JuliaLang/julia/issues/37034\n[#37041]: https://github.com/JuliaLang/julia/issues/37041\n[#37247]: https://github.com/JuliaLang/julia/issues/37247\n[#37283]: https://github.com/JuliaLang/julia/issues/37283\n[#37300]: https://github.com/JuliaLang/julia/issues/37300\n[#37320]: https://github.com/JuliaLang/julia/issues/37320\n[#37340]: https://github.com/JuliaLang/julia/issues/37340\n[#37367]: https://github.com/JuliaLang/julia/issues/37367\n[#37369]: https://github.com/JuliaLang/julia/issues/37369\n[#37391]: https://github.com/JuliaLang/julia/issues/37391\n[#37410]: https://github.com/JuliaLang/julia/issues/37410\n[#37461]: https://github.com/JuliaLang/julia/issues/37461\n[#37486]: https://github.com/JuliaLang/julia/issues/37486\n[#37490]: https://github.com/JuliaLang/julia/issues/37490\n[#37517]: https://github.com/JuliaLang/julia/issues/37517\n[#37540]: https://github.com/JuliaLang/julia/issues/37540\n[#37542]: https://github.com/JuliaLang/julia/issues/37542\n[#37583]: https://github.com/JuliaLang/julia/issues/37583\n[#37635]: https://github.com/JuliaLang/julia/issues/37635\n[#37678]: https://github.com/JuliaLang/julia/issues/37678\n[#37684]: https://github.com/JuliaLang/julia/issues/37684\n[#37753]: https://github.com/JuliaLang/julia/issues/37753\n[#37829]: https://github.com/JuliaLang/julia/issues/37829\n[#37844]: https://github.com/JuliaLang/julia/issues/37844\n[#37973]: https://github.com/JuliaLang/julia/issues/37973\n[#38042]: https://github.com/JuliaLang/julia/issues/38042\n[#38062]: https://github.com/JuliaLang/julia/issues/38062\n[#38168]: https://github.com/JuliaLang/julia/issues/38168\n[#38449]: https://github.com/JuliaLang/julia/issues/38449\n[#38475]: https://github.com/JuliaLang/julia/issues/38475\n[#38487]: https://github.com/JuliaLang/julia/issues/38487\n[#38649]: https://github.com/JuliaLang/julia/issues/38649\n[#38742]: https://github.com/JuliaLang/julia/issues/38742\n\n\nJulia v1.5 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Macro calls `@foo {...}` can now also be written `@foo{...}` (without the space) ([#34498]).\n* `\u2a1f` is now parsed as a binary operator with times precedence. It can be entered in the REPL\n  with `\\bbsemi` followed by <kbd>TAB</kbd> ([#34722]).\n* `\u00b1` and `\u2213` are now unary operators as well, like `+` or `-`. Attention has to be paid in\n  macros and matrix constructors, which are whitespace sensitive, because expressions like\n  `[a \u00b1b]` now get parsed as `[a \u00b1(b)]` instead of `[\u00b1(a, b)]` ([#34200]).\n* Passing an identifier `x` by itself as a keyword argument or named tuple element\n  is equivalent to `x=x`, implicitly using the name of the variable as the keyword\n  or named tuple field name.\n  Similarly, passing an `a.b` expression uses `b` as the keyword or field name ([#29333]).\n* Support for Unicode 13.0.0 (via utf8proc 2.5) ([#35282]).\n* The compiler optimization level can now be set per-module using the experimental macro\n  `Base.Experimental.@optlevel n`. For code that is not performance-critical, setting\n  this to 0 or 1 can provide significant latency improvements ([#34896]).\n\nLanguage changes\n----------------\n\n* The interactive REPL now uses \"soft scope\" for top-level expressions: an assignment inside a\n  scope block such as a `for` loop automatically assigns to a global variable if one has been\n  defined already. This matches the behavior of Julia versions 0.6 and prior, as well as\n  [IJulia](https://github.com/JuliaLang/IJulia.jl).\n  Note that this only affects expressions interactively typed or pasted directly into the\n  default REPL ([#28789], [#33864]).\n* Outside of the REPL (e.g. in a file), assigning to a variable within a top-level scope\n  block is considered ambiguous if a global variable with the same name exists.\n  A warning is given if that happens, to alert you that the code will work differently\n  than in the REPL.\n  A new command line option `--warn-scope` controls this warning ([#33864]).\n* Converting arbitrary tuples to `NTuple`, e.g. `convert(NTuple, (1, \"\"))` now gives an error,\n  where it used to be incorrectly allowed. This is because `NTuple` refers only to homogeneous\n  tuples (this meaning has not changed) ([#34272]).\n* The syntax `(;)` (which was deprecated in v1.4) now creates an empty named tuple ([#30115]).\n* `@inline` macro can now be applied to short-form anonymous functions ([#34953]).\n* In triple-quoted string literals, whitespace stripping is now done before processing\n  escape sequences instead of after. For example, the syntax\n  ```\n  \"\"\"\n    a\\n b\"\"\"\n  ```\n  used to yield the string \" a\\nb\", since the single space before `b` set the indent level.\n  Now the result is \"a\\n b\", since the space before `b` is no longer considered to occur\n  at the start of a line. The old behavior is considered a bug ([#35001]).\n* `<:` and `>:` can now be broadcasted over arrays with `.<:` and `.>:`  ([#35085])\n* The line number of function definitions is now added by the parser as an\n  additional `LineNumberNode` at the start of each function body ([#35138]).\n* Statements of the form `a'` now get lowered to `var\"'\"(a)` instead of `Base.adjoint(a)`. This\n  allows for shadowing this function in local scopes, although this is generally discouraged.\n  By default, Base exports `var\"'\"` as an alias of `Base.adjoint`, so custom types should still\n  extend `Base.adjoint` ([#34634]).\n\nCompiler/Runtime improvements\n-----------------------------\n\n* Immutable structs (including tuples) that contain references can now be allocated\n  on the stack, and allocated inline within arrays and other structs ([#33886]).\n  This significantly reduces the number of heap allocations in some workloads.\n  Code that requires assumptions about object layout and addresses (usually for\n  interoperability with C or other languages) might need to be updated; for\n  example any object that needs a stable address should be a `mutable struct`.\n  As a result, Array `view`s no longer allocate ([#34126]).\n\nCommand-line option changes\n---------------------------\n\n* Deprecation warnings are no longer shown by default. i.e. if the `--depwarn=...` flag is\n  not passed it defaults to `--depwarn=no`. The warnings are printed from tests run by\n  `Pkg.test()` ([#35362]).\n* Color now defaults to on when stdout and stderr are TTYs ([#34347]).\n* `-t N`, `--threads N` starts Julia with `N` threads. This option takes precedence over\n  `JULIA_NUM_THREADS`. The specified number of threads also propagates to worker\n  processes spawned using the `-p`/`--procs` or `--machine-file` command line arguments.\n  In order to set number of threads for worker processes spawned with `addprocs` use the\n  `exeflags` keyword argument, e.g. ```addprocs(...; exeflags=`--threads 4`)``` ([#35108]).\n\nMulti-threading changes\n-----------------------\n\n* Parts of the multi-threading API are now considered stable, with caveats.\n  This includes all documented identifiers from `Base.Threads` except the\n  `atomic_` operations.\n* `@threads` now allows an optional schedule argument. Use `@threads :static ...` to\n  ensure that the same schedule will be used as in past versions; the default schedule\n  is likely to change in the future.\n\nBuild system changes\n--------------------\n\n* The build system now contains a pure-make caching system for expanding expensive operations at the latest\n  possible moment, while still expanding it only once ([#35626]).\n\nNew library functions\n---------------------\n\n* Packages can now provide custom hints to help users resolve errors by using the\n  experimental `Base.Experimental.register_error_hint` function.\n  Packages that define custom exception types can support hints by calling the\n  `Base.Experimental.show_error_hints` from their `showerror` method ([#35094]).\n* The `@ccall` macro has been added to Base. It is a near drop-in replacement for `ccall` with more Julia-like syntax. It also wraps the new `foreigncall` API for varargs of different types, though it lacks the capability to specify an LLVM calling convention ([#32748]).\n* New functions `mergewith` and `mergewith!` supersede `merge` and `merge!` with `combine`\n  argument.  They don't have the restriction for `combine` to be a `Function` and also\n  provide one-argument method that returns a closure.  The old methods of `merge` and\n  `merge!` are still available for backward compatibility ([#34296]).\n* The new `isdisjoint` function indicates whether two collections are disjoint ([#34427]).\n* Add function `ismutable` and deprecate `isimmutable` to check whether something is mutable ([#34652]).\n* `include` now accepts an optional `mapexpr` first argument to transform the parsed\n  expressions before they are evaluated ([#34595]).\n* New function `bitreverse` for reversing the order of bits in a fixed-width integer ([#34791]).\n* New function `bitrotate(x, k)` for rotating the bits in a fixed-width integer ([#33937]).\n* New function `contains(haystack, needle)` and its one argument partially applied form have been added, it acts like `occursin(needle, haystack)` ([#35132]).\n* New function `Base.exit_on_sigint` is added to control if `InterruptException` is\n  thrown by Ctrl-C ([#29411]).\n\nNew library features\n--------------------\n\n* Function composition now works also on one argument `\u2218(f) = f` (#34251).\n* One argument methods `startswith(x)` and `endswith(x)` have been added, returning partially-applied versions of the functions, similar to existing methods like `isequal(x)` ([#33193]).\n* `isapprox` (or `\u2248`) now has a one-argument \"curried\" method `isapprox(x)` which returns a function, like `isequal` (or `==`) ([#32305]).\n* `@NamedTuple{key1::Type1, ...}` macro for convenient `NamedTuple` declarations ([#34548]).\n* `Ref{NTuple{N,T}}` can be passed to `Ptr{T}`/`Ref{T}` `ccall` signatures ([#34199]).\n* `x::Signed % Unsigned` and `x::Unsigned % Signed` are supported for integer bitstypes.\n* `signed(unsigned_type)` is supported for integer bitstypes, `unsigned(signed_type)` has been supported.\n* `accumulate`, `cumsum`, and `cumprod` now support `Tuple` ([#34654]) and arbitrary iterators ([#34656]).\n* `pop!(collection, key, [default])` now has a method for `Vector` to remove an element at an arbitrary index ([#35513]).\n* In `splice!` with no replacement, values to be removed can now be specified with an\n  arbitrary iterable (instead of a `UnitRange`) ([#34524]).\n* The `@view` and `@views` macros now support the `a[begin]` syntax that was introduced in Julia 1.4 ([#35289]).\n* `open` for files now accepts a keyword argument `lock` controlling whether file operations\n  will acquire locks for safe multi-threaded access. Setting it to `false` provides better\n  performance when only one thread will access the file ([#35426]).\n* The introspection macros (`@which`, `@code_typed`, etc.) now work with `do`-block syntax ([#35283]) and with dot syntax ([#35522]).\n* `count` now accepts the `dims` keyword.\n* new in-place `count!` function similar to `sum!`.\n* `peek` is now exported and accepts a type to peek from a stream ([#28811]).\n\nStandard library changes\n------------------------\n\n* Empty ranges now compare equal, regardless of their startpoint and step ([#32348]).\n* A 1-d `Zip` iterator (where `Base.IteratorSize` is `Base.HasShape{1}()`) with defined length of `n` has now also size of `(n,)` (instead of throwing an error with truncated iterators) ([#29927]).\n* The `@timed` macro now returns a `NamedTuple` ([#34149]).\n* New `supertypes(T)` function returns a tuple of all supertypes of `T` ([#34419]).\n* Views of builtin ranges are now recomputed ranges (like indexing returns) instead of\n  `SubArray`s ([#26872]).\n* Sorting-related functions such as `sort` that take the keyword arguments `lt`, `rev`, `order`\n  and `by` now do not discard `order` if `by` or `lt` are passed. In the former case, the\n  order from `order` is used to compare the values of `by(element)`. In the latter case,\n  any order different from `Forward` or `Reverse` will raise an error about the\n  ambiguity.\n* `close` on a file (`IOStream`) can now throw an exception if an error occurs when trying\n  to flush buffered data to disk ([#35303]).\n* The large `StridedArray` `Union` now has special printing to avoid printing out its entire\n  contents ([#31149]).\n\n#### LinearAlgebra\n\n* The BLAS submodule now supports the level-2 BLAS subroutine `hpmv!` ([#34211]).\n* `normalize` now supports multidimensional arrays ([#34239]).\n* `lq` factorizations can now be used to compute the minimum-norm solution to under-determined systems ([#34350]).\n* `sqrt(::Hermitian)` now treats slightly negative eigenvalues as zero for nearly semidefinite matrices, and accepts a new `rtol` keyword argument for this tolerance ([#35057]).\n* The BLAS submodule now supports the level-2 BLAS subroutine `spmv!` ([#34320]).\n* The BLAS submodule now supports the level-1 BLAS subroutine `rot!` ([#35124]).\n* New generic `rotate!(x, y, c, s)` and `reflect!(x, y, c, s)` functions ([#35124]).\n\n#### Markdown\n\n* In docstrings, a level-1 markdown header \"Extended help\" is now interpreted as a marker\n  dividing \"brief help\" from \"extended help\". The REPL help mode only shows the brief help\n  (the content before the \"Extended help\" header) by default; prepend the expression with '?'\n  (in addition to the one that enters the help mode) to see the full docstring ([#25930]).\n\n#### Random\n\n* `randn!(::MersenneTwister, ::Array{Float64})` is faster, and as a result, for a given state of the RNG,\n  the corresponding generated numbers have changed ([#35078]).\n* `rand!(::MersenneTwister, ::Array{Bool})` is faster, and as a result, for a given state of the RNG,\n  the corresponding generated numbers have changed ([#33721]).\n* A new faster algorithm (\"nearly division less\") is used for generating random numbers\n  within a range ([#29240]). As a result, the streams of generated numbers are changed\n  (for ranges, like in `rand(1:9)`, and for collections in general, like in `rand([1, 2, 3])`).\n  Also, for performance, the undocumented property that, given a seed and `a, b` of type `Int`,\n  `rand(a:b)` produces the same stream on 32 and 64 bits architectures, is dropped.\n\n#### REPL\n\n\n#### SparseArrays\n\n* `lu!` accepts `UmfpackLU` as an argument to make use of its symbolic factorization.\n* The `trim` keyword argument for the functions `fkeep!`, `tril!`, `triu!`,\n  `droptol!`,`dropzeros!` and `dropzeros` has been removed in favour of always\n  trimming. Calling these with `trim=false` could result in invalid sparse\n  arrays.\n\n#### Dates\n\n* The `eps` function now accepts `TimeType` types ([#31487]).\n* The `zero` function now accepts `TimeType` types ([#35554]).\n\n#### Statistics\n\n\n#### Sockets\n\n* Joining and leaving UDP multicast groups on a `UDPSocket` is now supported\n  through `join_multicast_group()` and `leave_multicast_group()` ([#35521]).\n\n#### Distributed\n\n* `launch_on_machine` now supports and parses ipv6 square-bracket notation ([#34430]).\n\nDeprecated or removed\n---------------------\n\nExternal dependencies\n---------------------\n\n* OpenBLAS has been updated to v0.3.9 ([#35113]).\n\nTooling Improvements\n---------------------\n\n\n<!--- generated by NEWS-update.jl: -->\n[#25930]: https://github.com/JuliaLang/julia/issues/25930\n[#26872]: https://github.com/JuliaLang/julia/issues/26872\n[#28789]: https://github.com/JuliaLang/julia/issues/28789\n[#29240]: https://github.com/JuliaLang/julia/issues/29240\n[#29333]: https://github.com/JuliaLang/julia/issues/29333\n[#29411]: https://github.com/JuliaLang/julia/issues/29411\n[#29927]: https://github.com/JuliaLang/julia/issues/29927\n[#30115]: https://github.com/JuliaLang/julia/issues/30115\n[#31149]: https://github.com/JuliaLang/julia/issues/31149\n[#31487]: https://github.com/JuliaLang/julia/issues/31487\n[#32305]: https://github.com/JuliaLang/julia/issues/32305\n[#32348]: https://github.com/JuliaLang/julia/issues/32348\n[#32748]: https://github.com/JuliaLang/julia/issues/32748\n[#33193]: https://github.com/JuliaLang/julia/issues/33193\n[#33721]: https://github.com/JuliaLang/julia/issues/33721\n[#33864]: https://github.com/JuliaLang/julia/issues/33864\n[#33886]: https://github.com/JuliaLang/julia/issues/33886\n[#33937]: https://github.com/JuliaLang/julia/issues/33937\n[#34149]: https://github.com/JuliaLang/julia/issues/34149\n[#34199]: https://github.com/JuliaLang/julia/issues/34199\n[#34200]: https://github.com/JuliaLang/julia/issues/34200\n[#34211]: https://github.com/JuliaLang/julia/issues/34211\n[#34239]: https://github.com/JuliaLang/julia/issues/34239\n[#34272]: https://github.com/JuliaLang/julia/issues/34272\n[#34296]: https://github.com/JuliaLang/julia/issues/34296\n[#34320]: https://github.com/JuliaLang/julia/issues/34320\n[#34347]: https://github.com/JuliaLang/julia/issues/34347\n[#34350]: https://github.com/JuliaLang/julia/issues/34350\n[#34419]: https://github.com/JuliaLang/julia/issues/34419\n[#34427]: https://github.com/JuliaLang/julia/issues/34427\n[#34430]: https://github.com/JuliaLang/julia/issues/34430\n[#34498]: https://github.com/JuliaLang/julia/issues/34498\n[#34524]: https://github.com/JuliaLang/julia/issues/34524\n[#34548]: https://github.com/JuliaLang/julia/issues/34548\n[#34595]: https://github.com/JuliaLang/julia/issues/34595\n[#34634]: https://github.com/JuliaLang/julia/issues/34634\n[#34652]: https://github.com/JuliaLang/julia/issues/34652\n[#34654]: https://github.com/JuliaLang/julia/issues/34654\n[#34656]: https://github.com/JuliaLang/julia/issues/34656\n[#34722]: https://github.com/JuliaLang/julia/issues/34722\n[#34791]: https://github.com/JuliaLang/julia/issues/34791\n[#34896]: https://github.com/JuliaLang/julia/issues/34896\n[#34953]: https://github.com/JuliaLang/julia/issues/34953\n[#35001]: https://github.com/JuliaLang/julia/issues/35001\n[#35078]: https://github.com/JuliaLang/julia/issues/35078\n[#35094]: https://github.com/JuliaLang/julia/issues/35094\n[#35108]: https://github.com/JuliaLang/julia/issues/35108\n[#35124]: https://github.com/JuliaLang/julia/issues/35124\n[#35132]: https://github.com/JuliaLang/julia/issues/35132\n[#35138]: https://github.com/JuliaLang/julia/issues/35138\n[#35282]: https://github.com/JuliaLang/julia/issues/35282\n[#35283]: https://github.com/JuliaLang/julia/issues/35283\n[#35289]: https://github.com/JuliaLang/julia/issues/35289\n[#35303]: https://github.com/JuliaLang/julia/issues/35303\n[#35362]: https://github.com/JuliaLang/julia/issues/35362\n[#35426]: https://github.com/JuliaLang/julia/issues/35426\n[#35513]: https://github.com/JuliaLang/julia/issues/35513\n[#35521]: https://github.com/JuliaLang/julia/issues/35521\n[#35522]: https://github.com/JuliaLang/julia/issues/35522\n[#35554]: https://github.com/JuliaLang/julia/issues/35554\n[#35626]: https://github.com/JuliaLang/julia/issues/35626\n\nJulia v1.4 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Structs with all isbits and isbitsunion fields are now stored inline in arrays ([#32448]).\n* `import` now allows quoted symbols, e.g. `import Base.:+` ([#33158]).\n* `a[begin]` can now be used to address the first element of an integer-indexed collection `a`.\n  The index is computed by `firstindex(a)` ([#33946]).\n\nLanguage changes\n----------------\n\n* The syntax `(;)`, which used to parse as an empty block expression, is deprecated.\n  In the future it will indicate an empty named tuple ([#30115]).\n\nMulti-threading changes\n-----------------------\n\n* Values can now be interpolated into `@async` and `@spawn` via `$`, which copies the value directly into the constructed\n  underlying closure ([#33119]).\n\nBuild system changes\n--------------------\n\n* Windows build installer has switched to Inno Setup. Installer command line parameters have thus changed. For example, to extract the installer to a specific directory, the command line parameter is now `/DIR=x:\\dirname`. Use `julia-installer.exe /?` to list all new command line parameters.\n\nNew library functions\n---------------------\n\n* The new `only(x)` function returns the one-and-only element of a collection `x`, and throws an `ArgumentError` if `x` contains zero or multiple elements ([#33129]).\n* `takewhile` and `dropwhile` have been added to the Iterators submodule ([#33437]).\n* `accumulate` has been added to the Iterators submodule ([#34033]).\n* There is a now an `evalpoly` function meant to take the role of the `@evalpoly` macro. The function is just as efficient as the macro while giving added flexibility, so it should be preferred over `@evalpoly`. `evalpoly` takes a list of coefficients as a tuple, so where one might write `@evalpoly(x, p1, p2, p3)` one would instead write `evalpoly(x, (p1, p2, p3))`.\n\nNew library features\n--------------------\n\n* Function composition now supports multiple functions: `\u2218(f, g, h) = f \u2218 g \u2218 h`\n  and splatting `\u2218(fs...)` for composing an iterable collection of functions ([#33568]).\n* Functions `gcd`, `lcm`, and `gcdx` now support `Rational` arguments ([#33910]).\n* The `splitpath` function now accepts any `AbstractString` whereas previously it only accepted paths of type `String` ([#33012]).\n* `filter` can now act on a `Tuple` ([#32968]).\n* The `tempname` function now takes an optional `parent::AbstractString` argument to give it a directory in which to attempt to produce a temporary path name ([#33090]).\n* The `tempname` function now takes a `cleanup::Bool` keyword argument defaulting to `true`, which causes the process to try to ensure that any file or directory at the path returned by `tempname` is deleted upon process exit ([#33090]).\n* The `readdir` function now takes a `join::Bool` keyword argument defaulting to `false`, which when set causes `readdir` to join its directory argument with each listed name ([#33113]).\n* `div` now accepts a rounding mode as the third argument, consistent with the corresponding argument to `rem`. Support for rounding division, by passing one of the RoundNearest modes to this function, was added. For future compatibility, library authors should now extend this function, rather than extending the two-argument `fld`/`cld`/`div` directly ([#33040]).\n* `methods` now accepts a module (or a list thereof) to filter methods defined in it ([#33403]).\n\nStandard library changes\n------------------------\n\n* Calling `show` or `repr` on an `undef`/`UndefInitializer()` array initializer now shows valid Julia code ([#33211]).\n* Calling `show` or `repr` on a 0-dimensional `AbstractArray` now shows valid code for creating an equivalent 0-dimensional array, instead of only showing the contained value ([#33206]).\n* `readdir` output is now guaranteed to be sorted. The `sort` keyword allows opting out of sorting to get names in OS-native order ([#33542]).\n* The methods of `mktemp` and `mktempdir` that take a function to pass temporary paths to no longer throw errors if the path is already deleted when the function returns ([#33091]).\n* Verbose `display` of `Char` (`text/plain` output) now shows the codepoint value in standard-conforming `\"U+XXXX\"` format ([#33291]).\n* `Iterators.partition` now uses views (or smartly re-computed ranges) for partitions of all `AbstractArray`s ([#33533]).\n* Sets are now displayed less compactly in the REPL, as a column of elements, like vectors\n  and dictionaries ([#33300]).\n* `delete!` on `WeakKeyDict`s now returns the `WeakKeyDict` itself instead of the underlying `Dict` used for implementation\n\n#### LinearAlgebra\n\n* `qr` and `qr!` functions support `blocksize` keyword argument ([#33053]).\n* `dot` now admits a 3-argument method `dot(x, A, y)` to compute generalized dot products `dot(x, A*y)`, but without computing and storing the intermediate result `A*y` ([#32739]).\n* `ldlt` and non-pivoted `lu` now throw a new `ZeroPivotException` type ([#33372]).\n* `cond(A, p)` with `p=1` or `p=Inf` now computes the exact condition number instead of an estimate ([#33547]).\n* `UniformScaling` objects may now be exponentiated such that `(a*I)^x = a^x * I`.\n\n#### Markdown\n\n* Tables now have the `align` attribute set when `show`n as HTML ([#33849]).\n\n#### Random\n\n* `AbstractRNG`s now behave like scalars when used in broadcasting ([#33213]).\n* The performance of `rand(::Tuple)` is improved in some cases ([#32208]). As a consequence, the\n  stream of generated values produced for a given seed has changed.\n\n#### REPL\n\n* The attributes of the implicit `IOContext` used by the REPL to display objects can be\n  modified by the user (experimental feature) ([#29249]).\n\n#### SparseArrays\n\n* The return value of `zero(x::AbstractSparseArray)` has no stored zeros anymore ([#31835]).\n  Previously, it would have stored zeros wherever `x` had them. This makes the operation\n  constant time instead of `O(<number of stored values>)`.\n* Products involving sparse arrays now allow more general sparse `eltype`s, such as `StaticArrays` ([#33205])\n\n<!--- generated by NEWS-update.jl: -->\n[#29249]: https://github.com/JuliaLang/julia/issues/29249\n[#30115]: https://github.com/JuliaLang/julia/issues/30115\n[#31835]: https://github.com/JuliaLang/julia/issues/31835\n[#32208]: https://github.com/JuliaLang/julia/issues/32208\n[#32448]: https://github.com/JuliaLang/julia/issues/32448\n[#32739]: https://github.com/JuliaLang/julia/issues/32739\n[#32968]: https://github.com/JuliaLang/julia/issues/32968\n[#33012]: https://github.com/JuliaLang/julia/issues/33012\n[#33040]: https://github.com/JuliaLang/julia/issues/33040\n[#33053]: https://github.com/JuliaLang/julia/issues/33053\n[#33090]: https://github.com/JuliaLang/julia/issues/33090\n[#33091]: https://github.com/JuliaLang/julia/issues/33091\n[#33113]: https://github.com/JuliaLang/julia/issues/33113\n[#33119]: https://github.com/JuliaLang/julia/issues/33119\n[#33129]: https://github.com/JuliaLang/julia/issues/33129\n[#33158]: https://github.com/JuliaLang/julia/issues/33158\n[#33205]: https://github.com/JuliaLang/julia/issues/33205\n[#33206]: https://github.com/JuliaLang/julia/issues/33206\n[#33211]: https://github.com/JuliaLang/julia/issues/33211\n[#33213]: https://github.com/JuliaLang/julia/issues/33213\n[#33291]: https://github.com/JuliaLang/julia/issues/33291\n[#33300]: https://github.com/JuliaLang/julia/issues/33300\n[#33372]: https://github.com/JuliaLang/julia/issues/33372\n[#33403]: https://github.com/JuliaLang/julia/issues/33403\n[#33437]: https://github.com/JuliaLang/julia/issues/33437\n[#33533]: https://github.com/JuliaLang/julia/issues/33533\n[#33542]: https://github.com/JuliaLang/julia/issues/33542\n[#33547]: https://github.com/JuliaLang/julia/issues/33547\n[#33568]: https://github.com/JuliaLang/julia/issues/33568\n[#33849]: https://github.com/JuliaLang/julia/issues/33849\n[#33910]: https://github.com/JuliaLang/julia/issues/33910\n[#33946]: https://github.com/JuliaLang/julia/issues/33946\n[#34033]: https://github.com/JuliaLang/julia/issues/34033\n\nJulia v1.3 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Support for Unicode 12.1.0 ([#32002]).\n* Methods can now be added to an abstract type ([#31916]).\n* Support for unicode bold digits and double-struck digits 0 through 9 as valid identifiers ([#32838]).\n* Added the syntax `var\"#str#\"` for printing and parsing non-standard variable names ([#32408]).\n\nLanguage changes\n----------------\n\n\nMulti-threading changes\n-----------------------\n\n* New experimental `Threads.@spawn` macro that runs a task on any available thread ([#32600]).\n* All system-level I/O operations (e.g. files and sockets) are now thread-safe.\n  This does not include subtypes of `IO` that are entirely in-memory, such as `IOBuffer`,\n  although it specifically does include `BufferStream`.\n  ([#32309], [#32174], [#31981], [#32421]).\n* The global random number generator (`GLOBAL_RNG`) is now thread-safe (and thread-local) ([#32407]).\n* New `Channel(f::Function, spawn=true)` keyword argument to schedule the created Task on\n  any available thread, matching the behavior of `Threads.@spawn` ([#32872]).\n* Simplified the `Channel` constructor, which is now easier to read and more idiomatic julia.\n  Use of the keyword arguments `csize` and `ctype` is now discouraged ([#30855], [#32818]).\n\nBuild system changes\n--------------------\n\n\nNew library functions\n---------------------\n\n* `findfirst`, `findlast`, `findnext` and `findprev` now accept a character as first argument\n  to search for that character in a string passed as the second argument ([#31664]).\n* New `findall(pattern, string)` method where `pattern` is a string or regex ([#31834]).\n* `count(pattern, string)` gives the number of things `findall` would match ([#32849]).\n* `istaskfailed` is now documented and exported, like its siblings `istaskdone` and `istaskstarted` ([#32300]).\n* `RefArray` and `RefValue` objects now accept index `CartesianIndex()` in  `getindex` and `setindex!` ([#32653])\n* Added `sincosd(x)` to simultaneously compute the sine and cosine of `x`, where `x` is in degrees ([#30134]).\n* The function `nonmissingtype`, which removes `Missing` from type unions, is now exported ([#31562]).\n\nStandard library changes\n------------------------\n\n* `Pkg` won't clobber pre-compilation files as often when switching environments ([#32651])\n* `Pkg` can now download and install binary artifacts through the `Pkg.Artifacts`\n   submodule and supporting functions. ([#32918])\n* When `wait` (or `@sync`, or `fetch`) is called on a failing `Task`, the exception is propagated as a\n  `TaskFailedException` wrapping the task.\n  This makes it possible to see the location of the original failure inside the task (as well as the\n  location of the `wait` call, as before) ([#32814]).\n* `Regex` can now be multiplied (`*`) and exponentiated (`^`), like strings ([#23422]).\n* `Cmd` interpolation (``` `$(x::Cmd) a b c` ``` where) now propagates `x`'s process flags\n  (environment, flags, working directory, etc) if `x` is the first interpolant and errors\n  otherwise ([#24353]).\n* Zero-dimensional arrays are now consistently preserved in the return values of mathematical\n  functions that operate on the array(s) as a whole (and are not explicitly broadcasted across their elements).\n  Previously, the functions  `+`, `-`, `*`, `/`, `conj`, `real` and `imag` returned the unwrapped element\n  when operating over zero-dimensional arrays ([#32122]).\n* `IPAddr` subtypes now behave like scalars when used in broadcasting ([#32133]).\n* `Pair` is now treated as a scalar for broadcasting ([#32209]).\n* `clamp` can now handle missing values ([#31066]).\n* `empty` now accepts a `NamedTuple` ([#32534]).\n* `mod` now accepts a unit range as the second argument to easily perform offset modular arithmetic to ensure the result is inside the range ([#32628]).\n* `nothing` can now be `print`ed, and interpolated into strings etc. as the string `\"nothing\"`. It is still not permitted to be interpolated into Cmds (i.e. ``echo `$(nothing)` `` will still error without running anything.) ([#32148])\n* When `open` is called with a function, command, and keyword argument (e.g. ```open(`ls`, read=true) do f ...```)\n  it now correctly throws a `ProcessFailedException` like other similar calls ([#32193]).\n* `mktemp` and `mktempdir` now try, by default, to remove temporary paths they create before the process exits ([#32851]).\n* Added argument `keep` to `unescape_string` ([#27125]).\n\n#### Libdl\n\n* `dlopen()` can now be invoked in `do`-block syntax, similar to `open()`.\n\n#### LinearAlgebra\n\n* The BLAS submodule no longer exports `dot`, which conflicts with that in LinearAlgebra ([#31838]).\n* `diagm` and `spdiagm` now accept optional `m,n` initial arguments to specify a size ([#31654]).\n* `Hessenberg` factorizations `H` now support efficient shifted solves `(H+\u00b5I) \\ b` and determinants, and use a specialized tridiagonal factorization for Hermitian matrices. There is also a new `UpperHessenberg` matrix type ([#31853]).\n* Added keyword argument `alg` to `svd` and `svd!` that allows one to switch between different SVD algorithms ([#31057]).\n* Five-argument `mul!(C, A, B, \u03b1, \u03b2)` now implements inplace multiplication fused with addition _C = A B \u03b1 + C \u03b2_ ([#23919]).\n\n#### SparseArrays\n\n* `SparseMatrixCSC(m,n,colptr,rowval,nzval)` perform consistency checks for arguments:\n  `colptr` must be properly populated and lengths of `colptr`, `rowval`, and `nzval`\n  must be compatible with `m`, `n`, and `eltype(colptr)`.\n* `sparse(I, J, V, m, n)` verifies lengths of `I`, `J`, `V` are equal and compatible with\n  `eltype(I)` and `m`, `n`.\n\n#### Dates\n\n* `DateTime` and `Time` formatting/parsing now supports 12-hour clocks with AM/PM via `I` and `p` codes, similar to `strftime` ([#32308]).\n* Fixed `repr` such that it displays `Time` as it would be entered in Julia ([#32103]).\n\n#### Statistics\n\n* `mean` now accepts both a function argument and a `dims` keyword ([#31576]).\n\n#### Sockets\n\n* `Sockets.recvfrom` now returns both host and port as an InetAddr ([#32729]).\n* Added `InetAddr` constructor from `AbstractString`, representing IP address, and `Integer`,\n  representing port number ([#31459]).\n\n#### Miscellaneous\n\n* `foldr` and `mapfoldr` now work on any iterator that supports `Iterators.reverse`, not just arrays ([#31781]).\n\nDeprecated or removed\n---------------------\n\n* `@spawn expr` from the `Distributed` standard library should be replaced with `@spawnat :any expr` ([#32600]).\n* `Threads.Mutex` and `Threads.RecursiveSpinLock` have been removed; use `ReentrantLock` (preferred) or\n  `Threads.SpinLock` instead ([#32875]).\n\nExternal dependencies\n---------------------\n\nTooling Improvements\n---------------------\n\n* The `ClangSA.jl` static analysis package has been imported, which makes use of\n  the clang static analyzer to validate GC invariants in Julia's C code. The analysis\n  may be run using `make -C src analyzegc`.\n\n<!--- generated by NEWS-update.jl: -->\n[#23422]: https://github.com/JuliaLang/julia/issues/23422\n[#23919]: https://github.com/JuliaLang/julia/issues/23919\n[#24353]: https://github.com/JuliaLang/julia/issues/24353\n[#27125]: https://github.com/JuliaLang/julia/issues/27125\n[#30134]: https://github.com/JuliaLang/julia/issues/30134\n[#30855]: https://github.com/JuliaLang/julia/issues/30855\n[#31057]: https://github.com/JuliaLang/julia/issues/31057\n[#31066]: https://github.com/JuliaLang/julia/issues/31066\n[#31459]: https://github.com/JuliaLang/julia/issues/31459\n[#31562]: https://github.com/JuliaLang/julia/issues/31562\n[#31576]: https://github.com/JuliaLang/julia/issues/31576\n[#31654]: https://github.com/JuliaLang/julia/issues/31654\n[#31664]: https://github.com/JuliaLang/julia/issues/31664\n[#31781]: https://github.com/JuliaLang/julia/issues/31781\n[#31834]: https://github.com/JuliaLang/julia/issues/31834\n[#31838]: https://github.com/JuliaLang/julia/issues/31838\n[#31853]: https://github.com/JuliaLang/julia/issues/31853\n[#31916]: https://github.com/JuliaLang/julia/issues/31916\n[#31981]: https://github.com/JuliaLang/julia/issues/31981\n[#32002]: https://github.com/JuliaLang/julia/issues/32002\n[#32103]: https://github.com/JuliaLang/julia/issues/32103\n[#32122]: https://github.com/JuliaLang/julia/issues/32122\n[#32133]: https://github.com/JuliaLang/julia/issues/32133\n[#32148]: https://github.com/JuliaLang/julia/issues/32148\n[#32174]: https://github.com/JuliaLang/julia/issues/32174\n[#32193]: https://github.com/JuliaLang/julia/issues/32193\n[#32209]: https://github.com/JuliaLang/julia/issues/32209\n[#32300]: https://github.com/JuliaLang/julia/issues/32300\n[#32308]: https://github.com/JuliaLang/julia/issues/32308\n[#32309]: https://github.com/JuliaLang/julia/issues/32309\n[#32407]: https://github.com/JuliaLang/julia/issues/32407\n[#32408]: https://github.com/JuliaLang/julia/issues/32408\n[#32421]: https://github.com/JuliaLang/julia/issues/32421\n[#32534]: https://github.com/JuliaLang/julia/issues/32534\n[#32600]: https://github.com/JuliaLang/julia/issues/32600\n[#32628]: https://github.com/JuliaLang/julia/issues/32628\n[#32653]: https://github.com/JuliaLang/julia/issues/32653\n[#32729]: https://github.com/JuliaLang/julia/issues/32729\n[#32814]: https://github.com/JuliaLang/julia/issues/32814\n[#32818]: https://github.com/JuliaLang/julia/issues/32818\n[#32838]: https://github.com/JuliaLang/julia/issues/32838\n[#32849]: https://github.com/JuliaLang/julia/issues/32849\n[#32851]: https://github.com/JuliaLang/julia/issues/32851\n[#32872]: https://github.com/JuliaLang/julia/issues/32872\n[#32875]: https://github.com/JuliaLang/julia/issues/32875\n\nJulia v1.2 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Argument splatting (`x...`) can now be used in calls to the `new` pseudo-function in\n  constructors ([#30577]).\n* Support for Unicode 12.0.0 ([#31561]).\n* Added `\u22c6` (`\\star`) as unary operator ([#31604]).\n\nLanguage changes\n----------------\n\n* Empty entries in `JULIA_DEPOT_PATH` are now expanded to default depot entries ([#31009]).\n\nMulti-threading changes\n-----------------------\n\n* The `Condition` type now has a thread-safe replacement, accessed as `Threads.Condition`.\n  With that addition, task scheduling primitives such as `ReentrantLock` are now thread-safe ([#30061]).\n* It is possible to schedule and switch Tasks during `@threads` loops, and perform limited I/O ([#31438]).\n\nBuild system changes\n--------------------\n\n* The build system now prefers downloading prebuilt binary tarballs for most dependencies on\n  supported systems, disable by setting `USE_BINARYBUILDER=0` at `make` time ([#31441]).\n\nNew library functions\n---------------------\n\n* `getipaddrs()` function returns all the IP addresses of the local machine, with IPv4 addresses sorting before IPv6 addresses ([#30349, #30604]).\n* `getipaddr(addr_type)` and `getipaddrs(addr_type)` functions returns an IP address(es) of the desired type of the local machine ([#30604]).\n* Added `Base.hasproperty` and `Base.hasfield` ([#28850]).\n* One argument `!=(x)`, `>(x)`, `>=(x)`, `<(x)`, `<=(x)` have been added, returning partially-applied\n  versions of the functions, similar to the existing `==(x)` and `isequal(x)` methods ([#30915]).\n* The new `map!(f, values(::AbstractDict))` method allows to modify in-place values of a dictionary ([#31223]).\n\nStandard library changes\n------------------------\n\n* `Enum` now behaves like a scalar when used in broadcasting ([#30670]).\n* If a `pipeline` is specified with `append=true` set, but no redirection, an `ArgumentError`\n  is thrown, rather than a `ErrorException` ([#27900]).\n* Functions that invoke commands (e.g. `run(::Cmd)`) now throw a `ProcessFailedException`\n  rather than an `ErrorException`, if those commands exit with non-zero exit code ([#27900]).\n* The `extrema` function now accepts a function argument in the same manner as `minimum` and\n  `maximum` ([#30323]).\n* `hasmethod` can now check for matching keyword argument names ([#30712]).\n* `startswith` and `endswith` now accept a `Regex` for the second argument ([#29790]).\n* `retry` supports arbitrary callable objects ([#30382]).\n* A no-argument constructor for `Ptr{T}` has been added which constructs a null pointer ([#30919]).\n* `strip` now accepts a function argument in the same manner as `lstrip` and `rstrip` ([#31211]).\n* `mktempdir` now accepts a `prefix` keyword argument to customize the file name ([#31230], [#22922]).\n* `keytype` and `valtype` now work on `AbstractArray`, and return the `eltype` of `keys(...)` and\n  `values(...)` respectively ([#27749]).\n* `nextfloat(::BigFloat)` and `prevfloat(::BigFloat)` now returns a value with the same precision\n  as their argument, which means that (in particular) `nextfloat(prevfloat(x)) == x` whereas\n  previously this could result in a completely different value with a different precision ([#31310]).\n* `mapreduce` now accepts multiple iterators, similar to `map` ([#31532]).\n* `filter` now supports `SkipMissing`-wrapped arrays ([#31235]).\n* Objects created by calling `skipmissing` on an array can now be indexed using indices\n  from the parent at non-missing positions. This allows functions such as\n  `findall`, `findfirst`, `argmin`/`argmax` and `findmin`/`findmax` to work with these\n  objects, returning the index of matching non-missing elements in the parent ([#31008]).\n* `inv(::Missing)` has now been added and returns `missing` ([#31451]).\n* `nextfloat(::BigFloat, n::Integer)` and `prevfloat(::BigFloat, n::Integer)` methods\n  have been added ([#31310]).\n\n#### LinearAlgebra\n* Added keyword arguments `rtol`, `atol` to `pinv` and `nullspace` ([#29998]).\n* `UniformScaling` instances are now callable such that e.g. `I(3)` will produce a `Diagonal` matrix ([#30298]).\n* Eigenvalues \u03bb of general matrices are now sorted lexicographically by (Re \u03bb, Im \u03bb) ([#21598]).\n* `one` for structured matrices (`Diagonal`, `Bidiagonal`, `Tridiagonal`, `Symtridiagonal`) now preserves\n  structure and type ([#29777]).\n* `diagm(v)` is now a shorthand for `diagm(0 => v)` ([#31125]).\n\n#### SparseArrays\n* Performance improvements for sparse matrix-matrix multiplication ([#30372]).\n* Sparse vector outer products are more performant and maintain sparsity in products of the\n  form `kron(u, v')`, `u * v'`, and `u .* v'` where `u` and `v` are sparse vectors or column\n  views ([#24980]).\n* The `sprand` function is now 2 to 5 times faster ([#30494]). As a consequence of this change, the random stream of matrices produced with `sprand` and `sprandn` has changed.\n\n#### Sockets\n\n* `getipaddrs` returns IP addresses in the order provided by libuv ([#32260]).\n* `getipaddr` prefers to return the first `IPv4` interface address provided by libuv ([#32260]).\n\n#### Dates\n* Fixed `repr` such that it displays `DateTime` as it would be entered in Julia ([#30200]).\n\n#### Statistics\n* `quantile` now accepts in all cases collections whose `eltype` is not a subtype of `Number` ([#30938]).\n\n#### Miscellaneous\n* Since environment variables on Windows are case-insensitive, `ENV` now converts its keys\n  to uppercase for display, iteration, and copying ([#30593]).\n\nExternal dependencies\n---------------------\n\n* libgit2 has been updated to v0.27.7 ([#30584]).\n* OpenBLAS has been updated to v0.3.5 ([#30583]).\n* MbedTLS has been updated to v2.16.0 ([#30618]).\n* libunwind has been updated to v1.3.1 ([#30724]).\n\n<!--- generated by NEWS-update.jl: -->\n[#21598]: https://github.com/JuliaLang/julia/issues/21598\n[#22922]: https://github.com/JuliaLang/julia/issues/22922\n[#24980]: https://github.com/JuliaLang/julia/issues/24980\n[#27749]: https://github.com/JuliaLang/julia/issues/27749\n[#27900]: https://github.com/JuliaLang/julia/issues/27900\n[#28850]: https://github.com/JuliaLang/julia/issues/28850\n[#29777]: https://github.com/JuliaLang/julia/issues/29777\n[#29790]: https://github.com/JuliaLang/julia/issues/29790\n[#29998]: https://github.com/JuliaLang/julia/issues/29998\n[#30061]: https://github.com/JuliaLang/julia/issues/30061\n[#30200]: https://github.com/JuliaLang/julia/issues/30200\n[#30298]: https://github.com/JuliaLang/julia/issues/30298\n[#30323]: https://github.com/JuliaLang/julia/issues/30323\n[#30372]: https://github.com/JuliaLang/julia/issues/30372\n[#30382]: https://github.com/JuliaLang/julia/issues/30382\n[#30494]: https://github.com/JuliaLang/julia/issues/30494\n[#30577]: https://github.com/JuliaLang/julia/issues/30577\n[#30583]: https://github.com/JuliaLang/julia/issues/30583\n[#30584]: https://github.com/JuliaLang/julia/issues/30584\n[#30593]: https://github.com/JuliaLang/julia/issues/30593\n[#30604]: https://github.com/JuliaLang/julia/issues/30604\n[#30618]: https://github.com/JuliaLang/julia/issues/30618\n[#30670]: https://github.com/JuliaLang/julia/issues/30670\n[#30712]: https://github.com/JuliaLang/julia/issues/30712\n[#30724]: https://github.com/JuliaLang/julia/issues/30724\n[#30915]: https://github.com/JuliaLang/julia/issues/30915\n[#30919]: https://github.com/JuliaLang/julia/issues/30919\n[#30938]: https://github.com/JuliaLang/julia/issues/30938\n[#31008]: https://github.com/JuliaLang/julia/issues/31008\n[#31009]: https://github.com/JuliaLang/julia/issues/31009\n[#31125]: https://github.com/JuliaLang/julia/issues/31125\n[#31211]: https://github.com/JuliaLang/julia/issues/31211\n[#31230]: https://github.com/JuliaLang/julia/issues/31230\n[#31235]: https://github.com/JuliaLang/julia/issues/31235\n[#31310]: https://github.com/JuliaLang/julia/issues/31310\n[#31438]: https://github.com/JuliaLang/julia/issues/31438\n[#31441]: https://github.com/JuliaLang/julia/issues/31441\n[#31451]: https://github.com/JuliaLang/julia/issues/31451\n[#31532]: https://github.com/JuliaLang/julia/issues/31532\n[#31561]: https://github.com/JuliaLang/julia/issues/31561\n[#31604]: https://github.com/JuliaLang/julia/issues/31604\n[#32260]: https://github.com/JuliaLang/julia/issues/32260\n\nJulia v1.1 Release Notes\n========================\n\nNew language features\n---------------------\n\n  * An *exception stack* is maintained on each task to make exception handling\n    more robust and enable root cause analysis. The stack may be accessed using\n    the experimental function `Base.catch_stack` ([#28878]).\n  * The experimental macro `Base.@locals` returns a dictionary of current local variable names\n    and values ([#29733]).\n  * Binary `~` can now be dotted, as in `x .~ y` ([#30341]).\n\nLanguage changes\n----------------\n\n  * Parser inputs ending with a comma are now consistently treated as incomplete.\n    Previously they were sometimes parsed as tuples, depending on whitespace ([#28506]).\n  * Spaces were accidentally allowed in broadcast call syntax, e.g. `f. (x)`. They are now\n    disallowed, consistent with normal function call syntax ([#29781]).\n  * Big integer literals and command syntax (backticks) are now parsed with the name of\n    the macro (`@int128_str`, `@uint128_str`, `@big_str`, `@cmd`) qualified to refer\n    to the `Core` module ([#29968]).\n  * Using the same name for both a local variable and a static parameter is now an error instead\n    of a warning ([#29429]).\n  * `findall(in(b), a)` now returns a `CartesianIndex` when `a` is a matrix or a higher-dimensional array,\n    for consistency with other `findall` methods. Use `LinearIndices(a)[findall(in(b), a)]` to get\n    the old behavior, or `CartesianIndices(a)[findall(in(b), a)]` to get the new behavior\n    on previous Julia versions ([#30226]).\n  * `findmin(::BitArray)` and `findmax(::BitArray)` now return a `CartesianIndex` when `a` is a matrix\n    or a higher-dimensional array, for consistency with other array types.\n    Use `LinearIndices(a)[findmin(a)[2]]` to get the old behavior, or `CartesianIndices(a)[findmin(a)[2]]`\n    to get the new behavior on previous Julia versions ([#30102]).\n  * Method signatures such as\n    `f(::Type{T}, ::T) where {T <: X}` and\n    `f(::Type{X}, ::Any)`\n    are now considered ambiguous. Previously a bug caused the first one to be considered more specific in\n    some cases ([#30160]).\n\nCommand-line option changes\n---------------------------\n\n  * When a script run in interactive mode (`-i`) throws an error, the REPL now starts after\n    the error is displayed. Previously the REPL only started if the script completed without\n    error ([#21233]).\n\nNew library functions\n---------------------\n\n  * `splitpath(p::String)` function, which is the opposite of `joinpath(parts...)`: it splits a filepath\n    into its components ([#28156]).\n  * `isnothing(::Any)` predicate, to check whether the argument is `nothing`. ([#29679]).\n  * `getpid(::Process)` method ([#24064]).\n  * `eachrow`, `eachcol` and `eachslice` functions provide efficient iterators over slices of arrays ([#29749]).\n  * `fieldtypes(T::Type)` which returns the declared types of the field in type T ([#29600]).\n  * `uuid5` has been added to the `UUIDs` standard library ([#28761]).\n  * Predicates `Sys.isfreebsd`, `Sys.isopenbsd`, `Sys.isnetbsd`, and `Sys.isdragonfly` for\n    detecting BSD systems have been added ([#30249]).\n  * Internal `Base.disable_library_threading` that sets libraries to use one thread.\n    It executes function hooks that have been registered with\n    `Base.at_disable_library_threading` ([#30004]).\n\nStandard library changes\n------------------------\n\n  * `CartesianIndices` can now be constructed from two `CartesianIndex`es `I` and `J` with `I:J` ([#29440]).\n  * `CartesianIndices` support broadcasting arithmetic (+ and -) with a `CartesianIndex` ([#29890]).\n  * `copy!` support for arrays, dicts, and sets has been moved to Base from the Future package ([#29173]).\n  * Channels now convert inserted values (like containers) instead of requiring types to match ([#29092]).\n  * `range` can accept the stop value as a positional argument, e.g. `range(1,10,step=2)` ([#28708]).\n  * `diff` now supports arrays of arbitrary dimensionality and can operate over any dimension ([#29827]).\n  * The constructor `BigFloat(::BigFloat)` now respects the global precision setting and always\n    returns a `BigFloat` with precision equal to `precision(BigFloat)` ([#29127]). The optional\n    `precision` argument to override the global setting is now a keyword instead of positional\n    argument ([#29157]).\n  * The use of scientific notation when printing `BigFloat` values is now consistent with other floating point\n    types ([#29211]).\n  * `Regex` now behaves like a scalar when used in broadcasting ([#29913]).\n  * `Char` now behaves like a read-only 0-dimensional array ([#29819]).\n  * `parse` now allows strings representing integer 0 and 1 for type `Bool` ([#29980]).\n  * `Base.tail` now works on named tuples ([#29595]).\n  * The process id is appended to malloc log files in order to track memory allocations of\n    multiple processes ([#29969]).\n  * `Base.julia_cmd` now propagates the `--inline=(yes|no)` flag ([#29858]).\n  * `Base.@kwdef` can now be used for parametric structs, and for structs with supertypes ([#29316]).\n  * `merge(::NamedTuple, ::NamedTuple...)` can now be used with more than 2 `NamedTuple`s ([#29259]).\n  * New `ncodeunits(c::Char)` method as a fast equivalent to `ncodeunits(string(c))` ([#29153]).\n  * New `sort!(::AbstractArray; dims)` method that can sort the array along the `dims` dimension ([#28902]).\n  * `range` now accepts `stop` as a positional argument ([#28708]).\n  * `get(A::AbstractArray, (), default)` now returns `A[]` instead of an empty array ([#30270]).\n  * `parse(Bool, str)` is now supported ([#29997]).\n  * `copyto!(::AbstractMatrix, ::UniformScaling)` now supports rectangular matrices ([#28790]).\n  * `current_project()` now searches the parent directories of a Git repository for a `Project.toml` file.\n    This also affects the behavior of the `--project` command line option when using the default\n    `--project=@.` ([#29108]).\n  * The `spawn` API is now more flexible and supports taking IOBuffer directly as an I/O stream,\n    converting to a system pipe as needed ([#30278]).\n\n#### Dates\n  * New `DateTime(::Date, ::Time)` constructor ([#29754]).\n  * `TimeZone` now behaves like a scalar when used in broadcasting ([#30159]).\n\n#### InteractiveUtils\n  * `edit` can now be called on a module to edit the file that defines it ([#29636]).\n  * All compiler-reflection tools (i.e. the `code_` class of functions and macros) now print accurate\n    line number and inlining information in a common style, and take an optional parameter (debuginfo=:default)\n    to control the verbosity of the metadata shown ([#29893]).\n\n#### LinearAlgebra\n  * `isdiag` and `isposdef` for `Diagonal` and `UniformScaling` ([#29638]).\n  * `mul!`, `rmul!` and `lmul!` methods for `UniformScaling` ([#29506]).\n  * `Symmetric` and `Hermitian` matrices now preserve the wrapper when scaled with a number ([#29469]).\n  * Exponentiation operator `^` now supports raising an `Irrational` to an `AbstractMatrix` power ([#29782]).\n  * Added keyword arguments `rtol`, `atol` to `rank` ([#29926]).\n\n#### Random\n  * `randperm` and `randcycle` now use the type of their argument to determine the element type of\n    the returned array ([#29670]).\n  * A new method `rand(::Tuple)` implements sampling from the values of a tuple ([#25278]).\n  * `serialize` and `deserialize` now accept a filename argument, like `write` and `read` ([#30151]).\n\n#### SparseArrays\n  * `sprandn` now supports specifying the output element type ([#30083]).\n\n#### Statistics\n  * `mean` and `var` now handle more kinds of empty inputs ([#29033]).\n\nExternal dependencies\n---------------------\n\n  * 7zip (bundled with Julia on Windows) has been upgraded from version 16.04 to 18.05 ([#30035]).\n  * Busybox is no longer bundled with Julia on Windows ([#30022]).\n  * OpenBLAS has been upgraded from 0.3.2 to 0.3.3 ([#29845]).\n  * The source code for Pkg is no longer included in JuliaLang/julia. Pkg is instead\n    downloaded during the build process ([#29615]).\n  * LLVM has been upgraded to 6.0.1 and support for LLVM < 6.0 has been dropped ([#28745], [#28696]).\n  * Pkg has been upgraded to version 1.1 ([#30342]).\n\nDeprecated or removed\n---------------------\n\n  * `one(i::CartesianIndex)` should be replaced with `oneunit(i::CartesianIndex)` ([#29442]).\n  * The internal array `Base.Grisu.DIGITS` is deprecated; new code should use `Base.Grisu.getbuf()`\n    to get an appropriate task-local buffer and pass it to `grisu()` instead ([#29907]).\n  * The internal function `Base._default_type(T)` has been removed. Calls to it should be\n    replaced with just the argument `T` ([#29739]).\n  * `peakflops` has been scheduled to move from `InteractiveUtils` to `LinearAlgebra`\n    but is already now available as `LinearAlgebra.peakflops` ([#29978]).\n\n<!--- generated by NEWS-update.jl: -->\n[#21233]: https://github.com/JuliaLang/julia/issues/21233\n[#24064]: https://github.com/JuliaLang/julia/issues/24064\n[#25278]: https://github.com/JuliaLang/julia/issues/25278\n[#28156]: https://github.com/JuliaLang/julia/issues/28156\n[#28506]: https://github.com/JuliaLang/julia/issues/28506\n[#28696]: https://github.com/JuliaLang/julia/issues/28696\n[#28708]: https://github.com/JuliaLang/julia/issues/28708\n[#28745]: https://github.com/JuliaLang/julia/issues/28745\n[#28761]: https://github.com/JuliaLang/julia/issues/28761\n[#28790]: https://github.com/JuliaLang/julia/issues/28790\n[#28878]: https://github.com/JuliaLang/julia/issues/28878\n[#28902]: https://github.com/JuliaLang/julia/issues/28902\n[#29033]: https://github.com/JuliaLang/julia/issues/29033\n[#29092]: https://github.com/JuliaLang/julia/issues/29092\n[#29108]: https://github.com/JuliaLang/julia/issues/29108\n[#29127]: https://github.com/JuliaLang/julia/issues/29127\n[#29153]: https://github.com/JuliaLang/julia/issues/29153\n[#29157]: https://github.com/JuliaLang/julia/issues/29157\n[#29173]: https://github.com/JuliaLang/julia/issues/29173\n[#29211]: https://github.com/JuliaLang/julia/issues/29211\n[#29259]: https://github.com/JuliaLang/julia/issues/29259\n[#29316]: https://github.com/JuliaLang/julia/issues/29316\n[#29429]: https://github.com/JuliaLang/julia/issues/29429\n[#29440]: https://github.com/JuliaLang/julia/issues/29440\n[#29442]: https://github.com/JuliaLang/julia/issues/29442\n[#29469]: https://github.com/JuliaLang/julia/issues/29469\n[#29506]: https://github.com/JuliaLang/julia/issues/29506\n[#29595]: https://github.com/JuliaLang/julia/issues/29595\n[#29600]: https://github.com/JuliaLang/julia/issues/29600\n[#29615]: https://github.com/JuliaLang/julia/issues/29615\n[#29636]: https://github.com/JuliaLang/julia/issues/29636\n[#29638]: https://github.com/JuliaLang/julia/issues/29638\n[#29670]: https://github.com/JuliaLang/julia/issues/29670\n[#29679]: https://github.com/JuliaLang/julia/issues/29679\n[#29733]: https://github.com/JuliaLang/julia/issues/29733\n[#29739]: https://github.com/JuliaLang/julia/issues/29739\n[#29749]: https://github.com/JuliaLang/julia/issues/29749\n[#29754]: https://github.com/JuliaLang/julia/issues/29754\n[#29781]: https://github.com/JuliaLang/julia/issues/29781\n[#29782]: https://github.com/JuliaLang/julia/issues/29782\n[#29819]: https://github.com/JuliaLang/julia/issues/29819\n[#29827]: https://github.com/JuliaLang/julia/issues/29827\n[#29845]: https://github.com/JuliaLang/julia/issues/29845\n[#29858]: https://github.com/JuliaLang/julia/issues/29858\n[#29890]: https://github.com/JuliaLang/julia/issues/29890\n[#29893]: https://github.com/JuliaLang/julia/issues/29893\n[#29907]: https://github.com/JuliaLang/julia/issues/29907\n[#29913]: https://github.com/JuliaLang/julia/issues/29913\n[#29926]: https://github.com/JuliaLang/julia/issues/29926\n[#29968]: https://github.com/JuliaLang/julia/issues/29968\n[#29969]: https://github.com/JuliaLang/julia/issues/29969\n[#29978]: https://github.com/JuliaLang/julia/issues/29978\n[#29980]: https://github.com/JuliaLang/julia/issues/29980\n[#29997]: https://github.com/JuliaLang/julia/issues/29997\n[#30004]: https://github.com/JuliaLang/julia/issues/30004\n[#30022]: https://github.com/JuliaLang/julia/issues/30022\n[#30035]: https://github.com/JuliaLang/julia/issues/30035\n[#30083]: https://github.com/JuliaLang/julia/issues/30083\n[#30102]: https://github.com/JuliaLang/julia/issues/30102\n[#30151]: https://github.com/JuliaLang/julia/issues/30151\n[#30159]: https://github.com/JuliaLang/julia/issues/30159\n[#30160]: https://github.com/JuliaLang/julia/issues/30160\n[#30226]: https://github.com/JuliaLang/julia/issues/30226\n[#30249]: https://github.com/JuliaLang/julia/issues/30249\n[#30270]: https://github.com/JuliaLang/julia/issues/30270\n[#30278]: https://github.com/JuliaLang/julia/issues/30278\n[#30341]: https://github.com/JuliaLang/julia/issues/30341\n[#30342]: https://github.com/JuliaLang/julia/issues/30342\n\nJulia v1.0.0 Release Notes\n==========================\n\nJulia v1.0 is identical to the v0.7 release, with the exception that\nit removes all deprecations and deprecation related warnings. When\nupgrading a codebase from v0.6, the process is to first get the code\nto work on v0.7, and fix all the deprecation warnings. Once the code\nruns on v0.7 without warnings, it should be good to run on v1.0.\n\nRefer to the [Release Notes for\nv0.7](https://github.com/JuliaLang/julia/blob/master/HISTORY.md) for a\ndetailed list of changes from Julia v0.6.\n\nStandard Library Changes\n------------------------\n\n* The `Libdl` module's methods `dlopen()` and `dlsym()` have gained a\n  `throw_error` keyword argument, replacing the now-deprecated `dlopen_e()`\n  and `dlsym_e()` methods.  When `throw_error` is `false`, failure to locate\n  a shared library or symbol will return `nothing` rather than `C_NULL`.\n  ([#28888])\n\nDeprecated or removed\n---------------------\n\n* The old package manager (now called `OldPkg`) has been moved to a\n  separate repository at https://github.com/JuliaArchive/OldPkg.jl ([#27930])\n\n<!--- generated by NEWS-update.jl: -->\n[#27930]: https://github.com/JuliaLang/julia/issues/27930\n[#28888]: https://github.com/JuliaLang/julia/issues/28888\n\nJulia v0.7.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Local variables can be tested for being defined\n    using the new `@isdefined variable` macro ([#22281]).\n\n  * Destructuring in function arguments: when an expression such as `(x, y)` is used as\n    a function argument name, the argument is unpacked into local variables `x` and `y`\n    as in the assignment `(x, y) = arg` ([#6614]).\n\n  * Named tuples, with the syntax `(a=1, b=2)`. These behave very similarly to tuples,\n    except components can also be accessed by name using dot syntax `t.a` ([#22194]).\n\n  * Keyword argument containers (`kw` in `f(; kw...)`) are now based on named tuples. Dictionary\n    functions like `haskey` and indexing can be used on them, and name-value pairs can be\n    iterated using `pairs(kw)`. `kw` can no longer contain multiple entries for the same\n    argument name ([#4916]).\n\n  * Custom infix operators can now be defined by appending Unicode\n    combining marks, primes, and sub/superscripts to other operators.\n    For example, `+\u0302\u2090\u2033` is parsed as an infix operator with the same\n    precedence as `+` ([#22089]).\n\n  * The macro call syntax `@macroname[args]` is now available and is parsed\n    as `@macroname([args])` ([#23519]).\n\n  * The construct `if @generated ...; else ...; end` can be used to provide both\n    `@generated` and normal implementations of part of a function. Surrounding code\n    will be common to both versions ([#23168]).\n\n  * Added `\u27c2` (`\\perp`) operator with comparison precedence ([#24404]).\n\n  * The `missing` singleton object (of type `Missing`) has been added to represent\n    missing values ([#24653]). It propagates through standard operators and mathematical functions,\n    and implements three-valued logic, similar to SQLs `NULL` and R's `NA`.\n\n  * Field access via dot-syntax can now be overloaded by adding methods to\n    `Base.getproperty` and `Base.setproperty!` ([#1974]), optionally along with\n    a corresponding `Base.propertynames` method for reflection ([#25311]).\n\n  * Values for `Enum`s can now be specified inside of a `begin` block when using the\n    `@enum` macro ([#25424]).\n\n  * Keyword arguments can be required: if a default value is omitted, then an\n    exception is thrown if the caller does not assign the keyword a value ([#25830]).\n\n  * The pair operator `=>` is now broadcastable as `.=>` which was previously a parsing error ([#27447])\n\nLanguage changes\n----------------\n\n  * The syntax for parametric methods, `function f{T}(x::T)`, has been\n    changed to `function f(x::T) where {T}` ([#11310]).\n\n  * The fallback constructor that calls `convert` is deprecated. Instead, new types should\n    prefer to define constructors, and add `convert` methods that call those constructors\n    only as necessary ([#15120]).\n\n  * The syntax `1.+2` is deprecated, since it is ambiguous: it could mean either\n    `1 .+ 2` (the current meaning) or `1. + 2` ([#19089]).\n\n  * Mutable structs with no fields are no longer singletons; it is now possible to make\n    multiple instances of them that can be distinguished by `===` ([#25854]).\n    Zero-size immutable structs are still singletons.\n\n  * In string and character literals, backslash `\\` may no longer\n    precede unrecognized escape characters ([#22800]).\n\n  * Juxtaposing binary, octal, and hexadecimal literals is deprecated, since it can lead to\n    confusing code such as `0xapi == 0xa * pi` ([#16356]).\n\n  * Numeric literal juxtaposition now has slighty lower precedence than unary operators,\n    so for example `\u221a2x` parses as `(\u221a2) * x` ([#27641]).\n\n  * Declaring arguments as `x::ANY` to avoid specialization has been replaced\n    by `@nospecialize x`. ([#22666]).\n\n    This can also be used in global scope, to apply to all subsequent method definitions\n    in the module (until `@specialize`). ([#28065])\n\n  * Keyword argument default values are now evaluated in successive scopes ---\n    the scope for each expression includes only previous keyword arguments, in\n    left-to-right order ([#17240]).\n\n  * The parsing of `1<<2*3` as `1<<(2*3)` is deprecated, and will change to\n    `(1<<2)*3` in a future version ([#13079]).\n\n  * The parsing of `<|` is now right associative. `|>` remains left associative ([#24153]).\n\n  * `:` now parses like other operators, as a call to a function named `:`, instead of\n    calling `colon` ([#25947]).\n\n  * `{ }` expressions now use `braces` and `bracescat` as expression heads instead\n    of `cell1d` and `cell2d`, and parse similarly to `vect` and `vcat` ([#8470]).\n\n  * Nested `if` expressions that arise from the keyword `elseif` now use `elseif`\n    as their expression head instead of `if` ([#21774]).\n\n  * `let` blocks now parse the same as `for` loops; the first argument is either an\n    assignment or `block` of assignments, and the second argument is a block of\n    statements ([#21774]).\n\n  * `do` syntax now parses to an expression with head `:do`, instead of as a function\n    call ([#21774]).\n\n  * Parsed and lowered forms of type definitions have been synchronized with their\n    new keywords ([#23157]). Expression heads are renamed as follows:\n\n    + `type`           => `struct`\n\n    + `bitstype`       => `primitive` (order of arguments is also reversed, to match syntax)\n\n    + `composite_type` => `struct_type`\n\n    + `bits_type`      => `primitive_type`\n\n  * The `global` keyword now only introduces a new binding if one doesn't already exist\n    in the module.\n    This means that assignment to a global (`global sin = 3`) may now throw the error:\n    \"cannot assign variable Base.sin from module Main\", rather than emitting a warning.\n    Additionally, the new bindings are now created before the statement is executed.\n    For example, `f() = (global sin = \"gluttony\"; nothing)` will now resolve which module\n    contains `sin` eagerly, rather than delaying that decision until `f` is run. ([#22984]).\n\n  * `global const` declarations may no longer appear inside functions ([#12010]).\n\n  * Uninitialized `BitArray` constructors of the form `BitArray[{N}](shape...)` have been\n    deprecated in favor of equivalents accepting `undef` (an alias for\n    `UndefInitializer()`) as their first argument, as in\n    `BitArray[{N}](undef, shape...)`. For example, `BitVector(3)` is now\n    `BitVector(undef, 3)`, `BitMatrix((2, 4))` is now\n    `BitMatrix(undef, (2, 4))`, and `BitArray{3}(11, 13, 17)` is now\n    `BitArray{3}(undef, 11, 14, 17)` ([#24785]).\n\n  * Dispatch rules have been simplified:\n    method matching is now determined exclusively by subtyping;\n    the rule that method type parameters must also be captured has been removed.\n    Instead, attempting to access the unconstrained parameters will throw an `UndefVarError`.\n    Linting in package tests is recommended to confirm that the set of methods\n    which might throw `UndefVarError` when accessing the static parameters\n    (`need_to_handle_undef_sparam = Set{Any}(m.sig for m in Test.detect_unbound_args(Base, recursive=true))`)\n    is equal (`==`) to some known set (`expected = Set()`). ([#23117])\n\n  * `const` declarations on local variables were previously ignored. They now give a\n    warning, so that this syntax can be disallowed or given a new meaning in a\n    future version ([#5148]).\n\n  * Placing an expression after `catch`, as in `catch f(x)`, is deprecated.\n    Use `catch; f(x)` instead ([#19987]).\n\n  * In `for i = ...`, if a local variable `i` already existed it would be overwritten\n    during the loop. This behavior is deprecated, and in the future `for` loop variables\n    will always be new variables local to the loop ([#22314]).\n    The old behavior of overwriting an existing variable is available via `for outer i = ...`.\n\n  * In `for i in x`, `x` used to be evaluated in a new scope enclosing the `for` loop.\n    Now it is evaluated in the scope outside the `for` loop.\n\n  * In `for i in x, j in y`, all variables now have fresh bindings on each iteration of the\n    innermost loop. For example, an assignment to `i` will not be visible on the next `j`\n    loop iteration ([#330]).\n\n  * Variable bindings local to `while` loop bodies are now freshly allocated on each loop iteration,\n    matching the behavior of `for` loops.\n\n  * Prefix `&` for by-reference arguments to `ccall` has been deprecated in favor of\n    `Ref` argument types ([#6080]).\n\n  * The constructor `Ref(x::T)` now always returns a `Ref{T}` ([#21527]).\n\n  * All line numbers in ASTs are represented by `LineNumberNode`s; the `:line` expression\n    head is no longer used. `QuoteNode`s are also consistently used for quoted symbols instead\n    of the `:quote` expression head (though `:quote` `Expr`s are still used for quoted\n    expressions) ([#23885]).\n\n  * The `+` and `-` methods for `Number` and `UniformScaling` are not ambiguous anymore since `+`\n    and `-` no longer do automatic broadcasting. Hence, the methods for `UniformScaling` and `Number` are\n    no longer deprecated ([#23923]).\n\n  * The keyword `importall` is deprecated. Use `using` and/or individual `import` statements\n    instead ([#22789]).\n\n  * `reduce(+, [...])` and `reduce(*, [...])` no longer widen the iterated over arguments to\n    system word size. `sum` and `prod` still preserve this behavior. ([#22825])\n\n  * Like `_`, variable names consisting only of underscores can be assigned,\n    but accessing their values is deprecated ([#24221]).\n\n  * Raw string literal escaping rules have been changed to make it possible to write all strings.\n    The rule is that backslashes escape both quotes and other backslashes, but only when a sequence\n    of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n\n    backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n\n    backslashes followed by a quote character ([#22926]).\n\n  * `reprmime(mime, x)` has been renamed to `repr(mime, x)`, and along with `repr(x)`\n    and `sprint` it now accepts an optional `context` keyword for `IOContext` attributes.\n    `stringmime` has been moved to the Base64 stdlib package ([#25990]).\n\n  * The syntax `(x...)` for constructing a tuple is deprecated; use `(x...,)` instead ([#24452]).\n\n  * Non-parenthesized interpolated variables in strings, e.g. `\"$x\"`, must be followed\n    by a character that will never be an allowed identifier character (currently\n    operators, space/control characters, or common punctuation characters) ([#25231]).\n\n  * The syntax `using A.B` can now only be used when `A.B` is a module, and the syntax\n    `using A: B` can only be used for adding single bindings ([#8000]).\n\n  * `=>` now has its own precedence level, giving it strictly higher precedence than\n    `=` and `,` ([#25391]).\n\n  * The conditions under which unary operators followed by `(` are parsed as prefix function\n    calls have changed ([#26154]).\n\n  * `begin` is disallowed inside indexing expressions, in order to enable the syntax\n    `a[begin]` (for selecting the first element) in the future ([#23354]).\n\n  * Underscores for `_italics_` and `__bold__` are now supported by the Base Markdown\n    parser. ([#25564])\n\n  * `\u2026` (`\\dots`) and `\u205d` (`\\tricolon`) are now parsed as binary operators ([#26262]).\n\n  * Assignment syntax (`a=b`) inside square bracket expressions (e.g. `A[...]`, `[x, y]`)\n    is deprecated. It will likely be reclaimed in a later version for passing keyword\n    arguments. Note this does not affect updating operators like `+=` ([#25631]).\n\n  * `try` blocks without `catch` or `finally` are no longer allowed. An explicit empty\n    `catch` block should be written instead ([#27554]).\n\n  * `AbstractArray` types that use unconventional (not 1-based) indexing can now support\n    `size`, `length`, and `@inbounds`. To optionally enforce conventional indices,\n    you can `@assert !has_offset_axes(A)`.\n\n  * Module pre-compilation is now the default for code loading. Adding a\n    `__precompile__()` declaration is no longer necessary, although\n    `__precompile__(false)` can still be used to opt-out ([#26991]).\n\nBreaking changes\n----------------\n\nThis section lists changes that do not have deprecation warnings.\n\n  * The package manager `Pkg` has been replaced with a new one. See the manual entries on\n    \"Code Loading\" and \"Pkg\" for documentation.\n\n  * `replace(s::AbstractString, pat=>repl)` for function `repl` arguments formerly\n    passed a substring to `repl` in all cases.  It now passes substrings for\n    string patterns `pat`, but a `Char` for character patterns (when `pat` is a\n    `Char`, collection of `Char`, or a character predicate) ([#25815]).\n\n  * `readuntil` now does *not* include the delimiter in its result, matching the\n    behavior of `readline`. Pass `keep=true` to get the old behavior ([#25633]).\n\n  * `lu` methods now return decomposition objects such as `LU` rather than\n    tuples of arrays or tuples of numbers ([#26997], [#27159], [#27212]).\n\n  * `schur` methods now return decomposition objects such as `Schur` and\n    `GeneralizedSchur` rather than tuples of arrays ([#26997], [#27159], [#27212]).\n\n  * `lq` methods now return decomposition objects such as `LQ`\n    rather than tuples of arrays ([#26997], [#27159], [#27212]).\n\n  * `qr` methods now return decomposition objects such as `QR`, `QRPivoted`,\n    and `QRCompactWY` rather than tuples of arrays ([#26997], [#27159], [#27212]).\n\n  * `svd` methods now return decomposition objects such as `SVD` and\n    `GeneralizedSVD` rather than tuples of arrays or tuples of numbers ([#26997], [#27159], [#27212]).\n\n  * `countlines` now always counts the last non-empty line even if it does not\n    end with EOL, matching the behavior of `eachline` and `readlines` ([#25845]).\n\n  * `getindex(s::String, r::UnitRange{Int})` now throws `StringIndexError` if `last(r)`\n    is not a valid index into `s` ([#22572]).\n\n  * `ntuple(f, n::Integer)` throws `ArgumentError` if `n` is negative.\n    Previously an empty tuple was returned ([#21697]).\n\n  * `\u22ee`, `\u22f1`, `\u22f0`, and `\u22ef` are now parsed as binary operators, not ordinary\n    identifiers.  `\u2254`, `\u2255`, and `\u2a74` now parse with assignment rather than comparison\n    precedence ([#26262]).\n\n  * Juxtaposing string literals (e.g. `\"x\"y`) is now a syntax error ([#20575]).\n\n  * `finalizer(function, object)` now returns `object` rather than `nothing` ([#24679]).\n\n  * The constructor of `SubString` now checks if the requested view range\n    is defined by valid indices in the parent `AbstractString` ([#22511]).\n\n  * Macro calls with `for` expressions are now parsed as generators inside\n    function argument lists ([#18650]). Examples:\n\n    + `sum(@inbounds a[i] for i = 1:n)` used to give a syntax error, but is now\n      parsed as `sum(@inbounds(a[i]) for i = 1:n)`.\n\n    + `sum(@m x for i = 1:n end)` used to parse the argument to `sum` as a 2-argument\n      call to macro `@m`, but now parses it as a generator plus a syntax error\n      for the dangling `end`.\n\n  * `@__DIR__` returns the current working directory rather than `nothing` when not run\n    from a file ([#21759]).\n\n  * `@__FILE__` and `@__DIR__` return information relative to the file that it was parsed from,\n    rather than from the task-local `SOURCE_PATH` global when it was expanded.\n\n  * All macros receive an extra argument `__source__::LineNumberNode` which describes the\n    parser location in the source file for the `@` of the macro call.\n    It can be accessed as a normal argument variable in the body of the macro.\n    This is implemented by inserting an extra leading argument into the\n    `Expr(:macrocall, :@name, LineNumberNode(...), args...)`\n    surface syntax. ([#21746])\n\n  * Passing the same keyword argument multiple times is now a syntax error ([#16937]).\n\n  * `getsockname` on a `TCPSocket` now returns the locally bound address and port\n    of the socket. Previously the address of the remote endpoint was being\n    returned ([#21825]).\n\n  * The `~/.juliarc.jl` file has been moved to `~/.julia/config/startup.jl` and\n    `/etc/julia/juliarc.jl` file has been renamed to `/etc/julia/startup.jl` ([#26161]).\n\n  * Using `ARGS` within `startup.jl` files or within a .jl file loaded with `--load` will no\n    longer contain the script name as the first argument. Instead, the script name will be\n    assigned to `PROGRAM_FILE`. ([#22092])\n\n  * The format for a `ClusterManager` specifying the cookie on the command line is now\n    `--worker=<cookie>`. `--worker <cookie>` will not work as it is now an optional argument.\n\n  * The representation of `CartesianRange` has changed to a\n    tuple-of-AbstractUnitRanges; the `start` and `stop` fields are no\n    longer present. Use `first(R)` and `last(R)` to obtain\n    start/stop. ([#20974])\n\n  * The `Diagonal`, `Bidiagonal`, `Tridiagonal` and `SymTridiagonal` type definitions have\n    changed from `Diagonal{T}`, `Bidiagonal{T}`, `Tridiagonal{T}` and `SymTridiagonal{T}`\n    to `Diagonal{T,V<:AbstractVector{T}}`, `Bidiagonal{T,V<:AbstractVector{T}}`,\n    `Tridiagonal{T,V<:AbstractVector{T}}` and `SymTridiagonal{T,V<:AbstractVector{T}}`\n    respectively ([#22718], [#22925], [#23035], [#23154]).\n\n  * The immediate supertype of `BitArray` is now simply `AbstractArray`. `BitArray` is no longer\n    considered a subtype of `DenseArray` and `StridedArray` ([#25858]).\n\n  * When called with an argument that contains `NaN` elements, `findmin` and `findmax` now return the\n    first `NaN` found and its corresponding index. Previously, `NaN` elements were ignored.\n    The new behavior matches that of `min`, `max`, `minimum`, and `maximum`.\n\n  * `isapprox(x,y)` now tests `norm(x-y) <= max(atol, rtol*max(norm(x), norm(y)))`\n    rather than `norm(x-y) <= atol + ...`, and `rtol` defaults to zero\n    if an `atol > 0` is specified ([#22742]).\n\n  * Spaces are no longer allowed between `@` and the name of a macro in a macro call ([#22868]).\n\n  * Juxtaposition of a non-literal with a macro call (`x@macro`) is no longer valid syntax ([#22868]).\n\n  * On a cluster, all files are now loaded from the local file system rather than node 1 ([#22588]).\n    To load the same file everywhere from node 1, one possible alternative is to broadcast a call to `include_string`:\n    `@everywhere include_string(Main, $(read(\"filename\", String)), \"filename\")`.\n    Improving upon this API is left as an opportunity for packages.\n\n  * `randperm(n)` and `randcycle(n)` now always return a `Vector{Int}` (independent of\n    the type of `n`). Use the corresponding mutating functions `randperm!` and `randcycle!`\n    to control the array type ([#22723]).\n\n  * Hermitian now ignores any imaginary components in the diagonal instead of checking\n    the diagonal. ([#17367])\n\n  * Worker-worker connections are setup lazily for an `:all_to_all` topology. Use keyword\n    arg `lazy=false` to force all connections to be setup during a `addprocs` call. ([#22814])\n\n  * In `joinpath(a, b)` on Windows, if the drive specifications of `a` and `b` do not match,\n    `joinpath` now returns `b` instead of throwing an `ArgumentError`. `joinpath(path...)` is\n    defined to be left associative, so if any argument has a drive path which does not match\n    the drive of the join of the preceding paths, the prior ones are dropped. ([#20912])\n\n  * `^(A::AbstractMatrix{<:Integer}, p::Integer)` now throws a `DomainError`\n    if `p < 0`, unless `A == one(A)` or `A == -one(A)` (same as for\n    `^(A::Integer, p::Integer)`) ([#23366]).\n\n  * `^(A::AbstractMatrix{<:Integer}, p::Integer)` now promotes the element type in the same\n    way as `^(A::Integer, p::Integer)`. This means, for instance, that `[1 1; 0 1]^big(1)`\n    will return a `Matrix{BigInt}` instead of a `Matrix{Int}` ([#23366]).\n\n  * The element type of the input is now preserved in `unique`. Previously the element type\n    of the output was shrunk to fit the union of the type of each element in the input.\n    ([#22696])\n\n  * The `promote` function now raises an error if its arguments are of different types\n    and if attempting to convert them to a common type fails to change any of their types.\n    This avoids stack overflows in the common case of definitions like\n    `f(x, y) = f(promote(x, y)...)` ([#22801]).\n\n  * `indmin` and `indmax` have been renamed to `argmin` and `argmax`, respectively ([#25654]).\n\n  * `findmin`, `findmax`, `argmin`, and `argmax` used to always return linear indices.\n    They now return `CartesianIndex`es for all but 1-d arrays, and in general return\n    the `keys` of indexed collections (e.g. dictionaries) ([#22907]).\n\n  * The `openspecfun` library is no longer built and shipped with Julia, as it is no longer\n    used internally ([#22390]).\n\n  * All loaded packages used to have bindings in `Main` (e.g. `Main.Package`). This is no\n    longer the case; now bindings will only exist for packages brought into scope by\n    typing `using Package` or `import Package` ([#17997]).\n\n  * The rules for mixed-signedness integer arithmetic (e.g. `Int32(1) + UInt64(1)`) have been\n    simplified: if the arguments have different sizes (in bits), then the type of the larger\n    argument is used. If the arguments have the same size, the unsigned type is used ([#9292]).\n\n  * All command line arguments passed via `-e`, `-E`, and `-L` will be executed in the order\n    given on the command line ([#23665]).\n\n  * `I` now yields `UniformScaling{Bool}(true)` rather than `UniformScaling{Int64}(1)`\n    to better preserve types in operations involving `I` ([#24396]).\n\n  * The return type of `reinterpret` has changed to `ReinterpretArray`. `reinterpret` on sparse\n    arrays has been discontinued.\n\n  * `Base.find_in_path` is now `Base.find_package` or `Base.find_source_file` ([#24320]).\n\n  * `finalizer` now takes functions or pointers as its first argument, and the object being\n    finalized as its second (rather than the reverse). For the majority of use cases\n    deprecation warnings will be triggered. However, deprecation warnings will not trigger where\n    (1) the callable argument is not a subtype of `Function`; or (2) both arguments are\n    `Function`s or `Ptr{Cvoid}`s ([#24605]).\n\n  * The `kill` function now throws errors on user error (e.g. on permission\n    errors), but returns successfully if the process had previously exited.\n    Its return value has been removed. Use the `process_running` function\n    to determine if a process has already exited.\n\n  * The logging system has been redesigned - `info` and `warn` are deprecated\n    and replaced with the logging macros `@info`, `@warn`, `@debug` and\n    `@error`.  The `logging` function is also deprecated and replaced with\n    `AbstractLogger` and the functions from the new standard `Logging` library.\n    ([#24490])\n\n  * The `RevString` type has been removed from the language; `reverse(::String)` returns\n    a `String` with code points (or fragments thereof) in reverse order. In general,\n    `reverse(s)` should return a string of the same type and encoding as `s` with code\n    points in reverse order; any string type overrides `reverse` to return a different\n    type of string must also override `reverseind` to compute reversed indices correctly.\n\n  * `eachindex(A, B...)` now requires that all inputs have the same number of elements.\n    When the chosen indexing is Cartesian, they must have the same axes.\n\n  * `AbstractRange` objects are now considered as equal to other `AbstractArray` objects\n    by `==` and `isequal` if all of their elements are equal ([#16401]).\n    This has required changing the hashing algorithm: ranges now use an O(N) fallback\n    instead of a O(1) specialized method unless they define the `Base.RangeStepStyle`\n    trait; see its documentation for details. Types which support subtraction (operator\n    `-`) must now implement `widen` for hashing to work inside heterogeneous arrays.\n\n  * `findn(x::AbstractArray)` has been deprecated in favor of `findall(!iszero, x)`, which\n    now returns cartesian indices for multidimensional arrays (see below, [#25532]).\n\n  * Broadcasting operations are no longer fused into a single operation by Julia's parser.\n    Instead, a lazy `Broadcasted` object is created to represent the fused expression and\n    then realized with `copy(bc::Broadcasted)` or `copyto!(dest, bc::Broadcasted)`\n    to evaluate the wrapper. Consequently, package authors generally need to specialize\n    `copy` and `copyto!` methods rather than `broadcast` and `broadcast!`. This also allows\n    for more customization and control of fused broadcasts. See the\n    [Interfaces chapter](https://docs.julialang.org/en/v1/manual/interfaces/#man-interfaces-broadcasting-1)\n    for more information.\n\n  * `find` has been renamed to `findall`. `findall`, `findfirst`, `findlast`, `findnext`\n    now take and/or return the same type of indices as `keys`/`pairs` for `AbstractArray`,\n    `AbstractDict`, `AbstractString`, `Tuple` and `NamedTuple` objects ([#24774], [#25545]).\n    In particular, this means that they use `CartesianIndex` objects for matrices\n    and higher-dimensional arrays instead of linear indices as was previously the case.\n    Use `LinearIndices(a)[findall(f, a)]` and similar constructs to compute linear indices.\n\n  * The `find*` functions, i.e. `findnext`, `findprev`, `findfirst`,\n    and `findlast`, as well as `indexin`, now return `nothing` when no match is found rather\n    than `0` or `0:-1` ([#25472], [#25662], [#26149])\n\n  * The `Base.HasShape` iterator trait has gained a type parameter `N` indicating the\n    number of dimensions, which must correspond to the length of the tuple returned by\n    `size` ([#25655]).\n\n * `AbstractSet` objects are now considered equal by `==` and `isequal` if all of their\n    elements are equal ([#25368]). This has required changing the hashing algorithm\n    for `BitSet`.\n\n  * the default behavior of `titlecase` is changed in two ways ([#23393]):\n    + characters not starting a word are converted to lowercase;\n      a new keyword argument `strict` is added which\n      allows to get the old behavior when it's `false`.\n    + any non-letter character is considered as a word separator;\n      to get the old behavior (only \"space\" characters are considered as\n      word separators), use the keyword `wordsep=isspace`.\n\n  * `writedlm` in the standard library module DelimitedFiles now writes numeric values\n    using `print` rather than `print_shortest` ([#25745]).\n\n  * The `tempname` function used to create a file on Windows but not on other\n    platforms. It now never creates a file ([#9053]).\n\n  * The `fieldnames` and `propertynames` functions now return a tuple rather than\n    an array ([#25725]).\n\n  * `indexin` now returns the first rather than the last matching index ([#25998]).\n\n  * `parse(::Type, ::Char)` now uses a default base of 10, like other number parsing\n    methods, instead of 36 ([#26576]).\n\n  * `isequal` for `Ptr`s now compares element types; `==` still compares only addresses\n    ([#26858]).\n\n  * `widen` on 8- and 16-bit integer types now widens to 16- and 32-bit types, respectively. ([#28045]).\n\n  * `mv`,`cp`, `touch`, `mkdir`, `mkpath`, `chmod` and `chown` now return the path that was created/modified\n    rather than `nothing` ([#27071]).\n\n  * Regular expressions now default to UCP mode. Escape sequences such as `\\w`\n    will now match based on unicode character properties, e.g. `r\"\\w+\"` will\n    match `caf\u00e9` (not just `caf`). Add the `a` modifier (e.g. `r\"\\w+\"a`) to\n    restore the previous behavior ([#27189]).\n\n  * `@sync` now waits only for *lexically* enclosed (i.e. visible directly in the source\n    text of its argument) `@async` expressions. If you need to wait for a task created by\n    a called function `f`, have `f` return the task and put `@async wait(f(...))` within\n    the `@sync` block.\n    This change makes `@schedule` redundant with `@async`, so `@schedule` has been\n    deprecated ([#27164]).\n\n  * `norm(A::AbstractMatrix, p=2)` computes no longer the operator/matrix norm but the `norm` of `A`\n    as for other iterables, i.e. as if it were a vector. Especially, `norm(A::AbstractMatrix)` is the\n    Frobenius norm. To compute the operator/matrix norm, use the new function `opnorm` ([#27401]).\n\n  * `dot(u, v)` now acts recursively. Instead of `sum(u[i]' * v[i] for i in ...)`, it computes\n    `sum(dot(u[i], v[i]) for i in ...)`, similarly to `vecdot` before ([#27401]).\n\n  * `Sys.CPU_CORES` has been renamed to `Sys.CPU_THREADS`; it still gives the number\n    of \"logical cores\" (including hyperthreading) rather than the number of physical\n    cores present on the CPU. Similarly, the environment variable `JULIA_CPU_CORES` is\n    deprecated in favor of `JULIA_CPU_THREADS` ([#27856]).\n\n  * `WeakKeyDict` does not convert keys on insertion anymore (#24941).\n\nLibrary improvements\n--------------------\n\n  * The function `thisind(s::AbstractString, i::Integer)` returns the largest valid index\n    less or equal than `i` in the string `s` or `0` if no such index exists ([#24414]).\n\n  * Support for Unicode 11 ([#28266]).\n\n  * `Char` is now a subtype of `AbstractChar`, and most of the functions that\n    take character arguments now accept any `AbstractChar` ([#26286]).\n\n  * `pathof(module)` returns the path a module was imported from ([#28310]).\n\n  * `bytes2hex` now accepts an optional `io` argument to output to a hexadecimal stream\n    without allocating a `String` first ([#27121]).\n\n  * `String(array)` now accepts an arbitrary `AbstractVector{UInt8}`. For `Vector`\n    inputs, it \"steals\" the memory buffer, leaving them with an empty buffer which\n    is guaranteed not to be shared with the `String` object. For other types of vectors\n    (in particular immutable vectors), a copy is made and the input is not truncated ([#26093]).\n\n  * `Irrational` is now a subtype of `AbstractIrrational` ([#24245]).\n\n  * Introduced the `empty` function, the functional pair to `empty!` which returns a new,\n    empty container ([#24390]).\n\n  * Jump to first/last history entries in the REPL via \"Alt-<\" and \"Alt->\" ([#22829]).\n\n  * REPL LaTeX-like tab completions have been simplified for several Unicode characters,\n    e.g. `\ud835\udd38` is now `\\bbA` rather than `\\BbbA` ([#25980]).\n\n  * The function `chop` now accepts two arguments `head` and `tail` allowing to specify\n    number of characters to remove from the head and tail of the string ([#24126]).\n\n  * `get(io, :color, false)` can now be used to query whether a stream `io` supports\n    [ANSI color codes](https://en.wikipedia.org/wiki/ANSI_escape_code) ([#25067]),\n    rather than using the undocumented `Base.have_color` global flag.\n\n  * `print_with_color` has been deprecated in favor of\n    `printstyled([io], xs...; bold=false, color=:normal)` for printing styled text ([#25522]).\n\n  * Functions `first` and `last` now accept `nchar` argument for `AbstractString`.\n    If this argument is used they return a string consisting of first/last `nchar`\n    characters from the original string ([#23960]).\n\n  * Expressions `x^-n` where `n` is an *integer literal* now correspond to `inv(x)^n`.\n    For example, `x^-1` is now essentially a synonym for `inv(x)`, and works\n    in a type-stable way even if `typeof(x) != typeof(inv(x))` ([#24240]).\n\n  * New `Iterators.reverse(itr)` for reverse-order iteration ([#24187]).  Iterator\n    types `T` can implement `start` etc. for `Iterators.Reverse{T}` to support this.\n\n  * The functions `nextind` and `prevind` now accept `nchar` argument that indicates\n    the number of characters to move ([#23805]).\n\n  * The functions `strip`, `lstrip` and `rstrip` now return `SubString` ([#22496]).\n\n  * The functions `strwidth` and `charwidth` have been merged into `textwidth`([#20816]).\n\n  * The functions `base` and `digits` digits now accept a negative\n    base (like `ndigits` did) ([#21692]).\n\n  * The function `randn` now accepts complex arguments (`Complex{T <: AbstractFloat}`)\n    ([#21973]).\n\n  * `parse(Complex{T}, string)` can parse complex numbers in some common formats ([#24713]).\n\n  * The function `rand` can now pick up random elements from strings, associatives\n    and sets ([#22228], [#21960], [#18155], [#22224]).\n\n  * It's now possible to specify the characters to pick from in the `randstring` function ([#22222]).\n\n  * Allow multidimensional arrays in `shuffle` and `shuffle!` functions ([#22226]).\n\n  * Method lists are now printed as a numbered list. In addition, the source code of a\n    method can be opened in an editor by entering the corresponding number in the REPL\n    and pressing `^Q` ([#22007]).\n\n  * `getpeername` on a `TCPSocket` returns the address and port of the remote\n    endpoint of the TCP connection ([#21825]).\n\n  * `resize!` and `sizehint!` methods no longer over-reserve memory when the\n    requested array size is more than double of its current size ([#22038]).\n\n  * The `crc32c` function for CRC-32c checksums is now exported ([#22274]).\n\n  * `eye(::Type{Diagonal{T}}, m::Integer)` has been deprecated in favor of\n    `Diagonal{T}(I, m)` ([#24415]).\n\n  * The output of `versioninfo` is now controlled with keyword arguments ([#21974]).\n\n  * The function `LibGit2.set_remote_url` now always sets both the fetch and push URLs for a\n    git repo. Additionally, the argument order was changed to be consistent with the git\n    command line tool ([#22062]).\n\n  * Added `unique!` which is an inplace version of `unique` ([#20549]).\n\n  * `@test isequal(x, y)` and `@test isapprox(x, y)` now prints an evaluated expression when\n    the test fails ([#22296]).\n\n  * Uses of `Val{c}` in `Base` has been replaced with `Val{c}()`, which is now easily\n    accessible via the efficient constructor `Val(c)`. Functions are defined as\n    `f(::Val{c}) = ...` and called by `f(Val(c))`. Notable affected functions include:\n    `ntuple`, `Base.literal_pow`, `sqrtm`, `lufact`, `lufact!`, `qrfact`, `qrfact!`,\n    `cholfact`, `cholfact!`, `_broadcast!`, `reshape`, `cat` and `cat_t`.\n\n  * A new `@macroexpand1` macro for non recursive macro expansion ([#21662]).\n\n  * `Char`s can now be concatenated with `String`s and/or other `Char`s using `*` ([#22532]).\n\n  * `Diagonal`, `Bidiagonal`, `Tridiagonal` and `SymTridiagonal` are now parameterized on\n    the type of the wrapped vectors, allowing `Diagonal`, `Bidiagonal`, `Tridiagonal` and\n    `SymTridiagonal` matrices with arbitrary `AbstractVector`s\n    ([#22718], [#22925], [#23035], [#23154]).\n\n  * Mutating versions of `randperm` and `randcycle` have been added:\n    `randperm!` and `randcycle!` ([#22723]).\n\n  * `BigFloat` random numbers can now be generated ([#22720]).\n\n  * The efficiency of random generation for MersenneTwister RNGs has been improved for\n    integers, `Float64` and ranges; as a result, given a seed, the produced stream of numbers\n    has changed ([#27560], [#25277], [#25197], [#25058], [#25047]).\n\n  * REPL Undo via Ctrl-/ and Ctrl-_\n\n  * `diagm` now accepts several diagonal index/vector `Pair`s ([#24047]).\n\n  * `isequal`, `==`, and `in` have one argument \"curried\" forms. For example `isequal(x)`\n    returns a function that compares its argument to `x` using `isequal` ([#26436]).\n\n  * `reinterpret` now works on any AbstractArray using the new `ReinterpretArray` type.\n    This supersedes the old behavior of reinterpret on Arrays. As a result, reinterpreting\n    arrays with different alignment requirements (removed in 0.6) is once again allowed ([#23750]).\n\n  * The `keys` of an `Associative` are now an `AbstractSet`. `Base.KeyIterator{<:Associative}`\n    has been changed to `KeySet{K, <:Associative{K}} <: AbstractSet{K}` ([#24580]).\n\n  * New function `ncodeunits(s::AbstractString)` gives the number of code units in a string.\n    The generic definition is constant time but calls `lastindex(s)` which may be inefficient.\n    Therefore custom string types may want to define direct `ncodeunits` methods.\n\n  * `reverseind(s::AbstractString, i::Integer)` now has an efficient generic fallback, so\n    custom string types do not need to provide their own efficient definitions. The generic\n    definition relies on `ncodeunits` however, so for optimal performance you may need to\n    define a custom method for that function.\n\n  * The global RNG is being re-seeded with its own seed at the beginning of each `@testset`,\n    and have its original state restored at the end ([#24445]). This is breaking for testsets\n    relying implicitly on the global RNG being in a specific state.\n\n  * `permutedims(m::AbstractMatrix)` is now short for `permutedims(m, (2,1))`, and is now a\n    more convenient way of making a \"shallow transpose\" of a 2D array. This is the\n    recommended approach for manipulating arrays of data, rather than the recursively\n    defined, linear-algebra function `transpose`. Similarly,\n    `permutedims(v::AbstractVector)` will create a row matrix ([#24839]).\n\n  * A new `replace(A, old=>new)` function is introduced to replace `old` by `new` in\n    collection `A`. There is also another method with a different API, and\n    a mutating variant, `replace!` ([#22324], [#25697], [#26206], [#27944]).\n\n  * Adding integers to `CartesianIndex` objects is now deprecated. Instead of\n    `i::Int + x::CartesianIndex`, use `i*one(x) + x` ([#26284]).\n\n  * `CartesianRange` changes ([#24715]):\n    - Inherits from `AbstractArray`, and linear indexing can be used to provide\n      linear-to-cartesian conversion ([#24715])\n    - It has a new constructor taking an array\n\n  * several missing set-like operations have been added ([#23528]):\n    `union`, `intersect`, `symdiff`, `setdiff` are now implemented for\n    all collections with arbitrary many arguments, as well as the\n    mutating counterparts (`union!` etc.). The performance is also\n    much better in many cases. Note that this change is slightly\n    breaking: all the non-mutating functions always return a new\n    object even if only one argument is passed. Moreover the semantics\n    of `intersect` and `symdiff` is changed for vectors:\n    + `intersect` doesn't preserve the multiplicity anymore (use `filter` for\n      the old behavior)\n    + `symdiff` has been made consistent with the corresponding methods for\n      other containers, by taking the multiplicity of the arguments into account.\n      Use `unique` to get the old behavior.\n\n  * The `linearindices` function has been deprecated in favor of the new\n    `LinearIndices` type, which additionally provides conversion from\n    cartesian indices to linear indices using the normal indexing operation.\n    ([#24715], [#26775]).\n\n  * `IdDict{K,V}` replaces `ObjectIdDict`.  It has type parameters\n    like other `AbstractDict` subtypes and its constructors mirror the\n    ones of `Dict`. ([#25210])\n\n  * `IOBuffer` can take the `sizehint` keyword argument to suggest a capacity of\n    the buffer ([#25944]).\n\n  * `lstrip` and `rstrip` now accept a predicate function that defaults to `isspace`\n    ([#27309]).\n\n  * `trunc`, `floor`, `ceil`, and `round` specify `digits`, `sigdigits` and `base` using\n    keyword arguments. ([#26156], [#26670])\n\n  * `Sys.which()` provides a cross-platform method to find executable files, similar to\n    the Unix `which` command. ([#26559])\n\n  * Added an optimized method of `vecdot` for taking the Frobenius inner product\n    of sparse matrices. ([#27470])\n\n  * Added an optimized method of `kron` for taking the tensor product of two\n    `Diagonal` matrices. ([27581])\n\n  * An official API for extending `rand` is now defined ([#23964], [#25002]).\n\n  * The constructor `MersenneTwister()` is re-enabled, producing a randomly initialized RNG\n    (similar to `Random.seed!(MersenneTwister(0))`) ([#21909]).\n\n  * `BitSet` can now store any `Int` (instead of only positive ones) ([#25029]).\n\n  * The initial element `v0` in `reduce(op, v0, itr)` has been replaced with an `init`\n    optional keyword argument, as in `reduce(op, itr; init=v0)`. Similarly for `foldl`,\n    `foldr`, `mapreduce`, `mapfoldl`, `mapfoldr`, `accumulate` and `accumulate!`.\n    ([#27711], [#27859])\n\nCompiler/Runtime improvements\n-----------------------------\n\n  * The inlining heuristic now models the approximate runtime cost of\n    a method (using some strongly-simplifying assumptions). Functions\n    are inlined unless their estimated runtime cost substantially\n    exceeds the cost of setting up and issuing a subroutine\n    call. ([#22210], [#22732])\n\n  * Inference recursion-detection heuristics are now more precise,\n    allowing them to be triggered less often, but being more aggressive when they\n    are triggered to drive the inference computation to a solution ([#23912]).\n\n  * Inference now propagates constants inter-procedurally, and can compute\n    various constants expressions at compile-time ([#24362]).\n\n  * The LLVM SLP Vectorizer optimization pass is now enabled at the default\n    optimization level.\n\nDeprecated or removed\n---------------------\n\n  * The `JULIA_HOME` environment variable has been renamed to `JULIA_BINDIR` and\n    `Base.JULIA_HOME` has been moved to `Sys.BINDIR` ([#20899]).\n\n  * The keyword `immutable` is fully deprecated to `struct`, and\n    `type` is fully deprecated to `mutable struct` ([#19157], [#20418]).\n\n  * `lufact`, `schurfact`, `lqfact`, `qrfact`, `ldltfact`, `svdfact`,\n    `bkfact`, `hessfact`, `eigfact`, and `cholfact` have respectively been\n    deprecated to `lu`, `schur`, `lq`, `qr`, `ldlt`, `svd`, `bunchkaufman`,\n    `hessenberg`, `eigen`, and `cholesky` ([#26997], [#27159], [#27212]).\n\n  * `lufact!`, `schurfact!`, `lqfact!`, `qrfact!`, `ldltfact!`, `svdfact!`,\n    `bkfact!`, `hessfact!`, and `eigfact!` have respectively been deprecated to\n    `lu!`, `schur!`, `lq!`, `qr!`, `ldlt!`, `svd!`, `bunchkaufman!`,\n    `hessenberg!`, and `eigen!` ([#26997], [#27159], [#27212]).\n\n  * `eig(A[, args...])` has been deprecated in favor of `eigen(A[, args...])`.\n    Whereas the former returns a tuple of arrays, the latter returns an `Eigen` object.\n    So for a direct replacement, use `(eigen(A[, args...])...,)`. But going forward,\n    consider using the direct result of `eigen(A[, args...])` instead, either\n    destructured into its components (`vals, vecs = eigen(A[, args...])`) or\n    as an `Eigen` object (`X = eigen(A[, args...])`) ([#26997], [#27159], [#27212]).\n\n  * `eig(A::AbstractMatrix, B::AbstractMatrix)` and `eig(A::Number, B::Number)`\n    have been deprecated in favor of `eigen(A, B)`. Whereas the former each return\n    a tuple of arrays, the latter returns a `GeneralizedEigen` object. So for a direct\n    replacement, use `(eigen(A, B)...,)`. But going forward, consider using the\n    direct result of `eigen(A, B)` instead, either destructured into its components\n    (`vals, vecs = eigen(A, B)`), or as a `GeneralizedEigen` object\n    (`X = eigen(A, B)`) ([#26997], [#27159], [#27212]).\n\n  * `ordschur(T::StridedMatrix{Ty}, Z::StridedMatrix{Ty}, select::Union{Vector{Bool},BitVector})`\n    and `ordschur(S::StridedMatrix{Ty}, T::StridedMatrix{Ty}, Q::StridedMatrix{Ty},\n    Z::StridedMatrix{Ty}, select::Union{Vector{Bool},BitVector})` and their respective\n    inplace versions have been deprecated.\n    Use `ordschur(schur::Schur, select::Union{Vector{Bool},BitVector})` and\n    `ordschur(gschur::GeneralizedSchur, select::Union{Vector{Bool},BitVector})` instead\n    ([#28155]).\n\n  * Indexing into multidimensional arrays with more than one index but fewer indices than there are\n    dimensions is no longer permitted when those trailing dimensions have lengths greater than 1.\n    Instead, reshape the array or add trailing indices so the dimensionality and number of indices\n    match ([#14770], [#23628]).\n\n  * The use of a positional dimension argument has largely been deprecated in favor of a\n    `dims` keyword argument. This includes the functions `sum`, `prod`, `maximum`,\n    `minimum`, `all`, `any`, `findmax`, `findmin`, `mean`, `varm`, `std`, `var`, `cov`,\n    `cor`, `median`, `mapreducedim`, `reducedim`, `sort`, `accumulate`, `accumulate!`,\n    `cumsum`, `cumsum!`, `cumprod`, `cumprod!`, `flipdim`, `dropdims`, and `cat` ([#25501], [#26660], [#27100]).\n\n  * `indices(a)` and `indices(a,d)` have been deprecated in favor of `axes(a)` and\n    `axes(a, d)` ([#25057]).\n\n  * `EnvHash` has been renamed to `EnvDict` ([#24167]).\n\n  * Uninitialized `Array` constructors of the form\n    `Array[{T,N}](shape...)` have been deprecated in favor of equivalents\n    accepting `undef` (an alias for `UndefInitializer()`) as their first argument,\n    as in `Array[{T,N}](undef, shape...)`. For example,\n    `Vector(3)` is now `Vector(undef, 3)`, `Matrix{Int}((2, 4))` is now,\n    `Matrix{Int}(undef, (2, 4))`, and `Array{Float32,3}(11, 13, 17)` is now\n    `Array{Float32,3}(undef, 11, 13, 17)` ([#24781]).\n\n  * Previously `setindex!(A, x, I...)` (and the syntax `A[I...] = x`) supported two\n    different modes of operation when supplied with a set of non-scalar indices `I`\n    (e.g., at least one index is an `AbstractArray`) depending upon the value of `x`\n    on the right hand side. If `x` is an `AbstractArray`, its _contents_ are copied\n    elementwise into the locations in `A` selected by `I` and it must have the same\n    number of elements as `I` selects locations. Otherwise, if `x` is not an\n    `AbstractArray`, then its _value_ is implicitly broadcast to all locations to\n    all locations in `A` selected by `I`. This latter behavior\u2014implicitly broadcasting\n    \"scalar\"-like values across many locations\u2014is now deprecated in favor of explicitly\n    using the broadcasted assignment syntax `A[I...] .= x` or `fill!(view(A, I...), x)`\n    ([#26347]).\n\n  * `broadcast_getindex(A, I...)` and `broadcast_setindex!(A, v, I...)` are deprecated in\n    favor of `getindex.((A,), I...)` and `setindex!.((A,), v, I...)`, respectively ([#27075]).\n\n  * `LinAlg.fillslots!` has been renamed `LinAlg.fillstored!` ([#25030]).\n\n  * `fill!(A::Diagonal, x)` and `fill!(A::AbstractTriangular, x)` have been deprecated\n    in favor of `Base.LinAlg.fillstored!(A, x)` ([#24413]).\n\n  * `eye` has been deprecated in favor of `I` and `Matrix` constructors. Please see the\n    deprecation warnings for replacement details ([#24438]).\n\n  * `zeros(D::Diagonal[, opts...])` has been deprecated ([#24654]).\n\n  * Using Bool values directly as indices is now deprecated and will be an error in the future. Convert\n    them to `Int` before indexing if you intend to access index `1` for `true` and `0` for `false`.\n\n  * `slicedim(A, d, i)` has been deprecated in favor of `copy(selectdim(A, d, i))`. The new\n    `selectdim` function now always returns a view into `A`; in many cases the `copy` is\n    not necessary. Previously, `slicedim` on a vector `V` over dimension `d=1` and scalar\n    index `i` would return the just selected element (unless `V` was a `BitVector`). This\n    has now been made consistent: `selectdim` now always returns a view into the original\n    array, with a zero-dimensional view in this specific case ([#26009]).\n\n  * `whos` has been renamed `varinfo`, and now returns a markdown table instead of printing\n    output ([#12131]).\n\n  * Uninitialized `RowVector` constructors of the form `RowVector{T}(shape...)` have been\n    deprecated in favor of equivalents accepting `undef` (an alias for\n    `UndefInitializer()`) as their first argument, as in\n    `RowVector{T}(undef, shape...)`. For example, `RowVector{Int}(3)` is now\n    `RowVector{Int}(undef, 3)`, and `RowVector{Float32}((1, 4))` is now\n    `RowVector{Float32}(undef, (1, 4))` ([#24786]).\n\n  * `writecsv(io, a; opts...)` has been deprecated in favor of\n    `writedlm(io, a, ','; opts...)` ([#23529]).\n\n  * The method `srand(rng, filename, n=4)` has been deprecated ([#21359]).\n\n  * `readcsv(io[, T::Type]; opts...)` has been deprecated in favor of\n    `readdlm(io, ','[, T]; opts...)` ([#23530]).\n\n  * `sparse(s::UniformScaling, m::Integer)` has been deprecated in favor of the\n    three-argument equivalent `sparse(s::UniformScaling, m, n)` ([#24472]).\n\n  * The `cholfact`/`cholfact!` methods that accepted an `uplo` symbol have been deprecated\n    in favor of using `Hermitian` (or `Symmetric`) views ([#22187], [#22188]).\n\n  * The `thin` keyword argument for orthogonal decomposition methods has\n    been deprecated in favor of `full`, which has the opposite meaning:\n    `thin == true` if and only if `full == false` ([#24279]).\n\n  * `isposdef(A::AbstractMatrix, UL::Symbol)` and `isposdef!(A::AbstractMatrix, UL::Symbol)`\n    have been deprecated in favor of `isposdef(Hermitian(A, UL))` and `isposdef!(Hermitian(A, UL))`\n    respectively ([#22245]).\n\n  * The `bkfact`/`bkfact!` methods that accepted `uplo` and `issymmetric` symbols have been deprecated\n    in favor of using `Hermitian` (or `Symmetric`) views ([#22605]).\n\n  * The function `current_module` is deprecated and replaced with `@__MODULE__`.\n    This caused the deprecation of some reflection methods (such as `macroexpand` and\n    `isconst`), which now require a module argument. And it caused the bugfix of other\n    default arguments to use the Main module (including `whos`, `which`)  ([#22064]).\n\n  * `expand(ex)` and `expand(module, ex)` have been deprecated in favor of\n    `Meta.lower(module, ex)` ([#22064], [#24278]).\n\n  * `ones(A::AbstractArray[, opts...])` and `zeros(A::AbstractArray[, opts...])` methods\n    have been deprecated. For `zeros(A)`, consider `zero(A)`. For `ones(A)` or `zeros(A)`,\n    consider `ones(size(A))`, `zeros(size(A))`, `fill(v, size(A))` for `v` an appropriate\n    one or zero, `fill!(copy(A), {1|0})`, `fill!(similar(A), {1|0})`, or any of the preceding\n    with different element type and/or shape depending on `opts...`. Where strictly\n    necessary, consider `fill!(similar(A[, opts...]), {one(eltype(A)) | zero(eltype(A))})`.\n    For an algebraic multiplicative identity, consider `one(A)` ([#24656]).\n\n  * The `similar(dims->f(..., dims...), [T], axes...)` method to add offset array support\n    to a function `f` that would otherwise create a non-offset array has been deprecated.\n    Instead, call `f(..., axes...)` directly and, if needed, the offset array implementation\n    should add offset axis support to the function `f` directly ([#26733]).\n\n  * The functions `ones` and `zeros` used to accept any objects as dimensional arguments,\n    implicitly converting them to `Int`s.  This is now deprecated; only `Integer`s or\n    `AbstractUnitRange`s are accepted as arguments.  Instead, convert the arguments before\n    calling `ones` or `zeros` ([#26733]).\n\n  * The variadic `size(A, dim1, dim2, dims...)` method to return a tuple of multiple\n    dimension lengths of `A` has been deprecated ([#26862]).\n\n  * The `Operators` module is deprecated. Instead, import required operators explicitly\n    from `Base`, e.g. `import Base: +, -, *, /` ([#22251]).\n\n  * Bindings to the FFTW library have been removed from Base. The DFT framework for building FFT\n    implementations is now in AbstractFFTs.jl, the bindings to the FFTW library are in FFTW.jl,\n    and the Base signal processing functions which used FFTs are now in DSP.jl ([#21956]).\n\n  * The `corrected` positional argument to `cov` has been deprecated in favor of\n    a keyword argument with the same name ([#21709]).\n\n  * Omitting spaces around the `?` and the `:` tokens in a ternary expression has been deprecated.\n    Ternaries must now include some amount of whitespace, e.g. `x ? a : b` rather than\n    `x?a:b` ([#22523] and [#22712]).\n\n  * `?` can no longer be used as an identifier name ([#22712])\n\n  * The method `replace(s::AbstractString, pat, r, [count])` is deprecated\n    in favor of `replace(s::AbstractString, pat => r; [count])` ([#25165]).\n    Moreover, `count` cannot be negative anymore (use `typemax(Int)` instead ([#22325]).\n\n  * `read(io, type, dims)` is deprecated to `read!(io, Array{type}(undef, dims))` ([#21450]).\n\n  * `read(::IO, ::Ref)` is now a method of `read!`, since it mutates its `Ref` argument ([#21592]).\n\n  * `nb_available` is now `bytesavailable` ([#25634]).\n\n  * `skipchars(io::IO, predicate; linecomment=nothing)` is deprecated in favor of\n    `skipchars(predicate, io::IO; linecomment=nothing)` ([#25667]).\n\n  * `Bidiagonal` constructors now use a `Symbol` (`:U` or `:L`) for the upper/lower\n    argument, instead of a `Bool` or a `Char` ([#22703]).\n\n  * `Bidiagonal`, `Tridiagonal` and `SymTridiagonal` constructors that automatically\n    converted the input vectors to the same type are deprecated in favor of explicit\n    conversion ([#22925], [#23035], [#23154].\n\n  * Calling `nfields` on a type to find out how many fields its instances have is deprecated.\n    Use `fieldcount` instead. Use `nfields` only to get the number of fields in a specific object ([#22350]).\n\n  * `fieldnames` now operates only on types. To get the names of fields in an object, use\n    `fieldnames(typeof(x))` ([#22350]).\n\n  * `InexactError`, `DomainError`, and `OverflowError` now take\n    arguments. `InexactError(func::Symbol, type, -3)` now prints as\n    \"ERROR: InexactError: func(type, -3)\", `DomainError(val,\n    [msg])` prints as \"ERROR: DomainError with val:\\nmsg\",\n    and `OverflowError(msg)` prints as \"ERROR: OverflowError: msg\".\n    ([#20005], [#22751], [#22761])\n\n  * The operating system identification functions: `is_linux`, `is_bsd`, `is_apple`, `is_unix`,\n    and `is_windows`, have been deprecated in favor of `Sys.islinux`, `Sys.isbsd`, `Sys.isapple`,\n    `Sys.isunix`, and `Sys.iswindows`, respectively ([#22182]).\n\n  * The forms of `read`, `readstring`, and `eachline` that accepted both a `Cmd` object and an\n    input stream are deprecated. Use e.g. `read(pipeline(stdin, cmd))` instead ([#22762]).\n\n  * The unexported type `AbstractIOBuffer` has been renamed to `GenericIOBuffer` ([#17360] [#22796]).\n\n  * `IOBuffer(data::AbstractVector{UInt8}, read::Bool, write::Bool, maxsize::Integer)`,\n    `IOBuffer(read::Bool, write::Bool)`, and `IOBuffer(maxsize::Integer)` are\n    deprecated in favor of constructors taking keyword arguments ([#25872]).\n\n  * `Display` has been renamed to `AbstractDisplay` ([#24831]).\n\n  * Remaining vectorized methods over `SparseVector`s, particularly `floor`, `ceil`,\n    `trunc`, `round`, and most common transcendental functions such as `exp`, `log`, and\n    `sin` variants, have been deprecated in favor of dot-syntax ([#22961]).\n\n  * The method `String(io::IOBuffer)` is deprecated to `String(take!(copy(io)))` ([#21438]).\n\n  * The function `readstring` is deprecated in favor of `read(io, String)` ([#22793])\n\n  * The function `showall` is deprecated. Showing entire values is the default, unless an\n    `IOContext` specifying `:limit=>true` is in use ([#22847]).\n\n  * `issubtype` has been deprecated in favor of `<:` (which used to be an alias for `issubtype`).\n\n  * Calling `write` on non-isbits arrays is deprecated in favor of explicit loops or\n    `serialize` ([#6466]).\n\n  * The default `startup.jl` file on Windows has been removed. Now must explicitly include the\n    full path if you need access to executables or libraries in the `Sys.BINDIR` directory, e.g.\n    `joinpath(Sys.BINDIR, \"7z.exe\")` for `7z.exe` ([#21540]).\n\n  * `sqrtm` has been deprecated in favor of `sqrt` ([#23504]).\n\n  * `expm` has been deprecated in favor of `exp` ([#23233]).\n\n  * `logm` has been deprecated in favor of `log` ([#23505]).\n\n  * `full` has been deprecated in favor of more specific, better defined alternatives.\n    On structured matrices `A`, consider instead `Matrix(A)`, `Array(A)`,\n    `SparseMatrixCSC(A)`, or `sparse(A)`. On sparse arrays `S`, consider instead\n    `Vector(S)`, `Matrix(S)`, or `Array(S)` as appropriate. On factorizations `F`,\n    consider instead `Matrix(F)`, `Array(F)`, `AbstractMatrix(F)`, or `AbstractArray(F)`.\n    On implicit orthogonal factors `Q`, consider instead `Matrix(Q)` or `Array(Q)`; for\n    implicit orthogonal factors that can be recovered in square or truncated form,\n    see the deprecation message for square recovery instructions. On `Symmetric`,\n    `Hermitian`, or `AbstractTriangular` matrices `A`, consider instead `Matrix(S)`,\n    `Array(S)`, `SparseMatrixCSC(S)`, or `sparse(S)`. On `Symmetric` matrices `A`\n    particularly, consider instead `LinAlg.copytri!(copy(parent(A)), A.uplo)`. On\n    `Hermitian` matrices `A` particularly, consider instead\n    `LinAlg.copytri!(copy(parent(A)), A.uplo, true)`. On `UpperTriangular` matrices `A`\n    particularly, consider instead `triu!(copy(parent(A)))`. On `LowerTriangular` matrices\n    `A` particularly, consider instead `tril!(copy(parent(A)))` ([#24250]).\n\n  * `speye` has been deprecated in favor of `I`, `sparse`, and `SparseMatrixCSC`\n    constructor methods ([#24356]).\n\n  * Calling `union` with no arguments is deprecated; construct an empty set with an appropriate\n    element type using `Set{T}()` instead ([#23144]).\n\n  * Vectorized `DateTime`, `Date`, and `format` methods have been deprecated in favor of\n    dot-syntax ([#23207]).\n\n  * `Base.cpad` has been removed; use an appropriate combination of `rpad` and `lpad`\n    instead ([#23187]).\n\n  * `ctranspose` and `ctranspose!` have been deprecated in favor of `adjoint` and `adjoint!`,\n    respectively ([#23235]).\n\n  * `filter` and `filter!` on dictionaries now pass a single `key=>value` pair to the\n    argument function, instead of two arguments ([#17886]).\n\n  * `rol`, `rol!`, `ror`, and `ror!` have been deprecated in favor of specialized methods for\n    `circshift`/`circshift!` ([#23404]).\n\n  * `Base.SparseArrays.SpDiagIterator` has been removed ([#23261]).\n\n  * The function `cfunction`, has been deprecated in favor of a macro form `@cfunction`.\n    Most existing uses can be upgraded simply by adding a `@`.\n    The new syntax now additionally supports allocating closures at runtime,\n    for dealing with C APIs that don't provide a separate `void* env`-type callback\n    argument. ([#26486])\n\n  * `diagm(v::AbstractVector, k::Integer=0)` has been deprecated in favor of\n    `diagm(k => v)` ([#24047]).\n\n  * `diagm(x::Number)` has been deprecated in favor of `fill(x, 1, 1)` ([#24047]).\n\n  * `diagm(A::SparseMatrixCSC)` has been deprecated in favor of\n    `spdiagm(sparsevec(A))` ([#23341]).\n\n  * `diagm(A::BitMatrix)` has been deprecated, use `diagm(0 => vec(A))` or\n    `BitMatrix(Diagonal(vec(A)))` instead ([#23373], [#24047]).\n\n  * `\u212f` (written as `\\mscre<TAB>` or `\\euler<TAB>`) is now the only (by default) exported\n    name for Euler's number, and the type has changed from `Irrational{:e}` to\n    `Irrational{:\u212f}` ([#23427]).\n\n  * The mathematical constants `\u03c0`, `pi`, `\u212f`, `e`, `\u03b3`, `eulergamma`, `catalan`, `\u03c6` and\n    `golden` have been moved from `Base` to a new module; `Base.MathConstants`.\n    Only `\u03c0`, `pi` and `\u212f` are now exported by default from `Base` ([#23427]).\n\n  * `eu` (previously an alias for `\u212f`) has been deprecated in favor of `\u212f` (or `MathConstants.e`) ([#23427]).\n\n  * `GMP.gmp_version()`, `GMP.GMP_VERSION`, `GMP.gmp_bits_per_limb()`, and `GMP.GMP_BITS_PER_LIMB`\n    have been renamed to `GMP.version()`, `GMP.VERSION`, `GMP.bits_per_limb()`, and `GMP.BITS_PER_LIMB`,\n    respectively. Similarly, `MPFR.get_version()`, has been renamed to `MPFR.version()` ([#23323]). Also,\n    `LinAlg.LAPACK.laver()` has been renamed to `LinAlg.LAPACK.version()` and now returns a `VersionNumber`.\n\n  * `select`, `select!`, `selectperm` and `selectperm!` have been renamed respectively to\n    `partialsort`, `partialsort!`, `partialsortperm` and `partialsortperm!` ([#23051]).\n\n  * The `Range` abstract type has been renamed to `AbstractRange` ([#23570]).\n\n  * `map` on dictionaries previously operated on `key=>value` pairs. This behavior is deprecated,\n    and in the future `map` will operate only on values ([#5794]).\n\n  * `map` on sets previously returned a `Set`, possibly changing the order or number of elements. This\n    behavior is deprecated and in the future `map` will preserve order and number of elements ([#26980]).\n\n  * Previously, broadcast defaulted to treating its arguments as scalars if they were not\n    arrays. This behavior is deprecated, and in the future `broadcast` will default to\n    iterating over all its arguments. Wrap arguments you wish to be treated as scalars with\n    `Ref()` or a 1-tuple. Package developers can choose to allow a non-iterable type `T` to\n    always behave as a scalar by implementing `broadcastable(x::T) = Ref(x)` ([#26212]).\n\n  * Automatically broadcasted `+` and `-` for `array + scalar`, `scalar - array`, and so-on have\n    been deprecated due to inconsistency with linear algebra. Use `.+` and `.-` for these operations\n    instead ([#22880], [#22932]).\n\n  * `flipbits!(B)` is deprecated in favor of using in-place broadcast to negate each element:\n    `B .= .!B` ([#27067]).\n\n  * `isleaftype` is deprecated in favor of the simpler predicates `isconcretetype` and `isdispatchtuple`.\n    Concrete types are those that might equal `typeof(x)` for some `x`;\n    `isleaftype` included some types for which this is not true. Those are now categorized more precisely\n    as \"dispatch tuple types\" and \"!has_free_typevars\" (not exported). ([#17086], [#25496])\n\n  * `contains(eq, itr, item)` is deprecated in favor of `any` with a predicate ([#23716]).\n\n  * `spdiagm(x::AbstractVector)` has been deprecated in favor of `sparse(Diagonal(x))`\n    alternatively `spdiagm(0 => x)` ([#23757]).\n\n  * `spdiagm(x::AbstractVector, d::Integer)` and `spdiagm(x::Tuple{<:AbstractVector}, d::Tuple{<:Integer})`\n    have been deprecated in favor of `spdiagm(d => x)` and `spdiagm(d[1] => x[1], d[2] => x[2], ...)`\n    respectively. The new `spdiagm` implementation now always returns a square matrix ([#23757]).\n\n  * `spones(A::AbstractSparseArray)` has been deprecated in favor of\n    `LinAlg.fillstored!(copy(A), 1)` ([#25037]).\n\n  * Constructors for `LibGit2.UserPasswordCredentials` and `LibGit2.SSHCredentials` which take a\n    `prompt_if_incorrect` argument are deprecated. Instead, prompting behavior is controlled using\n    the `allow_prompt` keyword in the `LibGit2.CredentialPayload` constructor ([#23690]).\n\n  * `gradient` is deprecated and will be removed in the next release ([#23816]).\n\n  * The timing functions `tic`, `toc`, and `toq` are deprecated in favor of `@time` and `@elapsed`\n    ([#17046]).\n\n  * Methods of `findfirst`, `findnext`, `findlast`, and `findprev` that accept a value to\n    search for are deprecated in favor of passing a predicate ([#19186], [#10593]).\n\n  * `find` functions now operate only on booleans by default. To look for non-zeros, use\n    `x->x!=0` or `!iszero` ([#23120]).\n\n  * The ability of `reinterpret` to yield `Array`s of different type than the underlying storage\n    has been removed. The `reinterpret` function is still available, but now returns a\n    `ReinterpretArray`. The three argument form of `reinterpret` that implicitly reshapes\n    has been deprecated ([#23750]).\n\n  * `bits` has been deprecated in favor of `bitstring` ([#24281], [#24263]).\n\n  * `num2hex` and `hex2num` have been deprecated in favor of `reinterpret` combined with `parse`/`hex` ([#22088]).\n\n  * `copy!` is deprecated for `AbstractSet` and `AbstractDict`, with the intention to re-enable\n    it with a cleaner meaning in a future version ([#24844]).\n\n  * `copy!` (resp. `unsafe_copy!`) is deprecated for `AbstractArray` and is renamed `copyto!`\n    (resp. `unsafe_copyto!`); it will be re-introduced with a different meaning in a future\n    version ([#24808]).\n\n  * `a:b` is deprecated for constructing a `StepRange` when `a` and `b` have physical units\n    (Dates and Times). Use `a:s:b`, where `s = Dates.Day(1)` or `s = Dates.Second(1)`.\n\n  * `trues(A::AbstractArray)` and `falses(A::AbstractArray)` are deprecated in favor of\n    `trues(size(A))` and `falses(size(A))` respectively ([#24595]).\n\n  * `workspace` is discontinued, check out [Revise.jl](https://github.com/timholy/Revise.jl)\n    for an alternative workflow ([#25046]).\n\n  * `cumsum`, `cumprod`, `accumulate`, their mutating versions, and `diff` all now require a `dim`\n    argument instead of defaulting to using the first dimension unless there is only\n    one dimension ([#24684], [#25457]).\n\n  * The `sum_kbn` and `cumsum_kbn` functions have been moved to the\n    [KahanSummation](https://github.com/JuliaMath/KahanSummation.jl) package ([#24869]).\n\n  * `isnumber` has been renamed to `isnumeric` ([#25021]).\n\n  * `isalpha` has been renamed to `isletter` ([#26932]).\n\n  * `is_assigned_char` and `normalize_string` have been renamed to `isassigned` and\n    `normalize`, and moved to the new `Unicode` standard library module.\n    `graphemes` has also been moved to that module ([#25021]).\n\n  * Sparse array functionality has moved to the `SparseArrays` standard library module ([#25249]).\n\n  * Linear algebra functionality, and specifically the `LinAlg` module has moved to the\n    `LinearAlgebra` standard library module ([#25571]).\n\n  * `@printf` and `@sprintf` have been moved to the `Printf` standard library ([#23929],[#25056]).\n\n  * The `Libdl` module has moved to the `Libdl` standard library module ([#25459]).\n\n  * The aliases `Complex32`, `Complex64` and `Complex128` have been deprecated in favor of `ComplexF16`,\n    `ComplexF32` and `ComplexF64` respectively ([#24647]).\n\n  * `Base.parentindexes` and `SharedArrays.localindexes` have been renamed to `parentindices`\n    and `localindices`, respectively. Similarly, the `indexes` field in the `SubArray` type\n    has been renamed to `indices` without deprecation ([#25088]).\n\n  * `Associative` has been deprecated in favor of `AbstractDict` ([#25012]).\n\n  * `Void` has been renamed back to `Nothing` with an alias `Cvoid` for use when calling C\n    with a return type of `Cvoid` or a return or argument type of `Ptr{Cvoid}` ([#25162]).\n\n  * `Nullable{T}` has been deprecated and moved to the Nullables package ([#23642]). Use\n    `Union{T, Nothing}` instead, or `Union{Some{T}, Nothing}` if `nothing` is a possible\n    value (i.e. `Nothing <: T`). `isnull(x)` can be replaced with `x === nothing` and\n    `unsafe_get`/`get` can be dropped or replaced with `coalesce`.\n    `NullException` has been removed.\n\n  * `unshift!` and `shift!` have been renamed to `pushfirst!` and `popfirst!` ([#23902])\n\n  * `ipermute!` has been deprecated in favor of `invpermute!` ([#25168]).\n\n  * `CartesianRange` has been renamed `CartesianIndices` ([#24715]).\n\n  * `sub2ind` and `ind2sub` are deprecated in favor of using `CartesianIndices` and `LinearIndices` ([#24715]).\n\n  * `getindex(F::Factorization, s::Symbol)` (usually seen as e.g. `F[:Q]`) is deprecated\n    in favor of dot overloading (`getproperty`) so factors should now be accessed as e.g.\n    `F.Q` instead of `F[:Q]` ([#25184]).\n\n  * `search` and `rsearch` have been deprecated in favor of `findfirst`/`findnext` and\n    `findlast`/`findprev` respectively, in combination with curried `isequal` and `in`\n    predicates for some methods ([#24673]).\n\n  * `search(buf::IOBuffer, delim::UInt8)` has been deprecated in favor of either `occursin(delim, buf)`\n    (to test containment) or `readuntil(buf, delim)` (to read data up to `delim`) ([#26600]).\n\n  * `ismatch(regex, str)` has been deprecated in favor of `occursin(regex, str)` ([#26283]).\n\n  * `matchall` has been deprecated in favor of `collect(m.match for m in eachmatch(r, s))` ([#26071]).\n\n  * `similar(::Associative)` has been deprecated in favor of `empty(::Associative)`, and\n    `similar(::Associative, ::Pair{K, V})` has been deprecated in favour of\n    `empty(::Associative, K, V)` ([#24390]).\n\n  * `findin(a, b)` has been deprecated in favor of `findall(in(b), a)` ([#24673]).\n\n  * `module_name` has been deprecated in favor of a new, general `nameof` function. Similarly,\n    the unexported `Base.function_name` and `Base.datatype_name` have been deprecated in favor\n    of `nameof` methods ([#25622]).\n\n  * The module `Random.dSFMT` is renamed `Random.DSFMT` ([#25567]).\n\n  * `Random.RandomDevice(unlimited::Bool)` (on non-Windows systems) is deprecated in favor of\n    `Random.RandomDevice(; unlimited=unlimited)` ([#25668]).\n\n  * The generic implementations of `strides(::AbstractArray)` and `stride(::AbstractArray, ::Int)`\n     have been deprecated. Subtypes of `AbstractArray` that implement the newly introduced strided\n     array interface should define their own `strides` method ([#25321]).\n\n  * `module_parent`, `Base.datatype_module`, and `Base.function_module` have been deprecated\n    in favor of `parentmodule` ([#TODO]).\n\n  * `rand(t::Tuple{Vararg{Int}})` is deprecated in favor of `rand(Float64, t)` or `rand(t...)`;\n    `rand(::Tuple)` will have another meaning in the future ([#25429], [#25278]).\n\n  * `randjump`, which produced an array, is deprecated in favor of the\n    scalar version `Future.randjump` used with `accumulate` ([#27746]).\n\n  * The `assert` function (and `@assert` macro) have been documented that they are not guaranteed to run under various optimization levels and should therefore not be used to e.g. verify passwords.\n\n  * `ObjectIdDict` has been deprecated in favor of `IdDict{Any,Any}` ([#25210]).\n\n  * `gc` and `gc_enable` have been deprecated in favor of `GC.gc` and `GC.enable` ([#25616]).\n\n  * `Base.@gc_preserve` has been deprecated in favor of `GC.@preserve` ([#25616]).\n\n  * `print_shortest` has been discontinued, but is still available in the `Base.Grisu`\n    submodule ([#25745]).\n\n  * `scale!` has been deprecated in favor of `mul!`, `lmul!`, and `rmul!` ([#25701], [#25812]).\n\n  * The `remove_destination` keyword argument to `cp`, `mv`, and the unexported `cptree`\n    has been renamed to `force` ([#25979]).\n\n  * `contains` has been deprecated in favor of a more general `occursin` function, which\n    takes its arguments in reverse order from `contains` ([#26283]).\n\n  * `Regex` objects are no longer callable. Use `occursin` instead ([#26283]).\n\n  * The methods of `range` based on positional arguments have been deprecated in favor of\n    keyword arguments ([#25896]).\n\n  * `linspace` has been deprecated in favor of `range` with `stop` and `length` keyword\n    arguments ([#25896]).\n\n  * `LinSpace` has been renamed to `LinRange` ([#25896]).\n\n  * `logspace` has been deprecated to its definition ([#25896]).\n\n  * `endof(a)` has been renamed to `lastindex(a)`, and the `end` keyword in indexing expressions now\n    lowers to either `lastindex(a)` (in the case with only one index) or `lastindex(a, d)` (in cases\n    where there is more than one index and `end` appears at dimension `d`) ([#23554], [#25763]).\n\n  * `DateTime()`, `Date()`, and `Time()` have been deprecated, instead use `DateTime(1)`, `Date(1)`\n    and `Time(0)` respectively ([#23724]).\n\n  * The fallback method `^(x, p::Integer)` is deprecated. If your type relied on this definition,\n    add a method such as `^(x::MyType, p::Integer) = Base.power_by_squaring(x, p)` ([#23332]).\n\n  * `DevNull`, `STDIN`, `STDOUT`, and `STDERR` have been renamed to `devnull`, `stdin`, `stdout`,\n    and `stderr`, respectively ([#25786]).\n\n  * `wait` and `fetch` on `Task` now resemble the interface of `Future`.\n\n  * `showcompact(io, x...)` has been deprecated in favor of\n    `show(IOContext(io, :compact => true), x...)` ([#26080]).\n    Use `sprint(show, x..., context=:compact => true)` instead of `sprint(showcompact, x...)`.\n\n  * `isupper`, `islower`, `ucfirst` and `lcfirst` have been deprecated in favor of `isuppercase`,\n    `islowercase`, `uppercasefirst` and `lowercasefirst`, respectively ([#26442]).\n\n  * `signif` has been deprecated in favor of the `sigdigits` keyword argument to `round`.\n\n  * `Base.IntSet` has been deprecated in favor of `Base.BitSet` ([#24282]).\n\n  * `setrounding` has been deprecated for `Float32` and `Float64`, as the behaviour was too unreliable ([#26935]).\n\n  * `gamma`, `lgamma`, `beta`, `lbeta` and `lfact` have been moved to\n    [SpecialFunctions.jl](https://github.com/JuliaMath/SpecialFunctions.jl) ([#27459], [#27473]).\n\n  * `atan2` is now a 2-argument method of `atan` ([#27248]).\n\n  * The functions `eigs` and `svds` have been moved to the `Arpack.jl` package ([#27616]).\n\n  * `vecdot` and `vecnorm` are deprecated in favor of `dot` and `norm`, respectively ([#27401]).\n\n  * `clipboard` has been moved to the `InteractiveUtils` standard library package\n    (along with other utilities mostly used at the interactive prompt, such as `edit`\n    and `less`) ([#27635]).\n\n  * `ndigits(n, b, [pad])` is deprecated in favor of `ndigits(n, base=b, pad=pad)` ([#27908]).\n\n  * `squeeze` is deprecated in favor of `dropdims`.\n\n  * `srand` is deprecated in favor of the unexported `Random.seed!` ([#27726]).\n\n  * `realmin`/`realmax` are deprecated in favor of `floatmin`/`floatmax` ([#28302]).\n\n  * `sortrows`/`sortcols` have been deprecated in favor of the more general `sortslices`.\n\n  * `nextpow2`/`prevpow2` have been deprecated in favor of the more general `nextpow`/`prevpow` functions.\n\nCommand-line option changes\n---------------------------\n\n  * New option `--warn-overwrite={yes|no}` to control the warning for overwriting method\n    definitions. The default is `no` ([#23002]).\n\n  * New option `--banner={yes,no}` allows suppressing or forcing the printing of the\n    startup banner, overriding the default behavior (banner in REPL, no banner otherwise).\n    The `--quiet` option implies `--banner=no` even in REPL mode but can be overridden by\n    passing `--quiet` together with `--banner=yes` ([#23342]).\n\n  * The option `--precompiled` has been renamed to `--sysimage-native-code` ([#23054]).\n\n  * The option `--compilecache` has been renamed to `--compiled-modules` ([#23054]).\n\n<!--- generated by NEWS-update.jl: -->\n[#330]: https://github.com/JuliaLang/julia/issues/330\n[#1974]: https://github.com/JuliaLang/julia/issues/1974\n[#4916]: https://github.com/JuliaLang/julia/issues/4916\n[#5148]: https://github.com/JuliaLang/julia/issues/5148\n[#5794]: https://github.com/JuliaLang/julia/issues/5794\n[#6080]: https://github.com/JuliaLang/julia/issues/6080\n[#6466]: https://github.com/JuliaLang/julia/issues/6466\n[#6614]: https://github.com/JuliaLang/julia/issues/6614\n[#8000]: https://github.com/JuliaLang/julia/issues/8000\n[#8470]: https://github.com/JuliaLang/julia/issues/8470\n[#9053]: https://github.com/JuliaLang/julia/issues/9053\n[#9292]: https://github.com/JuliaLang/julia/issues/9292\n[#10593]: https://github.com/JuliaLang/julia/issues/10593\n[#11310]: https://github.com/JuliaLang/julia/issues/11310\n[#12010]: https://github.com/JuliaLang/julia/issues/12010\n[#12131]: https://github.com/JuliaLang/julia/issues/12131\n[#13079]: https://github.com/JuliaLang/julia/issues/13079\n[#14770]: https://github.com/JuliaLang/julia/issues/14770\n[#15120]: https://github.com/JuliaLang/julia/issues/15120\n[#16356]: https://github.com/JuliaLang/julia/issues/16356\n[#16401]: https://github.com/JuliaLang/julia/issues/16401\n[#16937]: https://github.com/JuliaLang/julia/issues/16937\n[#17046]: https://github.com/JuliaLang/julia/issues/17046\n[#17086]: https://github.com/JuliaLang/julia/issues/17086\n[#17240]: https://github.com/JuliaLang/julia/issues/17240\n[#17360]: https://github.com/JuliaLang/julia/issues/17360\n[#17367]: https://github.com/JuliaLang/julia/issues/17367\n[#17886]: https://github.com/JuliaLang/julia/issues/17886\n[#17997]: https://github.com/JuliaLang/julia/issues/17997\n[#18155]: https://github.com/JuliaLang/julia/issues/18155\n[#18650]: https://github.com/JuliaLang/julia/issues/18650\n[#19089]: https://github.com/JuliaLang/julia/issues/19089\n[#19157]: https://github.com/JuliaLang/julia/issues/19157\n[#19186]: https://github.com/JuliaLang/julia/issues/19186\n[#19987]: https://github.com/JuliaLang/julia/issues/19987\n[#20005]: https://github.com/JuliaLang/julia/issues/20005\n[#20418]: https://github.com/JuliaLang/julia/issues/20418\n[#20549]: https://github.com/JuliaLang/julia/issues/20549\n[#20575]: https://github.com/JuliaLang/julia/issues/20575\n[#20816]: https://github.com/JuliaLang/julia/issues/20816\n[#20899]: https://github.com/JuliaLang/julia/issues/20899\n[#20912]: https://github.com/JuliaLang/julia/issues/20912\n[#20974]: https://github.com/JuliaLang/julia/issues/20974\n[#21359]: https://github.com/JuliaLang/julia/issues/21359\n[#21438]: https://github.com/JuliaLang/julia/issues/21438\n[#21450]: https://github.com/JuliaLang/julia/issues/21450\n[#21527]: https://github.com/JuliaLang/julia/issues/21527\n[#21540]: https://github.com/JuliaLang/julia/issues/21540\n[#21592]: https://github.com/JuliaLang/julia/issues/21592\n[#21662]: https://github.com/JuliaLang/julia/issues/21662\n[#21692]: https://github.com/JuliaLang/julia/issues/21692\n[#21697]: https://github.com/JuliaLang/julia/issues/21697\n[#21709]: https://github.com/JuliaLang/julia/issues/21709\n[#21746]: https://github.com/JuliaLang/julia/issues/21746\n[#21759]: https://github.com/JuliaLang/julia/issues/21759\n[#21774]: https://github.com/JuliaLang/julia/issues/21774\n[#21825]: https://github.com/JuliaLang/julia/issues/21825\n[#21909]: https://github.com/JuliaLang/julia/issues/21909\n[#21956]: https://github.com/JuliaLang/julia/issues/21956\n[#21960]: https://github.com/JuliaLang/julia/issues/21960\n[#21973]: https://github.com/JuliaLang/julia/issues/21973\n[#21974]: https://github.com/JuliaLang/julia/issues/21974\n[#22007]: https://github.com/JuliaLang/julia/issues/22007\n[#22038]: https://github.com/JuliaLang/julia/issues/22038\n[#22062]: https://github.com/JuliaLang/julia/issues/22062\n[#22064]: https://github.com/JuliaLang/julia/issues/22064\n[#22088]: https://github.com/JuliaLang/julia/issues/22088\n[#22089]: https://github.com/JuliaLang/julia/issues/22089\n[#22092]: https://github.com/JuliaLang/julia/issues/22092\n[#22182]: https://github.com/JuliaLang/julia/issues/22182\n[#22187]: https://github.com/JuliaLang/julia/issues/22187\n[#22188]: https://github.com/JuliaLang/julia/issues/22188\n[#22194]: https://github.com/JuliaLang/julia/issues/22194\n[#22210]: https://github.com/JuliaLang/julia/issues/22210\n[#22222]: https://github.com/JuliaLang/julia/issues/22222\n[#22224]: https://github.com/JuliaLang/julia/issues/22224\n[#22226]: https://github.com/JuliaLang/julia/issues/22226\n[#22228]: https://github.com/JuliaLang/julia/issues/22228\n[#22245]: https://github.com/JuliaLang/julia/issues/22245\n[#22251]: https://github.com/JuliaLang/julia/issues/22251\n[#22274]: https://github.com/JuliaLang/julia/issues/22274\n[#22281]: https://github.com/JuliaLang/julia/issues/22281\n[#22296]: https://github.com/JuliaLang/julia/issues/22296\n[#22314]: https://github.com/JuliaLang/julia/issues/22314\n[#22324]: https://github.com/JuliaLang/julia/issues/22324\n[#22325]: https://github.com/JuliaLang/julia/issues/22325\n[#22350]: https://github.com/JuliaLang/julia/issues/22350\n[#22390]: https://github.com/JuliaLang/julia/issues/22390\n[#22496]: https://github.com/JuliaLang/julia/issues/22496\n[#22511]: https://github.com/JuliaLang/julia/issues/22511\n[#22523]: https://github.com/JuliaLang/julia/issues/22523\n[#22532]: https://github.com/JuliaLang/julia/issues/22532\n[#22572]: https://github.com/JuliaLang/julia/issues/22572\n[#22588]: https://github.com/JuliaLang/julia/issues/22588\n[#22605]: https://github.com/JuliaLang/julia/issues/22605\n[#22666]: https://github.com/JuliaLang/julia/issues/22666\n[#22696]: https://github.com/JuliaLang/julia/issues/22696\n[#22703]: https://github.com/JuliaLang/julia/issues/22703\n[#22712]: https://github.com/JuliaLang/julia/issues/22712\n[#22718]: https://github.com/JuliaLang/julia/issues/22718\n[#22720]: https://github.com/JuliaLang/julia/issues/22720\n[#22723]: https://github.com/JuliaLang/julia/issues/22723\n[#22732]: https://github.com/JuliaLang/julia/issues/22732\n[#22742]: https://github.com/JuliaLang/julia/issues/22742\n[#22751]: https://github.com/JuliaLang/julia/issues/22751\n[#22761]: https://github.com/JuliaLang/julia/issues/22761\n[#22762]: https://github.com/JuliaLang/julia/issues/22762\n[#22789]: https://github.com/JuliaLang/julia/issues/22789\n[#22793]: https://github.com/JuliaLang/julia/issues/22793\n[#22796]: https://github.com/JuliaLang/julia/issues/22796\n[#22800]: https://github.com/JuliaLang/julia/issues/22800\n[#22801]: https://github.com/JuliaLang/julia/issues/22801\n[#22814]: https://github.com/JuliaLang/julia/issues/22814\n[#22825]: https://github.com/JuliaLang/julia/issues/22825\n[#22829]: https://github.com/JuliaLang/julia/issues/22829\n[#22847]: https://github.com/JuliaLang/julia/issues/22847\n[#22868]: https://github.com/JuliaLang/julia/issues/22868\n[#22880]: https://github.com/JuliaLang/julia/issues/22880\n[#22907]: https://github.com/JuliaLang/julia/issues/22907\n[#22925]: https://github.com/JuliaLang/julia/issues/22925\n[#22926]: https://github.com/JuliaLang/julia/issues/22926\n[#22932]: https://github.com/JuliaLang/julia/issues/22932\n[#22961]: https://github.com/JuliaLang/julia/issues/22961\n[#22984]: https://github.com/JuliaLang/julia/issues/22984\n[#23002]: https://github.com/JuliaLang/julia/issues/23002\n[#23035]: https://github.com/JuliaLang/julia/issues/23035\n[#23051]: https://github.com/JuliaLang/julia/issues/23051\n[#23054]: https://github.com/JuliaLang/julia/issues/23054\n[#23117]: https://github.com/JuliaLang/julia/issues/23117\n[#23120]: https://github.com/JuliaLang/julia/issues/23120\n[#23144]: https://github.com/JuliaLang/julia/issues/23144\n[#23154]: https://github.com/JuliaLang/julia/issues/23154\n[#23157]: https://github.com/JuliaLang/julia/issues/23157\n[#23168]: https://github.com/JuliaLang/julia/issues/23168\n[#23187]: https://github.com/JuliaLang/julia/issues/23187\n[#23207]: https://github.com/JuliaLang/julia/issues/23207\n[#23233]: https://github.com/JuliaLang/julia/issues/23233\n[#23235]: https://github.com/JuliaLang/julia/issues/23235\n[#23261]: https://github.com/JuliaLang/julia/issues/23261\n[#23323]: https://github.com/JuliaLang/julia/issues/23323\n[#23332]: https://github.com/JuliaLang/julia/issues/23332\n[#23341]: https://github.com/JuliaLang/julia/issues/23341\n[#23342]: https://github.com/JuliaLang/julia/issues/23342\n[#23354]: https://github.com/JuliaLang/julia/issues/23354\n[#23366]: https://github.com/JuliaLang/julia/issues/23366\n[#23373]: https://github.com/JuliaLang/julia/issues/23373\n[#23393]: https://github.com/JuliaLang/julia/issues/23393\n[#23404]: https://github.com/JuliaLang/julia/issues/23404\n[#23427]: https://github.com/JuliaLang/julia/issues/23427\n[#23504]: https://github.com/JuliaLang/julia/issues/23504\n[#23505]: https://github.com/JuliaLang/julia/issues/23505\n[#23519]: https://github.com/JuliaLang/julia/issues/23519\n[#23528]: https://github.com/JuliaLang/julia/issues/23528\n[#23529]: https://github.com/JuliaLang/julia/issues/23529\n[#23530]: https://github.com/JuliaLang/julia/issues/23530\n[#23554]: https://github.com/JuliaLang/julia/issues/23554\n[#23570]: https://github.com/JuliaLang/julia/issues/23570\n[#23628]: https://github.com/JuliaLang/julia/issues/23628\n[#23642]: https://github.com/JuliaLang/julia/issues/23642\n[#23665]: https://github.com/JuliaLang/julia/issues/23665\n[#23690]: https://github.com/JuliaLang/julia/issues/23690\n[#23716]: https://github.com/JuliaLang/julia/issues/23716\n[#23724]: https://github.com/JuliaLang/julia/issues/23724\n[#23750]: https://github.com/JuliaLang/julia/issues/23750\n[#23757]: https://github.com/JuliaLang/julia/issues/23757\n[#23805]: https://github.com/JuliaLang/julia/issues/23805\n[#23816]: https://github.com/JuliaLang/julia/issues/23816\n[#23885]: https://github.com/JuliaLang/julia/issues/23885\n[#23902]: https://github.com/JuliaLang/julia/issues/23902\n[#23912]: https://github.com/JuliaLang/julia/issues/23912\n[#23923]: https://github.com/JuliaLang/julia/issues/23923\n[#23929]: https://github.com/JuliaLang/julia/issues/23929\n[#23960]: https://github.com/JuliaLang/julia/issues/23960\n[#23964]: https://github.com/JuliaLang/julia/issues/23964\n[#24047]: https://github.com/JuliaLang/julia/issues/24047\n[#24126]: https://github.com/JuliaLang/julia/issues/24126\n[#24153]: https://github.com/JuliaLang/julia/issues/24153\n[#24167]: https://github.com/JuliaLang/julia/issues/24167\n[#24187]: https://github.com/JuliaLang/julia/issues/24187\n[#24221]: https://github.com/JuliaLang/julia/issues/24221\n[#24240]: https://github.com/JuliaLang/julia/issues/24240\n[#24245]: https://github.com/JuliaLang/julia/issues/24245\n[#24250]: https://github.com/JuliaLang/julia/issues/24250\n[#24263]: https://github.com/JuliaLang/julia/issues/24263\n[#24278]: https://github.com/JuliaLang/julia/issues/24278\n[#24279]: https://github.com/JuliaLang/julia/issues/24279\n[#24281]: https://github.com/JuliaLang/julia/issues/24281\n[#24282]: https://github.com/JuliaLang/julia/issues/24282\n[#24320]: https://github.com/JuliaLang/julia/issues/24320\n[#24356]: https://github.com/JuliaLang/julia/issues/24356\n[#24362]: https://github.com/JuliaLang/julia/issues/24362\n[#24390]: https://github.com/JuliaLang/julia/issues/24390\n[#24396]: https://github.com/JuliaLang/julia/issues/24396\n[#24404]: https://github.com/JuliaLang/julia/issues/24404\n[#24413]: https://github.com/JuliaLang/julia/issues/24413\n[#24414]: https://github.com/JuliaLang/julia/issues/24414\n[#24415]: https://github.com/JuliaLang/julia/issues/24415\n[#24438]: https://github.com/JuliaLang/julia/issues/24438\n[#24445]: https://github.com/JuliaLang/julia/issues/24445\n[#24452]: https://github.com/JuliaLang/julia/issues/24452\n[#24472]: https://github.com/JuliaLang/julia/issues/24472\n[#24490]: https://github.com/JuliaLang/julia/issues/24490\n[#24580]: https://github.com/JuliaLang/julia/issues/24580\n[#24595]: https://github.com/JuliaLang/julia/issues/24595\n[#24605]: https://github.com/JuliaLang/julia/issues/24605\n[#24647]: https://github.com/JuliaLang/julia/issues/24647\n[#24653]: https://github.com/JuliaLang/julia/issues/24653\n[#24654]: https://github.com/JuliaLang/julia/issues/24654\n[#24656]: https://github.com/JuliaLang/julia/issues/24656\n[#24673]: https://github.com/JuliaLang/julia/issues/24673\n[#24679]: https://github.com/JuliaLang/julia/issues/24679\n[#24684]: https://github.com/JuliaLang/julia/issues/24684\n[#24713]: https://github.com/JuliaLang/julia/issues/24713\n[#24715]: https://github.com/JuliaLang/julia/issues/24715\n[#24774]: https://github.com/JuliaLang/julia/issues/24774\n[#24781]: https://github.com/JuliaLang/julia/issues/24781\n[#24785]: https://github.com/JuliaLang/julia/issues/24785\n[#24786]: https://github.com/JuliaLang/julia/issues/24786\n[#24808]: https://github.com/JuliaLang/julia/issues/24808\n[#24831]: https://github.com/JuliaLang/julia/issues/24831\n[#24839]: https://github.com/JuliaLang/julia/issues/24839\n[#24844]: https://github.com/JuliaLang/julia/issues/24844\n[#24869]: https://github.com/JuliaLang/julia/issues/24869\n[#25002]: https://github.com/JuliaLang/julia/issues/25002\n[#25012]: https://github.com/JuliaLang/julia/issues/25012\n[#25021]: https://github.com/JuliaLang/julia/issues/25021\n[#25029]: https://github.com/JuliaLang/julia/issues/25029\n[#25030]: https://github.com/JuliaLang/julia/issues/25030\n[#25037]: https://github.com/JuliaLang/julia/issues/25037\n[#25046]: https://github.com/JuliaLang/julia/issues/25046\n[#25047]: https://github.com/JuliaLang/julia/issues/25047\n[#25056]: https://github.com/JuliaLang/julia/issues/25056\n[#25057]: https://github.com/JuliaLang/julia/issues/25057\n[#25058]: https://github.com/JuliaLang/julia/issues/25058\n[#25067]: https://github.com/JuliaLang/julia/issues/25067\n[#25088]: https://github.com/JuliaLang/julia/issues/25088\n[#25162]: https://github.com/JuliaLang/julia/issues/25162\n[#25165]: https://github.com/JuliaLang/julia/issues/25165\n[#25168]: https://github.com/JuliaLang/julia/issues/25168\n[#25184]: https://github.com/JuliaLang/julia/issues/25184\n[#25197]: https://github.com/JuliaLang/julia/issues/25197\n[#25210]: https://github.com/JuliaLang/julia/issues/25210\n[#25231]: https://github.com/JuliaLang/julia/issues/25231\n[#25249]: https://github.com/JuliaLang/julia/issues/25249\n[#25277]: https://github.com/JuliaLang/julia/issues/25277\n[#25278]: https://github.com/JuliaLang/julia/issues/25278\n[#25311]: https://github.com/JuliaLang/julia/issues/25311\n[#25321]: https://github.com/JuliaLang/julia/issues/25321\n[#25368]: https://github.com/JuliaLang/julia/issues/25368\n[#25391]: https://github.com/JuliaLang/julia/issues/25391\n[#25424]: https://github.com/JuliaLang/julia/issues/25424\n[#25429]: https://github.com/JuliaLang/julia/issues/25429\n[#25457]: https://github.com/JuliaLang/julia/issues/25457\n[#25459]: https://github.com/JuliaLang/julia/issues/25459\n[#25472]: https://github.com/JuliaLang/julia/issues/25472\n[#25496]: https://github.com/JuliaLang/julia/issues/25496\n[#25501]: https://github.com/JuliaLang/julia/issues/25501\n[#25522]: https://github.com/JuliaLang/julia/issues/25522\n[#25532]: https://github.com/JuliaLang/julia/issues/25532\n[#25545]: https://github.com/JuliaLang/julia/issues/25545\n[#25564]: https://github.com/JuliaLang/julia/issues/25564\n[#25567]: https://github.com/JuliaLang/julia/issues/25567\n[#25571]: https://github.com/JuliaLang/julia/issues/25571\n[#25616]: https://github.com/JuliaLang/julia/issues/25616\n[#25622]: https://github.com/JuliaLang/julia/issues/25622\n[#25631]: https://github.com/JuliaLang/julia/issues/25631\n[#25633]: https://github.com/JuliaLang/julia/issues/25633\n[#25634]: https://github.com/JuliaLang/julia/issues/25634\n[#25654]: https://github.com/JuliaLang/julia/issues/25654\n[#25655]: https://github.com/JuliaLang/julia/issues/25655\n[#25662]: https://github.com/JuliaLang/julia/issues/25662\n[#25667]: https://github.com/JuliaLang/julia/issues/25667\n[#25668]: https://github.com/JuliaLang/julia/issues/25668\n[#25697]: https://github.com/JuliaLang/julia/issues/25697\n[#25701]: https://github.com/JuliaLang/julia/issues/25701\n[#25725]: https://github.com/JuliaLang/julia/issues/25725\n[#25745]: https://github.com/JuliaLang/julia/issues/25745\n[#25763]: https://github.com/JuliaLang/julia/issues/25763\n[#25786]: https://github.com/JuliaLang/julia/issues/25786\n[#25812]: https://github.com/JuliaLang/julia/issues/25812\n[#25815]: https://github.com/JuliaLang/julia/issues/25815\n[#25830]: https://github.com/JuliaLang/julia/issues/25830\n[#25845]: https://github.com/JuliaLang/julia/issues/25845\n[#25854]: https://github.com/JuliaLang/julia/issues/25854\n[#25858]: https://github.com/JuliaLang/julia/issues/25858\n[#25872]: https://github.com/JuliaLang/julia/issues/25872\n[#25896]: https://github.com/JuliaLang/julia/issues/25896\n[#25944]: https://github.com/JuliaLang/julia/issues/25944\n[#25947]: https://github.com/JuliaLang/julia/issues/25947\n[#25979]: https://github.com/JuliaLang/julia/issues/25979\n[#25980]: https://github.com/JuliaLang/julia/issues/25980\n[#25990]: https://github.com/JuliaLang/julia/issues/25990\n[#25998]: https://github.com/JuliaLang/julia/issues/25998\n[#26009]: https://github.com/JuliaLang/julia/issues/26009\n[#26071]: https://github.com/JuliaLang/julia/issues/26071\n[#26080]: https://github.com/JuliaLang/julia/issues/26080\n[#26093]: https://github.com/JuliaLang/julia/issues/26093\n[#26149]: https://github.com/JuliaLang/julia/issues/26149\n[#26154]: https://github.com/JuliaLang/julia/issues/26154\n[#26156]: https://github.com/JuliaLang/julia/issues/26156\n[#26161]: https://github.com/JuliaLang/julia/issues/26161\n[#26206]: https://github.com/JuliaLang/julia/issues/26206\n[#26212]: https://github.com/JuliaLang/julia/issues/26212\n[#26262]: https://github.com/JuliaLang/julia/issues/26262\n[#26283]: https://github.com/JuliaLang/julia/issues/26283\n[#26284]: https://github.com/JuliaLang/julia/issues/26284\n[#26286]: https://github.com/JuliaLang/julia/issues/26286\n[#26347]: https://github.com/JuliaLang/julia/issues/26347\n[#26436]: https://github.com/JuliaLang/julia/issues/26436\n[#26442]: https://github.com/JuliaLang/julia/issues/26442\n[#26486]: https://github.com/JuliaLang/julia/issues/26486\n[#26559]: https://github.com/JuliaLang/julia/issues/26559\n[#26576]: https://github.com/JuliaLang/julia/issues/26576\n[#26600]: https://github.com/JuliaLang/julia/issues/26600\n[#26660]: https://github.com/JuliaLang/julia/issues/26660\n[#26670]: https://github.com/JuliaLang/julia/issues/26670\n[#26733]: https://github.com/JuliaLang/julia/issues/26733\n[#26775]: https://github.com/JuliaLang/julia/issues/26775\n[#26858]: https://github.com/JuliaLang/julia/issues/26858\n[#26862]: https://github.com/JuliaLang/julia/issues/26862\n[#26932]: https://github.com/JuliaLang/julia/issues/26932\n[#26935]: https://github.com/JuliaLang/julia/issues/26935\n[#26980]: https://github.com/JuliaLang/julia/issues/26980\n[#26997]: https://github.com/JuliaLang/julia/issues/26997\n[#27067]: https://github.com/JuliaLang/julia/issues/27067\n[#27071]: https://github.com/JuliaLang/julia/issues/27071\n[#27075]: https://github.com/JuliaLang/julia/issues/27075\n[#27100]: https://github.com/JuliaLang/julia/issues/27100\n[#27121]: https://github.com/JuliaLang/julia/issues/27121\n[#27159]: https://github.com/JuliaLang/julia/issues/27159\n[#27164]: https://github.com/JuliaLang/julia/issues/27164\n[#27189]: https://github.com/JuliaLang/julia/issues/27189\n[#27212]: https://github.com/JuliaLang/julia/issues/27212\n[#27248]: https://github.com/JuliaLang/julia/issues/27248\n[#27309]: https://github.com/JuliaLang/julia/issues/27309\n[#27401]: https://github.com/JuliaLang/julia/issues/27401\n[#27447]: https://github.com/JuliaLang/julia/issues/27447\n[#27459]: https://github.com/JuliaLang/julia/issues/27459\n[#27470]: https://github.com/JuliaLang/julia/issues/27470\n[#27473]: https://github.com/JuliaLang/julia/issues/27473\n[#27554]: https://github.com/JuliaLang/julia/issues/27554\n[#27560]: https://github.com/JuliaLang/julia/issues/27560\n[#27616]: https://github.com/JuliaLang/julia/issues/27616\n[#27635]: https://github.com/JuliaLang/julia/issues/27635\n[#27641]: https://github.com/JuliaLang/julia/issues/27641\n[#27711]: https://github.com/JuliaLang/julia/issues/27711\n[#27726]: https://github.com/JuliaLang/julia/issues/27726\n[#27746]: https://github.com/JuliaLang/julia/issues/27746\n[#27856]: https://github.com/JuliaLang/julia/issues/27856\n[#27859]: https://github.com/JuliaLang/julia/issues/27859\n[#27908]: https://github.com/JuliaLang/julia/issues/27908\n[#27944]: https://github.com/JuliaLang/julia/issues/27944\n[#28045]: https://github.com/JuliaLang/julia/issues/28045\n[#28065]: https://github.com/JuliaLang/julia/issues/28065\n[#28155]: https://github.com/JuliaLang/julia/issues/28155\n[#28266]: https://github.com/JuliaLang/julia/issues/28266\n[#28302]: https://github.com/JuliaLang/julia/issues/28302\n\nJulia v0.6.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * New type system capabilities ([#8974], [#18457])\n\n    + Type parameter constraints can refer to previous parameters, e.g.\n      `type Foo{R<:Real, A<:AbstractArray{R}}`. Can also be used in method definitions.\n\n    + New syntax `Array{T} where T<:Integer`, indicating a union of types over all\n      specified values of `T` (represented by a `UnionAll` type). This provides behavior\n      similar to parametric methods or `typealias`, but can be used anywhere a type is\n      accepted. This syntax can also be used in method definitions, e.g.\n      `function inv(M::Matrix{T}) where T<:AbstractFloat`.\n      Anonymous functions can have type parameters via the syntax\n      `((x::Array{T}) where T<:Real) -> 2x`.\n\n    + Implicit type parameters, e.g. `Vector{<:Real}` is equivalent to\n      `Vector{T} where T<:Real`, and similarly for `Vector{>:Int}` ([#20414]).\n\n    + Much more accurate subtype and type intersection algorithms. Method sorting and\n      identification of equivalent and ambiguous methods are improved as a result.\n\nLanguage changes\n----------------\n\n  * \"Inner constructor\" syntax for parametric types is deprecated. For example,\n    in this definition:\n    ```\n    type Foo{T,S<:Real}\n        x\n        Foo(x) = new(x)\n    end\n    ```\n    the syntax `Foo(x) = new(x)` actually defined a constructor for `Foo{T,S}`,\n    i.e. the case where the type parameters are specified. For clarity, this\n    definition now must be written as `Foo{T,S}(x) where {T,S<:Real} = new(x)`\n    ([#11310], [#20308]).\n\n  * The keywords used to define types have changed ([#19157], [#20418]).\n\n    + `immutable` changes to `struct`\n\n    + `type` changes to `mutable struct`\n\n    + `abstract` changes to `abstract type ... end`\n\n    + `bitstype 32 Char` changes to `primitive type Char 32 end`\n\n    In 0.6, `immutable` and `type` are still allowed as synonyms without a deprecation\n    warning.\n\n  * Multi-line and single-line nonstandard command literals have been added. A\n    nonstandard command literal is like a nonstandard string literal, but the\n    syntax uses backquotes (``` ` ```) instead of double quotes, and the\n    resulting macro called is suffixed with `_cmd`. For instance, the syntax\n    ``` q`xyz` ``` is equivalent to `@q_cmd \"xyz\"` ([#18644]).\n\n  * Nonstandard string and command literals can now be qualified with their\n    module. For instance, `Base.r\"x\"` is now parsed as `Base.@r_str \"x\"`.\n    Previously, this syntax parsed as an implicit multiplication ([#18690]).\n\n  * For every binary operator `\u2a33`, `a .\u2a33 b` is now automatically equivalent to\n    the `broadcast` call `(\u2a33).(a, b)`.  Hence, one no longer defines methods\n    for `.*` etcetera.  This also means that \"dot operations\" automatically\n    fuse into a single loop, along with other dot calls `f.(x)` ([#17623]).\n    Similarly for unary operators ([#20249]).\n\n  * Newly defined methods are no longer callable from the same dynamic runtime\n    scope they were defined in ([#17057]).\n\n  * `isa` is now parsed as an infix operator with the same precedence as `in`\n    ([#19677]).\n\n  * `@.` is now parsed as `@__dot__`, and can be used to add dots to\n    every function call, operator, and assignment in an expression ([#20321]).\n\n  * The identifier `_` can be assigned, but accessing its value is deprecated,\n    allowing this syntax to be used in the future for discarding values ([#9343],\n    [#18251], [#20328]).\n\n  * The `typealias` keyword is deprecated, and should be replaced with\n    `Vector{T} = Array{T,1}` or a `const` assignment ([#20500]).\n\n  * Experimental feature: `x^n` for integer literals `n` (e.g. `x^3`\n    or `x^-3`) is now lowered to `Base.literal_pow(^, x, Val{n})`, to enable\n    compile-time specialization for literal integer exponents ([#20530], [#20889]).\n\nBreaking changes\n----------------\n\nThis section lists changes that do not have deprecation warnings.\n\n  * `readline`, `readlines` and `eachline` return lines without line endings by default.\n    You *must* use `readline(s, chomp=false)`, etc. to get the old behavior where\n    returned lines include trailing end-of-line character(s) ([#19944]).\n\n  * `String`s no longer have a `.data` field (as part of a significant performance\n    improvement). Use `Vector{UInt8}(str)` to access a string as a byte array.\n    However, allocating the `Vector` object has overhead. You can also use\n    `codeunit(str, i)` to access the `i`th byte of a `String`.\n    Use `sizeof(str)` instead of `length(str.data)`, and `pointer(str)` instead of\n    `pointer(str.data)` ([#19449]).\n\n  * Operations between `Float16` and `Integers` now return `Float16` instead of `Float32` ([#17261]).\n\n  * Keyword arguments are processed left-to-right: if the same keyword is specified more than\n    once, the rightmost occurrence takes precedence ([#17785]).\n\n  * The `lgamma(z)` function now uses a different (more standard) branch cut\n    for `real(z) < 0`, which differs from `log(gamma(z))` by multiples of 2\u03c0\n    in the imaginary part ([#18330]).\n\n  * `broadcast` now handles tuples, and treats any argument that is not a tuple\n    or an array as a \"scalar\" ([#16986]).\n\n  * `broadcast` now produces a `BitArray` instead of `Array{Bool}` for\n    functions yielding a boolean result.  If you want `Array{Bool}`, use\n    `broadcast!` or `.=` ([#17623]).\n\n  * Broadcast `A[I...] .= X` with entirely scalar indices `I` is deprecated as\n    its behavior will change in the future.  Use `A[I...] = X` instead.\n\n  * Operations like `.+` and `.*` on `Range` objects are now generic\n    `broadcast` calls (see [above](#language-changes)) and produce an `Array`.\n    If you want a `Range` result, use `+` and `*`, etcetera ([#17623]).\n\n  * `broadcast` now treats `Ref` (except for `Ptr`) arguments as 0-dimensional\n    arrays ([#18965]).\n\n  * `broadcast` now handles missing data (`Nullable`s) allowing operations to\n    be lifted over mixtures of `Nullable`s and scalars, as if the `Nullable`\n    were like an array with zero or one element ([#16961], [#19787]).\n\n  * The runtime now enforces when new method definitions can take effect ([#17057]).\n    The flip-side of this is that new method definitions should now reliably actually\n    take effect, and be called when evaluating new code ([#265]).\n\n  * The array-scalar methods of `/`, `\\`, `*`, `+`, and `-` now follow broadcast promotion\n    rules. (Likewise for the now-deprecated array-scalar methods of `div`, `mod`, `rem`,\n    `&`, `|`, and `xor`; see \"Deprecated or removed\" below.) ([#19692]).\n\n  * `broadcast!(f, A)` now calls `f()` for each element of `A`, rather than doing `fill!(A, f())` ([#19722]).\n\n  * `rmprocs` now throws an exception if requested workers have not been completely\n    removed before `waitfor` seconds. With a `waitfor=0`, `rmprocs` returns immediately\n    without waiting for worker exits.\n\n  * `quadgk` has been moved from Base into a separate package ([#19741]).\n\n  * The `Collections` module has been removed, and all functions defined therein have been\n    moved to the `DataStructures` package ([#19800]).\n\n  * The `RepString` type has been moved to the\n    [LegacyStrings.jl package](https://github.com/JuliaArchive/LegacyStrings.jl).\n\n  * In macro calls with parentheses, e.g. `@m(a=1)`, assignments are now parsed as\n    `=` expressions, instead of as `kw` expressions ([#7669]).\n\n  * When used as an infix operator, `~` is now parsed as a call to an ordinary operator\n    with assignment precedence, instead of as a macro call ([#20406]).\n\n  * (\u00b5 \"micro\" and \u025b \"latin epsilon\") are considered equivalent to\n    the corresponding Greek characters in identifiers.  `\\varepsilon`\n    now tab-completes to U+03B5 (greek small letter epsilon) ([#19464]).\n\n  * `retry` now inputs the keyword arguments `delays` and `check` instead of\n    `n` and `max_delay`.  The previous functionality can be achieved setting\n    `delays` to `ExponentialBackOff` ([#19331]).\n\n  * `transpose(::AbstractVector)` now always returns a `RowVector` view of the input (which is a\n     special 1\u00d7n-sized `AbstractMatrix`), not a `Matrix`, etc. In particular, for\n     `v::AbstractVector` we now have `(v.').' === v` and `v.' * v` is a scalar ([#19670]).\n\n  * Parametric types with \"unspecified\" parameters, such as `Array`, are now represented\n    as `UnionAll` types instead of `DataType`s ([#18457]).\n\n  * `Union` types have two fields, `a` and `b`, instead of a single `types` field.\n    The empty type `Union{}` is represented by a singleton of type `TypeofBottom` ([#18457]).\n\n  * The type `NTuple{N}` now refers to tuples where every element has the same type\n    (since it is shorthand for `NTuple{N,T} where T`). To get the old behavior of matching\n    any tuple, use `NTuple{N,Any}` ([#18457]).\n\n  * `FloatRange` has been replaced by `StepRangeLen`, and the internal\n    representation of `LinSpace` has changed. Aside from changes in\n    the internal field names, this leads to several differences in\n    behavior ([#18777]):\n\n    + Both `StepRangeLen` and `LinSpace` can represent ranges of\n      arbitrary object types---they are no longer limited to\n      floating-point numbers.\n\n    + For ranges that produce `Float64`, `Float32`, or `Float16`\n      numbers, `StepRangeLen` can be used to produce values with\n      little or no roundoff error due to internal arithmetic that is\n      typically twice the precision of the output result.\n\n    + To take advantage of this precision, `linspace(start, stop,\n      len)` now returns a range of type `StepRangeLen` rather than\n      `LinSpace` when `start` and `stop` are\n      `FloatNN`. `LinSpace(start, stop, len)` always returns a\n      `LinSpace`.\n\n    + `StepRangeLen(a, step, len)` constructs an ordinary-precision range\n      using the values and types of `a` and `step` as given, whereas\n      `range(a, step, len)` will attempt to match inputs `a::FloatNN`\n      and `step::FloatNN` to rationals and construct a `StepRangeLen`\n      that internally uses twice-precision arithmetic.  These two\n      outcomes exhibit differences in both precision and speed.\n\n  * `A=>B` expressions are now parsed as calls instead of using `=>` as the\n    expression head ([#20327]).\n\n  * The `count` function no longer sums non-boolean values ([#20404])\n\n  * The generic `getindex(::AbstractString, ::AbstractVector)` method's signature has been\n    tightened to `getindex(::AbstractString, ::AbstractVector{<:Integer})`. Consequently,\n    indexing into `AbstractString`s with non-`AbstractVector{<:Integer}` `AbstractVector`s\n    now throws a `MethodError` in the absence of an appropriate specialization.\n    (Previously such cases failed less explicitly with the exception of\n    `AbstractVector{Bool}`, which now throws an `ArgumentError` noting that\n    logical indexing into strings is not supported.)  ([#20248])\n\n  * Bessel, Hankel, Airy, error, Dawson, eta, zeta, digamma, inverse digamma,\n    trigamma, and polygamma special functions have been moved from Base to\n    the\n    [SpecialFunctions.jl package](https://github.com/JuliaMath/SpecialFunctions.jl)\n    ([#20427]).  Note that `airy`, `airyx` and `airyprime` have been deprecated\n    in favor of more specific functions (`airyai`, `airybi`, `airyaiprime`,\n    `airybiprimex`, `airyaix`, `airybix`, `airyaiprimex`, `airybiprimex`)\n    ([#18050]).\n\n  * When a macro is called in the module in which that macro is defined, global variables\n    in the macro are now correctly resolved in the macro definition environment. Breakage\n    from this change commonly manifests as undefined variable errors that do not occur\n    under 0.5. Fixing such breakage typically requires sprinkling additional `esc`s in\n    the offending macro ([#15850]).\n\n  * `write` on an `IOBuffer` now returns a signed integer in order to be\n    consistent with other buffers ([#20609]).\n\n  * The `<:Integer` division fallback `/(::Integer, ::Integer)`, which formerly\n    inappropriately took precedence over other division methods for some\n    mixed-integer-type division calls, has been removed ([#19779]).\n\n  * `@async`, `@spawn`, `@spawnat`, `@fetch` and `@fetchfrom` no longer implicitly\n    localize variables. Previously, the expression would be wrapped in an implicit\n    `let` block  ([#19594]).\n\n  * `parse` no longer accepts IPv4 addresses including leading zeros, octal, or hexadecimal.\n    Convert IPv4 addresses including octal or hexadecimal to decimal, and remove leading\n    zeros in decimal addresses ([#19811]).\n\n  * Closures shipped for remote execution via `@spawn` or `remotecall` now automatically\n    serialize globals defined under Main. For details, please refer to the paragraph\n    on \"Global variables\" under the \"Parallel computing\" chapter in the manual ([#19594]).\n\n  * `homedir` now determines the user's home directory via `libuv`'s `uv_os_homedir`,\n    rather than from environment variables ([#19636]).\n\n  * Workers now listen on an ephemeral port assigned by the OS. Previously workers would\n    listen on the first free port available from 9009 ([#21818]).\n\n\nLibrary improvements\n--------------------\n\n  * A new `@views` macro was added to convert a whole expression or block of code to\n    use views for all slices ([#20164]).\n\n  * `max`, `min`, and related functions (`minmax`, `maximum`, `minimum`, `extrema`)\n     now return `NaN` for `NaN` arguments ([#12563]).\n\n  * `oneunit(x)` function to return a dimensionful version of `one(x)`\n    (which is clarified to mean a dimensionless quantity if `x` is dimensionful) ([#20268]).\n\n  * The `chop` and `chomp` functions now return a `SubString` ([#18339]).\n\n  * Numbered stackframes printed in stacktraces can now be opened in an editor by\n    entering the corresponding number in the REPL and pressing `^Q` ([#19680]).\n\n  * The REPL now supports something called *prompt pasting* ([#17599]).\n    This activates when pasting text that starts with `julia>\u2007` into the REPL.\n    In that case, only expressions starting with `julia>\u2007` are parsed, the rest are removed.\n    This makes it possible to paste a chunk of code that has been copied from a REPL session\n    without having to scrub away prompts and outputs.\n    This can be disabled or enabled at will with `Base.REPL.enable_promptpaste(::Bool)`.\n\n  * The function `print_with_color` can now take a color\n    represented by an integer between 0 and 255 inclusive\n    as its first argument ([#18473]). For a number-to-color mapping, please refer to\n    [this chart](https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg).\n    It is also possible to use numbers as colors in environment variables that customizes colors in the REPL.\n    For example, to get orange warning messages, simply set `ENV[\"JULIA_WARN_COLOR\"] = 208`.\n    Please note that not all terminals support 256 colors.\n\n  * The function `print_with_color` no longer prints text in bold by default ([#18628]).\n    Instead, the function now take a keyword argument `bold::Bool`\n    which determines whether to print in bold or not. On some terminals, printing a color in non bold\n    results in slightly darker colors being printed than when printing in bold.\n    Therefore, light versions of the colors are now supported.\n    For the available colors see the help entry on `print_with_color`.\n\n  * The default text style for REPL input and answers has been changed from bold to normal ([#11250]).\n    They can be changed back to bold by setting the environment variables\n    `JULIA_INPUT_COLOR` and `JULIA_ANSWER_COLOR` to `\"bold\"`.\n    For example, one way of doing this is adding `ENV[\"JULIA_INPUT_COLOR\"] = :bold`\n    and `ENV[\"JULIA_ANSWER_COLOR\"] = :bold` to the `.juliarc.jl` file. See the\n    [manual section on customizing colors](https://docs.julialang.org/en/v1/stdlib/REPL/#Customizing-Colors-1)\n    for more information.\n\n  * The default color for info messages has been changed from blue to cyan\n    ([#18442]), and for warning messages from red to yellow ([#18453]).  This\n    can be changed back to the original colors by setting the environment\n    variables `JULIA_INFO_COLOR` to `\"blue\"` and `JULIA_WARN_COLOR` to `\"red\"`.\n\n  * Iteration utilities that wrap iterators and return other iterators (`enumerate`, `zip`, `rest`,\n    `countfrom`, `take`, `drop`, `cycle`, `repeated`, `product`, `flatten`, `partition`) have been\n    moved to the module `Base.Iterators` ([#18839]).\n\n  * BitArrays can now be constructed from arbitrary iterables, in particular from generator expressions,\n    e.g. `BitArray(isodd(x) for x = 1:100)` ([#19018]).\n\n  * `hcat`, `vcat`, and `hvcat` now work with `UniformScaling` objects, so\n    you can now do e.g. `[A I]` and it will concatenate an appropriately sized\n    identity matrix ([#19305]).\n\n  * New `accumulate` and `accumulate!` functions were added, which generalize `cumsum` and `cumprod`.\n    Also known as a [scan](https://en.wikipedia.org/wiki/Prefix_sum) operation ([#18931]).\n\n  * `reshape` now allows specifying one dimension with a `Colon()` (`:`) for the new shape, in which case\n    that dimension's length will be computed such that its product with all the other dimensions is equal\n    to the length of the original array ([#19919]).\n\n  * The new `to_indices` function provides a uniform interface for index conversions,\n    taking an array and a tuple of indices as arguments and returning a tuple of\n    integers and/or arrays of supported scalar indices. It will throw an `ArgumentError`\n    for any unsupported indices, and the returned arrays should be iterated over (and\n    not indexed into) to support more efficient logical indexing ([#19730]).\n\n    + Using colons (`:`) to represent a collection of indices is deprecated. They now must be\n      explicitly converted to a specialized array of integers with the `to_indices` function.\n   \u00a0 \u00a0As a result, the type of `SubArray`s that represent views over colon indices has changed.\n\n    + Logical indexing is now more efficient. Logical arrays are converted by `to_indices` to\n      a lazy, iterable collection of indices that doesn't support indexing. A deprecation\n      provides indexing support with O(n) lookup.\n\n    + The performance of indexing with `CartesianIndex`es is also improved in many situations.\n\n  * A new `titlecase` function was added, to capitalize the first character of each word within a string ([#19469]).\n\n  * `any` and `all` now always short-circuit, and `mapreduce` never short-circuits ([#19543]).\n    That is, not every member of the input iterable will be visited if a `true` (in the case of `any`) or\n    `false` (in the case of `all`) value is found, and `mapreduce` will visit all members of the iterable.\n\n  * Additional methods for `ones` and `zeros` functions were added\n    to support the same signature as the `similar` function ([#19635]).\n\n  * `count` now has a `count(itr)` method equivalent to `count(identity, itr)` ([#20403]).\n\n  * Methods for `map` and `filter` with `Nullable` arguments have been implemented;\n    the semantics are as if the `Nullable` were a container with zero or one elements ([#16961]).\n\n  * New `@test_warn` and `@test_nowarn` macros were added in the `Base.Test` module to\n    test for the presence or absence of warning messages ([#19903]).\n\n  * `logging` can now be used to redirect `info`, `warn`, and `error` messages\n    either universally or on a per-module/function basis ([#16213]).\n\n  * New function `Base.invokelatest(f, args...)` to call the latest version\n    of a function in circumstances where an older version may be called\n    instead (e.g. in a function calling `eval`) ([#19784]).\n\n  * A new `iszero(x)` function was added, to quickly check whether `x` is zero\n    (or is all zeros, for an array) ([#19950]).\n\n  * `notify` now returns a count of tasks woken up ([#19841]).\n\n  * A new nonstandard string literal `raw\"...\"` was added,\n    for creating strings with no interpolation or unescaping ([#19900]).\n\n  * A new `Dates.Time` type was added that supports representing the time of day\n    with up to nanosecond resolution ([#12274]).\n\n  * Raising one or negative one to a negative integer power formerly threw a `DomainError`.\n    One raised to any negative integer power now yields one, negative one raised to any\n    negative even integer power now yields one, and negative one raised to any negative\n    odd integer power now yields negative one. Similarly, raising `true` to any negative\n    integer power now yields `true` rather than throwing a `DomainError` ([#18342]).\n\n  * A new `@macroexpand` macro was added as a convenient alternative to the `macroexpand` function ([#18660]).\n\n  * `invoke` now supports keyword arguments ([#20345]).\n\n  * A new `ConjArray` type was added, as a wrapper type for lazy complex conjugation of arrays.\n    Currently, it is used by default for the new `RowVector` type only, and\n    enforces that both `transpose(vec)` and `ctranspose(vec)` are views not copies ([#20047]).\n\n  * `rem` now accepts a `RoundingMode` argument via `rem(x, y, r::RoundingMode)`, yielding\n    `x - y*round(x/y, r)` without intermediate rounding. In particular, `rem(x, y, RoundNearest)`\n    yields a value in the interval `[-abs(y)/2, abs(y)/2]`), which corresponds to the IEE754\n    `remainder` function. Similarly, `rem2pi(x, r::RoundingMode)` now exists as well, yielding\n    `rem(x, 2pi, r::RoundingMode)` but with greater accuracy ([#10946]).\n\n  * `map[!]` and `broadcast[!]` now have dedicated methods for sparse/structured\n    vectors/matrices. Specifically, `map[!]` and `broadcast[!]` over combinations including\n    one or more `SparseVector`, `SparseMatrixCSC`, `Diagonal`, `Bidiagonal`, `Tridiagonal`,\n    or `SymTridiagonal`, and any number of `broadcast` scalars, `Vector`s, or `Matrix`s,\n    now efficiently yield `SparseVector`s or `SparseMatrix`s as appropriate ([#19239],\n    [#19371], [#19518], [#19438], [#19690], [#19724], [#19926], [#19934], [#20009]).\n\n  * The operators `!` and `\u2218` (`\\circ<tab>` at the REPL and in most code editors) now\n    respectively perform predicate function negation and function composition. For example,\n    `map(!iszero, (0, 1))` is now equivalent to `map(x -> !iszero(x), (0, 1))` and\n    `map(uppercase \u2218 hex, 250:255)` is now equivalent to\n    `map(x -> uppercase(hex(x)), 250:255)` ([#17155]).\n\n  * `enumerate` now supports the two-argument form `enumerate(::IndexStyle, iterable)`.\n    This form allows specification of the returned indices' style. For example,\n    `enumerate(IndexLinear, iterable)` yields linear indices and\n    `enumerate(IndexCartesian, iterable)` yields cartesian indices ([#16378]).\n\nCompiler/Runtime improvements\n-----------------------------\n\n  * `ccall` is now implemented as a macro,\n    removing the need for special code-generator support for `Intrinsics` ([#18754]).\n\n  * `ccall` gained limited support for a `llvmcall` calling-convention.\n    This can replace many uses of `llvmcall` with a simpler, shorter declaration ([#18754]).\n\n  * All `Intrinsics` are now `Builtin` functions instead and have proper error checking\n    and fall-back static compilation support ([#18754]).\n\nDeprecated or removed\n---------------------\n\n  * `ipermutedims(A::AbstractArray, p)` has been deprecated in favor of\n    `permutedims(A, invperm(p))` ([#18891]).\n\n  * Linear indexing is now only supported when there is exactly one\n    non-cartesian index provided. Allowing a trailing index at dimension `d` to\n    linearly access the higher dimensions from array `A` (beyond `size(A, d)`)\n    has been deprecated as a stricter constraint during bounds checking.\n    Instead, `reshape` the array such that its dimensionality matches the\n    number of indices ([#20079]).\n\n  * `Multimedia.@textmime \"mime\"` has been deprecated. Instead define\n    `Multimedia.istextmime(::MIME\"mime\") = true` ([#18441]).\n\n  * `isdefined(a::Array, i::Int)` has been deprecated in favor of `isassigned` ([#18346]).\n\n  * The three-argument `SubArray` constructor (which accepts `dims::Tuple` as its third\n    argument) has been deprecated in favor of the two-argument equivalent (the\n    `dims::Tuple` argument being superfluous) ([#19259]).\n\n  * `is` has been deprecated in favor of `===` (which used to be an alias for `is`) ([#17758]).\n\n  * Ambiguous methods for addition and subtraction between `UniformScaling`s and `Number`s,\n    for example `(+)(J::UniformScaling, x::Number)`, have been deprecated in favor of\n    unambiguous, explicit equivalents, for example `J.\u03bb + x` ([#17607]).\n\n  * `num` and `den` have been deprecated in favor of `numerator` and `denominator` respectively ([#19233],[#19246]).\n\n  * `delete!(ENV::EnvDict, k::AbstractString, def)` has been deprecated in favor of\n    `pop!(ENV, k, def)`. Be aware that `pop!` returns `k` or `def`, whereas `delete!`\n    returns `ENV` or `def` ([#18012]).\n\n  * infix operator `$` has been deprecated in favor of infix `\u22bb` or function `xor` ([#18977]).\n\n  * The single-argument form of `write` (`write(x)`, with implicit `STDOUT` output stream),\n    has been deprecated in favor of the explicit equivalent `write(STDOUT, x)` ([#17654]).\n\n  * `Dates.recur` has been deprecated in favor of `filter` ([#19288])\n\n  * A number of ambiguous `convert` operations between `Number`s (especially `Real`s)\n    and `Date`, `DateTime`, and `Period` types have been deprecated in favor of\n    unambiguous `convert` and explicit constructor calls. Additionally, ambiguous colon\n    construction of `<:Period` ranges without step specification, for example\n    `Dates.Hour(1):Dates.Hour(2)`, has been deprecated in favor of such construction\n    including step specification, for example `Dates.Hour(1):Dates.Hour(1):Dates.Hour(2)`\n    ([#19920]).\n\n  * `cummin` and `cummax` have been deprecated in favor of `accumulate` ([#18931]).\n\n  * The `Array` constructor syntax `Array(T, dims...)` has been deprecated\n    in favor of the forms `Array{T,N}(dims...)` (where `N` is known, or\n    particularly `Vector{T}(dims...)` for `N = 1` and `Matrix{T}(dims...)` for `N = 2`),\n    and `Array{T}(dims...)` (where `N` is not known). Likewise for `SharedArray`s ([#19989]).\n\n  * `sumabs` and `sumabs2` have been deprecated in favor of `sum(abs, x)` and `sum(abs2, x)`, respectively.\n    `maxabs` and `minabs` have similarly been deprecated in favor of `maximum(abs, x)` and `minimum(abs, x)`.\n    Likewise for the in-place counterparts of these functions ([#19598]).\n\n  * The array-reducing form of `isinteger` (`isinteger(x::AbstractArray)`) has been\n    deprecated in favor of `all(isinteger, x)` ([#19925]).\n\n  * `produce`, `consume` and iteration over a Task object have been deprecated in favor of\n    using Channels for inter-task communication  ([#19841]).\n\n  * The `negate` keyword has been deprecated from all functions in the `Dates` adjuster\n    API (`adjust`, `tonext`, `toprev`, `Date`, `Time`, and `DateTime`). Instead use\n    predicate function negation via the `!` operator\n    (see [Library Improvements](#library-improvements)) ([#20213]).\n\n  * `@test_approx_eq x y` has been deprecated in favor of `@test isapprox(x,y)` or `@test x \u2248 y` ([#4615]).\n\n  * `Matrix()` and `Matrix{T}()` have been deprecated in favor of the explicit forms\n    `Matrix(0, 0)` and `Matrix{T}(0, 0)` ([#20330]).\n\n  * Vectorized functions have been deprecated in favor of dot syntax ([#17302], [#17265],\n    [#18558], [#19711], [#19712], [#19791], [#19802], [#19931], [#20543], [#20228]).\n\n  *  All methods of character predicates (`isalnum`, `isalpha`, `iscntrl`, `isdigit`,\n     `isnumber`, `isgraph`, `islower`, `isprint`, `ispunct`, `isspace`, `isupper`,\n     `isxdigit`) that accept `AbstractStrings` have been deprecated in favor of `all`.\n     For example, `isnumber(\"123\")` should now be expressed `all(isnumber, \"123\")`\n     ([#20342]).\n\n  * A few names related to indexing traits have been changed: `LinearIndexing` and\n    `linearindexing` have been deprecated in favor of `IndexStyle`. `LinearFast` has\n    been deprecated in favor of `IndexLinear`, and `LinearSlow` has been deprecated in\n    favor of `IndexCartesian` ([#16378]).\n\n  * The two-argument forms of `map` (`map!(f, A)`) and `asyncmap!` (`asyncmap!(f, A)`)\n    have been deprecated in anticipation of future semantic changes ([#19721]).\n\n  * `unsafe_wrap(String, ...)` has been deprecated in favor of `unsafe_string` ([#19449]).\n\n  * `zeros` and `ones` methods accepting an element type as the first argument and an\n    array as the second argument, for example `zeros(Float64, [1, 2, 3])`, have been\n    deprecated in favor of equivalent methods with the second argument instead the\n    size of the array, for example `zeros(Float64, size([1, 2, 3]))` ([#21183]).\n\n  * `Base.promote_eltype_op` has been deprecated ([#19669], [#19814], [#19937]).\n\n  * `isimag` has been deprecated ([#19949]).\n\n  * The tuple-of-types form of `invoke`, `invoke(f, (types...), ...)`, has been deprecated\n    in favor of the tuple-type form `invoke(f, Tuple{types...}, ...)` ([#18444]).\n\n  * `Base._promote_array_type` has been deprecated ([#19766]).\n\n  * `broadcast_zpreserving` has been deprecated ([#19533], [#19720]).\n\n  * Methods allowing indexing of tuples by `AbstractArray`s with more than one dimension\n    have been deprecated. (Indexing a tuple by such a higher-dimensional `AbstractArray`\n    should yield a tuple with more than one dimension, but tuples are one-dimensional.)\n    ([#19737]).\n\n  * `@test_approx_eq a b` has been deprecated in favor of `@test a \u2248 b` (or,\n    equivalently, `@test \u2248(a, b)` or `@test isapprox(a, b)`).\n    `@test_approx_eq_eps` has been deprecated in favor of new `@test` syntax:\n    `@test` now supports the syntax `@test f(args...) key=val ...` for\n    `@test f(args..., key=val...)`. This syntax allows, for example, writing\n    `@test a \u2248 b atol=c` in place of `@test \u2248(a, b, atol=c)` (and hence\n    `@test_approx_eq_eps a b c`) ([#19901]).\n\n  * `takebuf_array` has been deprecated in favor of `take!`, and `takebuf_string(x)`\n    has been deprecated in favor of `String(take!(x))` ([#19088]).\n\n  * `convert` methods from `Diagonal` and `Bidiagonal` to subtypes of\n    `AbstractTriangular` have been deprecated ([#17723]).\n\n  * `Base.LinAlg.arithtype` has been deprecated. If you were using `arithtype` within a\n    `promote_op` call, instead use `promote_op(Base.LinAlg.matprod, Ts...)`. Otherwise,\n    consider defining equivalent functionality locally ([#18218]).\n\n  * Special characters (`#{}()[]<>|&*?~;`) should now be quoted in commands. For example,\n    ``` `export FOO=1\\;` ``` should replace ``` `export FOO=1;` ``` and\n    ``` `cd $dir '&&' $thingie` ``` should replace ``` `cd $dir && $thingie` ``` ([#19786]).\n\n  * Zero-argument `Channel` constructors (`Channel()`, `Channel{T}()`) have been deprecated\n    in favor of equivalents accepting an explicit `Channel` size\n    (`Channel(2)`, `Channel{T}(2)`) ([#18832]).\n\n  * The zero-argument constructor `MersenneTwister()` has been\n    deprecated in favor of the explicit `MersenneTwister(0)` ([#16984]).\n\n  * `Base.promote_type(op::Type, Ts::Type...)` has been removed as part of an overhaul\n    of `broadcast`'s promotion mechanism. If you need the functionality of that\n    `Base.promote_type` method, consider defining it locally via\n    `Core.Compiler.return_type(op, Tuple{Ts...})` ([#18642]).\n\n  * `bitbroadcast` has been deprecated in favor of `broadcast`, which now produces a\n    `BitArray` instead of `Array{Bool}` for functions yielding a boolean result ([#19771]).\n\n  * To complete the deprecation of histogram-related functions, `midpoints` has been\n    deprecated. Instead use the\n    [StatsBase.jl package](https://github.com/JuliaStats/StatsBase.jl)'s\n    `midpoints` function ([#20058]).\n\n  * Passing a type argument to `LibGit2.cat` has been deprecated in favor of a simpler,\n    two-argument method for `LibGit2.cat` ([#20435]).\n\n  * The `LibGit2.owner` function for finding the repository which owns a given Git object\n    has been deprecated in favor of `LibGit2.repository` ([#20135]).\n\n  * The `LibGit2.GitAnyObject` type has been renamed to `LibGit2.GitUnknownObject` to\n    clarify its intent ([#19935]).\n\n  * The `LibGit2.GitOid` type has been renamed to `LibGit2.GitHash` for clarity ([#19878]).\n\n  * Finalizing `LibGit2` objects with `finalize` has been deprecated in favor of using `close`\n    ([#19660]).\n\n  * Parsing string dates from a `Dates.DateFormat` object has been deprecated as part of a\n    larger effort toward faster, more extensible date parsing ([#20952]).\n\nCommand-line option changes\n---------------------------\n\n  * In `polly` builds (`USE_POLLY := 1`), the new flag `--polly={yes|no}` controls whether\n    `@polly` declarations are respected. (With `--polly=no`, `@polly` declarations are\n    ignored.) This flag is also available in non-`polly` builds (`USE_POLLY := 0`),\n    but has no effect ([#18159]).\n\nJulia v0.5.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Generator expressions: `f(i) for i in 1:n` ([#4470]). This returns an iterator\n    that computes the specified values on demand. This is useful for computing, e.g.\n    `sum(f(i) for i in 1:n)` without creating an intermediate array of values.\n\n  * Generators and comprehensions support filtering using `if` ([#550]) and nested\n    iteration using multiple `for` keywords ([#4867]).\n\n  * Fused broadcasting syntax: ``f.(args...)`` is equivalent to ``broadcast(f, args...)`` ([#15032]),\n    and nested `f.(g.(args...))` calls are fused into a single `broadcast` loop ([#17300]).\n    Similarly, the syntax `x .= ...` is equivalent to a `broadcast!(identity, x, ...)`\n    call and fuses with nested \"dot\" calls; also, `x .+= y` and similar is now\n    equivalent to `x .= x .+ y`, rather than `x = x .+ y` ([#17510]).\n\n  * Macro expander functions are now generic, so macros can have multiple definitions\n    (e.g. for different numbers of arguments, or optional arguments) ([#8846], [#9627]).\n    However note that the argument types refer to the syntax tree representation, and not\n    to the types of run time values.\n\n  * Varargs functions like `foo{T}(x::T...)` may now restrict the number\n    of such arguments using `foo{T,N}(x::Vararg{T,N})` ([#11242]).\n\n  * `x \u2208 X` is now a synonym for `x in X` in `for` loops and comprehensions,\n    as it already was in comparisons ([#13824]).\n\n  * The `PROGRAM_FILE` global is now available for determining the name of the running script ([#14114]).\n\n  * The syntax `x.:sym` (e.g. `Base.:+`) is now supported, while using `x.(:sym)`\n    or `x.(i)` for field access are deprecated in favor of `getfield` ([#15032]).\n\n  * Function return type syntax `function f()::T` has been added ([#1090]). Values returned\n    from a function with such a declaration will be converted to the specified type `T`.\n\n  * Many more operators now support `.` prefixes (e.g. `.\u2264`) ([#17393]).  However,\n    users are discouraged from overloading these, since they are mainly parsed\n    in order to implement backwards compatibility with planned automatic\n    broadcasting of dot operators in Julia 0.6 ([#16285]).  Explicitly qualified\n    operator names like `Base.\u2264` should now use `Base.:\u2264` (prefixed by `@compat`\n    if you need 0.4 compatibility via the `Compat` package).\n\n  * User-extensible bounds check elimination is now possible with the new\n    `@boundscheck` macro ([#14474]). This macro marks bounds checking code blocks,\n    which the compiler may remove when encountered inside an `@inbounds` call.\n\nExperimental language features\n------------------------------\n\n  * Support for\n    [multi-threading](https://docs.julialang.org/en/v1/manual/parallel-computing/#man-multithreading-1).\n    Loops with independent iterations can be easily parallelized with the\n    `Threads.@threads` macro.\n\n  * Support for arrays with indexing starting at values different from 1.\n    The array types are expected to be defined in packages, but now\n    Julia provides an API for writing generic algorithms for arbitrary\n    indexing schemes ([#16260]).\n\nLanguage changes\n----------------\n\n  * Each function and closure now has its own type. The captured variables of a closure\n    are fields of its type. `Function` is now an abstract type, and is the default\n    supertype of functions and closures. All functions, including anonymous functions,\n    are generic and support all features (e.g. keyword arguments). Instead of adding\n    methods to `call`, methods are added by type using the syntax\n    `(::ftype)(...) = ...`. `call` is deprecated ([#13412]). A significant result of\n    this language change is that higher order functions can be specialized on their\n    function arguments, leading to much faster functional programming, typically as\n    fast as if function arguments were manually inlined. See below for details.\n\n  * Square brackets and commas (e.g. `[x, y]`) no longer concatenate arrays, and always\n    simply construct a vector of the provided values. If `x` and `y` are arrays,\n    `[x, y]` will be an array of arrays ([#3737], [#2488], [#8599]).\n\n  * `using` and `import` are now case-sensitive even on case-insensitive filesystems\n    (common on Mac and Windows) ([#13542]).\n\n  * Relational algebra symbols are now allowed as infix operators ([#8036]):\n    `\u2a1d`, `\u27d5`, `\u27d6`, `\u27d7` for joins and `\u25b7` for anti-join.\n\n  * A warning is always given when a method is overwritten; previously, this was done\n    only when the new and old definitions were in separate modules ([#14759]).\n\n  * The `if` keyword cannot be followed immediately by a line break ([#15763]).\n\n  * Juxtaposition of numeric literals ending in `.` (e.g. `1.x`) is no longer\n    allowed ([#15731]).\n\n  * The built-in `NTuple` type has been removed; `NTuple{N,T}` is now\n    implemented internally as `Tuple{Vararg{T,N}}` ([#11242]).\n\n  * Use of the syntax `x::T` to declare the type of a local variable is deprecated.\n    In the future this will always mean type assertion, and declarations should use\n    `local x::T` instead ([#16071]).\n    When `x` is global, `x::T = ...` and `global x::T` used to mean type assertion,\n    but this syntax is now reserved for type declaration ([#964]).\n\n  * Dictionary comprehension syntax `[ a=>b for x in y ]` is deprecated.\n    Use `Dict(a=>b for x in y)` instead ([#16510]).\n\n  * Parentheses are no longer allowed around iteration specifications, e.g.\n    `for (i = 1:n)` ([#17668]).\n\nBreaking changes\n----------------\n\nThis section lists changes that do not have deprecation warnings.\n\n  * All dimensions indexed by scalars are now dropped, whereas previously only\n    trailing scalar dimensions would be omitted from the result ([#13612]). This\n    is a very major behavioral change, but should cause obvious failures. To retain\n    a dimension sliced with a scalar `i` slice with `i:i` instead.\n\n  * The assignment operations `.+=`, `.*=` and so on now generate calls\n    to `broadcast!` on the left-hand side (or call to `view(a, ...)` on the left-hand side\n    if the latter is an indexing expression, e.g. `a[...]`). This means that they will fail\n    if the left-hand side is immutable (or does not support `view`), and will otherwise\n    change the left-hand side in-place ([#17510], [#17546]).\n\n  * Method ambiguities no longer generate warnings when files are loaded,\n    nor do they dispatch to an arbitrarily-chosen method; instead, a call that\n    cannot be resolved to a single method results in a `MethodError` at run time,\n    rather than the previous definition-time warning ([#6190]).\n\n  * Array comprehensions preserve the dimensions of the input ranges. For example,\n    `[2x for x in A]` will have the same dimensions as `A` ([#16622]).\n\n  * The result type of an array comprehension depends only on the types of elements\n    computed, instead of using type inference ([#7258]). If the result is empty, then\n    type inference is still used to determine the element type.\n\n  * `reshape` is now defined to always share data with the original array.\n    If a reshaped copy is needed, use `copy(reshape(a))` or `copy!` to a new array of\n    the desired shape ([#4211]).\n\n  * `mapslices` now re-uses temporary storage. Recipient functions that expect\n    input slices to be persistent should copy data to other storage ([#17266]).\n    All usages of `mapslices` should be carefully audited since this change can cause\n    silent, incorrect behavior, rather than failing noisily.\n\n  * Local variables and arguments are represented in lowered code as numbered `Slot`\n    objects instead of as symbols ([#15609]).\n\n  * The information that used to be in the `ast` field of the `LambdaStaticData` type\n    is now divided among the fields `code`, `slotnames`, `slottypes`, `slotflags`,\n    `gensymtypes`, `rettype`, `nargs`, and `isva` in the `LambdaInfo` type ([#15609]).\n\n  * `A <: B` is parsed as `Expr(:(<:), :A, :B)` in all cases ([#9503]).\n    This also applies to the `>:` operator.\n\n  * Simple 2-argument comparisons like `A < B` are parsed as calls instead of using the\n    `:comparison` expression type ([#15524]). The `:comparison` expression type is still\n    produced in ASTs when comparisons are chained (e.g. `A < B \u2264 C`).\n\n  * `map` on a dictionary now expects a function that expects and returns a `Pair`.\n    The result is now another dictionary instead of an array ([#16622]).\n\n  * Bit shift operations (i.e. `<<`, `>>`, and `>>>`) now handle\n    negative shift counts differently: Negative counts are interpreted\n    as shifts in the opposite direction. For example, `4 >> -1 == 4 <<\n    +1 == 8`. Previously, negative counts would implicitly overflow to\n    large positive counts, always yielding either `0` or `-1`.\n\nLibrary improvements\n--------------------\n\n  * Strings ([#16107]):\n\n    * The `UTF8String` and `ASCIIString` types have been merged into a single\n      `String` type ([#16058]).  Use `isascii(s)` to check whether\n      a string contains only ASCII characters. The `ascii(s)` function now\n      converts `s` to `String`, raising an `ArgumentError` exception if `s` is\n      not pure ASCII.\n\n    * The `UTF16String` and `UTF32String` types and corresponding `utf16` and\n      `utf32` converter functions have been removed from the standard library.\n      If you need these types, they have been moved to the\n      [LegacyStrings.jl package](https://github.com/JuliaArchive/LegacyStrings.jl).\n      In the future, more robust Unicode string support will be provided by the\n      [StringEncodings.jl package](https://github.com/nalimilan/StringEncodings.jl).\n      If you only need these types to call wide string APIs (UTF-16 on Windows,\n      UTF-32 on UNIX), consider using the new `transcode` function (see below)\n      or the `Cwstring` type as a `ccall` argument type, which also ensures\n      correct NUL termination of string data.\n\n    * A `transcode(T, src)` function is now exported for converting data\n      between UTF-xx Unicode encodings ([#17323]).\n\n    * The basic string construction routines are now `string(args...)`,\n      `String(s)`, `unsafe_string(ptr)` (formerly `bytestring(ptr)`), and\n      `unsafe_wrap(String, ptr)` (formerly `pointer_to_string`) ([#16731]).\n\n    * Comparisons between `Char`s and `Integer`s are now deprecated ([#16024]):\n      `'x' == 120` now produces a warning but still evaluates to `true`. In the\n      future it may evaluate to `false` or the comparison may be an error. To\n      compare characters with integers you should either convert the integer to\n      a character value or convert the character to the corresponding code point\n      first: e.g. `'x' == Char(120)` or `Int('x') == 120`. The former is usually\n      preferable.\n\n    * Support for Unicode 9 ([#17402]).\n\n  * Arrays and linear algebra:\n\n    * Dimensions indexed by multidimensional arrays add dimensions. More generally, the\n      dimensionality of the result is the sum of the dimensionalities of the indices ([#15431]).\n\n    * New `normalize` and `normalize!` convenience functions for normalizing\n      vectors ([#13681]).\n\n    * QR matrix factorization:\n\n      * New method for generic QR with column pivoting ([#13480]).\n\n      * New method for polar decompositions of `AbstractVector`s ([#13681]).\n\n    * A new `SparseVector` type allows for one-dimensional sparse arrays.\n      Slicing and reshaping sparse matrices now return vectors when\n      appropriate. The `sparsevec` function returns a one-dimensional sparse\n      vector instead of a one-column sparse matrix. The `SparseMatrix` module\n      has been renamed to `SparseArrays` ([#13440]).\n\n    * Rank one update and downdate functions, `lowrankupdate`, `lowrankupdate!`, `lowrankdowndate`,\n      and `lowrankdowndate!`, have been introduced for dense Cholesky factorizations ([#14243], [#14424]).\n\n    * All `sparse` methods now retain provided numerical zeros as structural nonzeros; to\n      drop numerical zeros, use `dropzeros!` ([#14798], [#15242]).\n\n    * `setindex!` methods for sparse matrices and vectors no longer purge allocated entries\n      on zero assignment. To drop stored entries from sparse matrices and vectors, use\n      `Base.SparseArrays.dropstored!` ([#17404]).\n\n    * Concatenating dense and sparse matrices now returns a sparse matrix ([#15172]).\n\n  * Files and I/O:\n\n    * The `open` function now respects `umask` on UNIX when creating files ([#16466], [#16502]).\n\n    * A new function `walkdir()` returns an iterator that walks the tree of a directory ([#8814], [#13707]).\n\n       ```\n       for (root, dirs, files) in walkdir(expanduser(\"~/.julia/v0.5/Plots/src\"))\n           println(\"$(length(files)) \\t files in $root\")\n       end\n       19    files in /Users/me/.julia/v0.5/Plots/src\n       15    files in /Users/me/.julia/v0.5/Plots/src/backends\n       4     files in /Users/me/.julia/v0.5/Plots/src/deprecated\n      ```\n\n    * A new function `chown()` changes the ownership of files ([#15007]).\n\n    * Display properties can now be passed among output functions (e.g. `show`)\n      using an `IOContext` object ([#13825]).\n\n    * `Cmd(cmd; ...)` now accepts new Windows-specific options `windows_verbatim`\n      (to alter Windows command-line generation) and `windows_hide` (to\n      suppress creation of new console windows) ([#13780]).\n\n    * There is now a default no-op `flush(io)` function for all `IO` types ([#16403]).\n\n  * Parallel computing:\n\n    * `pmap` keyword arguments `err_retry=true` and `err_stop=false` are deprecated.\n      Action to be taken on errors can be specified via the `on_error` keyword argument.\n      Retry is specified via `retry_n`, `retry_on` and `retry_max_delay` ([#15409], [#15975], [#16663]).\n\n    * The functions `remotecall`, `remotecall_fetch`, and `remotecall_wait` now have the\n      function argument as the first argument to allow for do-block syntax ([#13338]).\n\n  * Statistics:\n\n    * Improve performance of `quantile` ([#14413]).\n\n    * `extrema` can now operate over a region ([#15550]).\n\n    * `cov` and `cor` don't use keyword arguments anymore and are therefore now type stable ([#13465]).\n\n    * Histogram functionality has been deprecated in `Base`. Use the\n      [StatsBase.jl package](https://github.com/JuliaStats/StatsBase.jl)\n      instead ([#6842], [#16450]).\n\n  * Testing:\n\n    * The `Base.Test` module now has a `@testset` feature to bundle\n      tests together and delay throwing an error until the end ([#13062]).\n\n    * The new features are mirrored in the\n      [BaseTestNext.jl package](https://github.com/IainNZ/BaseTestNext.jl)\n      for users who would like to use the new functionality on Julia v0.4.\n\n    * The [BaseTestDeprecated.jl package](https://github.com/IainNZ/BaseTestDeprecated.jl)\n      provides the old-style `handler` functionality, for compatibility\n      with code that needs to support both Julia v0.4 and v0.5.\n\n  * Package management:\n\n    * The package system (`Pkg`) is now based on the `libgit2` library, rather\n      than running the `git` program, increasing performance (especially on\n      Windows) ([#11196]).\n\n    * Package-development functions like `Pkg.tag` and `Pkg.publish`\n      have been moved to an external [PkgDev] package ([#13387]).\n\n    * Updating only a subset of the packages is now supported,\n      e.g. `Pkg.update(\"Example\")` ([#17132]).\n\n  * Miscellaneous:\n\n    * Prime number related functions have been moved from `Base` to the\n      [Primes.jl package](https://github.com/JuliaMath/Primes.jl) ([#16481]).\n\n    * Most of the combinatorics functions have been moved from `Base`\n      to the [Combinatorics.jl package](https://github.com/JuliaLang/Combinatorics.jl) ([#13897]).\n\n    * New `foreach` function for calling a function on every element of a collection when\n      the results are not needed ([#13774]). Compared to `map(f, v)`, which allocates and\n      returns a result array, `foreach(f, v)` calls `f` on each element of `v`, returning\n      nothing.\n\n    * The new `Base.StackTraces` module makes stack traces easier to use programmatically ([#14469]).\n\n    * The `libjulia` library is now properly versioned and installed to the public `<prefix>/lib`\n      directory, instead of the private `<prefix>/lib/julia` directory ([#16362]).\n\n    * System reflection is now more consistently exposed from `Sys` and not `Base`\n      (e.g. constants such as `WORD_SIZE` and `CPU_CORES`). `OS_NAME` has been\n      replaced by `Sys.KERNEL` and always reports the name of the kernel (as\n      reported by `uname`). The `@windows_only` and `@osx` family of macros\n      have been replaced with functions such as `is_windows()` and `is_apple()`.\n      There is now also a `@static` macro that will evaluate the condition of an\n      if-statement at compile time, for when a static branch is required ([#16219]).\n\n    * `Date` and `DateTime` values can now be rounded to a specified resolution (e.g., 1 month or\n      15 minutes) with `floor`, `ceil`, and `round` ([#17037]).\n\n[PkgDev]: https://github.com/JuliaLang/PkgDev.jl\n\nCompiler/Runtime improvements\n-----------------------------\n\n  * Machine SIMD types can be represented in Julia as a homogeneous tuple of `VecElement` ([#15244]).\n\n  * The performance of higher-order and anonymous functions has been greatly improved.\n    For example, `map(x->2x, A)` performs as well as `2.*A`([#13412]).\n\n  * On windows, a DLL of standard library code is now precompiled and used by default,\n    improving startup time ([#16953]).\n\n  * LLVM has been upgraded to version 3.7.1, improving the quality of generated\n    code and debug info. However compile times may be slightly longer ([#14623]).\n\nNew architectures\n-----------------\n\n  This release greatly improves support for ARM, and introduces support for Power.\n\n  * [ARM](https://github.com/JuliaLang/julia/issues?utf8=%E2%9C%93&q=label%3Aarm):\n    [#14194], [#14519], [#16645], [#16621]\n\n  * [Power](https://github.com/JuliaLang/julia/issues?utf8=%E2%9C%93&q=label%3Apower):\n    [#16455], [#16404]\n\nDeprecated or removed\n---------------------\n\n  * The following function names have been simplified and unified ([#13232]):\n\n    * `get_bigfloat_precision`  -> `precision(BigFloat)`\n    * `set_bigfloat_precision`  -> `setprecision`\n    * `with_bigfloat_precision` -> `setprecision`\n\n    * `get_rounding`            -> `rounding`\n    * `set_rounding`            -> `setrounding`\n    * `with_rounding`           -> `setrounding`\n\n  * The method `A_ldiv_B!(SparseMatrixCSC, StridedVecOrMat)` has been deprecated\n    in favor of versions that require the matrix to be in factored form\n    ([#13496]).\n\n  * `chol(A,Val{:U/:L})` has been deprecated in favor of `chol(A)` ([#13680]).\n\n  * `rem1(x,y)` is discontinued due to inconsistency for `x==0`. Use `mod1` instead ([#14140]).\n\n  * The `FS` module has been renamed to `Filesystem`. Calling the functions `isreadable`,\n   `iswritable`, and `isexecutable` on filesystem paths has been deprecated ([#12819]).\n\n  * `RemoteRef` has been deprecated in favor of `RemoteChannel` ([#14458]).\n\n  * `super` has been renamed to `supertype` ([#14335]).\n\n  * `parseip(str)` has been deprecated in favor of `parse(IPAddr, str)` ([#14676]).\n\n  * `readall` has been renamed to `readstring`, and `readbytes` has been renamed to `read` ([#14608], [#14660]).\n\n  * `fieldoffsets(x)` has been deprecated in favor of calling `fieldoffset(x, i)` on each field ([#14777]).\n\n  * `issym` is deprecated in favor of `issymmetric` to match similar functions\n    (`ishermitian`, ...) ([#15192]).\n\n  * `scale` is deprecated in favor of either `\u03b1*A`, `Diagonal(x)*A`, or `A*Diagonal(x)` ([#15258]).\n\n  * `istext` has been renamed to `istextmime` ([#12872], [#15708]).\n\n  * \"Functor\" types are no longer necessary and have been deprecated ([#15804]). To maintain\n    performance on older versions of Julia the [Compat.jl package](https://github.com/JuliaLang/Compat.jl/pull/184)\n    provides a `@functorize` macro.\n\n  * `bitunpack(B)` and `bitpack(A)` have been deprecated in favor of\n    `Array(B)` and `BitArray(A)`, respectively ([#16010]).\n\n  * `xdump` is removed, and `dump` now simply shows the full representation of a value.\n    `dump` should not be overloaded, since it is for examining concrete structure ([#4163]).\n\n  * `sprandbool` has been deprecated in favor of `sprand(Bool, ...)` or\n    `sprand(rng, Bool, ...)` ([#11688], [#16098]).\n\n  * The lowercase `symbol` function has been deprecated in favor of the `Symbol`\n    constructor ([#16154]).\n\n  * `writemime` is deprecated, and output methods specifying a MIME type are now\n    methods of `show` ([#14052]).\n\n  * BLAS utility functions `blas_set_num_threads`, `blas_vendor`, and `check_blas`\n    have been moved to the BLAS module as `BLAS.set_num_threads`, `BLAS.vendor`,\n    and `BLAS.check` ([#10548], [#16600]).\n\n  * `print_escaped` has been renamed to `escape_string`, `print_unescaped` has been\n    renamed to `unescape_string`, and `print_joined` has been renamed to `join` ([#16603]).\n\n  * `pointer_to_string` has been renamed to `unsafe_wrap(String, ...)`, and\n    `pointer_to_array` has been renamed to `unsafe_wrap(Array, ...)` ([#16731]).\n\n  * `sub` and `slice` have been deprecated in favor of `view` ([#16972]).\n\n  * Sparse matrix functions `etree`, `ereach`, `csc_permute`, and `symperm` have been moved\n    to the [SuiteSparse.jl package](https://github.com/JuliaSparse/SuiteSparse.jl) ([#12231], [#17033]).\n\n  * The no-op `transpose` fallback for non-numeric arrays has been deprecated. Consider introducing suitable\n    `transpose` methods or calling `permutedims(x, (2, 1))` for matrices and `reshape(x, 1, length(x))` for\n    vectors.  ([#13171], [#17075], [#17374]).\n\n  * The following macros have been deprecated ([#16219]):\n    * `@windows` is deprecated in favor of `is_windows()`\n    * `@unix` is deprecated in favor of `is_unix()`\n    * `@osx` is deprecated in favor of `is_apple()`\n    * `@linux` is deprecated in favor of `is_linux()`\n    * `@windows_only` is deprecated in favor of `if is_windows()`\n    * `@unix_only` is deprecated in favor of `if is_unix()`\n    * `@osx_only` is deprecated in favor of `if is_apple()`\n    * `@linux_only` is deprecated in favor of `if is_linux()`\n    * NOTE: Using `@static` could be useful/necessary when used in a function's local scope. See details at the section entitled [Handling Operating System Variation](https://docs.julialang.org/en/v1/manual/handling-operating-system-variation/) in the manual.\n\nCommand-line option changes\n---------------------------\n\n  * The `-F` flag to load `~/.juliarc` has been deprecated in favor of\n    `--startup-file=yes` ([#9482]).\n\n  * The `-f` and `--no-startup` flags to disable loading of `~/.juliarc` have\n    been deprecated in favor of `--startup-file=no` ([#9482]).\n\n  * The `-P` and `--post-boot` flags for evaluating an expression in \"interactive mode\"\n    have been deprecated in favor of `-i -e` ([#16854]).\n\n  * The `--no-history-file` flag to disable loading of `~/.julia_history` has been\n    deprecated in favor of `--history-file=no` ([#9482]).\n\nLanguage tooling improvements\n-----------------------------\n\n   * The [Julia debugger](https://github.com/Keno/Gallium.jl) makes its debut\n     with this release. Install it with `Pkg.add(\"Gallium\")`, and the\n     [documentation](https://github.com/Keno/Gallium.jl#gallium) should\n     get you going. The [JuliaCon\n     talk](https://www.youtube.com/watch?v=e6-hcOHO0tc&list=PLP8iPy9hna6SQPwZUDtAM59-wPzCPyD_S&index=5)\n     on Gallium shows off various features of the debugger.\n\n   * The [Juno IDE](http://junolab.org) has matured significantly, and now\n     also includes support for plotting and debugging.\n\n   * [Cxx.jl](https://github.com/Keno/Cxx.jl) provides a convenient FFI for\n     calling C++ code from Julia.\n\nJulia v0.4.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Function call overloading: for arbitrary objects `x` (not of type\n    `Function`), `x(...)` is transformed into `call(x, ...)`, and `call`\n    can be overloaded as desired.  Constructors are now a special case of\n    this mechanism, which allows e.g. constructors for abstract types.\n    `T(...)` falls back to `convert(T, x)`, so all `convert` methods implicitly\n    define a constructor ([#8712], [#2403]).\n\n  * Unicode version 8 is now supported for identifiers etcetera ([#7917], [#12031]).\n\n  * Type parameters now permit any `isbits` type, not just `Int` and `Bool` ([#6081]).\n\n  * Keyword argument names can be computed, using syntax such as `f(; symbol => val)` ([#7704]).\n\n  * The syntax `@generated function` enables generation of specialized methods based on\n    argument types. At compile time, the function is called with its arguments bound to their\n    types instead of to their values. The function then returns an expression forming the\n    body of the function to be called at run time ([#7311]).\n\n  * [Documentation system](https://docs.julialang.org/en/v1/manual/documentation/)\n    for functions, methods, types and macros in packages and user code ([#8791]).\n\n  * The syntax `function foo end` can be used to introduce a generic function without\n    yet adding any methods ([#8283]).\n\n  * Incremental precompilation of modules: call `VERSION >= v\"0.4.0-dev+6521\" && __precompile__()` at the top of a\n    module file to automatically precompile it when it is imported ([#12491]), or manually\n    run `Base.compilecache(modulename)`. The resulting precompiled `.ji` file is saved in\n    `~/.julia/lib/v0.4` ([#8745]).\n\n      * See manual section on `Module initialization and precompilation` (under `Modules`) for\n        details and errata.  In particular, to be safely precompilable a module may need an\n        `__init__` function to separate code that must be executed at runtime rather than precompile\n        time.  Modules that are *not* precompilable should call `__precompile__(false)`.\n\n      * The precompiled `.ji` file includes a list of dependencies (modules and files that\n        were imported/included at precompile-time), and the module is automatically recompiled\n        upon `import` when any of its dependencies have changed.  Explicit dependencies\n        on other files can be declared with `include_dependency(path)` ([#12458]).\n\n      * New option `--output-incremental={yes|no}` added to invoke the equivalent of `Base.compilecache`\n        from the command line.\n\n  * The syntax `new{parameters...}(...)` can be used in constructors to specify parameters for\n    the type to be constructed ([#8135]).\n\n  * `++` is now parsed as an infix operator, but does not yet have a default definition ([#11030], [#11686]).\n\n  * Support for inter-task communication using `Channels` ([#12264]).\n    See https://docs.julialang.org/en/v1/manual/parallel-computing/#Channels-1 for details.\n\n  * `RemoteRef`s now point to remote channels. The remote channels can be of length greater than 1.\n    Default continues to be of length 1 ([#12385]).\n    See https://docs.julialang.org/en/v1/manual/parallel-computing/#Remote-References-and-AbstractChannels-1 for details.\n\n  * `@__LINE__` special macro now available to reflect invocation source line number ([#12727]).\n\nLanguage changes\n----------------\n\n  * Tuple types are now written as `Tuple{A, B}` instead of as `(A, B)`.\n    Tuples of bits types are inlined into structs and arrays, like other\n    immutable types.\n    `...` now does splatting inside parentheses, instead of constructing a\n    variadic tuple type ([#10380]).\n    Variadic tuple types are written as `Tuple{Vararg{T}}`.\n\n  * Using `[x,y]` to concatenate arrays is deprecated, and in the future will\n    construct a vector of `x` and `y` instead ([#3737], [#2488], [#8599]).\n\n  * Significant improvements to `ccall` and `cfunction`\n\n    * As a safer alternative to creating pointers (`Ptr`), the managed reference type\n      `Ref` has been added. A `Ref` points to the data contained by a value in an\n      abstract sense, and in a way that is GC-safe. For example, `Ref(2)` points to\n      a storage location that contains the integer `2`, and `Ref(array,3)` points\n      to the third element of an array. A `Ref` can be automatically converted to a\n      native pointer when passed to a `ccall`.\n\n    * When passing a by-reference argument to `ccall`, you can declare\n      the argument type to be `Ref{T}` instead of `Ptr{T}`, and just\n      pass `x` instead of `&x`.\n\n    * `ccall` is now lowered to call `unsafe_convert(T, cconvert(T, x))` on each\n      argument. `cconvert` falls back to `convert`, but can be used to convert an\n      argument to an arbitrarily-different representation more suitable for passing\n      to C. `unsafe_convert` then handles conversions to `Ptr`.\n\n    * `ccall` and `cfunction` now support correctly passing and returning structs,\n      following the platform ABI (assuming the C types are mirrored accurately in Julia).\n\n    * `cfunction` arguments of struct-like Julia types are now passed by value.\n      If `Ref{T}` is used as a `cfunction` argument type, it will look up the\n      method applicable to `T`, but pass the argument by reference (as Julia functions\n      usually do). However, this should only be used for objects allocated by Julia\n      and for `isbits` types.\n\n  * `convert(Ptr,x)` is deprecated for most types, replaced by\n    `unsafe_convert`. You can still `convert` between pointer types,\n    and between pointers and `Int` or `UInt`.\n\n  * Module `__init__` methods no longer swallow thrown exceptions; they now\n    throw an `InitError` wrapping the thrown exception ([#12576]).\n\n  * Unsigned `BigInt` literal syntax has been removed ([#11105]).\n    Unsigned literals larger than `UInt128` now throw a syntax error.\n\n  * `error(::Exception)` and `error(::Type{Exception})` have been deprecated\n     in favor of using an explicit `throw` ([#9690]).\n\n  * `Uint` etcetera are renamed to `UInt` ([#8905]).\n\n  * `String` is renamed to `AbstractString` ([#8872]).\n\n  * `FloatingPoint` is renamed to `AbstractFloat` ([#12162]).\n\n  * `None` is deprecated; use `Union{}` instead ([#8423]).\n\n  * `Nothing` (the type of `nothing`) is renamed to `Void` ([#8423]).\n\n  * Arrays can be constructed with the syntax `Array{T}(m,n)` ([#3214], [#10075]).\n\n  * `Dict` literal syntax `[a=>b,c=>d]` is replaced by `Dict(a=>b,c=>d)`,\n    `{a=>b}` is replaced by `Dict{Any,Any}(a=>b)`, and\n    `(K=>V)[...]` is replaced by `Dict{K,V}(...)`.\n    The new syntax has many advantages: all of its components are first-class,\n    it generalizes to other types of containers, it is easier to guess how to\n    specify key and value types, and the syntaxes for empty and pre-populated\n    dicts are synchronized. As part of this change, `=>` is parsed as a normal\n    operator, and `Base` defines it to construct `Pair` objects ([#6739]).\n\n  * `Char` is no longer a subtype of `Integer` ([#8816]).\n    Char now supports a more limited set of operations with `Integer` types:\n\n      * comparison / equality\n      * `Char` + `Int` = `Char`\n      * `Char` - `Char` = `Int`\n\n  * `round` rounds to the nearest integer using the default rounding mode,\n    which is ties-to-even by default ([#8750]).\n\n  * A custom triple-quoted string like `x\"\"\"...\"\"\"` no longer invokes an `x_mstr`\n    macro. Instead, the string is first unindented and then `x_str` is invoked,\n    as if the string had been single-quoted ([#10228]).\n\n  * Colons (`:`) within indexing expressions are no longer lowered to the range\n    `1:end`. Instead, the `:` identifier is passed directly. Custom array types\n    that implement `getindex` or `setindex!` methods must also extend those\n    methods to support arguments of type `Colon` ([#10331]).\n\n  * Unions of types should now be written with curly braces instead of parentheses, i.e.\n    `Union{Type1, Type2}` instead of `Union(Type1, Type2)` ([#11432]).\n\n  * The keyword `local` is no longer allowed in global scope. Use `let` instead of\n    `begin` to create a new scope from the top level ([#7234], [#10472]).\n\n  * Triple-quoted strings no longer treat tabs as 8 spaces. Instead, the\n    longest common prefix of spaces and tabs is removed.\n\n  * `global x` in a nested scope is now a syntax error if `x` is local\n    to the enclosing scope ([#7264]/[#11985]).\n\n  * The default `importall Base.Operators` is deprecated, and relying on it\n    will give a warning ([#8113]).\n\n  * `remotecall_fetch` and `fetch` now rethrow any uncaught remote exception locally as a\n    `RemoteException`. Previously they would return the remote exception object.\n    The worker pid, remote exception and remote backtrace are available in the\n    thrown `RemoteException`.\n\n  * If any of the enclosed async operations in a `@sync` block throw exceptions, they\n    are now collected in a `CompositeException` and the `CompositeException` thrown.\n\n\nCommand line option changes\n---------------------------\n\n  * The `-i` option now forces the REPL to run after loading the specified script (if any) ([#11347]).\n\n  * New option `--handle-signals={yes|no}` to disable Julia's signal handlers.\n\n  * The `--depwarn={yes|no|error}` option enables/disables syntax and method deprecation warnings,\n    or turns them into errors ([#9294]).\n\n  * Some command line options are slated for deprecation / removal\n    - `-f, --no-startup` Don't load ~/.juliarc (deprecated, use --startup-file=no)\n    - `-F` Load ~/.juliarc (deprecated, use --startup-file=yes)`\n    - `-P, --post-boot <expr>`  Evaluate <expr>, but don't disable interactive mode (deprecated, use -i -e instead)\n    - `--no-history-file`  Don't load history file (deprecated, use --history-file=no)\n\nCompiler/Runtime improvements\n-----------------------------\n\n  * Functions may be annotated with metadata (`:meta` expressions) to be used by the compiler ([#8297]).\n\n  * `@inline` before a function definition forces the compiler to inline the function ([#8297]).\n\n  * Loads from heap-allocated immutables are hoisted out of loops in more cases ([#8867]).\n\n  * Accessing fields that are always initialized no longer produces undefined checks ([#8827]).\n\n  * New generational garbage collector which greatly reduces GC overhead for many common workloads ([#5227]).\n\nLibrary improvements\n--------------------\n\n  * Build with USE_GPL_LIBS=0 to exclude all GPL libraries and code ([#10870]).\n\n  * Linear algebra\n\n    * The `LinAlg` module is now exported.\n\n    * `sparse(A)` now takes any `AbstractMatrix` A as an argument ([#10031]).\n\n    * Factorization API is now type-stable; functions dispatch on `Val{false}` or `Val{true}` instead of a boolean value ([#9575]).\n\n    * Added generic Cholesky factorization, and the Cholesky factorization is now parametrized by the matrix type ([#7236]).\n\n    * Sparse `cholfact` and `ldltfact` functions now accept a `perm` keyword\n      for user-provided permutations and a `shift` keyword to factorize\n      a shifted matrix ([#10844]).\n\n    * New `svds` function for the sparse truncated SVD ([#9425]).\n\n    * `Symmetric` and `Hermitian` immutables are now parametrized by the matrix type ([#7992]).\n\n    * New `ordschur` and `ordschur!` functions for sorting a Schur factorization by the eigenvalues ([#8467],[#9701]).\n\n    * `Givens` type doesn't have a size anymore and is no longer a subtype of `AbstractMatrix` ([#8660]).\n\n    * Large speedup in sparse `\\` and splitting of Cholesky and LDL\u1d40 factorizations into `cholfact` and `ldltfact` ([#10117]).\n\n    * Add sparse least squares to `\\` by adding `qrfact` for sparse matrices based on the SPQR library ([#10180]).\n\n    * Split `Triangular` type into `UpperTriangular`, `LowerTriangular`, `UnitUpperTriagular` and `UnitLowerTriangular` ([#9779])\n\n    * OpenBLAS 64-bit (ILP64) interface is now compiled with a `64_` suffix ([#8734]) to avoid conflicts with external libraries using a 32-bit BLAS ([#4923]).\n\n    * New `vecdot` function, analogous to `vecnorm`, for Euclidean inner products over any iterable container ([#11067]).\n\n    * `p = plan_fft(x)` and similar functions now return a `Base.DFT.Plan` object, rather\n    than an anonymous function.  Calling it via `p(x)` is deprecated in favor of\n    `p * x` or `p \\ x` (for the inverse), and it can also be used with `A_mul_B!`\n    to employ pre-allocated output arrays ([#12087]).\n\n    * `LU{T,Tridiagonal{T}}` now supports extraction of `L`, `U`, `p`, and `P` factors ([#12137]).\n\n    * Allocations in sparse matrix factorizations are now tracked by Julia's garbage collector ([#12034]).\n\n  * Strings\n\n    * NUL-terminated strings should now be passed to C via the new `Cstring` type, not `Ptr{UInt8}` or `Ptr{Cchar}`,\n      in order to check whether the string is free of NUL characters (which would cause silent truncation in C).\n      The analogous type `Cwstring` should be used for NUL-terminated `wchar_t*` strings ([#10994]).\n\n    * `graphemes(s)` returns an iterator over grapheme substrings of `s` ([#9261]).\n\n    * Character predicates such as `islower()`, `isspace()`, etc. use\n      utf8proc to provide uniform cross-platform behavior and\n      up-to-date, locale-independent support for Unicode standards\n      ([#5939]).\n\n    * `reverseind` function to convert indices in reversed strings (e.g. from\n      reversed regex searches) to indices in the original string ([#9249]).\n\n    * `charwidth(c)` and `strwidth(s)` now return up-to-date cross-platform\n      results (via utf8proc) ([#10659]): Julia now likes pizza ([#3721]), but some terminals still don't.\n\n    * `is_valid_char(c)`, (now `isvalid(Char,c)` ([#11241])), now correctly handles Unicode \"non-characters\", which are valid Unicode codepoints ([#11171]).\n\n    * Backreferences in replacement strings in calls to `replace` with a `Regex` pattern are now supported ([#11849]).\n      Use the `s` string prefix to indicate a replacement string contains a backreference. For example, `replace(\"ab\", r\"(.)(.)\", s\"\\2\\1\")` yields \"ba\".\n\n    * Capture groups in regular expressions can now be named using PCRE syntax, `(?P<group_name>...)`. Capture group matches can be accessed by name by indexing a `Match` object with the name of the group ([#11566]).\n\n    * `countlines()` now counts all lines, not just non-empty ([#11947]).\n\n  * Array and AbstractArray improvements\n\n    * New multidimensional iterators and index types for efficient iteration over `AbstractArray`s. Array iteration should generally be written as `for i in eachindex(A) ... end` rather than `for i = 1:length(A) ... end` ([#8432]).\n\n    * New implementation of SubArrays with substantial performance and functionality improvements ([#8501]).\n\n    * AbstractArray subtypes only need to implement `size` and `getindex`\n      for scalar indices to support indexing; all other indexing behaviors\n      (including logical indexing, ranges of indices, vectors, colons, etc.) are\n      implemented in default fallbacks. Similarly, they only need to implement\n      scalar `setindex!` to support all forms of indexed assingment ([#10525]).\n\n    * AbstractArrays that do not extend `similar` now return an `Array` by\n      default ([#10525]).\n\n  * Data structures\n\n    * New `sortperm!` function for pre-allocated index arrays ([#8792]).\n\n    * Switch from `O(N)` to `O(log N)` algorithm for `dequeue!(pq, key)`\n    with `PriorityQueue`. This provides major speedups for large\n    queues ([#8011]).\n\n    * `PriorityQueue` now includes the order type among its\n      parameters, `PriorityQueue{KeyType,ValueType,OrderType}`. An\n      empty queue can be constructed as `pq =\n      PriorityQueue(KeyType,ValueType)`, if you intend to use the\n      default `Forward` order, or `pq = PriorityQueue(KeyType,\n      ValueType, OrderType)` otherwise ([#8011]).\n\n    * Efficient `mean` and `median` for ranges ([#8089]).\n\n    * `deepcopy` recurses through immutable types and makes copies of their mutable fields ([#8560]).\n\n    * `copy(a::DArray)` will now make a copy of a `DArray` ([#9745]).\n\n  * New types\n\n    * Enums are now supported through the `@enum EnumName EnumValue1\n      EnumValue2` syntax. Enum member values also support abitrary\n      value assignment by the `@enum EnumName EnumValue1=1\n      EnumValue2=10 EnumValue3=20` syntax ([#10168]).\n\n    * New `Dates` module for calendar dates and other time-interval calculations ([#7654]).\n\n    * New `Nullable` type for missing data ([#8152]).\n\n    * A new `Val{T}` type allows one to dispatch on bits-type values ([#9452]).\n\n    * `linspace` now returns a `LinSpace` object which lazily computes linear interpolation of values between the start and stop values. It \"lifts\" endpoints which are approximately rational in the same manner as the `colon` operator.\n\n  * Arithmetic\n\n    * `convert` now checks for overflow when truncating integers or converting between\n    signed and unsigned ([#5413]).\n\n    * Arithmetic is type-preserving for more types; e.g. `(x::Int8) + (y::Int8)` now\n    yields an `Int8` ([#3759]).\n\n    * Reductions (e.g. `reduce`, `sum`) widen small types (integers smaller than `Int`, and `Float16`).\n\n    * Added optional rounding argument to floating-point constructors ([#8845]).\n\n    * Equality (`==`) and inequality (`<`/`<=`) comparisons are now correct\n      across all numeric types ([#9133], [#9198]).\n\n    * Rational arithmetic throws errors on overflow ([#8672]).\n\n    * Optional `log` and `log1p` functions implemented in pure Julia (experimental) ([#10008]).\n\n    * The `MathConst` type has been renamed `Irrational` ([#11922]).\n\n    * `isapprox` now has simpler and more sensible default tolerances ([#12393]), supports arrays, and has synonyms `\u2248` ([U+2248](https://www.fileformat.info/info/unicode/char/2248/index.htm), LaTeX `\\approx`) and `\u2249` ([U+2249](https://www.fileformat.info/info/unicode/char/2249/index.htm), LaTeX `\\napprox`) for `isapprox` and `!isapprox`, respectively ([#12472]).\n\n  * Numbers\n\n    * `primes` is now faster and has been extended to generate the primes in a user defined closed interval ([#12025]).\n\n    * The function `primesmask` which generates a prime sieve for a user defined closed interval is now exported ([#12025]).\n\n  * Random numbers\n\n    * Streamlined random number generation APIs [#8246].\n    The default `rand` no longer uses global state in the underlying C library,\n    dSFMT, making it closer to being thread-safe ([#8399], [#8832]).\n    All APIs can now take an `AbstractRNG` argument ([#8854], [#9065]). The seed argument to `srand` is now optional ([#8320], [#8854]).\n    The APIs accepting a range argument are extended to accept an arbitrary\n    `AbstractArray` ([#9049]).\n    Passing a range of `BigInt` to `rand` or `rand!` is now supported ([#9122]).\n    There are speed improvements across the board ([#8808], [#8941], [#8958], [#9083]).\n\n    * Significantly faster `randn` ([#9126], [#9132]).\n\n    * The `randexp` and `randexp!` functions are exported ([#9144]).\n\n  * File\n\n    * Added function `readlink` which returns the value of a symbolic link \"path\" ([#10714]).\n\n    * Added function `ismount` which checks if a directory is a mount point ([#11279]).\n\n    * The `cp` function now accepts keyword arguments `remove_destination` and `follow_symlinks` ([#10888]).\n\n    * The `mv` function now accepts keyword argument `remove_destination` ([#11145]).\n\n  * `Pipe()` creates a bidirectional I/O object that can be passed to `spawn` or `pipeline`\n    for redirecting process streams ([#12739]).\n\n  * Other improvements\n\n    * You can now tab-complete emoji via their [short names](http://www.emoji-cheat-sheet.com/), using `\\:name:<tab>` ([#10709]).\n\n    * `gc_enable` subsumes `gc_disable`, and also returns the previous GC state.\n\n    * `assert`, `@assert` now throws an `AssertionError` exception type ([#9734]).\n\n    * `@simd` now rejects invalid control flow (`@goto` / break / continue) in the inner loop body at compile time ([#8624]).\n\n    * The `machinefile` now supports a host count ([#7616]).\n\n    * `code_native` now outputs branch labels ([#8897]).\n\n    * Added `recvfrom` to get source address of UDP packets ([#9418]).\n\n    * `ClusterManager` performance improvements ([#9309]) and support for changing transports([#9434]).\n\n    * Added `Base.get_process_title` / `Base.set_process_title` ([#9957]).\n\n    * `readavailable` now returns a byte vector instead of a string.\n\n    * New `lock` and `unlock` functions, operating on `ReentrantLock`, to lock a stream during\n      concurrent writes from multiple tasks ([#10679]).\n\n    * `code_llvm` now outputs stripped IR without debug info or other attached metadata.\n      Use `code_llvm_raw` for the unstripped output ([#10747]).\n\n    * New `withenv(var=>val, ...) do ... end` function to temporarily\n      modify environment variables ([#10914]).\n\n    * New function `relpath` returns a relative filepath to path either from the current\n      directory or from an optional start directory ([#10893]).\n\n    * `mktemp` and `mktempdir` now take an optional argument to set which\n      directory the temporary file or directory is created in.\n\n    * New garbage collector tracked memory allocator functions: `jl_malloc`, `jl_calloc`,\n    `jl_realloc`, and `jl_free` with libc API ([[#12034]]).\n\n    * `mktempdir` and `mktemp` now have variants that take a function as its\n      first argument for automated clean-up ([[#9017]]).\n\nDeprecated or removed\n---------------------\n\n  * several syntax whitespace insensitivities have been deprecated ([#11891]).\n    ```julia\n     # function call\n     f (x)\n\n     # getindex\n     x [17]\n     rand(2) [1]\n\n     # function definition\n     f (x) = x^2\n     function foo (x)\n\tx^2\n     end\n    ```\n\n  * indexing with `Real`s that are not subtypes of `Integer` (`Rational`, `AbstractFloat`, etc.) has been deprecated ([#10458]).\n\n  * `push!(A)` has been deprecated, use `append!` instead of splatting arguments to `push!` ([#10400]).\n\n  * `names` for composite datatypes has been deprecated and\n    renamed to `fieldnames` ([#10332]).\n\n  * `DArray` functionality has been removed from `Base` and is now a\n    standalone package under the JuliaParallel umbrella organization ([#10333]).\n\n  * The `Graphics` module has been removed from `Base` and is now a\n    standalone package ([#10150], [#9862]).\n\n  * The `Woodbury` special matrix type has been removed from `LinAlg` ([#10024]).\n\n  * `median` and `median!` no longer accept a `checknan` keyword argument ([#8605]).\n\n  * `inf` and `nan` are now deprecated in favor of `T(Inf)` and `T(NaN)`, respectively ([#8776]).\n\n  * `oftype(T::Type, x)` is deprecated in favor of `convert(T,x)` (or `T(x)`).\n\n  * `{...}` syntax is deprecated in favor of `Any[...]` ([#8578]).\n\n  * `itrunc`, `ifloor`, `iceil` and `iround` are deprecated in favour of\n    `trunc{T<:Integer}(T,x)`, `floor{T<:Integer}(T,x)`, etc.. `trunc` is now\n    always bound-checked;`Base.unsafe_trunc` provides the old unchecked `itrunc`\n    behaviour ([#9133]).\n\n  * `squeeze` now requires that passed dimension(s) are an `Int` or tuple of `Int`s;\n    calling `squeeze` with an arbitrary iterator is deprecated ([#9271]).\n    Additionally, passed dimensions must be unique and correspond to extant\n    dimensions of the input array.\n\n  * `randbool` is deprecated. Use `rand(Bool)` to produce a random boolean value, and\n    `bitrand` to produce a random BitArray ([#9105], [#9569]).\n\n  * `beginswith` is renamed to `startswith` ([#9578]).\n\n  * `null` is renamed to `nullspace` ([#9714]).\n\n  * The operators `|>`, `.>`, `>>`, and `.>>` as used for process I/O redirection\n    are replaced with the `pipeline` function ([#5349], [#12739]).\n\n  * `flipud(A)` and `fliplr(A)` have been deprecated in favor of `flipdim(A, 1)` and\n    `flipdim(A, 2)`, respectively ([#10446]).\n\n  * Numeric conversion functions whose names are lower-case versions of type\n    names have been removed. To convert a scalar, use the type name, e.g.\n    `Int32(x)`. To convert an array to a different element type, use\n    `Array{T}(x)`, `map(T,x)`, or `round(T,x)`. To parse a string as an integer\n    or floating-point number, use `parse` ([#1470], [#6211]).\n\n  * Low-level functions from the C library and dynamic linker have been moved to\n    modules `Libc` and `Libdl`, respectively ([#10328]).\n\n  * The functions `parseint`, `parsefloat`, `float32_isvalid`,\n  `float64_isvalid`, and the string-argument `BigInt` and `BigFloat` have\n  been replaced by `parse` and `tryparse` with a type argument. The string\n  macro `big\"xx\"` can be used to construct `BigInt` and `BigFloat` literals\n  ([#3631], [#5704], [#9487], [#10543], [#10955]).\n\n  * the `--int-literals` compiler option is no longer accepted ([#9597]).\n\n  * Instead of `linrange`, use `linspace` ([#9666]).\n\n  * The functions `is_valid_char`, `is_valid_ascii`, `is_valid_utf8`, `is_valid_utf16`, and\n    `is_valid_utf32` have been replaced by generic `isvalid` methods.\n    The single argument form `isvalid(value)` can now be used for values of type `Char`, `ASCIIString`,\n    `UTF8String`, `UTF16String` and `UTF32String`.\n    The two argument form `isvalid(type, value)` can be used with the above types, with values\n    of type `Vector{UInt8}`, `Vector{UInt16}`, `Vector{UInt32}`, and `Vector{Char}` ([#11241]).\n\n  * Instead of `utf32(64,123,...)` use `utf32(UInt32[64,123,...])` ([#11379]).\n\n  * `start_timer` and `stop_timer` are replaced by `Timer` and `close`.\n\n  * The following internal julia C functions have been renamed, in order to prevent\n    potential naming conflicts with C libraries: ([#11741])\n\n    * `gc_wb*` -> `jl_gc_wb*`\n\n    * `gc_queue_root` -> `jl_gc_queue_root`\n\n    * `allocobj` -> `jl_gc_allocobj`\n\n    * `alloc_[0-3]w` -> `jl_gc_alloc_*w`\n\n    * `diff_gc_total_bytes` -> `jl_gc_diff_total_bytes`\n\n    * `sync_gc_total_bytes` -> `jl_gc_sync_total_bytes`\n\n  * `require(::AbstractString)` and `reload` (see news about addition of `compile`).\n\n  * `cartesianmap` is deprecated in favor of iterating over a `CartesianRange`\n\nJulia v0.3.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Greatly enhanced performance for passing and returning `Tuple`s ([#4042]).\n\n  * `Tuple`s (of `Integer`s, `Symbol`s, or `Bool`s) can now be used as type\n    parameters ([#5164]).\n\n  * An additional default \"inner\" constructor accepting any arguments is now\n    generated. Constructors that look like `MyType(a, b) = new(a, b)` do not\n    need to be added manually ([#4026], [#7071]).\n\n  * Expanded array type hierarchy to include an abstract `DenseArray` for\n    in-memory arrays with standard strided storage ([#987], [#2345],\n    [#6212]).\n\n  * When reloading code, types whose definitions have not changed can be\n    ignored in some cases.\n\n  * Binary `~` now parses as a vararg macro call to `@~`.\n    For example `x~y~z` => `@~ x y z` ([#4882]).\n\n  * Structure fields can now be accessed by index ([#4806]).\n\n  * If a module contains a function `__init__()`, it will be called when\n    the module is first loaded, and on process startup if a pre-compiled\n    version of the module is present ([#1268]).\n\n  * Multi-line comments ([#69], [#6128]): `#= .... =#`\n\n  * `--check-bounds=yes|no` compiler option\n\n  * Unicode identifiers are normalized (NFC) so that different encodings\n    of equivalent strings are treated as the same identifier ([#5462]).\n\n  * The set of characters permitted in identifiers has been restricted based\n    on Unicode categories. Generally, punctuation, formatting and control\n    characters, and operator symbols are not allowed in identifiers.\n    Number-like characters cannot begin identifiers ([#5936]).\n\n  * Define a limited number of infix Unicode operators ([#552], [#6582]):\n\n    | Precedence class | Operators (with synonyms, if any)\n    | ---------------- | ---------------------------------\n    |   ==             |  \u2265 (>=) \u2264 (<=) \u2261 (===) \u2260 (!=) \u2262 (!==) .\u2265 (.>=) .\u2264 (.<=) .!= (.\u2260) \u2208 (`in`) \u2209 (`(x,y)->!in(x, y)`) \u220b (`(x,y)->in(y, x)`) \u220c (`(x,y)->!in(y, x)`) \u2286 (`issubset`) \u2288 (`(x,y)->!issubset(x, y)`) \u228a (`(x,y)->x\u2286y && x!=y`) |\n    |   +              | \u222a (`union`) |\n    |   *              | \u00f7 (`div`) \u22c5 (`dot`) \u00d7 (`cross`) \u2229 (`intersect`) |\n    |   unary          | \u221a \u221b |\n\n    In addition to these, many of the Unicode operator symbols are parsed\n    as infix operators and are available for user-defined methods ([#6929]).\n\n  * Improved reporting of syntax errors ([#6179])\n\n  * `break` inside a `for` loop with multiple ranges now exits the entire loop nest ([#5154])\n\n  * Local goto statements using the `@goto` and `@label` macros ([#101]).\n\nREPL improvements\n-----------------\n\n  * New native-Julia REPL implementation, eliminating many problems\n    stemming from the old GNU Readline-based REPL ([#6270]).\n\n  * Tab-substitution of LaTeX math symbols (e.g. `\\alpha` by `\u03b1`) ([#6911]).\n    This also works in IJulia and in Emacs ([#6920]).\n\n  * `workspace()` function for obtaining a fresh workspace ([#1195]).\n\nLibrary improvements\n--------------------\n\n  * `isequal` now compares all numbers by value, ignoring type ([#6624]).\n\n  * Implement limited shared-memory parallelism with `SharedArray`s ([#5380]).\n\n  * Well-behaved floating-point ranges ([#2333], [#5636]).\n    Introduced the `FloatRange` type for floating-point ranges with a step,\n    which will give intuitive/correct results for classically problematic\n    ranges like `0.1:0.1:0.3`, `0.0:0.7:2.1` or `1.0:1/49:27.0`.\n\n  * `mod2pi` function ([#4799], [#4862]).\n\n  * New functions `minmax` and `extrema` ([#5275]).\n\n  * New macros `@edit`, `@less`, `@code_typed`, `@code_lowered`, `@code_llvm` and `@code_native` that all function like `@which` ([#5832]).\n\n  * `consume(p)` extended to `consume(p, args...)`, allowing it\n    to optionally pass `args...` back to the producer ([#4775]).\n\n  * `.juliarc.jl` is now loaded for both script and REPL execution ([#5076]).\n\n  * The `Sys` module now includes convenient functions for working with\n    dynamic library handles; `Sys.dllist` will list out all paths currently\n    loaded via `dlopen`, and `Sys.dlpath` will lookup a path from a handle\n\n  * `readdlm` treats multiple whitespace characters as a single delimiter\n    by default (when no delimiter is specified). This is useful for reading\n    fixed-width or messy whitespace-delimited data ([#5403]).\n\n  * The Airy, Bessel, Hankel, and related functions (`airy*`,\n    `bessel*`, `hankel*`) now detect errors returned by the underlying\n    AMOS library, throwing an `AmosException` in that case ([#4967]).\n\n  * `methodswith` now returns an array of `Method`s ([#5464]) rather\n    than just printing its results.\n\n  * `errno([code])` function to get or set the C library's `errno`.\n\n  * `GitHub` module for interacting with the GitHub API.\n\n  * Package improvements\n\n    * Packages are now installed into `.julia/v0.3` by default (or\n      whatever the current Julia version is), so that different\n      versions of Julia can co-exist with incompatible packages.\n      Existing `.julia` installations are unaffected unless `Pkg.init()`\n      is run to re-create the package directories ([#3344], [#5737]).\n\n    * `Pkg.submit(pkg[,commit])` function to automatically submit\n      a GitHub pull request to the package author.\n\n  * Collections improvements\n\n    * `Array` assignment (e.g. `x[:] = y`) ignores singleton dimensions\n      and allows the last dimension of one side to match all trailing dimensions\n      of the other ([#4048], [#4383]).\n\n    * `Dict(kv)` constructor for any iterator on `(key,value)` pairs.\n\n    * Multi-key `Dict`s: `D[x,y...]` is now a synonym for `D[(x,y...)]`\n      for associations `D` ([#4870]).\n\n    * `push!` and `unshift!` can push multiple arguments ([#4782]).\n\n    * `writedlm` and `writecsv` now accept any iterable collection of\n      iterable rows, in addition to `AbstractArray` arguments, and the\n      `writedlm` delimiter can be any printable object (e.g. a\n      `String`) instead of just a `Char`.\n\n    * `isempty` now works for any iterable collection ([#5827]).\n\n    * `unique` now accepts an optional `dim` argument for finding\n      unique rows or columns of a matrix or regions of a\n      multidimensional array ([#5811]).\n\n  * `Number` improvements\n\n    * The `ImaginaryUnit` type no longer exists. Instead, `im` is of type\n      `Complex{Bool}`. Making this work required changing the semantics of\n      boolean multiplication to approximately, `true * x = x` and\n      `false * x = zero(x)`, which can itself be considered useful ([#5468]).\n\n    * `big` is now vectorized ([#4766])\n\n    * `nextpow` and `prevpow` now return the `a^n` values instead of the\n      exponent `n` ([#4819])\n\n    * Overflow detection in `parseint` ([#4874]).\n\n    * `rand` now supports arbitrary `Ranges` arguments ([#5059]).\n\n    * `expm1` and `log1p` now support complex arguments ([#3141]).\n\n    * Broadcasting `.//` is now included ([#7094]).\n\n    * `prevfloat` and `nextfloat` now saturate at -Inf and Inf,\n      respectively, and have otherwise been fixed to follow the IEEE-754\n      standard functions `nextDown` and `nextUp` ([#5025]).\n\n    * New function `widen` for widening numeric types and values, and `widemul`\n      for multiplying to a larger type ([#6169]).\n\n    * `polygamma`, `digamma`, and `trigamma` now accept complex\n      arguments, and `zeta(s, z)` now provides the Hurwitz zeta ([#7125]).\n\n    * Narrow integer types (< 32 bits) are promoted to `Float64` rather\n      than to `Float32` by `float(x)` ([#7390]).\n\n  * `String` improvements\n\n    * Triple-quoted regex strings, `r\"\"\"...\"\"\"` ([#4934]).\n\n    * New string type, `UTF16String` ([#4930]), constructed by\n      `utf16(s)` from another string, a `Uint16` array or pointer, or\n      a byte array (possibly prefixed by a byte-order marker to\n      indicate endian-ness).  Its data is internally `NULL`-terminated\n      for passing to C ([#7016]).\n\n    * `CharString` is renamed to `UTF32String` ([#4943]), and its data\n      is now internally `NULL`-terminated for passing to C ([#7016]).\n      `CharString(c::Char...)` is deprecated in favor of `utf32(c...)`,\n      and `utf32(s)` otherwise has functionality similar to `utf16(s)`.\n\n    * New `WString` and `wstring` synonyms for either `UTF16String`\n      and `utf16` or `UTF32String` and `utf32`, respectively, depending\n      on the width of `Cwchar_t` ([#7016]).\n\n    * `normalize_string` function to perform Unicode normalization,\n      case-folding, and other transformations ([#5576]).\n\n    * `pointer(s, i=1)` for `ByteString`, `UTF16String`, `UTF32String`,\n      and `SubString`s thereof ([#5703]).\n\n    * `bytestring` is automatically called on `String` arguments for\n      conversion to `Ptr{Uint8}` in `ccall` ([#5677]).\n\n  * Linear algebra improvements\n\n      * Balancing options for eigenvector calculations for general matrices ([#5428]).\n\n      * Mutating linear algebra functions no longer promote ([#5526]).\n\n      * `condskeel` for Skeel condition numbers ([#5726]).\n\n      * `norm(::Matrix)` no longer calculates a vector norm when the first\n        dimension is one ([#5545]); it always uses the operator (induced)\n        matrix norm.\n\n      * New `vecnorm(itr, p=2)` function that computes the norm of\n        any iterable collection of numbers as if it were a vector of\n        the same length.  This generalizes and replaces `normfro` ([#6057]),\n        and `norm` is now type-stable ([#6056]).\n\n      * New `UniformScaling` matrix type and identity `I` constant ([#5810]).\n\n      * None of the concrete matrix factorization types are exported from `Base`\n        by default anymore.\n\n    * Sparse linear algebra\n\n      * 1-d sparse `getindex` has been implemented ([#7047])\n\n      * Faster sparse `getindex` ([#7131]).\n\n      * Faster sparse `kron` ([#4958]).\n\n      * `sparse(A) \\ B` now supports a matrix `B` of right-hand sides ([#5196]).\n\n      * `eigs(A, sigma)` now uses shift-and-invert for nonzero shifts `sigma` and inverse iteration for `which=\"SM\"`. If `sigma==nothing` (the new default), computes ordinary (forward) iterations ([#5776]).\n\n      * `sprand` is faster, and whether any entry is nonzero is now determined independently with the specified probability ([#6726]).\n\n    * Dense linear algebra for special matrix types\n\n      * Interconversions between the special matrix types `Diagonal`, `Bidiagonal`,\n        `SymTridiagonal`, `Triangular`, and `Triangular`, and `Matrix` are now allowed\n        for matrices which are representable in both source and destination types ([5e3f074b]).\n\n      * Allow for addition and subtraction over mixed matrix types, automatically promoting\n        the result to the denser matrix type ([a448e080], [#5927])\n\n      * new algorithms for linear solvers and eigensystems of `Bidiagonal`\n        matrices of generic element types ([#5277])\n\n      * new algorithms for linear solvers, eigensystems and singular systems of `Diagonal`\n        matrices of generic element types ([#5263])\n\n      * new algorithms for linear solvers and eigensystems of `Triangular`\n        matrices of generic element types ([#5255])\n\n      * specialized `inv` and `det` methods for `Tridiagonal` and `SymTridiagonal`\n        based on recurrence relations between principal minors ([#5358])\n\n      * specialized `transpose`, `ctranspose`, `istril`, `istriu` methods for\n        `Triangular` ([#5255]) and `Bidiagonal` ([#5277])\n\n      * new LAPACK wrappers\n        - condition number estimate `cond(A::Triangular)` ([#5255])\n\n      * parametrize `Triangular` on matrix type ([#7064])\n\n      * Lyapunov / Sylvester solver ([#7435])\n\n      * `eigvals` for `Symmetric`, `Tridiagonal` and `Hermitian` matrices now\n        support additional method signatures: ([#3688], [#6652], [#6678], [#7647])\n        - `eigvals(M, el, eu)` finds all eigenvalues in the interval `(el, eu]`\n        - `eigvals(M, il:iu)` finds the `il`th through the `iu`th eigenvalues (in ascending order)\n\n    * Dense linear algebra for generic matrix element types\n\n      * LU factorization ([#5381] and [#5430])\n\n      * QR factorization ([#5526])\n\n  * New function `deleteat!` deletes a specified index or indices and\n    returns the updated collection\n\n  * The `setenv` function for external processes now accepts a `dir` keyword\n    argument for specifying the directory to start the child process in ([#4888]).\n\n  * Constructors for collections (`Set`, `Dict`, etc.) now generally accept a\n    single iterable argument giving the elements of the collection ([#4996], [#4871])\n\n  * Ranges and arrays with the same elements are now unequal. This allows hashing\n    and comparing ranges to be faster ([#5778]).\n\n  * Broadcasting now works on arbitrary `AbstractArrays` ([#5387])\n\n  * Reduction functions that accept a pre-allocated output array, including\n    `sum!`, `prod!`, `maximum!`, `minimum!`, `all!`, `any!` ([#6197], [#5387])\n\n  * Faster performance on `fill!` and `copy!` for array types not supporting\n    efficient linear indexing ([#5671], [#5387])\n\n  * Changes to range types ([#5585])\n\n    * `Range` is now the abstract range type, instead of `Ranges`\n\n    * New function `range` for constructing ranges by length\n\n    * `Range` is now `StepRange`, and `Range1` is now `UnitRange`. Their\n      constructors accept end points instead of lengths. Both are subtypes of a\n      new abstract type `OrdinalRange`.\n\n    * Ranges now support `BigInt` and general ordinal types.\n\n    * Very large ranges (e.g. `0:typemax(Int)`) can now be constructed, but some\n      operations (e.g. `length`) will raise an `OverflowError`.\n\n  * Extended API for `cov` and `cor`, which accept keyword arguments `vardim`,\n    `corrected`, and `mean` ([#6273])\n\n  * New functions `randsubseq` and `randsubseq!` to create a random subsequence of an array ([#6726])\n\n  * New macro `@evalpoly` for efficient inline evaluation of polynomials ([#7146]).\n\n  * The signal filtering function `filt` now accepts an optional initial filter state vector. A new in-place function `filt!` is also exported ([#7513]).\n\n  * Significantly faster `cumsum` and `cumprod` ([#7359]).\n\n  * Implement `findmin` and `findmax` over specified array dimensions ([#6716]).\n\n  * Support memory-mapping of files with offsets on Windows ([#7242]).\n\n  * Catch writes to protect memory, such as when trying to modify a mmapped file opened in read-only mode ([#3434]).\n\nEnvironment improvements\n------------------------\n\n  * New `--code-coverage` and `--track-allocation` startup features allow one to measure the number of executions or the amount of memory allocated, respectively, at each line of code ([#5423],[#7464]).\n\n  * `Profile.init` now accepts keyword arguments, and returns the current settings when no arguments are supplied ([#7365]).\n\nBuild improvements\n------------------\n\n  * Dependencies are now verified against stored MD5/SHA512 hashes, to ensure\n    that the correct file has been downloaded and was not modified ([#6773]).\n\n\nDeprecated or removed\n---------------------\n\n  * `convert(Ptr{T1}, x::Array{T2})` is now deprecated unless `T1 == T2`\n    or `T1 == Void` ([#6073]).  (You can still explicitly `convert`\n    one pointer type into another if needed.)\n\n  * `Sys.shlib_ext` has been renamed to `Sys.dlext`\n\n  * `dense` is deprecated in favor of `full` ([#4759]).\n\n  * The `Stat` type is renamed `StatStruct` ([#4670]).\n\n  * `setrounding`, `rounding` and `setrounding` now take an additional\n    argument specifying the floating point type to which they apply. The old\n    behaviour and `[get/set/with]_bigfloat_rounding` functions are deprecated ([#5007]).\n\n  * `cholpfact` and `qrpfact` are deprecated in favor of keyword arguments in\n    `cholfact(..., pivot=true)` and `qrfact(..., pivot=true)` ([#5330]).\n\n  * `symmetrize!` is deprecated in favor of `Base.LinAlg.copytri!` ([#5427]).\n\n  * `myindexes` has been renamed to `localindexes` ([#5475]).\n\n  * `factorize!` is deprecated in favor of `factorize` ([#5526]).\n\n  * `nnz` counts the number of structural nonzeros in a sparse\n    matrix. Use `countnz` for the actual number of nonzeros ([#6769]).\n\n  * `setfield` is renamed `setfield!` ([#5748]).\n\n  * `put` and `take` are renamed `put!` and `take!` ([#5511]).\n\n  * `put!` now returns its first argument, the remote reference ([#5819]).\n\n  * `read` methods that modify a passed array are now called `read!` ([#5970])\n\n  * `infs` and `nans` are deprecated in favor of the more general `fill`.\n\n  * `*` and `div` are no longer supported for `Char`.\n\n  * `Range` is renamed `StepRange` and `Range1` is renamed `UnitRange`.\n    `Ranges` is renamed `Range`.\n\n  * `bitmix` is replaced by a 2-argument form of `hash`.\n\n  * `readsfrom` and `writesto` are replaced by `open` ([#6948]).\n\n  * `insert!` now throws a `BoundsError` if\n    `index > length(collection)+1` ([#7373]).\n\n  * No longer exported from `Base`:\n    * `start_reading`, `stop_reading`, `start_watching` ([#10885]).\n\nJulia v0.2.0 Release Notes\n==========================\n\nThe 0.2 release brings improvements to many areas of Julia. Among the\nmost visible changes are support for 64-bit Windows, keyword arguments\nto functions, immutable types, a redesigned and polished package\nmanager, a multimedia interface supporting usage of Julia in IPython,\na built-in profiler, and major improvements to Julia's linear algebra,\nI/O, and parallel capabilities. These are accompanied by many other\nchanges adding new features, enhancing the library's consistency,\nimproving performance, increasing test coverage, easing installation,\nand expanding the documentation. While not part of Julia proper, the\npackage ecosystem has also grown and matured considerably since the\n0.1 release. See below for more information about the long list of\nchanges that improve Julia's usability and performance.\n\nNew language features\n---------------------\n\n  * Keyword & optional function arguments ([#485], [#1817]).\n\n  * Immutable types ([#13]).\n\n  * Triple-quoted string literals ([#70]).\n\n  * New infix operator `in` (e.g. `x in S`), and corresponding function\n    `in(x,S)`, replacing `contains(S,x)` function ([#2703]).\n\n  * New variable bindings on each for loop and comprehension iteration ([#1571]).\n    For example, before this change:\n\n        julia> map(f->f(), { ()->i for i=1:3 })\n        3-element Any Array:\n         3\n         3\n         3\n\n    and after:\n\n        julia> map(f->f(), { ()->i for i=1:3 })\n        3-element Any Array:\n         1\n         2\n         3\n\n  * Explicit relative importing ([#2375]).\n\n  * Methods can be added to functions in other modules using dot syntax,\n    as in `Foo.bar(x) = 0`.\n\n  * `import module: name1, name2, ...` ([#5214]).\n\n  * A semicolon is now allowed after an `import` or `using` statement ([#4130]).\n\n  * In an interactive session (REPL), you can use `;cmd` to run `cmd` via an interactive\n    shell. For example:\n\n        julia> ;ls\n        CONTRIBUTING.md  Makefile           VERSION      cli/       deps/   julia@\n        DISTRIBUTING.md  NEWS.md            Windows.inc  doc/       src/    usr/\n        LICENSE.md       README.md          base/        etc/       test/\n        Make.inc         README.windows.md  contrib/     examples/  tmp/\n\nNew library functions\n---------------------\n\n  * Sampling profiler ([#2597]).\n\n  * Functions for examining stages of the compiler's output:\n    `code_lowered`, `code_typed`, `code_llvm`, and `code_native`.\n\n  * Multimedia I/O API (display, writemime, etcetera) ([#3932]).\n\n  * MPFR-based `BigFloat` ([#2814]), and many new `BigFloat` operations.\n\n  * New half-precision IEEE floating-point type, `Float16` ([#3467]).\n\n  * Support for setting floating-point rounding modes ([#3149]).\n\n  * `methodswith` shows all methods with an argument of specific type.\n\n  * `mapslices` provides a general way to perform operations on slices of arrays ([#2204]).\n\n  * `repeat` function for constructing Arrays with repeated elements ([#3605]).\n\n  * `Collections.PriorityQueue` type and `Collections.heap` functions ([#2920]).\n\n  * `quadgk` 1d-integration routine ([#3140]).\n\n  * `erfinv` and `erfcinv` functions ([#2987]).\n\n  * `varm`, `stdm` ([#2265]).\n\n  * `digamma`, `invdigamma`, `trigamma` and `polygamma` for calculating derivatives of `gamma` function ([#3233]).\n\n  * `logdet` ([#3070]).\n\n  * Names for C-compatible types: `Cchar`, `Clong`, etc. ([#2370]).\n\n  * `cglobal` to access global variables ([#1815]).\n\n  * `unsafe_pointer_to_objref` ([#2468]) and `pointer_from_objref` ([#2515]).\n\n  * `readandwrite` for external processes.\n\n  * I/O functions `readbytes` and `readbytes!` ([#3878]).\n\n  * `flush_cstdio` function ([#3949]).\n\n  * ClusterManager makes it possible to support different types of compute clusters\n    ([#3649], [#4014]).\n\n  * `rmprocs` for removing processors from a parallel computing session.\n    The system can also tolerate to some extent processors that die unexpectedly\n    ([#3050]).\n\n  * `interrupt` for interrupting worker processes ([#3819]).\n\n  * `timedwait` does a polled wait for an event till a specified timeout.\n\n  * `Condition` type with `wait` and `notify` functions for `Task` synchronization.\n\n  * `versioninfo` provides detailed version information, especially useful when\n    reporting and diagnosing bugs.\n\n  * `detach` for running child processes in a separate process group.\n\n  * `setenv` for passing environment variables to child processes.\n\n  * `ifelse` eagerly-evaluated conditional function, especially useful for\n    vectorized conditionals.\n\nLibrary improvements\n--------------------\n\n  * `isequal` now returns `false` for numbers of different types.\n    This makes it much easier to define hashing for new numeric types.\n    Uses of `Dict` with numeric keys might need to change\n    to account for this increased strictness.\n\n  * A redesigned and rewritten `Pkg` system is much more robust in case of problems.\n    The basic interface to adding and removing package requirements remains the\n    same, but great deal of additional functionality for developing packages in-place\n    was added. See the new [packages chapter] in the manual for further details.\n\n  * Sorting API updates ([#3665]) \u2013 see [sorting functions].\n\n  * The `delete!(d::Dict, key)` function has been split into separate `pop!`\n    and `delete!` functions ([#3439]).\n    `pop!(d,key)` removes `key` from `d` and returns the value that was associated with it;\n    it throws an exception if `d` does not contain `key`.\n    `delete!(d,key)` removes `key` from `d` and succeeds regardless of whether `d`\n    contained `key` or not, returning `d` itself in either case.\n\n  * Linear-algebra factorization routines (`lu`, `chol`, etc.) now return\n    `Factorization` objects (and `lud`, `chold`, etc. are deprecated; [#2212]).\n\n  * A number of improvements to sparse matrix capabilities and sparse linear algebra.\n\n  * More linear algebra fixes and eigensolver hooks\n    for `SymTridiagonal`, `Tridiagonal` and `Bidiagonal` matrix types\n    ([#2606], [#2608], [#2609], [#2611], [#2678], [#2713], [#2720], [#2725]).\n\n  * Change `integer_valued`, `real_valued`, and so on to `isinteger`, `isreal`,\n    and so on, and semantics of the later are now value-based rather than type-based,\n    unlike MATLAB/Octave ([#3071]). `isbool` and `iscomplex` are eliminated in favor\n    of a general `iseltype` function.\n\n  * Transitive comparison of floats with rationals ([#3102]).\n\n  * Fast prime generation with `primes` and fast primality testing with `isprime`.\n\n  * `sum` and `cumsum` now use [pairwise summation] for better accuracy ([#4039]).\n\n  * Dot operators (`.+`, `.*` etc.) now broadcast singleton dimensions of array arguments.\n    This behavior can be applied to any function using `broadcast(f, ...)`.\n\n  * `combinations`, `permutations`, and `partitions` now return iterators instead of a task,\n    and `integer_partitions` has been renamed to `partitions` ([#3989], [#4055]).\n\n  * `isreadable`/`iswritable` methods added for more IO types ([#3872]).\n\n  * Much faster and improved `readdlm` and `writedlm` ([#3350], [#3468], [#3483]).\n\n  * Faster `matchall` ([#3719]), and various string and regex improvements.\n\n  * Documentation of advanced linear algebra features ([#2807]).\n\n  * Support optional RTLD flags in `dlopen` ([#2380]).\n\n  * `pmap` now works with any iterable collection.\n\n  * Options in `pmap` for retrying or ignoring failed tasks.\n\n  * New `sinpi(x)` and `cospi(x)` functions to compute sine and cosine of `pi*x`\n    more accurately ([#4112]).\n\n  * New implementations of elementary complex functions\n    `sqrt`, `log`, `asin`, `acos`, `atan`, `tanh`, `asinh`, `acosh`, `atanh`\n    with correct branch cuts ([#2891]).\n\n  * Improved behavior of `SubArray` ([#4412], [#4284], [#4044], [#3697], [#3790],\n    [#3148], [#2844], [#2644] and various other fixes).\n\n  * New convenience functions in graphics API.\n\n  * Improved backtraces on Windows and OS X.\n\n  * Implementation of reduction functions (including `reduce`, `mapreduce`, `sum`, `prod`,\n    `maximum`, `minimum`, `all`, and `any`) are refactored, with improved type stability,\n    efficiency, and consistency ([#6116], [#7035], [#7061], [#7106]).\n\nDeprecated or removed\n---------------------\n\n  * Methods of `min` and `max` that do reductions were renamed to\n    `minimum` and `maximum`. `min(x)` is now `minimum(x)`, and\n    `min(x,(),dim)` is now `minimum(x,dim)` ([#4235]).\n\n  * `ComplexPair` was renamed to `Complex` and made `immutable`,\n    and `Complex128` and so on are now aliases to the new `Complex` type.\n\n  * `!` was added to the name of many mutating functions,\n    e.g., `push` was renamed `push!` ([#907]).\n\n  * `ref` renamed to `getindex`, and `assign` to `setindex!` ([#1484]).\n\n  * `writeable` renamed to `writable` ([#3874]).\n\n  * `logb` and `ilogb` renamed to `exponent` ([#2516]).\n\n  * `quote_string` became a method of `repr`.\n\n  * `safe_char`, `check_ascii`, and `check_utf8` replaced by\n    `is_valid_char`, `is_valid_ascii`, and `is_valid_utf8`, respectively.\n\n  * `each_line`, `each_match`, `begins_with`, `ends_with`, `parse_float`,\n    `parse_int`, and `seek_end` replaced by: `eachline`, `eachmatch`, and so on\n    (`_` was removed) ([#1539]).\n\n  * `parse_bin(s)` replaced by `parseint(s,2)`;\n    `parse_oct(s)` replaced by `parseint(s,8)`;\n    `parse_hex(s)` replaced by `parseint(s,16)`.\n\n  * `findn_nzs` replaced by `findnz` ([#1539]).\n\n  * `DivideByZeroError` replaced by `DivideError`.\n\n  * `addprocs_ssh`, `addprocs_ssh_tunnel`, and `addprocs_local`\n    replaced by `addprocs` (with keyword options).\n\n  * `remote_call`, `remote_call_fetch`, and `remote_call_wait`\n    replaced by `remotecall`, `remotecall_fetch`, and `remotecall_wait`.\n\n  * `has` replaced by `in` for sets and by `haskey` for dictionaries.\n\n  * `diagmm` and `diagmm!` replaced by `scale` and `scale!` ([#2916]).\n\n  * `unsafe_ref` and `unsafe_assign` replaced by `unsafe_load` and `unsafe_store!`.\n\n  * `add_each!` and `del_each!` replaced by `union!` and `setdiff!`.\n\n  * `isdenormal` renamed to `issubnormal` ([#3105]).\n\n  * `expr` replaced by direct call to `Expr` constructor.\n\n  * `|`, `&`, `$`, `-`, and `~` for sets replaced by\n    `union`, `intersect`, `symdiff`, `setdiff`, and `complement` ([#3272]).\n\n  * `square` function removed.\n\n  * `pascal` function removed.\n\n  * `add` and `add!` for `Set` replaced by `push!`.\n\n  * `ls` function deprecated in favor of `readdir` or `;ls` in the REPL.\n\n  * `start_timer` now expects arguments in units of seconds, not milliseconds.\n\n  * Shell redirection operators `|`, `>`, and `<` eliminated in favor of a new\n    operator `|>` ([#3523]).\n\n  * `amap` is deprecated in favor of new `mapslices` functionality.\n\n  * The `Reverse` iterator was removed since it did not work in many cases.\n\n  * The `gcd` function now returns a non-negative value regardless of\n    the argument signs, and various other sign problems with `invmod`,\n    `lcm`, `gcdx`, and `powermod` were fixed ([#4811]).\n\nMiscellaneous changes\n---------------------\n\n  * `julia-release-*` executables renamed to `julia-*`,\n    and `libjulia-release` renamed to `libjulia` ([#4177]).\n\n  * Packages will now be installed in `.julia/vX.Y`, where\n    X.Y is the current Julia version.\n\nBugfixes and performance updates\n--------------------------------\n\nToo numerous to mention.\n\n[packages chapter]: https://docs.julialang.org/en/v1/stdlib/Pkg/\n[sorting functions]: https://docs.julialang.org/en/v1/base/sort/\n[pairwise summation]: https://en.wikipedia.org/wiki/Pairwise_summation\n[a448e080]: https://github.com/JuliaLang/julia/commit/a448e080dc736c7fb326426dfcb2528be36973d3\n[5e3f074b]: https://github.com/JuliaLang/julia/commit/5e3f074b9173044a0a4219f9b285879ff7cec041\n<!--- generated by NEWS-update.jl: -->\n[#13]: https://github.com/JuliaLang/julia/issues/13\n[#69]: https://github.com/JuliaLang/julia/issues/69\n[#70]: https://github.com/JuliaLang/julia/issues/70\n[#101]: https://github.com/JuliaLang/julia/issues/101\n[#265]: https://github.com/JuliaLang/julia/issues/265\n[#485]: https://github.com/JuliaLang/julia/issues/485\n[#550]: https://github.com/JuliaLang/julia/issues/550\n[#552]: https://github.com/JuliaLang/julia/issues/552\n[#907]: https://github.com/JuliaLang/julia/issues/907\n[#964]: https://github.com/JuliaLang/julia/issues/964\n[#987]: https://github.com/JuliaLang/julia/issues/987\n[#1090]: https://github.com/JuliaLang/julia/issues/1090\n[#1195]: https://github.com/JuliaLang/julia/issues/1195\n[#1268]: https://github.com/JuliaLang/julia/issues/1268\n[#1470]: https://github.com/JuliaLang/julia/issues/1470\n[#1484]: https://github.com/JuliaLang/julia/issues/1484\n[#1539]: https://github.com/JuliaLang/julia/issues/1539\n[#1571]: https://github.com/JuliaLang/julia/issues/1571\n[#1815]: https://github.com/JuliaLang/julia/issues/1815\n[#1817]: https://github.com/JuliaLang/julia/issues/1817\n[#2204]: https://github.com/JuliaLang/julia/issues/2204\n[#2212]: https://github.com/JuliaLang/julia/issues/2212\n[#2265]: https://github.com/JuliaLang/julia/issues/2265\n[#2333]: https://github.com/JuliaLang/julia/issues/2333\n[#2345]: https://github.com/JuliaLang/julia/issues/2345\n[#2370]: https://github.com/JuliaLang/julia/issues/2370\n[#2375]: https://github.com/JuliaLang/julia/issues/2375\n[#2380]: https://github.com/JuliaLang/julia/issues/2380\n[#2403]: https://github.com/JuliaLang/julia/issues/2403\n[#2468]: https://github.com/JuliaLang/julia/issues/2468\n[#2488]: https://github.com/JuliaLang/julia/issues/2488\n[#2515]: https://github.com/JuliaLang/julia/issues/2515\n[#2516]: https://github.com/JuliaLang/julia/issues/2516\n[#2597]: https://github.com/JuliaLang/julia/issues/2597\n[#2606]: https://github.com/JuliaLang/julia/issues/2606\n[#2608]: https://github.com/JuliaLang/julia/issues/2608\n[#2609]: https://github.com/JuliaLang/julia/issues/2609\n[#2611]: https://github.com/JuliaLang/julia/issues/2611\n[#2644]: https://github.com/JuliaLang/julia/issues/2644\n[#2678]: https://github.com/JuliaLang/julia/issues/2678\n[#2703]: https://github.com/JuliaLang/julia/issues/2703\n[#2713]: https://github.com/JuliaLang/julia/issues/2713\n[#2720]: https://github.com/JuliaLang/julia/issues/2720\n[#2725]: https://github.com/JuliaLang/julia/issues/2725\n[#2807]: https://github.com/JuliaLang/julia/issues/2807\n[#2814]: https://github.com/JuliaLang/julia/issues/2814\n[#2844]: https://github.com/JuliaLang/julia/issues/2844\n[#2891]: https://github.com/JuliaLang/julia/issues/2891\n[#2916]: https://github.com/JuliaLang/julia/issues/2916\n[#2920]: https://github.com/JuliaLang/julia/issues/2920\n[#2987]: https://github.com/JuliaLang/julia/issues/2987\n[#3050]: https://github.com/JuliaLang/julia/issues/3050\n[#3070]: https://github.com/JuliaLang/julia/issues/3070\n[#3071]: https://github.com/JuliaLang/julia/issues/3071\n[#3102]: https://github.com/JuliaLang/julia/issues/3102\n[#3105]: https://github.com/JuliaLang/julia/issues/3105\n[#3140]: https://github.com/JuliaLang/julia/issues/3140\n[#3141]: https://github.com/JuliaLang/julia/issues/3141\n[#3148]: https://github.com/JuliaLang/julia/issues/3148\n[#3149]: https://github.com/JuliaLang/julia/issues/3149\n[#3214]: https://github.com/JuliaLang/julia/issues/3214\n[#3233]: https://github.com/JuliaLang/julia/issues/3233\n[#3272]: https://github.com/JuliaLang/julia/issues/3272\n[#3344]: https://github.com/JuliaLang/julia/issues/3344\n[#3350]: https://github.com/JuliaLang/julia/issues/3350\n[#3434]: https://github.com/JuliaLang/julia/issues/3434\n[#3439]: https://github.com/JuliaLang/julia/issues/3439\n[#3467]: https://github.com/JuliaLang/julia/issues/3467\n[#3468]: https://github.com/JuliaLang/julia/issues/3468\n[#3483]: https://github.com/JuliaLang/julia/issues/3483\n[#3523]: https://github.com/JuliaLang/julia/issues/3523\n[#3605]: https://github.com/JuliaLang/julia/issues/3605\n[#3631]: https://github.com/JuliaLang/julia/issues/3631\n[#3649]: https://github.com/JuliaLang/julia/issues/3649\n[#3665]: https://github.com/JuliaLang/julia/issues/3665\n[#3688]: https://github.com/JuliaLang/julia/issues/3688\n[#3697]: https://github.com/JuliaLang/julia/issues/3697\n[#3719]: https://github.com/JuliaLang/julia/issues/3719\n[#3721]: https://github.com/JuliaLang/julia/issues/3721\n[#3737]: https://github.com/JuliaLang/julia/issues/3737\n[#3759]: https://github.com/JuliaLang/julia/issues/3759\n[#3790]: https://github.com/JuliaLang/julia/issues/3790\n[#3819]: https://github.com/JuliaLang/julia/issues/3819\n[#3872]: https://github.com/JuliaLang/julia/issues/3872\n[#3874]: https://github.com/JuliaLang/julia/issues/3874\n[#3878]: https://github.com/JuliaLang/julia/issues/3878\n[#3932]: https://github.com/JuliaLang/julia/issues/3932\n[#3949]: https://github.com/JuliaLang/julia/issues/3949\n[#3989]: https://github.com/JuliaLang/julia/issues/3989\n[#4014]: https://github.com/JuliaLang/julia/issues/4014\n[#4026]: https://github.com/JuliaLang/julia/issues/4026\n[#4039]: https://github.com/JuliaLang/julia/issues/4039\n[#4042]: https://github.com/JuliaLang/julia/issues/4042\n[#4044]: https://github.com/JuliaLang/julia/issues/4044\n[#4048]: https://github.com/JuliaLang/julia/issues/4048\n[#4055]: https://github.com/JuliaLang/julia/issues/4055\n[#4112]: https://github.com/JuliaLang/julia/issues/4112\n[#4130]: https://github.com/JuliaLang/julia/issues/4130\n[#4163]: https://github.com/JuliaLang/julia/issues/4163\n[#4177]: https://github.com/JuliaLang/julia/issues/4177\n[#4211]: https://github.com/JuliaLang/julia/issues/4211\n[#4235]: https://github.com/JuliaLang/julia/issues/4235\n[#4284]: https://github.com/JuliaLang/julia/issues/4284\n[#4383]: https://github.com/JuliaLang/julia/issues/4383\n[#4412]: https://github.com/JuliaLang/julia/issues/4412\n[#4470]: https://github.com/JuliaLang/julia/issues/4470\n[#4615]: https://github.com/JuliaLang/julia/issues/4615\n[#4670]: https://github.com/JuliaLang/julia/issues/4670\n[#4759]: https://github.com/JuliaLang/julia/issues/4759\n[#4766]: https://github.com/JuliaLang/julia/issues/4766\n[#4775]: https://github.com/JuliaLang/julia/issues/4775\n[#4782]: https://github.com/JuliaLang/julia/issues/4782\n[#4799]: https://github.com/JuliaLang/julia/issues/4799\n[#4806]: https://github.com/JuliaLang/julia/issues/4806\n[#4811]: https://github.com/JuliaLang/julia/issues/4811\n[#4819]: https://github.com/JuliaLang/julia/issues/4819\n[#4862]: https://github.com/JuliaLang/julia/issues/4862\n[#4867]: https://github.com/JuliaLang/julia/issues/4867\n[#4870]: https://github.com/JuliaLang/julia/issues/4870\n[#4871]: https://github.com/JuliaLang/julia/issues/4871\n[#4874]: https://github.com/JuliaLang/julia/issues/4874\n[#4882]: https://github.com/JuliaLang/julia/issues/4882\n[#4888]: https://github.com/JuliaLang/julia/issues/4888\n[#4923]: https://github.com/JuliaLang/julia/issues/4923\n[#4930]: https://github.com/JuliaLang/julia/issues/4930\n[#4934]: https://github.com/JuliaLang/julia/issues/4934\n[#4943]: https://github.com/JuliaLang/julia/issues/4943\n[#4958]: https://github.com/JuliaLang/julia/issues/4958\n[#4967]: https://github.com/JuliaLang/julia/issues/4967\n[#4996]: https://github.com/JuliaLang/julia/issues/4996\n[#5007]: https://github.com/JuliaLang/julia/issues/5007\n[#5025]: https://github.com/JuliaLang/julia/issues/5025\n[#5059]: https://github.com/JuliaLang/julia/issues/5059\n[#5076]: https://github.com/JuliaLang/julia/issues/5076\n[#5154]: https://github.com/JuliaLang/julia/issues/5154\n[#5164]: https://github.com/JuliaLang/julia/issues/5164\n[#5196]: https://github.com/JuliaLang/julia/issues/5196\n[#5214]: https://github.com/JuliaLang/julia/issues/5214\n[#5227]: https://github.com/JuliaLang/julia/issues/5227\n[#5255]: https://github.com/JuliaLang/julia/issues/5255\n[#5263]: https://github.com/JuliaLang/julia/issues/5263\n[#5275]: https://github.com/JuliaLang/julia/issues/5275\n[#5277]: https://github.com/JuliaLang/julia/issues/5277\n[#5330]: https://github.com/JuliaLang/julia/issues/5330\n[#5349]: https://github.com/JuliaLang/julia/issues/5349\n[#5358]: https://github.com/JuliaLang/julia/issues/5358\n[#5380]: https://github.com/JuliaLang/julia/issues/5380\n[#5381]: https://github.com/JuliaLang/julia/issues/5381\n[#5387]: https://github.com/JuliaLang/julia/issues/5387\n[#5403]: https://github.com/JuliaLang/julia/issues/5403\n[#5413]: https://github.com/JuliaLang/julia/issues/5413\n[#5423]: https://github.com/JuliaLang/julia/issues/5423\n[#5427]: https://github.com/JuliaLang/julia/issues/5427\n[#5428]: https://github.com/JuliaLang/julia/issues/5428\n[#5430]: https://github.com/JuliaLang/julia/issues/5430\n[#5462]: https://github.com/JuliaLang/julia/issues/5462\n[#5464]: https://github.com/JuliaLang/julia/issues/5464\n[#5468]: https://github.com/JuliaLang/julia/issues/5468\n[#5475]: https://github.com/JuliaLang/julia/issues/5475\n[#5511]: https://github.com/JuliaLang/julia/issues/5511\n[#5526]: https://github.com/JuliaLang/julia/issues/5526\n[#5545]: https://github.com/JuliaLang/julia/issues/5545\n[#5576]: https://github.com/JuliaLang/julia/issues/5576\n[#5585]: https://github.com/JuliaLang/julia/issues/5585\n[#5636]: https://github.com/JuliaLang/julia/issues/5636\n[#5671]: https://github.com/JuliaLang/julia/issues/5671\n[#5677]: https://github.com/JuliaLang/julia/issues/5677\n[#5703]: https://github.com/JuliaLang/julia/issues/5703\n[#5704]: https://github.com/JuliaLang/julia/issues/5704\n[#5726]: https://github.com/JuliaLang/julia/issues/5726\n[#5737]: https://github.com/JuliaLang/julia/issues/5737\n[#5748]: https://github.com/JuliaLang/julia/issues/5748\n[#5776]: https://github.com/JuliaLang/julia/issues/5776\n[#5778]: https://github.com/JuliaLang/julia/issues/5778\n[#5810]: https://github.com/JuliaLang/julia/issues/5810\n[#5811]: https://github.com/JuliaLang/julia/issues/5811\n[#5819]: https://github.com/JuliaLang/julia/issues/5819\n[#5827]: https://github.com/JuliaLang/julia/issues/5827\n[#5832]: https://github.com/JuliaLang/julia/issues/5832\n[#5927]: https://github.com/JuliaLang/julia/issues/5927\n[#5936]: https://github.com/JuliaLang/julia/issues/5936\n[#5939]: https://github.com/JuliaLang/julia/issues/5939\n[#5970]: https://github.com/JuliaLang/julia/issues/5970\n[#6056]: https://github.com/JuliaLang/julia/issues/6056\n[#6057]: https://github.com/JuliaLang/julia/issues/6057\n[#6073]: https://github.com/JuliaLang/julia/issues/6073\n[#6081]: https://github.com/JuliaLang/julia/issues/6081\n[#6116]: https://github.com/JuliaLang/julia/issues/6116\n[#6128]: https://github.com/JuliaLang/julia/issues/6128\n[#6169]: https://github.com/JuliaLang/julia/issues/6169\n[#6179]: https://github.com/JuliaLang/julia/issues/6179\n[#6190]: https://github.com/JuliaLang/julia/issues/6190\n[#6197]: https://github.com/JuliaLang/julia/issues/6197\n[#6211]: https://github.com/JuliaLang/julia/issues/6211\n[#6212]: https://github.com/JuliaLang/julia/issues/6212\n[#6270]: https://github.com/JuliaLang/julia/issues/6270\n[#6273]: https://github.com/JuliaLang/julia/issues/6273\n[#6582]: https://github.com/JuliaLang/julia/issues/6582\n[#6624]: https://github.com/JuliaLang/julia/issues/6624\n[#6652]: https://github.com/JuliaLang/julia/issues/6652\n[#6678]: https://github.com/JuliaLang/julia/issues/6678\n[#6716]: https://github.com/JuliaLang/julia/issues/6716\n[#6726]: https://github.com/JuliaLang/julia/issues/6726\n[#6739]: https://github.com/JuliaLang/julia/issues/6739\n[#6769]: https://github.com/JuliaLang/julia/issues/6769\n[#6773]: https://github.com/JuliaLang/julia/issues/6773\n[#6842]: https://github.com/JuliaLang/julia/issues/6842\n[#6911]: https://github.com/JuliaLang/julia/issues/6911\n[#6920]: https://github.com/JuliaLang/julia/issues/6920\n[#6929]: https://github.com/JuliaLang/julia/issues/6929\n[#6948]: https://github.com/JuliaLang/julia/issues/6948\n[#7016]: https://github.com/JuliaLang/julia/issues/7016\n[#7035]: https://github.com/JuliaLang/julia/issues/7035\n[#7047]: https://github.com/JuliaLang/julia/issues/7047\n[#7061]: https://github.com/JuliaLang/julia/issues/7061\n[#7064]: https://github.com/JuliaLang/julia/issues/7064\n[#7071]: https://github.com/JuliaLang/julia/issues/7071\n[#7094]: https://github.com/JuliaLang/julia/issues/7094\n[#7106]: https://github.com/JuliaLang/julia/issues/7106\n[#7125]: https://github.com/JuliaLang/julia/issues/7125\n[#7131]: https://github.com/JuliaLang/julia/issues/7131\n[#7146]: https://github.com/JuliaLang/julia/issues/7146\n[#7234]: https://github.com/JuliaLang/julia/issues/7234\n[#7236]: https://github.com/JuliaLang/julia/issues/7236\n[#7242]: https://github.com/JuliaLang/julia/issues/7242\n[#7258]: https://github.com/JuliaLang/julia/issues/7258\n[#7264]: https://github.com/JuliaLang/julia/issues/7264\n[#7311]: https://github.com/JuliaLang/julia/issues/7311\n[#7359]: https://github.com/JuliaLang/julia/issues/7359\n[#7365]: https://github.com/JuliaLang/julia/issues/7365\n[#7373]: https://github.com/JuliaLang/julia/issues/7373\n[#7390]: https://github.com/JuliaLang/julia/issues/7390\n[#7435]: https://github.com/JuliaLang/julia/issues/7435\n[#7464]: https://github.com/JuliaLang/julia/issues/7464\n[#7513]: https://github.com/JuliaLang/julia/issues/7513\n[#7616]: https://github.com/JuliaLang/julia/issues/7616\n[#7647]: https://github.com/JuliaLang/julia/issues/7647\n[#7654]: https://github.com/JuliaLang/julia/issues/7654\n[#7669]: https://github.com/JuliaLang/julia/issues/7669\n[#7704]: https://github.com/JuliaLang/julia/issues/7704\n[#7917]: https://github.com/JuliaLang/julia/issues/7917\n[#7992]: https://github.com/JuliaLang/julia/issues/7992\n[#8011]: https://github.com/JuliaLang/julia/issues/8011\n[#8036]: https://github.com/JuliaLang/julia/issues/8036\n[#8089]: https://github.com/JuliaLang/julia/issues/8089\n[#8113]: https://github.com/JuliaLang/julia/issues/8113\n[#8135]: https://github.com/JuliaLang/julia/issues/8135\n[#8152]: https://github.com/JuliaLang/julia/issues/8152\n[#8246]: https://github.com/JuliaLang/julia/issues/8246\n[#8283]: https://github.com/JuliaLang/julia/issues/8283\n[#8297]: https://github.com/JuliaLang/julia/issues/8297\n[#8320]: https://github.com/JuliaLang/julia/issues/8320\n[#8399]: https://github.com/JuliaLang/julia/issues/8399\n[#8423]: https://github.com/JuliaLang/julia/issues/8423\n[#8432]: https://github.com/JuliaLang/julia/issues/8432\n[#8467]: https://github.com/JuliaLang/julia/issues/8467\n[#8501]: https://github.com/JuliaLang/julia/issues/8501\n[#8560]: https://github.com/JuliaLang/julia/issues/8560\n[#8578]: https://github.com/JuliaLang/julia/issues/8578\n[#8599]: https://github.com/JuliaLang/julia/issues/8599\n[#8605]: https://github.com/JuliaLang/julia/issues/8605\n[#8624]: https://github.com/JuliaLang/julia/issues/8624\n[#8660]: https://github.com/JuliaLang/julia/issues/8660\n[#8672]: https://github.com/JuliaLang/julia/issues/8672\n[#8712]: https://github.com/JuliaLang/julia/issues/8712\n[#8734]: https://github.com/JuliaLang/julia/issues/8734\n[#8745]: https://github.com/JuliaLang/julia/issues/8745\n[#8750]: https://github.com/JuliaLang/julia/issues/8750\n[#8776]: https://github.com/JuliaLang/julia/issues/8776\n[#8791]: https://github.com/JuliaLang/julia/issues/8791\n[#8792]: https://github.com/JuliaLang/julia/issues/8792\n[#8808]: https://github.com/JuliaLang/julia/issues/8808\n[#8814]: https://github.com/JuliaLang/julia/issues/8814\n[#8816]: https://github.com/JuliaLang/julia/issues/8816\n[#8827]: https://github.com/JuliaLang/julia/issues/8827\n[#8832]: https://github.com/JuliaLang/julia/issues/8832\n[#8845]: https://github.com/JuliaLang/julia/issues/8845\n[#8846]: https://github.com/JuliaLang/julia/issues/8846\n[#8854]: https://github.com/JuliaLang/julia/issues/8854\n[#8867]: https://github.com/JuliaLang/julia/issues/8867\n[#8872]: https://github.com/JuliaLang/julia/issues/8872\n[#8897]: https://github.com/JuliaLang/julia/issues/8897\n[#8905]: https://github.com/JuliaLang/julia/issues/8905\n[#8941]: https://github.com/JuliaLang/julia/issues/8941\n[#8958]: https://github.com/JuliaLang/julia/issues/8958\n[#8974]: https://github.com/JuliaLang/julia/issues/8974\n[#9017]: https://github.com/JuliaLang/julia/issues/9017\n[#9049]: https://github.com/JuliaLang/julia/issues/9049\n[#9065]: https://github.com/JuliaLang/julia/issues/9065\n[#9083]: https://github.com/JuliaLang/julia/issues/9083\n[#9105]: https://github.com/JuliaLang/julia/issues/9105\n[#9122]: https://github.com/JuliaLang/julia/issues/9122\n[#9126]: https://github.com/JuliaLang/julia/issues/9126\n[#9132]: https://github.com/JuliaLang/julia/issues/9132\n[#9133]: https://github.com/JuliaLang/julia/issues/9133\n[#9144]: https://github.com/JuliaLang/julia/issues/9144\n[#9198]: https://github.com/JuliaLang/julia/issues/9198\n[#9249]: https://github.com/JuliaLang/julia/issues/9249\n[#9261]: https://github.com/JuliaLang/julia/issues/9261\n[#9271]: https://github.com/JuliaLang/julia/issues/9271\n[#9294]: https://github.com/JuliaLang/julia/issues/9294\n[#9309]: https://github.com/JuliaLang/julia/issues/9309\n[#9343]: https://github.com/JuliaLang/julia/issues/9343\n[#9418]: https://github.com/JuliaLang/julia/issues/9418\n[#9425]: https://github.com/JuliaLang/julia/issues/9425\n[#9434]: https://github.com/JuliaLang/julia/issues/9434\n[#9452]: https://github.com/JuliaLang/julia/issues/9452\n[#9482]: https://github.com/JuliaLang/julia/issues/9482\n[#9487]: https://github.com/JuliaLang/julia/issues/9487\n[#9503]: https://github.com/JuliaLang/julia/issues/9503\n[#9569]: https://github.com/JuliaLang/julia/issues/9569\n[#9575]: https://github.com/JuliaLang/julia/issues/9575\n[#9578]: https://github.com/JuliaLang/julia/issues/9578\n[#9597]: https://github.com/JuliaLang/julia/issues/9597\n[#9627]: https://github.com/JuliaLang/julia/issues/9627\n[#9666]: https://github.com/JuliaLang/julia/issues/9666\n[#9690]: https://github.com/JuliaLang/julia/issues/9690\n[#9701]: https://github.com/JuliaLang/julia/issues/9701\n[#9714]: https://github.com/JuliaLang/julia/issues/9714\n[#9734]: https://github.com/JuliaLang/julia/issues/9734\n[#9745]: https://github.com/JuliaLang/julia/issues/9745\n[#9779]: https://github.com/JuliaLang/julia/issues/9779\n[#9862]: https://github.com/JuliaLang/julia/issues/9862\n[#9957]: https://github.com/JuliaLang/julia/issues/9957\n[#10008]: https://github.com/JuliaLang/julia/issues/10008\n[#10024]: https://github.com/JuliaLang/julia/issues/10024\n[#10031]: https://github.com/JuliaLang/julia/issues/10031\n[#10075]: https://github.com/JuliaLang/julia/issues/10075\n[#10117]: https://github.com/JuliaLang/julia/issues/10117\n[#10150]: https://github.com/JuliaLang/julia/issues/10150\n[#10168]: https://github.com/JuliaLang/julia/issues/10168\n[#10180]: https://github.com/JuliaLang/julia/issues/10180\n[#10228]: https://github.com/JuliaLang/julia/issues/10228\n[#10328]: https://github.com/JuliaLang/julia/issues/10328\n[#10331]: https://github.com/JuliaLang/julia/issues/10331\n[#10332]: https://github.com/JuliaLang/julia/issues/10332\n[#10333]: https://github.com/JuliaLang/julia/issues/10333\n[#10380]: https://github.com/JuliaLang/julia/issues/10380\n[#10400]: https://github.com/JuliaLang/julia/issues/10400\n[#10446]: https://github.com/JuliaLang/julia/issues/10446\n[#10458]: https://github.com/JuliaLang/julia/issues/10458\n[#10472]: https://github.com/JuliaLang/julia/issues/10472\n[#10525]: https://github.com/JuliaLang/julia/issues/10525\n[#10543]: https://github.com/JuliaLang/julia/issues/10543\n[#10548]: https://github.com/JuliaLang/julia/issues/10548\n[#10659]: https://github.com/JuliaLang/julia/issues/10659\n[#10679]: https://github.com/JuliaLang/julia/issues/10679\n[#10709]: https://github.com/JuliaLang/julia/issues/10709\n[#10714]: https://github.com/JuliaLang/julia/issues/10714\n[#10747]: https://github.com/JuliaLang/julia/issues/10747\n[#10844]: https://github.com/JuliaLang/julia/issues/10844\n[#10870]: https://github.com/JuliaLang/julia/issues/10870\n[#10885]: https://github.com/JuliaLang/julia/issues/10885\n[#10888]: https://github.com/JuliaLang/julia/issues/10888\n[#10893]: https://github.com/JuliaLang/julia/issues/10893\n[#10914]: https://github.com/JuliaLang/julia/issues/10914\n[#10946]: https://github.com/JuliaLang/julia/issues/10946\n[#10955]: https://github.com/JuliaLang/julia/issues/10955\n[#10994]: https://github.com/JuliaLang/julia/issues/10994\n[#11030]: https://github.com/JuliaLang/julia/issues/11030\n[#11067]: https://github.com/JuliaLang/julia/issues/11067\n[#11105]: https://github.com/JuliaLang/julia/issues/11105\n[#11145]: https://github.com/JuliaLang/julia/issues/11145\n[#11171]: https://github.com/JuliaLang/julia/issues/11171\n[#11196]: https://github.com/JuliaLang/julia/issues/11196\n[#11241]: https://github.com/JuliaLang/julia/issues/11241\n[#11242]: https://github.com/JuliaLang/julia/issues/11242\n[#11250]: https://github.com/JuliaLang/julia/issues/11250\n[#11279]: https://github.com/JuliaLang/julia/issues/11279\n[#11310]: https://github.com/JuliaLang/julia/issues/11310\n[#11347]: https://github.com/JuliaLang/julia/issues/11347\n[#11379]: https://github.com/JuliaLang/julia/issues/11379\n[#11432]: https://github.com/JuliaLang/julia/issues/11432\n[#11566]: https://github.com/JuliaLang/julia/issues/11566\n[#11686]: https://github.com/JuliaLang/julia/issues/11686\n[#11688]: https://github.com/JuliaLang/julia/issues/11688\n[#11741]: https://github.com/JuliaLang/julia/issues/11741\n[#11849]: https://github.com/JuliaLang/julia/issues/11849\n[#11891]: https://github.com/JuliaLang/julia/issues/11891\n[#11922]: https://github.com/JuliaLang/julia/issues/11922\n[#11947]: https://github.com/JuliaLang/julia/issues/11947\n[#11985]: https://github.com/JuliaLang/julia/issues/11985\n[#12025]: https://github.com/JuliaLang/julia/issues/12025\n[#12031]: https://github.com/JuliaLang/julia/issues/12031\n[#12034]: https://github.com/JuliaLang/julia/issues/12034\n[#12087]: https://github.com/JuliaLang/julia/issues/12087\n[#12137]: https://github.com/JuliaLang/julia/issues/12137\n[#12162]: https://github.com/JuliaLang/julia/issues/12162\n[#12231]: https://github.com/JuliaLang/julia/issues/12231\n[#12264]: https://github.com/JuliaLang/julia/issues/12264\n[#12274]: https://github.com/JuliaLang/julia/issues/12274\n[#12385]: https://github.com/JuliaLang/julia/issues/12385\n[#12393]: https://github.com/JuliaLang/julia/issues/12393\n[#12458]: https://github.com/JuliaLang/julia/issues/12458\n[#12472]: https://github.com/JuliaLang/julia/issues/12472\n[#12491]: https://github.com/JuliaLang/julia/issues/12491\n[#12563]: https://github.com/JuliaLang/julia/issues/12563\n[#12576]: https://github.com/JuliaLang/julia/issues/12576\n[#12727]: https://github.com/JuliaLang/julia/issues/12727\n[#12739]: https://github.com/JuliaLang/julia/issues/12739\n[#12819]: https://github.com/JuliaLang/julia/issues/12819\n[#12872]: https://github.com/JuliaLang/julia/issues/12872\n[#13062]: https://github.com/JuliaLang/julia/issues/13062\n[#13171]: https://github.com/JuliaLang/julia/issues/13171\n[#13232]: https://github.com/JuliaLang/julia/issues/13232\n[#13338]: https://github.com/JuliaLang/julia/issues/13338\n[#13387]: https://github.com/JuliaLang/julia/issues/13387\n[#13412]: https://github.com/JuliaLang/julia/issues/13412\n[#13440]: https://github.com/JuliaLang/julia/issues/13440\n[#13465]: https://github.com/JuliaLang/julia/issues/13465\n[#13480]: https://github.com/JuliaLang/julia/issues/13480\n[#13496]: https://github.com/JuliaLang/julia/issues/13496\n[#13542]: https://github.com/JuliaLang/julia/issues/13542\n[#13612]: https://github.com/JuliaLang/julia/issues/13612\n[#13680]: https://github.com/JuliaLang/julia/issues/13680\n[#13681]: https://github.com/JuliaLang/julia/issues/13681\n[#13707]: https://github.com/JuliaLang/julia/issues/13707\n[#13774]: https://github.com/JuliaLang/julia/issues/13774\n[#13780]: https://github.com/JuliaLang/julia/issues/13780\n[#13824]: https://github.com/JuliaLang/julia/issues/13824\n[#13825]: https://github.com/JuliaLang/julia/issues/13825\n[#13897]: https://github.com/JuliaLang/julia/issues/13897\n[#14052]: https://github.com/JuliaLang/julia/issues/14052\n[#14114]: https://github.com/JuliaLang/julia/issues/14114\n[#14140]: https://github.com/JuliaLang/julia/issues/14140\n[#14194]: https://github.com/JuliaLang/julia/issues/14194\n[#14243]: https://github.com/JuliaLang/julia/issues/14243\n[#14335]: https://github.com/JuliaLang/julia/issues/14335\n[#14413]: https://github.com/JuliaLang/julia/issues/14413\n[#14424]: https://github.com/JuliaLang/julia/issues/14424\n[#14458]: https://github.com/JuliaLang/julia/issues/14458\n[#14469]: https://github.com/JuliaLang/julia/issues/14469\n[#14474]: https://github.com/JuliaLang/julia/issues/14474\n[#14519]: https://github.com/JuliaLang/julia/issues/14519\n[#14608]: https://github.com/JuliaLang/julia/issues/14608\n[#14623]: https://github.com/JuliaLang/julia/issues/14623\n[#14660]: https://github.com/JuliaLang/julia/issues/14660\n[#14676]: https://github.com/JuliaLang/julia/issues/14676\n[#14759]: https://github.com/JuliaLang/julia/issues/14759\n[#14777]: https://github.com/JuliaLang/julia/issues/14777\n[#14798]: https://github.com/JuliaLang/julia/issues/14798\n[#15007]: https://github.com/JuliaLang/julia/issues/15007\n[#15032]: https://github.com/JuliaLang/julia/issues/15032\n[#15172]: https://github.com/JuliaLang/julia/issues/15172\n[#15192]: https://github.com/JuliaLang/julia/issues/15192\n[#15242]: https://github.com/JuliaLang/julia/issues/15242\n[#15244]: https://github.com/JuliaLang/julia/issues/15244\n[#15258]: https://github.com/JuliaLang/julia/issues/15258\n[#15409]: https://github.com/JuliaLang/julia/issues/15409\n[#15431]: https://github.com/JuliaLang/julia/issues/15431\n[#15524]: https://github.com/JuliaLang/julia/issues/15524\n[#15550]: https://github.com/JuliaLang/julia/issues/15550\n[#15609]: https://github.com/JuliaLang/julia/issues/15609\n[#15708]: https://github.com/JuliaLang/julia/issues/15708\n[#15731]: https://github.com/JuliaLang/julia/issues/15731\n[#15763]: https://github.com/JuliaLang/julia/issues/15763\n[#15804]: https://github.com/JuliaLang/julia/issues/15804\n[#15850]: https://github.com/JuliaLang/julia/issues/15850\n[#15975]: https://github.com/JuliaLang/julia/issues/15975\n[#16010]: https://github.com/JuliaLang/julia/issues/16010\n[#16024]: https://github.com/JuliaLang/julia/issues/16024\n[#16058]: https://github.com/JuliaLang/julia/issues/16058\n[#16071]: https://github.com/JuliaLang/julia/issues/16071\n[#16098]: https://github.com/JuliaLang/julia/issues/16098\n[#16107]: https://github.com/JuliaLang/julia/issues/16107\n[#16154]: https://github.com/JuliaLang/julia/issues/16154\n[#16213]: https://github.com/JuliaLang/julia/issues/16213\n[#16219]: https://github.com/JuliaLang/julia/issues/16219\n[#16260]: https://github.com/JuliaLang/julia/issues/16260\n[#16285]: https://github.com/JuliaLang/julia/issues/16285\n[#16362]: https://github.com/JuliaLang/julia/issues/16362\n[#16378]: https://github.com/JuliaLang/julia/issues/16378\n[#16403]: https://github.com/JuliaLang/julia/issues/16403\n[#16404]: https://github.com/JuliaLang/julia/issues/16404\n[#16450]: https://github.com/JuliaLang/julia/issues/16450\n[#16455]: https://github.com/JuliaLang/julia/issues/16455\n[#16466]: https://github.com/JuliaLang/julia/issues/16466\n[#16481]: https://github.com/JuliaLang/julia/issues/16481\n[#16502]: https://github.com/JuliaLang/julia/issues/16502\n[#16510]: https://github.com/JuliaLang/julia/issues/16510\n[#16600]: https://github.com/JuliaLang/julia/issues/16600\n[#16603]: https://github.com/JuliaLang/julia/issues/16603\n[#16621]: https://github.com/JuliaLang/julia/issues/16621\n[#16622]: https://github.com/JuliaLang/julia/issues/16622\n[#16645]: https://github.com/JuliaLang/julia/issues/16645\n[#16663]: https://github.com/JuliaLang/julia/issues/16663\n[#16731]: https://github.com/JuliaLang/julia/issues/16731\n[#16854]: https://github.com/JuliaLang/julia/issues/16854\n[#16953]: https://github.com/JuliaLang/julia/issues/16953\n[#16961]: https://github.com/JuliaLang/julia/issues/16961\n[#16972]: https://github.com/JuliaLang/julia/issues/16972\n[#16984]: https://github.com/JuliaLang/julia/issues/16984\n[#16986]: https://github.com/JuliaLang/julia/issues/16986\n[#17033]: https://github.com/JuliaLang/julia/issues/17033\n[#17037]: https://github.com/JuliaLang/julia/issues/17037\n[#17057]: https://github.com/JuliaLang/julia/issues/17057\n[#17075]: https://github.com/JuliaLang/julia/issues/17075\n[#17132]: https://github.com/JuliaLang/julia/issues/17132\n[#17155]: https://github.com/JuliaLang/julia/issues/17155\n[#17261]: https://github.com/JuliaLang/julia/issues/17261\n[#17265]: https://github.com/JuliaLang/julia/issues/17265\n[#17266]: https://github.com/JuliaLang/julia/issues/17266\n[#17300]: https://github.com/JuliaLang/julia/issues/17300\n[#17302]: https://github.com/JuliaLang/julia/issues/17302\n[#17323]: https://github.com/JuliaLang/julia/issues/17323\n[#17374]: https://github.com/JuliaLang/julia/issues/17374\n[#17393]: https://github.com/JuliaLang/julia/issues/17393\n[#17402]: https://github.com/JuliaLang/julia/issues/17402\n[#17404]: https://github.com/JuliaLang/julia/issues/17404\n[#17510]: https://github.com/JuliaLang/julia/issues/17510\n[#17546]: https://github.com/JuliaLang/julia/issues/17546\n[#17599]: https://github.com/JuliaLang/julia/issues/17599\n[#17607]: https://github.com/JuliaLang/julia/issues/17607\n[#17623]: https://github.com/JuliaLang/julia/issues/17623\n[#17654]: https://github.com/JuliaLang/julia/issues/17654\n[#17668]: https://github.com/JuliaLang/julia/issues/17668\n[#17723]: https://github.com/JuliaLang/julia/issues/17723\n[#17758]: https://github.com/JuliaLang/julia/issues/17758\n[#17785]: https://github.com/JuliaLang/julia/issues/17785\n[#18012]: https://github.com/JuliaLang/julia/issues/18012\n[#18050]: https://github.com/JuliaLang/julia/issues/18050\n[#18159]: https://github.com/JuliaLang/julia/issues/18159\n[#18218]: https://github.com/JuliaLang/julia/issues/18218\n[#18251]: https://github.com/JuliaLang/julia/issues/18251\n[#18330]: https://github.com/JuliaLang/julia/issues/18330\n[#18339]: https://github.com/JuliaLang/julia/issues/18339\n[#18342]: https://github.com/JuliaLang/julia/issues/18342\n[#18346]: https://github.com/JuliaLang/julia/issues/18346\n[#18441]: https://github.com/JuliaLang/julia/issues/18441\n[#18442]: https://github.com/JuliaLang/julia/issues/18442\n[#18444]: https://github.com/JuliaLang/julia/issues/18444\n[#18453]: https://github.com/JuliaLang/julia/issues/18453\n[#18457]: https://github.com/JuliaLang/julia/issues/18457\n[#18473]: https://github.com/JuliaLang/julia/issues/18473\n[#18558]: https://github.com/JuliaLang/julia/issues/18558\n[#18628]: https://github.com/JuliaLang/julia/issues/18628\n[#18642]: https://github.com/JuliaLang/julia/issues/18642\n[#18644]: https://github.com/JuliaLang/julia/issues/18644\n[#18660]: https://github.com/JuliaLang/julia/issues/18660\n[#18690]: https://github.com/JuliaLang/julia/issues/18690\n[#18754]: https://github.com/JuliaLang/julia/issues/18754\n[#18777]: https://github.com/JuliaLang/julia/issues/18777\n[#18832]: https://github.com/JuliaLang/julia/issues/18832\n[#18839]: https://github.com/JuliaLang/julia/issues/18839\n[#18891]: https://github.com/JuliaLang/julia/issues/18891\n[#18931]: https://github.com/JuliaLang/julia/issues/18931\n[#18965]: https://github.com/JuliaLang/julia/issues/18965\n[#18977]: https://github.com/JuliaLang/julia/issues/18977\n[#19018]: https://github.com/JuliaLang/julia/issues/19018\n[#19088]: https://github.com/JuliaLang/julia/issues/19088\n[#19157]: https://github.com/JuliaLang/julia/issues/19157\n[#19233]: https://github.com/JuliaLang/julia/issues/19233\n[#19239]: https://github.com/JuliaLang/julia/issues/19239\n[#19246]: https://github.com/JuliaLang/julia/issues/19246\n[#19259]: https://github.com/JuliaLang/julia/issues/19259\n[#19288]: https://github.com/JuliaLang/julia/issues/19288\n[#19305]: https://github.com/JuliaLang/julia/issues/19305\n[#19331]: https://github.com/JuliaLang/julia/issues/19331\n[#19371]: https://github.com/JuliaLang/julia/issues/19371\n[#19438]: https://github.com/JuliaLang/julia/issues/19438\n[#19449]: https://github.com/JuliaLang/julia/issues/19449\n[#19464]: https://github.com/JuliaLang/julia/issues/19464\n[#19469]: https://github.com/JuliaLang/julia/issues/19469\n[#19518]: https://github.com/JuliaLang/julia/issues/19518\n[#19533]: https://github.com/JuliaLang/julia/issues/19533\n[#19543]: https://github.com/JuliaLang/julia/issues/19543\n[#19594]: https://github.com/JuliaLang/julia/issues/19594\n[#19598]: https://github.com/JuliaLang/julia/issues/19598\n[#19635]: https://github.com/JuliaLang/julia/issues/19635\n[#19636]: https://github.com/JuliaLang/julia/issues/19636\n[#19660]: https://github.com/JuliaLang/julia/issues/19660\n[#19669]: https://github.com/JuliaLang/julia/issues/19669\n[#19670]: https://github.com/JuliaLang/julia/issues/19670\n[#19677]: https://github.com/JuliaLang/julia/issues/19677\n[#19680]: https://github.com/JuliaLang/julia/issues/19680\n[#19690]: https://github.com/JuliaLang/julia/issues/19690\n[#19692]: https://github.com/JuliaLang/julia/issues/19692\n[#19711]: https://github.com/JuliaLang/julia/issues/19711\n[#19712]: https://github.com/JuliaLang/julia/issues/19712\n[#19720]: https://github.com/JuliaLang/julia/issues/19720\n[#19721]: https://github.com/JuliaLang/julia/issues/19721\n[#19722]: https://github.com/JuliaLang/julia/issues/19722\n[#19724]: https://github.com/JuliaLang/julia/issues/19724\n[#19730]: https://github.com/JuliaLang/julia/issues/19730\n[#19737]: https://github.com/JuliaLang/julia/issues/19737\n[#19741]: https://github.com/JuliaLang/julia/issues/19741\n[#19766]: https://github.com/JuliaLang/julia/issues/19766\n[#19771]: https://github.com/JuliaLang/julia/issues/19771\n[#19779]: https://github.com/JuliaLang/julia/issues/19779\n[#19784]: https://github.com/JuliaLang/julia/issues/19784\n[#19786]: https://github.com/JuliaLang/julia/issues/19786\n[#19787]: https://github.com/JuliaLang/julia/issues/19787\n[#19791]: https://github.com/JuliaLang/julia/issues/19791\n[#19800]: https://github.com/JuliaLang/julia/issues/19800\n[#19802]: https://github.com/JuliaLang/julia/issues/19802\n[#19811]: https://github.com/JuliaLang/julia/issues/19811\n[#19814]: https://github.com/JuliaLang/julia/issues/19814\n[#19841]: https://github.com/JuliaLang/julia/issues/19841\n[#19878]: https://github.com/JuliaLang/julia/issues/19878\n[#19900]: https://github.com/JuliaLang/julia/issues/19900\n[#19901]: https://github.com/JuliaLang/julia/issues/19901\n[#19903]: https://github.com/JuliaLang/julia/issues/19903\n[#19919]: https://github.com/JuliaLang/julia/issues/19919\n[#19920]: https://github.com/JuliaLang/julia/issues/19920\n[#19925]: https://github.com/JuliaLang/julia/issues/19925\n[#19926]: https://github.com/JuliaLang/julia/issues/19926\n[#19931]: https://github.com/JuliaLang/julia/issues/19931\n[#19934]: https://github.com/JuliaLang/julia/issues/19934\n[#19935]: https://github.com/JuliaLang/julia/issues/19935\n[#19937]: https://github.com/JuliaLang/julia/issues/19937\n[#19944]: https://github.com/JuliaLang/julia/issues/19944\n[#19949]: https://github.com/JuliaLang/julia/issues/19949\n[#19950]: https://github.com/JuliaLang/julia/issues/19950\n[#19989]: https://github.com/JuliaLang/julia/issues/19989\n[#20009]: https://github.com/JuliaLang/julia/issues/20009\n[#20047]: https://github.com/JuliaLang/julia/issues/20047\n[#20058]: https://github.com/JuliaLang/julia/issues/20058\n[#20079]: https://github.com/JuliaLang/julia/issues/20079\n[#20135]: https://github.com/JuliaLang/julia/issues/20135\n[#20164]: https://github.com/JuliaLang/julia/issues/20164\n[#20213]: https://github.com/JuliaLang/julia/issues/20213\n[#20228]: https://github.com/JuliaLang/julia/issues/20228\n[#20248]: https://github.com/JuliaLang/julia/issues/20248\n[#20249]: https://github.com/JuliaLang/julia/issues/20249\n[#20268]: https://github.com/JuliaLang/julia/issues/20268\n[#20308]: https://github.com/JuliaLang/julia/issues/20308\n[#20321]: https://github.com/JuliaLang/julia/issues/20321\n[#20327]: https://github.com/JuliaLang/julia/issues/20327\n[#20328]: https://github.com/JuliaLang/julia/issues/20328\n[#20330]: https://github.com/JuliaLang/julia/issues/20330\n[#20342]: https://github.com/JuliaLang/julia/issues/20342\n[#20345]: https://github.com/JuliaLang/julia/issues/20345\n[#20403]: https://github.com/JuliaLang/julia/issues/20403\n[#20404]: https://github.com/JuliaLang/julia/issues/20404\n[#20406]: https://github.com/JuliaLang/julia/issues/20406\n[#20414]: https://github.com/JuliaLang/julia/issues/20414\n[#20418]: https://github.com/JuliaLang/julia/issues/20418\n[#20427]: https://github.com/JuliaLang/julia/issues/20427\n[#20435]: https://github.com/JuliaLang/julia/issues/20435\n[#20500]: https://github.com/JuliaLang/julia/issues/20500\n[#20530]: https://github.com/JuliaLang/julia/issues/20530\n[#20543]: https://github.com/JuliaLang/julia/issues/20543\n[#20609]: https://github.com/JuliaLang/julia/issues/20609\n[#20889]: https://github.com/JuliaLang/julia/issues/20889\n[#20952]: https://github.com/JuliaLang/julia/issues/20952\n[#21183]: https://github.com/JuliaLang/julia/issues/21183\n[#21818]: https://github.com/JuliaLang/julia/issues/21818\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/cli/loader.h": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n/* Bring in definitions for `_OS_X_`, `PATH_MAX` and `PATHSEPSTRING`, `jl_ptls_t`, etc... */\n#include \"../src/support/platform.h\"\n#include \"../src/support/dirpath.h\"\n\n#ifdef _OS_WINDOWS_\n/* We need to reimplement a bunch of standard library stuff on windows,\n * but we want to make sure that it doesn't conflict with the actual implementations\n * once those get linked into this process. */\n#define fwrite loader_fwrite\n#define fputs loader_fputs\n#define exit loader_exit\n#define strlen loader_strlen\n#define wcslen loader_wcslen\n#define strncat loader_strncat\n#define memcpy loader_memcpy\n#define dirname loader_dirname\n#define strchr loader_strchr\n#define malloc loader_malloc\n#define realloc loader_realloc\n#endif\n\n#ifdef _OS_WINDOWS_\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#else\n#ifdef _OS_DARWIN_\n#include <mach-o/dyld.h>\n#endif\n#ifdef _OS_FREEBSD_\n#include <stddef.h>\n#include <sys/sysctl.h>\n#endif\n\n#define _GNU_SOURCE // Need this for `dladdr()`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#endif\n\n// Borrow definitions from `julia.h`\n#if defined(__GNUC__)\n#  define JL_CONST_FUNC __attribute__((const))\n#elif defined(_COMPILER_MICROSOFT_)\n#  define JL_CONST_FUNC __declspec(noalias)\n#else\n#  define JL_CONST_FUNC\n#endif\n\n// Borrow definition from `support/dtypes.h`\n#ifdef _OS_WINDOWS_\n# ifdef LIBRARY_EXPORTS\n#  define JL_DLLEXPORT __declspec(dllexport)\n# else\n#  define JL_DLLEXPORT __declspec(dllimport)\n# endif\n#define JL_HIDDEN\n#else\n# if defined(LIBRARY_EXPORTS) && defined(_OS_LINUX)\n#  define JL_DLLEXPORT __attribute__ ((visibility(\"protected\")))\n# else\n#  define JL_DLLEXPORT __attribute__ ((visibility(\"default\")))\n# endif\n#define JL_HIDDEN    __attribute__ ((visibility(\"hidden\")))\n#endif\n#ifdef JL_DEBUG_BUILD\n#define JL_NAKED     __attribute__ ((naked,no_stack_protector))\n#else\n#define JL_NAKED     __attribute__ ((naked))\n#endif\n\n/*\n * DEP_LIBS is our list of dependent libraries that must be loaded before `libjulia`.\n * Note that order matters, as each entry will be opened in-order.  We define here a\n * dummy value just so this file compiles on its own, and also so that developers can\n * see what this value should look like.  Note that the last entry must always be\n * `libjulia`, and that all paths should be relative to this loader library path.\n */\n#if !defined(DEP_LIBS)\n#define DEP_LIBS \"../lib/example.so:../lib/libjulia.so\"\n#endif\n\n// We need to dlopen() ourselves in order to introspect the libdir.\n#if defined(JL_DEBUG_BUILD)\n#define LIBJULIA_NAME \"libjulia-debug\"\n#else\n#define LIBJULIA_NAME \"libjulia\"\n#endif\n\n\n// Declarations from `loader_lib.c` and `loader_win_utils.c`\nJL_DLLEXPORT extern int jl_load_repl(int, char **);\nJL_DLLEXPORT void jl_loader_print_stderr(const char * msg);\nvoid jl_loader_print_stderr3(const char * msg1, const char * msg2, const char * msg3);\nstatic void * lookup_symbol(const void * lib_handle, const char * symbol_name);\n\n#ifdef _OS_WINDOWS_\nLPWSTR *CommandLineToArgv(LPWSTR lpCmdLine, int *pNumArgs);\nint wchar_to_utf8(const wchar_t * wstr, char *str, size_t maxlen);\nint utf8_to_wchar(const char * str, wchar_t *wstr, size_t maxlen);\nvoid setup_stdio(void);\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/cli/loader_lib.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n// This file defines an RPATH-style relative path loader for all platforms\n#include \"loader.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Bring in definitions of symbols exported from libjulia. */\n#include \"jl_exports.h\"\n\n/* Bring in helper functions for windows without libgcc. */\n#ifdef _OS_WINDOWS_\n#include \"loader_win_utils.c\"\n#endif\n\n// Save DEP_LIBS to a variable that is explicitly sized for expansion\nstatic char dep_libs[512] = DEP_LIBS;\n\nJL_DLLEXPORT void jl_loader_print_stderr(const char * msg)\n{\n    fputs(msg, stderr);\n}\n// I use three arguments a lot.\nvoid jl_loader_print_stderr3(const char * msg1, const char * msg2, const char * msg3)\n{\n    jl_loader_print_stderr(msg1);\n    jl_loader_print_stderr(msg2);\n    jl_loader_print_stderr(msg3);\n}\n\n/* Wrapper around dlopen(), with extra relative pathing thrown in*/\nstatic void * load_library(const char * rel_path, const char * src_dir) {\n    char path[2*PATH_MAX + 1] = {0};\n    strncat(path, src_dir, sizeof(path) - 1);\n    strncat(path, PATHSEPSTRING, sizeof(path) - 1);\n    strncat(path, rel_path, sizeof(path) - 1);\n\n    void * handle = NULL;\n#if defined(_OS_WINDOWS_)\n    wchar_t wpath[2*PATH_MAX + 1] = {0};\n    if (!utf8_to_wchar(path, wpath, 2*PATH_MAX)) {\n        jl_loader_print_stderr3(\"ERROR: Unable to convert path \", path, \" to wide string!\\n\");\n        exit(1);\n    }\n    handle = (void *)LoadLibraryExW(wpath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n#else\n    handle = dlopen(path, RTLD_NOW | RTLD_GLOBAL);\n#endif\n\n    if (handle == NULL) {\n        jl_loader_print_stderr3(\"ERROR: Unable to load dependent library \", path, \"\\n\");\n#if defined(_OS_WINDOWS_)\n        LPWSTR wmsg = TEXT(\"\");\n        FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                       FORMAT_MESSAGE_FROM_SYSTEM |\n                       FORMAT_MESSAGE_IGNORE_INSERTS |\n                       FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                       NULL, GetLastError(),\n                       MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                       (LPWSTR)&wmsg, 0, NULL);\n        char err[256] = {0};\n        wchar_to_utf8(wmsg, err, 255);\n        jl_loader_print_stderr3(\"Message:\", err, \"\\n\");\n#else\n        jl_loader_print_stderr3(\"Message:\", dlerror(), \"\\n\");\n#endif\n        exit(1);\n    }\n    return handle;\n}\n\nstatic void * lookup_symbol(const void * lib_handle, const char * symbol_name) {\n#ifdef _OS_WINDOWS_\n    return GetProcAddress((HMODULE) lib_handle, symbol_name);\n#else\n    return dlsym((void *)lib_handle, symbol_name);\n#endif\n}\n\n// Find the location of libjulia.\nchar lib_dir[PATH_MAX];\nJL_DLLEXPORT const char * jl_get_libdir()\n{\n    // Reuse the path if this is not the first call.\n    if (lib_dir[0] != 0) {\n        return lib_dir;\n    }\n#if defined(_OS_WINDOWS_)\n    // On Windows, we use GetModuleFileNameW\n    wchar_t libjulia_path[PATH_MAX];\n    HMODULE libjulia = NULL;\n\n    // Get a handle to libjulia.\n    if (!utf8_to_wchar(LIBJULIA_NAME, libjulia_path, PATH_MAX)) {\n        jl_loader_print_stderr3(\"ERROR: Unable to convert path \", LIBJULIA_NAME, \" to wide string!\\n\");\n        exit(1);\n    }\n    libjulia = LoadLibraryW(libjulia_path);\n    if (libjulia == NULL) {\n        jl_loader_print_stderr3(\"ERROR: Unable to load \", LIBJULIA_NAME, \"!\\n\");\n        exit(1);\n    }\n    if (!GetModuleFileNameW(libjulia, libjulia_path, PATH_MAX)) {\n        jl_loader_print_stderr(\"ERROR: GetModuleFileName() failed\\n\");\n        exit(1);\n    }\n    if (!wchar_to_utf8(libjulia_path, lib_dir, PATH_MAX)) {\n        jl_loader_print_stderr(\"ERROR: Unable to convert julia path to UTF-8\\n\");\n        exit(1);\n    }\n#else\n    // On all other platforms, use dladdr()\n    Dl_info info;\n    if (!dladdr(&jl_get_libdir, &info)) {\n        jl_loader_print_stderr(\"ERROR: Unable to dladdr(&jl_get_libdir)!\\n\");\n        jl_loader_print_stderr3(\"Message:\", dlerror(), \"\\n\");\n        exit(1);\n    }\n    strcpy(lib_dir, info.dli_fname);\n#endif\n    // Finally, convert to dirname\n    const char * new_dir = dirname(lib_dir);\n    if (new_dir != lib_dir) {\n        // On some platforms, dirname() mutates.  On others, it does not.\n        memcpy(lib_dir, new_dir, strlen(new_dir)+1);\n    }\n    return lib_dir;\n}\n\nvoid * libjulia_internal = NULL;\n__attribute__((constructor)) void jl_load_libjulia_internal(void) {\n    // Only initalize this once\n    if (libjulia_internal != NULL) {\n        return;\n    }\n\n    // Introspect to find our own path\n    const char * lib_dir = jl_get_libdir();\n\n    // Pre-load libraries that libjulia-internal needs.\n    int deps_len = strlen(dep_libs);\n    char * curr_dep = &dep_libs[0];\n    while (1) {\n        // try to find next colon character, if we can't, escape out.\n        char * colon = strchr(curr_dep, ':');\n        if (colon == NULL)\n            break;\n\n        // Chop the string at the colon, load this library.\n        *colon = '\\0';\n        load_library(curr_dep, lib_dir);\n\n        // Skip ahead to next dependency\n        curr_dep = colon + 1;\n    }\n\n    // Last dependency is `libjulia-internal`, so load that and we're done with `dep_libs`!\n    libjulia_internal = load_library(curr_dep, lib_dir);\n\n    // Once we have libjulia-internal loaded, re-export its symbols:\n    for (unsigned int symbol_idx=0; jl_exported_func_names[symbol_idx] != NULL; ++symbol_idx) {\n        (*jl_exported_func_addrs[symbol_idx]) = lookup_symbol(libjulia_internal, jl_exported_func_names[symbol_idx]);\n    }\n}\n\n// Load libjulia and run the REPL with the given arguments (in UTF-8 format)\nJL_DLLEXPORT int jl_load_repl(int argc, char * argv[]) {\n    // Some compilers/platforms are known to have `__attribute__((constructor))` issues,\n    // so we have a fallback call of `jl_load_libjulia_internal()` here.\n    if (libjulia_internal == NULL) {\n        jl_load_libjulia_internal();\n        if (libjulia_internal == NULL) {\n            jl_loader_print_stderr(\"ERROR: libjulia-internal could not be loaded!\\n\");\n            exit(1);\n        }\n    }\n    // Next, if we're on Linux/FreeBSD, set up fast TLS.\n#if !defined(_OS_WINDOWS_) && !defined(_OS_DARWIN_)\n    void (*jl_set_ptls_states_getter)(void *) = lookup_symbol(libjulia_internal, \"jl_set_ptls_states_getter\");\n    if (jl_set_ptls_states_getter == NULL) {\n        jl_loader_print_stderr(\"ERROR: Cannot find jl_set_ptls_states_getter() function within libjulia-internal!\\n\");\n        exit(1);\n    }\n    void * (*fptr)(void) = lookup_symbol(RTLD_DEFAULT, \"jl_get_ptls_states_static\");\n    if (fptr == NULL) {\n        jl_loader_print_stderr(\"ERROR: Cannot find jl_get_ptls_states_static(), must define this symbol within calling executable!\\n\");\n        exit(1);\n    }\n    jl_set_ptls_states_getter((void *)fptr);\n#endif\n\n    // Load the repl entrypoint symbol and jump into it!\n    int (*entrypoint)(int, char **) = (int (*)(int, char **))lookup_symbol(libjulia_internal, \"repl_entrypoint\");\n    if (entrypoint == NULL) {\n        jl_loader_print_stderr(\"ERROR: Unable to find `repl_entrypoint()` within libjulia-internal!\\n\");\n        exit(1);\n    }\n    return entrypoint(argc, (char **)argv);\n}\n\n#ifdef _OS_WINDOWS_\nint __stdcall DllMainCRTStartup(void* instance, unsigned reason, void* reserved) {\n    setup_stdio();\n\n    // Because we override DllMainCRTStartup, we have to manually call our constructor methods\n    jl_load_libjulia_internal();\n    return 1;\n}\n#endif\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/jl_exported_funcs.inc": "#define JL_EXPORTED_FUNCS(XX) \\\n    XX(jl_) \\\n    XX(jl_abs_float) \\\n    XX(jl_abs_float_withtype) \\\n    XX(jl_active_task_stack) \\\n    XX(jl_add_float) \\\n    XX(jl_add_int) \\\n    XX(jl_add_optimization_passes) \\\n    XX(jl_add_ptr) \\\n    XX(jl_add_standard_imports) \\\n    XX(jl_alignment) \\\n    XX(jl_alloc_array_1d) \\\n    XX(jl_alloc_array_2d) \\\n    XX(jl_alloc_array_3d) \\\n    XX(jl_alloc_string) \\\n    XX(jl_alloc_svec) \\\n    XX(jl_alloc_svec_uninit) \\\n    XX(jl_alloc_vec_any) \\\n    XX(jl_and_int) \\\n    XX(jl_apply_array_type) \\\n    XX(jl_apply_generic) \\\n    XX(jl_apply_tuple_type) \\\n    XX(jl_apply_tuple_type_v) \\\n    XX(jl_apply_type) \\\n    XX(jl_apply_type1) \\\n    XX(jl_apply_type2) \\\n    XX(jl_argument_datatype) \\\n    XX(jl_argument_method_table) \\\n    XX(jl_array_cconvert_cstring) \\\n    XX(jl_array_copy) \\\n    XX(jl_array_data_owner) \\\n    XX(jl_array_del_at) \\\n    XX(jl_array_del_beg) \\\n    XX(jl_array_del_end) \\\n    XX(jl_array_eltype) \\\n    XX(jl_array_grow_at) \\\n    XX(jl_array_grow_beg) \\\n    XX(jl_array_grow_end) \\\n    XX(jl_array_isassigned) \\\n    XX(jl_arraylen) \\\n    XX(jl_array_ptr) \\\n    XX(jl_array_ptr_1d_append) \\\n    XX(jl_array_ptr_1d_push) \\\n    XX(jl_array_ptr_copy) \\\n    XX(jl_array_rank) \\\n    XX(jl_arrayref) \\\n    XX(jl_arrayset) \\\n    XX(jl_array_size) \\\n    XX(jl_array_sizehint) \\\n    XX(jl_array_to_string) \\\n    XX(jl_array_typetagdata) \\\n    XX(jl_arrayunset) \\\n    XX(jl_ashr_int) \\\n    XX(jl_astaggedvalue) \\\n    XX(jl_atexit_hook) \\\n    XX(jl_backtrace_from_here) \\\n    XX(jl_base_relative_to) \\\n    XX(jl_binding_owner) \\\n    XX(jl_binding_resolved_p) \\\n    XX(jl_bitcast) \\\n    XX(jl_boundp) \\\n    XX(jl_bounds_error) \\\n    XX(jl_bounds_error_int) \\\n    XX(jl_bounds_error_ints) \\\n    XX(jl_bounds_error_tuple_int) \\\n    XX(jl_bounds_error_unboxed_int) \\\n    XX(jl_bounds_error_v) \\\n    XX(jl_box_bool) \\\n    XX(jl_box_char) \\\n    XX(jl_box_float32) \\\n    XX(jl_box_float64) \\\n    XX(jl_box_int16) \\\n    XX(jl_box_int32) \\\n    XX(jl_box_int64) \\\n    XX(jl_box_int8) \\\n    XX(jl_box_slotnumber) \\\n    XX(jl_box_ssavalue) \\\n    XX(jl_box_uint16) \\\n    XX(jl_box_uint32) \\\n    XX(jl_box_uint64) \\\n    XX(jl_box_uint8) \\\n    XX(jl_box_uint8pointer) \\\n    XX(jl_box_voidpointer) \\\n    XX(jl_breakpoint) \\\n    XX(jl_bswap_int) \\\n    XX(jl_call) \\\n    XX(jl_call0) \\\n    XX(jl_call1) \\\n    XX(jl_call2) \\\n    XX(jl_call3) \\\n    XX(jl_call_in_typeinf_world) \\\n    XX(jl_calloc) \\\n    XX(jl_capture_interp_frame) \\\n    XX(jl_ceil_llvm) \\\n    XX(jl_ceil_llvm_withtype) \\\n    XX(jl_cglobal) \\\n    XX(jl_cglobal_auto) \\\n    XX(jl_checked_assignment) \\\n    XX(jl_checked_sadd_int) \\\n    XX(jl_checked_sdiv_int) \\\n    XX(jl_checked_smul_int) \\\n    XX(jl_checked_srem_int) \\\n    XX(jl_checked_ssub_int) \\\n    XX(jl_checked_uadd_int) \\\n    XX(jl_checked_udiv_int) \\\n    XX(jl_checked_umul_int) \\\n    XX(jl_checked_urem_int) \\\n    XX(jl_checked_usub_int) \\\n    XX(jl_clear_implicit_imports) \\\n    XX(jl_clear_malloc_data) \\\n    XX(jl_clock_now) \\\n    XX(jl_close_uv) \\\n    XX(jl_code_for_staged) \\\n    XX(jl_compile_hint) \\\n    XX(jl_compress_argnames) \\\n    XX(jl_compress_ir) \\\n    XX(jl_compute_fieldtypes) \\\n    XX(jl_copy_ast) \\\n    XX(jl_copy_code_info) \\\n    XX(jl_copysign_float) \\\n    XX(jl_cpuid) \\\n    XX(jl_cpuidex) \\\n    XX(jl_cpu_pause) \\\n    XX(jl_cpu_threads) \\\n    XX(jl_cpu_wake) \\\n    XX(jl_crc32c_sw) \\\n    XX(jl_create_native) \\\n    XX(jl_create_system_image) \\\n    XX(jl_cstr_to_string) \\\n    XX(jl_ctlz_int) \\\n    XX(jl_ctpop_int) \\\n    XX(jl_cttz_int) \\\n    XX(jl_current_exception) \\\n    XX(jl_debug_method_invalidation) \\\n    XX(jl_declare_constant) \\\n    XX(jl_defines_or_exports_p) \\\n    XX(jl_deprecate_binding) \\\n    XX(jl_div_float) \\\n    XX(jl_dlclose) \\\n    XX(jl_dlopen) \\\n    XX(jl_dlsym) \\\n    XX(jl_dump_compiles) \\\n    XX(jl_dump_fptr_asm) \\\n    XX(jl_dump_function_ir) \\\n    XX(jl_dump_host_cpu) \\\n    XX(jl_dump_llvm_asm) \\\n    XX(jl_dump_method_asm) \\\n    XX(jl_egal) \\\n    XX(jl_eh_restore_state) \\\n    XX(jl_enqueue_task) \\\n    XX(jl_enter_handler) \\\n    XX(jl_enter_threaded_region) \\\n    XX(jl_environ) \\\n    XX(jl_eof_error) \\\n    XX(jl_eq_float) \\\n    XX(jl_eq_int) \\\n    XX(jl_eqtable_get) \\\n    XX(jl_eqtable_nextind) \\\n    XX(jl_eqtable_pop) \\\n    XX(jl_eqtable_put) \\\n    XX(jl_errno) \\\n    XX(jl_error) \\\n    XX(jl_errorf) \\\n    XX(jl_eval_string) \\\n    XX(jl_exception_clear) \\\n    XX(jl_exceptionf) \\\n    XX(jl_exception_occurred) \\\n    XX(jl_excstack_state) \\\n    XX(jl_exit) \\\n    XX(jl_exit_on_sigint) \\\n    XX(jl_exit_threaded_region) \\\n    XX(jl_expand) \\\n    XX(jl_expand_and_resolve) \\\n    XX(jl_expand_stmt) \\\n    XX(jl_expand_stmt_with_loc) \\\n    XX(jl_expand_with_loc) \\\n    XX(jl_expand_with_loc_warn) \\\n    XX(jl_extern_c) \\\n    XX(jl_f__abstracttype) \\\n    XX(jl_f__apply) \\\n    XX(jl_f__apply_iterate) \\\n    XX(jl_f__apply_pure) \\\n    XX(jl_f__call_in_world) \\\n    XX(jl_f__call_latest) \\\n    XX(jl_f_applicable) \\\n    XX(jl_f_apply_type) \\\n    XX(jl_f_arrayref) \\\n    XX(jl_f_arrayset) \\\n    XX(jl_f_arraysize) \\\n    XX(jl_f_const_arrayref) \\\n    XX(jl_f__equiv_typedef) \\\n    XX(jl_f__expr) \\\n    XX(jl_f_fieldtype) \\\n    XX(jl_f_getfield) \\\n    XX(jl_field_index) \\\n    XX(jl_field_isdefined) \\\n    XX(jl_f_ifelse) \\\n    XX(jl_finalize) \\\n    XX(jl_finalize_th) \\\n    XX(jl_find_free_typevars) \\\n    XX(jl_f_intrinsic_call) \\\n    XX(jl_f_invoke) \\\n    XX(jl_f_invoke_kwsorter) \\\n    XX(jl_first_argument_datatype) \\\n    XX(jl_f_is) \\\n    XX(jl_f_isa) \\\n    XX(jl_f_isdefined) \\\n    XX(jl_f_issubtype) \\\n    XX(jl_flipsign_int) \\\n    XX(jl_floor_llvm) \\\n    XX(jl_floor_llvm_withtype) \\\n    XX(jl_fl_parse) \\\n    XX(jl_flush_cstdio) \\\n    XX(jl_fma_float) \\\n    XX(jl_f_new_module) \\\n    XX(jl_f_nfields) \\\n    XX(jl_forceclose_uv) \\\n    XX(jl_format_filename) \\\n    XX(jl_fpext) \\\n    XX(jl_fpiseq) \\\n    XX(jl_fpislt) \\\n    XX(jl_f__primitivetype) \\\n    XX(jl_fptosi) \\\n    XX(jl_fptoui) \\\n    XX(jl_fptr_args) \\\n    XX(jl_fptr_const_return) \\\n    XX(jl_fptr_interpret_call) \\\n    XX(jl_fptr_sparam) \\\n    XX(jl_fptrunc) \\\n    XX(jl_free) \\\n    XX(jl_free_stack) \\\n    XX(jl_fs_access) \\\n    XX(jl_fs_chmod) \\\n    XX(jl_fs_chown) \\\n    XX(jl_fs_close) \\\n    XX(jl_f_setfield) \\\n    XX(jl_f__setsuper) \\\n    XX(jl_f_sizeof) \\\n    XX(jl_fs_read) \\\n    XX(jl_fs_read_byte) \\\n    XX(jl_fs_rename) \\\n    XX(jl_fs_sendfile) \\\n    XX(jl_fs_symlink) \\\n    XX(jl_fstat) \\\n    XX(jl_f__structtype) \\\n    XX(jl_fs_unlink) \\\n    XX(jl_f_svec) \\\n    XX(jl_fs_write) \\\n    XX(jl_f_throw) \\\n    XX(jl_ftruncate) \\\n    XX(jl_f_tuple) \\\n    XX(jl_f_typeassert) \\\n    XX(jl_f__typebody) \\\n    XX(jl_f_typeof) \\\n    XX(jl_f__typevar) \\\n    XX(jl_gc_add_finalizer) \\\n    XX(jl_gc_add_finalizer_th) \\\n    XX(jl_gc_add_ptr_finalizer) \\\n    XX(jl_gc_alloc) \\\n    XX(jl_gc_alloc_0w) \\\n    XX(jl_gc_alloc_1w) \\\n    XX(jl_gc_alloc_2w) \\\n    XX(jl_gc_alloc_3w) \\\n    XX(jl_gc_allocobj) \\\n    XX(jl_gc_alloc_typed) \\\n    XX(jl_gc_big_alloc) \\\n    XX(jl_gc_collect) \\\n    XX(jl_gc_conservative_gc_support_enabled) \\\n    XX(jl_gc_counted_calloc) \\\n    XX(jl_gc_counted_free_with_size) \\\n    XX(jl_gc_counted_malloc) \\\n    XX(jl_gc_counted_realloc_with_old_size) \\\n    XX(jl_gc_diff_total_bytes) \\\n    XX(jl_gc_enable) \\\n    XX(jl_gc_enable_conservative_gc_support) \\\n    XX(jl_gc_enable_finalizers) \\\n    XX(jl_gc_external_obj_hdr_size) \\\n    XX(jl_gc_find_taggedvalue_pool) \\\n    XX(jl_gc_get_total_bytes) \\\n    XX(jl_gc_internal_obj_base_ptr) \\\n    XX(jl_gc_is_enabled) \\\n    XX(jl_gc_live_bytes) \\\n    XX(jl_gc_managed_malloc) \\\n    XX(jl_gc_managed_realloc) \\\n    XX(jl_gc_mark_queue_obj) \\\n    XX(jl_gc_mark_queue_objarray) \\\n    XX(jl_gc_max_internal_obj_size) \\\n    XX(jl_gc_new_weakref) \\\n    XX(jl_gc_new_weakref_th) \\\n    XX(jl_gc_num) \\\n    XX(jl_gc_pool_alloc) \\\n    XX(jl_gc_queue_multiroot) \\\n    XX(jl_gc_queue_root) \\\n    XX(jl_gc_safe_enter) \\\n    XX(jl_gc_safe_leave) \\\n    XX(jl_gc_safepoint) \\\n    XX(jl_gc_schedule_foreign_sweepfunc) \\\n    XX(jl_gc_set_cb_notify_external_alloc) \\\n    XX(jl_gc_set_cb_notify_external_free) \\\n    XX(jl_gc_set_cb_post_gc) \\\n    XX(jl_gc_set_cb_pre_gc) \\\n    XX(jl_gc_set_cb_root_scanner) \\\n    XX(jl_gc_set_cb_task_scanner) \\\n    XX(jl_gc_sync_total_bytes) \\\n    XX(jl_gc_total_hrtime) \\\n    XX(jl_gc_unsafe_enter) \\\n    XX(jl_gc_unsafe_leave) \\\n    XX(jl_gdblookup) \\\n    XX(jl_generating_output) \\\n    XX(jl_generic_function_def) \\\n    XX(jl_gensym) \\\n    XX(jl_getaddrinfo) \\\n    XX(jl_getallocationgranularity) \\\n    XX(jl_get_ARCH) \\\n    XX(jl_get_backtrace) \\\n    XX(jl_get_binding) \\\n    XX(jl_get_binding_for_method_def) \\\n    XX(jl_get_binding_or_error) \\\n    XX(jl_get_binding_wr) \\\n    XX(jl_get_cfunction_trampoline) \\\n    XX(jl_get_cpu_name) \\\n    XX(jl_get_current_task) \\\n    XX(jl_get_default_sysimg_path) \\\n    XX(jl_get_excstack) \\\n    XX(jl_get_fenv_consts) \\\n    XX(jl_get_field) \\\n    XX(jl_get_field_offset) \\\n    XX(jl_get_fieldtypes) \\\n    XX(jl_get_function_id) \\\n    XX(jl_get_global) \\\n    XX(jl_get_image_file) \\\n    XX(jl_get_JIT) \\\n    XX(jl_get_julia_bin) \\\n    XX(jl_get_julia_bindir) \\\n    XX(jl_get_keyword_sorter) \\\n    XX(jl_get_kwsorter) \\\n    XX(jl_get_llvm_context) \\\n    XX(jl_get_llvmf_defn) \\\n    XX(jl_get_llvm_function) \\\n    XX(jl_get_llvm_module) \\\n    XX(jl_get_LLVM_VERSION) \\\n    XX(jl_get_method_inferred) \\\n    XX(jl_get_module_binding) \\\n    XX(jl_get_module_compile) \\\n    XX(jl_get_module_infer) \\\n    XX(jl_get_module_of_binding) \\\n    XX(jl_get_module_optlevel) \\\n    XX(jl_getnameinfo) \\\n    XX(jl_get_next_task) \\\n    XX(jl_get_nth_field) \\\n    XX(jl_get_nth_field_checked) \\\n    XX(jl_get_nth_field_noalloc) \\\n    XX(jl_getpagesize) \\\n    XX(jl_getpid) \\\n    XX(jl_get_ptls_states) \\\n    XX(jl_get_root_symbol) \\\n    XX(jl_get_safe_restore) \\\n    XX(jl_get_size) \\\n    XX(jl_get_task_tid) \\\n    XX(jl_gettimeofday) \\\n    XX(jl_get_tls_world_age) \\\n    XX(jl_get_UNAME) \\\n    XX(jl_get_world_counter) \\\n    XX(jl_get_zero_subnormals) \\\n    XX(jl_gf_invoke_lookup) \\\n    XX(jl_gf_invoke_lookup_worlds) \\\n    XX(jl_git_branch) \\\n    XX(jl_git_commit) \\\n    XX(jl_global_event_loop) \\\n    XX(jl_has_empty_intersection) \\\n    XX(jl_has_free_typevars) \\\n    XX(jl_has_so_reuseport) \\\n    XX(jl_has_typevar) \\\n    XX(jl_has_typevar_from_unionall) \\\n    XX(jl_hrtime) \\\n    XX(jl_id_char) \\\n    XX(jl_id_start_char) \\\n    XX(jl_idtable_rehash) \\\n    XX(jl_infer_thunk) \\\n    XX(jl_init_restored_modules) \\\n    XX(jl_init__threading) \\\n    XX(jl_init_with_image__threading) \\\n    XX(jl_install_sigint_handler) \\\n    XX(jl_instantiate_type_in_env) \\\n    XX(jl_instantiate_unionall) \\\n    XX(jl_intersect_types) \\\n    XX(jl_in_threaded_region) \\\n    XX(jl_intrinsic_name) \\\n    XX(jl_invoke) \\\n    XX(jl_invoke_api) \\\n    XX(jl_iolock_begin) \\\n    XX(jl_iolock_end) \\\n    XX(jl_ios_buffer_n) \\\n    XX(jl_ios_fd) \\\n    XX(jl_ios_get_nbyte_int) \\\n    XX(jl_ir_flag_inferred) \\\n    XX(jl_ir_flag_inlineable) \\\n    XX(jl_ir_flag_pure) \\\n    XX(jl_ir_nslots) \\\n    XX(jl_ir_slotflag) \\\n    XX(jl_isa) \\\n    XX(jl_isa_compileable_sig) \\\n    XX(jl_is_binding_deprecated) \\\n    XX(jl_is_char_signed) \\\n    XX(jl_is_const) \\\n    XX(jl_is_debugbuild) \\\n    XX(jl_is_identifier) \\\n    XX(jl_is_imported) \\\n    XX(jl_is_initialized) \\\n    XX(jl_is_in_pure_context) \\\n    XX(jl_islayout_inline) \\\n    XX(jl_is_memdebug) \\\n    XX(jl_is_not_broken_subtype) \\\n    XX(jl_is_operator) \\\n    XX(jl_is_task_started) \\\n    XX(jl_istopmod) \\\n    XX(jl_is_unary_and_binary_operator) \\\n    XX(jl_is_unary_operator) \\\n    XX(jl_lazy_load_and_lookup) \\\n    XX(jl_le_float) \\\n    XX(jl_lisp_prompt) \\\n    XX(jl_LLVMCreateDisasm) \\\n    XX(jl_LLVMDisasmInstruction) \\\n    XX(jl_LLVMFlipSign) \\\n    XX(jl_LLVMSMod) \\\n    XX(jl_load) \\\n    XX(jl_load_) \\\n    XX(jl_load_and_lookup) \\\n    XX(jl_load_dynamic_library) \\\n    XX(jl_load_file_string) \\\n    XX(jl_lookup_code_address) \\\n    XX(jl_lseek) \\\n    XX(jl_lshr_int) \\\n    XX(jl_lstat) \\\n    XX(jl_lt_float) \\\n    XX(jl_macroexpand) \\\n    XX(jl_macroexpand1) \\\n    XX(jl_malloc) \\\n    XX(jl_malloc_stack) \\\n    XX(jl_matching_methods) \\\n    XX(jl_maxrss) \\\n    XX(jl_method_def) \\\n    XX(jl_method_instance_add_backedge) \\\n    XX(jl_method_table_add_backedge) \\\n    XX(jl_method_table_disable) \\\n    XX(jl_method_table_for) \\\n    XX(jl_method_table_insert) \\\n    XX(jl_methtable_lookup) \\\n    XX(jl_mi_cache_insert) \\\n    XX(jl_mmap) \\\n    XX(jl_module_build_id) \\\n    XX(jl_module_export) \\\n    XX(jl_module_exports_p) \\\n    XX(jl_module_globalref) \\\n    XX(jl_module_import) \\\n    XX(jl_module_name) \\\n    XX(jl_module_names) \\\n    XX(jl_module_parent) \\\n    XX(jl_module_use) \\\n    XX(jl_module_using) \\\n    XX(jl_module_usings) \\\n    XX(jl_module_uuid) \\\n    XX(jl_muladd_float) \\\n    XX(jl_mul_float) \\\n    XX(jl_mul_int) \\\n    XX(jl_native_alignment) \\\n    XX(jl_nb_available) \\\n    XX(jl_ne_float) \\\n    XX(jl_neg_float) \\\n    XX(jl_neg_float_withtype) \\\n    XX(jl_neg_int) \\\n    XX(jl_ne_int) \\\n    XX(jl_new_array) \\\n    XX(jl_new_bits) \\\n    XX(jl_new_code_info_uninit) \\\n    XX(jl_new_codeinst) \\\n    XX(jl_new_datatype) \\\n    XX(jl_new_foreign_type) \\\n    XX(jl_new_method_instance_uninit) \\\n    XX(jl_new_method_table) \\\n    XX(jl_new_method_uninit) \\\n    XX(jl_new_module) \\\n    XX(jl_new_primitivetype) \\\n    XX(jl_new_struct) \\\n    XX(jl_new_structt) \\\n    XX(jl_new_struct_uninit) \\\n    XX(jl_new_structv) \\\n    XX(jl_new_task) \\\n    XX(jl_new_typename_in) \\\n    XX(jl_new_typevar) \\\n    XX(jl_next_from_addrinfo) \\\n    XX(jl_no_exc_handler) \\\n    XX(jl_normalize_to_compilable_sig) \\\n    XX(jl_not_int) \\\n    XX(jl_object_id) \\\n    XX(jl_object_id_) \\\n    XX(jl_obvious_subtype) \\\n    XX(jl_operator_precedence) \\\n    XX(jl_op_suffix_char) \\\n    XX(jl_or_int) \\\n    XX(jl_parse) \\\n    XX(jl_parse_all) \\\n    XX(jl_parse_input_line) \\\n    XX(jl_parse_opts) \\\n    XX(jl_parse_string) \\\n    XX(jl_pathname_for_handle) \\\n    XX(jl_pchar_to_array) \\\n    XX(jl_pchar_to_string) \\\n    XX(jl_pointerref) \\\n    XX(jl_pointerset) \\\n    XX(jl_pop_handler) \\\n    XX(jl_preload_sysimg_so) \\\n    XX(jl_prepend_cwd) \\\n    XX(jl_printf) \\\n    XX(jl_process_events) \\\n    XX(jl_profile_clear_data) \\\n    XX(jl_profile_delay_nsec) \\\n    XX(jl_profile_get_data) \\\n    XX(jl_profile_init) \\\n    XX(jl_profile_is_running) \\\n    XX(jl_profile_len_data) \\\n    XX(jl_profile_maxlen_data) \\\n    XX(jl_profile_start_timer) \\\n    XX(jl_profile_stop_timer) \\\n    XX(jl_ptrarrayref) \\\n    XX(jl_ptr_to_array) \\\n    XX(jl_ptr_to_array_1d) \\\n    XX(jl_pwrite) \\\n    XX(jl_queue_work) \\\n    XX(jl_raise_debugger) \\\n    XX(jl_readuntil) \\\n    XX(jl_read_verify_header) \\\n    XX(jl_realloc) \\\n    XX(jl_register_newmeth_tracer) \\\n    XX(jl_rem_float) \\\n    XX(jl_repl_raise_sigtstp) \\\n    XX(jl_reshape_array) \\\n    XX(jl_restore_excstack) \\\n    XX(jl_restore_incremental) \\\n    XX(jl_restore_incremental_from_buf) \\\n    XX(jl_restore_system_image) \\\n    XX(jl_restore_system_image_data) \\\n    XX(jl_rethrow) \\\n    XX(jl_rethrow_other) \\\n    XX(jl_rettype_inferred) \\\n    XX(jl_rint_llvm) \\\n    XX(jl_rint_llvm_withtype) \\\n    XX(jl_running_on_valgrind) \\\n    XX(jl_safe_printf) \\\n    XX(jl_save_incremental) \\\n    XX(jl_save_system_image) \\\n    XX(jl_SC_CLK_TCK) \\\n    XX(jl_sdiv_int) \\\n    XX(jl_set_ARGS) \\\n    XX(jl_set_const) \\\n    XX(jl_set_errno) \\\n    XX(jl_set_global) \\\n    XX(jl_set_istopmod) \\\n    XX(jl_set_module_compile) \\\n    XX(jl_set_module_infer) \\\n    XX(jl_set_module_nospecialize) \\\n    XX(jl_set_module_optlevel) \\\n    XX(jl_set_module_uuid) \\\n    XX(jl_set_next_task) \\\n    XX(jl_set_nth_field) \\\n    XX(jl_set_ptls_states_getter) \\\n    XX(jl_set_safe_restore) \\\n    XX(jl_set_sysimg_so) \\\n    XX(jl_set_task_tid) \\\n    XX(jl_set_typeinf_func) \\\n    XX(jl_set_zero_subnormals) \\\n    XX(jl_sext_int) \\\n    XX(jl_shl_int) \\\n    XX(jl_sigatomic_begin) \\\n    XX(jl_sigatomic_end) \\\n    XX(jl_sig_throw) \\\n    XX(jl_sitofp) \\\n    XX(jl_sizeof_ios_t) \\\n    XX(jl_sizeof_jl_options) \\\n    XX(jl_sizeof_mode_t) \\\n    XX(jl_sizeof_off_t) \\\n    XX(jl_sizeof_stat) \\\n    XX(jl_sizeof_uv_fs_t) \\\n    XX(jl_sle_int) \\\n    XX(jl_slt_int) \\\n    XX(jl_smod_int) \\\n    XX(jl_sockaddr_from_addrinfo) \\\n    XX(jl_sockaddr_host4) \\\n    XX(jl_sockaddr_host6) \\\n    XX(jl_sockaddr_is_ip4) \\\n    XX(jl_sockaddr_is_ip6) \\\n    XX(jl_sockaddr_port4) \\\n    XX(jl_sockaddr_port6) \\\n    XX(jl_sockaddr_set_port) \\\n    XX(jl_spawn) \\\n    XX(jl_specializations_get_linfo) \\\n    XX(jl_specializations_lookup) \\\n    XX(jl_sqrt_llvm) \\\n    XX(jl_sqrt_llvm_fast) \\\n    XX(jl_sqrt_llvm_fast_withtype) \\\n    XX(jl_sqrt_llvm_withtype) \\\n    XX(jl_srem_int) \\\n    XX(jl_stat) \\\n    XX(jl_stat_blksize) \\\n    XX(jl_stat_blocks) \\\n    XX(jl_stat_ctime) \\\n    XX(jl_stat_dev) \\\n    XX(jl_stat_gid) \\\n    XX(jl_static_show) \\\n    XX(jl_static_show_func_sig) \\\n    XX(jl_stat_ino) \\\n    XX(jl_stat_mode) \\\n    XX(jl_stat_mtime) \\\n    XX(jl_stat_nlink) \\\n    XX(jl_stat_rdev) \\\n    XX(jl_stat_size) \\\n    XX(jl_stat_uid) \\\n    XX(jl_stderr_obj) \\\n    XX(jl_stderr_stream) \\\n    XX(jl_stdin_stream) \\\n    XX(jl_stdout_obj) \\\n    XX(jl_stdout_stream) \\\n    XX(jl_stored_inline) \\\n    XX(jl_string_ptr) \\\n    XX(jl_string_to_array) \\\n    XX(jl_strtod_c) \\\n    XX(jl_strtof_c) \\\n    XX(jl_sub_float) \\\n    XX(jl_sub_int) \\\n    XX(jl_sub_ptr) \\\n    XX(jl_substrtod) \\\n    XX(jl_substrtof) \\\n    XX(jl_subtype) \\\n    XX(jl_subtype_env) \\\n    XX(jl_subtype_env_size) \\\n    XX(jl_svec) \\\n    XX(jl_svec1) \\\n    XX(jl_svec2) \\\n    XX(jl_svec_copy) \\\n    XX(jl_svec_fill) \\\n    XX(jl_svec_isassigned) \\\n    XX(jl_svec_len) \\\n    XX(jl_svec_ref) \\\n    XX(jl_switch) \\\n    XX(jl_switchto) \\\n    XX(jl_symbol) \\\n    XX(jl_symbol_lookup) \\\n    XX(jl_symbol_n) \\\n    XX(jl_symbol_name) \\\n    XX(jl_tagged_gensym) \\\n    XX(jl_take_buffer) \\\n    XX(jl_task_get_next) \\\n    XX(jl_task_stack_buffer) \\\n    XX(jl_tcp_bind) \\\n    XX(jl_tcp_connect) \\\n    XX(jl_tcp_getpeername) \\\n    XX(jl_tcp_getsockname) \\\n    XX(jl_tcp_quickack) \\\n    XX(jl_tcp_reuseport) \\\n    XX(jl_test_cpu_feature) \\\n    XX(jl_threadid) \\\n    XX(jl_threading_enabled) \\\n    XX(jl_throw) \\\n    XX(jl_throw_out_of_memory_error) \\\n    XX(jl_too_few_args) \\\n    XX(jl_too_many_args) \\\n    XX(jl_toplevel_eval) \\\n    XX(jl_toplevel_eval_in) \\\n    XX(jl_trunc_int) \\\n    XX(jl_trunc_llvm) \\\n    XX(jl_trunc_llvm_withtype) \\\n    XX(jl_try_substrtod) \\\n    XX(jl_try_substrtof) \\\n    XX(jl_tty_set_mode) \\\n    XX(jl_tupletype_fill) \\\n    XX(jl_typeassert) \\\n    XX(jl_type_equality_is_identity) \\\n    XX(jl_type_error) \\\n    XX(jl_type_error_rt) \\\n    XX(jl_typeinf_begin) \\\n    XX(jl_typeinf_end) \\\n    XX(jl_type_intersection) \\\n    XX(jl_type_intersection_with_env) \\\n    XX(jl_typemax_uint) \\\n    XX(jl_type_morespecific) \\\n    XX(jl_type_morespecific_no_subtype) \\\n    XX(jl_typename_str) \\\n    XX(jl_typeof) \\\n    XX(jl_typeof_str) \\\n    XX(jl_types_equal) \\\n    XX(jl_type_to_llvm) \\\n    XX(jl_type_union) \\\n    XX(jl_type_unionall) \\\n    XX(jl_udiv_int) \\\n    XX(jl_udp_bind) \\\n    XX(jl_udp_send) \\\n    XX(jl_uitofp) \\\n    XX(jl_ule_int) \\\n    XX(jl_ult_int) \\\n    XX(jl_unbox_bool) \\\n    XX(jl_unbox_float32) \\\n    XX(jl_unbox_float64) \\\n    XX(jl_unbox_int16) \\\n    XX(jl_unbox_int32) \\\n    XX(jl_unbox_int64) \\\n    XX(jl_unbox_int8) \\\n    XX(jl_unbox_uint16) \\\n    XX(jl_unbox_uint32) \\\n    XX(jl_unbox_uint64) \\\n    XX(jl_unbox_uint8) \\\n    XX(jl_unbox_uint8pointer) \\\n    XX(jl_unbox_voidpointer) \\\n    XX(jl_uncompress_argname_n) \\\n    XX(jl_uncompress_argnames) \\\n    XX(jl_uncompress_ir) \\\n    XX(jl_undefined_var_error) \\\n    XX(jl_urem_int) \\\n    XX(jl_uv_associate_julia_struct) \\\n    XX(jl_uv_buf_base) \\\n    XX(jl_uv_buf_len) \\\n    XX(jl_uv_buf_set_base) \\\n    XX(jl_uv_buf_set_len) \\\n    XX(jl_uv_connect_handle) \\\n    XX(jl_uv_disassociate_julia_struct) \\\n    XX(jl_uv_file_handle) \\\n    XX(jl_uv_flush) \\\n    XX(jl_uv_fs_t_path) \\\n    XX(jl_uv_fs_t_ptr) \\\n    XX(jl_uv_handle) \\\n    XX(jl_uv_handle_data) \\\n    XX(jl_uv_handle_type) \\\n    XX(jl_uv_interface_addresses) \\\n    XX(jl_uv_interface_address_is_internal) \\\n    XX(jl_uv_interface_address_sockaddr) \\\n    XX(jl_uv_process_data) \\\n    XX(jl_uv_process_pid) \\\n    XX(jl_uv_putb) \\\n    XX(jl_uv_putc) \\\n    XX(jl_uv_puts) \\\n    XX(jl_uv_req_data) \\\n    XX(jl_uv_req_set_data) \\\n    XX(jl_uv_sizeof_interface_address) \\\n    XX(jl_uv_unix_fd_is_watched) \\\n    XX(jl_uv_write) \\\n    XX(jl_uv_writecb) \\\n    XX(jl_uv_write_handle) \\\n    XX(jl_valueof) \\\n    XX(jl_value_ptr) \\\n    XX(jl_ver_is_release) \\\n    XX(jl_ver_major) \\\n    XX(jl_ver_minor) \\\n    XX(jl_ver_patch) \\\n    XX(jl_ver_string) \\\n    XX(jl_vexceptionf) \\\n    XX(jl_vprintf) \\\n    XX(jl_wakeup_thread) \\\n    XX(jl_xor_int) \\\n    XX(jl_yield) \\\n    XX(jl_zext_int)\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/sys.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n/*\n  sys.c\n  I/O and operating system utility functions\n*/\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n\n#ifdef _OS_WINDOWS_\n#include <psapi.h>\n#else\n#include <unistd.h>\n#if !defined(_SC_NPROCESSORS_ONLN) || defined(_OS_FREEBSD_) || defined(_OS_DARWIN_)\n// try secondary location for _SC_NPROCESSORS_ONLN, or for HW_AVAILCPU on BSDs\n#include <sys/sysctl.h>\n#endif\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#endif\n\n#ifndef _OS_WINDOWS_\n// for getrusage\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#ifdef __APPLE__\n#include <mach-o/dyld.h>\n#include <mach-o/nlist.h>\n#include <sys/types.h> // for jl_raise_debugger\n#elif !defined(_OS_WINDOWS_)\n#include <link.h>\n#endif\n\n#ifdef __SSE__\n#include <xmmintrin.h>\n#endif\n\n#if defined _MSC_VER\n#include <io.h>\n#include <intrin.h>\n#endif\n\n#ifdef JL_MSAN_ENABLED\n#include <sanitizer/msan_interface.h>\n#endif\n\n#include \"julia_assert.h\"\n\n#include <llvm-c/Core.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(_OS_WINDOWS_) && !defined(_COMPILER_GCC_)\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\nJL_DLLEXPORT int jl_sizeof_off_t(void) { return sizeof(off_t); }\n#ifndef _OS_WINDOWS_\nJL_DLLEXPORT int jl_sizeof_mode_t(void) { return sizeof(mode_t); }\nJL_DLLEXPORT int jl_ftruncate(int fd, int64_t length)\n{\n    return ftruncate(fd, (off_t)length);\n}\nJL_DLLEXPORT int64_t jl_lseek(int fd, int64_t offset, int whence)\n{\n    return lseek(fd, (off_t)offset, whence);\n}\nJL_DLLEXPORT ssize_t jl_pwrite(int fd, const void *buf, size_t count, int64_t offset)\n{\n    return pwrite(fd, buf, count, (off_t)offset);\n}\nJL_DLLEXPORT void *jl_mmap(void *addr, size_t length, int prot, int flags,\n                           int fd, int64_t offset)\n{\n    return mmap(addr, length, prot, flags, fd, (off_t)offset);\n}\n#else\nJL_DLLEXPORT int64_t jl_lseek(HANDLE fd, int64_t offset, int whence)\n{\n    LARGE_INTEGER tell;\n    tell.QuadPart = offset;\n    if (SetFilePointerEx(fd, tell, &tell, whence) == 0)\n        return -1;\n    return tell.QuadPart;\n}\n#endif\nJL_DLLEXPORT int jl_sizeof_ios_t(void) { return sizeof(ios_t); }\n\nJL_DLLEXPORT long jl_ios_fd(ios_t *s) { return s->fd; }\n\nJL_DLLEXPORT int32_t jl_nb_available(ios_t *s)\n{\n    return (int32_t)(s->size - s->bpos);\n}\n\n// --- dir/file stuff ---\n\nJL_DLLEXPORT int jl_sizeof_uv_fs_t(void) { return sizeof(uv_fs_t); }\nJL_DLLEXPORT char *jl_uv_fs_t_ptr(uv_fs_t *req) { return (char*)req->ptr; }\nJL_DLLEXPORT char *jl_uv_fs_t_path(uv_fs_t *req) { return (char*)req->path; }\n\n// --- stat ---\nJL_DLLEXPORT int jl_sizeof_stat(void) { return sizeof(uv_stat_t); }\n\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf) JL_NOTSAFEPOINT\n{\n    uv_fs_t req;\n    int ret;\n\n    // Ideally one would use the statbuf for the storage in req, but\n    // it's not clear that this is possible using libuv\n    ret = uv_fs_stat(unused_uv_loop_arg, &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_lstat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_lstat(unused_uv_loop_arg, &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_fstat(uv_os_fd_t fd, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_fstat(unused_uv_loop_arg, &req, fd, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_dev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_dev;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_ino(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_ino;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_mode(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_mode;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_nlink(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_nlink;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_uid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_uid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_gid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_gid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_rdev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_rdev;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_size(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_size;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blksize(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blksize;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blocks(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blocks;\n}\n\n/*\n// atime is stupid, let's not support it\nJL_DLLEXPORT double jl_stat_atime(char *statbuf)\n{\n  uv_stat_t *s;\n  s = (uv_stat_t*)statbuf;\n  return (double)s->st_atim.tv_sec + (double)s->st_atim.tv_nsec * 1e-9;\n}\n*/\n\nJL_DLLEXPORT double jl_stat_mtime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_mtim.tv_sec + (double)s->st_mtim.tv_nsec * 1e-9;\n}\n\nJL_DLLEXPORT double jl_stat_ctime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_ctim.tv_sec + (double)s->st_ctim.tv_nsec * 1e-9;\n}\n\n// --- buffer manipulation ---\n\nJL_DLLEXPORT jl_array_t *jl_take_buffer(ios_t *s)\n{\n    size_t n;\n    jl_array_t *a;\n    if (s->buf == &s->local[0]) {\n        // small data case. copies, but this can be avoided using the\n        // technique of jl_readuntil below.\n        a = jl_pchar_to_array(s->buf, s->size);\n        ios_trunc(s, 0);\n    }\n    else {\n        char *b = ios_take_buffer(s, &n);\n        a = jl_ptr_to_array_1d(jl_array_uint8_type, b, n-1, 1);\n    }\n    return a;\n}\n\n// str: if 1 return a string, otherwise return a Vector{UInt8}\n// chomp:\n//   0 - keep delimiter\n//   1 - remove 1 byte delimiter\n//   2 - remove 2 bytes \\r\\n if present\nJL_DLLEXPORT jl_value_t *jl_readuntil(ios_t *s, uint8_t delim, uint8_t str, uint8_t chomp)\n{\n    jl_array_t *a;\n    // manually inlined common case\n    char *pd = (char*)memchr(s->buf + s->bpos, delim, (size_t)(s->size - s->bpos));\n    if (pd) {\n        size_t n = pd - (s->buf + s->bpos) + 1;\n        size_t nchomp = 0;\n        if (chomp) {\n            nchomp = chomp == 2 ? ios_nchomp(s, n) : 1;\n        }\n        if (str) {\n            jl_value_t *str = jl_pchar_to_string(s->buf + s->bpos, n - nchomp);\n            s->bpos += n;\n            return str;\n        }\n        a = jl_alloc_array_1d(jl_array_uint8_type, n - nchomp);\n        memcpy(jl_array_data(a), s->buf + s->bpos, n - nchomp);\n        s->bpos += n;\n    }\n    else {\n        a = jl_alloc_array_1d(jl_array_uint8_type, 80);\n        ios_t dest;\n        ios_mem(&dest, 0);\n        ios_setbuf(&dest, (char*)a->data, 80, 0);\n        size_t n = ios_copyuntil(&dest, s, delim);\n        if (chomp && n > 0 && dest.buf[n - 1] == delim) {\n            n--;\n            if (chomp == 2 && n > 0 && dest.buf[n - 1] == '\\r') {\n                n--;\n            }\n            int truncret = ios_trunc(&dest, n); // it should always be possible to truncate dest\n            assert(truncret == 0);\n            (void)truncret; // ensure the variable is used to avoid warnings\n        }\n        if (dest.buf != a->data) {\n            a = jl_take_buffer(&dest);\n        }\n        else {\n#ifdef STORE_ARRAY_LEN\n            a->length = n;\n#endif\n            a->nrows = n;\n            ((char*)a->data)[n] = '\\0';\n        }\n        if (str) {\n            JL_GC_PUSH1(&a);\n            jl_value_t *st = jl_array_to_string(a);\n            JL_GC_POP();\n            return st;\n        }\n    }\n    return (jl_value_t*)a;\n}\n\nJL_DLLEXPORT int jl_ios_buffer_n(ios_t *s, const size_t n)\n{\n    size_t space, ret;\n    do {\n        space = (size_t)(s->size - s->bpos);\n        ret = ios_readprep(s, n);\n        if (space == ret && ret < n)\n            return 1;\n    } while (ret < n);\n    return 0;\n}\n\nJL_DLLEXPORT uint64_t jl_ios_get_nbyte_int(ios_t *s, const size_t n)\n{\n    assert(n <= 8);\n    uint64_t x = 0;\n    uint8_t *buf = (uint8_t*)&s->buf[s->bpos];\n    if (n == 8) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 8; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else if (n >= 4) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 4; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n        for (size_t i = 4; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else {\n        for (size_t i = 0; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    s->bpos += n;\n    return x;\n}\n\n// -- syscall utilities --\n\nJL_DLLEXPORT int jl_errno(void) JL_NOTSAFEPOINT { return errno; }\nJL_DLLEXPORT void jl_set_errno(int e) JL_NOTSAFEPOINT { errno = e; }\n\n// -- get the number of CPU threads (logical cores) --\n\n#ifdef _OS_WINDOWS_\ntypedef DWORD (WINAPI *GAPC)(WORD);\n#ifndef ALL_PROCESSOR_GROUPS\n#define ALL_PROCESSOR_GROUPS 0xffff\n#endif\n#endif\n\nJL_DLLEXPORT int jl_cpu_threads(void) JL_NOTSAFEPOINT\n{\n#if defined(HW_AVAILCPU) && defined(HW_NCPU)\n    size_t len = 4;\n    int32_t count;\n    int nm[2] = {CTL_HW, HW_AVAILCPU};\n    sysctl(nm, 2, &count, &len, NULL, 0);\n    if (count < 1) {\n        nm[1] = HW_NCPU;\n        sysctl(nm, 2, &count, &len, NULL, 0);\n        if (count < 1) { count = 1; }\n    }\n    return count;\n#elif defined(_SC_NPROCESSORS_ONLN)\n    long count = sysconf(_SC_NPROCESSORS_ONLN);\n    if (count < 1)\n        return 1;\n    return count;\n#elif defined(_OS_WINDOWS_)\n    //Try to get WIN7 API method\n    GAPC gapc;\n    if (jl_dlsym(jl_kernel32_handle, \"GetActiveProcessorCount\", (void **)&gapc, 0)) {\n        return gapc(ALL_PROCESSOR_GROUPS);\n    }\n    else { //fall back on GetSystemInfo\n        SYSTEM_INFO info;\n        GetSystemInfo(&info);\n        return info.dwNumberOfProcessors;\n    }\n#else\n#warning \"cpu core detection not defined for this platform\"\n    return 1;\n#endif\n}\n\n\n// -- high resolution timers --\n// Returns time in nanosec\nJL_DLLEXPORT uint64_t jl_hrtime(void) JL_NOTSAFEPOINT\n{\n    return uv_hrtime();\n}\n\n// -- iterating the environment --\n\n#ifdef __APPLE__\n#include <crt_externs.h>\n#else\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_GCC_)\nextern char **environ;\n#endif\n#endif\n\nJL_DLLEXPORT jl_value_t *jl_environ(int i)\n{\n#ifdef __APPLE__\n    char **environ = *_NSGetEnviron();\n#endif\n    char *env = environ[i];\n    return env ? jl_pchar_to_string(env, strlen(env)) : jl_nothing;\n}\n\n// -- child process status --\n\n#if defined _MSC_VER || defined _OS_WINDOWS_\n/* Native Woe32 API.  */\n#include <process.h>\n#define waitpid(pid,statusp,options) _cwait (statusp, pid, WAIT_CHILD)\n#define WAIT_T int\n#define WTERMSIG(x) ((x) & 0xff) /* or: SIGABRT ?? */\n#define WCOREDUMP(x) 0\n#define WEXITSTATUS(x) (((x) >> 8) & 0xff) /* or: (x) ?? */\n#define WIFSIGNALED(x) (WTERMSIG (x) != 0) /* or: ((x) == 3) ?? */\n#define WIFEXITED(x) (WTERMSIG (x) == 0) /* or: ((x) != 3) ?? */\n#define WIFSTOPPED(x) 0\n#define WSTOPSIG(x) 0 //Is this correct?\n#endif\n\nint jl_process_exited(int status)      { return WIFEXITED(status); }\nint jl_process_signaled(int status)    { return WIFSIGNALED(status); }\nint jl_process_stopped(int status)     { return WIFSTOPPED(status); }\n\nint jl_process_exit_status(int status) { return WEXITSTATUS(status); }\nint jl_process_term_signal(int status) { return WTERMSIG(status); }\nint jl_process_stop_signal(int status) { return WSTOPSIG(status); }\n\n// -- access to std filehandles --\n\nJL_STREAM *JL_STDIN  = (JL_STREAM*)STDIN_FILENO;\nJL_STREAM *JL_STDOUT = (JL_STREAM*)STDOUT_FILENO;\nJL_STREAM *JL_STDERR = (JL_STREAM*)STDERR_FILENO;\n\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void)  { return JL_STDIN; }\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void) { return JL_STDOUT; }\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void) { return JL_STDERR; }\n\n// -- processor native alignment information --\n\nJL_DLLEXPORT void jl_native_alignment(uint_t *int8align, uint_t *int16align, uint_t *int32align,\n                                      uint_t *int64align, uint_t *float32align, uint_t *float64align)\n{\n    *int8align = __alignof(uint8_t);\n    *int16align = __alignof(uint16_t);\n    *int32align = __alignof(uint32_t);\n    *int64align = __alignof(uint64_t);\n    *float32align = __alignof(float);\n    *float64align = __alignof(double);\n}\n\nJL_DLLEXPORT jl_value_t *jl_is_char_signed(void)\n{\n    return ((char)255) < 0 ? jl_true : jl_false;\n}\n\n// -- misc sysconf info --\n\n#ifdef _OS_WINDOWS_\nstatic long cachedPagesize = 0;\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    if (!cachedPagesize) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedPagesize = systemInfo.dwPageSize;\n    }\n    return cachedPagesize;\n}\n#else\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    long page_size = sysconf(_SC_PAGESIZE);\n    assert(page_size != -1);\n    return page_size;\n}\n#endif\n\n#ifdef _OS_WINDOWS_\nstatic long cachedAllocationGranularity = 0;\nJL_DLLEXPORT long jl_getallocationgranularity(void) JL_NOTSAFEPOINT\n{\n    if (!cachedAllocationGranularity) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedAllocationGranularity = systemInfo.dwAllocationGranularity;\n    }\n    return cachedAllocationGranularity;\n}\n#else\nJL_DLLEXPORT long jl_getallocationgranularity(void) JL_NOTSAFEPOINT\n{\n    return jl_getpagesize();\n}\n#endif\n\nJL_DLLEXPORT long jl_SC_CLK_TCK(void)\n{\n#ifndef _OS_WINDOWS_\n    return sysconf(_SC_CLK_TCK);\n#else\n    return 0;\n#endif\n}\n\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nJL_DLLEXPORT const char *jl_pathname_for_handle(void *handle)\n{\n    if (!handle)\n        return NULL;\n\n#ifdef __APPLE__\n    // Iterate through all images currently in memory\n    for (int32_t i = _dyld_image_count() - 1; i >= 0 ; i--) {\n        // dlopen() each image, check handle\n        const char *image_name = _dyld_get_image_name(i);\n        void *probe_lib = jl_load_dynamic_library(image_name, JL_RTLD_DEFAULT | JL_RTLD_NOLOAD, 0);\n        jl_dlclose(probe_lib);\n\n        // If the handle is the same as what was passed in (modulo mode bits), return this image name\n        if (((intptr_t)handle & (-4)) == ((intptr_t)probe_lib & (-4)))\n            return image_name;\n    }\n\n#elif defined(_OS_WINDOWS_)\n\n    wchar_t *pth16 = (wchar_t*)malloc_s(32768 * sizeof(*pth16)); // max long path length\n    DWORD n16 = GetModuleFileNameW((HMODULE)handle, pth16, 32768);\n    if (n16 <= 0) {\n        free(pth16);\n        return NULL;\n    }\n    pth16[n16] = L'\\0';\n    DWORD n8 = WideCharToMultiByte(CP_UTF8, 0, pth16, -1, NULL, 0, NULL, NULL);\n    if (n8 == 0) {\n        free(pth16);\n        return NULL;\n    }\n    char *filepath = (char*)malloc_s(++n8);\n    if (!WideCharToMultiByte(CP_UTF8, 0, pth16, -1, filepath, n8, NULL, NULL)) {\n        free(pth16);\n        free(filepath);\n        return NULL;\n    }\n    free(pth16);\n    return filepath;\n\n#else // Linux, FreeBSD, ...\n\n    struct link_map *map;\n    dlinfo(handle, RTLD_DI_LINKMAP, &map);\n#ifdef JL_MSAN_ENABLED\n    __msan_unpoison(&map,sizeof(struct link_map*));\n    if (map) {\n        __msan_unpoison(map, sizeof(struct link_map));\n        __msan_unpoison_string(map->l_name);\n    }\n#endif\n    if (map)\n        return map->l_name;\n\n#endif\n    return NULL;\n}\n\n#ifdef _OS_WINDOWS_\n// Get a list of all the modules in this process.\nJL_DLLEXPORT int jl_dllist(jl_array_t *list)\n{\n    DWORD cb, cbNeeded;\n    HMODULE *hMods = NULL;\n    unsigned int i;\n    cbNeeded = 1024 * sizeof(*hMods);\n    do {\n        cb = cbNeeded;\n        hMods = (HMODULE*)realloc_s(hMods, cb);\n        if (!EnumProcessModulesEx(GetCurrentProcess(), hMods, cb, &cbNeeded, LIST_MODULES_ALL)) {\n          free(hMods);\n          return FALSE;\n        }\n    } while (cb < cbNeeded);\n    for (i = 0; i < cbNeeded / sizeof(HMODULE); i++) {\n        const char *path = jl_pathname_for_handle(hMods[i]);\n        // XXX: change to jl_arrayset if array storage allocation for Array{String,1} changes:\n        if (path == NULL)\n            continue;\n        jl_array_grow_end((jl_array_t*)list, 1);\n        jl_value_t *v = jl_cstr_to_string(path);\n        free(path);\n        jl_array_ptr_set(list, jl_array_dim0(list) - 1, v);\n    }\n    free(hMods);\n    return TRUE;\n}\n#endif\n\nJL_DLLEXPORT void jl_raise_debugger(void)\n{\n#if defined(_OS_WINDOWS_)\n    if (IsDebuggerPresent() == 1)\n        DebugBreak();\n#else\n    raise(SIGTRAP);\n#endif // _OS_WINDOWS_\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void) JL_NOTSAFEPOINT\n{\n    return jl_symbol(JL_BUILD_UNAME);\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void) JL_NOTSAFEPOINT\n{\n    return jl_symbol(JL_BUILD_ARCH);\n}\n\nJL_DLLEXPORT size_t jl_maxrss(void)\n{\n#if defined(_OS_WINDOWS_)\n    PROCESS_MEMORY_COUNTERS counter;\n    GetProcessMemoryInfo( GetCurrentProcess( ), &counter, sizeof(counter) );\n    return (size_t)counter.PeakWorkingSetSize;\n\n// FIXME: `rusage` is available on OpenBSD, DragonFlyBSD and NetBSD as well.\n//        All of them return `ru_maxrss` in kilobytes.\n#elif defined(_OS_LINUX_) || defined(_OS_DARWIN_) || defined (_OS_FREEBSD_)\n    struct rusage rusage;\n    getrusage( RUSAGE_SELF, &rusage );\n\n#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n    return (size_t)(rusage.ru_maxrss * 1024);\n#else\n    return (size_t)rusage.ru_maxrss;\n#endif\n\n#else\n    return (size_t)0;\n#endif\n}\n\nJL_DLLEXPORT int jl_threading_enabled(void)\n{\n    return 1;\n}\n\nJL_DLLEXPORT jl_value_t *jl_get_libllvm(void) JL_NOTSAFEPOINT {\n#if defined(_OS_WINDOWS_)\n    HMODULE mod;\n    // FIXME: GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS on LLVMContextCreate,\n    //        but that just points to libjulia.dll\n    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, \"LLVM\", &mod))\n        return jl_nothing;\n\n    char path[MAX_PATH];\n    if (!GetModuleFileNameA(mod, path, sizeof(path)))\n        return jl_nothing;\n    return (jl_value_t*) jl_symbol(path);\n#else\n    Dl_info dli;\n    if (!dladdr(LLVMContextCreate, &dli))\n        return jl_nothing;\n    return (jl_value_t*) jl_symbol(dli.dli_fname);\n#endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/dlload.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n\n#include \"platform.h\"\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#ifdef _OS_WINDOWS_\n#include <windows.h>\n#include <direct.h>\n#else\n#include <unistd.h>\n#include <dlfcn.h>\n#endif\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(__APPLE__)\nstatic char const *const extensions[] = { \"\", \".dylib\" };\n#elif defined(_OS_WINDOWS_)\nstatic char const *const extensions[] = { \"\", \".dll\" };\nextern volatile int needsSymRefreshModuleList;\n#else\nstatic char const *const extensions[] = { \"\", \".so\" };\n#endif\n#define N_EXTENSIONS (sizeof(extensions) / sizeof(char*))\n\nstatic int endswith_extension(const char *path) JL_NOTSAFEPOINT\n{\n    if (!path)\n        return 0;\n    size_t len = strlen(path);\n    // Skip the first one since it is empty\n    for (size_t i = 1; i < N_EXTENSIONS; i++) {\n        const char *ext = extensions[i];\n        size_t extlen = strlen(ext);\n        if (len < extlen)\n            return 0;\n        // Skip version extensions if present\n        size_t j = len - 1;\n        while (j > 0) {\n            if (path[j] == '.' || (path[j] >= '0' && path[j] <= '9'))\n                j--;\n            else\n                break;\n        }\n        if ((j == len-1 || path[j+1] == '.') && memcmp(ext, path + j - extlen + 1, extlen) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n#define PATHBUF 4096\n\n#define JL_RTLD(flags, FLAG) (flags & JL_RTLD_ ## FLAG ? RTLD_ ## FLAG : 0)\n\n#ifdef _OS_WINDOWS_\nstatic void win32_formatmessage(DWORD code, char *reason, int len) JL_NOTSAFEPOINT\n{\n    DWORD res;\n    LPWSTR errmsg;\n    res = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_FROM_SYSTEM |\n                         FORMAT_MESSAGE_IGNORE_INSERTS |\n                         FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                         NULL, code,\n                         MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                         (LPWSTR)&errmsg, 0, NULL);\n    if (!res && (GetLastError() == ERROR_MUI_FILE_NOT_FOUND ||\n                 GetLastError() == ERROR_RESOURCE_TYPE_NOT_FOUND)) {\n      res = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                           FORMAT_MESSAGE_FROM_SYSTEM |\n                           FORMAT_MESSAGE_IGNORE_INSERTS |\n                           FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                           NULL, code,\n                           0, (LPWSTR)&errmsg, 0, NULL);\n    }\n    res = WideCharToMultiByte(CP_UTF8, 0, errmsg, -1, reason, len, NULL, NULL);\n    assert(res > 0 || GetLastError() == ERROR_INSUFFICIENT_BUFFER);\n    reason[len - 1] = '\\0';\n    LocalFree(errmsg);\n}\n#endif\n\nJL_DLLEXPORT void *jl_dlopen(const char *filename, unsigned flags) JL_NOTSAFEPOINT\n{\n#if defined(_OS_WINDOWS_)\n    size_t len = MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);\n    if (!len) return NULL;\n    WCHAR *wfilename = (WCHAR*)alloca(len * sizeof(WCHAR));\n    if (!MultiByteToWideChar(CP_UTF8, 0, filename, -1, wfilename, len)) return NULL;\n    HANDLE lib = LoadLibraryExW(wfilename, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n    if (lib)\n        needsSymRefreshModuleList = 1;\n    return lib;\n#else\n    dlerror(); /* Reset error status. */\n    return dlopen(filename,\n                  (flags & JL_RTLD_NOW ? RTLD_NOW : RTLD_LAZY)\n                  | JL_RTLD(flags, LOCAL)\n                  | JL_RTLD(flags, GLOBAL)\n#ifdef RTLD_NODELETE\n                  | JL_RTLD(flags, NODELETE)\n#endif\n#ifdef RTLD_NOLOAD\n                  | JL_RTLD(flags, NOLOAD)\n#endif\n#if defined(RTLD_DEEPBIND) && !(defined(JL_ASAN_ENABLED) || defined(JL_TSAN_ENABLED) || defined(JL_MSAN_ENABLED))\n                  | JL_RTLD(flags, DEEPBIND)\n#endif\n#ifdef RTLD_FIRST\n                  | JL_RTLD(flags, FIRST)\n#endif\n                  );\n#endif\n}\n\nJL_DLLEXPORT int jl_dlclose(void *handle) JL_NOTSAFEPOINT\n{\n#ifdef _OS_WINDOWS_\n    if (!handle) return -1;\n    return !FreeLibrary((HMODULE) handle);\n#else\n    dlerror(); /* Reset error status. */\n    if (!handle) return -1;\n    return dlclose(handle);\n#endif\n}\n\nJL_DLLEXPORT void *jl_load_dynamic_library(const char *modname, unsigned flags, int throw_err) JL_NOTSAFEPOINT // (or throw)\n{\n    char path[PATHBUF], relocated[PATHBUF];\n    int i;\n#ifdef _OS_WINDOWS_\n    int err;\n#endif\n    uv_stat_t stbuf;\n    void *handle;\n    int abspath;\n    // number of extensions to try \u2014\u00a0if modname already ends with the\n    // standard extension, then we don't try adding additional extensions\n    int n_extensions = endswith_extension(modname) ? 1 : N_EXTENSIONS;\n\n    /*\n      this branch returns handle of libjulia-internal\n    */\n    if (modname == NULL) {\n#ifdef _OS_WINDOWS_\n        if (!GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                                (LPCWSTR)(uintptr_t)(&jl_load_dynamic_library),\n                                (HMODULE*)&handle)) {\n#ifndef __clang_analyzer__\n            // Hide the error throwing from the analyser since there isn't a way to express\n            // \"safepoint only when throwing error\" currently.\n            jl_error(\"could not load base module\");\n#endif\n        }\n#else\n        Dl_info info;\n        if (!dladdr((void*)(uintptr_t)&jl_load_dynamic_library, &info) || !info.dli_fname) {\n#ifndef __clang_analyzer__\n            // Hide the error throwing from the analyser since there isn't a way to express\n            // \"safepoint only when throwing error\" currently.\n            jl_error(\"could not load base module\");\n#endif\n        }\n        handle = dlopen(info.dli_fname, RTLD_NOW);\n#endif\n        goto done;\n    }\n\n    abspath = isabspath(modname);\n\n    /*\n      this branch permutes all base paths in DL_LOAD_PATH with all extensions\n      note: skip when !jl_base_module to avoid UndefVarError(:DL_LOAD_PATH),\n            and also skip for absolute paths\n      We also do simple string replacement here for elements starting with `@executable_path/`.\n      While these exist as OS concepts on Darwin, we want to use them on other platforms\n      such as Windows, so we emulate them here.\n    */\n    if (!abspath && jl_base_module != NULL) {\n        jl_binding_t *b = jl_get_module_binding(jl_base_module, jl_symbol(\"DL_LOAD_PATH\"));\n        jl_array_t *DL_LOAD_PATH = (jl_array_t*)(b ? b->value : NULL);\n        if (DL_LOAD_PATH != NULL) {\n            size_t j;\n            for (j = 0; j < jl_array_len(DL_LOAD_PATH); j++) {\n                char *dl_path = jl_string_data(jl_array_ptr_data(DL_LOAD_PATH)[j]);\n                size_t len = strlen(dl_path);\n                if (len == 0)\n                    continue;\n\n                // Is this entry supposed to be relative to the bindir?\n                if (len >= 16 && strncmp(dl_path, \"@executable_path\", 16) == 0) {\n                    snprintf(relocated, PATHBUF, \"%s%s\", jl_options.julia_bindir, dl_path + 16);\n                    len = len - 16 + strlen(jl_options.julia_bindir);\n                } else {\n                    strncpy(relocated, dl_path, PATHBUF);\n                    relocated[PATHBUF-1] = '\\0';\n                }\n                for (i = 0; i < n_extensions; i++) {\n                    const char *ext = extensions[i];\n                    path[0] = '\\0';\n                    if (relocated[len-1] == PATHSEPSTRING[0])\n                        snprintf(path, PATHBUF, \"%s%s%s\", relocated, modname, ext);\n                    else\n                        snprintf(path, PATHBUF, \"%s\" PATHSEPSTRING \"%s%s\", relocated, modname, ext);\n#ifdef _OS_WINDOWS_\n                    if (i == 0) { // LoadLibrary already tested the extensions, we just need to check the `stat` result\n#endif\n                        handle = jl_dlopen(path, flags);\n                        if (handle)\n                            goto done;\n#ifdef _OS_WINDOWS_\n                        err = GetLastError();\n                    }\n#endif\n                    // bail out and show the error if file actually exists\n                    if (jl_stat(path, (char*)&stbuf) == 0)\n                        goto notfound;\n                }\n            }\n        }\n    }\n\n    // now fall back and look in default library paths, for all extensions\n    for (i = 0; i < n_extensions; i++) {\n        const char *ext = extensions[i];\n        path[0] = '\\0';\n        snprintf(path, PATHBUF, \"%s%s\", modname, ext);\n        handle = jl_dlopen(path, flags);\n        if (handle)\n            goto done;\n#ifdef _OS_WINDOWS_\n        err = GetLastError();\n        break; // LoadLibrary already tested the rest\n#endif\n    }\n\nnotfound:\n    if (throw_err) {\n#ifdef _OS_WINDOWS_\n        char reason[256];\n        win32_formatmessage(err, reason, sizeof(reason));\n#else\n        const char *reason = dlerror();\n#endif\n#ifndef __clang_analyzer__\n        // Hide the error throwing from the analyser since there isn't a way to express\n        // \"safepoint only when throwing error\" currently.\n        jl_errorf(\"could not load library \\\"%s\\\"\\n%s\", modname, reason);\n#endif\n    }\n    handle = NULL;\n\ndone:\n    return handle;\n}\n\nJL_DLLEXPORT int jl_dlsym(void *handle, const char *symbol, void ** value, int throw_err) JL_NOTSAFEPOINT\n{\n    int symbol_found = 0;\n\n    /* First, get the symbol value */\n#ifdef _OS_WINDOWS_\n    *value = GetProcAddress((HMODULE) handle, symbol);\n#else\n    dlerror(); /* Reset error status. */\n    *value = dlsym(handle, symbol);\n#endif\n\n    /* Next, check for errors.  On Windows, a NULL pointer means the symbol\n     * was not found.  On everything else, we can have NULL symbols, so we check\n     * for non-NULL returns from dlerror().  Note that means we unconditionally\n     * call dlerror() on POSIX systems.*/\n#ifdef _OS_WINDOWS_\n    symbol_found = *value != NULL;\n#else\n    const char *err = dlerror();\n    symbol_found = err == NULL;\n#endif\n\n    if (!symbol_found && throw_err) {\n#ifdef _OS_WINDOWS_\n        char err[256];\n        win32_formatmessage(GetLastError(), err, sizeof(err));\n#endif\n#ifndef __clang_analyzer__\n        // Hide the error throwing from the analyser since there isn't a way to express\n        // \"safepoint only when throwing error\" currently.\n        jl_errorf(\"could not load symbol \\\"%s\\\":\\n%s\", symbol, err);\n#endif\n    }\n    return symbol_found;\n}\n\n#ifdef _OS_WINDOWS_\n//Look for symbols in win32 libraries\nconst char *jl_dlfind_win32(const char *f_name)\n{\n    void * dummy;\n    if (jl_dlsym(jl_exe_handle, f_name, &dummy, 0))\n        return JL_EXE_LIBNAME;\n    if (jl_dlsym(jl_libjulia_internal_handle, f_name, &dummy, 0))\n        return JL_LIBJULIA_INTERNAL_DL_LIBNAME;\n    if (jl_dlsym(jl_libjulia_handle, f_name, &dummy, 0))\n        return JL_LIBJULIA_DL_LIBNAME;\n    if (jl_dlsym(jl_kernel32_handle, f_name, &dummy, 0))\n        return \"kernel32\";\n    if (jl_dlsym(jl_ntdll_handle, f_name, &dummy, 0))\n        return \"ntdll\";\n    if (jl_dlsym(jl_crtdll_handle, f_name, &dummy, 0))\n#if defined(_MSC_VER)\n#if _MSC_VER == 1800\n        return \"msvcr120\";\n#else\n#error This version of MSVC has not been tested.\n#endif\n#else\n        return \"msvcrt\";\n#endif\n    if (jl_dlsym(jl_winsock_handle, f_name, &dummy, 0))\n        return \"ws2_32\";\n    // additional common libraries (libc?) could be added here, but in general,\n    // it is better to specify the library explicitly in the code. This exists\n    // mainly to ease compatibility with linux, and for libraries that don't\n    // have a name (julia.exe and libjulia.dll)\n    // We could also loop over all libraries that have been used so far, but, again,\n    // explicit is preferred over implicit\n    return NULL;\n    // oops, we didn't find it. NULL defaults to searching jl_RTLD_DEFAULT_handle,\n    // which defaults to jl_libjulia_internal_handle, where we won't find it, and\n    // will throw the appropriate error.\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/init.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n/*\n  init.c\n  system initialization and global state\n*/\n#include \"platform.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n\n#include <errno.h>\n\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_GCC_)\n#include <getopt.h>\n#endif\n\n#if defined(_OS_FREEBSD_)\n#include <pthread_np.h>\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#define DEFINE_BUILTIN_GLOBALS\n#include \"builtin_proto.h\"\n#undef DEFINE_BUILTIN_GLOBALS\n#include \"threading.h\"\n#include \"julia_assert.h\"\n#include \"processor.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _MSC_VER\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\n#ifdef _OS_WINDOWS_\nextern int needsSymRefreshModuleList;\nextern BOOL (WINAPI *hSymRefreshModuleList)(HANDLE);\n#else\n#include <sys/resource.h>\n#include <unistd.h>\n#endif\n\n// list of modules being deserialized with __init__ methods\njl_array_t *jl_module_init_order;\n\nsize_t jl_page_size;\n\nvoid jl_init_stack_limits(int ismaster, void **stack_lo, void **stack_hi)\n{\n#ifdef _OS_WINDOWS_\n    (void)ismaster;\n    // https://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n#  ifdef _P64\n    *stack_hi = (void**)__readgsqword(0x08); // Stack Base / Bottom of stack (high address)\n    *stack_lo = (void**)__readgsqword(0x10); // Stack Limit / Ceiling of stack (low address)\n#  else // !_P64\n    *stack_hi = (void**)__readfsdword(0x04); // Stack Base / Bottom of stack (high address)\n    *stack_lo = (void**)__readfsdword(0x08); // Stack Limit / Ceiling of stack (low address)\n#  endif // _P64\n#else // !_OS_WINDOWS_\n    // Only use pthread_*_np functions to get stack address for non-master\n    // threads since it seems to return bogus values for master thread on Linux\n    // and possibly OSX.\n    if (!ismaster) {\n#  if defined(_OS_LINUX_)\n        pthread_attr_t attr;\n        pthread_getattr_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        *stack_lo = (void*)stackaddr;\n        *stack_hi = (void*)&stacksize;\n        return;\n#  elif defined(_OS_DARWIN_)\n        extern void *pthread_get_stackaddr_np(pthread_t thread);\n        extern size_t pthread_get_stacksize_np(pthread_t thread);\n        pthread_t thread = pthread_self();\n        void *stackaddr = pthread_get_stackaddr_np(thread);\n        size_t stacksize = pthread_get_stacksize_np(thread);\n        *stack_lo = (void*)stackaddr;\n        *stack_hi = (void*)&stacksize;\n        return;\n#  elif defined(_OS_FREEBSD_)\n        pthread_attr_t attr;\n        pthread_attr_init(&attr);\n        pthread_attr_get_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        *stack_lo = (void*)stackaddr;\n        *stack_hi = (void*)&stacksize;\n        return;\n#  else\n#      warning \"Getting precise stack size for thread is not supported.\"\n#  endif\n    }\n    struct rlimit rl;\n    getrlimit(RLIMIT_STACK, &rl);\n    size_t stacksize = rl.rlim_cur;\n    *stack_hi = (void*)&stacksize;\n    *stack_lo = (void*)((char*)*stack_hi - stacksize);\n#endif\n}\n\nstatic void jl_prep_sanitizers(void)\n{\n#if !defined(_OS_WINDOWS_)\n#if defined(JL_ASAN_ENABLED) || defined(JL_MSAN_ENABLED)\n    struct rlimit rl;\n\n    // When using the sanitizers, increase stack size because they bloat\n    // stack usage\n    const rlim_t kStackSize = 64 * 1024 * 1024;   // 64MiB stack\n    int result;\n\n    result = getrlimit(RLIMIT_STACK, &rl);\n    if (result == 0) {\n        if (rl.rlim_cur < kStackSize) {\n            rl.rlim_cur = kStackSize;\n            result = setrlimit(RLIMIT_STACK, &rl);\n            if (result != 0) {\n                fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n            }\n        }\n    }\n#endif\n#endif\n}\n\nstruct uv_shutdown_queue_item { uv_handle_t *h; struct uv_shutdown_queue_item *next; };\nstruct uv_shutdown_queue { struct uv_shutdown_queue_item *first; struct uv_shutdown_queue_item *last; };\n\nstatic void jl_uv_exitcleanup_add(uv_handle_t *handle, struct uv_shutdown_queue *queue)\n{\n    struct uv_shutdown_queue_item *item = (struct uv_shutdown_queue_item*)malloc_s(sizeof(struct uv_shutdown_queue_item));\n    item->h = handle;\n    item->next = NULL;\n    if (queue->last)\n        queue->last->next = item;\n    if (!queue->first)\n        queue->first = item;\n    queue->last = item;\n}\n\nstatic void jl_uv_exitcleanup_walk(uv_handle_t *handle, void *arg)\n{\n    jl_uv_exitcleanup_add(handle, (struct uv_shutdown_queue*)arg);\n}\n\nstatic struct uv_shutdown_queue_item *next_shutdown_queue_item(struct uv_shutdown_queue_item *item)\n{\n    struct uv_shutdown_queue_item *rv = item->next;\n    free(item);\n    return rv;\n}\n\nstatic void jl_close_item_atexit(uv_handle_t *handle)\n{\n    if (handle->type != UV_FILE && uv_is_closing(handle))\n        return;\n    switch(handle->type) {\n    case UV_PROCESS:\n        // cause Julia to forget about the Process object\n        if (handle->data)\n            jl_uv_call_close_callback((jl_value_t*)handle->data);\n        // and make libuv think it is already dead\n        ((uv_process_t*)handle)->pid = 0;\n        // fall-through\n    case UV_TTY:\n    case UV_UDP:\n    case UV_TCP:\n    case UV_NAMED_PIPE:\n    case UV_POLL:\n    case UV_TIMER:\n    case UV_ASYNC:\n    case UV_FS_EVENT:\n    case UV_FS_POLL:\n    case UV_IDLE:\n    case UV_PREPARE:\n    case UV_CHECK:\n    case UV_SIGNAL:\n    case UV_FILE:\n        // These will be shutdown as appropriate by jl_close_uv\n        jl_close_uv(handle);\n        break;\n    case UV_HANDLE:\n    case UV_STREAM:\n    default:\n        assert(0 && \"not a valid libuv handle\");\n    }\n}\n\nJL_DLLEXPORT void jl_atexit_hook(int exitcode)\n{\n    if (jl_all_tls_states == NULL)\n        return;\n\n    jl_ptls_t ptls = jl_get_ptls_states();\n\n    if (exitcode == 0)\n        jl_write_compiler_output();\n    jl_print_gc_stats(JL_STDERR);\n    if (jl_options.code_coverage)\n        jl_write_coverage_data(jl_options.output_code_coverage);\n    if (jl_options.malloc_log)\n        jl_write_malloc_log();\n    if (jl_base_module) {\n        jl_value_t *f = jl_get_global(jl_base_module, jl_symbol(\"_atexit\"));\n        if (f != NULL) {\n            JL_TRY {\n                size_t last_age = ptls->world_age;\n                ptls->world_age = jl_get_world_counter();\n                jl_apply(&f, 1);\n                ptls->world_age = last_age;\n            }\n            JL_CATCH {\n                jl_printf((JL_STREAM*)STDERR_FILENO, \"\\natexit hook threw an error: \");\n                jl_static_show((JL_STREAM*)STDERR_FILENO, jl_current_exception());\n                jl_printf((JL_STREAM*)STDERR_FILENO, \"\\n\");\n                jlbacktrace(); // written to STDERR_FILENO\n            }\n        }\n    }\n\n    // replace standard output streams with something that we can still print to\n    // after the finalizers from base/stream.jl close the TTY\n    JL_STDOUT = (uv_stream_t*) STDOUT_FILENO;\n    JL_STDERR = (uv_stream_t*) STDERR_FILENO;\n\n    jl_gc_run_all_finalizers(ptls);\n\n    uv_loop_t *loop = jl_global_event_loop();\n\n    if (loop == NULL) {\n        return;\n    }\n\n    struct uv_shutdown_queue queue = {NULL, NULL};\n    JL_UV_LOCK();\n    uv_walk(loop, jl_uv_exitcleanup_walk, &queue);\n    struct uv_shutdown_queue_item *item = queue.first;\n    if (ptls->current_task != NULL) {\n        while (item) {\n            JL_TRY {\n                while (item) {\n                    jl_close_item_atexit(item->h);\n                    item = next_shutdown_queue_item(item);\n                }\n            }\n            JL_CATCH {\n                //error handling -- continue cleanup, as much as possible\n                assert(item);\n                uv_unref(item->h);\n                jl_printf((JL_STREAM*)STDERR_FILENO, \"error during exit cleanup: close: \");\n                jl_static_show((JL_STREAM*)STDERR_FILENO, jl_current_exception());\n                jl_printf((JL_STREAM*)STDERR_FILENO, \"\\n\");\n                jlbacktrace(); // written to STDERR_FILENO\n                item = next_shutdown_queue_item(item);\n            }\n        }\n    }\n    else {\n        while (item) {\n            jl_close_item_atexit(item->h);\n            item = next_shutdown_queue_item(item);\n        }\n    }\n\n    // force libuv to spin until everything has finished closing\n    loop->stop_flag = 0;\n    while (uv_run(loop, UV_RUN_DEFAULT)) { }\n    JL_UV_UNLOCK();\n\n    // TODO: Destroy threads\n\n    jl_destroy_timing();\n#ifdef ENABLE_TIMINGS\n    jl_print_timings();\n#endif\n\n    jl_teardown_codegen();\n}\n\nstatic void post_boot_hooks(void);\n\nJL_DLLEXPORT void *jl_libjulia_internal_handle;\nJL_DLLEXPORT void *jl_libjulia_handle;\nvoid *jl_RTLD_DEFAULT_handle;\nJL_DLLEXPORT void *jl_exe_handle;\n#ifdef _OS_WINDOWS_\nvoid *jl_ntdll_handle;\nvoid *jl_kernel32_handle;\nvoid *jl_crtdll_handle;\nvoid *jl_winsock_handle;\n#endif\n\nuv_loop_t *jl_io_loop;\n\n#ifdef _OS_WINDOWS_\nstatic int uv_dup(uv_os_fd_t fd, uv_os_fd_t* dupfd) {\n    HANDLE current_process;\n\n    if (fd == UV_STDIN_FD || fd == UV_STDOUT_FD || fd == UV_STDERR_FD)\n        fd = GetStdHandle((DWORD)(uintptr_t) fd);\n\n    /* _get_osfhandle will sometimes return -2 in case of an error. This seems */\n    /* to happen when fd <= 2 and the process' corresponding stdio handle is */\n    /* set to NULL. Unfortunately DuplicateHandle will happily duplicate */\n    /* (HANDLE) -2, so this situation goes unnoticed until someone tries to */\n    /* use the duplicate. Therefore we filter out known-invalid handles here. */\n    if (fd == INVALID_HANDLE_VALUE ||\n        fd == NULL ||\n        fd == (HANDLE) -2) {\n        *dupfd = INVALID_HANDLE_VALUE;\n        return 0; // allow the execution to continue even if stdio is not available as in batchmode or without a console\n    }\n\n    current_process = GetCurrentProcess();\n\n    if (!DuplicateHandle(current_process,\n                         fd,\n                         current_process,\n                         dupfd,\n                         0,\n                         TRUE,\n                         DUPLICATE_SAME_ACCESS)) {\n        *dupfd = INVALID_HANDLE_VALUE;\n        return GetLastError();\n    }\n\n    return 0;\n}\n#else\nstatic int uv_dup(uv_os_fd_t fd, uv_os_fd_t* dupfd) {\n    if ((*dupfd = fcntl(fd, F_DUPFD_CLOEXEC, 3)) == -1)\n        return -errno;\n    return 0;\n}\n#endif\n\nstatic void *init_stdio_handle(const char *stdio, uv_os_fd_t fd, int readable)\n{\n    void *handle;\n    int err;\n    // Duplicate the file descriptor so we can later dup it over if we want to redirect\n    // STDIO without having to worry about closing the associated libuv object.\n    // This also helps limit the impact other libraries can cause on our file handle.\n    if ((err = uv_dup(fd, &fd)))\n        jl_errorf(\"error initializing %s in uv_dup: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n    switch(uv_guess_handle(fd)) {\n    case UV_TTY:\n        handle = malloc_s(sizeof(uv_tty_t));\n        if ((err = uv_tty_init(jl_io_loop, (uv_tty_t*)handle, fd, 0))) {\n            jl_errorf(\"error initializing %s in uv_tty_init: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        ((uv_tty_t*)handle)->data = NULL;\n        uv_tty_set_mode((uv_tty_t*)handle, UV_TTY_MODE_NORMAL); // initialized cooked stdio\n        break;\n    default:\n        assert(0 && \"missing case for uv_guess_handle return handling\");\n        JL_FALLTHROUGH;\n    case UV_UDP:\n        JL_FALLTHROUGH;\n    case UV_UNKNOWN_HANDLE:\n        // dup the descriptor with a new one pointing at the bit bucket ...\n#if defined(_OS_WINDOWS_)\n        CloseHandle(fd);\n        fd = CreateFile(\"NUL\", readable ? FILE_GENERIC_READ : FILE_GENERIC_WRITE | FILE_READ_ATTRIBUTES,\n                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n#else\n        {\n            int nullfd;\n            nullfd = open(\"/dev/null\", O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH /* 0666 */);\n            assert(nullfd != -1);\n            dup2(nullfd, fd);\n            close(nullfd);\n        }\n#endif\n        // ...and continue on as in the UV_FILE case\n        JL_FALLTHROUGH;\n    case UV_FILE:\n        handle = malloc_s(sizeof(jl_uv_file_t));\n        {\n            jl_uv_file_t *file = (jl_uv_file_t*)handle;\n            file->loop = jl_io_loop;\n            file->type = UV_FILE;\n            file->file = fd;\n            file->data = NULL;\n        }\n        break;\n    case UV_NAMED_PIPE:\n        handle = malloc_s(sizeof(uv_pipe_t));\n        if ((err = uv_pipe_init(jl_io_loop, (uv_pipe_t*)handle, 0))) {\n            jl_errorf(\"error initializing %s in uv_pipe_init: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        if ((err = uv_pipe_open((uv_pipe_t*)handle, fd))) {\n            jl_errorf(\"error initializing %s in uv_pipe_open: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        ((uv_pipe_t*)handle)->data = NULL;\n        break;\n    case UV_TCP:\n        handle = malloc_s(sizeof(uv_tcp_t));\n        if ((err = uv_tcp_init(jl_io_loop, (uv_tcp_t*)handle))) {\n            jl_errorf(\"error initializing %s in uv_tcp_init: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        if ((err = uv_tcp_open((uv_tcp_t*)handle, (uv_os_sock_t)fd))) {\n            jl_errorf(\"error initializing %s in uv_tcp_open: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        ((uv_tcp_t*)handle)->data = NULL;\n        break;\n    }\n    return handle;\n}\n\nstatic void init_stdio(void)\n{\n    JL_STDIN  = (uv_stream_t*)init_stdio_handle(\"stdin\", UV_STDIN_FD, 1);\n    JL_STDOUT = (uv_stream_t*)init_stdio_handle(\"stdout\", UV_STDOUT_FD, 0);\n    JL_STDERR = (uv_stream_t*)init_stdio_handle(\"stderr\", UV_STDERR_FD, 0);\n    jl_flush_cstdio();\n}\n\n#ifdef JL_USE_INTEL_JITEVENTS\nchar jl_using_intel_jitevents; // Non-zero if running under Intel VTune Amplifier\n#endif\n\n#ifdef JL_USE_OPROFILE_JITEVENTS\nchar jl_using_oprofile_jitevents = 0; // Non-zero if running under OProfile\n#endif\n\n#ifdef JL_USE_PERF_JITEVENTS\nchar jl_using_perf_jitevents = 0;\n#endif\n\nchar jl_using_gdb_jitevents = 0;\n\nint isabspath(const char *in) JL_NOTSAFEPOINT\n{\n#ifdef _OS_WINDOWS_\n    char c0 = in[0];\n    if (c0 == '/' || c0 == '\\\\') {\n        return 1; // absolute path relative to %CD% (current drive), or UNC\n    }\n    else if (c0 && in[1] == ':') {\n        char c2 = in[2];\n        return c2 == '/' || c2 == '\\\\'; // absolute path with drive name\n    }\n#else\n    if (in[0] == '/') return 1; // absolute path\n#endif\n    return 0; // relative path\n}\n\nstatic char *abspath(const char *in, int nprefix)\n{ // compute an absolute realpath location, so that chdir doesn't change the file reference\n  // ignores (copies directly over) nprefix characters at the start of abspath\n#ifndef _OS_WINDOWS_\n    char *out = realpath(in + nprefix, NULL);\n    if (out) {\n        if (nprefix > 0) {\n            size_t sz = strlen(out) + 1;\n            char *cpy = (char*)malloc_s(sz + nprefix);\n            memcpy(cpy, in, nprefix);\n            memcpy(cpy + nprefix, out, sz);\n            free(out);\n            out = cpy;\n        }\n    }\n    else {\n        size_t sz = strlen(in + nprefix) + 1;\n        if (in[nprefix] == PATHSEPSTRING[0]) {\n            out = (char*)malloc_s(sz + nprefix);\n            memcpy(out, in, sz + nprefix);\n        }\n        else {\n            size_t path_size = PATH_MAX;\n            char *path = (char*)malloc_s(PATH_MAX);\n            if (uv_cwd(path, &path_size)) {\n                jl_error(\"fatal error: unexpected error while retrieving current working directory\");\n            }\n            out = (char*)malloc_s(path_size + 1 + sz + nprefix);\n            memcpy(out, in, nprefix);\n            memcpy(out + nprefix, path, path_size);\n            out[nprefix + path_size] = PATHSEPSTRING[0];\n            memcpy(out + nprefix + path_size + 1, in + nprefix, sz);\n            free(path);\n        }\n    }\n#else\n    DWORD n = GetFullPathName(in + nprefix, 0, NULL, NULL);\n    if (n <= 0) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n    char *out = (char*)malloc_s(n + nprefix);\n    DWORD m = GetFullPathName(in + nprefix, n, out + nprefix, NULL);\n    if (n != m + 1) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n    memcpy(out, in, nprefix);\n#endif\n    return out;\n}\n\n// create an absolute-path copy of the input path format string\n// formed as `joinpath(replace(pwd(), \"%\" => \"%%\"), in)`\n// unless `in` starts with `%`\nstatic const char *absformat(const char *in)\n{\n    if (in[0] == '%' || isabspath(in))\n        return in;\n    // get an escaped copy of cwd\n    size_t path_size = PATH_MAX;\n    char path[PATH_MAX];\n    if (uv_cwd(path, &path_size)) {\n        jl_error(\"fatal error: unexpected error while retrieving current working directory\");\n    }\n    size_t sz = strlen(in) + 1;\n    size_t i, fmt_size = 0;\n    for (i = 0; i < path_size; i++)\n        fmt_size += (path[i] == '%' ? 2 : 1);\n    char *out = (char*)malloc_s(fmt_size + 1 + sz);\n    fmt_size = 0;\n    for (i = 0; i < path_size; i++) { // copy-replace pwd portion\n        char c = path[i];\n        out[fmt_size++] = c;\n        if (c == '%')\n            out[fmt_size++] = '%';\n    }\n    out[fmt_size++] = PATHSEPSTRING[0]; // path sep\n    memcpy(out + fmt_size, in, sz); // copy over format, including nul\n    return out;\n}\n\nstatic void jl_resolve_sysimg_location(JL_IMAGE_SEARCH rel)\n{   // this function resolves the paths in jl_options to absolute file locations as needed\n    // and it replaces the pointers to `julia_bindir`, `julia_bin`, `image_file`, and output file paths\n    // it may fail, print an error, and exit(1) if any of these paths are longer than PATH_MAX\n    //\n    // note: if you care about lost memory, you should call the appropriate `free()` function\n    // on the original pointer for each `char*` you've inserted into `jl_options`, after\n    // calling `julia_init()`\n    char *free_path = (char*)malloc_s(PATH_MAX);\n    size_t path_size = PATH_MAX;\n    if (uv_exepath(free_path, &path_size)) {\n        jl_error(\"fatal error: unexpected error while retrieving exepath\");\n    }\n    if (path_size >= PATH_MAX) {\n        jl_error(\"fatal error: jl_options.julia_bin path too long\");\n    }\n    jl_options.julia_bin = (char*)malloc_s(path_size + 1);\n    memcpy((char*)jl_options.julia_bin, free_path, path_size);\n    ((char*)jl_options.julia_bin)[path_size] = '\\0';\n    if (!jl_options.julia_bindir) {\n        jl_options.julia_bindir = getenv(\"JULIA_BINDIR\");\n        if (!jl_options.julia_bindir) {\n            jl_options.julia_bindir = dirname(free_path);\n        }\n    }\n    if (jl_options.julia_bindir)\n        jl_options.julia_bindir = abspath(jl_options.julia_bindir, 0);\n    free(free_path);\n    free_path = NULL;\n    if (jl_options.image_file) {\n        if (rel == JL_IMAGE_JULIA_HOME && !isabspath(jl_options.image_file)) {\n            // build time path, relative to JULIA_BINDIR\n            free_path = (char*)malloc_s(PATH_MAX);\n            int n = snprintf(free_path, PATH_MAX, \"%s\" PATHSEPSTRING \"%s\",\n                             jl_options.julia_bindir, jl_options.image_file);\n            if (n >= PATH_MAX || n < 0) {\n                jl_error(\"fatal error: jl_options.image_file path too long\");\n            }\n            jl_options.image_file = free_path;\n        }\n        if (jl_options.image_file)\n            jl_options.image_file = abspath(jl_options.image_file, 0);\n        if (free_path) {\n            free(free_path);\n            free_path = NULL;\n        }\n    }\n    if (jl_options.outputo)\n        jl_options.outputo = abspath(jl_options.outputo, 0);\n    if (jl_options.outputji)\n        jl_options.outputji = abspath(jl_options.outputji, 0);\n    if (jl_options.outputbc)\n        jl_options.outputbc = abspath(jl_options.outputbc, 0);\n    if (jl_options.outputasm)\n        jl_options.outputasm = abspath(jl_options.outputasm, 0);\n    if (jl_options.machine_file)\n        jl_options.machine_file = abspath(jl_options.machine_file, 0);\n    if (jl_options.output_code_coverage)\n        jl_options.output_code_coverage = absformat(jl_options.output_code_coverage);\n\n    const char **cmdp = jl_options.cmds;\n    if (cmdp) {\n        for (; *cmdp; cmdp++) {\n            const char *cmd = *cmdp;\n            if (cmd[0] == 'L') {\n                *cmdp = abspath(cmd, 1);\n            }\n        }\n    }\n}\n\nstatic void jl_set_io_wait(int v)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    ptls->io_wait = v;\n}\n\nextern jl_mutex_t jl_modules_mutex;\n\nstatic void restore_fp_env(void)\n{\n    if (jl_set_zero_subnormals(0) || jl_set_default_nans(0)) {\n        jl_error(\"Failed to configure floating point environment\");\n    }\n}\n\nvoid _julia_init(JL_IMAGE_SEARCH rel)\n{\n    jl_init_timing();\n    // Make sure we finalize the tls callback before starting any threads.\n    jl_get_ptls_states_getter();\n    jl_ptls_t ptls = jl_get_ptls_states();\n    (void)ptls; assert(ptls); // make sure early that we have initialized ptls\n    jl_safepoint_init();\n    libsupport_init();\n    htable_new(&jl_current_modules, 0);\n    JL_MUTEX_INIT(&jl_modules_mutex);\n    ios_set_io_wait_func = jl_set_io_wait;\n    jl_io_loop = uv_default_loop(); // this loop will internal events (spawning process etc.),\n                                    // best to call this first, since it also initializes libuv\n    jl_init_uv();\n    init_stdio();\n    restore_fp_env();\n    restore_signals();\n\n    jl_page_size = jl_getpagesize();\n    uint64_t total_mem = uv_get_total_memory();\n    uint64_t constrained_mem = uv_get_constrained_memory();\n    if (constrained_mem > 0 && constrained_mem < total_mem)\n        total_mem = constrained_mem;\n    if (total_mem >= (size_t)-1) {\n        total_mem = (size_t)-1;\n    }\n    jl_arr_xtralloc_limit = total_mem / 100;  // Extra allocation limited to 1% of total RAM\n    jl_prep_sanitizers();\n    void *stack_lo, *stack_hi;\n    jl_init_stack_limits(1, &stack_lo, &stack_hi);\n\n    // Load libjulia-internal (which contains this function), and libjulia, explicitly.\n    jl_libjulia_internal_handle = jl_load_dynamic_library(NULL, JL_RTLD_DEFAULT, 1);\n    jl_libjulia_handle = jl_load_dynamic_library(JL_LIBJULIA_SONAME, JL_RTLD_DEFAULT, 1);\n#ifdef _OS_WINDOWS_\n    jl_ntdll_handle = jl_dlopen(\"ntdll.dll\", 0); // bypass julia's pathchecking for system dlls\n    jl_kernel32_handle = jl_dlopen(\"kernel32.dll\", 0);\n#if defined(_MSC_VER) && _MSC_VER == 1800\n    jl_crtdll_handle = jl_dlopen(\"msvcr120.dll\", 0);\n#else\n    jl_crtdll_handle = jl_dlopen(\"msvcrt.dll\", 0);\n#endif\n    jl_winsock_handle = jl_dlopen(\"ws2_32.dll\", 0);\n    jl_exe_handle = GetModuleHandleA(NULL);\n    JL_MUTEX_INIT(&jl_in_stackwalk);\n    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES | SYMOPT_IGNORE_CVREC);\n    if (!SymInitialize(GetCurrentProcess(), \"\", 1)) {\n        jl_printf(JL_STDERR, \"WARNING: failed to initialize stack walk info\\n\");\n    }\n    needsSymRefreshModuleList = 0;\n    HMODULE jl_dbghelp = (HMODULE) jl_dlopen(\"dbghelp.dll\", 0);\n    if (jl_dbghelp)\n        jl_dlsym(jl_dbghelp, \"SymRefreshModuleList\", (void **)&hSymRefreshModuleList, 1);\n#else\n    jl_exe_handle = jl_dlopen(NULL, JL_RTLD_NOW);\n#ifdef RTLD_DEFAULT\n    jl_RTLD_DEFAULT_handle = RTLD_DEFAULT;\n#else\n    jl_RTLD_DEFAULT_handle = jl_exe_handle;\n#endif\n#endif\n\n#if defined(JL_USE_INTEL_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_intel_jitevents = 1;\n    }\n#endif\n\n#if defined(JL_USE_OPROFILE_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_oprofile_jitevents = 1;\n    }\n#endif\n\n#if defined(JL_USE_PERF_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_perf_jitevents= 1;\n    }\n#endif\n\n#if defined(JL_DEBUG_BUILD)\n    jl_using_gdb_jitevents = 1;\n# else\n    const char *jit_gdb = getenv(\"ENABLE_GDBLISTENER\");\n    if (jit_gdb && atoi(jit_gdb)) {\n        jl_using_gdb_jitevents = 1;\n    }\n#endif\n\n    if ((jl_options.outputo || jl_options.outputbc || jl_options.outputasm) &&\n        (jl_options.code_coverage || jl_options.malloc_log)) {\n        jl_error(\"cannot generate code-coverage or track allocation information while generating a .o, .bc, or .s output file\");\n    }\n\n    jl_gc_init();\n\n    jl_init_threading();\n    jl_init_intrinsic_properties();\n\n    jl_gc_enable(0);\n\n    jl_resolve_sysimg_location(rel);\n    // loads sysimg if available, and conditionally sets jl_options.cpu_target\n    if (jl_options.image_file)\n        jl_preload_sysimg_so(jl_options.image_file);\n    if (jl_options.cpu_target == NULL)\n        jl_options.cpu_target = \"native\";\n\n    if (jl_options.image_file) {\n        jl_restore_system_image(jl_options.image_file);\n    }\n    else {\n        jl_init_types();\n        jl_init_codegen();\n    }\n\n    jl_init_tasks();\n    jl_init_root_task(stack_lo, stack_hi);\n    jl_init_common_symbols();\n    jl_init_flisp();\n    jl_init_serializer();\n\n    if (!jl_options.image_file) {\n        jl_core_module = jl_new_module(jl_symbol(\"Core\"));\n        jl_core_module->parent = jl_core_module;\n        jl_type_typename->mt->module = jl_core_module;\n        jl_top_module = jl_core_module;\n        jl_init_intrinsic_functions();\n        jl_init_primitives();\n        jl_init_main_module();\n        jl_load(jl_core_module, \"boot.jl\");\n        post_boot_hooks();\n    }\n\n    if (jl_base_module != NULL) {\n        // Do initialization needed before starting child threads\n        jl_value_t *f = jl_get_global(jl_base_module, jl_symbol(\"__preinit_threads__\"));\n        if (f) {\n            size_t last_age = ptls->world_age;\n            ptls->world_age = jl_get_world_counter();\n            jl_apply(&f, 1);\n            ptls->world_age = last_age;\n        }\n    }\n    else {\n        // nthreads > 1 requires code in Base\n        jl_n_threads = 1;\n    }\n    jl_start_threads();\n\n    // This needs to be after jl_start_threads\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_default_signal_handlers();\n\n    jl_gc_enable(1);\n\n    if (jl_options.image_file && (!jl_generating_output() || jl_options.incremental) && jl_module_init_order) {\n        jl_array_t *init_order = jl_module_init_order;\n        JL_GC_PUSH1(&init_order);\n        jl_module_init_order = NULL;\n        int i, l = jl_array_len(init_order);\n        for (i = 0; i < l; i++) {\n            jl_value_t *mod = jl_array_ptr_ref(init_order, i);\n            jl_module_run_initializer((jl_module_t*)mod);\n        }\n        JL_GC_POP();\n    }\n\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_sigint_handler();\n}\n\nstatic jl_value_t *core(const char *name)\n{\n    return jl_get_global(jl_core_module, jl_symbol(name));\n}\n\n// fetch references to things defined in boot.jl\nstatic void post_boot_hooks(void)\n{\n    jl_char_type    = (jl_datatype_t*)core(\"Char\");\n    jl_int8_type    = (jl_datatype_t*)core(\"Int8\");\n    jl_int16_type   = (jl_datatype_t*)core(\"Int16\");\n    jl_uint16_type  = (jl_datatype_t*)core(\"UInt16\");\n    jl_float16_type = (jl_datatype_t*)core(\"Float16\");\n    jl_float32_type = (jl_datatype_t*)core(\"Float32\");\n    jl_float64_type = (jl_datatype_t*)core(\"Float64\");\n    jl_floatingpoint_type = (jl_datatype_t*)core(\"AbstractFloat\");\n    jl_number_type  = (jl_datatype_t*)core(\"Number\");\n    jl_signed_type  = (jl_datatype_t*)core(\"Signed\");\n    jl_datatype_t *jl_unsigned_type = (jl_datatype_t*)core(\"Unsigned\");\n    jl_datatype_t *jl_integer_type = (jl_datatype_t*)core(\"Integer\");\n\n    jl_bool_type->super = jl_integer_type;\n    jl_uint8_type->super = jl_unsigned_type;\n    jl_int32_type->super = jl_signed_type;\n    jl_int64_type->super = jl_signed_type;\n    jl_uint32_type->super = jl_unsigned_type;\n    jl_uint64_type->super = jl_unsigned_type;\n\n    jl_errorexception_type = (jl_datatype_t*)core(\"ErrorException\");\n    jl_stackovf_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"StackOverflowError\"));\n    jl_diverror_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"DivideError\"));\n    jl_undefref_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"UndefRefError\"));\n    jl_undefvarerror_type  = (jl_datatype_t*)core(\"UndefVarError\");\n    jl_interrupt_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"InterruptException\"));\n    jl_boundserror_type    = (jl_datatype_t*)core(\"BoundsError\");\n    jl_memory_exception    = jl_new_struct_uninit((jl_datatype_t*)core(\"OutOfMemoryError\"));\n    jl_readonlymemory_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"ReadOnlyMemoryError\"));\n    jl_typeerror_type      = (jl_datatype_t*)core(\"TypeError\");\n#ifdef SEGV_EXCEPTION\n    jl_segv_exception      = jl_new_struct_uninit((jl_datatype_t*)core(\"SegmentationFault\"));\n#endif\n    jl_argumenterror_type  = (jl_datatype_t*)core(\"ArgumentError\");\n    jl_methoderror_type    = (jl_datatype_t*)core(\"MethodError\");\n    jl_loaderror_type      = (jl_datatype_t*)core(\"LoadError\");\n    jl_initerror_type      = (jl_datatype_t*)core(\"InitError\");\n\n    jl_weakref_type = (jl_datatype_t*)core(\"WeakRef\");\n    jl_vecelement_typename = ((jl_datatype_t*)jl_unwrap_unionall(core(\"VecElement\")))->name;\n\n    jl_init_box_caches();\n\n    // set module field of primitive types\n    int i;\n    void **table = jl_core_module->bindings.table;\n    for (i = 1; i < jl_core_module->bindings.size; i += 2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            jl_value_t *v = b->value;\n            if (v) {\n                if (jl_is_unionall(v))\n                    v = jl_unwrap_unionall(v);\n                if (jl_is_datatype(v)) {\n                    jl_datatype_t *tt = (jl_datatype_t*)v;\n                    tt->name->module = jl_core_module;\n                    if (tt->name->mt)\n                        tt->name->mt->module = jl_core_module;\n                }\n            }\n        }\n    }\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/julia.h": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#ifndef JULIA_H\n#define JULIA_H\n\n//** Configuration options that affect the Julia ABI **//\n// if this is not defined, only individual dimension sizes are\n// stored and not total length, to save space.\n#define STORE_ARRAY_LEN\n//** End Configuration options **//\n\n#include \"libsupport.h\"\n#include <stdint.h>\n#include <string.h>\n\n#include \"htable.h\"\n#include \"arraylist.h\"\n#include \"analyzer_annotations.h\"\n\n#include <setjmp.h>\n#ifndef _OS_WINDOWS_\n#  define jl_jmp_buf sigjmp_buf\n#  if defined(_CPU_ARM_) || defined(_CPU_PPC_) || defined(_CPU_WASM_)\n#    define MAX_ALIGN 8\n#  elif defined(_CPU_AARCH64_)\n// int128 is 16 bytes aligned on aarch64\n#    define MAX_ALIGN 16\n#  elif defined(_P64)\n// Generically we assume MAX_ALIGN is sizeof(void*)\n#    define MAX_ALIGN 8\n#  else\n#    define MAX_ALIGN 4\n#  endif\n#else\n#  include \"win32_ucontext.h\"\n#  define jl_jmp_buf jmp_buf\n#  define MAX_ALIGN 8\n#endif\n\n#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\n#if defined(__GNUC__)\n#  define JL_NORETURN __attribute__ ((noreturn))\n#  define JL_CONST_FUNC __attribute__((const))\n#  define JL_USED_FUNC __attribute__((used))\n#  define JL_SECTION(name) __attribute__((section(name)))\n#  define JL_THREAD_LOCAL __thread\n#elif defined(_COMPILER_MICROSOFT_)\n#  define JL_NORETURN __declspec(noreturn)\n// This is the closest I can find for __attribute__((const))\n#  define JL_CONST_FUNC __declspec(noalias)\n// Does MSVC have this?\n#  define JL_USED_FUNC\n// TODO: Figure out what to do on MSVC\n#  define JL_SECTION(x)\n#  define JL_THREAD_LOCAL __declspec(threaD)\n#else\n#  define JL_NORETURN\n#  define JL_CONST_FUNC\n#  define JL_USED_FUNC\n#  define JL_THREAD_LOCAL\n#endif\n\n#if defined(__has_feature) // Clang flavor\n#if __has_feature(address_sanitizer)\n#define JL_ASAN_ENABLED\n#endif\n#if __has_feature(memory_sanitizer)\n#define JL_MSAN_ENABLED\n#endif\n#if __has_feature(thread_sanitizer)\n#if __clang_major__ < 11\n#error Thread sanitizer runtime libraries in clang < 11 leak memory and cannot be used\n#endif\n#define JL_TSAN_ENABLED\n#endif\n#else // GCC flavor\n#if defined(__SANITIZE_ADDRESS__)\n#define JL_ASAN_ENABLED\n#endif\n#endif // __has_feature\n\n#define container_of(ptr, type, member) \\\n    ((type *) ((char *)(ptr) - offsetof(type, member)))\n\ntypedef struct _jl_taggedvalue_t jl_taggedvalue_t;\n\n#include \"atomics.h\"\n#include \"tls.h\"\n#include \"julia_threads.h\"\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// core data types ------------------------------------------------------------\n\n// the common fields are hidden before the pointer, but the following macro is\n// used to indicate which types below are subtypes of jl_value_t\n#define JL_DATA_TYPE\n\ntypedef struct _jl_value_t jl_value_t;\n\nstruct _jl_taggedvalue_bits {\n    uintptr_t gc:2;\n};\n\nJL_EXTENSION struct _jl_taggedvalue_t {\n    union {\n        uintptr_t header;\n        jl_taggedvalue_t *next;\n        jl_value_t *type; // 16-byte aligned\n        struct _jl_taggedvalue_bits bits;\n    };\n    // jl_value_t value;\n};\n\n#ifdef __clang_analyzer__\nJL_DLLEXPORT jl_taggedvalue_t *_jl_astaggedvalue(jl_value_t *v JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\n#define jl_astaggedvalue(v) _jl_astaggedvalue((jl_value_t*)(v))\njl_value_t *_jl_valueof(jl_taggedvalue_t *tv JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\n#define jl_valueof(v) _jl_valueof((jl_taggedvalue_t*)(v))\nJL_DLLEXPORT jl_value_t *_jl_typeof(jl_value_t *v JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\n#define jl_typeof(v) _jl_typeof((jl_value_t*)(v))\n#else\n#define jl_astaggedvalue(v)                                             \\\n    ((jl_taggedvalue_t*)((char*)(v) - sizeof(jl_taggedvalue_t)))\n#define jl_valueof(v)                                           \\\n    ((jl_value_t*)((char*)(v) + sizeof(jl_taggedvalue_t)))\n#define jl_typeof(v)                                                    \\\n    ((jl_value_t*)(jl_astaggedvalue(v)->header & ~(uintptr_t)15))\n#endif\nstatic inline void jl_set_typeof(void *v, void *t) JL_NOTSAFEPOINT\n{\n    // Do not call this on a value that is already initialized.\n    jl_taggedvalue_t *tag = jl_astaggedvalue(v);\n    jl_atomic_store_relaxed(&tag->type, (jl_value_t*)t);\n}\n#define jl_typeis(v,t) (jl_typeof(v)==(jl_value_t*)(t))\n\n// Symbols are interned strings (hash-consed) stored as an invasive binary tree.\n// The string data is nul-terminated and hangs off the end of the struct.\ntypedef struct _jl_sym_t {\n    JL_DATA_TYPE\n    struct _jl_sym_t *left;\n    struct _jl_sym_t *right;\n    uintptr_t hash;    // precomputed hash value\n    // JL_ATTRIBUTE_ALIGN_PTRSIZE(char name[]);\n} jl_sym_t;\n\n// A numbered SSA value, for optimized code analysis and generation\n// the `id` is a unique, small number\ntypedef struct _jl_ssavalue_t {\n    JL_DATA_TYPE\n    ssize_t id;\n} jl_ssavalue_t;\n\n// A SimpleVector is an immutable pointer array\n// Data is stored at the end of this variable-length struct.\ntypedef struct {\n    JL_DATA_TYPE\n    size_t length;\n    // pointer size aligned\n    // jl_value_t *data[];\n} jl_svec_t;\n\ntypedef struct {\n    /*\n      how - allocation style\n      0 = data is inlined, or a foreign pointer we don't manage\n      1 = julia-allocated buffer that needs to be marked\n      2 = malloc-allocated pointer this array object manages\n      3 = has a pointer to the object that owns the data\n    */\n    uint16_t how:2;\n    uint16_t ndims:9;\n    uint16_t pooled:1;\n    uint16_t ptrarray:1; // representation is pointer array\n    uint16_t hasptr:1; // representation has embedded pointers\n    uint16_t isshared:1; // data is shared by multiple Arrays\n    uint16_t isaligned:1; // data allocated with memalign\n} jl_array_flags_t;\n\nJL_EXTENSION typedef struct {\n    JL_DATA_TYPE\n    void *data;\n#ifdef STORE_ARRAY_LEN\n    size_t length;\n#endif\n    jl_array_flags_t flags;\n    uint16_t elsize;  // element size including alignment (dim 1 memory stride)\n    uint32_t offset;  // for 1-d only. does not need to get big.\n    size_t nrows;\n    union {\n        // 1d\n        size_t maxsize;\n        // Nd\n        size_t ncols;\n    };\n    // other dim sizes go here for ndims > 2\n\n    // followed by alignment padding and inline data, or owner pointer\n} jl_array_t;\n\n// compute # of extra words needed to store dimensions\nSTATIC_INLINE int jl_array_ndimwords(uint32_t ndims) JL_NOTSAFEPOINT\n{\n    return (ndims < 3 ? 0 : ndims-2);\n}\n\ntypedef struct _jl_datatype_t jl_tupletype_t;\nstruct _jl_code_instance_t;\n\n// TypeMap is an implicitly defined type\n// that can consist of any of the following nodes:\n//   typedef TypeMap Union{TypeMapLevel, TypeMapEntry, Nothing}\n// it forms a roughly tree-shaped structure, consisting of nodes of TypeMapLevels\n// which split the tree when possible, for example based on the key into the tuple type at `offs`\n// when key is a leaftype, (but only when the tree has enough entries for this to be\n// more efficient than storing them sorted linearly)\n// otherwise the leaf entries are stored sorted, linearly\ntypedef jl_value_t jl_typemap_t;\n\ntypedef jl_value_t *(jl_call_t)(jl_value_t*, jl_value_t**, uint32_t, struct _jl_code_instance_t*);\ntypedef jl_call_t *jl_callptr_t;\n\n// \"speccall\" calling convention signatures.\n// This describes some of the special ABI used by compiled julia functions.\nJL_DLLEXPORT extern jl_call_t jl_fptr_args;\ntypedef jl_value_t *(*jl_fptr_args_t)(jl_value_t*, jl_value_t**, uint32_t);\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_const_return;\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_sparam;\ntypedef jl_value_t *(*jl_fptr_sparam_t)(jl_value_t*, jl_value_t**, uint32_t, jl_svec_t*);\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_interpret_call;\n\nJL_EXTENSION typedef union {\n    void* fptr;\n    jl_fptr_args_t fptr1;\n    // 2 constant\n    jl_fptr_sparam_t fptr3;\n    // 4 interpreter\n} jl_generic_specptr_t;\n\ntypedef struct _jl_method_instance_t jl_method_instance_t;\n\ntypedef struct _jl_line_info_node_t {\n    struct _jl_module_t *module;\n    jl_value_t *method;\n    jl_sym_t *file;\n    intptr_t line;\n    intptr_t inlined_at;\n} jl_line_info_node_t;\n\n// This type describes a single function body\ntypedef struct _jl_code_info_t {\n    // ssavalue-indexed arrays of properties:\n    jl_array_t *code;  // Any array of statements\n    jl_value_t *codelocs; // Int32 array of indicies into the line table\n    jl_value_t *ssavaluetypes; // types of ssa values (or count of them)\n    jl_array_t *ssaflags; // flags associated with each statement:\n        // 0 = inbounds\n        // 1,2 = <reserved> inlinehint,always-inline,noinline\n        // 3 = <reserved> strict-ieee (strictfp)\n        // 4-6 = <unused>\n        // 7 = has out-of-band info\n    // miscellaneous data:\n    jl_value_t *method_for_inference_limit_heuristics; // optional method used during inference\n    jl_value_t *linetable; // Table of locations [TODO: make this volatile like slotnames]\n    jl_array_t *slotnames; // names of local variables\n    jl_array_t *slotflags;  // local var bit flags\n    // the following are optional transient properties (not preserved by compression--as they typically get stored elsewhere):\n    jl_value_t *slottypes; // inferred types of slots\n    jl_value_t *rettype;\n    jl_method_instance_t *parent; // context (optionally, if available, otherwise nothing)\n    jl_value_t *edges; // forward edges to method instances that must be invalidated\n    size_t min_world;\n    size_t max_world;\n    // various boolean properties:\n    uint8_t inferred;\n    uint8_t inlineable;\n    uint8_t propagate_inbounds;\n    uint8_t pure;\n    uint8_t aggressive_constprop;\n} jl_code_info_t;\n\n// This type describes a single method definition, and stores data\n// shared by the specializations of a function.\ntypedef struct _jl_method_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;  // for error reporting\n    struct _jl_module_t *module;\n    jl_sym_t *file;\n    int32_t line;\n    size_t primary_world;\n    size_t deleted_world;\n\n    // method's type signature. redundant with TypeMapEntry->specTypes\n    jl_value_t *sig;\n\n    // table of all jl_method_instance_t specializations we have\n    jl_svec_t *specializations; // allocated as [hashable, ..., NULL, linear, ....]\n    jl_array_t *speckeyset; // index lookup by hash into specializations\n\n    jl_value_t *slot_syms; // compacted list of slot names (String)\n    jl_value_t *source;  // original code template (jl_code_info_t, but may be compressed), null for builtins\n    struct _jl_method_instance_t *unspecialized;  // unspecialized executable method instance, or null\n    jl_value_t *generator;  // executable code-generating function if available\n    jl_array_t *roots;  // pointers in generated code (shared to reduce memory), or null\n    jl_svec_t *ccallable; // svec(rettype, sig) if a ccallable entry point is requested for this\n\n    // cache of specializations of this method for invoke(), i.e.\n    // cases where this method was called even though it was not necessarily\n    // the most specific for the argument types.\n    jl_typemap_t *invokes;\n\n    int32_t nargs;\n    int32_t called;        // bit flags: whether each of the first 8 arguments is called\n    int32_t nospecialize;  // bit flags: which arguments should not be specialized\n    int32_t nkw;           // # of leading arguments that are actually keyword arguments\n                           // of another method.\n    uint8_t isva;\n    uint8_t pure;\n    uint8_t is_for_opaque_closure;\n    uint8_t aggressive_constprop;\n\n// hidden fields:\n    // lock for modifications to the method\n    jl_mutex_t writelock;\n} jl_method_t;\n\n// This type is a placeholder to cache data for a specType signature specialization of a Method\n// can can be used as a unique dictionary key representation of a call to a particular Method\n// with a particular set of argument types\nstruct _jl_method_instance_t {\n    JL_DATA_TYPE\n    union {\n        jl_value_t *value; // generic accessor\n        struct _jl_module_t *module; // this is a toplevel thunk\n        jl_method_t *method; // method this is specialized from\n    } def; // pointer back to the context for this code\n    jl_value_t *specTypes;  // argument types this was specialized for\n    jl_svec_t *sparam_vals; // static parameter values, indexed by def.method->sparam_syms\n    jl_value_t *uninferred; // cached uncompressed code, for generated functions, top-level thunks, or the interpreter\n    jl_array_t *backedges; // list of method-instances which contain a call into this method-instance\n    jl_array_t *callbacks; // list of callback functions to inform external caches about invalidations\n    struct _jl_code_instance_t *cache;\n    uint8_t inInference; // flags to tell if inference is running on this object\n};\n\n// OpaqueClosure\ntypedef struct jl_opaque_closure_t {\n    JL_DATA_TYPE\n    jl_value_t *captures;\n    uint8_t isva;\n    size_t world;\n    jl_method_t *source;\n    jl_fptr_args_t invoke;\n    void *specptr;\n} jl_opaque_closure_t;\n\n// This type represents an executable operation\ntypedef struct _jl_code_instance_t {\n    JL_DATA_TYPE\n    jl_method_instance_t *def; // method this is specialized from\n    struct _jl_code_instance_t *next; // pointer to the next cache entry\n\n    // world range for which this object is valid to use\n    size_t min_world;\n    size_t max_world;\n\n    // inference state cache\n    jl_value_t *rettype; // return type for fptr\n    jl_value_t *rettype_const; // inferred constant return value, or null\n    jl_value_t *inferred; // inferred jl_code_info_t, or jl_nothing, or null\n    //TODO: jl_array_t *edges; // stored information about edges from this object\n    //TODO: uint8_t absolute_max; // whether true max world is unknown\n\n    // compilation state cache\n    uint8_t isspecsig; // if specptr is a specialized function signature for specTypes->rettype\n    uint8_t precompile;  // if set, this will be added to the output system image\n    jl_callptr_t invoke; // jlcall entry point\n    jl_generic_specptr_t specptr; // private data for `jlcall entry point`\n} jl_code_instance_t;\n\n// all values are callable as Functions\ntypedef jl_value_t jl_function_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    jl_value_t *lb;   // lower bound\n    jl_value_t *ub;   // upper bound\n} jl_tvar_t;\n\n// UnionAll type (iterated union over all values of a variable in certain bounds)\n// written `body where lb<:var<:ub`\ntypedef struct {\n    JL_DATA_TYPE\n    jl_tvar_t *var;\n    jl_value_t *body;\n} jl_unionall_t;\n\n// represents the \"name\" part of a DataType, describing the syntactic structure\n// of a type and storing all data common to different instantiations of the type,\n// including a cache for hash-consed allocation of DataType objects.\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *module;\n    jl_svec_t *names;  // field names\n    // `wrapper` is either the only instantiation of the type (if no parameters)\n    // or a UnionAll accepting parameters to make an instantiation.\n    jl_value_t *wrapper;\n    jl_svec_t *cache;        // sorted array\n    jl_svec_t *linearcache;  // unsorted array\n    intptr_t hash;\n    struct _jl_methtable_t *mt;\n    jl_array_t *partial;     // incomplete instantiations of this type\n} jl_typename_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_value_t *a;\n    jl_value_t *b;\n} jl_uniontype_t;\n\n// in little-endian, isptr is always the first bit, avoiding the need for a branch in computing isptr\ntypedef struct {\n    uint8_t isptr:1;\n    uint8_t size:7;\n    uint8_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc8_t;\n\ntypedef struct {\n    uint16_t isptr:1;\n    uint16_t size:15;\n    uint16_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc16_t;\n\ntypedef struct {\n    uint32_t isptr:1;\n    uint32_t size:31;\n    uint32_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc32_t;\n\ntypedef struct {\n    uint32_t nfields;\n    uint32_t npointers; // number of pointers embedded inside\n    int32_t first_ptr; // index of the first pointer (or -1)\n    uint16_t alignment; // strictest alignment over all fields\n    uint16_t haspadding : 1; // has internal undefined bytes\n    uint16_t fielddesc_type : 2; // 0 -> 8, 1 -> 16, 2 -> 32, 3 -> foreign type\n    // union {\n    //     jl_fielddesc8_t field8[nfields];\n    //     jl_fielddesc16_t field16[nfields];\n    //     jl_fielddesc32_t field32[nfields];\n    // };\n    // union { // offsets relative to data start in words\n    //     uint8_t ptr8[npointers];\n    //     uint16_t ptr16[npointers];\n    //     uint32_t ptr32[npointers];\n    // };\n} jl_datatype_layout_t;\n\ntypedef struct _jl_datatype_t {\n    JL_DATA_TYPE\n    jl_typename_t *name;\n    struct _jl_datatype_t *super;\n    jl_svec_t *parameters;\n    jl_svec_t *types;\n    jl_svec_t *names;\n    jl_value_t *instance;  // for singletons\n    const jl_datatype_layout_t *layout;\n    int32_t size; // TODO: move to _jl_datatype_layout_t\n    int32_t ninitialized;\n    uint32_t hash;\n    uint8_t abstract;\n    uint8_t mutabl;\n    // memoized properties\n    uint8_t hasfreetypevars; // majority part of isconcrete computation\n    uint8_t isconcretetype; // whether this type can have instances\n    uint8_t isdispatchtuple; // aka isleaftupletype\n    uint8_t isbitstype; // relevant query for C-api and type-parameters\n    uint8_t zeroinit; // if one or more fields requires zero-initialization\n    uint8_t isinlinealloc; // if this is allocated inline\n    uint8_t has_concrete_subtype; // If clear, no value will have this datatype\n    uint8_t cached_by_hash; // stored in hash-based set cache (instead of linear cache)\n} jl_datatype_t;\n\ntypedef struct _jl_vararg_t {\n    JL_DATA_TYPE\n    jl_value_t *T;\n    jl_value_t *N;\n} jl_vararg_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_value_t *value;\n} jl_weakref_t;\n\ntypedef struct {\n    // not first-class\n    jl_sym_t *name;\n    jl_value_t *value;\n    jl_value_t *globalref;  // cached GlobalRef for this binding\n    struct _jl_module_t *owner;  // for individual imported bindings\n    uint8_t constp;\n    uint8_t exportp:1;\n    uint8_t imported:1;\n    uint8_t deprecated:2; // 0=not deprecated, 1=renamed, 2=moved to another package\n} jl_binding_t;\n\ntypedef struct {\n    uint64_t hi;\n    uint64_t lo;\n} jl_uuid_t;\n\ntypedef struct _jl_module_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *parent;\n    // hidden fields:\n    htable_t bindings;\n    arraylist_t usings;  // modules with all bindings potentially imported\n    uint64_t build_id;\n    jl_uuid_t uuid;\n    size_t primary_world;\n    uint32_t counter;\n    int32_t nospecialize;  // global bit flags: initialization for new methods\n    int8_t optlevel;\n    int8_t compile;\n    int8_t infer;\n    uint8_t istopmod;\n    jl_mutex_t lock;\n} jl_module_t;\n\n// one Type-to-Value entry\ntypedef struct _jl_typemap_entry_t {\n    JL_DATA_TYPE\n    struct _jl_typemap_entry_t *next; // invasive linked list\n    jl_tupletype_t *sig; // the type signature for this entry\n    jl_tupletype_t *simplesig; // a simple signature for fast rejection\n    jl_svec_t *guardsigs;\n    size_t min_world;\n    size_t max_world;\n    union {\n        jl_value_t *value; // generic accessor\n        jl_method_instance_t *linfo; // [nullable] for guard entries\n        jl_method_t *method;\n    } func;\n    // memoized properties of sig:\n    int8_t isleafsig; // isleaftype(sig) & !any(isType, sig) : unsorted and very fast\n    int8_t issimplesig; // all(isleaftype | isAny | isType | isVararg, sig) : sorted and fast\n    int8_t va; // isVararg(sig)\n} jl_typemap_entry_t;\n\n// one level in a TypeMap tree (each level splits on a type at a given offset)\ntypedef struct _jl_typemap_level_t {\n    JL_DATA_TYPE\n    // these vectors contains vectors of more levels in their intended visit order\n    // with an index that gives the functionality of a sorted dict.\n    // next split may be on Type{T} as LeafTypes then TypeName's parents up to Any\n    // next split may be on LeafType\n    // next split may be on TypeName\n    jl_array_t *arg1; // contains LeafType\n    jl_array_t *targ; // contains Type{LeafType}\n    jl_array_t *name1; // contains non-abstract TypeName, for parents up to (excluding) Any\n    jl_array_t *tname; // contains a dict of Type{TypeName}, for parents up to Any\n    // next a linear list of things too complicated at this level for analysis (no more levels)\n    jl_typemap_entry_t *linear;\n    // finally, start a new level if the type at offs is Any\n    jl_typemap_t *any;\n} jl_typemap_level_t;\n\n// contains the TypeMap for one Type\ntypedef struct _jl_methtable_t {\n    JL_DATA_TYPE\n    jl_sym_t *name; // sometimes a hack used by serialization to handle kwsorter\n    jl_typemap_t *defs;\n    jl_array_t *leafcache;\n    jl_typemap_t *cache;\n    intptr_t max_args;  // max # of non-vararg arguments in a signature\n    jl_value_t *kwsorter;  // keyword argument sorter function\n    jl_module_t *module; // used for incremental serialization to locate original binding\n    jl_array_t *backedges;\n    jl_mutex_t writelock;\n    uint8_t offs;  // 0, or 1 to skip splitting typemap on first (function) argument\n    uint8_t frozen; // whether this accepts adding new methods\n} jl_methtable_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *head;\n    jl_array_t *args;\n} jl_expr_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_tupletype_t *spec_types;\n    jl_svec_t *sparams;\n    jl_method_t *method;\n    // A bool on the julia side, but can be temporarily 0x2 as a sentinel\n    // during construction.\n    uint8_t fully_covers;\n} jl_method_match_t;\n\n// constants and type objects -------------------------------------------------\n\n// kinds\nextern JL_DLLIMPORT jl_datatype_t *jl_typeofbottom_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_datatype_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uniontype_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_unionall_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_tvar_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_type_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typename_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_type_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_symbol_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_ssavalue_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_abstractslot_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_slotnumber_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typedslot_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_argument_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_const_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_partial_struct_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_method_match_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_simplevector_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_tuple_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_vecelement_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_anytuple_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_emptytuple_type JL_GLOBALLY_ROOTED;\n#define jl_tuple_type jl_anytuple_type\nextern JL_DLLIMPORT jl_unionall_t *jl_anytuple_type_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_vararg_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_function_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_builtin_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_opaque_closure_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_opaque_closure_typename JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_value_t *jl_bottom_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_method_instance_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_code_instance_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_code_info_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_method_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_module_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_abstractarray_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_densearray_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_array_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_array_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_weakref_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_abstractstring_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_string_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_errorexception_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_argumenterror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_loaderror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_initerror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typeerror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_methoderror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_undefvarerror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_lineinfonode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_stackovf_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_memory_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_readonlymemory_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_diverror_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_undefref_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_interrupt_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_boundserror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_an_empty_vec_any JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_an_empty_string JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_datatype_t *jl_bool_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_char_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_int8_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint8_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_int16_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint16_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_int32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_int64_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint64_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_float16_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_float32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_float64_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_floatingpoint_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_number_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_void_type JL_GLOBALLY_ROOTED;  // deprecated\nextern JL_DLLIMPORT jl_datatype_t *jl_nothing_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_signed_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_voidpointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint8pointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_pointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_llvmpointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_ref_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_pointer_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_llvmpointer_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_namedtuple_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_namedtuple_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_task_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_value_t *jl_array_uint8_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_array_any_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_array_symbol_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_array_int32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_expr_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_globalref_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_linenumbernode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_gotonode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_gotoifnot_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_returnnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_phinode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_pinode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_phicnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_upsilonnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_quotenode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_newvarnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_intrinsic_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_methtable_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typemap_level_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typemap_entry_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_svec_t *jl_emptysvec JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_emptytuple JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_true JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_false JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_nothing JL_GLOBALLY_ROOTED;\n\n// gc -------------------------------------------------------------------------\n\ntypedef struct _jl_gcframe_t {\n    size_t nroots;\n    struct _jl_gcframe_t *prev;\n    // actual roots go here\n} jl_gcframe_t;\n\n// NOTE: it is the caller's responsibility to make sure arguments are\n// rooted such that the gc can see them on the stack.\n// `foo(f(), g())` is not safe,\n// since the result of `f()` is not rooted during the call to `g()`,\n// and the arguments to foo are not gc-protected during the call to foo.\n// foo can't do anything about it, so the caller must do:\n// jl_value_t *x=NULL, *y=NULL; JL_GC_PUSH2(&x, &y);\n// x = f(); y = g(); foo(x, y)\n\n#define jl_pgcstack (jl_get_ptls_states()->pgcstack)\n\n#define JL_GC_ENCODE_PUSHARGS(n)   (((size_t)(n))<<2)\n#define JL_GC_ENCODE_PUSH(n)       ((((size_t)(n))<<2)|1)\n\n#ifdef __clang_analyzer__\n\n// When running with the analyzer make these real function calls, that are\n// easier to detect in the analyzer\nextern void JL_GC_PUSH1(void *) JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH2(void *, void *) JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH3(void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH4(void *, void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH5(void *, void *, void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH7(void *, void *, void *, void *, void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void _JL_GC_PUSHARGS(jl_value_t **, size_t) JL_NOTSAFEPOINT;\n// This is necessary, because otherwise the analyzer considers this undefined\n// behavior and terminates the exploration\n#define JL_GC_PUSHARGS(rts_var, n)     \\\n  rts_var = (jl_value_t **)alloca(sizeof(void*) * (n)); \\\n  memset(rts_var, 0, sizeof(void*) * (n)); \\\n  _JL_GC_PUSHARGS(rts_var, (n));\n\nextern void JL_GC_POP() JL_NOTSAFEPOINT;\n\n#else\n\n#define JL_GC_PUSH1(arg1)                                                                               \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(1), jl_pgcstack, arg1};                                 \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH2(arg1, arg2)                                                                         \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(2), jl_pgcstack, arg1, arg2};                           \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH3(arg1, arg2, arg3)                                                                   \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(3), jl_pgcstack, arg1, arg2, arg3};                     \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH4(arg1, arg2, arg3, arg4)                                                             \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(4), jl_pgcstack, arg1, arg2, arg3, arg4};               \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH5(arg1, arg2, arg3, arg4, arg5)                                                       \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(5), jl_pgcstack, arg1, arg2, arg3, arg4, arg5};         \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH6(arg1, arg2, arg3, arg4, arg5, arg6)                                                 \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(6), jl_pgcstack, arg1, arg2, arg3, arg4, arg5, arg6};   \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH7(arg1, arg2, arg3, arg4, arg5, arg6, arg7)                                           \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(7), jl_pgcstack, arg1, arg2, arg3, arg4, arg5, arg6, arg7}; \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n\n#define JL_GC_PUSHARGS(rts_var,n)                                                                       \\\n  rts_var = ((jl_value_t**)alloca(((n)+2)*sizeof(jl_value_t*)))+2;                                      \\\n  ((void**)rts_var)[-2] = (void*)JL_GC_ENCODE_PUSHARGS(n);                                              \\\n  ((void**)rts_var)[-1] = jl_pgcstack;                                                                  \\\n  memset((void*)rts_var, 0, (n)*sizeof(jl_value_t*));                                                   \\\n  jl_pgcstack = (jl_gcframe_t*)&(((void**)rts_var)[-2])\n\n#define JL_GC_POP() (jl_pgcstack = jl_pgcstack->prev)\n\n#endif\n\nJL_DLLEXPORT int jl_gc_enable(int on);\nJL_DLLEXPORT int jl_gc_is_enabled(void);\n\ntypedef enum {\n    JL_GC_AUTO = 0,         // use heuristics to determine the collection type\n    JL_GC_FULL = 1,         // force a full collection\n    JL_GC_INCREMENTAL = 2,  // force an incremental collection\n} jl_gc_collection_t;\n\nJL_DLLEXPORT void jl_gc_collect(jl_gc_collection_t);\n\nJL_DLLEXPORT void jl_gc_add_finalizer(jl_value_t *v, jl_function_t *f);\nJL_DLLEXPORT void jl_finalize(jl_value_t *o);\nJL_DLLEXPORT jl_weakref_t *jl_gc_new_weakref(jl_value_t *value);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_0w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_1w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_2w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_3w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_allocobj(size_t sz);\nJL_DLLEXPORT void *jl_malloc_stack(size_t *bufsz, struct _jl_task_t *owner) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_free_stack(void *stkbuf, size_t bufsz);\nJL_DLLEXPORT void jl_gc_use(jl_value_t *a);\n\nJL_DLLEXPORT void jl_clear_malloc_data(void);\n\n// GC write barriers\nJL_DLLEXPORT void jl_gc_queue_root(jl_value_t *root) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_gc_queue_multiroot(jl_value_t *root, jl_value_t *stored) JL_NOTSAFEPOINT;\n\nSTATIC_INLINE void jl_gc_wb(void *parent, void *ptr) JL_NOTSAFEPOINT\n{\n    // parent and ptr isa jl_value_t*\n    if (__unlikely(jl_astaggedvalue(parent)->bits.gc == 3 && // parent is old and not in remset\n                   (jl_astaggedvalue(ptr)->bits.gc & 1) == 0)) // ptr is young\n        jl_gc_queue_root((jl_value_t*)parent);\n}\n\nSTATIC_INLINE void jl_gc_wb_back(void *ptr) JL_NOTSAFEPOINT // ptr isa jl_value_t*\n{\n    // if ptr is old\n    if (__unlikely(jl_astaggedvalue(ptr)->bits.gc == 3)) {\n        jl_gc_queue_root((jl_value_t*)ptr);\n    }\n}\n\nSTATIC_INLINE void jl_gc_multi_wb(void *parent, jl_value_t *ptr) JL_NOTSAFEPOINT\n{\n    // ptr is an immutable object\n    if (__likely(jl_astaggedvalue(parent)->bits.gc != 3))\n        return; // parent is young or in remset\n    if (__likely(jl_astaggedvalue(ptr)->bits.gc == 3))\n        return; // ptr is old and not in remset (thus it does not point to young)\n    jl_datatype_t *dt = (jl_datatype_t*)jl_typeof(ptr);\n    const jl_datatype_layout_t *ly = dt->layout;\n    if (ly->npointers)\n        jl_gc_queue_multiroot((jl_value_t*)parent, ptr);\n}\n\nJL_DLLEXPORT void *jl_gc_managed_malloc(size_t sz);\nJL_DLLEXPORT void *jl_gc_managed_realloc(void *d, size_t sz, size_t oldsz,\n                                         int isaligned, jl_value_t *owner);\n\n// object accessors -----------------------------------------------------------\n\n#define jl_svec_len(t)              (((jl_svec_t*)(t))->length)\n#define jl_svec_set_len_unsafe(t,n) (((jl_svec_t*)(t))->length=(n))\n#define jl_svec_data(t) ((jl_value_t**)((char*)(t) + sizeof(jl_svec_t)))\n\n#ifdef __clang_analyzer__\nSTATIC_INLINE jl_value_t *jl_svecref(void *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\nSTATIC_INLINE jl_value_t *jl_svecset(\n    void *t JL_ROOTING_ARGUMENT JL_PROPAGATES_ROOT,\n    size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT;\n#else\nSTATIC_INLINE jl_value_t *jl_svecref(void *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    // while svec is supposedly immutable, in practice we sometimes publish it first\n    // and set the values lazily\n    return jl_atomic_load_relaxed(jl_svec_data(t) + i);\n}\nSTATIC_INLINE jl_value_t *jl_svecset(\n    void *t JL_ROOTING_ARGUMENT JL_PROPAGATES_ROOT,\n    size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    // TODO: while svec is supposedly immutable, in practice we sometimes publish it first\n    // and set the values lazily. Those users should be using jl_atomic_store_release here.\n    jl_svec_data(t)[i] = (jl_value_t*)x;\n    if (x) jl_gc_wb(t, x);\n    return (jl_value_t*)x;\n}\n#endif\n\n#ifdef STORE_ARRAY_LEN\n#define jl_array_len(a)   (((jl_array_t*)(a))->length)\n#else\nJL_DLLEXPORT size_t jl_array_len_(jl_array_t *a);\n#define jl_array_len(a)   jl_array_len_((jl_array_t*)(a))\n#endif\n#define jl_array_data(a)  ((void*)((jl_array_t*)(a))->data)\n#define jl_array_dim(a,i) ((&((jl_array_t*)(a))->nrows)[i])\n#define jl_array_dim0(a)  (((jl_array_t*)(a))->nrows)\n#define jl_array_nrows(a) (((jl_array_t*)(a))->nrows)\n#define jl_array_ndims(a) ((int32_t)(((jl_array_t*)a)->flags.ndims))\n#define jl_array_data_owner_offset(ndims) (offsetof(jl_array_t,ncols) + sizeof(size_t)*(1+jl_array_ndimwords(ndims))) // in bytes\n#define jl_array_data_owner(a) (*((jl_value_t**)((char*)a + jl_array_data_owner_offset(jl_array_ndims(a)))))\n\nJL_DLLEXPORT char *jl_array_typetagdata(jl_array_t *a) JL_NOTSAFEPOINT;\n\n#ifdef __clang_analyzer__\njl_value_t **jl_array_ptr_data(jl_array_t *a JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\nSTATIC_INLINE jl_value_t *jl_array_ptr_ref(void *a JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\nSTATIC_INLINE jl_value_t *jl_array_ptr_set(\n    void *a JL_ROOTING_ARGUMENT, size_t i,\n    void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT;\n#else\n#define jl_array_ptr_data(a)  ((jl_value_t**)((jl_array_t*)(a))->data)\nSTATIC_INLINE jl_value_t *jl_array_ptr_ref(void *a JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT\n{\n    assert(((jl_array_t*)a)->flags.ptrarray);\n    assert(i < jl_array_len(a));\n    return jl_atomic_load_relaxed(((jl_value_t**)(jl_array_data(a))) + i);\n}\nSTATIC_INLINE jl_value_t *jl_array_ptr_set(\n    void *a JL_ROOTING_ARGUMENT, size_t i,\n    void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n{\n    assert(((jl_array_t*)a)->flags.ptrarray);\n    assert(i < jl_array_len(a));\n    jl_atomic_store_relaxed(((jl_value_t**)(jl_array_data(a))) + i, (jl_value_t*)x);\n    if (x) {\n        if (((jl_array_t*)a)->flags.how == 3) {\n            a = jl_array_data_owner(a);\n        }\n        jl_gc_wb(a, x);\n    }\n    return (jl_value_t*)x;\n}\n#endif\n\nSTATIC_INLINE uint8_t jl_array_uint8_ref(void *a, size_t i) JL_NOTSAFEPOINT\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    return ((uint8_t*)(jl_array_data(a)))[i];\n}\nSTATIC_INLINE void jl_array_uint8_set(void *a, size_t i, uint8_t x) JL_NOTSAFEPOINT\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    ((uint8_t*)(jl_array_data(a)))[i] = x;\n}\n\n#define jl_exprarg(e,n) jl_array_ptr_ref(((jl_expr_t*)(e))->args, n)\n#define jl_exprargset(e, n, v) jl_array_ptr_set(((jl_expr_t*)(e))->args, n, v)\n#define jl_expr_nargs(e) jl_array_len(((jl_expr_t*)(e))->args)\n\n#define jl_fieldref(s,i) jl_get_nth_field(((jl_value_t*)(s)),i)\n#define jl_fieldref_noalloc(s,i) jl_get_nth_field_noalloc(((jl_value_t*)(s)),i)\n#define jl_nfields(v)    jl_datatype_nfields(jl_typeof(v))\n\n// Not using jl_fieldref to avoid allocations\n#define jl_linenode_line(x) (((intptr_t*)(x))[0])\n#define jl_linenode_file(x) (((jl_value_t**)(x))[1])\n#define jl_slot_number(x) (((intptr_t*)(x))[0])\n#define jl_typedslot_get_type(x) (((jl_value_t**)(x))[1])\n#define jl_gotonode_label(x) (((intptr_t*)(x))[0])\n#define jl_gotoifnot_cond(x) (((jl_value_t**)(x))[0])\n#define jl_gotoifnot_label(x) (((intptr_t*)(x))[1])\n#define jl_globalref_mod(s) (*(jl_module_t**)(s))\n#define jl_globalref_name(s) (((jl_sym_t**)(s))[1])\n#define jl_quotenode_value(x) (((jl_value_t**)x)[0])\n#define jl_returnnode_value(x) (((jl_value_t**)x)[0])\n\n#define jl_nparams(t)  jl_svec_len(((jl_datatype_t*)(t))->parameters)\n#define jl_tparam0(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 0)\n#define jl_tparam1(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 1)\n#define jl_tparam(t,i) jl_svecref(((jl_datatype_t*)(t))->parameters, i)\n\n// get a pointer to the data in a datatype\n#define jl_data_ptr(v)  ((jl_value_t**)v)\n\n#define jl_string_data(s) ((char*)s + sizeof(void*))\n#define jl_string_len(s)  (*(size_t*)s)\n\n#define jl_gf_mtable(f) (((jl_datatype_t*)jl_typeof(f))->name->mt)\n#define jl_gf_name(f)   (jl_gf_mtable(f)->name)\n\n// struct type info\nJL_DLLEXPORT jl_svec_t *jl_compute_fieldtypes(jl_datatype_t *st JL_PROPAGATES_ROOT, void *stack);\n#define jl_get_fieldtypes(st) ((st)->types ? (st)->types : jl_compute_fieldtypes((st), NULL))\nSTATIC_INLINE jl_svec_t *jl_field_names(jl_datatype_t *st) JL_NOTSAFEPOINT\n{\n    jl_svec_t *names = st->names;\n    if (!names)\n        names = st->name->names;\n    return names;\n}\nSTATIC_INLINE jl_sym_t *jl_field_name(jl_datatype_t *st, size_t i) JL_NOTSAFEPOINT\n{\n    return (jl_sym_t*)jl_svecref(jl_field_names(st), i);\n}\nSTATIC_INLINE jl_value_t *jl_field_type(jl_datatype_t *st JL_PROPAGATES_ROOT, size_t i)\n{\n    return jl_svecref(jl_get_fieldtypes(st), i);\n}\nSTATIC_INLINE jl_value_t *jl_field_type_concrete(jl_datatype_t *st JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT\n{\n    assert(st->types);\n    return jl_svecref(st->types, i);\n}\n\n#define jl_datatype_size(t)    (((jl_datatype_t*)t)->size)\n#define jl_datatype_align(t)   (((jl_datatype_t*)t)->layout->alignment)\n#define jl_datatype_nbits(t)   ((((jl_datatype_t*)t)->size)*8)\n#define jl_datatype_nfields(t) (((jl_datatype_t*)(t))->layout->nfields)\n#define jl_datatype_isinlinealloc(t) (((jl_datatype_t *)(t))->isinlinealloc)\n\nJL_DLLEXPORT void *jl_symbol_name(jl_sym_t *s);\n// inline version with strong type check to detect typos in a `->name` chain\nSTATIC_INLINE char *jl_symbol_name_(jl_sym_t *s) JL_NOTSAFEPOINT\n{\n    return (char*)s + LLT_ALIGN(sizeof(jl_sym_t), sizeof(void*));\n}\n#define jl_symbol_name(s) jl_symbol_name_(s)\n\nstatic inline uint32_t jl_fielddesc_size(int8_t fielddesc_type) JL_NOTSAFEPOINT\n{\n    assert(fielddesc_type >= 0 && fielddesc_type <= 2);\n    return 2 << fielddesc_type;\n    //if (fielddesc_type == 0) {\n    //    return sizeof(jl_fielddesc8_t);\n    //}\n    //else if (fielddesc_type == 1) {\n    //    return sizeof(jl_fielddesc16_t);\n    //}\n    //else {\n    //    return sizeof(jl_fielddesc32_t);\n    //}\n}\n\n#define jl_dt_layout_fields(d) ((const char*)(d) + sizeof(jl_datatype_layout_t))\nstatic inline const char *jl_dt_layout_ptrs(const jl_datatype_layout_t *l) JL_NOTSAFEPOINT\n{\n    return jl_dt_layout_fields(l) + jl_fielddesc_size(l->fielddesc_type) * l->nfields;\n}\n\n#define DEFINE_FIELD_ACCESSORS(f)                                             \\\n    static inline uint32_t jl_field_##f(jl_datatype_t *st,                    \\\n                                        int i) JL_NOTSAFEPOINT                \\\n    {                                                                         \\\n        const jl_datatype_layout_t *ly = st->layout;                          \\\n        assert(i >= 0 && (size_t)i < ly->nfields);                            \\\n        if (ly->fielddesc_type == 0) {                                        \\\n            return ((const jl_fielddesc8_t*)jl_dt_layout_fields(ly))[i].f;    \\\n        }                                                                     \\\n        else if (ly->fielddesc_type == 1) {                                   \\\n            return ((const jl_fielddesc16_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n        else {                                                                \\\n            assert(ly->fielddesc_type == 2);                                  \\\n            return ((const jl_fielddesc32_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n    }                                                                         \\\n\nDEFINE_FIELD_ACCESSORS(offset)\nDEFINE_FIELD_ACCESSORS(size)\n#undef DEFINE_FIELD_ACCESSORS\n\nstatic inline int jl_field_isptr(jl_datatype_t *st, int i) JL_NOTSAFEPOINT\n{\n    const jl_datatype_layout_t *ly = st->layout;\n    assert(i >= 0 && (size_t)i < ly->nfields);\n    return ((const jl_fielddesc8_t*)(jl_dt_layout_fields(ly) + jl_fielddesc_size(ly->fielddesc_type) * i))->isptr;\n}\n\nstatic inline uint32_t jl_ptr_offset(jl_datatype_t *st, int i) JL_NOTSAFEPOINT\n{\n    const jl_datatype_layout_t *ly = st->layout;\n    assert(i >= 0 && (size_t)i < ly->npointers);\n    const void *ptrs = jl_dt_layout_ptrs(ly);\n    if (ly->fielddesc_type == 0) {\n        return ((const uint8_t*)ptrs)[i];\n    }\n    else if (ly->fielddesc_type == 1) {\n        return ((const uint16_t*)ptrs)[i];\n    }\n    else {\n        assert(ly->fielddesc_type == 2);\n        return ((const uint32_t*)ptrs)[i];\n    }\n}\n\nstatic inline int jl_is_layout_opaque(const jl_datatype_layout_t *l) JL_NOTSAFEPOINT\n{\n    return l->nfields == 0 && l->npointers > 0;\n}\n\n// basic predicates -----------------------------------------------------------\n#define jl_is_nothing(v)     (((jl_value_t*)(v)) == ((jl_value_t*)jl_nothing))\n#define jl_is_tuple(v)       (((jl_datatype_t*)jl_typeof(v))->name == jl_tuple_typename)\n#define jl_is_namedtuple(v)  (((jl_datatype_t*)jl_typeof(v))->name == jl_namedtuple_typename)\n#define jl_is_svec(v)        jl_typeis(v,jl_simplevector_type)\n#define jl_is_simplevector(v) jl_is_svec(v)\n#define jl_is_datatype(v)    jl_typeis(v,jl_datatype_type)\n#define jl_is_mutable(t)     (((jl_datatype_t*)t)->mutabl)\n#define jl_is_mutable_datatype(t) (jl_is_datatype(t) && (((jl_datatype_t*)t)->mutabl))\n#define jl_is_immutable(t)   (!((jl_datatype_t*)t)->mutabl)\n#define jl_is_immutable_datatype(t) (jl_is_datatype(t) && (!((jl_datatype_t*)t)->mutabl))\n#define jl_is_uniontype(v)   jl_typeis(v,jl_uniontype_type)\n#define jl_is_typevar(v)     jl_typeis(v,jl_tvar_type)\n#define jl_is_unionall(v)    jl_typeis(v,jl_unionall_type)\n#define jl_is_typename(v)    jl_typeis(v,jl_typename_type)\n#define jl_is_int8(v)        jl_typeis(v,jl_int8_type)\n#define jl_is_int16(v)       jl_typeis(v,jl_int16_type)\n#define jl_is_int32(v)       jl_typeis(v,jl_int32_type)\n#define jl_is_int64(v)       jl_typeis(v,jl_int64_type)\n#define jl_is_uint8(v)       jl_typeis(v,jl_uint8_type)\n#define jl_is_uint16(v)      jl_typeis(v,jl_uint16_type)\n#define jl_is_uint32(v)      jl_typeis(v,jl_uint32_type)\n#define jl_is_uint64(v)      jl_typeis(v,jl_uint64_type)\n#define jl_is_bool(v)        jl_typeis(v,jl_bool_type)\n#define jl_is_symbol(v)      jl_typeis(v,jl_symbol_type)\n#define jl_is_ssavalue(v)    jl_typeis(v,jl_ssavalue_type)\n#define jl_is_slot(v)        (jl_typeis(v,jl_slotnumber_type) || jl_typeis(v,jl_typedslot_type))\n#define jl_is_expr(v)        jl_typeis(v,jl_expr_type)\n#define jl_is_globalref(v)   jl_typeis(v,jl_globalref_type)\n#define jl_is_gotonode(v)    jl_typeis(v,jl_gotonode_type)\n#define jl_is_gotoifnot(v)   jl_typeis(v,jl_gotoifnot_type)\n#define jl_is_returnnode(v)  jl_typeis(v,jl_returnnode_type)\n#define jl_is_argument(v)    jl_typeis(v,jl_argument_type)\n#define jl_is_pinode(v)      jl_typeis(v,jl_pinode_type)\n#define jl_is_phinode(v)     jl_typeis(v,jl_phinode_type)\n#define jl_is_phicnode(v)    jl_typeis(v,jl_phicnode_type)\n#define jl_is_upsilonnode(v) jl_typeis(v,jl_upsilonnode_type)\n#define jl_is_quotenode(v)   jl_typeis(v,jl_quotenode_type)\n#define jl_is_newvarnode(v)  jl_typeis(v,jl_newvarnode_type)\n#define jl_is_linenode(v)    jl_typeis(v,jl_linenumbernode_type)\n#define jl_is_method_instance(v) jl_typeis(v,jl_method_instance_type)\n#define jl_is_code_instance(v) jl_typeis(v,jl_code_instance_type)\n#define jl_is_code_info(v)   jl_typeis(v,jl_code_info_type)\n#define jl_is_method(v)      jl_typeis(v,jl_method_type)\n#define jl_is_module(v)      jl_typeis(v,jl_module_type)\n#define jl_is_mtable(v)      jl_typeis(v,jl_methtable_type)\n#define jl_is_task(v)        jl_typeis(v,jl_task_type)\n#define jl_is_string(v)      jl_typeis(v,jl_string_type)\n#define jl_is_cpointer(v)    jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_pointer(v)     jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_uint8pointer(v)jl_typeis(v,jl_uint8pointer_type)\n#define jl_is_llvmpointer(v) (((jl_datatype_t*)jl_typeof(v))->name == jl_llvmpointer_typename)\n#define jl_is_intrinsic(v)   jl_typeis(v,jl_intrinsic_type)\n#define jl_array_isbitsunion(a) (!(((jl_array_t*)(a))->flags.ptrarray) && jl_is_uniontype(jl_tparam0(jl_typeof(a))))\n\nJL_DLLEXPORT int jl_subtype(jl_value_t *a, jl_value_t *b);\n\nSTATIC_INLINE int jl_is_kind(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return (v==(jl_value_t*)jl_uniontype_type || v==(jl_value_t*)jl_datatype_type ||\n            v==(jl_value_t*)jl_unionall_type || v==(jl_value_t*)jl_typeofbottom_type);\n}\n\nSTATIC_INLINE int jl_is_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_is_kind(jl_typeof(v));\n}\n\nSTATIC_INLINE int jl_is_primitivetype(void *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) && jl_is_immutable(v) &&\n            ((jl_datatype_t*)(v))->layout &&\n            jl_datatype_nfields(v) == 0 &&\n            jl_datatype_size(v) > 0);\n}\n\nSTATIC_INLINE int jl_is_structtype(void *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) &&\n            !((jl_datatype_t*)(v))->abstract &&\n            !jl_is_primitivetype(v));\n}\n\nSTATIC_INLINE int jl_isbits(void *t) JL_NOTSAFEPOINT // corresponding to isbits() in julia\n{\n    return (jl_is_datatype(t) && ((jl_datatype_t*)t)->isbitstype);\n}\n\nSTATIC_INLINE int jl_is_datatype_singleton(jl_datatype_t *d) JL_NOTSAFEPOINT\n{\n    return (d->instance != NULL);\n}\n\nSTATIC_INLINE int jl_is_abstracttype(void *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) && ((jl_datatype_t*)(v))->abstract);\n}\n\nSTATIC_INLINE int jl_is_array_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_array_typename);\n}\n\nSTATIC_INLINE int jl_is_array(void *v) JL_NOTSAFEPOINT\n{\n    jl_value_t *t = jl_typeof(v);\n    return jl_is_array_type(t);\n}\n\n\nSTATIC_INLINE int jl_is_opaque_closure_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_opaque_closure_typename);\n}\n\nSTATIC_INLINE int jl_is_opaque_closure(void *v) JL_NOTSAFEPOINT\n{\n    jl_value_t *t = jl_typeof(v);\n    return jl_is_opaque_closure_type(t);\n}\n\nSTATIC_INLINE int jl_is_cpointer_type(jl_value_t *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == ((jl_datatype_t*)jl_pointer_type->body)->name);\n}\n\nSTATIC_INLINE int jl_is_llvmpointer_type(jl_value_t *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_llvmpointer_typename);\n}\n\nSTATIC_INLINE int jl_is_abstract_ref_type(jl_value_t *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == ((jl_datatype_t*)jl_ref_type->body)->name);\n}\n\nSTATIC_INLINE int jl_is_tuple_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_tuple_typename);\n}\n\nSTATIC_INLINE int jl_is_namedtuple_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_namedtuple_typename);\n}\n\nSTATIC_INLINE int jl_is_vecelement_type(jl_value_t* t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_vecelement_typename);\n}\n\nSTATIC_INLINE int jl_is_type_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == ((jl_datatype_t*)jl_type_type->body)->name);\n}\n\nSTATIC_INLINE int jl_is_array_zeroinit(jl_array_t *a) JL_NOTSAFEPOINT\n{\n    if (a->flags.ptrarray || a->flags.hasptr)\n        return 1;\n    jl_value_t *elty = jl_tparam0(jl_typeof(a));\n    return jl_is_datatype(elty) && ((jl_datatype_t*)elty)->zeroinit;\n}\n\n// object identity\nJL_DLLEXPORT int jl_egal(jl_value_t *a JL_MAYBE_UNROOTED, jl_value_t *b JL_MAYBE_UNROOTED) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uintptr_t jl_object_id(jl_value_t *v) JL_NOTSAFEPOINT;\n\n// type predicates and basic operations\nJL_DLLEXPORT int jl_type_equality_is_identity(jl_value_t *t1, jl_value_t *t2) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_has_free_typevars(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_has_typevar(jl_value_t *t, jl_tvar_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_has_typevar_from_unionall(jl_value_t *t, jl_unionall_t *ua);\nJL_DLLEXPORT int jl_subtype_env_size(jl_value_t *t);\nJL_DLLEXPORT int jl_subtype_env(jl_value_t *x, jl_value_t *y, jl_value_t **env, int envsz);\nJL_DLLEXPORT int jl_isa(jl_value_t *a, jl_value_t *t);\nJL_DLLEXPORT int jl_types_equal(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT int jl_is_not_broken_subtype(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_type_union(jl_value_t **ts, size_t n);\nJL_DLLEXPORT jl_value_t *jl_type_intersection(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT int jl_has_empty_intersection(jl_value_t *x, jl_value_t *y);\nJL_DLLEXPORT jl_value_t *jl_type_unionall(jl_tvar_t *v, jl_value_t *body);\nJL_DLLEXPORT const char *jl_typename_str(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT const char *jl_typeof_str(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_type_morespecific(jl_value_t *a, jl_value_t *b);\n\nSTATIC_INLINE int jl_is_dispatch_tupletype(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isdispatchtuple;\n}\n\nSTATIC_INLINE int jl_is_concrete_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isconcretetype;\n}\n\nJL_DLLEXPORT int jl_isa_compileable_sig(jl_tupletype_t *type, jl_method_t *definition);\n\n// type constructors\nJL_DLLEXPORT jl_typename_t *jl_new_typename_in(jl_sym_t *name, jl_module_t *inmodule);\nJL_DLLEXPORT jl_tvar_t *jl_new_typevar(jl_sym_t *name, jl_value_t *lb, jl_value_t *ub);\nJL_DLLEXPORT jl_value_t *jl_instantiate_unionall(jl_unionall_t *u, jl_value_t *p);\nJL_DLLEXPORT jl_value_t *jl_apply_type(jl_value_t *tc, jl_value_t **params, size_t n);\nJL_DLLEXPORT jl_value_t *jl_apply_type1(jl_value_t *tc, jl_value_t *p1);\nJL_DLLEXPORT jl_value_t *jl_apply_type2(jl_value_t *tc, jl_value_t *p1, jl_value_t *p2);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type(jl_svec_t *params);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type_v(jl_value_t **p, size_t np);\nJL_DLLEXPORT jl_datatype_t *jl_new_datatype(jl_sym_t *name,\n                                            jl_module_t *module,\n                                            jl_datatype_t *super,\n                                            jl_svec_t *parameters,\n                                            jl_svec_t *fnames, jl_svec_t *ftypes,\n                                            int abstract, int mutabl,\n                                            int ninitialized);\nJL_DLLEXPORT jl_datatype_t *jl_new_primitivetype(jl_value_t *name,\n                                                 jl_module_t *module,\n                                                 jl_datatype_t *super,\n                                                 jl_svec_t *parameters, size_t nbits);\n\n// constructors\nJL_DLLEXPORT jl_value_t *jl_new_bits(jl_value_t *bt, void *data);\nJL_DLLEXPORT jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\nJL_DLLEXPORT jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);\nJL_DLLEXPORT jl_value_t *jl_new_structt(jl_datatype_t *type, jl_value_t *tup);\nJL_DLLEXPORT jl_value_t *jl_new_struct_uninit(jl_datatype_t *type);\nJL_DLLEXPORT jl_method_instance_t *jl_new_method_instance_uninit(void);\nJL_DLLEXPORT jl_svec_t *jl_svec(size_t n, ...) JL_MAYBE_UNROOTED;\nJL_DLLEXPORT jl_svec_t *jl_svec1(void *a);\nJL_DLLEXPORT jl_svec_t *jl_svec2(void *a, void *b);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec_uninit(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_svec_copy(jl_svec_t *a);\nJL_DLLEXPORT jl_svec_t *jl_svec_fill(size_t n, jl_value_t *x);\nJL_DLLEXPORT jl_value_t *jl_tupletype_fill(size_t n, jl_value_t *v);\nJL_DLLEXPORT jl_sym_t *jl_symbol(const char *str) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_symbol_lookup(const char *str) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_symbol_n(const char *str, size_t len) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_gensym(void);\nJL_DLLEXPORT jl_sym_t *jl_tagged_gensym(const char *str, size_t len);\nJL_DLLEXPORT jl_sym_t *jl_get_root_symbol(void);\nJL_DLLEXPORT jl_value_t *jl_generic_function_def(jl_sym_t *name,\n                                                 jl_module_t *module,\n                                                 jl_value_t **bp, jl_value_t *bp_owner,\n                                                 jl_binding_t *bnd);\nJL_DLLEXPORT void jl_method_def(jl_svec_t *argdata, jl_code_info_t *f, jl_module_t *module);\nJL_DLLEXPORT jl_code_info_t *jl_code_for_staged(jl_method_instance_t *linfo);\nJL_DLLEXPORT jl_code_info_t *jl_copy_code_info(jl_code_info_t *src);\nJL_DLLEXPORT size_t jl_get_world_counter(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_function_t *jl_get_kwsorter(jl_value_t *ty);\nJL_DLLEXPORT jl_value_t *jl_box_bool(int8_t x) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_box_int8(int8_t x) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_box_uint8(uint8_t x) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_box_int16(int16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint16(uint16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int32(int32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint32(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_char(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int64(int64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint64(uint64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_float32(float x);\nJL_DLLEXPORT jl_value_t *jl_box_float64(double x);\nJL_DLLEXPORT jl_value_t *jl_box_voidpointer(void *x);\nJL_DLLEXPORT jl_value_t *jl_box_uint8pointer(uint8_t *x);\nJL_DLLEXPORT jl_value_t *jl_box_ssavalue(size_t x);\nJL_DLLEXPORT jl_value_t *jl_box_slotnumber(size_t x);\nJL_DLLEXPORT int8_t jl_unbox_bool(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int8_t jl_unbox_int8(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t jl_unbox_uint8(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int16_t jl_unbox_int16(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint16_t jl_unbox_uint16(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int32_t jl_unbox_int32(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint32_t jl_unbox_uint32(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int64_t jl_unbox_int64(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint64_t jl_unbox_uint64(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT float jl_unbox_float32(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT double jl_unbox_float64(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void *jl_unbox_voidpointer(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t *jl_unbox_uint8pointer(jl_value_t *v) JL_NOTSAFEPOINT;\n\nJL_DLLEXPORT int jl_get_size(jl_value_t *val, size_t *pnt);\n\n#ifdef _P64\n#define jl_box_long(x)   jl_box_int64(x)\n#define jl_box_ulong(x)  jl_box_uint64(x)\n#define jl_unbox_long(x) jl_unbox_int64(x)\n#define jl_unbox_ulong(x) jl_unbox_uint64(x)\n#define jl_is_long(x)    jl_is_int64(x)\n#define jl_is_ulong(x)   jl_is_uint64(x)\n#define jl_long_type     jl_int64_type\n#define jl_ulong_type    jl_uint64_type\n#else\n#define jl_box_long(x)   jl_box_int32(x)\n#define jl_box_ulong(x)  jl_box_uint32(x)\n#define jl_unbox_long(x) jl_unbox_int32(x)\n#define jl_unbox_ulong(x) jl_unbox_uint32(x)\n#define jl_is_long(x)    jl_is_int32(x)\n#define jl_is_ulong(x)   jl_is_uint32(x)\n#define jl_long_type     jl_int32_type\n#define jl_ulong_type    jl_uint32_type\n#endif\n\n// structs\nJL_DLLEXPORT int         jl_field_index(jl_datatype_t *t, jl_sym_t *fld, int err);\nJL_DLLEXPORT jl_value_t *jl_get_nth_field(jl_value_t *v, size_t i);\n// Like jl_get_nth_field above, but asserts if it needs to allocate\nJL_DLLEXPORT jl_value_t *jl_get_nth_field_noalloc(jl_value_t *v JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\nJL_DLLEXPORT void        jl_set_nth_field(jl_value_t *v, size_t i,\n                                          jl_value_t *rhs) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int         jl_field_isdefined(jl_value_t *v, size_t i) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_get_field(jl_value_t *o, const char *fld);\nJL_DLLEXPORT jl_value_t *jl_value_ptr(jl_value_t *a);\nint jl_uniontype_size(jl_value_t *ty, size_t *sz) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_islayout_inline(jl_value_t *eltype, size_t *fsz, size_t *al) JL_NOTSAFEPOINT;\n\n// arrays\nJL_DLLEXPORT jl_array_t *jl_new_array(jl_value_t *atype, jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_reshape_array(jl_value_t *atype, jl_array_t *data,\n                                          jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array_1d(jl_value_t *atype, void *data,\n                                            size_t nel, int own_buffer);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array(jl_value_t *atype, void *data,\n                                         jl_value_t *dims, int own_buffer);\n\nJL_DLLEXPORT jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr,\n                                           size_t nc);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr,\n                                           size_t nc, size_t z);\nJL_DLLEXPORT jl_array_t *jl_pchar_to_array(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_pchar_to_string(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_cstr_to_string(const char *str);\nJL_DLLEXPORT jl_value_t *jl_alloc_string(size_t len);\nJL_DLLEXPORT jl_value_t *jl_array_to_string(jl_array_t *a);\nJL_DLLEXPORT jl_array_t *jl_alloc_vec_any(size_t n);\nJL_DLLEXPORT jl_value_t *jl_arrayref(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT jl_value_t *jl_ptrarrayref(jl_array_t *a JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;  // 0-indexed\nJL_DLLEXPORT void jl_arrayset(jl_array_t *a JL_ROOTING_ARGUMENT, jl_value_t *v JL_ROOTED_ARGUMENT JL_MAYBE_UNROOTED, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_arrayunset(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT int jl_array_isassigned(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_array_grow_end(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_end(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_grow_beg(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_beg(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_sizehint(jl_array_t *a, size_t sz);\nJL_DLLEXPORT void jl_array_ptr_1d_push(jl_array_t *a, jl_value_t *item);\nJL_DLLEXPORT void jl_array_ptr_1d_append(jl_array_t *a, jl_array_t *a2);\nJL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim);\n// property access\nJL_DLLEXPORT void *jl_array_ptr(jl_array_t *a);\nJL_DLLEXPORT void *jl_array_eltype(jl_value_t *a);\nJL_DLLEXPORT int jl_array_rank(jl_value_t *a);\nJL_DLLEXPORT size_t jl_array_size(jl_value_t *a, int d);\n\n// strings\nJL_DLLEXPORT const char *jl_string_ptr(jl_value_t *s);\n\n// modules and global variables\nextern JL_DLLEXPORT jl_module_t *jl_main_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_core_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_base_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_top_module JL_GLOBALLY_ROOTED;\nJL_DLLEXPORT jl_module_t *jl_new_module(jl_sym_t *name);\nJL_DLLEXPORT void jl_set_module_nospecialize(jl_module_t *self, int on);\nJL_DLLEXPORT void jl_set_module_optlevel(jl_module_t *self, int lvl);\nJL_DLLEXPORT int jl_get_module_optlevel(jl_module_t *m);\nJL_DLLEXPORT void jl_set_module_compile(jl_module_t *self, int value);\nJL_DLLEXPORT int jl_get_module_compile(jl_module_t *m);\nJL_DLLEXPORT void jl_set_module_infer(jl_module_t *self, int value);\nJL_DLLEXPORT int jl_get_module_infer(jl_module_t *m);\n// get binding for reading\nJL_DLLEXPORT jl_binding_t *jl_get_binding(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *var);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_or_error(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_module_globalref(jl_module_t *m, jl_sym_t *var);\n// get binding for assignment\nJL_DLLEXPORT jl_binding_t *jl_get_binding_wr(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *var, int error);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_for_method_def(jl_module_t *m JL_PROPAGATES_ROOT,\n                                                         jl_sym_t *var);\nJL_DLLEXPORT int jl_boundp(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_defines_or_exports_p(jl_module_t *m, jl_sym_t *var) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_binding_resolved_p(jl_module_t *m, jl_sym_t *var) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_is_const(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_get_global(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *var);\nJL_DLLEXPORT void jl_set_global(jl_module_t *m JL_ROOTING_ARGUMENT, jl_sym_t *var, jl_value_t *val JL_ROOTED_ARGUMENT);\nJL_DLLEXPORT void jl_set_const(jl_module_t *m JL_ROOTING_ARGUMENT, jl_sym_t *var, jl_value_t *val JL_ROOTED_ARGUMENT);\nJL_DLLEXPORT void jl_checked_assignment(jl_binding_t *b JL_ROOTING_ARGUMENT, jl_value_t *rhs JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_declare_constant(jl_binding_t *b);\nJL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from);\nJL_DLLEXPORT void jl_module_use(jl_module_t *to, jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT void jl_module_use_as(jl_module_t *to, jl_module_t *from, jl_sym_t *s, jl_sym_t *asname);\nJL_DLLEXPORT void jl_module_import(jl_module_t *to, jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT void jl_module_import_as(jl_module_t *to, jl_module_t *from, jl_sym_t *s, jl_sym_t *asname);\nJL_DLLEXPORT void jl_module_export(jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT int jl_is_imported(jl_module_t *m, jl_sym_t *s);\nJL_DLLEXPORT int jl_module_exports_p(jl_module_t *m, jl_sym_t *var) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_add_standard_imports(jl_module_t *m);\nSTATIC_INLINE jl_function_t *jl_get_function(jl_module_t *m, const char *name)\n{\n    return (jl_function_t*)jl_get_global(m, jl_symbol(name));\n}\n\n// eq hash tables\nJL_DLLEXPORT jl_array_t *jl_eqtable_put(jl_array_t *h, jl_value_t *key, jl_value_t *val, int *inserted);\nJL_DLLEXPORT jl_value_t *jl_eqtable_get(jl_array_t *h, jl_value_t *key, jl_value_t *deflt) JL_NOTSAFEPOINT;\n\n// system information\nJL_DLLEXPORT int jl_errno(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_set_errno(int e) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_cpu_threads(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT long jl_getpagesize(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT long jl_getallocationgranularity(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_is_debugbuild(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_get_libllvm(void) JL_NOTSAFEPOINT;\nextern JL_DLLIMPORT int jl_n_threads;\n\n// environment entries\nJL_DLLEXPORT jl_value_t *jl_environ(int i);\n\n// throwing common exceptions\nJL_DLLEXPORT jl_value_t *jl_vexceptionf(jl_datatype_t *exception_type,\n                                        const char *fmt, va_list args);\nJL_DLLEXPORT void JL_NORETURN jl_error(const char *str);\nJL_DLLEXPORT void JL_NORETURN jl_errorf(const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_exceptionf(jl_datatype_t *ty,\n                                            const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_too_few_args(const char *fname, int min);\nJL_DLLEXPORT void JL_NORETURN jl_too_many_args(const char *fname, int max);\nJL_DLLEXPORT void JL_NORETURN jl_type_error(const char *fname,\n                                            jl_value_t *expected JL_MAYBE_UNROOTED,\n                                            jl_value_t *got JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_type_error_rt(const char *fname,\n                                               const char *context,\n                                               jl_value_t *ty JL_MAYBE_UNROOTED,\n                                               jl_value_t *got JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_undefined_var_error(jl_sym_t *var);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error(jl_value_t *v JL_MAYBE_UNROOTED,\n                                              jl_value_t *t JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_v(jl_value_t *v JL_MAYBE_UNROOTED,\n                                                jl_value_t **idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_int(jl_value_t *v JL_MAYBE_UNROOTED,\n                                                  size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_tuple_int(jl_value_t **v,\n                                                        size_t nv, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_unboxed_int(void *v, jl_value_t *vt, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_ints(jl_value_t *v JL_MAYBE_UNROOTED,\n                                                   size_t *idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_eof_error(void);\n\n// Return the exception currently being handled, or `jl_nothing`.\n//\n// The catch scope is determined dynamically so this works in functions called\n// from a catch block.  The returned value is gc rooted until we exit the\n// enclosing JL_CATCH.\n// FIXME: Teach the static analyzer about this rather than using\n// JL_GLOBALLY_ROOTED which is far too optimistic.\nJL_DLLEXPORT jl_value_t *jl_current_exception(void) JL_GLOBALLY_ROOTED JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_exception_occurred(void);\nJL_DLLEXPORT void jl_exception_clear(void) JL_NOTSAFEPOINT;\n\n#define JL_NARGS(fname, min, max)                               \\\n    if (nargs < min) jl_too_few_args(#fname, min);              \\\n    else if (nargs > max) jl_too_many_args(#fname, max);\n\n#define JL_NARGSV(fname, min)                           \\\n    if (nargs < min) jl_too_few_args(#fname, min);\n\n#define JL_TYPECHK(fname, type, v)                                 \\\n    if (!jl_is_##type(v)) {                                        \\\n        jl_type_error(#fname, (jl_value_t*)jl_##type##_type, (v)); \\\n    }\n#define JL_TYPECHKS(fname, type, v)                                     \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(fname, (jl_value_t*)jl_##type##_type, (v));       \\\n    }\n\n// initialization functions\ntypedef enum {\n    JL_IMAGE_CWD = 0,\n    JL_IMAGE_JULIA_HOME = 1,\n    //JL_IMAGE_LIBJULIA = 2,\n} JL_IMAGE_SEARCH;\n// this helps turn threading compilation mismatches into linker errors\n#define julia_init julia_init__threading\n#define jl_init jl_init__threading\n#define jl_init_with_image jl_init_with_image__threading\n\nJL_DLLEXPORT const char *jl_get_libdir(void);\nJL_DLLEXPORT void julia_init(JL_IMAGE_SEARCH rel);\nJL_DLLEXPORT void jl_init(void);\nJL_DLLEXPORT void jl_init_with_image(const char *julia_bindir,\n                                     const char *image_relative_path);\nJL_DLLEXPORT const char *jl_get_default_sysimg_path(void);\nJL_DLLEXPORT int jl_is_initialized(void);\nJL_DLLEXPORT void jl_atexit_hook(int status);\nJL_DLLEXPORT void JL_NORETURN jl_exit(int status);\nJL_DLLEXPORT const char *jl_pathname_for_handle(void *handle);\n\nJL_DLLEXPORT int jl_deserialize_verify_header(ios_t *s);\nJL_DLLEXPORT void jl_preload_sysimg_so(const char *fname);\nJL_DLLEXPORT void jl_set_sysimg_so(void *handle);\nJL_DLLEXPORT ios_t *jl_create_system_image(void *);\nJL_DLLEXPORT void jl_save_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len);\nJL_DLLEXPORT int jl_save_incremental(const char *fname, jl_array_t *worklist);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental(const char *fname, jl_array_t *depmods);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental_from_buf(const char *buf, size_t sz, jl_array_t *depmods);\n\n// parsing\nJL_DLLEXPORT jl_value_t *jl_parse_all(const char *text, size_t text_len,\n                                      const char *filename, size_t filename_len);\nJL_DLLEXPORT jl_value_t *jl_parse_string(const char *text, size_t text_len,\n                                         int offset, int greedy);\n// lowering\nJL_DLLEXPORT jl_value_t *jl_expand(jl_value_t *expr, jl_module_t *inmodule);\nJL_DLLEXPORT jl_value_t *jl_expand_with_loc(jl_value_t *expr, jl_module_t *inmodule,\n                                            const char *file, int line);\nJL_DLLEXPORT jl_value_t *jl_expand_with_loc_warn(jl_value_t *expr, jl_module_t *inmodule,\n                                                 const char *file, int line);\nJL_DLLEXPORT jl_value_t *jl_expand_in_world(jl_value_t *expr, jl_module_t *inmodule,\n                                            const char *file, int line, size_t world);\nJL_DLLEXPORT jl_value_t *jl_expand_stmt(jl_value_t *expr, jl_module_t *inmodule);\nJL_DLLEXPORT jl_value_t *jl_expand_stmt_with_loc(jl_value_t *expr, jl_module_t *inmodule,\n                                                 const char *file, int line);\n// deprecated; use jl_parse_all\nJL_DLLEXPORT jl_value_t *jl_parse_input_line(const char *text, size_t text_len,\n                                             const char *filename, size_t filename_len);\n\n// external libraries\nenum JL_RTLD_CONSTANT {\n     JL_RTLD_LOCAL=1U,\n     JL_RTLD_GLOBAL=2U,\n     JL_RTLD_LAZY=4U,\n     JL_RTLD_NOW=8U,\n     /* Linux/glibc and MacOS X: */\n     JL_RTLD_NODELETE=16U,\n     JL_RTLD_NOLOAD=32U,\n     /* Linux/glibc: */\n     JL_RTLD_DEEPBIND=64U,\n     /* MacOS X 10.5+: */\n     JL_RTLD_FIRST=128U\n};\n#define JL_RTLD_DEFAULT (JL_RTLD_LAZY | JL_RTLD_DEEPBIND)\n\ntypedef void *jl_uv_libhandle; // compatible with dlopen (void*) / LoadLibrary (HMODULE)\nJL_DLLEXPORT jl_uv_libhandle jl_load_dynamic_library(const char *fname, unsigned flags, int throw_err) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_uv_libhandle jl_dlopen(const char *filename, unsigned flags) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_dlclose(jl_uv_libhandle handle) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_dlsym(jl_uv_libhandle handle, const char *symbol, void ** value, int throw_err) JL_NOTSAFEPOINT;\n\n// evaluation\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval(jl_module_t *m, jl_value_t *v);\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval_in(jl_module_t *m, jl_value_t *ex);\n// code loading (parsing + evaluation)\nJL_DLLEXPORT jl_value_t *jl_eval_string(const char *str); // embedding interface\nJL_DLLEXPORT jl_value_t *jl_load_file_string(const char *text, size_t len,\n                                             char *filename, jl_module_t *module);\nJL_DLLEXPORT jl_value_t *jl_load(jl_module_t *module, const char *fname);\n\nJL_DLLEXPORT jl_module_t *jl_base_relative_to(jl_module_t *m JL_PROPAGATES_ROOT);\n\n// tracing\nJL_DLLEXPORT void jl_register_newmeth_tracer(void (*callback)(jl_method_t *tracee));\n\n// AST access\nJL_DLLEXPORT jl_value_t *jl_copy_ast(jl_value_t *expr JL_MAYBE_UNROOTED);\n\n// IR representation\nJL_DLLEXPORT jl_array_t *jl_compress_ir(jl_method_t *m, jl_code_info_t *code);\nJL_DLLEXPORT jl_code_info_t *jl_uncompress_ir(jl_method_t *m, jl_code_instance_t *metadata, jl_array_t *data);\nJL_DLLEXPORT uint8_t jl_ir_flag_inferred(jl_array_t *data) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t jl_ir_flag_inlineable(jl_array_t *data) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t jl_ir_flag_pure(jl_array_t *data) JL_NOTSAFEPOINT;\nJL_DLLEXPORT ssize_t jl_ir_nslots(jl_array_t *data) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t jl_ir_slotflag(jl_array_t *data, size_t i) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_compress_argnames(jl_array_t *syms);\nJL_DLLEXPORT jl_array_t *jl_uncompress_argnames(jl_value_t *syms);\nJL_DLLEXPORT jl_value_t *jl_uncompress_argname_n(jl_value_t *syms, size_t i);\n\nJL_DLLEXPORT int jl_is_operator(char *sym);\nJL_DLLEXPORT int jl_is_unary_operator(char *sym);\nJL_DLLEXPORT int jl_is_unary_and_binary_operator(char *sym);\nJL_DLLEXPORT int jl_is_syntactic_operator(char *sym);\nJL_DLLEXPORT int jl_operator_precedence(char *sym);\n\nSTATIC_INLINE int jl_vinfo_sa(uint8_t vi)\n{\n    return (vi&16)!=0;\n}\n\nSTATIC_INLINE int jl_vinfo_usedundef(uint8_t vi)\n{\n    return (vi&32)!=0;\n}\n\n// calling into julia ---------------------------------------------------------\n\nJL_DLLEXPORT jl_value_t *jl_apply_generic(jl_value_t *F, jl_value_t **args, uint32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_invoke(jl_value_t *F, jl_value_t **args, uint32_t nargs, jl_method_instance_t *meth);\nJL_DLLEXPORT int32_t jl_invoke_api(jl_code_instance_t *linfo);\n\nSTATIC_INLINE jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)\n{\n    return jl_apply_generic(args[0], &args[1], nargs - 1);\n}\n\nJL_DLLEXPORT jl_value_t *jl_call(jl_function_t *f JL_MAYBE_UNROOTED, jl_value_t **args, int32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_call0(jl_function_t *f JL_MAYBE_UNROOTED);\nJL_DLLEXPORT jl_value_t *jl_call1(jl_function_t *f JL_MAYBE_UNROOTED, jl_value_t *a JL_MAYBE_UNROOTED);\nJL_DLLEXPORT jl_value_t *jl_call2(jl_function_t *f JL_MAYBE_UNROOTED, jl_value_t *a JL_MAYBE_UNROOTED, jl_value_t *b JL_MAYBE_UNROOTED);\nJL_DLLEXPORT jl_value_t *jl_call3(jl_function_t *f JL_MAYBE_UNROOTED, jl_value_t *a JL_MAYBE_UNROOTED,\n                                  jl_value_t *b JL_MAYBE_UNROOTED, jl_value_t *c JL_MAYBE_UNROOTED);\n\n// interfacing with Task runtime\nJL_DLLEXPORT void jl_yield(void);\n\n// async signal handling ------------------------------------------------------\n\nJL_DLLEXPORT void jl_install_sigint_handler(void);\nJL_DLLEXPORT void jl_sigatomic_begin(void);\nJL_DLLEXPORT void jl_sigatomic_end(void);\n\n// tasks and exceptions -------------------------------------------------------\n\ntypedef struct _jl_timing_block_t jl_timing_block_t;\ntypedef struct _jl_excstack_t jl_excstack_t;\n\n// info describing an exception handler\ntypedef struct _jl_handler_t {\n    jl_jmp_buf eh_ctx;\n    jl_gcframe_t *gcstack;\n    struct _jl_handler_t *prev;\n    int8_t gc_state;\n    size_t locks_len;\n    sig_atomic_t defer_signal;\n    jl_timing_block_t *timing_stack;\n    size_t world_age;\n} jl_handler_t;\n\ntypedef struct _jl_task_t {\n    JL_DATA_TYPE\n    jl_value_t *next; // invasive linked list for scheduler\n    jl_value_t *queue; // invasive linked list for scheduler\n    jl_value_t *tls;\n    jl_value_t *donenotify;\n    jl_value_t *result;\n    jl_value_t *logstate;\n    jl_function_t *start;\n    uint8_t _state;\n    uint8_t sticky; // record whether this Task can be migrated to a new thread\n    uint8_t _isexception; // set if `result` is an exception to throw or that we exited with\n\n// hidden state:\n    // id of owning thread - does not need to be defined until the task runs\n    int16_t tid;\n    // multiqueue priority\n    int16_t prio;\n    // saved exception stack\n    jl_excstack_t *excstack;\n    // current exception handler\n    jl_handler_t *eh;\n\n    union {\n        jl_ucontext_t ctx; // saved thread state\n#ifdef _OS_WINDOWS_\n        jl_ucontext_t copy_stack_ctx;\n#else\n        struct jl_stack_context_t copy_stack_ctx;\n#endif\n    };\n#if defined(JL_TSAN_ENABLED)\n    void *tsan_state;\n#endif\n    void *stkbuf; // malloc'd memory (either copybuf or stack)\n    size_t bufsz; // actual sizeof stkbuf\n    unsigned int copy_stack:31; // sizeof stack for copybuf\n    unsigned int started:1;\n\n    // saved gc stack top for context switches\n    jl_gcframe_t *gcstack;\n} jl_task_t;\n\n#define JL_TASK_STATE_RUNNABLE 0\n#define JL_TASK_STATE_DONE     1\n#define JL_TASK_STATE_FAILED   2\n\nJL_DLLEXPORT jl_task_t *jl_new_task(jl_function_t*, jl_value_t*, size_t);\nJL_DLLEXPORT void jl_switchto(jl_task_t **pt);\nJL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow(void);\nJL_DLLEXPORT void JL_NORETURN jl_sig_throw(void);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow_other(jl_value_t *e JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_no_exc_handler(jl_value_t *e);\n\n#include \"locks.h\"   // requires jl_task_t definition\n\nJL_DLLEXPORT void jl_enter_handler(jl_handler_t *eh);\nJL_DLLEXPORT void jl_eh_restore_state(jl_handler_t *eh);\nJL_DLLEXPORT void jl_pop_handler(int n);\nJL_DLLEXPORT size_t jl_excstack_state(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_restore_excstack(size_t state) JL_NOTSAFEPOINT;\n\n#if defined(_OS_WINDOWS_)\n#if defined(_COMPILER_GCC_)\nint __attribute__ ((__nothrow__,__returns_twice__)) (jl_setjmp)(jmp_buf _Buf);\n__declspec(noreturn) __attribute__ ((__nothrow__)) void (jl_longjmp)(jmp_buf _Buf, int _Value);\n#else\nint (jl_setjmp)(jmp_buf _Buf);\nvoid (jl_longjmp)(jmp_buf _Buf, int _Value);\n#endif\n#define jl_setjmp_f jl_setjmp\n#define jl_setjmp_name \"jl_setjmp\"\n#define jl_setjmp(a,b) jl_setjmp(a)\n#define jl_longjmp(a,b) jl_longjmp(a,b)\n#elif defined(_OS_EMSCRIPTEN_)\n#define jl_setjmp(a,b) setjmp(a)\n#define jl_longjmp(a,b) longjmp(a,b)\n#define jl_setjmp_f    setjmp\n#define jl_setjmp_name \"setjmp\"\n#else\n// determine actual entry point name\n#if defined(sigsetjmp)\n#define jl_setjmp_f    __sigsetjmp\n#define jl_setjmp_name \"__sigsetjmp\"\n#else\n#define jl_setjmp_f    sigsetjmp\n#define jl_setjmp_name \"sigsetjmp\"\n#endif\n#define jl_setjmp(a,b) sigsetjmp(a,b)\n#define jl_longjmp(a,b) siglongjmp(a,b)\n#endif\n\n\n#ifdef __clang_analyzer__\n\n// This is hard. Ideally we'd teach the static analyzer about the extra control\n// flow edges. But for now, just hide this as best we can\nextern int had_exception;\n#define JL_TRY if (1)\n#define JL_CATCH if (had_exception)\n\n#else\n\n#define JL_TRY                                                    \\\n    int i__tr, i__ca; jl_handler_t __eh;                          \\\n    size_t __excstack_state = jl_excstack_state();                \\\n    jl_enter_handler(&__eh);                                      \\\n    if (!jl_setjmp(__eh.eh_ctx,0))                                \\\n        for (i__tr=1; i__tr; i__tr=0, jl_eh_restore_state(&__eh))\n\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0, jl_restore_excstack(__excstack_state))\n\n#endif\n\n// I/O system -----------------------------------------------------------------\n\n#define JL_STREAM uv_stream_t\n#define JL_STDOUT jl_uv_stdout\n#define JL_STDERR jl_uv_stderr\n#define JL_STDIN  jl_uv_stdin\n\nJL_DLLEXPORT int jl_process_events(void);\n\nJL_DLLEXPORT uv_loop_t *jl_global_event_loop(void);\n\nJL_DLLEXPORT void jl_close_uv(uv_handle_t *handle);\n\nJL_DLLEXPORT jl_array_t *jl_take_buffer(ios_t *s);\n\ntypedef struct {\n    void *data;\n    uv_loop_t *loop;\n    uv_handle_type type;\n    uv_os_fd_t file;\n} jl_uv_file_t;\n\n#ifdef __GNUC__\n#define _JL_FORMAT_ATTR(type, str, arg) \\\n    __attribute__((format(type, str, arg)))\n#else\n#define _JL_FORMAT_ATTR(type, str, arg)\n#endif\n\nJL_DLLEXPORT void jl_uv_puts(uv_stream_t *stream, const char *str, size_t n);\nJL_DLLEXPORT int jl_printf(uv_stream_t *s, const char *format, ...)\n    _JL_FORMAT_ATTR(printf, 2, 3);\nJL_DLLEXPORT int jl_vprintf(uv_stream_t *s, const char *format, va_list args)\n    _JL_FORMAT_ATTR(printf, 2, 0);\nJL_DLLEXPORT void jl_safe_printf(const char *str, ...) JL_NOTSAFEPOINT\n    _JL_FORMAT_ATTR(printf, 1, 2);\n\nextern JL_DLLEXPORT JL_STREAM *JL_STDIN;\nextern JL_DLLEXPORT JL_STREAM *JL_STDOUT;\nextern JL_DLLEXPORT JL_STREAM *JL_STDERR;\n\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void);\n\n// showing and std streams\nJL_DLLEXPORT void jl_flush_cstdio(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_stdout_obj(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_stderr_obj(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT size_t jl_static_show(JL_STREAM *out, jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT size_t jl_static_show_func_sig(JL_STREAM *s, jl_value_t *type) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jlbacktrace(void) JL_NOTSAFEPOINT;\n// Mainly for debugging, use `void*` so that no type cast is needed in C++.\nJL_DLLEXPORT void jl_(void *jl_value) JL_NOTSAFEPOINT;\n\n// julia options -----------------------------------------------------------\n// NOTE: This struct needs to be kept in sync with JLOptions type in base/options.jl\ntypedef struct {\n    int8_t quiet;\n    int8_t banner;\n    const char *julia_bindir;\n    const char *julia_bin;\n    const char **cmds;\n    const char *image_file;\n    const char *cpu_target;\n    int32_t nthreads;\n    int32_t nprocs;\n    const char *machine_file;\n    const char *project;\n    int8_t isinteractive;\n    int8_t color;\n    int8_t historyfile;\n    int8_t startupfile;\n    int8_t compile_enabled;\n    int8_t code_coverage;\n    int8_t malloc_log;\n    int8_t opt_level;\n    int8_t debug_level;\n    int8_t check_bounds;\n    int8_t depwarn;\n    int8_t warn_overwrite;\n    int8_t can_inline;\n    int8_t polly;\n    const char *trace_compile;\n    int8_t fast_math;\n    int8_t worker;\n    const char *cookie;\n    int8_t handle_signals;\n    int8_t use_sysimage_native_code;\n    int8_t use_compiled_modules;\n    const char *bindto;\n    const char *outputbc;\n    const char *outputunoptbc;\n    const char *outputo;\n    const char *outputasm;\n    const char *outputji;\n    const char *output_code_coverage;\n    int8_t incremental;\n    int8_t image_file_specified;\n    int8_t warn_scope;\n    int8_t image_codegen;\n    int8_t rr_detach;\n} jl_options_t;\n\nextern JL_DLLEXPORT jl_options_t jl_options;\nJL_DLLEXPORT ssize_t jl_sizeof_jl_options(void);\n\n// Parse an argc/argv pair to extract general julia options, passing back out\n// any arguments that should be passed on to the script.\nJL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp);\nJL_DLLEXPORT char *jl_format_filename(const char *output_pattern);\n\n// Set julia-level ARGS array according to the arguments provided in\n// argc/argv\nJL_DLLEXPORT void jl_set_ARGS(int argc, char **argv);\n\nJL_DLLEXPORT int jl_generating_output(void) JL_NOTSAFEPOINT;\n\n// Settings for code_coverage and malloc_log\n// NOTE: if these numbers change, test/cmdlineargs.jl will have to be updated\n#define JL_LOG_NONE 0\n#define JL_LOG_USER 1\n#define JL_LOG_ALL  2\n\n#define JL_OPTIONS_CHECK_BOUNDS_DEFAULT 0\n#define JL_OPTIONS_CHECK_BOUNDS_ON 1\n#define JL_OPTIONS_CHECK_BOUNDS_OFF 2\n\n#define JL_OPTIONS_COMPILE_DEFAULT 1\n#define JL_OPTIONS_COMPILE_OFF 0\n#define JL_OPTIONS_COMPILE_ON  1\n#define JL_OPTIONS_COMPILE_ALL 2\n#define JL_OPTIONS_COMPILE_MIN 3\n\n#define JL_OPTIONS_COLOR_AUTO 0\n#define JL_OPTIONS_COLOR_ON 1\n#define JL_OPTIONS_COLOR_OFF 2\n\n#define JL_OPTIONS_HISTORYFILE_ON 1\n#define JL_OPTIONS_HISTORYFILE_OFF 0\n\n#define JL_OPTIONS_STARTUPFILE_ON 1\n#define JL_OPTIONS_STARTUPFILE_OFF 2\n\n#define JL_LOGLEVEL_BELOWMIN -1000001\n#define JL_LOGLEVEL_DEBUG    -1000\n#define JL_LOGLEVEL_INFO      0\n#define JL_LOGLEVEL_WARN      1000\n#define JL_LOGLEVEL_ERROR     2000\n#define JL_LOGLEVEL_ABOVEMAX  1000001\n\n#define JL_OPTIONS_DEPWARN_OFF 0\n#define JL_OPTIONS_DEPWARN_ON 1\n#define JL_OPTIONS_DEPWARN_ERROR 2\n\n#define JL_OPTIONS_WARN_OVERWRITE_OFF 0\n#define JL_OPTIONS_WARN_OVERWRITE_ON 1\n\n#define JL_OPTIONS_WARN_SCOPE_OFF 0\n#define JL_OPTIONS_WARN_SCOPE_ON 1\n\n#define JL_OPTIONS_POLLY_ON 1\n#define JL_OPTIONS_POLLY_OFF 0\n\n#define JL_OPTIONS_FAST_MATH_ON 1\n#define JL_OPTIONS_FAST_MATH_OFF 2\n#define JL_OPTIONS_FAST_MATH_DEFAULT 0\n\n#define JL_OPTIONS_HANDLE_SIGNALS_ON 1\n#define JL_OPTIONS_HANDLE_SIGNALS_OFF 0\n\n#define JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_YES 1\n#define JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_NO 0\n\n#define JL_OPTIONS_USE_COMPILED_MODULES_YES 1\n#define JL_OPTIONS_USE_COMPILED_MODULES_NO 0\n\n// Version information\n#include \"julia_version.h\"\n\nJL_DLLEXPORT extern int jl_ver_major(void);\nJL_DLLEXPORT extern int jl_ver_minor(void);\nJL_DLLEXPORT extern int jl_ver_patch(void);\nJL_DLLEXPORT extern int jl_ver_is_release(void);\nJL_DLLEXPORT extern const char *jl_ver_string(void);\nJL_DLLEXPORT const char *jl_git_branch(void);\nJL_DLLEXPORT const char *jl_git_commit(void);\n\n// nullable struct representations\ntypedef struct {\n    uint8_t hasvalue;\n    double value;\n} jl_nullable_float64_t;\n\ntypedef struct {\n    uint8_t hasvalue;\n    float value;\n} jl_nullable_float32_t;\n\n#define jl_current_task (jl_get_ptls_states()->current_task)\n#define jl_root_task (jl_get_ptls_states()->root_task)\n\nJL_DLLEXPORT jl_value_t *jl_get_current_task(void);\n\nJL_DLLEXPORT jl_jmp_buf *jl_get_safe_restore(void);\nJL_DLLEXPORT void jl_set_safe_restore(jl_jmp_buf *);\n\n// codegen interface ----------------------------------------------------------\n// The root propagation here doesn't have to be literal, but callers should\n// ensure that the return value outlives the MethodInstance\ntypedef jl_value_t *(*jl_codeinstance_lookup_t)(jl_method_instance_t *mi JL_PROPAGATES_ROOT,\n    size_t min_world, size_t max_world);\ntypedef struct {\n    int track_allocations;  // can we track allocations?\n    int code_coverage;      // can we measure coverage?\n    int prefer_specsig;     // are specialized function signatures preferred?\n\n    // controls the emission of debug-info. mirrors the clang options\n    int gnu_pubnames;       // can we emit the gnu pubnames debuginfo\n    int debug_info_kind; // Enum for line-table-only, line-directives-only,\n                            // limited, standalone\n\n    // Cache access. Default: jl_rettype_inferred.\n    jl_codeinstance_lookup_t lookup;\n\n    // If not `nothing`, rewrite all generic calls to call\n    // generic_context(f, args...) instead of f(args...).\n    jl_value_t *generic_context;\n} jl_cgparams_t;\nextern JL_DLLEXPORT jl_cgparams_t jl_default_cgparams;\nextern JL_DLLEXPORT int jl_default_debug_info_kind;\n\n#if !defined(_OS_DARWIN_) && !defined(_OS_WINDOWS_)\n#define JULIA_DEFINE_FAST_TLS()                                                             \\\nJL_DLLEXPORT JL_CONST_FUNC jl_ptls_t jl_get_ptls_states_static(void)                        \\\n{                                                                                           \\\n    static __attribute__((tls_model(\"local-exec\"))) __thread jl_tls_states_t tls_states;    \\\n    return &tls_states;                                                                     \\\n}                                                                                           \\\n__attribute__((constructor)) void jl_register_ptls_states_getter(void)                      \\\n{                                                                                           \\\n    /* We need to make sure this function is called before any reference to */              \\\n    /* TLS variables. */                                                                    \\\n    jl_set_ptls_states_getter(jl_get_ptls_states_static);                                   \\\n}\n#else\n#define JULIA_DEFINE_FAST_TLS()\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/processor_arm.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// ARM (AArch32/AArch64) specific processor detection and dispatch\n\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <set>\n#include <fstream>\n#include <algorithm>\n\n// This nesting is required to allow compilation on musl\n#define USE_DYN_GETAUXVAL\n#if defined(_OS_LINUX_) && defined(_CPU_AARCH64_)\n#  undef USE_DYN_GETAUXVAL\n#  include <sys/auxv.h>\n#elif defined(__GLIBC_PREREQ)\n#  if __GLIBC_PREREQ(2, 16)\n#    undef USE_DYN_GETAUXVAL\n#    include <sys/auxv.h>\n#  endif\n#endif\n\nnamespace ARM {\nenum class CPU : uint32_t {\n    generic = 0,\n\n    // Architecture targets\n    armv7_a,\n    armv7_m,\n    armv7e_m,\n    armv7_r,\n    armv8_a,\n    armv8_m_base,\n    armv8_m_main,\n    armv8_r,\n    armv8_1_a,\n    armv8_2_a,\n    armv8_3_a,\n    armv8_4_a,\n    armv8_5_a,\n    armv8_6_a,\n\n    // ARM\n    // armv6l\n    arm_mpcore,\n    arm_1136jf_s,\n    arm_1156t2f_s,\n    arm_1176jzf_s,\n    arm_cortex_m0,\n    arm_cortex_m1,\n    // armv7ml\n    arm_cortex_m3,\n    arm_cortex_m4,\n    arm_cortex_m7,\n    // armv7l\n    arm_cortex_a5,\n    arm_cortex_a7,\n    arm_cortex_a8,\n    arm_cortex_a9,\n    arm_cortex_a12,\n    arm_cortex_a15,\n    arm_cortex_a17,\n    arm_cortex_r4,\n    arm_cortex_r5,\n    arm_cortex_r7,\n    arm_cortex_r8,\n    // armv8ml\n    arm_cortex_m23,\n    arm_cortex_m33,\n    // armv8l\n    arm_cortex_a32,\n    arm_cortex_r52,\n    // aarch64\n    arm_cortex_a34,\n    arm_cortex_a35,\n    arm_cortex_a53,\n    arm_cortex_a55,\n    arm_cortex_a57,\n    arm_cortex_a65,\n    arm_cortex_a65ae,\n    arm_cortex_a72,\n    arm_cortex_a73,\n    arm_cortex_a75,\n    arm_cortex_a76,\n    arm_cortex_a76ae,\n    arm_cortex_a77,\n    arm_cortex_a78,\n    arm_cortex_x1,\n    arm_neoverse_e1,\n    arm_neoverse_n1,\n    arm_neoverse_v1,\n    arm_neoverse_n2,\n\n    // Cavium\n    // aarch64\n    cavium_thunderx,\n    cavium_thunderx88,\n    cavium_thunderx88p1,\n    cavium_thunderx81,\n    cavium_thunderx83,\n    cavium_thunderx2t99,\n    cavium_thunderx2t99p1,\n    cavium_octeontx2,\n    cavium_octeontx2t98,\n    cavium_octeontx2t96,\n    cavium_octeontx2f95,\n    cavium_octeontx2f95n,\n    cavium_octeontx2f95mm,\n\n    // Fujitsu\n    // aarch64\n    fujitsu_a64fx,\n\n    // HiSilicon\n    // aarch64\n    hisilicon_tsv110,\n\n    // Huaxingtong\n    // aarch64\n    hxt_phecda,\n\n    // NVIDIA\n    // aarch64\n    nvidia_denver1,\n    nvidia_denver2,\n    nvidia_carmel,\n\n    // AppliedMicro\n    // aarch64\n    apm_xgene1,\n    apm_xgene2,\n    apm_xgene3,\n\n    // Qualcomm\n    // armv7l\n    qualcomm_scorpion,\n    qualcomm_krait,\n    // aarch64\n    qualcomm_kyro,\n    qualcomm_falkor,\n    qualcomm_saphira,\n\n    // Samsung\n    // aarch64\n    samsung_exynos_m1,\n    samsung_exynos_m2,\n    samsung_exynos_m3,\n    samsung_exynos_m4,\n    samsung_exynos_m5,\n\n    // Apple\n    // armv7l\n    apple_swift,\n    // aarch64\n    apple_a7, // cyclone\n    apple_a8, // typhoon\n    apple_a9, // twister\n    apple_a10, // hurricane\n    apple_a11,\n    apple_a12,\n    apple_a13,\n    apple_s4,\n    apple_s5,\n\n    // Marvell\n    // armv7l\n    marvell_pj4,\n    // aarch64\n    marvell_thunderx3t110,\n\n    // Intel\n    // armv7l\n    intel_3735d,\n};\n\n#ifdef _CPU_AARCH64_\nstatic constexpr size_t feature_sz = 3;\nstatic constexpr FeatureName feature_names[] = {\n#define JL_FEATURE_DEF(name, bit, llvmver) {#name, bit, llvmver},\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) {str, bit, llvmver},\n#include \"features_aarch64.h\"\n#undef JL_FEATURE_DEF\n#undef JL_FEATURE_DEF_NAME\n};\nstatic constexpr uint32_t nfeature_names = sizeof(feature_names) / sizeof(FeatureName);\n\ntemplate<typename... Args>\nstatic inline constexpr FeatureList<feature_sz> get_feature_masks(Args... args)\n{\n    return ::get_feature_masks<feature_sz>(args...);\n}\n\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) JL_FEATURE_DEF(name, bit, llvmver)\nstatic constexpr auto feature_masks = get_feature_masks(\n#define JL_FEATURE_DEF(name, bit, llvmver) bit,\n#include \"features_aarch64.h\"\n#undef JL_FEATURE_DEF\n    -1);\nstatic const auto real_feature_masks =\n    feature_masks & FeatureList<feature_sz>{{(uint32_t)-1, (uint32_t)-1, 0}};\n\nnamespace Feature {\nenum : uint32_t {\n#define JL_FEATURE_DEF(name, bit, llvmver) name = bit,\n#include \"features_aarch64.h\"\n#undef JL_FEATURE_DEF\n};\n#undef JL_FEATURE_DEF_NAME\n// This does not cover all dependencies (e.g. the ones that depends on arm versions)\nstatic constexpr FeatureDep deps[] = {\n    {rcpc_immo, rcpc},\n    {sha3, sha2},\n    // {sha512, sha3},\n    {ccdp, ccpp},\n    {sve, fullfp16},\n    {fp16fml, fullfp16},\n    {altnzcv, fmi},\n    {sve2, sve},\n    {sve2_aes, sve2},\n    {sve2_aes, aes},\n    {sve2_bitperm, sve2},\n    {sve2_sha3, sve2},\n    {sve2_sha3, sha3},\n    {sve2_sm4, sve2},\n    {sve2_sm4, sm4},\n    {f32mm, sve},\n    {f64mm, sve},\n};\n\nconstexpr auto generic = get_feature_masks();\nconstexpr auto armv8a_crc = get_feature_masks(crc);\nconstexpr auto armv8a_crc_crypto = armv8a_crc | get_feature_masks(aes, sha2);\nconstexpr auto armv8_1a = armv8a_crc | get_feature_masks(v8_1a, lse, rdm); // lor\nconstexpr auto armv8_1a_crypto = armv8_1a | get_feature_masks(aes, sha2);\nconstexpr auto armv8_2a = armv8_1a | get_feature_masks(v8_2a, ccpp);\nconstexpr auto armv8_2a_crypto = armv8_2a | get_feature_masks(aes, sha2);\nconstexpr auto armv8_3a = armv8_2a | get_feature_masks(v8_3a, jsconv, complxnum, rcpc);\nconstexpr auto armv8_3a_crypto = armv8_3a | get_feature_masks(aes, sha2);\nconstexpr auto armv8_4a = armv8_3a | get_feature_masks(v8_4a, dit, rcpc_immo, fmi);\nconstexpr auto armv8_4a_crypto = armv8_4a | get_feature_masks(aes, sha2);\nconstexpr auto armv8_5a = armv8_4a | get_feature_masks(v8_5a, sb, ccdp, altnzcv, fptoint);\nconstexpr auto armv8_6a = armv8_5a | get_feature_masks(v8_6a, i8mm, bf16);\n\n// For ARM cores, the features required can be found in the technical reference manual\n// The relevant register values and the features they are related to are:\n// ID_AA64ISAR0_EL1:\n//     .AES: aes, pmull\n//     .SHA1: sha1\n//     .SHA2: sha2, sha512\n//     .CRC32: crc\n//     .Atomic: les\n//     .RDM: rdm\n//     .SHA3: sha3\n//     .SM3: sm3 (sm4)\n//     .SM4: sm4\n//     .DP: dotprod\n//     .FHM: fp16fml\n//     .TS: fmi, altnzcz\n//     .RNDR: rand\n\n// ID_AA64ISAR1_EL1\n//     .JSCVT: jsconv\n//     .FCMA: complxnum\n//     .LRCPC: rcpc, rcpc_immo\n//     .DPB: ccpp, ccdp\n//     .SB: sb\n//     .APA/.API: paca (pa)\n//     .GPA/.GPI: paga (pa)\n//     .FRINTTS: fptoint\n//     .I8MM: i8mm\n//     .BF16: bf16\n//     .DGH: dgh\n\n// ID_AA64PFR0_EL1\n//     .FP: fullfp16\n//     .SVE: sve\n//     .DIT: dit\n//     .BT: bti\n\n// ID_AA64PFR1_EL1\n//     .SSBS: ssbs\n//     .MTE: mte\n\n// ID_AA64MMFR2_EL1.AT: uscat\n\n// ID_AA64ZFR0_EL1\n//     .SVEVer: sve2\n//     .AES: sve2-aes, sve2-pmull\n//     .BitPerm: sve2-bitperm\n//     .SHA3: sve2-sha3\n//     .SM4: sve2-sm4\n//     .F32MM: f32mm\n//     .F64MM: f64mm\n\nconstexpr auto arm_cortex_a34 = armv8a_crc;\nconstexpr auto arm_cortex_a35 = armv8a_crc;\nconstexpr auto arm_cortex_a53 = armv8a_crc;\nconstexpr auto arm_cortex_a55 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs);\nconstexpr auto arm_cortex_a57 = armv8a_crc;\nconstexpr auto arm_cortex_a65 = armv8_2a | get_feature_masks(rcpc, fullfp16, ssbs);\nconstexpr auto arm_cortex_a72 = armv8a_crc;\nconstexpr auto arm_cortex_a73 = armv8a_crc;\nconstexpr auto arm_cortex_a75 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16);\nconstexpr auto arm_cortex_a76 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs);\nconstexpr auto arm_cortex_a77 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs);\nconstexpr auto arm_cortex_a78 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs); // spe\nconstexpr auto arm_cortex_x1 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs); // spe\nconstexpr auto arm_neoverse_e1 = armv8_2a | get_feature_masks(rcpc, fullfp16, ssbs);\nconstexpr auto arm_neoverse_n1 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs);\nconstexpr auto arm_neoverse_v1 = armv8_4a | get_feature_masks(sve, i8mm, bf16, fullfp16, ssbs, rand);\nconstexpr auto arm_neoverse_n2 = armv8_5a | get_feature_masks(sve, i8mm, bf16, fullfp16, sve2,\n                                                              sve2_bitperm, rand, mte);\nconstexpr auto cavium_thunderx = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx88 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx88p1 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx81 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx83 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx2t99 = armv8_1a_crypto;\nconstexpr auto cavium_thunderx2t99p1 = cavium_thunderx2t99;\nconstexpr auto cavium_octeontx2 = armv8_2a_crypto;\nconstexpr auto fujitsu_a64fx = armv8_2a | get_feature_masks(sha2, fullfp16, sve, complxnum);\nconstexpr auto hisilicon_tsv110 = armv8_2a_crypto | get_feature_masks(dotprod, fullfp16);\nconstexpr auto hxt_phecda = armv8a_crc_crypto;\nconstexpr auto marvell_thunderx3t110 = armv8_3a_crypto;\nconstexpr auto nvidia_denver1 = generic; // TODO? (crc, crypto)\nconstexpr auto nvidia_denver2 = armv8a_crc_crypto;\nconstexpr auto nvidia_carmel = armv8_2a_crypto | get_feature_masks(fullfp16);\nconstexpr auto apm_xgene1 = generic;\nconstexpr auto apm_xgene2 = generic; // TODO?\nconstexpr auto apm_xgene3 = generic; // TODO?\nconstexpr auto qualcomm_kyro = armv8a_crc_crypto;\nconstexpr auto qualcomm_falkor = armv8a_crc_crypto | get_feature_masks(rdm);\nconstexpr auto qualcomm_saphira = armv8_4a_crypto;\nconstexpr auto samsung_exynos_m1 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m2 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m3 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m4 = armv8_2a_crypto | get_feature_masks(dotprod, fullfp16);\nconstexpr auto samsung_exynos_m5 = samsung_exynos_m4;\nconstexpr auto apple_a7 = armv8a_crc_crypto;\nconstexpr auto apple_a10 = armv8a_crc_crypto | get_feature_masks(rdm);\nconstexpr auto apple_a11 = armv8_2a_crypto | get_feature_masks(fullfp16);\nconstexpr auto apple_a12 = armv8_3a_crypto | get_feature_masks(fullfp16);\nconstexpr auto apple_a13 = armv8_4a_crypto | get_feature_masks(fp16fml, fullfp16, sha3);\nconstexpr auto apple_s4 = apple_a12;\nconstexpr auto apple_s5 = apple_a12;\n\n}\n\nstatic constexpr CPUSpec<CPU, feature_sz> cpus[] = {\n    {\"generic\", CPU::generic, CPU::generic, 0, Feature::generic},\n    {\"armv8.1-a\", CPU::armv8_1_a, CPU::generic, 0, Feature::armv8_1a},\n    {\"armv8.2-a\", CPU::armv8_2_a, CPU::generic, 0, Feature::armv8_2a},\n    {\"armv8.3_a\", CPU::armv8_3_a, CPU::generic, 0, Feature::armv8_3a},\n    {\"armv8.4-a\", CPU::armv8_4_a, CPU::generic, 0, Feature::armv8_4a},\n    {\"armv8.5-a\", CPU::armv8_5_a, CPU::generic, 0, Feature::armv8_5a},\n    {\"armv8.6_a\", CPU::armv8_6_a, CPU::generic, 0, Feature::armv8_6a},\n    {\"cortex-a34\", CPU::arm_cortex_a34, CPU::arm_cortex_a35, 110000, Feature::arm_cortex_a34},\n    {\"cortex-a35\", CPU::arm_cortex_a35, CPU::generic, 0, Feature::arm_cortex_a35},\n    {\"cortex-a53\", CPU::arm_cortex_a53, CPU::generic, 0, Feature::arm_cortex_a53},\n    {\"cortex-a55\", CPU::arm_cortex_a55, CPU::generic, 0, Feature::arm_cortex_a55},\n    {\"cortex-a57\", CPU::arm_cortex_a57, CPU::generic, 0, Feature::arm_cortex_a57},\n    {\"cortex-a65\", CPU::arm_cortex_a65, CPU::arm_cortex_a75, 100000, Feature::arm_cortex_a65},\n    {\"cortex-a65ae\", CPU::arm_cortex_a65ae, CPU::arm_cortex_a75, 100000, Feature::arm_cortex_a65},\n    {\"cortex-a72\", CPU::arm_cortex_a72, CPU::generic, 0, Feature::arm_cortex_a72},\n    {\"cortex-a73\", CPU::arm_cortex_a73, CPU::generic, 0, Feature::arm_cortex_a73},\n    {\"cortex-a75\", CPU::arm_cortex_a75, CPU::generic, 0, Feature::arm_cortex_a75},\n    {\"cortex-a76\", CPU::arm_cortex_a76, CPU::generic, 0, Feature::arm_cortex_a76},\n    {\"cortex-a76ae\", CPU::arm_cortex_a76ae, CPU::generic, 0, Feature::arm_cortex_a76},\n    {\"cortex-a77\", CPU::arm_cortex_a77, CPU::arm_cortex_a76, 110000, Feature::arm_cortex_a77},\n    {\"cortex-a78\", CPU::arm_cortex_a78, CPU::arm_cortex_a77, 110000, Feature::arm_cortex_a78},\n    {\"cortex-x1\", CPU::arm_cortex_x1, CPU::arm_cortex_a78, 110000, Feature::arm_cortex_x1},\n    {\"neoverse-e1\", CPU::arm_neoverse_e1, CPU::arm_cortex_a76, 100000, Feature::arm_neoverse_e1},\n    {\"neoverse-n1\", CPU::arm_neoverse_n1, CPU::arm_cortex_a76, 100000, Feature::arm_neoverse_n1},\n    {\"neoverse-v1\", CPU::arm_neoverse_v1, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_v1},\n    {\"neoverse-n2\", CPU::arm_neoverse_n2, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_n2},\n    {\"thunderx\", CPU::cavium_thunderx, CPU::generic, 0, Feature::cavium_thunderx},\n    {\"thunderxt88\", CPU::cavium_thunderx88, CPU::generic, 0, Feature::cavium_thunderx88},\n    {\"thunderxt88p1\", CPU::cavium_thunderx88p1, CPU::cavium_thunderx88, UINT32_MAX,\n     Feature::cavium_thunderx88p1},\n    {\"thunderxt81\", CPU::cavium_thunderx81, CPU::generic, 0, Feature::cavium_thunderx81},\n    {\"thunderxt83\", CPU::cavium_thunderx83, CPU::generic, 0, Feature::cavium_thunderx83},\n    {\"thunderx2t99\", CPU::cavium_thunderx2t99, CPU::generic, 0, Feature::cavium_thunderx2t99},\n    {\"thunderx2t99p1\", CPU::cavium_thunderx2t99p1, CPU::cavium_thunderx2t99, UINT32_MAX,\n     Feature::cavium_thunderx2t99p1},\n    {\"octeontx2\", CPU::cavium_octeontx2, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2t98\", CPU::cavium_octeontx2t98, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2t96\", CPU::cavium_octeontx2t96, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2f95\", CPU::cavium_octeontx2f95, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2f95n\", CPU::cavium_octeontx2f95n, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2f95mm\", CPU::cavium_octeontx2f95mm, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"a64fx\", CPU::fujitsu_a64fx, CPU::generic, 110000, Feature::fujitsu_a64fx},\n    {\"tsv110\", CPU::hisilicon_tsv110, CPU::generic, 0, Feature::hisilicon_tsv110},\n    {\"phecda\", CPU::hxt_phecda, CPU::qualcomm_falkor, UINT32_MAX, Feature::hxt_phecda},\n    {\"denver1\", CPU::nvidia_denver1, CPU::generic, UINT32_MAX, Feature::nvidia_denver1},\n    {\"denver2\", CPU::nvidia_denver2, CPU::generic, UINT32_MAX, Feature::nvidia_denver2},\n    {\"carmel\", CPU::nvidia_carmel, CPU::generic, 110000, Feature::nvidia_carmel},\n    {\"xgene1\", CPU::apm_xgene1, CPU::generic, UINT32_MAX, Feature::apm_xgene1},\n    {\"xgene2\", CPU::apm_xgene2, CPU::generic, UINT32_MAX, Feature::apm_xgene2},\n    {\"xgene3\", CPU::apm_xgene3, CPU::generic, UINT32_MAX, Feature::apm_xgene3},\n    {\"kyro\", CPU::qualcomm_kyro, CPU::generic, 0, Feature::qualcomm_kyro},\n    {\"falkor\", CPU::qualcomm_falkor, CPU::generic, 0, Feature::qualcomm_falkor},\n    {\"saphira\", CPU::qualcomm_saphira, CPU::generic, 0, Feature::qualcomm_saphira},\n    {\"exynos-m1\", CPU::samsung_exynos_m1, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m1},\n    {\"exynos-m2\", CPU::samsung_exynos_m2, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m2},\n    {\"exynos-m3\", CPU::samsung_exynos_m3, CPU::generic, 0, Feature::samsung_exynos_m3},\n    {\"exynos-m4\", CPU::samsung_exynos_m4, CPU::generic, 0, Feature::samsung_exynos_m4},\n    {\"exynos-m5\", CPU::samsung_exynos_m5, CPU::samsung_exynos_m4, 110000,\n     Feature::samsung_exynos_m5},\n    {\"apple-a7\", CPU::apple_a7, CPU::generic, 100000, Feature::apple_a7},\n    {\"apple-a8\", CPU::apple_a8, CPU::generic, 100000, Feature::apple_a7},\n    {\"apple-a9\", CPU::apple_a9, CPU::generic, 100000, Feature::apple_a7},\n    {\"apple-a10\", CPU::apple_a10, CPU::generic, 100000, Feature::apple_a10},\n    {\"apple-a11\", CPU::apple_a11, CPU::generic, 100000, Feature::apple_a11},\n    {\"apple-a12\", CPU::apple_a12, CPU::generic, 100000, Feature::apple_a12},\n    {\"apple-a13\", CPU::apple_a13, CPU::generic, 100000, Feature::apple_a13},\n    {\"apple-s4\", CPU::apple_s4, CPU::generic, 100000, Feature::apple_s4},\n    {\"apple-s5\", CPU::apple_s5, CPU::generic, 100000, Feature::apple_s5},\n    {\"thunderx3t110\", CPU::marvell_thunderx3t110, CPU::cavium_thunderx2t99, 110000,\n     Feature::marvell_thunderx3t110},\n};\n#else\nstatic constexpr size_t feature_sz = 3;\nstatic constexpr FeatureName feature_names[] = {\n#define JL_FEATURE_DEF(name, bit, llvmver) {#name, bit, llvmver},\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) {str, bit, llvmver},\n#include \"features_aarch32.h\"\n#undef JL_FEATURE_DEF\n#undef JL_FEATURE_DEF_NAME\n};\nstatic constexpr uint32_t nfeature_names = sizeof(feature_names) / sizeof(FeatureName);\n\ntemplate<typename... Args>\nstatic inline constexpr FeatureList<feature_sz> get_feature_masks(Args... args)\n{\n    return ::get_feature_masks<feature_sz>(args...);\n}\n\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) JL_FEATURE_DEF(name, bit, llvmver)\nstatic constexpr auto feature_masks = get_feature_masks(\n#define JL_FEATURE_DEF(name, bit, llvmver) bit,\n#include \"features_aarch32.h\"\n#undef JL_FEATURE_DEF\n    -1);\nstatic const auto real_feature_masks =\n    feature_masks & FeatureList<feature_sz>{{(uint32_t)-1, (uint32_t)-1, 0}};\n\nnamespace Feature {\nenum : uint32_t {\n#define JL_FEATURE_DEF(name, bit, llvmver) name = bit,\n#include \"features_aarch32.h\"\n#undef JL_FEATURE_DEF\n};\n#undef JL_FEATURE_DEF_NAME\n// This does not cover all dependencies (e.g. the ones that depends on arm versions)\nstatic constexpr FeatureDep deps[] = {\n    {neon, vfp3},\n    {vfp4, vfp3},\n    {crypto, neon},\n};\n\n// These are the real base requirements of the specific architectures\nconstexpr auto _armv7m = get_feature_masks(v7, mclass, hwdiv);\nconstexpr auto _armv7a = get_feature_masks(v7, aclass);\nconstexpr auto _armv7r = get_feature_masks(v7, rclass);\nconstexpr auto _armv8m = get_feature_masks(v7, v8, mclass, hwdiv);\nconstexpr auto _armv8a = get_feature_masks(v7, v8, aclass, neon, vfp3, vfp4, d32,\n                                           hwdiv, hwdiv_arm);\nconstexpr auto _armv8r = get_feature_masks(v7, v8, rclass, neon, vfp3, vfp4, d32,\n                                           hwdiv, hwdiv_arm);\n\n// Set `generic` to match the feature requirement of the `C` code.\n// we'll require at least these when compiling the sysimg.\n#if __ARM_ARCH >= 8\n#  if !defined(__ARM_ARCH_PROFILE)\nconstexpr auto generic = get_feature_masks(v7, v8, hwdiv);\n#  elif __ARM_ARCH_PROFILE == 'A'\nconstexpr auto generic = _armv8a;\n#  elif __ARM_ARCH_PROFILE == 'R'\nconstexpr auto generic = _armv8r;\n#  elif __ARM_ARCH_PROFILE == 'M'\nconstexpr auto generic = _armv8m;\n#  else\nconstexpr auto generic = get_feature_masks(v7, v8, hwdiv);\n#  endif\n#elif __ARM_ARCH == 7\n#  if !defined(__ARM_ARCH_PROFILE)\nconstexpr auto generic = get_feature_masks(v7);\n#  elif __ARM_ARCH_PROFILE == 'A'\nconstexpr auto generic = _armv7a;\n#  elif __ARM_ARCH_PROFILE == 'R'\nconstexpr auto generic = _armv7r;\n#  elif __ARM_ARCH_PROFILE == 'M'\nconstexpr auto generic = _armv7m;\n#  else\nconstexpr auto generic = get_feature_masks(v7);\n#  endif\n#else\nconstexpr auto generic = get_feature_masks();\n#endif\n\n// All feature sets below should use or be or'ed with one of these (or generic).\n// This makes sure that, for example, the `generic` target on `armv7-a` binary is equivalent\n// to the `armv7-a` target.\nconstexpr auto armv7m = generic | _armv7m;\nconstexpr auto armv7a = generic | _armv7a;\nconstexpr auto armv7r = generic | _armv7r;\nconstexpr auto armv8m = generic | _armv8m;\nconstexpr auto armv8a = generic | _armv8a;\nconstexpr auto armv8r = generic | _armv8r;\n\n// armv7l\nconstexpr auto arm_cortex_a5 = armv7a;\nconstexpr auto arm_cortex_a7 = armv7a | get_feature_masks(vfp3, vfp4, neon);\nconstexpr auto arm_cortex_a8 = armv7a | get_feature_masks(d32, vfp3, neon);\nconstexpr auto arm_cortex_a9 = armv7a;\nconstexpr auto arm_cortex_a12 = armv7a | get_feature_masks(d32, vfp3, vfp4, neon);\nconstexpr auto arm_cortex_a15 = armv7a | get_feature_masks(d32, vfp3, vfp4, neon);\nconstexpr auto arm_cortex_a17 = armv7a | get_feature_masks(d32, vfp3, vfp4, neon);\nconstexpr auto arm_cortex_r4 = armv7r | get_feature_masks(vfp3, hwdiv);\nconstexpr auto arm_cortex_r5 = armv7r | get_feature_masks(vfp3, hwdiv, hwdiv_arm);\nconstexpr auto arm_cortex_r7 = armv7r | get_feature_masks(vfp3, hwdiv, hwdiv_arm);\nconstexpr auto arm_cortex_r8 = armv7r | get_feature_masks(vfp3, hwdiv, hwdiv_arm);\nconstexpr auto qualcomm_scorpion = armv7a | get_feature_masks(v7, aclass, vfp3, neon);\nconstexpr auto qualcomm_krait = armv7a | get_feature_masks(vfp3, vfp4, neon, hwdiv, hwdiv_arm);\nconstexpr auto apple_swift = armv7a | get_feature_masks(d32, vfp3, vfp4, neon, hwdiv, hwdiv_arm);\nconstexpr auto marvell_pj4 = armv7a | get_feature_masks(vfp3);\nconstexpr auto intel_3735d = armv7a | get_feature_masks(vfp3, neon);\n// armv8ml\nconstexpr auto arm_cortex_m23 = armv8m; // unsupported\nconstexpr auto arm_cortex_m33 = armv8m | get_feature_masks(v8_m_main); // unsupported\n// armv8l\nconstexpr auto armv8a_crc = armv8a | get_feature_masks(crc);\nconstexpr auto armv8_1a = armv8a_crc | get_feature_masks(v8_1a);\nconstexpr auto armv8_2a = armv8_1a | get_feature_masks(v8_2a);\nconstexpr auto armv8a_crc_crypto = armv8a_crc | get_feature_masks(crypto);\nconstexpr auto armv8_2a_crypto = armv8_2a | get_feature_masks(crypto);\nconstexpr auto armv8_3a = armv8_2a | get_feature_masks(v8_3a);\nconstexpr auto armv8_3a_crypto = armv8_3a | get_feature_masks(crypto);\nconstexpr auto armv8_4a = armv8_3a | get_feature_masks(v8_4a);\nconstexpr auto armv8_4a_crypto = armv8_4a | get_feature_masks(crypto);\nconstexpr auto armv8_5a = armv8_4a | get_feature_masks(v8_5a);\nconstexpr auto armv8_5a_crypto = armv8_5a | get_feature_masks(crypto);\nconstexpr auto armv8_6a = armv8_5a | get_feature_masks(v8_6a);\nconstexpr auto armv8_6a_crypto = armv8_6a | get_feature_masks(crypto);\n\nconstexpr auto arm_cortex_a32 = armv8a_crc;\nconstexpr auto arm_cortex_r52 = armv8a_crc;\nconstexpr auto arm_cortex_a35 = armv8a_crc;\nconstexpr auto arm_cortex_a53 = armv8a_crc;\nconstexpr auto arm_cortex_a55 = armv8_2a;\nconstexpr auto arm_cortex_a57 = armv8a_crc;\nconstexpr auto arm_cortex_a72 = armv8a_crc;\nconstexpr auto arm_cortex_a73 = armv8a_crc;\nconstexpr auto arm_cortex_a75 = armv8_2a;\nconstexpr auto arm_cortex_a76 = armv8_2a;\nconstexpr auto arm_cortex_a77 = armv8_2a;\nconstexpr auto arm_cortex_a78 = armv8_2a;\nconstexpr auto arm_cortex_x1 = armv8_2a;\nconstexpr auto arm_neoverse_n1 = armv8_2a;\nconstexpr auto arm_neoverse_v1 = armv8_4a;\nconstexpr auto arm_neoverse_n2 = armv8_5a;\nconstexpr auto nvidia_denver1 = armv8a; // TODO? (crc, crypto)\nconstexpr auto nvidia_denver2 = armv8a_crc_crypto;\nconstexpr auto apm_xgene1 = armv8a;\nconstexpr auto apm_xgene2 = armv8a; // TODO?\nconstexpr auto apm_xgene3 = armv8a; // TODO?\nconstexpr auto qualcomm_kyro = armv8a_crc_crypto;\nconstexpr auto qualcomm_falkor = armv8a_crc_crypto;\nconstexpr auto qualcomm_saphira = armv8_3a_crypto;\nconstexpr auto samsung_exynos_m1 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m2 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m3 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m4 = armv8_2a_crypto;\nconstexpr auto samsung_exynos_m5 = samsung_exynos_m4;\nconstexpr auto apple_a7 = armv8a_crc_crypto;\n\n}\n\nstatic constexpr CPUSpec<CPU, feature_sz> cpus[] = {\n    {\"generic\", CPU::generic, CPU::generic, 0, Feature::generic},\n    // armv6\n    {\"mpcore\", CPU::arm_mpcore, CPU::generic, 0, Feature::generic},\n    {\"arm1136jf-s\", CPU::arm_1136jf_s, CPU::generic, 0, Feature::generic},\n    {\"arm1156t2f-s\", CPU::arm_1156t2f_s, CPU::generic, 0, Feature::generic},\n    {\"arm1176jzf-s\", CPU::arm_1176jzf_s, CPU::generic, 0, Feature::generic},\n    {\"cortex-m0\", CPU::arm_cortex_m0, CPU::generic, 0, Feature::generic},\n    {\"cortex-m1\", CPU::arm_cortex_m1, CPU::generic, 0, Feature::generic},\n    // armv7ml\n    {\"armv7-m\", CPU::armv7_m, CPU::generic, 0, Feature::armv7m},\n    {\"armv7e-m\", CPU::armv7e_m, CPU::generic, 0, Feature::armv7m},\n    {\"cortex-m3\", CPU::arm_cortex_m3, CPU::generic, 0, Feature::armv7m},\n    {\"cortex-m4\", CPU::arm_cortex_m4, CPU::generic, 0, Feature::armv7m},\n    {\"cortex-m7\", CPU::arm_cortex_m7, CPU::generic, 0, Feature::armv7m},\n    // armv7l\n    {\"armv7-a\", CPU::armv7_a, CPU::generic, 0, Feature::armv7a},\n    {\"armv7-r\", CPU::armv7_r, CPU::generic, 0, Feature::armv7r},\n    {\"cortex-a5\", CPU::arm_cortex_a5, CPU::generic, 0, Feature::arm_cortex_a5},\n    {\"cortex-a7\", CPU::arm_cortex_a7, CPU::generic, 0, Feature::arm_cortex_a7},\n    {\"cortex-a8\", CPU::arm_cortex_a8, CPU::generic, 0, Feature::arm_cortex_a8},\n    {\"cortex-a9\", CPU::arm_cortex_a9, CPU::generic, 0, Feature::arm_cortex_a9},\n    {\"cortex-a12\", CPU::arm_cortex_a12, CPU::generic, 0, Feature::arm_cortex_a12},\n    {\"cortex-a15\", CPU::arm_cortex_a15, CPU::generic, 0, Feature::arm_cortex_a15},\n    {\"cortex-a17\", CPU::arm_cortex_a17, CPU::generic, 0, Feature::arm_cortex_a17},\n    {\"cortex-r4\", CPU::arm_cortex_r4, CPU::generic, 0, Feature::arm_cortex_r4},\n    {\"cortex-r5\", CPU::arm_cortex_r5, CPU::generic, 0, Feature::arm_cortex_r5},\n    {\"cortex-r7\", CPU::arm_cortex_r7, CPU::generic, 0, Feature::arm_cortex_r7},\n    {\"cortex-r8\", CPU::arm_cortex_r8, CPU::generic, 0, Feature::arm_cortex_r8},\n    {\"scorpion\", CPU::qualcomm_scorpion, CPU::armv7_a, UINT32_MAX, Feature::qualcomm_scorpion},\n    {\"krait\", CPU::qualcomm_krait, CPU::generic, 0, Feature::qualcomm_krait},\n    {\"swift\", CPU::apple_swift, CPU::generic, 0, Feature::apple_swift},\n    {\"pj4\", CPU::marvell_pj4, CPU::armv7_a, UINT32_MAX, Feature::marvell_pj4},\n    {\"3735d\", CPU::intel_3735d, CPU::armv7_a, UINT32_MAX, Feature::intel_3735d},\n\n    // armv8ml\n    {\"armv8-m.base\", CPU::armv8_m_base, CPU::generic, 0, Feature::armv8m},\n    {\"armv8-m.main\", CPU::armv8_m_main, CPU::generic, 0, Feature::armv8m},\n    {\"cortex-m23\", CPU::arm_cortex_m23, CPU::armv8_m_base, 0, Feature::arm_cortex_m23},\n    {\"cortex-m33\", CPU::arm_cortex_m33, CPU::armv8_m_main, 0, Feature::arm_cortex_m33},\n\n    // armv8l\n    {\"armv8-a\", CPU::armv8_a, CPU::generic, 0, Feature::armv8a},\n    {\"armv8-r\", CPU::armv8_r, CPU::generic, 0, Feature::armv8r},\n    {\"armv8.1-a\", CPU::armv8_1_a, CPU::generic, 0, Feature::armv8_1a},\n    {\"armv8.2-a\", CPU::armv8_2_a, CPU::generic, 0, Feature::armv8_2a},\n    {\"armv8.3-a\", CPU::armv8_3_a, CPU::generic, 0, Feature::armv8_3a},\n    {\"armv8.4-a\", CPU::armv8_4_a, CPU::generic, 0, Feature::armv8_4a},\n    {\"armv8.5-a\", CPU::armv8_5_a, CPU::generic, 0, Feature::armv8_5a},\n    {\"armv8.6_a\", CPU::armv8_6_a, CPU::generic, 0, Feature::armv8_6a},\n    {\"cortex-a32\", CPU::arm_cortex_a32, CPU::generic, 0, Feature::arm_cortex_a32},\n    {\"cortex-r52\", CPU::arm_cortex_r52, CPU::generic, 0, Feature::arm_cortex_r52},\n    {\"cortex-a35\", CPU::arm_cortex_a35, CPU::generic, 0, Feature::arm_cortex_a35},\n    {\"cortex-a53\", CPU::arm_cortex_a53, CPU::generic, 0, Feature::arm_cortex_a53},\n    {\"cortex-a55\", CPU::arm_cortex_a55, CPU::generic, 0, Feature::arm_cortex_a55},\n    {\"cortex-a57\", CPU::arm_cortex_a57, CPU::generic, 0, Feature::arm_cortex_a57},\n    {\"cortex-a72\", CPU::arm_cortex_a72, CPU::generic, 0, Feature::arm_cortex_a72},\n    {\"cortex-a73\", CPU::arm_cortex_a73, CPU::generic, 0, Feature::arm_cortex_a73},\n    {\"cortex-a75\", CPU::arm_cortex_a75, CPU::generic, 0, Feature::arm_cortex_a75},\n    {\"cortex-a76\", CPU::arm_cortex_a76, CPU::generic, 0, Feature::arm_cortex_a76},\n    {\"cortex-a76ae\", CPU::arm_cortex_a76ae, CPU::generic, 0, Feature::arm_cortex_a76},\n    {\"cortex-a77\", CPU::arm_cortex_a77, CPU::arm_cortex_a76, 110000, Feature::arm_cortex_a77},\n    {\"cortex-a78\", CPU::arm_cortex_a78, CPU::arm_cortex_a77, 110000, Feature::arm_cortex_a78},\n    {\"cortex-x1\", CPU::arm_cortex_x1, CPU::arm_cortex_a78, 110000, Feature::arm_cortex_x1},\n    {\"neoverse-n1\", CPU::arm_neoverse_n1, CPU::arm_cortex_a76, 100000, Feature::arm_neoverse_n1},\n    {\"neoverse-v1\", CPU::arm_neoverse_v1, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_v1},\n    {\"neoverse-n2\", CPU::arm_neoverse_n2, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_n2},\n    {\"denver1\", CPU::nvidia_denver1, CPU::arm_cortex_a53, UINT32_MAX, Feature::nvidia_denver1},\n    {\"denver2\", CPU::nvidia_denver2, CPU::arm_cortex_a57, UINT32_MAX, Feature::nvidia_denver2},\n    {\"xgene1\", CPU::apm_xgene1, CPU::armv8_a, UINT32_MAX, Feature::apm_xgene1},\n    {\"xgene2\", CPU::apm_xgene2, CPU::armv8_a, UINT32_MAX, Feature::apm_xgene2},\n    {\"xgene3\", CPU::apm_xgene3, CPU::armv8_a, UINT32_MAX, Feature::apm_xgene3},\n    {\"kyro\", CPU::qualcomm_kyro, CPU::armv8_a, UINT32_MAX, Feature::qualcomm_kyro},\n    {\"falkor\", CPU::qualcomm_falkor, CPU::armv8_a, UINT32_MAX, Feature::qualcomm_falkor},\n    {\"saphira\", CPU::qualcomm_saphira, CPU::armv8_a, UINT32_MAX, Feature::qualcomm_saphira},\n    {\"exynos-m1\", CPU::samsung_exynos_m1, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m1},\n    {\"exynos-m2\", CPU::samsung_exynos_m2, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m2},\n    {\"exynos-m3\", CPU::samsung_exynos_m3, CPU::generic, 0, Feature::samsung_exynos_m3},\n    {\"exynos-m4\", CPU::samsung_exynos_m4, CPU::generic, 0, Feature::samsung_exynos_m4},\n    {\"exynos-m5\", CPU::samsung_exynos_m5, CPU::samsung_exynos_m4, 110000,\n     Feature::samsung_exynos_m5},\n    {\"apple-a7\", CPU::apple_a7, CPU::generic, 0, Feature::apple_a7},\n};\n#endif\nstatic constexpr size_t ncpu_names = sizeof(cpus) / sizeof(cpus[0]);\n\n// auxval reader\n\n#ifndef AT_HWCAP\n#  define AT_HWCAP 16\n#endif\n#ifndef AT_HWCAP2\n#  define AT_HWCAP2 26\n#endif\n\n#if defined(USE_DYN_GETAUXVAL)\nstatic unsigned long getauxval_procfs(unsigned long type)\n{\n    int fd = open(\"/proc/self/auxv\", O_RDONLY);\n    if (fd == -1)\n        return 0;\n    unsigned long val = 0;\n    unsigned long buff[2];\n    while (read(fd, buff, sizeof(buff)) == sizeof(buff)) {\n        if (buff[0] == 0)\n            break;\n        if (buff[0] == type) {\n            val = buff[1];\n            break;\n        }\n    }\n    close(fd);\n    return val;\n}\n\nstatic inline unsigned long jl_getauxval(unsigned long type)\n{\n    // First, try resolving getauxval in libc\n    auto libc = jl_dlopen(nullptr, JL_RTLD_LOCAL);\n    static unsigned long (*getauxval_p)(unsigned long) = NULL;\n    if (getauxval_p == NULL && jl_dlsym(libc, \"getauxval\", (void **)&getauxval_p, 0)) {\n        return getauxval_p(type);\n    }\n\n    // If we couldn't resolve it, use procfs.\n    return getauxval_procfs(type);\n}\n#else\nstatic inline unsigned long jl_getauxval(unsigned long type)\n{\n    return getauxval(type);\n}\n#endif\n\nstruct CPUID {\n    uint8_t implementer;\n    uint8_t variant;\n    uint16_t part;\n    bool operator<(const CPUID &right) const\n    {\n        if (implementer < right.implementer)\n            return true;\n        if (implementer > right.implementer)\n            return false;\n        if (part < right.part)\n            return true;\n        if (part > right.part)\n            return false;\n        return variant < right.variant;\n    }\n};\n\n// /sys/devices/system/cpu/cpu<n>/regs/identification/midr_el1 reader\nstatic inline void get_cpuinfo_sysfs(std::set<CPUID> &res)\n{\n    // This only works on a 64bit 4.7+ kernel\n    auto dir = opendir(\"/sys/devices/system/cpu\");\n    if (!dir)\n        return;\n    while (auto entry = readdir(dir)) {\n        if (entry->d_type != DT_DIR)\n            continue;\n        if (strncmp(entry->d_name, \"cpu\", 3) != 0)\n            continue;\n        std::string stm;\n        llvm::raw_string_ostream(stm) << \"/sys/devices/system/cpu/\" << entry->d_name << \"/regs/identification/midr_el1\";\n        std::ifstream file(stm);\n        if (!file)\n            continue;\n        uint64_t val = 0;\n        file >> std::hex >> val;\n        if (!file)\n            continue;\n        CPUID cpuid = {\n            uint8_t(val >> 24),\n            uint8_t((val >> 20) & 0xf),\n            uint16_t((val >> 4) & 0xfff)\n        };\n        res.insert(cpuid);\n    }\n    closedir(dir);\n}\n\n// Use an external template since lambda's can't be templated in C++11\ntemplate<typename T, typename F>\nstatic inline bool try_read_procfs_line(llvm::StringRef line, const char *prefix, T &out,\n                                        bool &flag, F &&reset)\n{\n    if (!line.startswith(prefix))\n        return false;\n    if (flag)\n        reset();\n    flag = line.substr(strlen(prefix)).ltrim(\"\\t :\").getAsInteger(0, out);\n    return true;\n}\n\n// /proc/cpuinfo reader\nstatic inline void get_cpuinfo_procfs(std::set<CPUID> &res)\n{\n    std::ifstream file(\"/proc/cpuinfo\");\n    CPUID cpuid = {0, 0, 0};\n    bool impl = false;\n    bool part = false;\n    bool var = false;\n    auto reset = [&] () {\n        if (impl && part)\n            res.insert(cpuid);\n        impl = false;\n        part = false;\n        var = false;\n        memset(&cpuid, 0, sizeof(cpuid));\n    };\n    for (std::string line; std::getline(file, line);) {\n        if (line.empty()) {\n            reset();\n            continue;\n        }\n        try_read_procfs_line(line, \"CPU implementer\", cpuid.implementer, impl, reset) ||\n            try_read_procfs_line(line, \"CPU variant\", cpuid.variant, var, reset) ||\n            try_read_procfs_line(line, \"CPU part\", cpuid.part, part, reset);\n    }\n    reset();\n}\n\nstatic std::set<CPUID> get_cpuinfo(void)\n{\n    std::set<CPUID> res;\n    get_cpuinfo_sysfs(res);\n    if (res.empty())\n        get_cpuinfo_procfs(res);\n    return res;\n}\n\nstatic CPU get_cpu_name(CPUID cpuid)\n{\n    switch (cpuid.implementer) {\n    case 0x41: // 'A': ARM\n        switch (cpuid.part) {\n        case 0xb02: return CPU::arm_mpcore;\n        case 0xb36: return CPU::arm_1136jf_s;\n        case 0xb56: return CPU::arm_1156t2f_s;\n        case 0xb76: return CPU::arm_1176jzf_s;\n        case 0xc05: return CPU::arm_cortex_a5;\n        case 0xc07: return CPU::arm_cortex_a7;\n        case 0xc08: return CPU::arm_cortex_a8;\n        case 0xc09: return CPU::arm_cortex_a9;\n        case 0xc0d: return CPU::arm_cortex_a12;\n        case 0xc0f: return CPU::arm_cortex_a15;\n        case 0xc0e: return CPU::arm_cortex_a17;\n        case 0xc14: return CPU::arm_cortex_r4;\n        case 0xc15: return CPU::arm_cortex_r5;\n        case 0xc17: return CPU::arm_cortex_r7;\n        case 0xc18: return CPU::arm_cortex_r8;\n        case 0xc20: return CPU::arm_cortex_m0;\n        case 0xc21: return CPU::arm_cortex_m1;\n        case 0xc23: return CPU::arm_cortex_m3;\n        case 0xc24: return CPU::arm_cortex_m4;\n        case 0xc27: return CPU::arm_cortex_m7;\n        case 0xd01: return CPU::arm_cortex_a32;\n        case 0xd02: return CPU::arm_cortex_a34;\n        case 0xd03: return CPU::arm_cortex_a53;\n        case 0xd04: return CPU::arm_cortex_a35;\n        case 0xd05: return CPU::arm_cortex_a55;\n        case 0xd06: return CPU::arm_cortex_a65;\n        case 0xd07: return CPU::arm_cortex_a57;\n        case 0xd08: return CPU::arm_cortex_a72;\n        case 0xd09: return CPU::arm_cortex_a73;\n        case 0xd0a: return CPU::arm_cortex_a75;\n        case 0xd0b: return CPU::arm_cortex_a76;\n        case 0xd0c: return CPU::arm_neoverse_n1;\n        case 0xd0d: return CPU::arm_cortex_a77;\n        case 0xd0e: return CPU::arm_cortex_a76ae;\n        case 0xd13: return CPU::arm_cortex_r52;\n        case 0xd20: return CPU::arm_cortex_m23;\n        case 0xd21: return CPU::arm_cortex_m33;\n            // case 0xd22: return CPU::arm_cortex_m55;\n        case 0xd40: return CPU::arm_neoverse_v1;\n        case 0xd41: return CPU::arm_cortex_a78;\n        case 0xd43: return CPU::arm_cortex_a65ae;\n        case 0xd44: return CPU::arm_cortex_x1;\n        case 0xd49: return CPU::arm_neoverse_n2;\n        case 0xd4a: return CPU::arm_neoverse_e1;\n        default: return CPU::generic;\n        }\n    case 0x42: // 'B': Broadcom (Cavium)\n        switch (cpuid.part) {\n            // case 0x00f: return CPU::broadcom_brahma_b15;\n            // case 0x100: return CPU::broadcom_brahma_b53;\n        case 0x516: return CPU::cavium_thunderx2t99p1;\n        default: return CPU::generic;\n        }\n    case 0x43: // 'C': Cavium\n        switch (cpuid.part) {\n        case 0xa0: return CPU::cavium_thunderx;\n        case 0xa1:\n            if (cpuid.variant == 0)\n                return CPU::cavium_thunderx88p1;\n            return CPU::cavium_thunderx88;\n        case 0xa2: return CPU::cavium_thunderx81;\n        case 0xa3: return CPU::cavium_thunderx83;\n        case 0xaf: return CPU::cavium_thunderx2t99;\n        case 0xb0: return CPU::cavium_octeontx2;\n        case 0xb1: return CPU::cavium_octeontx2t98;\n        case 0xb2: return CPU::cavium_octeontx2t96;\n        case 0xb3: return CPU::cavium_octeontx2f95;\n        case 0xb4: return CPU::cavium_octeontx2f95n;\n        case 0xb5: return CPU::cavium_octeontx2f95mm;\n        case 0xb8: return CPU::marvell_thunderx3t110;\n        default: return CPU::generic;\n        }\n    case 0x46: // 'F': Fujitsu\n        switch (cpuid.part) {\n        case 0x1: return CPU::fujitsu_a64fx;\n        default: return CPU::generic;\n        }\n    case 0x48: // 'H': HiSilicon\n        switch (cpuid.part) {\n        case 0xd01: return CPU::hisilicon_tsv110;\n        case 0xd40: return CPU::arm_cortex_a76; // Kirin 980\n        default: return CPU::generic;\n        }\n    case 0x4e: // 'N': NVIDIA\n        switch (cpuid.part) {\n        case 0x000: return CPU::nvidia_denver1;\n        case 0x003: return CPU::nvidia_denver2;\n        case 0x004: return CPU::nvidia_carmel;\n        default: return CPU::generic;\n        }\n    case 0x50: // 'P': AppliedMicro\n        // x-gene 2\n        // x-gene 3\n        switch (cpuid.part) {\n        case 0x000: return CPU::apm_xgene1;\n        default: return CPU::generic;\n        }\n    case 0x51: // 'Q': Qualcomm\n        switch (cpuid.part) {\n        case 0x00f:\n        case 0x02d:\n            return CPU::qualcomm_scorpion;\n        case 0x04d:\n        case 0x06f:\n            return CPU::qualcomm_krait;\n        case 0x201: // silver\n        case 0x205: // gold\n        case 0x211: // silver\n            return CPU::qualcomm_kyro;\n            // kryo 2xx\n        case 0x800: // gold\n            return CPU::arm_cortex_a73;\n        case 0x801: // silver\n            return CPU::arm_cortex_a53;\n            // kryo 3xx\n        case 0x802: // gold\n            return CPU::arm_cortex_a75;\n        case 0x803: // silver\n            return CPU::arm_cortex_a55;\n            // kryo 4xx\n        case 0x804: // gold\n            return CPU::arm_cortex_a76;\n        case 0x805: // silver\n            return CPU::arm_cortex_a55;\n            // kryo 5xx seems to be using ID for cortex-a77 directly\n        case 0xc00:\n            return CPU::qualcomm_falkor;\n        case 0xc01:\n            return CPU::qualcomm_saphira;\n        default: return CPU::generic;\n        }\n    case 0x53: // 'S': Samsung\n        if (cpuid.part == 1) {\n            if (cpuid.variant == 4)\n                return CPU::samsung_exynos_m2;\n            return CPU::samsung_exynos_m1;\n        }\n        if (cpuid.variant != 1)\n            return CPU::generic;\n        switch (cpuid.part) {\n        case 0x2: return CPU::samsung_exynos_m3;\n        case 0x3: return CPU::samsung_exynos_m4;\n        case 0x4: return CPU::samsung_exynos_m5;\n        default: return CPU::generic;\n        }\n    case 0x56: // 'V': Marvell\n        switch (cpuid.part) {\n        case 0x581:\n        case 0x584:\n            return CPU::marvell_pj4;\n        default: return CPU::generic;\n        }\n    case 0x61: // 'a': Apple\n        // https://opensource.apple.com/source/xnu/xnu-6153.81.5/osfmk/arm/cpuid.h.auto.html\n        switch (cpuid.part) {\n        case 0x0: // Swift\n            return CPU::apple_swift;\n        case 0x1: // Cyclone\n            return CPU::apple_a7;\n        case 0x2: // Typhoon\n        case 0x3: // Typhoo/Capri\n            return CPU::apple_a8;\n        case 0x4: // Twister\n        case 0x5: // Twister/Elba/Malta\n            return CPU::apple_a9;\n        case 0x6: // Hurricane\n        case 0x7: // Hurricane/Myst\n            return CPU::apple_a10;\n        case 0x8: // Monsoon\n        case 0x9: // Mistral\n            return CPU::apple_a11;\n        case 0xB: // Vortex\n        case 0xC: // Tempest\n        case 0x10: // A12X, Vortex Aruba\n        case 0x11: // A12X, Tempest Aruba\n            return CPU::apple_a12;\n        case 0xF: // Tempest M9\n            return CPU::apple_s4;\n        case 0x12: // Lightning\n        case 0x13: // Thunder\n            return CPU::apple_a13;\n        default: return CPU::generic;\n        }\n    case 0x68: // 'h': Huaxintong Semiconductor\n        switch (cpuid.part) {\n        case 0x0: return CPU::hxt_phecda;\n        default: return CPU::generic;\n        }\n    case 0x69: // 'i': Intel\n        switch (cpuid.part) {\n        case 0x001: return CPU::intel_3735d;\n        default: return CPU::generic;\n        }\n    default:\n        return CPU::generic;\n    }\n}\n\nnamespace {\n\nstruct arm_arch {\n    int version;\n    char klass;\n    constexpr bool mclass() const { return klass == 'M'; }\n};\n\n}\n\nstatic arm_arch get_elf_arch(void)\n{\n#ifdef _CPU_AARCH64_\n    return {8, 'A'};\n#else\n    int ver = 0;\n    char profile = 0;\n    struct utsname name;\n    if (uname(&name) >= 0) {\n        // name.machine is the elf_platform in the kernel.\n        if (strcmp(name.machine, \"armv6l\") == 0) {\n            ver = 6;\n        }\n        else if (strcmp(name.machine, \"armv7l\") == 0) {\n            ver = 7;\n        }\n        else if (strcmp(name.machine, \"armv7ml\") == 0) {\n            ver = 7;\n            profile = 'M';\n        }\n        else if (strcmp(name.machine, \"armv8l\") == 0 || strcmp(name.machine, \"aarch64\") == 0) {\n            ver = 8;\n        }\n    }\n    if (__ARM_ARCH > ver)\n        ver = __ARM_ARCH;\n#  if __ARM_ARCH > 6 && defined(__ARM_ARCH_PROFILE)\n    profile = __ARM_ARCH_PROFILE;\n#  endif\n    return {ver, profile};\n#endif\n}\n\nstatic inline const CPUSpec<CPU,feature_sz> *find_cpu(uint32_t cpu)\n{\n    return ::find_cpu(cpu, cpus, ncpu_names);\n}\n\nstatic inline const CPUSpec<CPU,feature_sz> *find_cpu(llvm::StringRef name)\n{\n    return ::find_cpu(name, cpus, ncpu_names);\n}\n\nstatic inline const char *find_cpu_name(uint32_t cpu)\n{\n    return ::find_cpu_name(cpu, cpus, ncpu_names);\n}\n\nstatic arm_arch feature_arch_version(const FeatureList<feature_sz> &feature)\n{\n#ifdef _CPU_AARCH64_\n    return {8, 'A'};\n#else\n    int ver;\n    if (test_nbit(feature, Feature::v8)) {\n        ver = 8;\n    }\n    else if (test_nbit(feature, Feature::v7)) {\n        ver = 7;\n    }\n    else {\n        return {6, 0};\n    }\n    if (test_nbit(feature, Feature::mclass)) {\n        return {ver, 'M'};\n    }\n    else if (test_nbit(feature, Feature::rclass)) {\n        return {ver, 'R'};\n    }\n    else if (test_nbit(feature, Feature::aclass)) {\n        return {ver, 'A'};\n    }\n    return {ver, 0};\n#endif\n}\n\nstatic CPU generic_for_arch(arm_arch arch)\n{\n#ifdef _CPU_AARCH64_\n    return CPU::generic;\n#else\n#  if defined(__ARM_ARCH_PROFILE)\n    char klass = __ARM_ARCH_PROFILE;\n#  else\n    char klass = arch.klass;\n#  endif\n    if (arch.version >= 8) {\n        if (klass == 'M') {\n            return CPU::armv8_m_base;\n        }\n        else if (klass == 'R') {\n            return CPU::armv8_r;\n        }\n        else {\n            return CPU::armv8_a;\n        }\n    }\n    else if (arch.version == 7) {\n        if (klass == 'M') {\n            return CPU::armv7_m;\n        }\n        else if (klass == 'R') {\n            return CPU::armv7_r;\n        }\n        else {\n            return CPU::armv7_a;\n        }\n    }\n    return CPU::generic;\n#endif\n}\n\nstatic bool check_cpu_arch_ver(uint32_t cpu, arm_arch arch)\n{\n    auto spec = find_cpu(cpu);\n    // This happens on AArch64 and indicates that the cpu name isn't a valid aarch64 CPU\n    if (!spec)\n        return false;\n    auto feature_arch = feature_arch_version(spec->features);\n    if (arch.mclass() != feature_arch.mclass())\n        return false;\n    if (arch.version > feature_arch.version)\n        return false;\n    return true;\n}\n\nstatic void shrink_big_little(std::vector<std::pair<uint32_t,CPUID>> &list,\n                              const CPU *cpus, uint32_t ncpu)\n{\n    auto find = [&] (uint32_t name) {\n        for (uint32_t i = 0; i < ncpu; i++) {\n            if (cpus[i] == CPU(name)) {\n                return (int)i;\n            }\n        }\n        return -1;\n    };\n    int maxidx = -1;\n    for (auto &ele: list) {\n        int idx = find(ele.first);\n        if (idx > maxidx) {\n            maxidx = idx;\n        }\n    }\n    if (maxidx >= 0) {\n        list.erase(std::remove_if(list.begin(), list.end(), [&] (std::pair<uint32_t,CPUID> &ele) {\n                    int idx = find(ele.first);\n                    return idx != -1 && idx < maxidx;\n                }), list.end());\n    }\n}\n\nstatic NOINLINE std::pair<uint32_t,FeatureList<feature_sz>> _get_host_cpu()\n{\n    FeatureList<feature_sz> features = {};\n    // Here we assume that only the lower 32bit are used on aarch64\n    // Change the cast here when that's not the case anymore (and when there's features in the\n    // high bits that we want to detect).\n    features[0] = (uint32_t)jl_getauxval(AT_HWCAP);\n    features[1] = (uint32_t)jl_getauxval(AT_HWCAP2);\n#ifdef _CPU_AARCH64_\n    if (test_nbit(features, 31)) // HWCAP_PACG\n        set_bit(features, Feature::pa, true);\n#endif\n    auto cpuinfo = get_cpuinfo();\n    auto arch = get_elf_arch();\n#ifdef _CPU_ARM_\n    if (arch.version >= 7) {\n        if (arch.klass == 'M') {\n            set_bit(features, Feature::mclass, true);\n        }\n        else if (arch.klass == 'R') {\n            set_bit(features, Feature::rclass, true);\n        }\n        else if (arch.klass == 'A') {\n            set_bit(features, Feature::aclass, true);\n        }\n    }\n    switch (arch.version) {\n    case 8:\n        set_bit(features, Feature::v8, true);\n        JL_FALLTHROUGH;\n    case 7:\n        set_bit(features, Feature::v7, true);\n        break;\n    default:\n        break;\n    }\n#endif\n\n    std::set<uint32_t> cpus;\n    std::vector<std::pair<uint32_t,CPUID>> list;\n    // Ideally the feature detection above should be enough.\n    // However depending on the kernel version not all features are available\n    // and it's also impossible to detect the ISA version which contains\n    // some features not yet exposed by the kernel.\n    // We therefore try to get a more complete feature list from the CPU name.\n    // Since it is possible to pair cores that have different feature set\n    // (Observed for exynos 9810 with exynos-m3 + cortex-a55) we'll compute\n    // an intersection of the known features from each core.\n    // If there's a core that we don't recognize, treat it as generic.\n    bool extra_initialized = false;\n    FeatureList<feature_sz> extra_features = {};\n    for (auto info: cpuinfo) {\n        auto name = (uint32_t)get_cpu_name(info);\n        if (name == 0) {\n            // no need to clear the feature set if it wasn't initialized\n            if (extra_initialized)\n                extra_features = FeatureList<feature_sz>{};\n            extra_initialized = true;\n            continue;\n        }\n        if (!check_cpu_arch_ver(name, arch))\n            continue;\n        if (cpus.insert(name).second) {\n            if (extra_initialized) {\n                extra_features = extra_features & find_cpu(name)->features;\n            }\n            else {\n                extra_initialized = true;\n                extra_features = find_cpu(name)->features;\n            }\n            list.emplace_back(name, info);\n        }\n    }\n    features = features | extra_features;\n\n    // Not all elements/pairs are valid\n    static constexpr CPU v8order[] = {\n        CPU::arm_cortex_a35,\n        CPU::arm_cortex_a53,\n        CPU::arm_cortex_a55,\n        CPU::arm_cortex_a57,\n        CPU::arm_cortex_a72,\n        CPU::arm_cortex_a73,\n        CPU::arm_cortex_a75,\n        CPU::arm_cortex_a76,\n        CPU::arm_neoverse_n1,\n        CPU::arm_neoverse_n2,\n        CPU::arm_neoverse_v1,\n        CPU::nvidia_denver2,\n        CPU::nvidia_carmel,\n        CPU::samsung_exynos_m1,\n        CPU::samsung_exynos_m2,\n        CPU::samsung_exynos_m3,\n        CPU::samsung_exynos_m4,\n        CPU::samsung_exynos_m5,\n    };\n    shrink_big_little(list, v8order, sizeof(v8order) / sizeof(CPU));\n#ifdef _CPU_ARM_\n    // Not all elements/pairs are valid\n    static constexpr CPU v7order[] = {\n        CPU::arm_cortex_a5,\n        CPU::arm_cortex_a7,\n        CPU::arm_cortex_a8,\n        CPU::arm_cortex_a9,\n        CPU::arm_cortex_a12,\n        CPU::arm_cortex_a15,\n        CPU::arm_cortex_a17\n    };\n    shrink_big_little(list, v7order, sizeof(v7order) / sizeof(CPU));\n#endif\n    uint32_t cpu = 0;\n    if (list.empty()) {\n        cpu = (uint32_t)generic_for_arch(arch);\n    }\n    else {\n        // This also covers `list.size() > 1` case which means there's a unknown combination\n        // consists of CPU's we know. Unclear what else we could try so just randomly return\n        // one...\n        cpu = list[0].first;\n    }\n    // Ignore feature bits that we are not interested in.\n    mask_features(feature_masks, &features[0]);\n\n    return std::make_pair(cpu, features);\n}\n\nstatic inline const std::pair<uint32_t,FeatureList<feature_sz>> &get_host_cpu()\n{\n    static auto host_cpu = _get_host_cpu();\n    return host_cpu;\n}\n\nstatic bool is_generic_cpu_name(uint32_t cpu)\n{\n    switch ((CPU)cpu) {\n    case CPU::generic:\n    case CPU::armv7_a:\n    case CPU::armv7_m:\n    case CPU::armv7e_m:\n    case CPU::armv7_r:\n    case CPU::armv8_a:\n    case CPU::armv8_m_base:\n    case CPU::armv8_m_main:\n    case CPU::armv8_r:\n    case CPU::armv8_1_a:\n    case CPU::armv8_2_a:\n    case CPU::armv8_3_a:\n    case CPU::armv8_4_a:\n    case CPU::armv8_5_a:\n    case CPU::armv8_6_a:\n        return true;\n    default:\n        return false;\n    }\n}\n\nstatic inline const std::string &host_cpu_name()\n{\n    static std::string name = [] {\n        if (is_generic_cpu_name(get_host_cpu().first)) {\n            auto llvm_name = jl_get_cpu_name_llvm();\n            if (llvm_name != \"generic\") {\n                return llvm_name;\n            }\n        }\n        return std::string(find_cpu_name(get_host_cpu().first));\n    }();\n    return name;\n}\n\nstatic inline const char *normalize_cpu_name(llvm::StringRef name)\n{\n    if (name == \"ares\")\n        return \"neoverse-n1\";\n    if (name == \"zeus\")\n        return \"neoverse-v1\";\n    if (name == \"cyclone\")\n        return \"apple-a7\";\n    if (name == \"typhoon\")\n        return \"apple-a8\";\n    if (name == \"twister\")\n        return \"apple-a9\";\n    if (name == \"hurricane\")\n        return \"apple-a10\";\n    return nullptr;\n}\n\ntemplate<size_t n>\nstatic inline void enable_depends(FeatureList<n> &features)\n{\n    if (test_nbit(features, Feature::v8_6a))\n        set_bit(features, Feature::v8_5a, true);\n    if (test_nbit(features, Feature::v8_5a))\n        set_bit(features, Feature::v8_4a, true);\n    if (test_nbit(features, Feature::v8_4a))\n        set_bit(features, Feature::v8_3a, true);\n    if (test_nbit(features, Feature::v8_3a))\n        set_bit(features, Feature::v8_2a, true);\n    if (test_nbit(features, Feature::v8_2a))\n        set_bit(features, Feature::v8_1a, true);\n    if (test_nbit(features, Feature::v8_1a))\n        set_bit(features, Feature::crc, true);\n#ifdef _CPU_ARM_\n    if (test_nbit(features, Feature::v8_1a)) {\n        set_bit(features, Feature::v8, true);\n        set_bit(features, Feature::aclass, true);\n    }\n    if (test_nbit(features, Feature::v8_m_main)) {\n        set_bit(features, Feature::v8, true);\n        set_bit(features, Feature::mclass, true);\n    }\n    if (test_nbit(features, Feature::v8)) {\n        set_bit(features, Feature::v7, true);\n        if (test_nbit(features, Feature::aclass)) {\n            set_bit(features, Feature::neon, true);\n            set_bit(features, Feature::vfp3, true);\n            set_bit(features, Feature::vfp4, true);\n            set_bit(features, Feature::hwdiv_arm, true);\n            set_bit(features, Feature::hwdiv, true);\n            set_bit(features, Feature::d32, true);\n        }\n    }\n#else\n    if (test_nbit(features, Feature::v8_1a)) {\n        set_bit(features, Feature::lse, true);\n        set_bit(features, Feature::rdm, true);\n    }\n    if (test_nbit(features, Feature::v8_2a)) {\n        set_bit(features, Feature::ccpp, true);\n    }\n    if (test_nbit(features, Feature::v8_3a)) {\n        set_bit(features, Feature::jsconv, true);\n        set_bit(features, Feature::complxnum, true);\n        set_bit(features, Feature::rcpc, true);\n    }\n    if (test_nbit(features, Feature::v8_4a)) {\n        set_bit(features, Feature::dit, true);\n        set_bit(features, Feature::rcpc_immo, true);\n        set_bit(features, Feature::fmi, true);\n    }\n    if (test_nbit(features, Feature::v8_5a)) {\n        set_bit(features, Feature::sb, true);\n        set_bit(features, Feature::ccdp, true);\n        set_bit(features, Feature::altnzcv, true);\n        set_bit(features, Feature::fptoint, true);\n    }\n    if (test_nbit(features, Feature::v8_6a)) {\n        set_bit(features, Feature::i8mm, true);\n        set_bit(features, Feature::bf16, true);\n    }\n#endif\n    ::enable_depends(features, Feature::deps, sizeof(Feature::deps) / sizeof(FeatureDep));\n}\n\ntemplate<size_t n>\nstatic inline void disable_depends(FeatureList<n> &features)\n{\n    ::disable_depends(features, Feature::deps, sizeof(Feature::deps) / sizeof(FeatureDep));\n}\n\nstatic const std::vector<TargetData<feature_sz>> &get_cmdline_targets(void)\n{\n    auto feature_cb = [] (const char *str, size_t len, FeatureList<feature_sz> &list) {\n#ifdef _CPU_AARCH64_\n        // On AArch64, treat `crypto` as an alias of aes + sha2 just like LLVM\n        if (llvm::StringRef(str, len) == \"crypto\") {\n            set_bit(list, Feature::aes, true);\n            set_bit(list, Feature::sha2, true);\n            return true;\n        }\n#endif\n        auto fbit = find_feature_bit(feature_names, nfeature_names, str, len);\n        if (fbit == (uint32_t)-1)\n            return false;\n        set_bit(list, fbit, true);\n        return true;\n    };\n    auto &targets = ::get_cmdline_targets<feature_sz>(feature_cb);\n    for (auto &t: targets) {\n        if (auto nname = normalize_cpu_name(t.name)) {\n            t.name = nname;\n        }\n    }\n    return targets;\n}\n\nstatic std::vector<TargetData<feature_sz>> jit_targets;\n\nstatic TargetData<feature_sz> arg_target_data(const TargetData<feature_sz> &arg, bool require_host)\n{\n    TargetData<feature_sz> res = arg;\n    const FeatureList<feature_sz> *cpu_features = nullptr;\n    if (res.name == \"native\") {\n        res.name = host_cpu_name();\n        cpu_features = &get_host_cpu().second;\n    }\n    else if (auto spec = find_cpu(res.name)) {\n        cpu_features = &spec->features;\n    }\n    else {\n        res.en.flags |= JL_TARGET_UNKNOWN_NAME;\n    }\n    if (cpu_features) {\n        for (size_t i = 0; i < feature_sz; i++) {\n            res.en.features[i] |= (*cpu_features)[i];\n        }\n    }\n    enable_depends(res.en.features);\n    for (size_t i = 0; i < feature_sz; i++)\n        res.en.features[i] &= ~res.dis.features[i];\n    if (require_host) {\n        for (size_t i = 0; i < feature_sz; i++) {\n            res.en.features[i] &= get_host_cpu().second[i];\n        }\n    }\n    disable_depends(res.en.features);\n    if (cpu_features) {\n        // If the base feature if known, fill in the disable features\n        for (size_t i = 0; i < feature_sz; i++) {\n            res.dis.features[i] = feature_masks[i] & ~res.en.features[i];\n        }\n    }\n    return res;\n}\n\nstatic int max_vector_size(const FeatureList<feature_sz> &features)\n{\n#ifdef _CPU_ARM_\n    if (test_nbit(features, Feature::neon))\n        return 16;\n    return 8;\n#else\n    if (test_nbit(features, Feature::sve2))\n        return 256;\n    if (test_nbit(features, Feature::sve))\n        return 128;\n    return 16;\n#endif\n}\n\nstatic uint32_t sysimg_init_cb(const void *id)\n{\n    // First see what target is requested for the JIT.\n    auto &cmdline = get_cmdline_targets();\n    TargetData<feature_sz> target = arg_target_data(cmdline[0], true);\n    // Then find the best match in the sysimg\n    auto sysimg = deserialize_target_data<feature_sz>((const uint8_t*)id);\n    for (auto &t: sysimg) {\n        if (auto nname = normalize_cpu_name(t.name)) {\n            t.name = nname;\n        }\n    }\n    auto match = match_sysimg_targets(sysimg, target, max_vector_size);\n    // Now we've decided on which sysimg version to use.\n    // Make sure the JIT target is compatible with it and save the JIT target.\n    if (match.vreg_size != max_vector_size(target.en.features) &&\n        (sysimg[match.best_idx].en.flags & JL_TARGET_VEC_CALL)) {\n#ifdef _CPU_ARM_\n        unset_bits(target.en.features, Feature::neon);\n#endif\n    }\n    jit_targets.push_back(std::move(target));\n    return match.best_idx;\n}\n\nstatic void ensure_jit_target(bool imaging)\n{\n    auto &cmdline = get_cmdline_targets();\n    check_cmdline(cmdline, imaging);\n    if (!jit_targets.empty())\n        return;\n    for (auto &arg: cmdline) {\n        auto data = arg_target_data(arg, jit_targets.empty());\n        jit_targets.push_back(std::move(data));\n    }\n    auto ntargets = jit_targets.size();\n    // Now decide the clone condition.\n    for (size_t i = 1; i < ntargets; i++) {\n        auto &t = jit_targets[i];\n        if (t.en.flags & JL_TARGET_CLONE_ALL)\n            continue;\n        // The most useful one in general...\n        t.en.flags |= JL_TARGET_CLONE_LOOP;\n#ifdef _CPU_ARM_\n        auto &features0 = jit_targets[t.base].en.features;\n        static constexpr uint32_t clone_math[] = {Feature::vfp3, Feature::vfp4, Feature::neon};\n        for (auto fe: clone_math) {\n            if (!test_nbit(features0, fe) && test_nbit(t.en.features, fe)) {\n                t.en.flags |= JL_TARGET_CLONE_MATH;\n                break;\n            }\n        }\n        static constexpr uint32_t clone_simd[] = {Feature::neon};\n        for (auto fe: clone_simd) {\n            if (!test_nbit(features0, fe) && test_nbit(t.en.features, fe)) {\n                t.en.flags |= JL_TARGET_CLONE_SIMD;\n                break;\n            }\n        }\n#endif\n    }\n}\n\nstatic std::pair<std::string,std::vector<std::string>>\nget_llvm_target_noext(const TargetData<feature_sz> &data)\n{\n    std::string name = data.name;\n    auto *spec = find_cpu(name);\n    while (spec) {\n        if (spec->llvmver <= JL_LLVM_VERSION)\n            break;\n        spec = find_cpu((uint32_t)spec->fallback);\n        name = spec->name;\n    }\n    auto features = data.en.features;\n    if (spec) {\n        if (is_generic_cpu_name((uint32_t)spec->cpu)) {\n            features = features | spec->features;\n            name = \"generic\";\n        }\n    }\n#ifdef _CPU_ARM_\n    // We use the name on aarch64 internally but the LLVM ARM backend still use the old name...\n    if (name == \"apple-a7\")\n        name = \"cyclone\";\n#endif\n    std::vector<std::string> feature_strs;\n    for (auto &fename: feature_names) {\n        if (fename.llvmver > JL_LLVM_VERSION)\n            continue;\n        if (fename.bit >= 32 * 2)\n            break;\n        const char *fename_str = fename.name;\n        bool enable = test_nbit(features, fename.bit);\n        bool disable = test_nbit(data.dis.features, fename.bit);\n        if (enable) {\n            feature_strs.insert(feature_strs.begin(), std::string(\"+\") + fename_str);\n        }\n        else if (disable) {\n            feature_strs.push_back(std::string(\"-\") + fename_str);\n        }\n    }\n#if JL_LLVM_VERSION >= 110000\n    if (test_nbit(features, Feature::v8_6a))\n        feature_strs.push_back(\"+v8.6a\");\n#endif\n    if (test_nbit(features, Feature::v8_5a))\n        feature_strs.push_back(\"+v8.5a\");\n    if (test_nbit(features, Feature::v8_4a))\n        feature_strs.push_back(\"+v8.4a\");\n    if (test_nbit(features, Feature::v8_3a))\n        feature_strs.push_back(\"+v8.3a\");\n    if (test_nbit(features, Feature::v8_2a))\n        feature_strs.push_back(\"+v8.2a\");\n    if (test_nbit(features, Feature::v8_1a))\n        feature_strs.push_back(\"+v8.1a\");\n#ifdef _CPU_ARM_\n    if (test_nbit(features, Feature::v8_m_main)) {\n        feature_strs.push_back(\"+v8m.main\");\n        feature_strs.push_back(\"+armv8-m.main\");\n    }\n    if (test_nbit(features, Feature::aclass))\n        feature_strs.push_back(\"+aclass\");\n    if (test_nbit(features, Feature::rclass))\n        feature_strs.push_back(\"+rclass\");\n    if (test_nbit(features, Feature::mclass))\n        feature_strs.push_back(\"+mclass\");\n    if (test_nbit(features, Feature::v8)) {\n        feature_strs.push_back(\"+v8\");\n        if (test_nbit(features, Feature::aclass))\n            feature_strs.push_back(\"+armv8-a\");\n        if (test_nbit(features, Feature::rclass))\n            feature_strs.push_back(\"+armv8-r\");\n        if (test_nbit(features, Feature::mclass)) {\n            feature_strs.push_back(\"+v8m\");\n            feature_strs.push_back(\"+armv8-m.base\");\n        }\n    }\n    if (test_nbit(features, Feature::v7)) {\n        feature_strs.push_back(\"+v7\");\n        if (test_nbit(features, Feature::aclass))\n            feature_strs.push_back(\"+armv7-a\");\n        if (test_nbit(features, Feature::rclass))\n            feature_strs.push_back(\"+armv7-r\");\n        if (test_nbit(features, Feature::mclass))\n            feature_strs.push_back(\"+armv7-m\");\n    }\n    feature_strs.push_back(\"+v6\");\n    feature_strs.push_back(\"+vfp2\");\n#else\n    feature_strs.push_back(\"+neon\");\n    feature_strs.push_back(\"+fp-armv8\");\n#endif\n    return std::make_pair(std::move(name), std::move(feature_strs));\n}\n\nstatic std::pair<std::string,std::vector<std::string>>\nget_llvm_target_vec(const TargetData<feature_sz> &data)\n{\n    auto res0 = get_llvm_target_noext(data);\n    append_ext_features(res0.second, data.ext_features);\n    return res0;\n}\n\nstatic std::pair<std::string,std::string>\nget_llvm_target_str(const TargetData<feature_sz> &data)\n{\n    auto res0 = get_llvm_target_noext(data);\n    auto features = join_feature_strs(res0.second);\n    append_ext_features(features, data.ext_features);\n    return std::make_pair(std::move(res0.first), std::move(features));\n}\n\nstatic FeatureList<feature_sz> get_max_feature(void)\n{\n#ifdef _CPU_ARM_\n    auto arch = get_elf_arch();\n    auto features = real_feature_masks;\n    if (arch.klass == 0)\n        arch.klass = 'A';\n    set_bit(features, Feature::v7, true);\n    set_bit(features, Feature::v8, true);\n    if (arch.klass == 'M') {\n        set_bit(features, Feature::mclass, true);\n        set_bit(features, Feature::v8_m_main, true);\n    }\n    else if (arch.klass == 'R') {\n        set_bit(features, Feature::rclass, true);\n    }\n    else if (arch.klass == 'A') {\n        set_bit(features, Feature::aclass, true);\n        set_bit(features, Feature::v8_1a, true);\n        set_bit(features, Feature::v8_2a, true);\n        set_bit(features, Feature::v8_3a, true);\n        set_bit(features, Feature::v8_4a, true);\n        set_bit(features, Feature::v8_5a, true);\n        set_bit(features, Feature::v8_6a, true);\n    }\n    return features;\n#else\n    // There isn't currently any conflicting features on AArch64\n    return feature_masks;\n#endif\n}\n\n}\n\nusing namespace ARM;\n\nJL_DLLEXPORT void jl_dump_host_cpu(void)\n{\n    dump_cpu_spec(get_host_cpu().first, get_host_cpu().second, feature_names, nfeature_names,\n                  cpus, ncpu_names);\n}\n\nJL_DLLEXPORT jl_value_t *jl_get_cpu_name(void)\n{\n    return jl_cstr_to_string(host_cpu_name().c_str());\n}\n\njl_sysimg_fptrs_t jl_init_processor_sysimg(void *hdl)\n{\n    if (!jit_targets.empty())\n        jl_error(\"JIT targets already initialized\");\n    return parse_sysimg(hdl, sysimg_init_cb);\n}\n\nstd::pair<std::string,std::vector<std::string>> jl_get_llvm_target(bool imaging, uint32_t &flags)\n{\n    ensure_jit_target(imaging);\n    flags = jit_targets[0].en.flags;\n    return get_llvm_target_vec(jit_targets[0]);\n}\n\nconst std::pair<std::string,std::string> &jl_get_llvm_disasm_target(void)\n{\n    auto max_feature = get_max_feature();\n    static const auto res = get_llvm_target_str(TargetData<feature_sz>{host_cpu_name(),\n#ifdef _CPU_AARCH64_\n#  if JL_LLVM_VERSION > 110000\n                \"+ecv,\"\n#  endif\n#  if JL_LLVM_VERSION > 100000\n                \"+tme,\"\n#  endif\n                \"+am,+specrestrict,+predres,+lor,+perfmon,+spe,+tracev8.4\",\n#else\n                \"+dotprod\",\n#endif\n                {max_feature, 0}, {feature_masks & ~max_feature, 0}, 0});\n    return res;\n}\n\nstd::vector<jl_target_spec_t> jl_get_llvm_clone_targets(void)\n{\n    if (jit_targets.empty())\n        jl_error(\"JIT targets not initialized\");\n    std::vector<jl_target_spec_t> res;\n    for (auto &target: jit_targets) {\n        auto features_en = target.en.features;\n        auto features_dis = target.dis.features;\n        for (auto &fename: feature_names) {\n            if (fename.llvmver > JL_LLVM_VERSION) {\n                unset_bits(features_en, fename.bit);\n                unset_bits(features_dis, fename.bit);\n            }\n        }\n        ARM::disable_depends(features_en);\n        jl_target_spec_t ele;\n        std::tie(ele.cpu_name, ele.cpu_features) = get_llvm_target_str(target);\n        ele.data = serialize_target_data(target.name, features_en, features_dis,\n                                         target.ext_features);\n        ele.flags = target.en.flags;\n        ele.base = target.base;\n        res.push_back(ele);\n    }\n    return res;\n}\n\nextern \"C\" int jl_test_cpu_feature(jl_cpu_feature_t feature)\n{\n    if (feature >= 32 * feature_sz)\n        return 0;\n    return test_nbit(&get_host_cpu().second[0], feature);\n}\n\n#ifdef _CPU_AARCH64_\n// FPCR FZ, bit [24]\nstatic constexpr uint32_t fpcr_fz_mask = 1 << 24;\n// FPCR DN, bit [25]\nstatic constexpr uint32_t fpcr_dn_mask = 1 << 25;\n\nstatic inline uint32_t get_fpcr_aarch64(void)\n{\n    uint32_t fpcr;\n    asm volatile(\"mrs %0, fpcr\" : \"=r\"(fpcr));\n    return fpcr;\n}\n\nstatic inline void set_fpcr_aarch64(uint32_t fpcr)\n{\n    asm volatile(\"msr fpcr, %0\" :: \"r\"(fpcr));\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return (get_fpcr_aarch64() & fpcr_fz_mask) != 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    uint32_t fpcr = get_fpcr_aarch64();\n    fpcr = isZero ? (fpcr | fpcr_fz_mask) : (fpcr & ~fpcr_fz_mask);\n    set_fpcr_aarch64(fpcr);\n    return 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_get_default_nans(void)\n{\n    return (get_fpcr_aarch64() & fpcr_dn_mask) != 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_default_nans(int8_t isDefault)\n{\n    uint32_t fpcr = get_fpcr_aarch64();\n    fpcr = isDefault ? (fpcr | fpcr_dn_mask) : (fpcr & ~fpcr_dn_mask);\n    set_fpcr_aarch64(fpcr);\n    return 0;\n}\n#else\nextern \"C\" JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    return isZero;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_get_default_nans(void)\n{\n    return 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_default_nans(int8_t isDefault)\n{\n    return isDefault;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/ccall.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// --- the ccall, cglobal, and llvm intrinsics ---\n#include \"llvm/Support/Path.h\" // for llvm::sys::path\n#include <llvm/Bitcode/BitcodeReader.h>\n#include <llvm/Linker/Linker.h>\n\n// somewhat unusual variable, in that aotcompile wants to get the address of this for a sanity check\nGlobalVariable *jl_emit_RTLD_DEFAULT_var(Module *M)\n{\n    return prepare_global_in(M, jlRTLD_DEFAULT_var);\n}\n\n// Find or create the GVs for the library and symbol lookup.\n// Return `runtime_lib` (whether the library name is a string)\n// The `lib` and `sym` GV returned may not be in the current module.\nstatic bool runtime_sym_gvs(jl_codegen_params_t &emission_context, const char *f_lib, const char *f_name,\n                            GlobalVariable *&lib, GlobalVariable *&sym)\n{\n    Module *M = emission_context.shared_module(jl_LLVMContext);\n    bool runtime_lib = false;\n    GlobalVariable *libptrgv;\n    jl_codegen_params_t::SymMapGV *symMap;\n#ifdef _OS_WINDOWS_\n    if ((intptr_t)f_lib == (intptr_t)JL_EXE_LIBNAME) {\n        libptrgv = prepare_global_in(M, jlexe_var);\n        symMap = &emission_context.symMapExe;\n    }\n    else if ((intptr_t)f_lib == (intptr_t)JL_LIBJULIA_INTERNAL_DL_LIBNAME) {\n        libptrgv = prepare_global_in(M, jldll_var);\n        symMap = &emission_context.symMapDl;\n    }\n    else\n#endif\n    if (f_lib == NULL) {\n        libptrgv = jl_emit_RTLD_DEFAULT_var(M);\n        symMap = &emission_context.symMapDefault;\n    }\n    else {\n        std::string name = \"ccalllib_\";\n        name += llvm::sys::path::filename(f_lib);\n        name += std::to_string(globalUnique++);\n        runtime_lib = true;\n        auto &libgv = emission_context.libMapGV[f_lib];\n        if (libgv.first == NULL) {\n            libptrgv = new GlobalVariable(*M, T_pint8, false,\n                                          GlobalVariable::ExternalLinkage,\n                                          Constant::getNullValue(T_pint8), name);\n            libgv.first = libptrgv;\n        }\n        else {\n            libptrgv = libgv.first;\n        }\n        symMap = &libgv.second;\n    }\n\n    GlobalVariable *&llvmgv = (*symMap)[f_name];\n    if (llvmgv == NULL) {\n        std::string name = \"ccall_\";\n        name += f_name;\n        name += \"_\";\n        name += std::to_string(globalUnique++);\n        llvmgv = new GlobalVariable(*M, T_pvoidfunc, false,\n                                    GlobalVariable::ExternalLinkage,\n                                    Constant::getNullValue(T_pvoidfunc), name);\n    }\n\n    lib = libptrgv;\n    sym = llvmgv;\n    return runtime_lib;\n}\n\nstatic Value *runtime_sym_lookup(\n        jl_codegen_params_t &emission_context,\n        IRBuilder<> &irbuilder,\n        jl_codectx_t *ctx,\n        PointerType *funcptype, const char *f_lib, jl_value_t *lib_expr,\n        const char *f_name, Function *f,\n        GlobalVariable *libptrgv,\n        GlobalVariable *llvmgv, bool runtime_lib)\n{\n    // in pseudo-code, this function emits the following:\n    //   global HMODULE *libptrgv\n    //   global void **llvmgv\n    //   if (*llvmgv == NULL) {\n    //       *llvmgv = jl_load_and_lookup(f_lib, f_name, libptrgv);\n    //   }\n    //   return (*llvmgv)\n    BasicBlock *enter_bb = irbuilder.GetInsertBlock();\n    BasicBlock *dlsym_lookup = BasicBlock::Create(jl_LLVMContext, \"dlsym\");\n    BasicBlock *ccall_bb = BasicBlock::Create(jl_LLVMContext, \"ccall\");\n    Constant *initnul = ConstantPointerNull::get((PointerType*)T_pvoidfunc);\n    LoadInst *llvmf_orig = irbuilder.CreateAlignedLoad(T_pvoidfunc, llvmgv, Align(sizeof(void*)));\n    // This in principle needs a consume ordering so that load from\n    // this pointer sees a valid value. However, this is not supported by\n    // LLVM (or agreed on in the C/C++ standard FWIW) and should be\n    // almost impossible to happen on every platform we support since this\n    // ordering is enforced by the hardware and LLVM has to speculate an\n    // invalid load from the `cglobal` but doesn't depend on the `cglobal`\n    // value for this to happen.\n    llvmf_orig->setAtomic(AtomicOrdering::Unordered);\n    irbuilder.CreateCondBr(\n            irbuilder.CreateICmpNE(llvmf_orig, initnul),\n            ccall_bb,\n            dlsym_lookup);\n\n    assert(f->getParent() != NULL);\n    f->getBasicBlockList().push_back(dlsym_lookup);\n    irbuilder.SetInsertPoint(dlsym_lookup);\n    Instruction *llvmf;\n    Value *nameval = stringConstPtr(emission_context, irbuilder, f_name);\n    if (lib_expr) {\n        jl_cgval_t libval = emit_expr(*ctx, lib_expr);\n        llvmf = irbuilder.CreateCall(prepare_call_in(jl_builderModule(irbuilder), jllazydlsym_func),\n                    { boxed(*ctx, libval), nameval });\n    }\n    else {\n        Value *libname;\n        if (runtime_lib) {\n            libname = stringConstPtr(emission_context, irbuilder, f_lib);\n        }\n        else {\n            // f_lib is actually one of the special sentinel values\n            libname = ConstantExpr::getIntToPtr(ConstantInt::get(T_size, (uintptr_t)f_lib), T_pint8);\n        }\n        llvmf = irbuilder.CreateCall(prepare_call_in(jl_builderModule(irbuilder), jldlsym_func),\n                    { libname, nameval, libptrgv });\n    }\n    StoreInst *store = irbuilder.CreateAlignedStore(llvmf, llvmgv, Align(sizeof(void*)));\n    store->setAtomic(AtomicOrdering::Release);\n    irbuilder.CreateBr(ccall_bb);\n\n    f->getBasicBlockList().push_back(ccall_bb);\n    irbuilder.SetInsertPoint(ccall_bb);\n    PHINode *p = irbuilder.CreatePHI(T_pvoidfunc, 2);\n    p->addIncoming(llvmf_orig, enter_bb);\n    p->addIncoming(llvmf, llvmf->getParent());\n    return irbuilder.CreateBitCast(p, funcptype);\n}\n\nstatic Value *runtime_sym_lookup(\n        jl_codectx_t &ctx,\n        PointerType *funcptype, const char *f_lib, jl_value_t *lib_expr,\n        const char *f_name, Function *f,\n        GlobalVariable *libptrgv,\n        GlobalVariable *llvmgv, bool runtime_lib)\n{\n    return runtime_sym_lookup(ctx.emission_context, ctx.builder, &ctx, funcptype, f_lib, lib_expr,\n                              f_name, f, libptrgv, llvmgv, runtime_lib);\n}\n\nstatic Value *runtime_sym_lookup(\n        jl_codectx_t &ctx,\n        PointerType *funcptype, const char *f_lib, jl_value_t *lib_expr,\n        const char *f_name, Function *f)\n{\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    bool runtime_lib;\n    if (lib_expr) {\n        // for computed library names, generate a global variable to cache the function\n        // pointer just for this call site.\n        runtime_lib = true;\n        libptrgv = NULL;\n        std::string gvname = \"libname_\";\n        gvname += f_name;\n        gvname += \"_\";\n        gvname += std::to_string(globalUnique++);\n        llvmgv = new GlobalVariable(*jl_Module, T_pvoidfunc, false,\n                                    GlobalVariable::ExternalLinkage,\n                                    Constant::getNullValue(T_pvoidfunc), gvname);\n    }\n    else {\n        runtime_lib = runtime_sym_gvs(ctx.emission_context, f_lib, f_name, libptrgv, llvmgv);\n        libptrgv = prepare_global_in(jl_Module, libptrgv);\n    }\n    llvmgv = prepare_global_in(jl_Module, llvmgv);\n    return runtime_sym_lookup(ctx, funcptype, f_lib, lib_expr, f_name, f, libptrgv, llvmgv, runtime_lib);\n}\n\n// Emit a \"PLT\" entry that will be lazily initialized\n// when being called the first time.\nstatic GlobalVariable *emit_plt_thunk(\n        jl_codegen_params_t &emission_context,\n        FunctionType *functype, const AttributeList &attrs,\n        CallingConv::ID cc, const char *f_lib, const char *f_name,\n        GlobalVariable *libptrgv, GlobalVariable *llvmgv,\n        bool runtime_lib)\n{\n    Module *M = emission_context.shared_module(jl_LLVMContext);\n    PointerType *funcptype = PointerType::get(functype, 0);\n    libptrgv = prepare_global_in(M, libptrgv);\n    llvmgv = prepare_global_in(M, llvmgv);\n    std::string fname;\n    raw_string_ostream(fname) << \"jlplt_\" << f_name << \"_\" << globalUnique++;\n    Function *plt = Function::Create(functype,\n                                     GlobalVariable::ExternalLinkage,\n                                     fname, M);\n    plt->setAttributes(attrs);\n    if (cc != CallingConv::C)\n        plt->setCallingConv(cc);\n    fname += \"_got\";\n    GlobalVariable *got = new GlobalVariable(*M, T_pvoidfunc, false,\n                                             GlobalVariable::ExternalLinkage,\n                                             ConstantExpr::getBitCast(plt, T_pvoidfunc),\n                                             fname);\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", plt);\n    IRBuilder<> irbuilder(b0);\n    Value *ptr = runtime_sym_lookup(emission_context, irbuilder, NULL, funcptype, f_lib, NULL, f_name, plt, libptrgv,\n                                    llvmgv, runtime_lib);\n    StoreInst *store = irbuilder.CreateAlignedStore(irbuilder.CreateBitCast(ptr, T_pvoidfunc), got, Align(sizeof(void*)));\n    store->setAtomic(AtomicOrdering::Release);\n    SmallVector<Value*, 16> args;\n    for (Function::arg_iterator arg = plt->arg_begin(), arg_e = plt->arg_end(); arg != arg_e; ++arg)\n        args.push_back(&*arg);\n    CallInst *ret = irbuilder.CreateCall(\n        cast<FunctionType>(ptr->getType()->getPointerElementType()),\n        ptr, ArrayRef<Value*>(args));\n    ret->setAttributes(attrs);\n    if (cc != CallingConv::C)\n        ret->setCallingConv(cc);\n    // NoReturn function can trigger LLVM verifier error when declared as\n    // MustTail since other passes might replace the `ret` with\n    // `unreachable` (LLVM should probably accept `unreachable`).\n    if (attrs.hasAttribute(AttributeList::FunctionIndex,\n                           Attribute::NoReturn)) {\n        irbuilder.CreateUnreachable();\n    }\n    else {\n        // musttail support is very bad on ARM, PPC, PPC64 (as of LLVM 3.9)\n        // Known failures includes vararg (not needed here) and sret.\n#if (defined(_CPU_X86_) || defined(_CPU_X86_64_) || \\\n                        defined(_CPU_AARCH64_))\n        // Ref https://bugs.llvm.org/show_bug.cgi?id=47058\n        // LLVM, as of 10.0.1 emits wrong/worse code when musttail is set\n        if (!attrs.hasAttrSomewhere(Attribute::ByVal))\n            ret->setTailCallKind(CallInst::TCK_MustTail);\n#endif\n        if (functype->getReturnType() == T_void) {\n            irbuilder.CreateRetVoid();\n        }\n        else {\n            irbuilder.CreateRet(ret);\n        }\n    }\n    irbuilder.ClearInsertionPoint();\n\n    return got;\n}\n\nstatic Value *emit_plt(\n        jl_codectx_t &ctx,\n        FunctionType *functype,\n        const AttributeList &attrs,\n        CallingConv::ID cc, const char *f_lib, const char *f_name)\n{\n    assert(imaging_mode);\n    // Don't do this for vararg functions so that the `musttail` is only\n    // an optimization and is not required to function correctly.\n    assert(!functype->isVarArg());\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    bool runtime_lib = runtime_sym_gvs(ctx.emission_context, f_lib, f_name, libptrgv, llvmgv);\n    PointerType *funcptype = PointerType::get(functype, 0);\n\n    auto &pltMap = ctx.emission_context.allPltMap[attrs];\n    auto key = std::make_tuple(llvmgv, functype, cc);\n    GlobalVariable *&sharedgot = pltMap[key];\n    if (!sharedgot) {\n        sharedgot = emit_plt_thunk(ctx.emission_context,\n                functype, attrs, cc, f_lib, f_name, libptrgv, llvmgv, runtime_lib);\n    }\n    GlobalVariable *got = prepare_global_in(jl_Module, sharedgot);\n    LoadInst *got_val = ctx.builder.CreateAlignedLoad(got, Align(sizeof(void*)));\n    // See comment in `runtime_sym_lookup` above. This in principle needs a\n    // consume ordering too. This is even less likely to cause issues though\n    // since the only thing we do to this loaded pointer is to call it\n    // immediately.\n    got_val->setAtomic(AtomicOrdering::Unordered);\n    return ctx.builder.CreateBitCast(got_val, funcptype);\n}\n\n// --- ABI Implementations ---\n// Partially based on the LDC ABI implementations licensed under the BSD 3-clause license\n\nclass AbiLayout {\npublic:\n    virtual ~AbiLayout() {}\n    virtual bool use_sret(jl_datatype_t *ty) = 0;\n    virtual bool needPassByRef(jl_datatype_t *ty, AttrBuilder&) = 0;\n    virtual Type *preferred_llvm_type(jl_datatype_t *ty, bool isret) const = 0;\n};\n\n// Determine if object of bitstype ty maps to a native x86 SIMD type (__m128, __m256, or __m512) in C\nstatic bool is_native_simd_type(jl_datatype_t *dt) {\n    size_t size = jl_datatype_size(dt);\n    if (size != 16 && size != 32 && size != 64)\n        // Wrong size for xmm, ymm, or zmm register.\n        return false;\n    uint32_t n = jl_datatype_nfields(dt);\n    if (n<2)\n        // Not mapped to SIMD register.\n        return false;\n    jl_value_t *ft0 = jl_field_type(dt, 0);\n    for (uint32_t i = 1; i < n; ++i)\n        if (jl_field_type(dt, i) != ft0)\n            // Not homogeneous\n            return false;\n    // Type is homogeneous.  Check if it maps to LLVM vector.\n    return jl_special_vector_alignment(n, ft0) != 0;\n}\n\n#include \"abi_llvm.cpp\"\n\n#include \"abi_arm.cpp\"\n#include \"abi_aarch64.cpp\"\n#include \"abi_ppc64le.cpp\"\n#include \"abi_win32.cpp\"\n#include \"abi_win64.cpp\"\n#include \"abi_x86_64.cpp\"\n#include \"abi_x86.cpp\"\n\n#if defined ABI_LLVM\n  typedef ABI_LLVMLayout DefaultAbiState;\n#elif defined _CPU_X86_64_\n#  if defined _OS_WINDOWS_\n     typedef ABI_Win64Layout DefaultAbiState;\n#  else\n     typedef ABI_x86_64Layout DefaultAbiState;\n#  endif\n#elif defined _CPU_X86_\n#  if defined _OS_WINDOWS_\n     typedef ABI_Win32Layout DefaultAbiState;\n#  else\n     typedef ABI_x86Layout DefaultAbiState;\n#  endif\n#elif defined _CPU_ARM_\n  typedef ABI_ARMLayout DefaultAbiState;\n#elif defined _CPU_AARCH64_\n  typedef ABI_AArch64Layout DefaultAbiState;\n#elif defined _CPU_PPC64_\n  typedef ABI_PPC64leLayout DefaultAbiState;\n#else\n#  warning \"ccall is defaulting to llvm ABI, since no platform ABI has been defined for this CPU/OS combination\"\n  typedef ABI_LLVMLayout DefaultAbiState;\n#endif\n\n// basic type widening and cast conversions\nstatic Value *llvm_type_rewrite(\n        jl_codectx_t &ctx,\n        Value *v, Type *target_type,\n        bool issigned) /* determines whether an integer value should be zero or sign extended */\n{\n    Type *from_type = v->getType();\n    if (target_type == from_type)\n        return v;\n\n    if (from_type == T_void || isa<UndefValue>(v))\n        return UndefValue::get(target_type); // convert undef (unreachable) -> undef (target_type)\n\n    assert(from_type->isPointerTy() == target_type->isPointerTy()); // expect that all ABIs consider all pointers to be equivalent\n    if (target_type->isPointerTy())\n        return emit_bitcast(ctx, v, target_type);\n\n    // simple integer and float widening & conversion cases\n    if (from_type->getPrimitiveSizeInBits() > 0 &&\n            target_type->getPrimitiveSizeInBits() == from_type->getPrimitiveSizeInBits())\n        return emit_bitcast(ctx, v, target_type);\n\n    if (target_type->isFloatingPointTy() && from_type->isFloatingPointTy()) {\n        if (target_type->getPrimitiveSizeInBits() > from_type->getPrimitiveSizeInBits())\n            return ctx.builder.CreateFPExt(v, target_type);\n        else if (target_type->getPrimitiveSizeInBits() < from_type->getPrimitiveSizeInBits())\n            return ctx.builder.CreateFPTrunc(v, target_type);\n        else\n            return v;\n    }\n\n    if (target_type->isIntegerTy() && from_type->isIntegerTy()) {\n        if (issigned)\n            return ctx.builder.CreateSExtOrTrunc(v, target_type);\n        else\n            return ctx.builder.CreateZExtOrTrunc(v, target_type);\n    }\n\n    // one or both of from_type and target_type is a VectorType or AggregateType\n    // LLVM doesn't allow us to cast these values directly, so\n    // we need to use this alloca copy trick instead\n    // On ARM and AArch64, the ABI requires casting through memory to different\n    // sizes.\n    Value *from;\n    Value *to;\n    const DataLayout &DL = jl_data_layout;\n    unsigned align = std::max(DL.getPrefTypeAlignment(target_type), DL.getPrefTypeAlignment(from_type));\n    if (DL.getTypeAllocSize(target_type) >= DL.getTypeAllocSize(from_type)) {\n        to = emit_static_alloca(ctx, target_type);\n        cast<AllocaInst>(to)->setAlignment(Align(align));\n        from = emit_bitcast(ctx, to, from_type->getPointerTo());\n    }\n    else {\n        from = emit_static_alloca(ctx, from_type);\n        cast<AllocaInst>(from)->setAlignment(Align(align));\n        to = emit_bitcast(ctx, from, target_type->getPointerTo());\n    }\n    ctx.builder.CreateAlignedStore(v, from, Align(align));\n    return ctx.builder.CreateAlignedLoad(to, Align(align));\n}\n\n// --- argument passing and scratch space utilities ---\n\n// Returns T_prjlvalue\nstatic Value *runtime_apply_type_env(jl_codectx_t &ctx, jl_value_t *ty)\n{\n    // box if concrete type was not statically known\n    Value *args[] = {\n        literal_pointer_val(ctx, ty),\n        literal_pointer_val(ctx, (jl_value_t*)ctx.linfo->def.method->sig),\n        ctx.builder.CreateInBoundsGEP(\n                T_prjlvalue,\n                ctx.spvals_ptr,\n                ConstantInt::get(T_size, sizeof(jl_svec_t) / sizeof(jl_value_t*)))\n    };\n    auto call = ctx.builder.CreateCall(prepare_call(jlapplytype_func), makeArrayRef(args));\n    call->addAttribute(AttributeList::ReturnIndex,\n                       Attribute::getWithAlignment(jl_LLVMContext, Align(16)));\n    return call;\n}\n\nstatic const std::string make_errmsg(const char *fname, int n, const char *err)\n{\n    std::string _msg;\n    raw_string_ostream msg(_msg);\n    msg << fname;\n    if (n > 0)\n        msg << \" argument \" << n;\n    else\n        msg << \" return\";\n    msg << err;\n    return msg.str();\n}\n\nstatic void typeassert_input(jl_codectx_t &ctx, const jl_cgval_t &jvinfo, jl_value_t *jlto, jl_unionall_t *jlto_env, int argn)\n{\n    if (jlto != (jl_value_t*)jl_any_type && !jl_subtype(jvinfo.typ, jlto)) {\n        if (jlto == (jl_value_t*)jl_voidpointer_type) {\n            // allow a bit more flexibility for what can be passed to (void*) due to Ref{T} conversion behavior in input\n            if (!jl_is_cpointer_type(jvinfo.typ)) {\n                // emit a typecheck, if not statically known to be correct\n                emit_cpointercheck(ctx, jvinfo, make_errmsg(\"ccall\", argn + 1, \"\"));\n            }\n        }\n        else {\n            // emit a typecheck, if not statically known to be correct\n            std::string msg = make_errmsg(\"ccall\", argn + 1, \"\");\n            if (!jlto_env || !jl_has_typevar_from_unionall(jlto, jlto_env)) {\n                emit_typecheck(ctx, jvinfo, jlto, msg);\n            }\n            else {\n                jl_cgval_t jlto_runtime = mark_julia_type(ctx, runtime_apply_type_env(ctx, jlto), true, jl_any_type);\n                Value *vx = boxed(ctx, jvinfo);\n                Value *istype = ctx.builder.CreateICmpNE(\n                        ctx.builder.CreateCall(prepare_call(jlisa_func), { vx, boxed(ctx, jlto_runtime) }),\n                        ConstantInt::get(T_int32, 0));\n                BasicBlock *failBB = BasicBlock::Create(jl_LLVMContext, \"fail\", ctx.f);\n                BasicBlock *passBB = BasicBlock::Create(jl_LLVMContext, \"pass\", ctx.f);\n                ctx.builder.CreateCondBr(istype, passBB, failBB);\n\n                ctx.builder.SetInsertPoint(failBB);\n                emit_type_error(ctx, mark_julia_type(ctx, vx, true, jl_any_type), boxed(ctx, jlto_runtime), msg);\n                ctx.builder.CreateUnreachable();\n                ctx.builder.SetInsertPoint(passBB);\n            }\n        }\n    }\n}\n\n// Emit code to convert argument to form expected by C ABI\n// to = desired LLVM type\n// jlto = Julia type of formal argument\n// jvinfo = value of actual argument\nstatic Value *julia_to_native(\n        jl_codectx_t &ctx,\n        Type *to, bool toboxed, jl_value_t *jlto, jl_unionall_t *jlto_env,\n        const jl_cgval_t &jvinfo,\n        bool byRef, int argn)\n{\n    // We're passing Any\n    if (toboxed) {\n        assert(!byRef); // don't expect any ABI to pass pointers by pointer\n        return boxed(ctx, jvinfo);\n    }\n    assert(jl_is_datatype(jlto) && julia_struct_has_layout((jl_datatype_t*)jlto, jlto_env));\n\n    typeassert_input(ctx, jvinfo, jlto, jlto_env, argn);\n    if (!byRef)\n        return emit_unbox(ctx, to, jvinfo, jlto);\n\n    // pass the address of an alloca'd thing, not a box\n    // since those are immutable.\n    Value *slot = emit_static_alloca(ctx, to);\n    if (!jvinfo.ispointer()) {\n        tbaa_decorate(jvinfo.tbaa, ctx.builder.CreateStore(emit_unbox(ctx, to, jvinfo, jlto), slot));\n    }\n    else {\n        emit_memcpy(ctx, slot, jvinfo.tbaa, jvinfo, jl_datatype_size(jlto), julia_alignment(jlto));\n    }\n    return slot;\n}\n\ntypedef struct {\n    Value *jl_ptr;  // if the argument is a run-time computed pointer\n    void (*fptr)(void);     // if the argument is a constant pointer\n    const char *f_name;   // if the symbol name is known\n    const char *f_lib;    // if a library name is specified\n    jl_value_t *lib_expr; // expression to compute library path lazily\n    jl_value_t *gcroot;\n} native_sym_arg_t;\n\n// --- parse :sym or (:sym, :lib) argument into address info ---\nstatic void interpret_symbol_arg(jl_codectx_t &ctx, native_sym_arg_t &out, jl_value_t *arg, const char *fname, bool llvmcall)\n{\n    Value *&jl_ptr = out.jl_ptr;\n    void (*&fptr)(void) = out.fptr;\n    const char *&f_name = out.f_name;\n    const char *&f_lib = out.f_lib;\n\n    jl_value_t *ptr = static_eval(ctx, arg);\n    if (ptr == NULL) {\n        if (jl_is_expr(arg) && ((jl_expr_t*)arg)->head == call_sym && jl_expr_nargs(arg) == 3 &&\n            jl_is_globalref(jl_exprarg(arg,0)) && jl_globalref_mod(jl_exprarg(arg,0)) == jl_core_module &&\n            jl_globalref_name(jl_exprarg(arg,0)) == jl_symbol(\"tuple\")) {\n            // attempt to interpret a non-constant 2-tuple expression as (func_name, lib_name()), where\n            // `lib_name()` will be executed when first used.\n            jl_value_t *name_val = static_eval(ctx, jl_exprarg(arg,1));\n            if (name_val && jl_is_symbol(name_val)) {\n                f_name = jl_symbol_name((jl_sym_t*)name_val);\n                out.lib_expr = jl_exprarg(arg, 2);\n                return;\n            }\n            else if (name_val && jl_is_string(name_val)) {\n                f_name = jl_string_data(name_val);\n                out.gcroot = name_val;\n                out.lib_expr = jl_exprarg(arg, 2);\n                return;\n            }\n        }\n        jl_cgval_t arg1 = emit_expr(ctx, arg);\n        jl_value_t *ptr_ty = arg1.typ;\n        if (!jl_is_cpointer_type(ptr_ty)) {\n            const char *errmsg = !strcmp(fname, \"ccall\") ?\n                \"ccall: first argument not a pointer or valid constant expression\" :\n                \"cglobal: first argument not a pointer or valid constant expression\";\n            emit_cpointercheck(ctx, arg1, errmsg);\n        }\n        arg1 = update_julia_type(ctx, arg1, (jl_value_t*)jl_voidpointer_type);\n        jl_ptr = emit_unbox(ctx, T_size, arg1, (jl_value_t*)jl_voidpointer_type);\n    }\n    else {\n        out.gcroot = ptr;\n        if (jl_is_tuple(ptr) && jl_nfields(ptr) == 1) {\n            ptr = jl_fieldref(ptr, 0);\n        }\n\n        if (jl_is_symbol(ptr))\n            f_name = jl_symbol_name((jl_sym_t*)ptr);\n        else if (jl_is_string(ptr))\n            f_name = jl_string_data(ptr);\n\n        if (f_name != NULL) {\n            // just symbol, default to JuliaDLHandle\n            // will look in process symbol table\n#ifdef _OS_WINDOWS_\n            if (!llvmcall)\n                f_lib = jl_dlfind_win32(f_name);\n#endif\n        }\n        else if (jl_is_cpointer_type(jl_typeof(ptr))) {\n            fptr = *(void(**)(void))jl_data_ptr(ptr);\n        }\n        else if (jl_is_tuple(ptr) && jl_nfields(ptr) > 1) {\n            jl_value_t *t0 = jl_fieldref(ptr, 0);\n            if (jl_is_symbol(t0))\n                f_name = jl_symbol_name((jl_sym_t*)t0);\n            else if (jl_is_string(t0))\n                f_name = jl_string_data(t0);\n            else\n                JL_TYPECHKS(fname, symbol, t0);\n\n            jl_value_t *t1 = jl_fieldref(ptr, 1);\n            if (jl_is_symbol(t1))\n                f_lib = jl_symbol_name((jl_sym_t*)t1);\n            else if (jl_is_string(t1))\n                f_lib = jl_string_data(t1);\n            else\n                JL_TYPECHKS(fname, symbol, t1);\n        }\n        else {\n            JL_TYPECHKS(fname, pointer, ptr);\n        }\n    }\n}\n\n// --- code generator for cglobal ---\n\nstatic jl_cgval_t emit_runtime_call(jl_codectx_t &ctx, JL_I::intrinsic f, const jl_cgval_t *argv, size_t nargs);\n\nstatic jl_cgval_t emit_cglobal(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n{\n    JL_NARGS(cglobal, 1, 2);\n    jl_value_t *rt = NULL;\n    Value *res;\n    native_sym_arg_t sym = {};\n    JL_GC_PUSH2(&rt, &sym.gcroot);\n\n    if (nargs == 2) {\n        rt = static_eval(ctx, args[2]);\n        if (rt == NULL) {\n            JL_GC_POP();\n            jl_cgval_t argv[2];\n            argv[0] = emit_expr(ctx, args[1]);\n            argv[1] = emit_expr(ctx, args[2]);\n            return emit_runtime_call(ctx, JL_I::cglobal, argv, nargs);\n        }\n\n        JL_TYPECHK(cglobal, type, rt);\n        rt = (jl_value_t*)jl_apply_type1((jl_value_t*)jl_pointer_type, rt);\n    }\n    else {\n        rt = (jl_value_t*)jl_voidpointer_type;\n    }\n    Type *lrt = T_size;\n    assert(lrt == julia_type_to_llvm(ctx, rt));\n\n    interpret_symbol_arg(ctx, sym, args[1], \"cglobal\", false);\n\n    if (sym.jl_ptr != NULL) {\n        res = ctx.builder.CreateBitCast(sym.jl_ptr, lrt);\n    }\n    else if (sym.fptr != NULL) {\n        res = ConstantInt::get(lrt, (uint64_t)sym.fptr);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in cglobal for %s; code cannot be statically compiled\\n\", sym.f_name);\n    }\n    else {\n        if (sym.lib_expr) {\n            res = runtime_sym_lookup(ctx, cast<PointerType>(T_pint8), NULL, sym.lib_expr, sym.f_name, ctx.f);\n        }\n        else if (imaging_mode) {\n            res = runtime_sym_lookup(ctx, cast<PointerType>(T_pint8), sym.f_lib, NULL, sym.f_name, ctx.f);\n            res = ctx.builder.CreatePtrToInt(res, lrt);\n        }\n        else {\n            void *symaddr;\n\n            void* libsym = jl_get_library_(sym.f_lib, 0);\n            if (!libsym || !jl_dlsym(libsym, sym.f_name, &symaddr, 0)) {\n                // Error mode, either the library or the symbol couldn't be find during compiletime.\n                // Fallback to a runtime symbol lookup.\n                res = runtime_sym_lookup(ctx, cast<PointerType>(T_pint8), sym.f_lib, NULL, sym.f_name, ctx.f);\n                res = ctx.builder.CreatePtrToInt(res, lrt);\n            } else {\n                // since we aren't saving this code, there's no sense in\n                // putting anything complicated here: just JIT the address of the cglobal\n                res = ConstantInt::get(lrt, (uint64_t)symaddr);\n            }\n        }\n    }\n\n    JL_GC_POP();\n    return mark_julia_type(ctx, res, false, rt);\n}\n\n// --- code generator for llvmcall ---\n\nstatic jl_cgval_t emit_llvmcall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n{\n    // parse and validate arguments\n    //\n    // two forms of llvmcall are supported:\n    // - llvmcall(ir, (rettypes...), (argtypes...), args...)\n    //   where `ir` represents IR that should be pasted in a function body\n    // - llvmcall((mod, fn), (rettypes...), (argtypes...), args...)\n    //   where `mod` represents the assembly of an entire LLVM module,\n    //   and `fn` the name of the function to call\n    JL_NARGSV(llvmcall, 3);\n    jl_value_t *rt = NULL, *at = NULL, *ir = NULL, *entry = NULL;\n    jl_value_t *ir_arg = args[1];\n    JL_GC_PUSH4(&ir, &rt, &at, &entry);\n    if (jl_is_ssavalue(ir_arg))\n        ir_arg = jl_arrayref((jl_array_t*)ctx.source->code, ((jl_ssavalue_t*)ir_arg)->id - 1);\n    ir = static_eval(ctx, ir_arg);\n    if (!ir) {\n        emit_error(ctx, \"error statically evaluating llvm IR argument\");\n        return jl_cgval_t();\n    }\n    if (jl_is_ssavalue(args[2]) && !jl_is_long(ctx.source->ssavaluetypes)) {\n        jl_value_t *rtt = jl_arrayref((jl_array_t*)ctx.source->ssavaluetypes, ((jl_ssavalue_t*)args[2])->id - 1);\n        if (jl_is_type_type(rtt))\n            rt = jl_tparam0(rtt);\n    }\n    if (!rt) {\n        rt = static_eval(ctx, args[2]);\n        if (!rt) {\n            emit_error(ctx, \"error statically evaluating llvmcall return type\");\n            return jl_cgval_t();\n        }\n    }\n    if (jl_is_ssavalue(args[3]) && !jl_is_long(ctx.source->ssavaluetypes)) {\n        jl_value_t *att = jl_arrayref((jl_array_t*)ctx.source->ssavaluetypes, ((jl_ssavalue_t*)args[3])->id - 1);\n        if (jl_is_type_type(att))\n            at = jl_tparam0(att);\n    }\n    if (!at) {\n        at = static_eval(ctx, args[3]);\n        if (!at) {\n            emit_error(ctx, \"error statically evaluating llvmcall argument tuple\");\n            return jl_cgval_t();\n        }\n    }\n    if (jl_is_tuple(ir)) {\n        // if the IR is a tuple, we expect (mod, fn)\n        if (jl_nfields(ir) != 2) {\n            emit_error(ctx, \"Tuple as first argument to llvmcall must have exactly two children\");\n            return jl_cgval_t();\n        }\n        entry = jl_fieldref(ir, 1);\n        if (!jl_is_string(entry)) {\n            emit_error(ctx, \"Function name passed to llvmcall must be a string\");\n            return jl_cgval_t();\n        }\n        ir = jl_fieldref(ir, 0);\n\n        if (!jl_is_string(ir) && !jl_typeis(ir, jl_array_uint8_type)) {\n            emit_error(ctx, \"Module IR passed to llvmcall must be a string or an array of bytes\");\n            return jl_cgval_t();\n        }\n    }\n    else {\n        if (!jl_is_string(ir)) {\n            emit_error(ctx, \"Function IR passed to llvmcall must be a string\");\n            return jl_cgval_t();\n        }\n    }\n\n    JL_TYPECHK(llvmcall, type, rt);\n    JL_TYPECHK(llvmcall, type, at);\n\n    // Generate arguments\n    std::string arguments;\n    raw_string_ostream argstream(arguments);\n    jl_svec_t *tt = ((jl_datatype_t*)at)->parameters;\n    jl_value_t *rtt = rt;\n    size_t nargt = jl_svec_len(tt);\n\n    /*\n     * Semantics for arguments are as follows:\n     * If the argument type is immutable (including bitstype), we pass the loaded llvm value\n     * type. Otherwise we pass a pointer to a jl_value_t.\n     */\n    std::vector<llvm::Type*> argtypes;\n    Value **argvals = (Value**)alloca(nargt * sizeof(Value*));\n    for (size_t i = 0; i < nargt; ++i) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        bool toboxed;\n        Type *t = julia_type_to_llvm(ctx, tti, &toboxed);\n        argtypes.push_back(t);\n        if (4 + i > nargs) {\n            emit_error(ctx, \"Missing arguments to llvmcall!\");\n            return jl_cgval_t();\n        }\n        jl_value_t *argi = args[4 + i];\n        jl_cgval_t arg = emit_expr(ctx, argi);\n\n        Value *v = julia_to_native(ctx, t, toboxed, tti, NULL, arg, false, i);\n        bool issigned = jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type);\n        argvals[i] = llvm_type_rewrite(ctx, v, t, issigned);\n    }\n\n    bool retboxed;\n    Type *rettype = julia_type_to_llvm(ctx, rtt, &retboxed);\n\n    // Make sure to find a unique name\n    std::string ir_name;\n    while (true) {\n        raw_string_ostream(ir_name) << (ctx.f->getName().str()) << \"u\" << globalUnique++;\n        if (jl_Module->getFunction(ir_name) == NULL)\n            break;\n    }\n\n    // generate a temporary module that contains our IR\n    std::unique_ptr<Module> Mod;\n    if (entry == NULL) {\n        // we only have function IR, which we should put in a function\n\n        bool first = true;\n        for (std::vector<Type *>::iterator it = argtypes.begin(); it != argtypes.end(); ++it) {\n            if (!first)\n                argstream << \",\";\n            else\n                first = false;\n            (*it)->print(argstream);\n            argstream << \" \";\n        }\n\n        std::string rstring;\n        raw_string_ostream rtypename(rstring);\n        rettype->print(rtypename);\n        std::map<uint64_t,std::string> localDecls;\n\n        std::string ir_string;\n        raw_string_ostream ir_stream(ir_string);\n        ir_stream << \"; Number of arguments: \" << nargt << \"\\n\"\n        << \"define \"<<rtypename.str()<<\" @\\\"\" << ir_name << \"\\\"(\"<<argstream.str()<<\") {\\n\"\n        << jl_string_data(ir) << \"\\n}\";\n\n        SMDiagnostic Err = SMDiagnostic();\n        Mod = parseAssemblyString(ir_stream.str(), Err, jl_LLVMContext);\n        if (!Mod) {\n            std::string message = \"Failed to parse LLVM assembly: \\n\";\n            raw_string_ostream stream(message);\n            Err.print(\"\", stream, true);\n            emit_error(ctx, stream.str());\n            return jl_cgval_t();\n        }\n\n        Function *f = Mod->getFunction(ir_name);\n        f->addFnAttr(Attribute::AlwaysInline);\n    }\n    else {\n        // we have the IR or bitcode of an entire module, which we can parse directly\n\n        if (jl_is_string(ir)) {\n            SMDiagnostic Err = SMDiagnostic();\n            Mod = parseAssemblyString(jl_string_data(ir), Err, jl_LLVMContext);\n            if (!Mod) {\n                std::string message = \"Failed to parse LLVM assembly: \\n\";\n                raw_string_ostream stream(message);\n                Err.print(\"\", stream, true);\n                emit_error(ctx, stream.str());\n                return jl_cgval_t();\n            }\n        }\n        else {\n            auto Buf = MemoryBuffer::getMemBuffer(\n                StringRef((char *)jl_array_data(ir), jl_array_len(ir)), \"llvmcall\",\n                /*RequiresNullTerminator*/ false);\n            Expected<std::unique_ptr<Module>> ModuleOrErr =\n                parseBitcodeFile(*Buf, jl_LLVMContext);\n            if (Error Err = ModuleOrErr.takeError()) {\n                std::string Message;\n                handleAllErrors(std::move(Err),\n                                [&](ErrorInfoBase &EIB) { Message = EIB.message(); });\n                std::string message = \"Failed to parse LLVM bitcode: \\n\";\n                raw_string_ostream stream(message);\n                stream << Message;\n                emit_error(ctx, stream.str());\n                return jl_cgval_t();\n            }\n            Mod = std::move(ModuleOrErr.get());\n        }\n\n        Function *f = Mod->getFunction(jl_string_data(entry));\n        if (!f) {\n            emit_error(ctx, \"Module IR does not contain specified entry function\");\n            return jl_cgval_t();\n        }\n        f->setName(ir_name);\n\n        // verify the function type\n        assert(!f->isDeclaration());\n        assert(f->getReturnType() == rettype);\n        int i = 0;\n        for (std::vector<Type *>::iterator it = argtypes.begin();\n            it != argtypes.end(); ++it, ++i)\n            assert(*it == f->getFunctionType()->getParamType(i));\n    }\n\n    // copy module properties that should always match\n    Mod->setTargetTriple(jl_Module->getTargetTriple());\n    Mod->setDataLayout(jl_Module->getDataLayout());\n\n    // verify the definition\n    Function *def = Mod->getFunction(ir_name);\n    assert(def);\n    std::string message = \"Malformed LLVM function: \\n\";\n    raw_string_ostream stream(message);\n    if (verifyFunction(*def, &stream)) {\n        emit_error(ctx, stream.str());\n        return jl_cgval_t();\n    }\n    def->setLinkage(GlobalVariable::LinkOnceODRLinkage);\n\n    // generate a call\n    FunctionType *decl_typ = FunctionType::get(rettype, argtypes, def->isVarArg());\n    Function *decl = Function::Create(decl_typ, def->getLinkage(), def->getAddressSpace(),\n                                      def->getName(), jl_Module);\n    decl->setAttributes(def->getAttributes());\n    CallInst *inst = ctx.builder.CreateCall(decl, ArrayRef<Value *>(&argvals[0], nargt));\n\n    // save the module to be linked later.\n    // we cannot do this right now, because linking mutates the destination module,\n    // which might invalidate LLVM values cached in cgval_t's (specifically constant arrays)\n    ctx.llvmcall_modules.push_back(std::move(Mod));\n\n    JL_GC_POP();\n\n    if (inst->getType() != rettype) {\n        std::string message;\n        raw_string_ostream stream(message);\n        stream << \"llvmcall return type \" << *inst->getType()\n               << \" does not match declared return type\" << *rettype;\n        emit_error(ctx, stream.str());\n        return jl_cgval_t();\n    }\n\n    return mark_julia_type(ctx, inst, retboxed, rtt);\n}\n\n// --- code generator for ccall itself ---\n\n// Returns T_prjlvalue\nstatic Value *box_ccall_result(jl_codectx_t &ctx, Value *result, Value *runtime_dt, jl_value_t *rt)\n{\n    // XXX: need to handle parameterized zero-byte types (singleton)\n    const DataLayout &DL = jl_data_layout;\n    unsigned nb = DL.getTypeStoreSize(result->getType());\n    MDNode *tbaa = jl_is_mutable(rt) ? tbaa_mutab : tbaa_immut;\n    Value *strct = emit_allocobj(ctx, nb, runtime_dt);\n    init_bits_value(ctx, strct, result, tbaa);\n    return strct;\n}\n\nstatic jl_cgval_t mark_or_box_ccall_result(jl_codectx_t &ctx, Value *result, bool isboxed, jl_value_t *rt, jl_unionall_t *unionall, bool static_rt)\n{\n    if (!static_rt) {\n        assert(!isboxed && jl_is_datatype(rt) && ctx.spvals_ptr && unionall);\n        Value *runtime_dt = runtime_apply_type_env(ctx, rt);\n        // TODO: skip this check if rt is not a Tuple\n        emit_concretecheck(ctx, runtime_dt, \"ccall: return type must be a concrete DataType\");\n        Value *strct = box_ccall_result(ctx, result, runtime_dt, rt);\n        return mark_julia_type(ctx, strct, true, rt); // TODO: jl_rewrap_unionall(rt, unionall)\n    }\n    return mark_julia_type(ctx, result, isboxed, rt);\n}\n\nclass function_sig_t {\npublic:\n    std::vector<Type*> fargt; // vector of llvm output types (julia_struct_to_llvm) for arguments\n    std::vector<Type*> fargt_sig; // vector of ABI coercion types for call signature\n    std::vector<bool> fargt_isboxed; // vector of whether the llvm output type is a Julia-box for each argument\n    std::vector<bool> byRefList; // vector of \"byref\" parameters\n    AttributeList attributes; // vector of function call site attributes\n    Type *lrt; // input parameter of the llvm return type (from julia_struct_to_llvm)\n    bool retboxed; // input parameter indicating whether lrt is jl_value_t*\n    Type *prt; // out parameter of the llvm return type for the function signature\n    int sret; // out parameter for indicating whether return value has been moved to the first argument position\n    std::string err_msg;\n    CallingConv::ID cc; // calling convention ABI\n    bool llvmcall;\n    jl_svec_t *at; // svec of julia argument types\n    jl_value_t *rt; // julia return type\n    jl_unionall_t *unionall_env; // UnionAll environment for `at` and `rt`\n    size_t nccallargs; // number of actual arguments\n    size_t nreqargs; // number of required arguments in ccall function definition\n    jl_codegen_params_t *ctx;\n\n    function_sig_t(const char *fname, Type *lrt, jl_value_t *rt, bool retboxed, jl_svec_t *at, jl_unionall_t *unionall_env, size_t nreqargs, CallingConv::ID cc, bool llvmcall, jl_codegen_params_t *ctx)\n      : lrt(lrt), retboxed(retboxed),\n        prt(NULL), sret(0), cc(cc), llvmcall(llvmcall),\n        at(at), rt(rt), unionall_env(unionall_env),\n        nccallargs(jl_svec_len(at)), nreqargs(nreqargs),\n        ctx(ctx)\n    {\n        err_msg = generate_func_sig(fname);\n    }\n\n    FunctionType *functype() const {\n        assert(err_msg.empty());\n        if (nreqargs > 0)\n            return FunctionType::get(sret ? T_void : prt, makeArrayRef(fargt_sig).slice(0, nreqargs), true);\n        else\n            return FunctionType::get(sret ? T_void : prt, fargt_sig, false);\n    }\n\n    jl_cgval_t emit_a_ccall(\n            jl_codectx_t &ctx,\n            const native_sym_arg_t &symarg,\n            jl_cgval_t *argv,\n            SmallVector<Value*, 16> &gc_uses,\n            bool static_rt) const;\n\nprivate:\nstd::string generate_func_sig(const char *fname)\n{\n    assert(rt && !jl_is_abstract_ref_type(rt));\n\n    std::vector<AttrBuilder> paramattrs;\n    std::unique_ptr<AbiLayout> abi;\n    if (llvmcall)\n        abi.reset(new ABI_LLVMLayout());\n    else\n        abi.reset(new DefaultAbiState());\n    sret = 0;\n\n    if (type_is_ghost(lrt)) {\n        prt = lrt = T_void;\n        abi->use_sret(jl_nothing_type);\n    }\n    else {\n        if (!jl_is_datatype(rt) || ((jl_datatype_t*)rt)->layout == NULL || jl_is_cpointer_type(rt) || jl_is_array_type(rt) || retboxed) {\n            prt = lrt; // passed as pointer\n            abi->use_sret(jl_voidpointer_type);\n        }\n        else if (abi->use_sret((jl_datatype_t*)rt)) {\n            AttrBuilder retattrs = AttrBuilder();\n#if !defined(_OS_WINDOWS_) // llvm used to use the old mingw ABI, skipping this marking works around that difference\n#if JL_LLVM_VERSION < 120000\n            retattrs.addAttribute(Attribute::StructRet);\n#else\n            retattrs.addStructRetAttr(lrt);\n#endif\n#endif\n            retattrs.addAttribute(Attribute::NoAlias);\n            paramattrs.push_back(std::move(retattrs));\n            fargt_sig.push_back(PointerType::get(lrt, 0));\n            sret = 1;\n            prt = lrt;\n        }\n        else {\n            prt = abi->preferred_llvm_type((jl_datatype_t*)rt, true);\n            if (prt == NULL)\n                prt = lrt;\n        }\n    }\n\n    for (size_t i = 0; i < nccallargs; ++i) {\n        AttrBuilder ab;\n        jl_value_t *tti = jl_svecref(at, i);\n        Type *t = NULL;\n        bool isboxed;\n        if (jl_is_abstract_ref_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type;\n            t = T_pint8;\n            isboxed = false;\n        }\n        else if (llvmcall && jl_is_llvmpointer_type(tti)) {\n            t = bitstype_to_llvm(tti, true);\n            tti = (jl_value_t*)jl_voidpointer_type;\n            isboxed = false;\n        }\n        else {\n            if (jl_is_primitivetype(tti)) {\n                // see pull req #978. need to annotate signext/zeroext for\n                // small integer arguments.\n                jl_datatype_t *bt = (jl_datatype_t*)tti;\n                if (jl_datatype_size(bt) < 4 && bt != jl_float16_type) {\n                    if (jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type))\n                        ab.addAttribute(Attribute::SExt);\n                    else\n                        ab.addAttribute(Attribute::ZExt);\n                }\n            }\n\n            t = _julia_struct_to_llvm(ctx, tti, unionall_env, &isboxed, llvmcall);\n            if (t == NULL || t == T_void) {\n                return make_errmsg(fname, i + 1, \" doesn't correspond to a C type\");\n            }\n        }\n\n        Type *pat;\n        if (!jl_is_datatype(tti) || ((jl_datatype_t*)tti)->layout == NULL || jl_is_array_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type; // passed as pointer\n        }\n\n        // Whether or not LLVM wants us to emit a pointer to the data\n        bool byRef = abi->needPassByRef((jl_datatype_t*)tti, ab);\n\n        if (jl_is_cpointer_type(tti)) {\n            pat = t;\n        }\n        else if (byRef) {\n            pat = PointerType::get(t, AddressSpace::Derived);\n        }\n        else {\n            pat = abi->preferred_llvm_type((jl_datatype_t*)tti, false);\n            if (pat == NULL)\n                pat = t;\n        }\n\n        if (!byRef && nreqargs > 0 && i >= nreqargs) { // TODO: handle byRef case too?\n            // The C vararg ABI says that small types must get widened,\n            // but we don't really want to expect the user to know that,\n            // so attempt to do that coercion here\n            if (!llvmcall && cc == CallingConv::C) {\n                if (pat->isIntegerTy() && pat->getPrimitiveSizeInBits() < sizeof(int) * 8)\n                    pat = T_int32;\n                if (pat->isFloatingPointTy() && pat->getPrimitiveSizeInBits() < sizeof(double) * 8)\n                    pat = T_float64;\n                ab.removeAttribute(Attribute::SExt);\n                ab.removeAttribute(Attribute::ZExt);\n            }\n        }\n\n        byRefList.push_back(byRef);\n        fargt.push_back(t);\n        fargt_isboxed.push_back(isboxed);\n        fargt_sig.push_back(pat);\n        paramattrs.push_back(AttributeSet::get(jl_LLVMContext, ab));\n    }\n\n    for (size_t i = 0; i < nccallargs + sret; ++i) {\n        const auto &as = paramattrs.at(i);\n        if (!as.hasAttributes())\n            continue;\n        attributes = attributes.addAttributes(jl_LLVMContext, i + 1, as);\n    }\n    // If return value is boxed it must be non-null.\n    if (retboxed)\n        attributes = attributes.addAttribute(jl_LLVMContext, AttributeList::ReturnIndex,\n                                             Attribute::NonNull);\n    if (rt == jl_bottom_type) {\n        attributes = attributes.addAttribute(jl_LLVMContext,\n                                             AttributeList::FunctionIndex,\n                                             Attribute::NoReturn);\n    }\n    return \"\";\n}\n};\n\nstatic std::pair<CallingConv::ID, bool> convert_cconv(jl_sym_t *lhd)\n{\n    // check for calling convention specifier\n    if (lhd == jl_symbol(\"stdcall\")) {\n        return std::make_pair(CallingConv::X86_StdCall, false);\n    }\n    else if (lhd == jl_symbol(\"cdecl\") || lhd == jl_symbol(\"ccall\")) {\n        // `ccall` calling convention is a placeholder for when there isn't one provided\n        // it is not by itself a valid calling convention name to be specified in the surface\n        // syntax.\n        return std::make_pair(CallingConv::C, false);\n    }\n    else if (lhd == jl_symbol(\"fastcall\")) {\n        return std::make_pair(CallingConv::X86_FastCall, false);\n    }\n    else if (lhd == jl_symbol(\"thiscall\")) {\n        return std::make_pair(CallingConv::X86_ThisCall, false);\n    }\n    else if (lhd == jl_symbol(\"llvmcall\")) {\n        return std::make_pair(CallingConv::C, true);\n    }\n    jl_errorf(\"ccall: invalid calling convention %s\", jl_symbol_name(lhd));\n}\n\nstatic bool verify_ref_type(jl_codectx_t &ctx, jl_value_t* ref, jl_unionall_t *unionall_env, int n, const char *fname)\n{\n    // emit verification that the tparam for Ref isn't Any or a TypeVar\n    const char rt_err_msg_notany[] = \" type Ref{Any} is invalid. Use Any or Ptr{Any} instead.\";\n    if (ref == (jl_value_t*)jl_any_type && n == 0) {\n        emit_error(ctx, make_errmsg(fname, n, rt_err_msg_notany));\n        return false;\n    }\n    else if (jl_is_typevar(ref)) {\n        bool always_error = true;\n        if (unionall_env) {\n            int i;\n            jl_unionall_t *ua = unionall_env;\n            for (i = 0; jl_is_unionall(ua); i++) {\n                if (ua->var == (jl_tvar_t*)ref) {\n                    jl_cgval_t runtime_sp = emit_sparam(ctx, i);\n                    if (n > 0) {\n                        always_error = false;\n                    }\n                    else if (runtime_sp.constant) {\n                        if (runtime_sp.constant != (jl_value_t*)jl_any_type)\n                            always_error = false;\n                    }\n                    else {\n                        Value *notany = ctx.builder.CreateICmpNE(\n                                boxed(ctx, runtime_sp),\n                                track_pjlvalue(ctx, literal_pointer_val(ctx, (jl_value_t*)jl_any_type)));\n                        error_unless(ctx, notany, make_errmsg(fname, n, rt_err_msg_notany));\n                        always_error = false;\n                    }\n                    break;\n                }\n                ua = (jl_unionall_t*)ua->body;\n            }\n        }\n        if (always_error) {\n            emit_error(ctx, make_errmsg(fname, n, \" type Ref should have an element type, not Ref{<:T}.\"));\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic const std::string verify_ccall_sig(jl_value_t *&rt, jl_value_t *at,\n                                          jl_unionall_t *unionall_env, jl_svec_t *sparam_vals,\n                                          jl_codegen_params_t *ctx,\n                                          Type *&lrt, bool &retboxed, bool &static_rt, bool llvmcall=false)\n{\n    JL_TYPECHK(ccall, type, rt);\n    JL_TYPECHK(ccall, simplevector, at);\n\n    if (jl_is_array_type(rt)) {\n        // `Array` used as return type just returns a julia object reference\n        rt = (jl_value_t*)jl_any_type;\n    }\n\n    lrt = _julia_struct_to_llvm(ctx, rt, unionall_env, &retboxed, llvmcall);\n    if (lrt == NULL)\n        return \"return type doesn't correspond to a C type\";\n\n    // is return type fully statically known?\n    if (unionall_env == NULL) {\n        static_rt = true;\n    }\n    else {\n        static_rt = retboxed || !jl_has_typevar_from_unionall(rt, unionall_env);\n        if (!static_rt && sparam_vals != NULL && jl_svec_len(sparam_vals) > 0) {\n            rt = jl_instantiate_type_in_env(rt, unionall_env, jl_svec_data(sparam_vals));\n            // `rt` is gc-rooted by the caller\n            static_rt = true;\n        }\n    }\n\n    return \"\";\n}\n\n// Expr(:foreigncall, pointer, rettype, (argtypes...), nreq, cconv, args..., roots...)\nstatic jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n{\n    JL_NARGSV(ccall, 5);\n    args -= 1;\n    jl_value_t *rt = args[2];\n    jl_value_t *at = args[3];\n    size_t nccallargs = jl_svec_len(at);\n    size_t nreqargs = jl_unbox_long(args[4]); // if vararg\n    assert(jl_is_quotenode(args[5]));\n    jl_sym_t *cc_sym = *(jl_sym_t**)args[5];\n    assert(jl_is_symbol(cc_sym));\n    native_sym_arg_t symarg = {};\n    JL_GC_PUSH3(&rt, &at, &symarg.gcroot);\n\n    CallingConv::ID cc = CallingConv::C;\n    bool llvmcall = false;\n    std::tie(cc, llvmcall) = convert_cconv(cc_sym);\n\n    interpret_symbol_arg(ctx, symarg, args[1], \"ccall\", llvmcall);\n    Value *&jl_ptr = symarg.jl_ptr;\n    void (*&fptr)(void) = symarg.fptr;\n    const char *&f_name = symarg.f_name;\n    const char *&f_lib = symarg.f_lib;\n\n    if (f_name == NULL && fptr == NULL && jl_ptr == NULL) {\n        emit_error(ctx, \"ccall: null function pointer\");\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    auto ccallarg = [=] (size_t i) {\n        assert(i < nccallargs && i + 6 <= nargs);\n        return args[6 + i];\n    };\n\n    auto _is_libjulia_func = [&] (uintptr_t ptr, const char *name) {\n        if ((uintptr_t)fptr == ptr)\n            return true;\n        return (!f_lib || f_lib == JL_LIBJULIA_INTERNAL_DL_LIBNAME) && f_name && !strcmp(f_name, name);\n    };\n#define is_libjulia_func(name) _is_libjulia_func((uintptr_t)&(name), #name)\n\n    static jl_ptls_t (*ptls_getter)(void) = [] {\n    // directly accessing the address of an ifunc can cause compile-time linker issues\n    // on some configurations (e.g. AArch64 + -Bsymbolic-functions), so we guard the\n    // `&jl_get_ptls_states` within this `#ifdef` guard, and use a more roundabout\n    // method involving `jl_dlsym()` on Linux platforms instead.\n#ifdef _OS_LINUX_\n        jl_ptls_t (*p)(void);\n        void *handle = jl_dlopen(nullptr, 0);\n        jl_dlsym(handle, \"jl_get_ptls_states\", (void **)&p, 0);\n        jl_dlclose(handle);\n        return p;\n#else\n        return &jl_get_ptls_states;\n#endif\n    }();\n\n    // emit arguments\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nccallargs);\n    for (size_t i = 0; i < nccallargs; i++) {\n        // Julia (expression) value of current parameter\n        jl_value_t *argi = ccallarg(i);\n        argv[i] = emit_expr(ctx, argi);\n    }\n\n    // emit roots\n    SmallVector<Value*, 16> gc_uses;\n    for (size_t i = nccallargs + 6; i <= nargs; i++) {\n        // Julia (expression) value of current parameter gcroot\n        jl_value_t *argi_root = args[i];\n        if (jl_is_long(argi_root))\n            continue;\n        jl_cgval_t arg_root = emit_expr(ctx, argi_root);\n        Value *gc_root = get_gc_root_for(arg_root);\n        if (gc_root)\n            gc_uses.push_back(gc_root);\n    }\n\n    jl_unionall_t *unionall = (jl_is_method(ctx.linfo->def.method) && jl_is_unionall(ctx.linfo->def.method->sig))\n        ? (jl_unionall_t*)ctx.linfo->def.method->sig\n        : NULL;\n\n    if (jl_is_abstract_ref_type(rt)) {\n        if (!verify_ref_type(ctx, jl_tparam0(rt), unionall, 0, \"ccall\")) {\n            JL_GC_POP();\n            return jl_cgval_t();\n        }\n        rt = (jl_value_t*)jl_any_type; // convert return type to jl_value_t*\n    }\n\n    // some sanity checking and check whether there's a vararg\n    Type *lrt;\n    bool retboxed;\n    bool static_rt;\n    std::string err = verify_ccall_sig(\n      /* inputs:  */\n      rt, at, unionall,\n      ctx.spvals_ptr == NULL ? ctx.linfo->sparam_vals : NULL,\n      &ctx.emission_context,\n      /* outputs: */\n      lrt, retboxed, static_rt,\n      /* optional arguments */\n      llvmcall);\n    if (err.empty()) {\n        // some extra checks for ccall\n        if (!retboxed && static_rt) {\n            if (!jl_is_concrete_type(rt)) {\n                if (jl_is_cpointer_type(rt))\n                    err = \"return type Ptr should have an element type (not Ptr{<:T})\";\n                else if (rt != jl_bottom_type)\n                    err = \"return type must be a concrete DataType\";\n            }\n        }\n        assert(jl_svec_len(at) >= nreqargs);\n    }\n    if (!err.empty()) {\n        emit_error(ctx, \"ccall \" + err);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n    if (rt != args[2] && rt != (jl_value_t*)jl_any_type)\n        jl_add_method_root(ctx, rt);\n    function_sig_t sig(\"ccall\", lrt, rt, retboxed,\n                       (jl_svec_t*)at, unionall, nreqargs,\n                       cc, llvmcall, &ctx.emission_context);\n    for (size_t i = 0; i < nccallargs; i++) {\n        jl_value_t *tti = jl_svecref(at, i);\n        if (jl_is_abstract_ref_type(tti)) {\n            if (!verify_ref_type(ctx, jl_tparam0(tti), unionall, i + 1, \"ccall\")) {\n                JL_GC_POP();\n                return jl_cgval_t();\n            }\n        }\n    }\n\n    // some special functions\n    bool isVa = nreqargs > 0;\n    (void)isVa; // prevent compiler warning\n    if (is_libjulia_func(jl_array_ptr)) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        const jl_cgval_t &ary = argv[0];\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, ctx.builder.CreatePtrToInt(emit_unsafe_arrayptr(ctx, ary), lrt),\n                                        retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_value_ptr)) {\n        assert(retboxed ? lrt == T_prjlvalue : lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        jl_value_t *tti = jl_svecref(at, 0);\n        Value *ary;\n        Type *largty;\n        bool isboxed;\n        if (jl_is_abstract_ref_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type;\n            largty = T_size;\n            isboxed = false;\n        }\n        else {\n            largty = _julia_struct_to_llvm(&ctx.emission_context, tti, unionall, &isboxed, llvmcall);\n        }\n        if (isboxed) {\n            ary = boxed(ctx, argv[0]);\n        }\n        else {\n            ary = emit_unbox(ctx, largty, argv[0], tti);\n        }\n        JL_GC_POP();\n        if (!retboxed) {\n            return mark_or_box_ccall_result(\n                    ctx,\n                    ctx.builder.CreatePtrToInt(\n                        emit_pointer_from_objref(ctx, emit_bitcast(ctx, ary, T_prjlvalue)),\n                        T_size),\n                    retboxed, rt, unionall, static_rt);\n        }\n        else {\n            return mark_or_box_ccall_result(\n                    ctx,\n                    ctx.builder.CreateAddrSpaceCast(\n                        emit_inttoptr(ctx, ary, T_pjlvalue),\n                        T_prjlvalue), // WARNING: this addrspace cast necessarily implies that the value is rooted elsewhere!\n                    retboxed, rt, unionall, static_rt);\n        }\n    }\n    else if (is_libjulia_func(jl_cpu_pause)) {\n        // Keep in sync with the julia_threads.h version\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n#ifdef __MIC__\n        // TODO\n#elif defined(_CPU_X86_64_) || defined(_CPU_X86_)  /* !__MIC__ */\n        static auto pauseinst = InlineAsm::get(FunctionType::get(T_void, false), \"pause\",\n                                               \"~{memory}\", true);\n        ctx.builder.CreateCall(pauseinst);\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#elif defined(_CPU_AARCH64_) || (defined(_CPU_ARM_) && __ARM_ARCH >= 7)\n        static auto wfeinst = InlineAsm::get(FunctionType::get(T_void, false), \"wfe\",\n                                             \"~{memory}\", true);\n        ctx.builder.CreateCall(wfeinst);\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#else\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#endif\n    }\n    else if (is_libjulia_func(jl_cpu_wake)) {\n        // Keep in sync with the julia_threads.h version\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n#if JL_CPU_WAKE_NOOP == 1\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#elif defined(_CPU_AARCH64_) || (defined(_CPU_ARM_) && __ARM_ARCH >= 7)\n        static auto sevinst = InlineAsm::get(FunctionType::get(T_void, false), \"sev\",\n                                             \"~{memory}\", true);\n        ctx.builder.CreateCall(sevinst);\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#endif\n    }\n    else if (is_libjulia_func(jl_gc_safepoint)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        ctx.builder.CreateCall(prepare_call(gcroot_flush_func));\n        emit_signal_fence(ctx);\n        ctx.builder.CreateLoad(T_size, ctx.signalPage, true);\n        emit_signal_fence(ctx);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (_is_libjulia_func((uintptr_t)ptls_getter, \"jl_get_ptls_states\")) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx,\n            ctx.builder.CreatePtrToInt(ctx.ptlsStates, lrt),\n            retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_threadid)) {\n        assert(lrt == T_int16);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        Value *ptls_i16 = emit_bitcast(ctx, ctx.ptlsStates, T_pint16);\n        const int tid_offset = offsetof(jl_tls_states_t, tid);\n        Value *ptid = ctx.builder.CreateInBoundsGEP(ptls_i16, ConstantInt::get(T_size, tid_offset / 2));\n        LoadInst *tid = ctx.builder.CreateAlignedLoad(ptid, Align(sizeof(int16_t)));\n        tbaa_decorate(tbaa_const, tid);\n        return mark_or_box_ccall_result(ctx, tid, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_gc_disable_finalizers_internal)\n#ifdef NDEBUG\n             || is_libjulia_func(jl_gc_enable_finalizers_internal)\n#endif\n             ) {\n        JL_GC_POP();\n        Value *ptls_i32 = emit_bitcast(ctx, ctx.ptlsStates, T_pint32);\n        const int finh_offset = offsetof(jl_tls_states_t, finalizers_inhibited);\n        Value *pfinh = ctx.builder.CreateInBoundsGEP(ptls_i32, ConstantInt::get(T_size, finh_offset / 4));\n        LoadInst *finh = ctx.builder.CreateAlignedLoad(pfinh, Align(sizeof(int32_t)));\n        Value *newval;\n        if (is_libjulia_func(jl_gc_disable_finalizers_internal)) {\n            newval = ctx.builder.CreateAdd(finh, ConstantInt::get(T_int32, 1));\n        }\n        else {\n            newval = ctx.builder.CreateSelect(ctx.builder.CreateICmpEQ(finh, ConstantInt::get(T_int32, 0)),\n                                              ConstantInt::get(T_int32, 0),\n                                              ctx.builder.CreateSub(finh, ConstantInt::get(T_int32, 1)));\n        }\n        ctx.builder.CreateStore(newval, pfinh);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (is_libjulia_func(jl_get_current_task)) {\n        assert(lrt == T_prjlvalue);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        Value *ptls_pv = emit_bitcast(ctx, ctx.ptlsStates, T_pprjlvalue);\n        const int ct_offset = offsetof(jl_tls_states_t, current_task);\n        Value *pct = ctx.builder.CreateInBoundsGEP(ptls_pv, ConstantInt::get(T_size, ct_offset / sizeof(void*)));\n        LoadInst *ct = ctx.builder.CreateAlignedLoad(pct, Align(sizeof(void*)));\n        tbaa_decorate(tbaa_const, ct);\n        return mark_or_box_ccall_result(ctx, ct, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_set_next_task)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        JL_GC_POP();\n        Value *ptls_pv = emit_bitcast(ctx, ctx.ptlsStates, T_ppjlvalue);\n        const int nt_offset = offsetof(jl_tls_states_t, next_task);\n        Value *pnt = ctx.builder.CreateInBoundsGEP(ptls_pv, ConstantInt::get(T_size, nt_offset / sizeof(void*)));\n        ctx.builder.CreateStore(emit_pointer_from_objref(ctx, boxed(ctx, argv[0])), pnt);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (is_libjulia_func(jl_sigatomic_begin)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        ctx.builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = ctx.builder.CreateLoad(pdefer_sig);\n        defer_sig = ctx.builder.CreateAdd(defer_sig, ConstantInt::get(T_sigatomic, 1));\n        ctx.builder.CreateStore(defer_sig, pdefer_sig);\n        emit_signal_fence(ctx);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (is_libjulia_func(jl_sigatomic_end)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        ctx.builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = ctx.builder.CreateLoad(pdefer_sig);\n        emit_signal_fence(ctx);\n        error_unless(ctx,\n                ctx.builder.CreateICmpNE(defer_sig, ConstantInt::get(T_sigatomic, 0)),\n                \"sigatomic_end called in non-sigatomic region\");\n        defer_sig = ctx.builder.CreateSub(\n                defer_sig,\n                ConstantInt::get(T_sigatomic, 1));\n        ctx.builder.CreateStore(defer_sig, pdefer_sig);\n        BasicBlock *checkBB = BasicBlock::Create(jl_LLVMContext, \"check\",\n                                                 ctx.f);\n        BasicBlock *contBB = BasicBlock::Create(jl_LLVMContext, \"cont\");\n        ctx.builder.CreateCondBr(\n                ctx.builder.CreateICmpEQ(defer_sig, ConstantInt::get(T_sigatomic, 0)),\n                checkBB, contBB);\n        ctx.builder.SetInsertPoint(checkBB);\n        ctx.builder.CreateLoad(\n                ctx.builder.CreateConstInBoundsGEP1_32(T_size, ctx.signalPage, -1),\n                true);\n        ctx.builder.CreateBr(contBB);\n        ctx.f->getBasicBlockList().push_back(contBB);\n        ctx.builder.SetInsertPoint(contBB);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (is_libjulia_func(jl_svec_len)) {\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        const jl_cgval_t &svecv = argv[0];\n        Value *len;\n        if (svecv.constant && svecv.typ == (jl_value_t*)jl_simplevector_type) {\n            // Check the type as well before we call\n            len = ConstantInt::get(T_size, jl_svec_len(svecv.constant));\n        }\n        else {\n            auto ptr = emit_bitcast(ctx, boxed(ctx, svecv), T_psize);\n            len = ctx.builder.CreateAlignedLoad(T_size, ptr, Align(sizeof(size_t)));\n            // Only mark with TBAA if we are sure about the type.\n            // This could otherwise be in a dead branch\n            if (svecv.typ == (jl_value_t*)jl_simplevector_type)\n                tbaa_decorate(tbaa_const, cast<Instruction>(len));\n            MDBuilder MDB(jl_LLVMContext);\n            auto rng = MDB.createRange(\n                V_size0, ConstantInt::get(T_size, INTPTR_MAX / sizeof(void*) - 1));\n            cast<LoadInst>(len)->setMetadata(LLVMContext::MD_range, rng);\n        }\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, len, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_svec_isassigned) &&\n             argv[1].typ == (jl_value_t*)jl_long_type) {\n        assert(!isVa && !llvmcall && nccallargs == 2);\n        const jl_cgval_t &svecv = argv[0];\n        const jl_cgval_t &idxv = argv[1];\n        Value *idx = emit_unbox(ctx, T_size, idxv, (jl_value_t*)jl_long_type);\n        idx = ctx.builder.CreateAdd(idx, ConstantInt::get(T_size, 1));\n        auto ptr = emit_bitcast(ctx, boxed(ctx, svecv), T_pprjlvalue);\n        Value *slot_addr = ctx.builder.CreateInBoundsGEP(T_prjlvalue,\n                                                         decay_derived(ctx, ptr), idx);\n        LoadInst *load = ctx.builder.CreateAlignedLoad(T_prjlvalue, slot_addr,\n                                                       Align(sizeof(void*)));\n        load->setAtomic(AtomicOrdering::Unordered);\n        // Only mark with TBAA if we are sure about the type.\n        // This could otherwise be in a dead branch\n        if (svecv.typ == (jl_value_t*)jl_simplevector_type)\n            tbaa_decorate(tbaa_const, load);\n        Value *res = ctx.builder.CreateZExt(ctx.builder.CreateICmpNE(load, V_rnull), T_int8);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, res, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_svec_ref) && argv[1].typ == (jl_value_t*)jl_long_type) {\n        assert(lrt == T_prjlvalue);\n        assert(!isVa && !llvmcall && nccallargs == 2);\n        const jl_cgval_t &svecv = argv[0];\n        const jl_cgval_t &idxv = argv[1];\n        Value *idx = emit_unbox(ctx, T_size, idxv, (jl_value_t*)jl_long_type);\n        idx = ctx.builder.CreateAdd(idx, ConstantInt::get(T_size, 1));\n        auto ptr = emit_bitcast(ctx, boxed(ctx, svecv), T_pprjlvalue);\n        Value *slot_addr = ctx.builder.CreateInBoundsGEP(T_prjlvalue,\n                                                         decay_derived(ctx, ptr), idx);\n        LoadInst *load = ctx.builder.CreateAlignedLoad(T_prjlvalue, slot_addr,\n                                                       Align(sizeof(void*)));\n        load->setAtomic(AtomicOrdering::Unordered);\n        // Only mark with TBAA if we are sure about the type.\n        // This could otherwise be in a dead branch\n        if (svecv.typ == (jl_value_t*)jl_simplevector_type)\n            tbaa_decorate(tbaa_const, load);\n        null_pointer_check(ctx, load);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, load, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_array_isassigned) &&\n             argv[1].typ == (jl_value_t*)jl_ulong_type) {\n        assert(!isVa && !llvmcall && nccallargs == 2);\n        jl_value_t *aryex = ccallarg(0);\n        const jl_cgval_t &aryv = argv[0];\n        const jl_cgval_t &idxv = argv[1];\n        jl_datatype_t *arydt = (jl_datatype_t*)jl_unwrap_unionall(aryv.typ);\n        if (jl_is_array_type(arydt)) {\n            jl_value_t *ety = jl_tparam0(arydt);\n            bool ptrarray = !jl_stored_inline(ety);\n            if (!ptrarray && !jl_type_hasptr(ety)) {\n                JL_GC_POP();\n                return mark_or_box_ccall_result(ctx, ConstantInt::get(T_int32, 1),\n                                                false, rt, unionall, static_rt);\n            }\n            else if (!jl_has_free_typevars(ety)) {\n                Value *idx = emit_unbox(ctx, T_size, idxv, (jl_value_t*)jl_ulong_type);\n                Value *arrayptr = emit_bitcast(ctx, emit_arrayptr(ctx, aryv, aryex), T_pprjlvalue);\n                if (!ptrarray) {\n                    size_t elsz = jl_datatype_size(ety);\n                    unsigned align = jl_datatype_align(ety);\n                    size_t stride = LLT_ALIGN(elsz, align) / sizeof(jl_value_t*);\n                    if (stride != 1)\n                        idx = ctx.builder.CreateMul(idx, ConstantInt::get(T_size, stride));\n                    idx = ctx.builder.CreateAdd(idx, ConstantInt::get(T_size, ((jl_datatype_t*)ety)->layout->first_ptr));\n                }\n                Value *slot_addr = ctx.builder.CreateInBoundsGEP(T_prjlvalue, arrayptr, idx);\n                LoadInst *load = ctx.builder.CreateAlignedLoad(T_prjlvalue, slot_addr, Align(sizeof(void*)));\n                load->setAtomic(AtomicOrdering::Unordered);\n                tbaa_decorate(tbaa_ptrarraybuf, load);\n                Value *res = ctx.builder.CreateZExt(ctx.builder.CreateICmpNE(load, V_rnull), T_int32);\n                JL_GC_POP();\n                return mark_or_box_ccall_result(ctx, res, retboxed, rt, unionall, static_rt);\n            }\n        }\n    }\n    else if (is_libjulia_func(jl_string_ptr)) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        auto obj = emit_bitcast(ctx, emit_pointer_from_objref(ctx, boxed(ctx, argv[0])),\n                                T_pprjlvalue);\n        // The inbounds gep makes it more clear to LLVM that the resulting value is not\n        // a null pointer.\n        auto strp = ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue, obj, 1);\n        strp = ctx.builder.CreatePtrToInt(strp, T_size);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, strp, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_symbol_name)) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        auto obj = emit_bitcast(ctx, emit_pointer_from_objref(ctx, boxed(ctx, argv[0])),\n                                T_pprjlvalue);\n        // The inbounds gep makes it more clear to LLVM that the resulting value is not\n        // a null pointer.\n        auto strp = ctx.builder.CreateConstInBoundsGEP1_32(\n            T_prjlvalue, obj, (sizeof(jl_sym_t) + sizeof(void*) - 1) / sizeof(void*));\n        strp = ctx.builder.CreatePtrToInt(strp, T_size);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, strp, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(memcpy) && (rt == (jl_value_t*)jl_nothing_type || jl_is_cpointer_type(rt))) {\n        const jl_cgval_t &dst = argv[0];\n        const jl_cgval_t &src = argv[1];\n        const jl_cgval_t &n = argv[2];\n        Value *destp = emit_unbox(ctx, T_size, dst, (jl_value_t*)jl_voidpointer_type);\n\n        ctx.builder.CreateMemCpy(\n                emit_inttoptr(ctx, destp, T_pint8),\n#if JL_LLVM_VERSION >= 100000\n                MaybeAlign(1),\n#else\n                1,\n#endif\n                emit_inttoptr(ctx,\n                    emit_unbox(ctx, T_size, src, (jl_value_t*)jl_voidpointer_type),\n                    T_pint8),\n#if JL_LLVM_VERSION >= 100000\n                MaybeAlign(0),\n#else\n                0,\n#endif\n                emit_unbox(ctx, T_size, n, (jl_value_t*)jl_ulong_type),\n                false);\n        JL_GC_POP();\n        return rt == (jl_value_t*)jl_nothing_type ? ghostValue(jl_nothing_type) :\n            mark_or_box_ccall_result(ctx, destp, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_object_id) && nccallargs == 1 &&\n            rt == (jl_value_t*)jl_ulong_type) {\n        jl_cgval_t val = argv[0];\n        if (!val.isboxed) {\n            // If the value is not boxed, try to compute the object id without\n            // reboxing it.\n            auto T_pint8_derived = PointerType::get(T_int8, AddressSpace::Derived);\n            if (!val.isghost && !val.ispointer())\n                val = value_to_pointer(ctx, val);\n            Value *args[] = {\n                emit_typeof_boxed(ctx, val),\n                val.isghost ? ConstantPointerNull::get(T_pint8_derived) :\n                    ctx.builder.CreateBitCast(\n                        decay_derived(ctx, data_pointer(ctx, val)),\n                        T_pint8_derived)\n            };\n            Value *ret = ctx.builder.CreateCall(prepare_call(jl_object_id__func), makeArrayRef(args));\n            JL_GC_POP();\n            return mark_or_box_ccall_result(ctx, ret, retboxed, rt, unionall, static_rt);\n        }\n    }\n\n    jl_cgval_t retval = sig.emit_a_ccall(\n            ctx,\n            symarg,\n            argv,\n            gc_uses,\n            static_rt);\n    JL_GC_POP();\n    return retval;\n}\n\njl_cgval_t function_sig_t::emit_a_ccall(\n        jl_codectx_t &ctx,\n        const native_sym_arg_t &symarg,\n        jl_cgval_t *argv,\n        SmallVector<Value*, 16> &gc_uses,\n        bool static_rt) const\n{\n    if (!err_msg.empty()) {\n        emit_error(ctx, err_msg);\n        return jl_cgval_t();\n    }\n\n    FunctionType *functype = this->functype();\n\n    Value **argvals = (Value**) alloca((nccallargs + sret) * sizeof(Value*));\n    for (size_t ai = 0; ai < nccallargs; ai++) {\n        // Current C function parameter\n        jl_cgval_t &arg = argv[ai];\n        jl_value_t *jargty = jl_svecref(at, ai); // Julia type of the current parameter\n        Type *largty = fargt.at(ai); // LLVM type of the current parameter\n        bool toboxed = fargt_isboxed.at(ai);\n        Type *pargty = fargt_sig.at(ai + sret); // LLVM coercion type\n        bool byRef = byRefList.at(ai); // Argument attributes\n\n        // if we know the function sparams, try to fill those in now\n        // so that the julia_to_native type checks are more likely to be doable (e.g. concrete types) at compile-time\n        jl_value_t *jargty_in_env = jargty;\n        if (ctx.spvals_ptr == NULL && !toboxed && unionall_env && jl_has_typevar_from_unionall(jargty, unionall_env) &&\n                jl_svec_len(ctx.linfo->sparam_vals) > 0) {\n            jargty_in_env = jl_instantiate_type_in_env(jargty_in_env, unionall_env, jl_svec_data(ctx.linfo->sparam_vals));\n            if (jargty_in_env != jargty)\n                jl_add_method_root(ctx, jargty_in_env);\n        }\n\n        Value *v;\n        if (jl_is_abstract_ref_type(jargty)) {\n            if (!jl_is_cpointer_type(arg.typ)) {\n                emit_cpointercheck(ctx, arg, \"ccall: argument to Ref{T} is not a pointer\");\n                arg.typ = (jl_value_t*)jl_voidpointer_type;\n                arg.isboxed = false;\n            }\n            jargty_in_env = (jl_value_t*)jl_voidpointer_type;\n        }\n\n        v = julia_to_native(ctx, largty, toboxed, jargty_in_env, unionall_env, arg, byRef, ai);\n        bool issigned = jl_signed_type && jl_subtype(jargty, (jl_value_t*)jl_signed_type);\n        if (byRef) {\n            v = decay_derived(ctx, v);\n            // julia_to_native should already have done the alloca and store\n            assert(v->getType() == pargty);\n        }\n        else {\n            v = llvm_type_rewrite(ctx, v, pargty, issigned);\n        }\n\n        if (isa<UndefValue>(v)) {\n            return jl_cgval_t();\n        }\n        assert(v->getType() == pargty);\n        argvals[ai + sret] = v;\n    }\n\n    Value *result = NULL;\n    // First, if the ABI requires us to provide the space for the return\n    // argument, allocate the box and store that as the first argument type\n    bool sretboxed = false;\n    if (sret) {\n        assert(!retboxed && jl_is_datatype(rt) && \"sret return type invalid\");\n        if (jl_is_pointerfree(rt)) {\n            result = emit_static_alloca(ctx, lrt);\n            argvals[0] = ctx.builder.CreateBitCast(result, fargt_sig.at(0));\n        }\n        else {\n            // XXX: result needs to be zero'd and given a GC root here\n            // and has incorrect write barriers.\n            // instead this code path should behave like `unsafe_load`\n            assert(jl_datatype_size(rt) > 0 && \"sret shouldn't be a singleton instance\");\n            result = emit_allocobj(ctx, jl_datatype_size(rt),\n                                   literal_pointer_val(ctx, (jl_value_t*)rt));\n            sretboxed = true;\n            gc_uses.push_back(result);\n            argvals[0] = ctx.builder.CreateBitCast(emit_pointer_from_objref(ctx, result), fargt_sig.at(0));\n        }\n    }\n\n    // make LLVM function object for the target\n    // keep this close to the function call, so that the compiler can\n    // optimize the global pointer load in the common case\n    Value *llvmf;\n    if (llvmcall) {\n        if (symarg.jl_ptr != NULL) {\n            emit_error(ctx, \"llvmcall doesn't support dynamic pointers\");\n            return jl_cgval_t();\n        }\n        else if (symarg.fptr != NULL) {\n            emit_error(ctx, \"llvmcall doesn't support static pointers\");\n            return jl_cgval_t();\n        }\n        else if (symarg.f_lib != NULL) {\n            emit_error(ctx, \"llvmcall doesn't support dynamic libraries\");\n            return jl_cgval_t();\n        }\n        else {\n            assert(symarg.f_name != NULL);\n            const char* f_name = symarg.f_name;\n            bool f_extern = (strncmp(f_name, \"extern \", 7) == 0);\n            if (f_extern)\n                f_name += 7;\n            llvmf = jl_Module->getOrInsertFunction(f_name, functype).getCallee();\n            if (!f_extern && (!isa<Function>(llvmf) ||\n                              cast<Function>(llvmf)->getIntrinsicID() ==\n                                      Intrinsic::not_intrinsic)) {\n                emit_error(ctx, \"llvmcall only supports intrinsic calls\");\n                return jl_cgval_t();\n            }\n        }\n    }\n    else if (symarg.jl_ptr != NULL) {\n        null_pointer_check(ctx, symarg.jl_ptr);\n        Type *funcptype = PointerType::get(functype, 0);\n        llvmf = emit_inttoptr(ctx, symarg.jl_ptr, funcptype);\n    }\n    else if (symarg.fptr != NULL) {\n        Type *funcptype = PointerType::get(functype, 0);\n        llvmf = literal_static_pointer_val((void*)(uintptr_t)symarg.fptr, funcptype);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in ccall for %s; code cannot be statically compiled\\n\", symarg.f_name);\n    }\n    else {\n        assert(symarg.f_name != NULL);\n        PointerType *funcptype = PointerType::get(functype, 0);\n        if (symarg.lib_expr) {\n            llvmf = runtime_sym_lookup(ctx, funcptype, NULL, symarg.lib_expr, symarg.f_name, ctx.f);\n        }\n        else if (imaging_mode) {\n            // vararg requires musttail,\n            // but musttail is incompatible with noreturn.\n            if (functype->isVarArg())\n                llvmf = runtime_sym_lookup(ctx, funcptype, symarg.f_lib, NULL, symarg.f_name, ctx.f);\n            else\n                llvmf = emit_plt(ctx, functype, attributes, cc, symarg.f_lib, symarg.f_name);\n        }\n        else {\n            void *symaddr;\n            void *libsym = jl_get_library_(symarg.f_lib, 0);\n            if (!libsym || !jl_dlsym(libsym, symarg.f_name, &symaddr, 0)) {\n                // either the library or the symbol could not be found, place a runtime\n                // lookup here instead.\n                llvmf = runtime_sym_lookup(ctx, funcptype, symarg.f_lib, NULL, symarg.f_name, ctx.f);\n            } else {\n                // since we aren't saving this code, there's no sense in\n                // putting anything complicated here: just JIT the function address\n                llvmf = literal_static_pointer_val(symaddr, funcptype);\n            }\n        }\n    }\n\n    OperandBundleDef OpBundle(\"jl_roots\", gc_uses);\n    // the actual call\n    CallInst *ret = ctx.builder.CreateCall(functype, llvmf,\n            ArrayRef<Value*>(&argvals[0], nccallargs + sret),\n            ArrayRef<OperandBundleDef>(&OpBundle, gc_uses.empty() ? 0 : 1));\n    ((CallInst*)ret)->setAttributes(attributes);\n\n    if (cc != CallingConv::C)\n        ((CallInst*)ret)->setCallingConv(cc);\n    if (!sret)\n        result = ret;\n    if (0) { // Enable this to turn on SSPREQ (-fstack-protector) on the function containing this ccall\n        ctx.f->addFnAttr(Attribute::StackProtectReq);\n    }\n\n    if (rt == jl_bottom_type) {\n        CreateTrap(ctx.builder);\n        return jl_cgval_t();\n    }\n\n    // Finally we need to box the result into julia type\n    // However, if we have already created a box for the return\n    // type because the ABI required us to pass a pointer (sret),\n    // then we do not need to do this.\n    bool jlretboxed;\n    if (retboxed) {\n        assert(!sret);\n        jlretboxed = true;\n    }\n    else if (sret) {\n        jlretboxed = sretboxed;\n        if (!jlretboxed) {\n            // something alloca'd above is SSA\n            if (static_rt)\n                return mark_julia_slot(result, rt, NULL, tbaa_stack);\n            result = ctx.builder.CreateLoad(result);\n        }\n    }\n    else {\n        Type *jlrt = julia_type_to_llvm(ctx, rt, &jlretboxed); // compute the real \"julian\" return type and compute whether it is boxed\n        if (type_is_ghost(jlrt)) {\n            return ghostValue(rt);\n        }\n        else if (jl_is_datatype(rt) && jl_is_datatype_singleton((jl_datatype_t*)rt)) {\n            return mark_julia_const(((jl_datatype_t*)rt)->instance);\n        }\n        else if (jlretboxed && !retboxed) {\n            assert(jl_is_datatype(rt));\n            if (static_rt) {\n                Value *runtime_bt = literal_pointer_val(ctx, rt);\n                size_t rtsz = jl_datatype_size(rt);\n                assert(rtsz > 0);\n                Value *strct = emit_allocobj(ctx, rtsz, runtime_bt);\n                MDNode *tbaa = jl_is_mutable(rt) ? tbaa_mutab : tbaa_immut;\n                int boxalign = julia_alignment(rt);\n                // copy the data from the return value to the new struct\n                const DataLayout &DL = jl_data_layout;\n                auto resultTy = result->getType();\n                if (DL.getTypeStoreSize(resultTy) > rtsz) {\n                    // ARM and AArch64 can use a LLVM type larger than the julia type.\n                    // When this happens, cast through memory.\n                    auto slot = emit_static_alloca(ctx, resultTy);\n                    slot->setAlignment(Align(boxalign));\n                    ctx.builder.CreateAlignedStore(result, slot, Align(boxalign));\n                    emit_memcpy(ctx, strct, tbaa, slot, tbaa, rtsz, boxalign);\n                }\n                else {\n                    init_bits_value(ctx, strct, result, tbaa, boxalign);\n                }\n                return mark_julia_type(ctx, strct, true, rt);\n            }\n            jlretboxed = false; // trigger mark_or_box_ccall_result to build the runtime box\n        }\n        else if (lrt != prt) {\n            assert(jlrt == lrt || !lrt->isStructTy()); // julia_type_to_llvm and julia_struct_to_llvm should be returning the same StructType\n            result = llvm_type_rewrite(ctx, result, lrt, false);\n        }\n    }\n\n    return mark_or_box_ccall_result(ctx, result, jlretboxed, rt, unionall_env, static_rt);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/jitlayers.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// Except for parts of this file which were copied from LLVM, under the UIUC license (marked below).\n\n#include \"llvm-version.h\"\n#include \"platform.h\"\n\n\n#include \"llvm/IR/Mangler.h\"\n#include <llvm/ADT/StringMap.h>\n#include <llvm/Analysis/TargetLibraryInfo.h>\n#include <llvm/Analysis/TargetTransformInfo.h>\n#include <llvm/ExecutionEngine/Orc/CompileUtils.h>\n#include <llvm/ExecutionEngine/Orc/ExecutionUtils.h>\n#include <llvm/Support/DynamicLibrary.h>\n#include <llvm/Support/FormattedStream.h>\n#include <llvm/Support/SmallVectorMemoryBuffer.h>\n#include <llvm/Support/TargetRegistry.h>\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Target/TargetMachine.h>\n#include <llvm/Transforms/Utils/Cloning.h>\n#include <llvm/Transforms/Utils/ModuleUtils.h>\n\nusing namespace llvm;\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"codegen_shared.h\"\n#include \"jitlayers.h\"\n#include \"julia_assert.h\"\n\nRTDyldMemoryManager* createRTDyldMemoryManager(void);\n\nvoid jl_init_jit(void) { }\n\n// Snooping on which functions are being compiled, and how long it takes\nJL_STREAM *dump_compiles_stream = NULL;\nextern \"C\" JL_DLLEXPORT\nvoid jl_dump_compiles(void *s)\n{\n    dump_compiles_stream = (JL_STREAM*)s;\n}\nJL_STREAM *dump_llvm_opt_stream = NULL;\nextern \"C\" JL_DLLEXPORT\nvoid jl_dump_llvm_opt(void *s)\n{\n    dump_llvm_opt_stream = (JL_STREAM*)s;\n}\n\nstatic void jl_add_to_ee(std::unique_ptr<Module> m);\nstatic void jl_add_to_ee(std::unique_ptr<Module> &M, StringMap<std::unique_ptr<Module>*> &NewExports);\nstatic uint64_t getAddressForFunction(StringRef fname);\n\nvoid jl_link_global(GlobalVariable *GV, void *addr)\n{\n    Constant *P = literal_static_pointer_val(addr, GV->getValueType());\n    GV->setInitializer(P);\n    if (jl_options.image_codegen) {\n        // If we are forcing imaging mode codegen for debugging,\n        // emit external non-const symbol to avoid LLVM optimizing the code\n        // similar to non-imaging mode.\n        GV->setLinkage(GlobalValue::ExternalLinkage);\n    }\n    else {\n        GV->setConstant(true);\n        GV->setLinkage(GlobalValue::PrivateLinkage);\n        GV->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);\n    }\n}\n\nvoid jl_jit_globals(std::map<void *, GlobalVariable*> &globals)\n{\n    for (auto &global : globals) {\n        jl_link_global(global.second, global.first);\n    }\n}\n\nextern \"C\" JL_DLLEXPORT\nuint64_t jl_cumulative_compile_time_ns_before()\n{\n    int tid = jl_threadid();\n    jl_measure_compile_time[tid] = 1;\n    return jl_cumulative_compile_time[tid];\n}\nextern \"C\" JL_DLLEXPORT\nuint64_t jl_cumulative_compile_time_ns_after()\n{\n    int tid = jl_threadid();\n    jl_measure_compile_time[tid] = 0;\n    return jl_cumulative_compile_time[tid];\n}\n\n// this generates llvm code for the lambda info\n// and adds the result to the jitlayers\n// (and the shadow module),\n// and generates code for it\nstatic jl_callptr_t _jl_compile_codeinst(\n        jl_code_instance_t *codeinst,\n        jl_code_info_t *src,\n        size_t world)\n{\n    // TODO: Merge with jl_dump_compiles?\n    static ios_t f_precompile;\n    static JL_STREAM* s_precompile = NULL;\n\n    // caller must hold codegen_lock\n    // and have disabled finalizers\n    uint64_t start_time = 0;\n    if (dump_compiles_stream != NULL)\n        start_time = jl_hrtime();\n\n    assert(jl_is_code_instance(codeinst));\n    assert(codeinst->min_world <= world && (codeinst->max_world >= world || codeinst->max_world == 0) &&\n        \"invalid world for method-instance\");\n    assert(src && jl_is_code_info(src));\n\n    jl_callptr_t fptr = NULL;\n    // emit the code in LLVM IR form\n    jl_codegen_params_t params;\n    params.cache = true;\n    params.world = world;\n    std::map<jl_code_instance_t*, jl_compile_result_t> emitted;\n    {\n        jl_compile_result_t result = jl_emit_codeinst(codeinst, src, params);\n        if (std::get<0>(result))\n            emitted[codeinst] = std::move(result);\n        jl_compile_workqueue(emitted, params, CompilationPolicy::Default);\n\n        if (params._shared_module)\n            jl_add_to_ee(std::unique_ptr<Module>(params._shared_module));\n        StringMap<std::unique_ptr<Module>*> NewExports;\n        StringMap<void*> NewGlobals;\n        for (auto &global : params.globals) {\n            NewGlobals[global.second->getName()] = global.first;\n        }\n        for (auto &def : emitted) {\n            std::unique_ptr<Module> &M = std::get<0>(def.second);\n            for (auto &F : M->global_objects()) {\n                if (!F.isDeclaration() && F.getLinkage() == GlobalValue::ExternalLinkage) {\n                    NewExports[F.getName()] = &M;\n                }\n            }\n            // Let's link all globals here also (for now)\n            for (auto &GV : M->globals()) {\n                auto InitValue = NewGlobals.find(GV.getName());\n                if (InitValue != NewGlobals.end()) {\n                    jl_link_global(&GV, InitValue->second);\n                }\n            }\n        }\n        for (auto &def : emitted) {\n            // Add the results to the execution engine now\n            std::unique_ptr<Module> &M = std::get<0>(def.second);\n            jl_add_to_ee(M, NewExports);\n        }\n    }\n    JL_TIMING(LLVM_MODULE_FINISH);\n\n    for (auto &def : emitted) {\n        jl_code_instance_t *this_code = def.first;\n        jl_llvm_functions_t decls = std::get<1>(def.second);\n        jl_callptr_t addr;\n        bool isspecsig = false;\n        if (decls.functionObject == \"jl_fptr_args\") {\n            addr = &jl_fptr_args;\n        }\n        else if (decls.functionObject == \"jl_fptr_sparam\") {\n            addr = &jl_fptr_sparam;\n        }\n        else {\n            addr = (jl_callptr_t)getAddressForFunction(decls.functionObject);\n            isspecsig = true;\n        }\n        if (this_code->invoke == NULL) {\n            // once set, don't change invoke-ptr, as that leads to race conditions\n            // with the (not) simultaneous updates to invoke and specptr\n            if (!decls.specFunctionObject.empty()) {\n                this_code->specptr.fptr = (void*)getAddressForFunction(decls.specFunctionObject);\n                this_code->isspecsig = isspecsig;\n            }\n            jl_atomic_store_release(&this_code->invoke, addr);\n        }\n        else if (this_code->invoke == jl_fptr_const_return && !decls.specFunctionObject.empty()) {\n            // hack to export this pointer value to jl_dump_method_asm\n            this_code->specptr.fptr = (void*)getAddressForFunction(decls.specFunctionObject);\n        }\n        if (this_code== codeinst)\n            fptr = addr;\n    }\n\n    uint64_t end_time = 0;\n    if (dump_compiles_stream != NULL)\n        end_time = jl_hrtime();\n\n    // If logging of the compilation stream is enabled,\n    // then dump the method-instance specialization type to the stream\n    jl_method_instance_t *mi = codeinst->def;\n    if (jl_is_method(mi->def.method)) {\n        if (jl_options.trace_compile != NULL) {\n            if (s_precompile == NULL) {\n                const char* t = jl_options.trace_compile;\n                if (!strncmp(t, \"stderr\", 6))\n                    s_precompile = JL_STDERR;\n                else {\n                    if (ios_file(&f_precompile, t, 1, 1, 1, 1) == NULL)\n                        jl_errorf(\"cannot open precompile statement file \\\"%s\\\" for writing\", t);\n                    s_precompile = (JL_STREAM*) &f_precompile;\n                }\n            }\n            if (!jl_has_free_typevars(mi->specTypes)) {\n                jl_printf(s_precompile, \"precompile(\");\n                jl_static_show(s_precompile, mi->specTypes);\n                jl_printf(s_precompile, \")\\n\");\n\n                if (s_precompile != JL_STDERR)\n                    ios_flush(&f_precompile);\n            }\n        }\n        if (dump_compiles_stream != NULL) {\n            jl_printf(dump_compiles_stream, \"%\" PRIu64 \"\\t\\\"\", end_time - start_time);\n            jl_static_show(dump_compiles_stream, mi->specTypes);\n            jl_printf(dump_compiles_stream, \"\\\"\\n\");\n        }\n    }\n    return fptr;\n}\n\nconst char *jl_generate_ccallable(void *llvmmod, void *sysimg_handle, jl_value_t *declrt, jl_value_t *sigt, jl_codegen_params_t &params);\n\n// compile a C-callable alias\nextern \"C\"\nint jl_compile_extern_c(void *llvmmod, void *p, void *sysimg, jl_value_t *declrt, jl_value_t *sigt)\n{\n    JL_LOCK(&codegen_lock);\n    uint64_t compiler_start_time = 0;\n    int tid = jl_threadid();\n    if (jl_measure_compile_time[tid])\n        compiler_start_time = jl_hrtime();\n    jl_codegen_params_t params;\n    jl_codegen_params_t *pparams = (jl_codegen_params_t*)p;\n    if (pparams == NULL)\n        pparams = &params;\n    Module *into = (Module*)llvmmod;\n    if (into == NULL)\n        into = jl_create_llvm_module(\"cextern\");\n    const char *name = jl_generate_ccallable(into, sysimg, declrt, sigt, *pparams);\n    bool success = true;\n    if (!sysimg) {\n        if (jl_ExecutionEngine->getGlobalValueAddress(name)) {\n            success = false;\n        }\n        if (success && p == NULL) {\n            jl_jit_globals(params.globals);\n            assert(params.workqueue.empty());\n            if (params._shared_module)\n                jl_add_to_ee(std::unique_ptr<Module>(params._shared_module));\n        }\n        if (success && llvmmod == NULL)\n            jl_add_to_ee(std::unique_ptr<Module>(into));\n    }\n    if (codegen_lock.count == 1 && jl_measure_compile_time[tid])\n        jl_cumulative_compile_time[tid] += (jl_hrtime() - compiler_start_time);\n    JL_UNLOCK(&codegen_lock);\n    return success;\n}\n\nbool jl_type_mappable_to_c(jl_value_t *ty);\n\n// declare a C-callable entry point; called during code loading from the toplevel\nextern \"C\" JL_DLLEXPORT\nvoid jl_extern_c(jl_value_t *declrt, jl_tupletype_t *sigt)\n{\n    // validate arguments. try to do as many checks as possible here to avoid\n    // throwing errors later during codegen.\n    JL_TYPECHK(@ccallable, type, declrt);\n    if (!jl_is_tuple_type(sigt))\n        jl_type_error(\"@ccallable\", (jl_value_t*)jl_anytuple_type_type, (jl_value_t*)sigt);\n    // check that f is a guaranteed singleton type\n    jl_datatype_t *ft = (jl_datatype_t*)jl_tparam0(sigt);\n    if (!jl_is_datatype(ft) || ft->instance == NULL)\n        jl_error(\"@ccallable: function object must be a singleton\");\n\n    // compute / validate return type\n    if (!jl_is_concrete_type(declrt) || jl_is_kind(declrt))\n        jl_error(\"@ccallable: return type must be concrete and correspond to a C type\");\n    JL_LOCK(&codegen_lock);\n    if (!jl_type_mappable_to_c(declrt))\n        jl_error(\"@ccallable: return type doesn't correspond to a C type\");\n    JL_UNLOCK(&codegen_lock);\n\n    // validate method signature\n    size_t i, nargs = jl_nparams(sigt);\n    for (i = 1; i < nargs; i++) {\n        jl_value_t *ati = jl_tparam(sigt, i);\n        if (!jl_is_concrete_type(ati) || jl_is_kind(ati))\n            jl_error(\"@ccallable: argument types must be concrete\");\n    }\n\n    // save a record of this so that the alias is generated when we write an object file\n    jl_method_t *meth = (jl_method_t*)jl_methtable_lookup(ft->name->mt, (jl_value_t*)sigt, jl_world_counter);\n    if (!jl_is_method(meth))\n        jl_error(\"@ccallable: could not find requested method\");\n    JL_GC_PUSH1(&meth);\n    meth->ccallable = jl_svec2(declrt, (jl_value_t*)sigt);\n    jl_gc_wb(meth, meth->ccallable);\n    JL_GC_POP();\n\n    // create the alias in the current runtime environment\n    int success = jl_compile_extern_c(NULL, NULL, NULL, declrt, (jl_value_t*)sigt);\n    if (!success)\n        jl_error(\"@ccallable was already defined for this method name\");\n}\n\n// this compiles li and emits fptr\nextern \"C\"\njl_code_instance_t *jl_generate_fptr(jl_method_instance_t *mi JL_PROPAGATES_ROOT, size_t world)\n{\n    JL_LOCK(&codegen_lock); // also disables finalizers, to prevent any unexpected recursion\n    uint64_t compiler_start_time = 0;\n    int tid = jl_threadid();\n    if (jl_measure_compile_time[tid])\n        compiler_start_time = jl_hrtime();\n    // if we don't have any decls already, try to generate it now\n    jl_code_info_t *src = NULL;\n    JL_GC_PUSH1(&src);\n    jl_value_t *ci = jl_rettype_inferred(mi, world, world);\n    jl_code_instance_t *codeinst = (ci == jl_nothing ? NULL : (jl_code_instance_t*)ci);\n    if (codeinst) {\n        src = (jl_code_info_t*)codeinst->inferred;\n        if ((jl_value_t*)src == jl_nothing)\n            src = NULL;\n        else if (jl_is_method(mi->def.method))\n            src = jl_uncompress_ir(mi->def.method, codeinst, (jl_array_t*)src);\n    }\n    if (src == NULL && jl_is_method(mi->def.method) &&\n             jl_symbol_name(mi->def.method->name)[0] != '@') {\n        // If the caller didn't provide the source,\n        // see if it is inferred, or try to infer it for ourself.\n        // (but don't bother with typeinf on macros or toplevel thunks)\n        src = jl_type_infer(mi, world, 0);\n    }\n    jl_code_instance_t *compiled = jl_method_compiled(mi, world);\n    if (compiled) {\n        codeinst = compiled;\n    }\n    else if (src && jl_is_code_info(src)) {\n        if (!codeinst) {\n            codeinst = jl_get_method_inferred(mi, src->rettype, src->min_world, src->max_world);\n            if (src->inferred && !codeinst->inferred)\n                codeinst->inferred = jl_nothing;\n        }\n        _jl_compile_codeinst(codeinst, src, world);\n        if (codeinst->invoke == NULL)\n            codeinst = NULL;\n    }\n    else {\n        codeinst = NULL;\n    }\n    if (codegen_lock.count == 1 && jl_measure_compile_time[tid])\n        jl_cumulative_compile_time[tid] += (jl_hrtime() - compiler_start_time);\n    JL_UNLOCK(&codegen_lock);\n    JL_GC_POP();\n    return codeinst;\n}\n\nextern \"C\"\nvoid jl_generate_fptr_for_unspecialized(jl_code_instance_t *unspec)\n{\n    if (jl_atomic_load_relaxed(&unspec->invoke) != NULL) {\n        return;\n    }\n    JL_LOCK(&codegen_lock);\n    uint64_t compiler_start_time = 0;\n    int tid = jl_threadid();\n    if (jl_measure_compile_time[tid])\n        compiler_start_time = jl_hrtime();\n    if (unspec->invoke == NULL) {\n        jl_code_info_t *src = NULL;\n        JL_GC_PUSH1(&src);\n        jl_method_t *def = unspec->def->def.method;\n        if (jl_is_method(def)) {\n            src = (jl_code_info_t*)def->source;\n            if (src == NULL) {\n                // TODO: this is wrong\n                assert(def->generator);\n                // TODO: jl_code_for_staged can throw\n                src = jl_code_for_staged(unspec->def);\n            }\n            if (src && (jl_value_t*)src != jl_nothing)\n                src = jl_uncompress_ir(def, NULL, (jl_array_t*)src);\n        }\n        else {\n            src = (jl_code_info_t*)unspec->def->uninferred;\n        }\n        assert(src && jl_is_code_info(src));\n        _jl_compile_codeinst(unspec, src, unspec->min_world);\n        if (unspec->invoke == NULL) {\n            // if we hit a codegen bug (or ran into a broken generated function or llvmcall), fall back to the interpreter as a last resort\n            jl_atomic_store_release(&unspec->invoke, &jl_fptr_interpret_call);\n        }\n        JL_GC_POP();\n    }\n    if (codegen_lock.count == 1 && jl_measure_compile_time[tid])\n        jl_cumulative_compile_time[tid] += (jl_hrtime() - compiler_start_time);\n    JL_UNLOCK(&codegen_lock); // Might GC\n}\n\n\n// get a native disassembly for a compiled method\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_dump_method_asm(jl_method_instance_t *mi, size_t world,\n        int raw_mc, char getwrapper, const char* asm_variant, const char *debuginfo)\n{\n    // printing via disassembly\n    jl_code_instance_t *codeinst = jl_generate_fptr(mi, world);\n    if (codeinst) {\n        uintptr_t fptr = (uintptr_t)codeinst->invoke;\n        if (getwrapper)\n            return jl_dump_fptr_asm(fptr, raw_mc, asm_variant, debuginfo);\n        uintptr_t specfptr = (uintptr_t)codeinst->specptr.fptr;\n        if (fptr == (uintptr_t)&jl_fptr_const_return && specfptr == 0) {\n            // normally we prevent native code from being generated for these functions,\n            // (using sentinel value `1` instead)\n            // so create an exception here so we can print pretty our lies\n            JL_LOCK(&codegen_lock); // also disables finalizers, to prevent any unexpected recursion\n            uint64_t compiler_start_time = 0;\n            int tid = jl_threadid();\n            if (jl_measure_compile_time[tid])\n                compiler_start_time = jl_hrtime();\n            specfptr = (uintptr_t)codeinst->specptr.fptr;\n            if (specfptr == 0) {\n                jl_code_info_t *src = jl_type_infer(mi, world, 0);\n                JL_GC_PUSH1(&src);\n                jl_method_t *def = mi->def.method;\n                if (jl_is_method(def)) {\n                    if (!src) {\n                        // TODO: jl_code_for_staged can throw\n                        src = def->generator ? jl_code_for_staged(mi) : (jl_code_info_t*)def->source;\n                    }\n                    if (src && (jl_value_t*)src != jl_nothing)\n                        src = jl_uncompress_ir(mi->def.method, codeinst, (jl_array_t*)src);\n                }\n                fptr = (uintptr_t)codeinst->invoke;\n                specfptr = (uintptr_t)codeinst->specptr.fptr;\n                if (src && jl_is_code_info(src)) {\n                    if (fptr == (uintptr_t)&jl_fptr_const_return && specfptr == 0) {\n                        fptr = (uintptr_t)_jl_compile_codeinst(codeinst, src, world);\n                        specfptr = (uintptr_t)codeinst->specptr.fptr;\n                    }\n                }\n                JL_GC_POP();\n            }\n            if (jl_measure_compile_time[tid])\n                jl_cumulative_compile_time[tid] += (jl_hrtime() - compiler_start_time);\n            JL_UNLOCK(&codegen_lock);\n        }\n        if (specfptr != 0)\n            return jl_dump_fptr_asm(specfptr, raw_mc, asm_variant, debuginfo);\n    }\n\n    // whatever, that didn't work - use the assembler output instead\n    if (raw_mc) // eh, give up, this flag doesn't really work anyways normally\n        return (jl_value_t*)jl_pchar_to_array(\"\", 0);\n    return jl_dump_llvm_asm(jl_get_llvmf_defn(mi, world, getwrapper, true, jl_default_cgparams), asm_variant, debuginfo);\n}\n\n// A simple forwarding class, since OrcJIT v2 needs a unique_ptr, while we have a shared_ptr\nclass ForwardingMemoryManager : public RuntimeDyld::MemoryManager {\nprivate:\n    std::shared_ptr<RuntimeDyld::MemoryManager> MemMgr;\n\npublic:\n    ForwardingMemoryManager(std::shared_ptr<RuntimeDyld::MemoryManager> MemMgr) : MemMgr(MemMgr) {}\n    virtual ~ForwardingMemoryManager() = default;\n    virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                                     unsigned SectionID,\n                                     StringRef SectionName) override {\n        return MemMgr->allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    }\n    virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                                     unsigned SectionID,\n                                     StringRef SectionName,\n                                     bool IsReadOnly) override {\n        return MemMgr->allocateDataSection(Size, Alignment, SectionID, SectionName, IsReadOnly);\n    }\n    virtual void reserveAllocationSpace(uintptr_t CodeSize, uint32_t CodeAlign,\n                                        uintptr_t RODataSize,\n                                        uint32_t RODataAlign,\n                                        uintptr_t RWDataSize,\n                                        uint32_t RWDataAlign) override {\n        return MemMgr->reserveAllocationSpace(CodeSize, CodeAlign, RODataSize, RODataAlign, RWDataSize, RWDataAlign);\n    }\n    virtual bool needsToReserveAllocationSpace() override {\n        return MemMgr->needsToReserveAllocationSpace();\n    }\n    virtual void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr,\n                                  size_t Size) override {\n        return MemMgr->registerEHFrames(Addr, LoadAddr, Size);\n    }\n    virtual void deregisterEHFrames() override {\n        return MemMgr->deregisterEHFrames();\n    }\n    virtual bool finalizeMemory(std::string *ErrMsg = nullptr) override {\n        return MemMgr->finalizeMemory(ErrMsg);\n    }\n    virtual void notifyObjectLoaded(RuntimeDyld &RTDyld,\n                                    const object::ObjectFile &Obj) override {\n        return MemMgr->notifyObjectLoaded(RTDyld, Obj);\n    }\n};\n\n\n// Custom object emission notification handler for the JuliaOJIT\nextern JITEventListener *CreateJuliaJITEventListener();\n\nJL_DLLEXPORT void ORCNotifyObjectEmitted(JITEventListener *Listener,\n                                         const object::ObjectFile &obj,\n                                         const RuntimeDyld::LoadedObjectInfo &L,\n                                         RTDyldMemoryManager *memmgr);\n\n#if JL_LLVM_VERSION >= 120000\ntemplate <typename ObjT, typename LoadResult>\nvoid JuliaOJIT::registerObject(const ObjT &Obj, const LoadResult &LO)\n{\n    const ObjT* Object = &Obj;\n    ORCNotifyObjectEmitted(JuliaListener.get(), *Object, *LO, MemMgr.get());\n}\n#else\ntemplate <typename ObjT, typename LoadResult>\nvoid JuliaOJIT::registerObject(RTDyldObjHandleT H, const ObjT &Obj, const LoadResult &LO)\n{\n    const ObjT* Object = &Obj;\n    NotifyFinalizer(H, *Object, *LO);\n    ORCNotifyObjectEmitted(JuliaListener.get(), *Object, *LO, MemMgr.get());\n}\n#endif\n\nCodeGenOpt::Level CodeGenOptLevelFor(int optlevel)\n{\n#ifdef DISABLE_OPT\n    return CodeGenOpt::None;\n#else\n    return optlevel < 2 ? CodeGenOpt::None :\n        optlevel == 2 ? CodeGenOpt::Default :\n        CodeGenOpt::Aggressive;\n#endif\n}\n\nstatic void addPassesForOptLevel(legacy::PassManager &PM, TargetMachine &TM, raw_svector_ostream &ObjStream, MCContext *Ctx, int optlevel)\n{\n    addTargetPasses(&PM, &TM);\n    addOptimizationPasses(&PM, optlevel);\n    addMachinePasses(&PM, &TM);\n    if (TM.addPassesToEmitMC(PM, Ctx, ObjStream))\n        llvm_unreachable(\"Target does not support MC emission.\");\n}\n\nCompilerResultT JuliaOJIT::CompilerT::operator()(Module &M)\n{\n    uint64_t start_time = 0;\n    if (dump_llvm_opt_stream != NULL) {\n        // Print LLVM function statistics _before_ optimization\n        // Print all the information about this invocation as a YAML object\n        jl_printf(dump_llvm_opt_stream, \"- \\n\");\n        // We print the name and some statistics for each function in the module, both\n        // before optimization and again afterwards.\n        jl_printf(dump_llvm_opt_stream, \"  before: \\n\");\n        for (auto &F : M.functions()) {\n            if (F.isDeclaration() || F.getName().startswith(\"jfptr_\")) {\n                continue;\n            }\n            // Count number of Basic Blocks\n            int bbs = 0;\n            for (auto &B : F.getBasicBlockList()) {\n                std::ignore = B;\n                ++bbs;\n            }\n\n            // Each function is printed as a YAML object with several attributes\n            jl_printf(dump_llvm_opt_stream, \"    \\\"%s\\\":\\n\", F.getName().str().c_str());\n            jl_printf(dump_llvm_opt_stream, \"        instructions: %u\\n\", F.getInstructionCount());\n            jl_printf(dump_llvm_opt_stream, \"        basicblocks: %u\\n\", bbs);\n        }\n\n        start_time = jl_hrtime();\n    }\n\n    JL_TIMING(LLVM_OPT);\n\n    int optlevel;\n    if (jl_generating_output()) {\n        optlevel = 0;\n    }\n    else {\n        optlevel = jl_options.opt_level;\n        for (auto &F : M.functions()) {\n            if (!F.getBasicBlockList().empty()) {\n                Attribute attr = F.getFnAttribute(\"julia-optimization-level\");\n                StringRef val = attr.getValueAsString();\n                if (val != \"\") {\n                    int ol = (int)val[0] - '0';\n                    if (ol >= 0 && ol < optlevel)\n                        optlevel = ol;\n                }\n            }\n        }\n    }\n    if (optlevel == 0)\n        jit.PM0.run(M);\n    else if (optlevel == 1)\n        jit.PM1.run(M);\n    else if (optlevel == 2)\n        jit.PM2.run(M);\n    else if (optlevel >= 3)\n        jit.PM3.run(M);\n\n    std::unique_ptr<MemoryBuffer> ObjBuffer(\n        new SmallVectorMemoryBuffer(std::move(jit.ObjBufferSV)));\n    auto Obj = object::ObjectFile::createObjectFile(ObjBuffer->getMemBufferRef());\n\n    if (!Obj) {\n        llvm_dump(&M);\n        std::string Buf;\n        raw_string_ostream OS(Buf);\n        logAllUnhandledErrors(Obj.takeError(), OS, \"\");\n        OS.flush();\n        llvm::report_fatal_error(\"FATAL: Unable to compile LLVM Module: '\" + Buf + \"'\\n\"\n                                 \"The module's content was printed above. Please file a bug report\");\n    }\n\n    uint64_t end_time = 0;\n    if (dump_llvm_opt_stream != NULL) {\n        end_time = jl_hrtime();\n        jl_printf(dump_llvm_opt_stream, \"  time_ns: %\" PRIu64 \"\\n\", end_time - start_time);\n        jl_printf(dump_llvm_opt_stream, \"  optlevel: %d\\n\", optlevel);\n\n        // Print LLVM function statistics _after_ optimization\n        jl_printf(dump_llvm_opt_stream, \"  after: \\n\");\n        for (auto &F : M.functions()) {\n            if (F.isDeclaration() || F.getName().startswith(\"jfptr_\")) {\n                continue;\n            }\n\n            // Count number of Basic Blocks\n            int bbs = 0;\n            for (auto &B : F.getBasicBlockList()) {\n                std::ignore = B;\n                ++bbs;\n            }\n\n            jl_printf(dump_llvm_opt_stream, \"    \\\"%s\\\":\\n\", F.getName().str().c_str());\n            jl_printf(dump_llvm_opt_stream, \"        instructions: %u\\n\", F.getInstructionCount());\n            jl_printf(dump_llvm_opt_stream, \"        basicblocks: %u\\n\", bbs);\n        }\n    }\n\n    return CompilerResultT(std::move(ObjBuffer));\n}\n\nJuliaOJIT::JuliaOJIT(TargetMachine &TM, LLVMContext *LLVMCtx)\n  : TM(TM),\n    DL(TM.createDataLayout()),\n    ObjStream(ObjBufferSV),\n    MemMgr(createRTDyldMemoryManager()),\n    JuliaListener(CreateJuliaJITEventListener()),\n    TSCtx(std::unique_ptr<LLVMContext>(LLVMCtx)),\n    ES(),\n    GlobalJD(ES.createBareJITDylib(\"JuliaGlobals\")),\n    JD(ES.createBareJITDylib(\"JuliaOJIT\")),\n    ObjectLayer(\n            ES,\n            [this]() {\n                std::unique_ptr<RuntimeDyld::MemoryManager> result(new ForwardingMemoryManager(MemMgr));\n                return result;\n            }\n        ),\n    CompileLayer(ES, ObjectLayer, std::make_unique<CompilerT>(this))\n{\n#if JL_LLVM_VERSION >= 120000\n    ObjectLayer.setNotifyLoaded(\n        [this](orc::MaterializationResponsibility &MR,\n               const object::ObjectFile &Object,\n               const RuntimeDyld::LoadedObjectInfo &LOS) {\n            registerObject(Object, &LOS);\n        });\n#else\n    ObjectLayer.setNotifyLoaded(\n        [this](RTDyldObjHandleT H,\n               const object::ObjectFile &Object,\n               const RuntimeDyld::LoadedObjectInfo &LOS) {\n            registerObject(H, Object, &LOS);\n        });\n#endif\n    for (int i = 0; i < 4; i++) {\n        TMs[i] = TM.getTarget().createTargetMachine(TM.getTargetTriple().getTriple(), TM.getTargetCPU(),\n                TM.getTargetFeatureString(), TM.Options, Reloc::Static, TM.getCodeModel(),\n                CodeGenOptLevelFor(i), true);\n    }\n    addPassesForOptLevel(PM0, *TMs[0], ObjStream, Ctx, 0);\n    addPassesForOptLevel(PM1, *TMs[1], ObjStream, Ctx, 1);\n    addPassesForOptLevel(PM2, *TMs[2], ObjStream, Ctx, 2);\n    addPassesForOptLevel(PM3, *TMs[3], ObjStream, Ctx, 3);\n\n    // Make sure SectionMemoryManager::getSymbolAddressInProcess can resolve\n    // symbols in the program as well. The nullptr argument to the function\n    // tells DynamicLibrary to load the program, not a library.\n    std::string ErrorStr;\n    if (sys::DynamicLibrary::LoadLibraryPermanently(nullptr, &ErrorStr))\n        report_fatal_error(\"FATAL: unable to dlopen self\\n\" + ErrorStr);\n\n    GlobalJD.addGenerator(\n      cantFail(orc::DynamicLibrarySearchGenerator::GetForCurrentProcess(\n        DL.getGlobalPrefix())));\n\n    // Resolve non-lock free atomic functions in the libatomic1 library.\n    // This is the library that provides support for c11/c++11 atomic operations.\n    const char *const libatomic =\n#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n        \"libatomic.so.1\";\n#elif defined(_OS_WINDOWS_)\n        \"libatomic-1.dll\";\n#else\n        NULL;\n#endif\n    if (libatomic) {\n        static void *atomic_hdl = jl_load_dynamic_library(libatomic, JL_RTLD_LOCAL, 0);\n        if (atomic_hdl != NULL) {\n            GlobalJD.addGenerator(\n              cantFail(orc::DynamicLibrarySearchGenerator::Load(\n                  libatomic,\n                  DL.getGlobalPrefix(),\n                  [&](const orc::SymbolStringPtr &S) {\n                        const char *const atomic_prefix = \"__atomic_\";\n                        return (*S).startswith(atomic_prefix);\n                  })));\n        }\n    }\n\n    JD.addToLinkOrder(GlobalJD, orc::JITDylibLookupFlags::MatchExportedSymbolsOnly);\n}\n\nvoid JuliaOJIT::addGlobalMapping(StringRef Name, uint64_t Addr)\n{\n    std::string MangleName = getMangledName(Name);\n    cantFail(JD.define(orc::absoluteSymbols({{ES.intern(MangleName), JITEvaluatedSymbol::fromPointer((void*)Addr)}})));\n}\n\nvoid JuliaOJIT::addModule(std::unique_ptr<Module> M)\n{\n    JL_TIMING(LLVM_MODULE_FINISH);\n    std::vector<std::string> NewExports;\n    for (auto &F : M->global_values()) {\n        if (!F.isDeclaration() && F.getLinkage() == GlobalValue::ExternalLinkage) {\n            NewExports.push_back(getMangledName(F.getName()));\n        }\n    }\n#ifndef JL_NDEBUG\n    // validate the relocations for M\n    for (Module::global_object_iterator I = M->global_objects().begin(), E = M->global_objects().end(); I != E; ) {\n        GlobalObject *F = &*I;\n        ++I;\n        if (F->isDeclaration()) {\n            if (F->use_empty())\n                F->eraseFromParent();\n            else if (!((isa<Function>(F) && isIntrinsicFunction(cast<Function>(F))) ||\n                       findUnmangledSymbol(F->getName()) ||\n                       SectionMemoryManager::getSymbolAddressInProcess(\n                           getMangledName(F->getName())))) {\n                llvm::errs() << \"FATAL ERROR: \"\n                             << \"Symbol \\\"\" << F->getName().str() << \"\\\"\"\n                             << \"not found\";\n                abort();\n            }\n        }\n    }\n#endif\n#if JL_LLVM_VERSION >= 120000\n    // TODO: what is the performance characteristics of this?\n    cantFail(CompileLayer.add(JD, orc::ThreadSafeModule(std::move(M), TSCtx)));\n#else\n    auto key = ES.allocateVModule();\n    // TODO: what is the performance characteristics of this?\n    cantFail(CompileLayer.add(JD, orc::ThreadSafeModule(std::move(M), TSCtx), key));\n#endif\n    // force eager compilation (for now), due to memory management specifics\n    // (can't handle compilation recursion)\n    for (auto Name : NewExports)\n        cantFail(ES.lookup({&JD}, Name));\n\n}\n\n#if JL_LLVM_VERSION < 120000\nvoid JuliaOJIT::removeModule(ModuleHandleT H)\n{\n    //(void)CompileLayer.remove(H);\n}\n#endif\n\nJL_JITSymbol JuliaOJIT::findSymbol(StringRef Name, bool ExportedSymbolsOnly)\n{\n    orc::JITDylib* SearchOrders[2] = {&GlobalJD, &JD};\n    ArrayRef<orc::JITDylib*> SearchOrder = makeArrayRef(&SearchOrders[ExportedSymbolsOnly ? 0 : 1], ExportedSymbolsOnly ? 2 : 1);\n    auto Sym = ES.lookup(SearchOrder, Name);\n    if (Sym)\n        return *Sym;\n    return Sym.takeError();\n}\n\nJL_JITSymbol JuliaOJIT::findUnmangledSymbol(StringRef Name)\n{\n    return findSymbol(getMangledName(Name), true);\n}\n\nuint64_t JuliaOJIT::getGlobalValueAddress(StringRef Name)\n{\n    auto addr = findSymbol(getMangledName(Name), false);\n    if (!addr) {\n        consumeError(addr.takeError());\n        return 0;\n    }\n    return cantFail(addr.getAddress());\n}\n\nuint64_t JuliaOJIT::getFunctionAddress(StringRef Name)\n{\n    auto addr = findSymbol(getMangledName(Name), false);\n    if (!addr) {\n        consumeError(addr.takeError());\n        return 0;\n    }\n    return cantFail(addr.getAddress());\n}\n\nstatic int globalUniqueGeneratedNames;\nStringRef JuliaOJIT::getFunctionAtAddress(uint64_t Addr, jl_code_instance_t *codeinst)\n{\n    auto &fname = ReverseLocalSymbolTable[(void*)(uintptr_t)Addr];\n    if (fname.empty()) {\n        std::string string_fname;\n        raw_string_ostream stream_fname(string_fname);\n        // try to pick an appropriate name that describes it\n        if (Addr == (uintptr_t)codeinst->invoke) {\n            stream_fname << \"jsysw_\";\n        }\n        else if (codeinst->invoke == &jl_fptr_args) {\n            stream_fname << \"jsys1_\";\n        }\n        else if (codeinst->invoke == &jl_fptr_sparam) {\n            stream_fname << \"jsys3_\";\n        }\n        else {\n            stream_fname << \"jlsys_\";\n        }\n        const char* unadorned_name = jl_symbol_name(codeinst->def->def.method->name);\n        stream_fname << unadorned_name << \"_\" << globalUniqueGeneratedNames++;\n        fname = strdup(stream_fname.str().c_str());\n        addGlobalMapping(fname, Addr);\n    }\n    return fname;\n}\n\n\nvoid JuliaOJIT::RegisterJITEventListener(JITEventListener *L)\n{\n    if (!L)\n        return;\n#if JL_LLVM_VERSION >= 120000\n    this->ObjectLayer.registerJITEventListener(*L);\n#else\n    EventListeners.push_back(L);\n#endif\n}\n\n#if JL_LLVM_VERSION < 120000\nvoid JuliaOJIT::NotifyFinalizer(RTDyldObjHandleT Key,\n                                const object::ObjectFile &Obj,\n                                const RuntimeDyld::LoadedObjectInfo &LoadedObjectInfo)\n{\n    for (auto &Listener : EventListeners)\n        Listener->notifyObjectLoaded(Key, Obj, LoadedObjectInfo);\n}\n#endif\n\nconst DataLayout& JuliaOJIT::getDataLayout() const\n{\n    return DL;\n}\n\nconst Triple& JuliaOJIT::getTargetTriple() const\n{\n    return TM.getTargetTriple();\n}\n\nstd::string JuliaOJIT::getMangledName(StringRef Name)\n{\n    SmallString<128> FullName;\n    Mangler::getNameWithPrefix(FullName, Name, DL);\n    return FullName.str().str();\n}\n\nstd::string JuliaOJIT::getMangledName(const GlobalValue *GV)\n{\n    return getMangledName(GV->getName());\n}\n\nsize_t getRTDyldMemoryManagerTotalBytes(RTDyldMemoryManager *mm);\n\nsize_t JuliaOJIT::getTotalBytes() const\n{\n    return getRTDyldMemoryManagerTotalBytes(MemMgr.get());\n}\n\nJuliaOJIT *jl_ExecutionEngine;\n\n// destructively move the contents of src into dest\n// this assumes that the targets of the two modules are the same\n// including the DataLayout and ModuleFlags (for example)\n// and that there is no module-level assembly\n// Comdat is also removed, since the JIT doesn't need it\nvoid jl_merge_module(Module *dest, std::unique_ptr<Module> src)\n{\n    assert(dest != src.get());\n    for (Module::global_iterator I = src->global_begin(), E = src->global_end(); I != E;) {\n        GlobalVariable *sG = &*I;\n        GlobalVariable *dG = cast_or_null<GlobalVariable>(dest->getNamedValue(sG->getName()));\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            //// If we start using llvm.used, we need to enable and test this\n            //else if (!dG->isDeclaration() && dG->hasAppendingLinkage() && sG->hasAppendingLinkage()) {\n            //    auto *dCA = cast<ConstantArray>(dG->getInitializer());\n            //    auto *sCA = cast<ConstantArray>(sG->getInitializer());\n            //    SmallVector<Constant *, 16> Init;\n            //    for (auto &Op : dCA->operands())\n            //        Init.push_back(cast_or_null<Constant>(Op));\n            //    for (auto &Op : sCA->operands())\n            //        Init.push_back(cast_or_null<Constant>(Op));\n            //    Type *Int8PtrTy = Type::getInt8PtrTy(dest.getContext());\n            //    ArrayType *ATy = ArrayType::get(Int8PtrTy, Init.size());\n            //    GlobalVariable *GV = new GlobalVariable(dest, ATy, dG->isConstant(),\n            //            GlobalValue::AppendingLinkage, ConstantArray::get(ATy, Init), \"\",\n            //            dG->getThreadLocalMode(), dG->getType()->getAddressSpace());\n            //    GV->copyAttributesFrom(dG);\n            //    sG->replaceAllUsesWith(GV);\n            //    dG->replaceAllUsesWith(GV);\n            //    GV->takeName(sG);\n            //    sG->eraseFromParent();\n            //    dG->eraseFromParent();\n            //    continue;\n            //}\n            else {\n                assert(dG->isDeclaration() || (dG->getInitializer() == sG->getInitializer() &&\n                            dG->isConstant() && sG->isConstant()));\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getGlobalList().push_back(sG);\n        // Comdat is owned by the Module\n        sG->setComdat(nullptr);\n    }\n\n    for (Module::iterator I = src->begin(), E = src->end(); I != E;) {\n        Function *sG = &*I;\n        Function *dG = cast_or_null<Function>(dest->getNamedValue(sG->getName()));\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                assert(dG->isDeclaration());\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getFunctionList().push_back(sG);\n        // Comdat is owned by the Module\n        sG->setComdat(nullptr);\n    }\n\n    for (Module::alias_iterator I = src->alias_begin(), E = src->alias_end(); I != E;) {\n        GlobalAlias *sG = &*I;\n        GlobalAlias *dG = cast_or_null<GlobalAlias>(dest->getNamedValue(sG->getName()));\n        ++I;\n        if (dG) {\n            if (!dG->isDeclaration()) { // aliases are always definitions, so this test is reversed from the above two\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        sG->removeFromParent();\n        dest->getAliasList().push_back(sG);\n    }\n\n    // metadata nodes need to be explicitly merged not just copied\n    // so there are special passes here for each known type of metadata\n    NamedMDNode *sNMD = src->getNamedMetadata(\"llvm.dbg.cu\");\n    if (sNMD) {\n        NamedMDNode *dNMD = dest->getOrInsertNamedMetadata(\"llvm.dbg.cu\");\n        for (NamedMDNode::op_iterator I = sNMD->op_begin(), E = sNMD->op_end(); I != E; ++I) {\n            dNMD->addOperand(*I);\n        }\n    }\n}\n\n// optimize memory by turning long strings into memoized copies, instead of\n// making a copy per object file of output.\nvoid jl_jit_share_data(Module &M)\n{\n    std::vector<GlobalVariable*> erase;\n    for (auto &GV : M.globals()) {\n        if (!GV.hasInitializer() || !GV.isConstant())\n            continue;\n        ConstantDataSequential *CDS = dyn_cast<ConstantDataSequential>(GV.getInitializer());\n        if (CDS == nullptr)\n            continue;\n        StringRef data = CDS->getRawDataValues();\n        if (data.size() > 16) { // only for long strings: keep short ones as values\n            Type *T_size = Type::getIntNTy(GV.getContext(), sizeof(void*) * 8);\n            Constant *v = ConstantExpr::getIntToPtr(\n                ConstantInt::get(T_size, (uintptr_t)data.data()),\n                GV.getType());\n            GV.replaceAllUsesWith(v);\n            erase.push_back(&GV);\n        }\n    }\n    for (auto GV : erase)\n        GV->eraseFromParent();\n}\n\nstatic void jl_add_to_ee(std::unique_ptr<Module> m)\n{\n#if defined(_CPU_X86_64_) && defined(_OS_WINDOWS_)\n    // Add special values used by debuginfo to build the UnwindData table registration for Win64\n    Type *T_uint32 = Type::getInt32Ty(m->getContext());\n    ArrayType *atype = ArrayType::get(T_uint32, 3); // want 4-byte alignment of 12-bytes of data\n    GlobalVariable *gvs[2] = {\n        new GlobalVariable(*m, atype,\n            false, GlobalVariable::InternalLinkage,\n            ConstantAggregateZero::get(atype), \"__UnwindData\"),\n        new GlobalVariable(*m, atype,\n            false, GlobalVariable::InternalLinkage,\n            ConstantAggregateZero::get(atype), \"__catchjmp\") };\n    gvs[0]->setSection(\".text\");\n    gvs[1]->setSection(\".text\");\n    appendToUsed(*m, makeArrayRef((GlobalValue**)gvs, 2));\n#endif\n    jl_jit_share_data(*m);\n    assert(jl_ExecutionEngine);\n    jl_ExecutionEngine->addModule(std::move(m));\n}\n\nstatic int jl_add_to_ee(\n        std::unique_ptr<Module> &M,\n        StringMap<std::unique_ptr<Module>*> &NewExports,\n        DenseMap<Module*, int> &Queued,\n        std::vector<std::vector<std::unique_ptr<Module>*>> &ToMerge,\n        int depth)\n{\n    // DAG-sort (post-dominator) the compile to compute the minimum\n    // merge-module sets for linkage\n    if (!M)\n        return 0;\n    // First check and record if it's on the stack somewhere\n    {\n        auto &Cycle = Queued[M.get()];\n        if (Cycle)\n            return Cycle;\n        ToMerge.push_back({});\n        Cycle = depth;\n    }\n    int MergeUp = depth;\n    // Compute the cycle-id\n    for (auto &F : M->global_objects()) {\n        if (F.isDeclaration() && F.getLinkage() == GlobalValue::ExternalLinkage) {\n            auto Callee = NewExports.find(F.getName());\n            if (Callee != NewExports.end()) {\n                auto &CM = Callee->second;\n                int Down = jl_add_to_ee(*CM, NewExports, Queued, ToMerge, depth + 1);\n                assert(Down <= depth);\n                if (Down && Down < MergeUp)\n                    MergeUp = Down;\n            }\n        }\n    }\n    if (MergeUp == depth) {\n        // Not in a cycle (or at the top of it)\n        Queued.erase(M.get());\n        for (auto &CM : ToMerge.at(depth - 1)) {\n            assert(Queued.find(CM->get())->second == depth);\n            Queued.erase(CM->get());\n            jl_merge_module(M.get(), std::move(*CM));\n        }\n        jl_add_to_ee(std::move(M));\n        MergeUp = 0;\n    }\n    else {\n        // Add our frame(s) to the top of the cycle\n        Queued[M.get()] = MergeUp;\n        auto &Top = ToMerge.at(MergeUp - 1);\n        Top.push_back(&M);\n        for (auto &CM : ToMerge.at(depth - 1)) {\n            assert(Queued.find(CM->get())->second == depth);\n            Queued[CM->get()] = MergeUp;\n            Top.push_back(CM);\n        }\n    }\n    ToMerge.pop_back();\n    return MergeUp;\n}\n\nstatic void jl_add_to_ee(std::unique_ptr<Module> &M, StringMap<std::unique_ptr<Module>*> &NewExports)\n{\n    DenseMap<Module*, int> Queued;\n    std::vector<std::vector<std::unique_ptr<Module>*>> ToMerge;\n    jl_add_to_ee(M, NewExports, Queued, ToMerge, 1);\n    assert(!M);\n}\n\n\nstatic uint64_t getAddressForFunction(StringRef fname)\n{\n    auto addr = jl_ExecutionEngine->getFunctionAddress(fname);\n    assert(addr);\n    return addr;\n}\n\n// helper function for adding a DLLImport (dlsym) address to the execution engine\nvoid add_named_global(StringRef name, void *addr)\n{\n    jl_ExecutionEngine->addGlobalMapping(name, (uint64_t)(uintptr_t)addr);\n}\n\nextern \"C\" JL_DLLEXPORT\nsize_t jl_jit_total_bytes(void)\n{\n    return jl_ExecutionEngine->getTotalBytes();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/base/libc.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule Libc\n@doc \"\"\"\nInterface to libc, the C standard library.\n\"\"\" Libc\n\nimport Base: transcode, windowserror, show\nimport Core.Intrinsics: bitcast\n\nexport FILE, TmStruct, strftime, strptime, getpid, gethostname, free, malloc, calloc, realloc,\n    errno, strerror, flush_cstdio, systemsleep, time, transcode\nif Sys.iswindows()\n    export GetLastError, FormatMessage\nend\n\ninclude(string(length(Core.ARGS) >= 2 ? Core.ARGS[2] : \"\", \"errno_h.jl\"))  # include($BUILDROOT/base/errno_h.jl)\n\n## RawFD ##\n\n# Wrapper for an OS file descriptor (on both Unix and Windows)\n\"\"\"\n    RawFD\n\nPrimitive type which wraps the native OS file descriptor.\n`RawFD`s can be passed to methods like [`stat`](@ref) to\ndiscover information about the underlying file, and can\nalso be used to open streams, with the `RawFD` describing\nthe OS file backing the stream.\n\"\"\"\nprimitive type RawFD 32 end\nRawFD(fd::Integer) = bitcast(RawFD, Cint(fd))\nRawFD(fd::RawFD) = fd\nBase.cconvert(::Type{Cint}, fd::RawFD) = bitcast(Cint, fd)\n\ndup(x::RawFD) = ccall((@static Sys.iswindows() ? :_dup : :dup), RawFD, (RawFD,), x)\ndup(src::RawFD, target::RawFD) = systemerror(\"dup\", -1 ==\n    ccall((@static Sys.iswindows() ? :_dup2 : :dup2), Int32,\n                (RawFD, RawFD), src, target))\n\nshow(io::IO, fd::RawFD) = print(io, \"RawFD(\", bitcast(UInt32, fd), ')')  # avoids invalidation via show_default\n\n# Wrapper for an OS file descriptor (for Windows)\nif Sys.iswindows()\n    primitive type WindowsRawSocket sizeof(Ptr) * 8 end # On Windows file descriptors are HANDLE's and 64-bit on 64-bit Windows\n    WindowsRawSocket(handle::Ptr{Cvoid}) = bitcast(WindowsRawSocket, handle)\n    WindowsRawSocket(handle::WindowsRawSocket) = handle\n\n    Base.cconvert(::Type{Ptr{Cvoid}}, fd::WindowsRawSocket) = bitcast(Ptr{Cvoid}, fd)\n    _get_osfhandle(fd::RawFD) = ccall(:_get_osfhandle, WindowsRawSocket, (RawFD,), fd)\n    _get_osfhandle(fd::WindowsRawSocket) = fd\n    function dup(src::WindowsRawSocket)\n        new_handle = Ref(WindowsRawSocket(Ptr{Cvoid}(-1)))\n        my_process = ccall(:GetCurrentProcess, stdcall, Ptr{Cvoid}, ())\n        DUPLICATE_SAME_ACCESS = 0x2\n        status = ccall(:DuplicateHandle, stdcall, Int32,\n            (Ptr{Cvoid}, WindowsRawSocket, Ptr{Cvoid}, Ptr{WindowsRawSocket}, UInt32, Int32, UInt32),\n            my_process, src, my_process, new_handle, 0, false, DUPLICATE_SAME_ACCESS)\n        windowserror(\"dup failed\", status == 0)\n        return new_handle[]\n    end\n    function dup(src::WindowsRawSocket, target::RawFD)\n        fd = ccall(:_open_osfhandle, RawFD, (WindowsRawSocket, Int32), dup(src), 0)\n        dup(fd, target)\n        ccall(:_close, Int32, (RawFD,), fd)\n        nothing\n    end\n\nelse\n    _get_osfhandle(fd::RawFD) = fd\nend\n\n## FILE (not auto-finalized) ##\n\nstruct FILE\n    ptr::Ptr{Cvoid}\nend\n\nmodestr(s::IO) = modestr(isreadable(s), iswritable(s))\nmodestr(r::Bool, w::Bool) = r ? (w ? \"r+\" : \"r\") : (w ? \"w\" : throw(ArgumentError(\"neither readable nor writable\")))\n\nfunction FILE(fd::RawFD, mode)\n    FILEp = ccall((@static Sys.iswindows() ? :_fdopen : :fdopen), Ptr{Cvoid}, (Cint, Cstring), fd, mode)\n    systemerror(\"fdopen\", FILEp == C_NULL)\n    FILE(FILEp)\nend\n\nfunction FILE(s::IO)\n    f = FILE(dup(RawFD(fd(s))),modestr(s))\n    seek(f, position(s))\n    f\nend\n\nBase.unsafe_convert(T::Union{Type{Ptr{Cvoid}},Type{Ptr{FILE}}}, f::FILE) = convert(T, f.ptr)\nBase.close(f::FILE) = systemerror(\"fclose\", ccall(:fclose, Cint, (Ptr{Cvoid},), f.ptr) != 0)\n\nfunction Base.seek(h::FILE, offset::Integer)\n    systemerror(\"fseek\", ccall(:fseek, Cint, (Ptr{Cvoid}, Clong, Cint),\n                               h.ptr, offset, 0) != 0)\n    h\nend\n\nBase.position(h::FILE) = ccall(:ftell, Clong, (Ptr{Cvoid},), h.ptr)\n\n# flush C stdio output from external libraries\n\n\"\"\"\n    flush_cstdio()\n\nFlushes the C `stdout` and `stderr` streams (which may have been written to by external C code).\n\"\"\"\nflush_cstdio() = ccall(:jl_flush_cstdio, Cvoid, ())\n\n## time-related functions ##\n\n# TODO: check for usleep errors?\nif Sys.isunix()\n    systemsleep(s::Real) = ccall(:usleep, Int32, (UInt32,), round(UInt32, s*1e6))\nelseif Sys.iswindows()\n    function systemsleep(s::Real)\n        ccall(:Sleep, stdcall, Cvoid, (UInt32,), round(UInt32, s * 1e3))\n        return Int32(0)\n    end\nelse\n    error(\"systemsleep undefined for this OS\")\nend\n\"\"\"\n    systemsleep(s::Real)\n\nSuspends execution for `s` seconds.\nThis function does not yield to Julia's scheduler and therefore blocks\nthe Julia thread that it is running on for the duration of the sleep time.\n\nSee also: [`sleep`](@ref)\n\"\"\"\nsystemsleep\n\nstruct TimeVal\n   sec::Int64\n   usec::Int64\nend\n\nfunction TimeVal()\n    tv = Ref{TimeVal}()\n    status = ccall(:jl_gettimeofday, Cint, (Ref{TimeVal},), tv)\n    status != 0 && error(\"unable to determine current time: \", status)\n    return tv[]\nend\n\n\"\"\"\n    TmStruct([seconds])\n\nConvert a number of seconds since the epoch to broken-down format, with fields `sec`, `min`,\n`hour`, `mday`, `month`, `year`, `wday`, `yday`, and `isdst`.\n\"\"\"\nmutable struct TmStruct\n    sec::Int32\n    min::Int32\n    hour::Int32\n    mday::Int32\n    month::Int32\n    year::Int32\n    wday::Int32\n    yday::Int32\n    isdst::Int32\n    # on some platforms the struct is 14 words, even though 9 are specified\n    _10::Int32\n    _11::Int32\n    _12::Int32\n    _13::Int32\n    _14::Int32\n\n    TmStruct(sec, min, hour, mday, month, year, wday, yday, isdst) =\n        new(sec, min, hour, mday, month, year, wday, yday, isdst, 0,0,0,0,0)\n    TmStruct() = new(0,0,0,0,0,0,0,0,0,0,0,0,0,0)\n    function TmStruct(t::Real)\n        t = floor(t)\n        tm = TmStruct()\n        # TODO: add support for UTC via gmtime_r()\n        ccall(:localtime_r, Ptr{TmStruct}, (Ref{Int}, Ref{TmStruct}), t, tm)\n        return tm\n    end\nend\n\n\"\"\"\n    strftime([format], time)\n\nConvert time, given as a number of seconds since the epoch or a `TmStruct`, to a formatted\nstring using the given format. Supported formats are the same as those in the standard C\nlibrary.\n\"\"\"\nstrftime(t) = strftime(\"%c\", t)\nstrftime(fmt::AbstractString, t::Real) = strftime(fmt, TmStruct(t))\n# Use wcsftime instead of strftime to support different locales\nfunction strftime(fmt::AbstractString, tm::TmStruct)\n    wctimestr = Vector{Cwchar_t}(undef, 128)\n    n = ccall(:wcsftime, Csize_t, (Ptr{Cwchar_t}, Csize_t, Cwstring, Ref{TmStruct}),\n              wctimestr, length(wctimestr), fmt, tm)\n    n == 0 && return \"\"\n    return transcode(String, resize!(wctimestr, n))\nend\n\n\"\"\"\n    strptime([format], timestr)\n\nParse a formatted time string into a `TmStruct` giving the seconds, minute, hour, date, etc.\nSupported formats are the same as those in the standard C library. On some platforms,\ntimezones will not be parsed correctly. If the result of this function will be passed to\n`time` to convert it to seconds since the epoch, the `isdst` field should be filled in\nmanually. Setting it to `-1` will tell the C library to use the current system settings to\ndetermine the timezone.\n\"\"\"\nstrptime(timestr::AbstractString) = strptime(\"%c\", timestr)\nfunction strptime(fmt::AbstractString, timestr::AbstractString)\n    tm = TmStruct()\n    r = ccall(:strptime, Cstring, (Cstring, Cstring, Ref{TmStruct}), timestr, fmt, tm)\n    # the following would tell mktime() that this is a local time, and that\n    # it should try to guess the timezone. not sure if/how this should be\n    # exposed in the API.\n    # tm.isdst = -1\n    if r == C_NULL\n        # TODO: better error message\n        throw(ArgumentError(\"invalid arguments\"))\n    end\n    @static if Sys.isapple()\n        # if we didn't explicitly parse the weekday or year day, use mktime\n        # to fill them in automatically.\n        if !occursin(r\"([^%]|^)%(a|A|j|w|Ow)\", fmt)\n            ccall(:mktime, Int, (Ref{TmStruct},), tm)\n        end\n    end\n    return tm\nend\n\n# system date in seconds\n\n\"\"\"\n    time(t::TmStruct)\n\nConverts a `TmStruct` struct to a number of seconds since the epoch.\n\"\"\"\ntime(tm::TmStruct) = Float64(ccall(:mktime, Int, (Ref{TmStruct},), tm))\n\n\"\"\"\n    time()\n\nGet the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.\n\"\"\"\ntime() = ccall(:jl_clock_now, Float64, ())\n\n## process-related functions ##\n\n\"\"\"\n    getpid() -> Int32\n\nGet Julia's process ID.\n\"\"\"\ngetpid() = ccall(:jl_getpid, Int32, ())\n\n## network functions ##\n\n\"\"\"\n    gethostname() -> AbstractString\n\nGet the local machine's host name.\n\"\"\"\nfunction gethostname()\n    hn = Vector{UInt8}(undef, 256)\n    err = @static if Sys.iswindows()\n        ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n    else\n        ccall(:gethostname, Int32, (Ptr{UInt8}, UInt), hn, length(hn))\n    end\n    systemerror(\"gethostname\", err != 0)\n    return GC.@preserve hn unsafe_string(pointer(hn))\nend\n\n## system error handling ##\n\n\"\"\"\n    errno([code])\n\nGet the value of the C library's `errno`. If an argument is specified, it is used to set the\nvalue of `errno`.\n\nThe value of `errno` is only valid immediately after a `ccall` to a C library routine that\nsets it. Specifically, you cannot call `errno` at the next prompt in a REPL, because lots of\ncode is executed between prompts.\n\"\"\"\nerrno() = ccall(:jl_errno, Cint, ())\nerrno(e::Integer) = ccall(:jl_set_errno, Cvoid, (Cint,), e)\n\n\"\"\"\n    strerror(n=errno())\n\nConvert a system call error code to a descriptive string\n\"\"\"\nstrerror(e::Integer) = unsafe_string(ccall(:strerror, Cstring, (Int32,), e))\nstrerror() = strerror(errno())\n\n\"\"\"\n    GetLastError()\n\nCall the Win32 `GetLastError` function [only available on Windows].\n\"\"\"\nfunction GetLastError end\n\n\"\"\"\n    FormatMessage(n=GetLastError())\n\nConvert a Win32 system call error code to a descriptive string [only available on Windows].\n\"\"\"\nfunction FormatMessage end\n\nif Sys.iswindows()\n    GetLastError() = ccall(:GetLastError, stdcall, UInt32, ())\n\n    FormatMessage(e) = FormatMessage(UInt32(e))\n    function FormatMessage(e::UInt32=GetLastError())\n        FORMAT_MESSAGE_ALLOCATE_BUFFER = UInt32(0x100)\n        FORMAT_MESSAGE_FROM_SYSTEM = UInt32(0x1000)\n        FORMAT_MESSAGE_IGNORE_INSERTS = UInt32(0x200)\n        FORMAT_MESSAGE_MAX_WIDTH_MASK = UInt32(0xFF)\n        lpMsgBuf = Ref{Ptr{UInt16}}()\n        lpMsgBuf[] = 0\n        len = ccall(:FormatMessageW, stdcall, UInt32, (UInt32, Ptr{Cvoid}, UInt32, UInt32, Ptr{Ptr{UInt16}}, UInt32, Ptr{Cvoid}),\n                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                    C_NULL, e, 0, lpMsgBuf, 0, C_NULL)\n        p = lpMsgBuf[]\n        len == 0 && return \"\"\n        buf = Vector{UInt16}(undef, len)\n        GC.@preserve buf unsafe_copyto!(pointer(buf), p, len)\n        ccall(:LocalFree, stdcall, Ptr{Cvoid}, (Ptr{Cvoid},), p)\n        return transcode(String, buf)\n    end\nend\n\n## Memory related ##\n\n\"\"\"\n    free(addr::Ptr)\n\nCall `free` from the C standard library. Only use this on memory obtained from [`malloc`](@ref), not\non pointers retrieved from other C libraries. [`Ptr`](@ref) objects obtained from C libraries should\nbe freed by the free functions defined in that library, to avoid assertion failures if\nmultiple `libc` libraries exist on the system.\n\"\"\"\nfree(p::Ptr) = ccall(:free, Cvoid, (Ptr{Cvoid},), p)\n\n\"\"\"\n    malloc(size::Integer) -> Ptr{Cvoid}\n\nCall `malloc` from the C standard library.\n\"\"\"\nmalloc(size::Integer) = ccall(:malloc, Ptr{Cvoid}, (Csize_t,), size)\n\n\"\"\"\n    realloc(addr::Ptr, size::Integer) -> Ptr{Cvoid}\n\nCall `realloc` from the C standard library.\n\nSee warning in the documentation for [`free`](@ref) regarding only using this on memory originally\nobtained from [`malloc`](@ref).\n\"\"\"\nrealloc(p::Ptr, size::Integer) = ccall(:realloc, Ptr{Cvoid}, (Ptr{Cvoid}, Csize_t), p, size)\n\n\"\"\"\n    calloc(num::Integer, size::Integer) -> Ptr{Cvoid}\n\nCall `calloc` from the C standard library.\n\"\"\"\ncalloc(num::Integer, size::Integer) = ccall(:calloc, Ptr{Cvoid}, (Csize_t, Csize_t), num, size)\n\nfree(p::Cstring) = free(convert(Ptr{UInt8}, p))\nfree(p::Cwstring) = free(convert(Ptr{Cwchar_t}, p))\n\n## Random numbers ##\n\n# To limit dependency on rand functionality implemented in the Random module,\n# Libc.rand is used in file.jl, and could be used in error.jl (but it breaks a test)\n\"\"\"\n    rand([T::Type])\n\nInterface to the C `rand()` function. If `T` is provided, generate a value of type `T`\nby composing two calls to `rand()`. `T` can be `UInt32` or `Float64`.\n\"\"\"\nrand() = ccall(:rand, Cint, ())\n@static if Sys.iswindows()\n    # Windows RAND_MAX is 2^15-1\n    rand(::Type{UInt32}) = ((rand() % UInt32) << 17) \u22bb ((rand() % UInt32) << 8) \u22bb (rand() % UInt32)\nelse\n    # RAND_MAX is at least 2^15-1 in theory, but we assume 2^16-1\n    # on non-Windows systems (in practice, it's 2^31-1)\n    rand(::Type{UInt32}) = ((rand() % UInt32) << 16) \u22bb (rand() % UInt32)\nend\nrand(::Type{Float64}) = rand(UInt32) * 2.0^-32\n\n\"\"\"\n    srand([seed])\n\nInterface to the C `srand(seed)` function.\n\"\"\"\nsrand(seed=floor(Int, time()) % Cuint) = ccall(:srand, Cvoid, (Cuint,), seed)\n\n# Include dlopen()/dlpath() code\ninclude(\"libdl.jl\")\nusing .Libdl\n\nend # module\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/base/libdl.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule Libdl\n@doc \"\"\"\nInterface to libdl. Provides dynamic linking support.\n\"\"\" Libdl\n\nimport Base.DL_LOAD_PATH\n\nexport DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n    dlpath, find_library, dlext, dllist\n\n\"\"\"\n    DL_LOAD_PATH\n\nWhen calling [`dlopen`](@ref), the paths in this list will be searched first, in\norder, before searching the system locations for a valid library handle.\n\"\"\"\nDL_LOAD_PATH\n\n# note: constants to match JL_RTLD_* in src/julia.h, translated\n#       to system-specific values by JL_RTLD macro in src/dlload.c\nconst RTLD_LOCAL     = 0x00000001\nconst RTLD_GLOBAL    = 0x00000002\nconst RTLD_LAZY      = 0x00000004\nconst RTLD_NOW       = 0x00000008\nconst RTLD_NODELETE  = 0x00000010\nconst RTLD_NOLOAD    = 0x00000020\nconst RTLD_DEEPBIND  = 0x00000040\nconst RTLD_FIRST     = 0x00000080\n\n\"\"\"\n    RTLD_DEEPBIND\n    RTLD_FIRST\n    RTLD_GLOBAL\n    RTLD_LAZY\n    RTLD_LOCAL\n    RTLD_NODELETE\n    RTLD_NOLOAD\n    RTLD_NOW\n\nEnum constant for [`dlopen`](@ref). See your platform man page for details, if\napplicable.\n\"\"\"\n(RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL, RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW)\n\n\"\"\"\n    dlsym(handle, sym; throw_error::Bool = true)\n\nLook up a symbol from a shared library handle, return callable function pointer on success.\n\nIf the symbol cannot be found, this method throws an error, unless the keyword argument\n`throw_error` is set to `false`, in which case this method returns `nothing`.\n\"\"\"\nfunction dlsym(hnd::Ptr, s::Union{Symbol,AbstractString}; throw_error::Bool = true)\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    val = Ref(Ptr{Cvoid}(0))\n    symbol_found = ccall(:jl_dlsym, Cint,\n        (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}, Cint),\n        hnd, s, val, Int64(throw_error)\n    )\n    if symbol_found == 0\n        return nothing\n    end\n    return val[]\nend\n\n\"\"\"\n    dlsym_e(handle, sym)\n\nLook up a symbol from a shared library handle, silently return `C_NULL` on lookup failure.\nThis method is now deprecated in favor of `dlsym(handle, sym; throw_error=false)`.\n\"\"\"\nfunction dlsym_e(hnd::Ptr, s::Union{Symbol,AbstractString})\n    return something(dlsym(hnd, s; throw_error=false), C_NULL)\nend\n\n\"\"\"\n    dlopen(libfile::AbstractString [, flags::Integer]; throw_error:Bool = true)\n\nLoad a shared library, returning an opaque handle.\n\nThe extension given by the constant `dlext` (`.so`, `.dll`, or `.dylib`)\ncan be omitted from the `libfile` string, as it is automatically appended\nif needed.   If `libfile` is not an absolute path name, then the paths\nin the array `DL_LOAD_PATH` are searched for `libfile`, followed by the\nsystem load path.\n\nThe optional flags argument is a bitwise-or of zero or more of `RTLD_LOCAL`, `RTLD_GLOBAL`,\n`RTLD_LAZY`, `RTLD_NOW`, `RTLD_NODELETE`, `RTLD_NOLOAD`, `RTLD_DEEPBIND`, and `RTLD_FIRST`.\nThese are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS)\ndlopen command, if possible, or are ignored if the specified functionality is not available\non the current platform. The default flags are platform specific. On MacOS the default\n`dlopen` flags are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` while on other platforms the\ndefaults are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL`. An important usage of these flags is to\nspecify non default behavior for when the dynamic library loader binds library references to\nexported symbols and if the bound references are put into process local or global scope. For\ninstance `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` allows the library's symbols to be available\nfor usage in other shared libraries, addressing situations where there are dependencies\nbetween shared libraries.\n\nIf the library cannot be found, this method throws an error, unless the keyword argument\n`throw_error` is set to `false`, in which case this method returns `nothing`.\n\n!!! note\n     From Julia 1.6 on, this method replaces paths starting with `@executable_path/` with\n     the path to the Julia executable, allowing for relocatable relative-path loads. In\n     Julia 1.5 and earlier, this only worked on macOS.\n\"\"\"\nfunction dlopen end\n\ndlopen(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND; kwargs...) =\n    dlopen(string(s), flags; kwargs...)\n\nfunction dlopen(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND; throw_error::Bool = true)\n    ret = ccall(:jl_load_dynamic_library, Ptr{Cvoid}, (Cstring,UInt32,Cint), s, flags, Cint(throw_error))\n    if ret == C_NULL\n        return nothing\n    end\n    return ret\nend\n\n\"\"\"\n    dlopen(f::Function, args...; kwargs...)\n\nWrapper for usage with `do` blocks to automatically close the dynamic library once\ncontrol flow leaves the `do` block scope.\n\n# Example\n```julia\nvendor = dlopen(\"libblas\") do lib\n    if Libdl.dlsym(lib, :openblas_set_num_threads; throw_error=false) !== nothing\n        return :openblas\n    else\n        return :other\n    end\nend\n```\n\"\"\"\nfunction dlopen(f::Function, args...; kwargs...)\n    hdl = nothing\n    try\n        hdl = dlopen(args...; kwargs...)\n        f(hdl)\n    finally\n        dlclose(hdl)\n    end\nend\n\n\"\"\"\n    dlopen_e(libfile::AbstractString [, flags::Integer])\n\nSimilar to [`dlopen`](@ref), except returns `C_NULL` instead of raising errors.\nThis method is now deprecated in favor of `dlopen(libfile::AbstractString [, flags::Integer]; throw_error=false)`.\n\"\"\"\ndlopen_e(args...) = something(dlopen(args...; throw_error=false), C_NULL)\n\n\"\"\"\n    dlclose(handle)\n\nClose shared library referenced by handle.\n\"\"\"\nfunction dlclose(p::Ptr)\n    0 == ccall(:jl_dlclose, Cint, (Ptr{Cvoid},), p)\nend\n\n\"\"\"\n    dlclose(::Nothing)\n\nFor the very common pattern usage pattern of\n\n    try\n        hdl = dlopen(library_name)\n        ... do something\n    finally\n        dlclose(hdl)\n    end\n\nWe define a `dlclose()` method that accepts a parameter of type `Nothing`, so\nthat user code does not have to change its behavior for the case that `library_name`\nwas not found.\n\"\"\"\nfunction dlclose(p::Nothing)\nend\n\n\"\"\"\n    find_library(names, locations)\n\nSearches for the first library in `names` in the paths in the `locations` list,\n`DL_LOAD_PATH`, or system library paths (in that order) which can successfully be dlopen'd.\nOn success, the return value will be one of the names (potentially prefixed by one of the\npaths in locations). This string can be assigned to a `global const` and used as the library\nname in future `ccall`'s. On failure, it returns the empty string.\n\"\"\"\nfunction find_library(libnames, extrapaths=String[])\n    for lib in libnames\n        for path in extrapaths\n            l = joinpath(path, lib)\n            p = dlopen(l, RTLD_LAZY; throw_error=false)\n            if p !== nothing\n                dlclose(p)\n                return l\n            end\n        end\n        p = dlopen(lib, RTLD_LAZY; throw_error=false)\n        if p !== nothing\n            dlclose(p)\n            return lib\n        end\n    end\n    return \"\"\nend\nfind_library(libname::Union{Symbol,AbstractString}, extrapaths=String[]) =\n    find_library([string(libname)], extrapaths)\n\n\"\"\"\n    dlpath(handle::Ptr{Cvoid})\n\nGiven a library `handle` from `dlopen`, return the full path.\n\"\"\"\nfunction dlpath(handle::Ptr{Cvoid})\n    p = ccall(:jl_pathname_for_handle, Cstring, (Ptr{Cvoid},), handle)\n    s = unsafe_string(p)\n    Sys.iswindows() && Libc.free(p)\n    return s\nend\n\n\"\"\"\n    dlpath(libname::Union{AbstractString, Symbol})\n\nGet the full path of the library `libname`.\n\n# Example\n```julia-repl\njulia> dlpath(\"libjulia\")\n```\n\"\"\"\nfunction dlpath(libname::Union{AbstractString, Symbol})\n    handle = dlopen(libname)\n    path = dlpath(handle)\n    dlclose(handle)\n    return path\nend\n\nif Sys.isapple()\n    const dlext = \"dylib\"\nelseif Sys.iswindows()\n    const dlext = \"dll\"\nelse\n    #assume Sys.islinux, or similar\n    const dlext = \"so\"\nend\n\n\"\"\"\n    dlext\n\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\"\"\"\ndlext\n\nif (Sys.islinux() || Sys.isbsd()) && !Sys.isapple()\n    struct dl_phdr_info\n        # Base address of object\n        addr::Cuint\n\n        # Null-terminated name of object\n        name::Ptr{UInt8}\n\n        # Pointer to array of ELF program headers for this object\n        phdr::Ptr{Cvoid}\n\n        # Number of program headers for this object\n        phnum::Cshort\n    end\n\n    # This callback function called by dl_iterate_phdr() on Linux and BSD's\n    # DL_ITERATE_PHDR(3) on freebsd\n    function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Array{String,1})\n        name = unsafe_string(di.name)\n        push!(dynamic_libraries, name)\n        return Cint(0)\n    end\nend\n\n\"\"\"\n    dllist()\n\nReturn the paths of dynamic libraries currently loaded in a `Vector{String}`.\n\"\"\"\nfunction dllist()\n    dynamic_libraries = Vector{String}()\n\n    @static if Sys.isapple()\n        numImages = ccall(:_dyld_image_count, Cint, ())\n\n        # start at 1 instead of 0 to skip self\n        for i in 1:numImages-1\n            name = unsafe_string(ccall(:_dyld_get_image_name, Cstring, (UInt32,), i))\n            push!(dynamic_libraries, name)\n        end\n    elseif Sys.islinux() || Sys.isbsd()\n        callback = @cfunction(dl_phdr_info_callback, Cint,\n                              (Ref{dl_phdr_info}, Csize_t, Ref{Vector{String}}))\n        ccall(:dl_iterate_phdr, Cint, (Ptr{Cvoid}, Ref{Vector{String}}), callback, dynamic_libraries)\n        popfirst!(dynamic_libraries)\n        filter!(!isempty, dynamic_libraries)\n    elseif Sys.iswindows()\n        ccall(:jl_dllist, Cint, (Any,), dynamic_libraries)\n    else\n        # unimplemented\n    end\n\n    return dynamic_libraries\nend\n\nend # module Libdl\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/base/binaryplatforms.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule BinaryPlatforms\n\nexport AbstractPlatform, Platform, HostPlatform, platform_dlext, tags, arch, os,\n       os_version, libc, compiler_abi, libgfortran_version, libstdcxx_version,\n       cxxstring_abi, parse_dl_name_version, detect_libgfortran_version,\n       detect_libstdcxx_version, detect_cxxstring_abi, call_abi, wordsize, triplet,\n       select_platform, platforms_match, platform_name\nimport .Libc.Libdl\n\n### Submodule with information about CPU features\ninclude(\"cpuid.jl\")\nusing .CPUID\n\n# This exists to ease compatibility with old-style Platform objects\nabstract type AbstractPlatform; end\n\n\"\"\"\n    Platform\n\nA `Platform` represents all relevant pieces of information that a julia process may need\nto know about its execution environment, such as the processor architecture, operating\nsystem, libc implementation, etc...  It is, at its heart, a key-value mapping of tags\n(such as `arch`, `os`, `libc`, etc...) to values (such as `\"arch\" => \"x86_64\"`, or\n`\"os\" => \"windows\"`, etc...).  `Platform` objects are extensible in that the tag mapping\nis open for users to add their own mappings to, as long as the mappings do not conflict\nwith the set of reserved tags: `arch`, `os`, `os_version`, `libc`, `call_abi`,\n`libgfortran_version`, `libstdcxx_version`, `cxxstring_abi` and `julia_version`.\n\nValid tags and values are composed of alphanumeric and period characters.  All tags and\nvalues will be lowercased when stored to reduce variation.\n\nExample:\n\n    Platform(\"x86_64\", \"windows\"; cuda = \"10.1\")\n\"\"\"\nstruct Platform <: AbstractPlatform\n    tags::Dict{String,String}\n    # The \"compare strategy\" allows selective overriding on how a tag is compared\n    compare_strategies::Dict{String,Function}\n\n    function Platform(arch::String, os::String;\n                      validate_strict::Bool = false,\n                      compare_strategies::Dict{String,<:Function} = Dict{String,Function}(),\n                      kwargs...)\n        # A wee bit of normalization\n        os = lowercase(os)\n        arch = CPUID.normalize_arch(arch)\n\n        tags = Dict{String,String}(\n            \"arch\" => arch,\n            \"os\" => os,\n        )\n        for (tag, value) in kwargs\n            tag = lowercase(string(tag::Symbol))\n            if tag \u2208 (\"arch\", \"os\")\n                throw(ArgumentError(\"Cannot double-pass key $(tag)\"))\n            end\n\n            # Drop `nothing` values; this means feature is not present or use default value.\n            if value === nothing\n                continue\n            end\n\n            # Normalize things that are known to be version numbers so that comparisons are easy.\n            # Note that in our effort to be extremely compatible, we actually allow something that\n            # doesn't parse nicely into a VersionNumber to persist, but if `validate_strict` is\n            # set to `true`, it will cause an error later on.\n            if tag \u2208 (\"libgfortran_version\", \"libstdcxx_version\", \"os_version\")\n                if isa(value, VersionNumber)\n                    value = string(value)\n                elseif isa(value, AbstractString)\n                    v = tryparse(VersionNumber, String(value))\n                    if isa(v, VersionNumber)\n                        value = string(v)\n                    end\n                end\n            end\n\n            # Use `add_tag!()` to add the tag to our collection of tags\n            add_tag!(tags, tag, string(value)::String)\n        end\n\n        # Auto-map call_abi and libc where necessary:\n        if os == \"linux\" && !haskey(tags, \"libc\")\n            # Default to `glibc` on Linux\n            tags[\"libc\"] = \"glibc\"\n        end\n        if os == \"linux\" && arch \u2208 (\"armv7l\", \"armv6l\") && \"call_abi\" \u2209 keys(tags)\n            # default `call_abi` to `eabihf` on 32-bit ARM\n            tags[\"call_abi\"] = \"eabihf\"\n        end\n\n        # If the user is asking for strict validation, do so.\n        if validate_strict\n            validate_tags(tags)\n        end\n\n        # By default, we compare julia_version only against major and minor versions:\n        if haskey(tags, \"julia_version\") && !haskey(compare_strategies, \"julia_version\")\n            compare_strategies[\"julia_version\"] = (a::String, b::String, a_comparator, b_comparator) -> begin\n                a = VersionNumber(a)\n                b = VersionNumber(b)\n                return a.major == b.major && a.minor == b.minor\n            end\n        end\n\n        return new(tags, compare_strategies)\n    end\nend\n\n# Simple tag insertion that performs a little bit of validation\nfunction add_tag!(tags::Dict{String,String}, tag::String, value::String)\n    # I know we said only alphanumeric and dots, but let's be generous so that we can expand\n    # our support in the future while remaining as backwards-compatible as possible.  The\n    # only characters that are absolutely disallowed right now are `-`, `+`, ` ` and things\n    # that are illegal in filenames:\n    nonos = raw\"\"\"+- /<>:\"'\\|?*\"\"\"\n    if any(occursin(nono, tag) for nono in nonos)\n        throw(ArgumentError(\"Invalid character in tag name \\\"$(tag)\\\"!\"))\n    end\n\n    # Normalize and reject nonos\n    value = lowercase(value)\n    if any(occursin(nono, value) for nono in nonos)\n        throw(ArgumentError(\"Invalid character in tag value \\\"$(value)\\\"!\"))\n    end\n    tags[tag] = value\n    return value\nend\n\n# Other `Platform` types can override this (I'm looking at you, `AnyPlatform`)\ntags(p::Platform) = p.tags\n\n# Make it act more like a dict\nBase.getindex(p::AbstractPlatform, k::String) = getindex(tags(p), k)\nBase.haskey(p::AbstractPlatform, k::String) = haskey(tags(p), k)\nfunction Base.setindex!(p::AbstractPlatform, v::String, k::String)\n    add_tag!(tags(p), k, v)\n    return p\nend\n\n# Hash definitino to ensure that it's stable\nfunction Base.hash(p::Platform, h::UInt)\n    h += 0x506c6174666f726d % UInt\n    h = hash(p.tags, h)\n    h = hash(p.compare_strategies, h)\n    return h\nend\n\n# Simple equality definition; for compatibility testing, use `platforms_match()`\nfunction Base.:(==)(a::Platform, b::Platform)\n    return a.tags == b.tags && a.compare_strategies == b.compare_strategies\nend\n\n\n# Allow us to easily serialize Platform objects\nfunction Base.repr(p::Platform; context=nothing)\n    str = string(\n        \"Platform(\",\n        repr(arch(p)),\n        \", \",\n        repr(os(p)),\n        \"; \",\n        join((\"$(k) = $(repr(v))\" for (k, v) in tags(p) if k \u2209 (\"arch\", \"os\")), \", \"),\n        \")\",\n    )\nend\n\n# Make showing the platform a bit more palatable\nfunction Base.show(io::IO, p::Platform)\n    str = string(platform_name(p), \" \", arch(p))\n    # Add on all the other tags not covered by os/arch:\n    other_tags = sort(collect(filter(kv -> kv[1] \u2209 (\"os\", \"arch\"), tags(p))))\n    if !isempty(other_tags)\n        str = string(str, \" {\", join([string(k, \"=\", v) for (k, v) in other_tags], \", \"), \"}\")\n    end\n    print(io, str)\nend\n\nfunction validate_tags(tags::Dict)\n    throw_invalid_key(k) = throw(ArgumentError(\"Key \\\"$(k)\\\" cannot have value \\\"$(tags[k])\\\"\"))\n    # Validate `arch`\n    if tags[\"arch\"] \u2209 (\"x86_64\", \"i686\", \"armv7l\", \"armv6l\", \"aarch64\", \"powerpc64le\")\n        throw_invalid_key(\"arch\")\n    end\n    # Validate `os`\n    if tags[\"os\"] \u2209 (\"linux\", \"macos\", \"freebsd\", \"windows\")\n        throw_invalid_key(\"os\")\n    end\n    # Validate `os`/`arch` combination\n    throw_os_mismatch() = throw(ArgumentError(\"Invalid os/arch combination: $(tags[\"os\"])/$(tags[\"arch\"])\"))\n    if tags[\"os\"] == \"windows\" && tags[\"arch\"] \u2209 (\"x86_64\", \"i686\", \"armv7l\", \"aarch64\")\n        throw_os_mismatch()\n    end\n    if tags[\"os\"] == \"macos\" && tags[\"arch\"] \u2209 (\"x86_64\", \"aarch64\")\n        throw_os_mismatch()\n    end\n\n    # Validate `os`/`libc` combination\n    throw_libc_mismatch() = throw(ArgumentError(\"Invalid os/libc combination: $(tags[\"os\"])/$(tags[\"libc\"])\"))\n    if tags[\"os\"] == \"linux\"\n        # Linux always has a `libc` entry\n        if tags[\"libc\"] \u2209 (\"glibc\", \"musl\")\n            throw_libc_mismatch()\n        end\n    else\n        # Nothing else is allowed to have a `libc` entry\n        if haskey(tags, \"libc\")\n            throw_libc_mismatch()\n        end\n    end\n\n    # Validate `os`/`arch`/`call_abi` combination\n    throw_call_abi_mismatch() = throw(ArgumentError(\"Invalid os/arch/call_abi combination: $(tags[\"os\"])/$(tags[\"arch\"])/$(tags[\"call_abi\"])\"))\n    if tags[\"os\"] == \"linux\" && tags[\"arch\"] \u2208 (\"armv7l\", \"armv6l\")\n        # If an ARM linux has does not have `call_abi` set to something valid, be sad.\n        if !haskey(tags, \"call_abi\") || tags[\"call_abi\"] \u2209 (\"eabihf\", \"eabi\")\n            throw_call_abi_mismatch()\n        end\n    else\n        # Nothing else should have a `call_abi`.\n        if haskey(tags, \"call_abi\")\n            throw_call_abi_mismatch()\n        end\n    end\n\n    # Validate `libgfortran_version` is a parsable `VersionNumber`\n    throw_version_number(k) = throw(ArgumentError(\"\\\"$(k)\\\" cannot have value \\\"$(tags[k])\\\", must be a valid VersionNumber\"))\n    if \"libgfortran_version\" in keys(tags) && tryparse(VersionNumber, tags[\"libgfortran_version\"]) === nothing\n        throw_version_number(\"libgfortran_version\")\n    end\n\n    # Validate `cxxstring_abi` is one of the two valid options:\n    if \"cxxstring_abi\" in keys(tags) && tags[\"cxxstring_abi\"] \u2209 (\"cxx03\", \"cxx11\")\n        throw_invalid_key(\"cxxstring_abi\")\n    end\n\n    # Validate `libstdcxx_version` is a parsable `VersionNumber`\n    if \"libstdcxx_version\" in keys(tags) && tryparse(VersionNumber, tags[\"libstdcxx_version\"]) === nothing\n        throw_version_number(\"libstdcxx_version\")\n    end\nend\n\nfunction set_compare_strategy!(p::Platform, key::String, f::Function)\n    if !haskey(p.tags, key)\n        throw(ArgumentError(\"Cannot set comparison strategy for nonexistant tag $(key)!\"))\n    end\n    p.compare_strategies[key] = f\nend\n\nfunction get_compare_strategy(p::Platform, key::String, default = compare_default)\n    if !haskey(p.tags, key)\n        throw(ArgumentError(\"Cannot get comparison strategy for nonexistant tag $(key)!\"))\n    end\n    return get(p.compare_strategies, key, default)\nend\nget_compare_strategy(p::AbstractPlatform, key::String, default = compare_default) = default\n\n\n\n\"\"\"\n    compare_default(a::String, b::String, a_requested::Bool, b_requested::Bool)\n\nDefault comparison strategy that falls back to `a == b`.  This only ever happens if both\n`a` and `b` request this strategy, as any other strategy is preferrable to this one.\n\"\"\"\nfunction compare_default(a::String, b::String, a_requested::Bool, b_requested::Bool)\n    return a == b\nend\n\n\"\"\"\n    compare_version_cap(a::String, b::String, a_comparator, b_comparator)\n\nExample comparison strategy for `set_comparison_strategy!()` that implements a version\ncap for host platforms that support _up to_ a particular version number.  As an example,\nif an artifact is built for macOS 10.9, it can run on macOS 10.11, however if it were\nbuilt for macOS 10.12, it could not.  Therefore, the host platform of macOS 10.11 has a\nversion cap at `v\"10.11\"`.\n\nNote that because both hosts and artifacts are represented with `Platform` objects it\nis possible to call `platforms_match()` with two artifacts, a host and an artifact, an\nartifact and a host, and even two hosts.  We attempt to do something intelligent for all\ncases, but in the case of comparing version caps between two hosts, we return `true` only\nif the two host platforms are in fact identical.\n\"\"\"\nfunction compare_version_cap(a::String, b::String, a_requested::Bool, b_requested::Bool)\n    a = VersionNumber(a)\n    b = VersionNumber(b)\n\n    # If both b and a requested, then we fall back to equality:\n    if a_requested && b_requested\n        return a == b\n    end\n\n    # Otherwise, do the comparison between the the single version cap and the single version:\n    if a_requested\n        return b <= a\n    else\n        return a <= b\n    end\nend\n\n\n\n\"\"\"\n    HostPlatform(p::AbstractPlatform)\n\nConvert a `Platform` to act like a \"host\"; e.g. if it has a version-bound tag such as\n`\"libstdcxx_version\" => \"3.4.26\"`, it will treat that value as an upper bound, rather\nthan a characteristic.  `Platform` objects that define artifacts generally denote the\nSDK or version that the artifact was built with, but for platforms, these versions are\ngenerally the maximal version the platform can support.  The way this transformation\nis implemented is to change the appropriate comparison strategies to treat these pieces\nof data as bounds rather than points in any comparison.\n\"\"\"\nfunction HostPlatform(p::AbstractPlatform)\n    if haskey(p, \"os_version\")\n        set_compare_strategy!(p, \"os_version\", compare_version_cap)\n    end\n    if haskey(p, \"libstdcxx_version\")\n        set_compare_strategy!(p, \"libstdcxx_version\", compare_version_cap)\n    end\n    return p\nend\n\n\"\"\"\n    arch(p::AbstractPlatform)\n\nGet the architecture for the given `Platform` object as a `String`.\n\n# Examples\n```jldoctest\njulia> arch(Platform(\"aarch64\", \"Linux\"))\n\"aarch64\"\n\njulia> arch(Platform(\"amd64\", \"freebsd\"))\n\"x86_64\"\n```\n\"\"\"\narch(p::AbstractPlatform) = get(tags(p), \"arch\", nothing)\n\n\"\"\"\n    os(p::AbstractPlatform)\n\nGet the operating system for the given `Platform` object as a `String`.\n\n# Examples\n```jldoctest\njulia> os(Platform(\"armv7l\", \"Linux\"))\n\"linux\"\n\njulia> os(Platform(\"aarch64\", \"macos\"))\n\"macos\"\n```\n\"\"\"\nos(p::AbstractPlatform) = get(tags(p), \"os\", nothing)\n\n# As a special helper, it's sometimes useful to know the current OS at compile-time\nfunction os()\n    if Sys.iswindows()\n        return \"windows\"\n    elseif Sys.isapple()\n        return \"macos\"\n    elseif Sys.isbsd()\n        return \"freebsd\"\n    else\n        return \"linux\"\n    end\nend\n\n\"\"\"\n    libc(p::AbstractPlatform)\n\nGet the libc for the given `Platform` object as a `String`.  Returns `nothing` on\nplatforms with no explicit `libc` choices (which is most platforms).\n\n# Examples\n```jldoctest\njulia> libc(Platform(\"armv7l\", \"Linux\"))\n\"glibc\"\n\njulia> libc(Platform(\"aarch64\", \"linux\"; libc=\"musl\"))\n\"musl\"\n\njulia> libc(Platform(\"i686\", \"Windows\"))\n```\n\"\"\"\nlibc(p::AbstractPlatform) = get(tags(p), \"libc\", nothing)\n\n\"\"\"\n    call_abi(p::AbstractPlatform)\n\nGet the call ABI for the given `Platform` object as a `String`.  Returns `nothing` on\nplatforms with no explicit `call_abi` choices (which is most platforms).\n\n# Examples\n```jldoctest\njulia> call_abi(Platform(\"armv7l\", \"Linux\"))\n\"eabihf\"\n\njulia> call_abi(Platform(\"x86_64\", \"macos\"))\n```\n\"\"\"\ncall_abi(p::AbstractPlatform) = get(tags(p), \"call_abi\", nothing)\n\nconst platform_names = Dict(\n    \"linux\" => \"Linux\",\n    \"macos\" => \"macOS\",\n    \"windows\" => \"Windows\",\n    \"freebsd\" => \"FreeBSD\",\n    nothing => \"Unknown\",\n)\n\n\"\"\"\n    platform_name(p::AbstractPlatform)\n\nGet the \"platform name\" of the given platform, returning e.g. \"Linux\" or \"Windows\".\n\"\"\"\nfunction platform_name(p::AbstractPlatform)\n    return platform_names[os(p)]\nend\n\nfunction VNorNothing(d::Dict, key)\n    v = get(d, key, nothing)\n    if v === nothing\n        return nothing\n    end\n    return VersionNumber(v)::VersionNumber\nend\n\n\"\"\"\n    libgfortran_version(p::AbstractPlatform)\n\nGet the libgfortran version dictated by this `Platform` object as a `VersionNumber`,\nor `nothing` if no compatibility bound is imposed.\n\"\"\"\nlibgfortran_version(p::AbstractPlatform) = VNorNothing(tags(p), \"libgfortran_version\")\n\n\"\"\"\n    libstdcxx_version(p::AbstractPlatform)\n\nGet the libstdc++ version dictated by this `Platform` object, or `nothing` if no\ncompatibility bound is imposed.\n\"\"\"\nlibstdcxx_version(p::AbstractPlatform) = VNorNothing(tags(p), \"libstdcxx_version\")\n\n\"\"\"\n    cxxstring_abi(p::AbstractPlatform)\n\nGet the c++ string ABI dictated by this `Platform` object, or `nothing` if no ABI is imposed.\n\"\"\"\ncxxstring_abi(p::AbstractPlatform) = get(tags(p), \"cxxstring_abi\", nothing)\n\n\"\"\"\n    os_version(p::AbstractPlatform)\n\nGet the OS version dictated by this `Platform` object, or `nothing` if no OS version is\nimposed/no data is available.  This is most commonly used by MacOS and FreeBSD objects\nwhere we have high platform SDK fragmentation, and features are available only on certain\nplatform versions.\n\"\"\"\nos_version(p::AbstractPlatform) = VNorNothing(tags(p), \"os_version\")\n\n\"\"\"\n    wordsize(p::AbstractPlatform)\n\nGet the word size for the given `Platform` object.\n\n# Examples\n```jldoctest\njulia> wordsize(Platform(\"armv7l\", \"linux\"))\n32\n\njulia> wordsize(Platform(\"x86_64\", \"macos\"))\n64\n```\n\"\"\"\nwordsize(p::AbstractPlatform) = (arch(p) \u2208 (\"i686\", \"armv6l\", \"armv7l\")) ? 32 : 64\n\n\"\"\"\n    triplet(p::AbstractPlatform; exclude_tags::Vector{String})\n\nGet the target triplet for the given `Platform` object as a `String`.\n\n# Examples\n```jldoctest\njulia> triplet(Platform(\"x86_64\", \"MacOS\"))\n\"x86_64-apple-darwin\"\n\njulia> triplet(Platform(\"i686\", \"Windows\"))\n\"i686-w64-mingw32\"\n\njulia> triplet(Platform(\"armv7l\", \"Linux\"; libgfortran_version=\"3\"))\n\"armv7l-linux-gnueabihf-libgfortran3\"\n```\n\"\"\"\nfunction triplet(p::AbstractPlatform)\n    str = string(\n        arch(p)::Union{Symbol,String},\n        os_str(p),\n        libc_str(p),\n        call_abi_str(p),\n    )\n\n    # Tack on optional compiler ABI flags\n    if libgfortran_version(p) !== nothing\n        str = string(str, \"-libgfortran\", libgfortran_version(p).major)\n    end\n    if cxxstring_abi(p) !== nothing\n        str = string(str, \"-\", cxxstring_abi(p))\n    end\n    if libstdcxx_version(p) !== nothing\n        str = string(str, \"-libstdcxx\", libstdcxx_version(p).patch)\n    end\n\n    # Tack on all extra tags\n    for (tag, val) in tags(p)\n        if tag \u2208 (\"os\", \"arch\", \"libc\", \"call_abi\", \"libgfortran_version\", \"libstdcxx_version\", \"cxxstring_abi\", \"os_version\")\n            continue\n        end\n        str = string(str, \"-\", tag, \"+\", val)\n    end\n    return str\nend\n\nfunction os_str(p::AbstractPlatform)\n    if os(p) == \"linux\"\n        return \"-linux\"\n    elseif os(p) == \"macos\"\n        osvn = os_version(p)\n        if osvn !== nothing\n            return \"-apple-darwin$(osvn.major)\"\n        else\n            return \"-apple-darwin\"\n        end\n    elseif os(p) == \"windows\"\n        return \"-w64-mingw32\"\n    elseif os(p) == \"freebsd\"\n        osvn = os_version(p)\n        if osvn !== nothing\n            return \"-unknown-freebsd$(osvn.major).$(osvn.minor)\"\n        else\n            return \"-unknown-freebsd\"\n        end\n    else\n        return \"-unknown\"\n    end\nend\n\n# Helper functions for Linux and FreeBSD libc/abi mishmashes\nfunction libc_str(p::AbstractPlatform)\n    lc = libc(p)\n    if lc === nothing\n        return \"\"\n    elseif lc === \"glibc\"\n        return \"-gnu\"\n    else\n        return string(\"-\", lc)\n    end\nend\nfunction call_abi_str(p::AbstractPlatform)\n    cabi = call_abi(p)\n    cabi === nothing ? \"\" : string(cabi::Union{Symbol,String})\nend\n\nSys.isapple(p::AbstractPlatform) = os(p) == \"macos\"\nSys.islinux(p::AbstractPlatform) = os(p) == \"linux\"\nSys.iswindows(p::AbstractPlatform) = os(p) == \"windows\"\nSys.isfreebsd(p::AbstractPlatform) = os(p) == \"freebsd\"\nSys.isbsd(p::AbstractPlatform) = os(p) \u2208 (\"freebsd\", \"macos\")\n\nconst arch_mapping = Dict(\n    \"x86_64\" => \"(x86_|amd)64\",\n    \"i686\" => \"i\\\\d86\",\n    \"aarch64\" => \"(aarch64|arm64)\",\n    \"armv7l\" => \"arm(v7l)?\", # if we just see `arm-linux-gnueabihf`, we assume it's `armv7l`\n    \"armv6l\" => \"armv6l\",\n    \"powerpc64le\" => \"p(ower)?pc64le\",\n)\n# Keep this in sync with `CPUID.ISAs_by_family`\n# These are the CPUID side of the microarchitectures targeted by GCC flags in BinaryBuilder.jl\nconst arch_march_isa_mapping = let\n    function get_set(arch, name)\n        all = CPUID.ISAs_by_family[arch]\n        return all[findfirst(x -> x.first == name, all)].second\n    end\n    Dict(\n        \"i686\" => [\n            \"pentium4\" => get_set(\"i686\", \"pentium4\"),\n            \"prescott\" => get_set(\"i686\", \"prescott\"),\n        ],\n        \"x86_64\" => [\n            \"x86_64\" => get_set(\"x86_64\", \"x86_64\"),\n            \"avx\" => get_set(\"x86_64\", \"sandybridge\"),\n            \"avx2\" => get_set(\"x86_64\", \"haswell\"),\n            \"avx512\" => get_set(\"x86_64\", \"skylake_avx512\"),\n        ],\n        \"armv6l\" => [\n            \"arm1176jzfs\" => get_set(\"armv6l\", \"arm1176jzfs\"),\n        ],\n        \"armv7l\" => [\n            \"armv7l\" => get_set(\"armv7l\", \"armv7l\"),\n            \"neonvfpv4\" => get_set(\"armv7l\", \"armv7l+neon+vfpv4\"),\n        ],\n        \"aarch64\" => [\n            \"armv8_0\" => get_set(\"aarch64\", \"armv8.0-a\"),\n            \"armv8_1\" => get_set(\"aarch64\", \"armv8.1-a\"),\n            \"armv8_2_crypto\" => get_set(\"aarch64\", \"armv8.2-a+crypto\"),\n            \"armv8_4_crypto_sve\" => get_set(\"aarch64\", \"armv8.4-a+crypto+sve\"),\n        ],\n        \"powerpc64le\" => [\n            \"power8\" => get_set(\"powerpc64le\", \"power8\"),\n        ]\n    )\nend\nconst os_mapping = Dict(\n    \"macos\" => \"-apple-darwin[\\\\d\\\\.]*\",\n    \"freebsd\" => \"-(.*-)?freebsd[\\\\d\\\\.]*\",\n    \"windows\" => \"-w64-mingw32\",\n    \"linux\" => \"-(.*-)?linux\",\n)\nconst libc_mapping = Dict(\n    \"libc_nothing\" => \"\",\n    \"glibc\" => \"-gnu\",\n    \"musl\" => \"-musl\",\n)\nconst call_abi_mapping = Dict(\n    \"call_abi_nothing\" => \"\",\n    \"eabihf\" => \"eabihf\",\n    \"eabi\" => \"eabi\",\n)\nconst libgfortran_version_mapping = Dict(\n    \"libgfortran_nothing\" => \"\",\n    \"libgfortran3\" => \"(-libgfortran3)|(-gcc4)\", # support old-style `gccX` versioning\n    \"libgfortran4\" => \"(-libgfortran4)|(-gcc7)\",\n    \"libgfortran5\" => \"(-libgfortran5)|(-gcc8)\",\n)\nconst cxxstring_abi_mapping = Dict(\n    \"cxxstring_nothing\" => \"\",\n    \"cxx03\" => \"-cxx03\",\n    \"cxx11\" => \"-cxx11\",\n)\nconst libstdcxx_version_mapping = Dict{String,String}(\n    \"libstdcxx_nothing\" => \"\",\n    \"libstdcxx\" => \"-libstdcxx\\\\d+\",\n)\n\n\"\"\"\n    parse(::Type{Platform}, triplet::AbstractString)\n\nParses a string platform triplet back into a `Platform` object.\n\"\"\"\nfunction Base.parse(::Type{Platform}, triplet::AbstractString; validate_strict::Bool = false)\n    # Helper function to collapse dictionary of mappings down into a regex of\n    # named capture groups joined by \"|\" operators\n    c(mapping) = string(\"(\",join([\"(?<$k>$v)\" for (k, v) in mapping], \"|\"), \")\")\n\n    # We're going to build a mondo regex here to parse everything:\n    triplet_regex = Regex(string(\n        \"^\",\n        # First, the core triplet; arch/os/libc/call_abi\n        c(arch_mapping),\n        c(os_mapping),\n        c(libc_mapping),\n        c(call_abi_mapping),\n        # Next, optional things, like libgfortran/libstdcxx/cxxstring abi\n        c(libgfortran_version_mapping),\n        c(cxxstring_abi_mapping),\n        c(libstdcxx_version_mapping),\n        # Finally, the catch-all for extended tags\n        \"(?<tags>(?:-[^-]+\\\\+[^-]+)*)?\",\n        \"\\$\",\n    ))\n\n    m = match(triplet_regex, triplet)\n    if m !== nothing\n        # Helper function to find the single named field within the giant regex\n        # that is not `nothing` for each mapping we give it.\n        get_field(m, mapping) = begin\n            for k in keys(mapping)\n                if m[k] !== nothing\n                    # Convert our sentinel `nothing` values to actual `nothing`\n                    if endswith(k, \"_nothing\")\n                        return nothing\n                    end\n                    # Convert libgfortran/libstdcxx version numbers\n                    if startswith(k, \"libgfortran\")\n                        return VersionNumber(parse(Int,k[12:end]))\n                    elseif startswith(k, \"libstdcxx\")\n                        return VersionNumber(3, 4, parse(Int,m[k][11:end]))\n                    else\n                        return k\n                    end\n                end\n            end\n        end\n\n        # Extract the information we're interested in:\n        arch = get_field(m, arch_mapping)\n        os = get_field(m, os_mapping)\n        libc = get_field(m, libc_mapping)\n        call_abi = get_field(m, call_abi_mapping)\n        libgfortran_version = get_field(m, libgfortran_version_mapping)\n        libstdcxx_version = get_field(m, libstdcxx_version_mapping)\n        cxxstring_abi = get_field(m, cxxstring_abi_mapping)\n        function split_tags(tagstr)\n            tag_fields = filter(!isempty, split(tagstr, \"-\"))\n            if isempty(tag_fields)\n                return Pair{String,String}[]\n            end\n            return map(v -> Symbol(v[1]) => v[2], split.(tag_fields, \"+\"))\n        end\n        tags = split_tags(m[\"tags\"])\n\n        # Special parsing of os version number, if any exists\n        function extract_os_version(os_name, pattern)\n            m_osvn = match(pattern, m[os_name])\n            if m_osvn !== nothing\n                return VersionNumber(m_osvn.captures[1])\n            end\n            return nothing\n        end\n        os_version = nothing\n        if os == \"macos\"\n            os_version = extract_os_version(\"macos\", r\".*darwin([\\d\\.]+)\")\n        end\n        if os == \"freebsd\"\n            os_version = extract_os_version(\"freebsd\", r\".*freebsd([\\d.]+)\")\n        end\n\n        return Platform(\n            arch, os;\n            validate_strict,\n            libc,\n            call_abi,\n            libgfortran_version,\n            cxxstring_abi,\n            libstdcxx_version,\n            os_version,\n            tags...,\n        )\n    end\n    throw(ArgumentError(\"Platform `$(triplet)` is not an officially supported platform\"))\nend\n\nfunction Base.tryparse(::Type{Platform}, triplet::AbstractString)\n    try\n        parse(Platform, triplet)\n    catch e\n        if isa(e, InterruptException)\n            rethrow(e)\n        end\n        return nothing\n    end\nend\n\n\"\"\"\n    platform_dlext(p::AbstractPlatform = HostPlatform())\n\nReturn the dynamic library extension for the given platform, defaulting to the\ncurrently running platform.  E.g. returns \"so\" for a Linux-based platform,\n\"dll\" for a Windows-based platform, etc...\n\"\"\"\nfunction platform_dlext(p::AbstractPlatform = HostPlatform())\n    if os(p) == \"windows\"\n        return \"dll\"\n    elseif os(p) == \"macos\"\n        return \"dylib\"\n    else\n        return \"so\"\n    end\nend\n\n\"\"\"\n    parse_dl_name_version(path::String, platform::AbstractPlatform)\n\nGiven a path to a dynamic library, parse out what information we can\nfrom the filename.  E.g. given something like \"lib/libfoo.so.3.2\",\nthis function returns `\"libfoo\", v\"3.2\"`.  If the path name is not a\nvalid dynamic library, this method throws an error.  If no soversion\ncan be extracted from the filename, as in \"libbar.so\" this method\nreturns `\"libbar\", nothing`.\n\"\"\"\nfunction parse_dl_name_version(path::String, os::String)\n    # Use an extraction regex that matches the given OS\n    local dlregex\n    if os == \"windows\"\n        # On Windows, libraries look like `libnettle-6.dll`\n        dlregex = r\"^(.*?)(?:-((?:[\\.\\d]+)*))?\\.dll$\"\n    elseif os == \"macos\"\n        # On OSX, libraries look like `libnettle.6.3.dylib`\n        dlregex = r\"^(.*?)((?:\\.[\\d]+)*)\\.dylib$\"\n    else\n        # On Linux and FreeBSD, libraries look like `libnettle.so.6.3.0`\n        dlregex = r\"^(.*?)\\.so((?:\\.[\\d]+)*)$\"\n    end\n\n    m = match(dlregex, basename(path))\n    if m === nothing\n        throw(ArgumentError(\"Invalid dynamic library path '$path'\"))\n    end\n\n    # Extract name and version\n    name = m.captures[1]\n    version = m.captures[2]\n    if version === nothing || isempty(version)\n        version = nothing\n    else\n        version = VersionNumber(strip(version, '.'))\n    end\n    return name, version\nend\n\n# Adapter for `AbstractString`\nfunction parse_dl_name_version(path::AbstractString, os::AbstractString)\n    return parse_dl_name_version(string(path)::String, string(os)::String)\nend\n\n\"\"\"\n    detect_libgfortran_version()\n\nInspects the current Julia process to determine the libgfortran version this Julia is\nlinked against (if any).\n\"\"\"\nfunction detect_libgfortran_version()\n    libgfortran_paths = filter(x -> occursin(\"libgfortran\", x), Libdl.dllist())\n    if isempty(libgfortran_paths)\n        # One day, I hope to not be linking against libgfortran in base Julia\n        return nothing\n    end\n    libgfortran_path = first(libgfortran_paths)\n\n    name, version = parse_dl_name_version(libgfortran_path, os())\n    if version === nothing\n        # Even though we complain about this, we allow it to continue in the hopes that\n        # we shall march on to a BRIGHTER TOMORROW.  One in which we are not shackled\n        # by the constraints of libgfortran compiler ABIs upon our precious programming\n        # languages; one where the mistakes of yesterday are mere memories and not\n        # continual maintenance burdens upon the children of the dawn; one where numeric\n        # code may be cleanly implemented in a modern language and not bestowed onto the\n        # next generation by grizzled ancients, documented only with a faded yellow\n        # sticky note that bears a hastily-scribbled \"good luck\".\n        @warn(\"Unable to determine libgfortran version from '$(libgfortran_path)'\")\n    end\n    return version\nend\n\n\"\"\"\n    detect_libstdcxx_version(max_minor_version::Int=30)\n\nInspects the currently running Julia process to find out what version of libstdc++\nit is linked against (if any).  `max_minor_version` is the latest version in the\n3.4 series of GLIBCXX where the search is performed.\n\"\"\"\nfunction detect_libstdcxx_version(max_minor_version::Int=30)\n    libstdcxx_paths = filter(x -> occursin(\"libstdc++\", x), Libdl.dllist())\n    if isempty(libstdcxx_paths)\n        # This can happen if we were built by clang, so we don't link against\n        # libstdc++ at all.\n        return nothing\n    end\n\n    # Brute-force our way through GLIBCXX_* symbols to discover which version we're linked against\n    hdl = Libdl.dlopen(first(libstdcxx_paths))\n    # Try all GLIBCXX versions down to GCC v4.8:\n    # https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html\n    for minor_version in max_minor_version:-1:18\n        if Libdl.dlsym(hdl, \"GLIBCXX_3.4.$(minor_version)\"; throw_error=false) !== nothing\n            Libdl.dlclose(hdl)\n            return VersionNumber(\"3.4.$(minor_version)\")\n        end\n    end\n    Libdl.dlclose(hdl)\n    return nothing\nend\n\n\"\"\"\n    detect_cxxstring_abi()\n\nInspects the currently running Julia process to see what version of the C++11 string ABI\nit was compiled with (this is only relevant if compiled with `g++`; `clang` has no\nincompatibilities yet, bless its heart).  In reality, this actually checks for symbols\nwithin LLVM, but that is close enough for our purposes, as you can't mix configurations\nbetween Julia and LLVM; they must match.\n\"\"\"\nfunction detect_cxxstring_abi()\n    # First, if we're not linked against libstdc++, then early-exit because this doesn't matter.\n    libstdcxx_paths = filter(x -> occursin(\"libstdc++\", x), Libdl.dllist())\n    if isempty(libstdcxx_paths)\n        # We were probably built by `clang`; we don't link against `libstdc++`` at all.\n        return nothing\n    end\n\n    function open_libllvm(f::Function)\n        for lib_name in (\"libLLVM\", \"LLVM\", \"libLLVMSupport\")\n            hdl = Libdl.dlopen_e(lib_name)\n            if hdl != C_NULL\n                try\n                    return f(hdl)\n                finally\n                    Libdl.dlclose(hdl)\n                end\n            end\n        end\n        error(\"Unable to open libLLVM!\")\n    end\n\n    return open_libllvm() do hdl\n        # Check for llvm::sys::getProcessTriple(), first without cxx11 tag:\n        if Libdl.dlsym_e(hdl, \"_ZN4llvm3sys16getProcessTripleEv\") != C_NULL\n            return \"cxx03\"\n        elseif Libdl.dlsym_e(hdl, \"_ZN4llvm3sys16getProcessTripleB5cxx11Ev\") != C_NULL\n            return \"cxx11\"\n        else\n            @warn(\"Unable to find llvm::sys::getProcessTriple() in libLLVM!\")\n            return nothing\n        end\n    end\nend\n\n\"\"\"\n    host_triplet()\n\nBuild host triplet out of `Sys.MACHINE` and various introspective utilities that\ndetect compiler ABI values such as `libgfortran_version`, `libstdcxx_version` and\n`cxxstring_abi`.  We do this without using any `Platform` tech as it must run before\nwe have much of that built.\n\"\"\"\nfunction host_triplet()\n    str = Base.BUILD_TRIPLET\n\n    if !occursin(\"-libgfortran\", str)\n        libgfortran_version = detect_libgfortran_version()\n        if libgfortran_version !== nothing\n            str = string(str, \"-libgfortran\", libgfortran_version.major)\n        end\n    end\n\n    if !occursin(\"-cxx\", str)\n        cxxstring_abi = detect_cxxstring_abi()\n        if cxxstring_abi !== nothing\n            str = string(str, \"-\", cxxstring_abi)\n        end\n    end\n\n    if !occursin(\"-libstdcxx\", str)\n        libstdcxx_version = detect_libstdcxx_version()\n        if libstdcxx_version !== nothing\n            str = string(str, \"-libstdcxx\", libstdcxx_version.patch)\n        end\n    end\n\n    # Add on julia_version extended tag\n    if !occursin(\"-julia_version+\", str)\n        str = string(str, \"-julia_version+\", VersionNumber(VERSION.major, VERSION.minor, VERSION.patch))\n    end\n    return str\nend\n\n\"\"\"\n    HostPlatform()\n\nReturn the `Platform` object that corresponds to the current host system, with all\nrelevant comparison strategies set to host platform mode.  This is equivalent to:\n\n    HostPlatform(parse(Platform, Base.BinaryPlatforms.host_triplet()))\n\"\"\"\nfunction HostPlatform()\n    return HostPlatform(parse(Platform, host_triplet()))::Platform\nend\n\n\"\"\"\n    platforms_match(a::AbstractPlatform, b::AbstractPlatform)\n\nReturn `true` if `a` and `b` are matching platforms, where matching is determined by\ncomparing all keys contained within the platform objects, and if both objects contain\nentries for that key, they must match.  Comparison, by default, is performed using\nthe `==` operator, however this can be overridden on a key-by-key basis by adding\n\"comparison strategies\" through `set_compare_strategy!(platform, key, func)`.\n\nNote that as the comparison strategy is set on the `Platform` object, and not globally,\na custom comparison strategy is first looked for within the `a` object, then if none\nis found, it is looked for in the `b` object.  Finally, if none is found in either, the\ndefault of `==(ak, bk)` is used.  We throw an error if custom comparison strategies are\nused on both `a` and `b` and they are not the same custom comparison.\n\nThe reserved tags `os_version` and `libstdcxx_version` use this mechanism to provide\nbounded version constraints, where an artifact can specify that it was built using APIs\nonly available in macOS `v\"10.11\"` and later, or an artifact can state that it requires\na libstdc++ that is at least `v\"3.4.22\"`, etc...\n\"\"\"\nfunction platforms_match(a::AbstractPlatform, b::AbstractPlatform)\n    for k in union(keys(tags(a)::Dict{String,String}), keys(tags(b)::Dict{String,String}))\n        ak = get(tags(a), k, nothing)\n        bk = get(tags(b), k, nothing)\n\n        # Only continue if both `ak` and `bk` are not `nothing`\n        if ak === nothing || bk === nothing\n            continue\n        end\n\n        a_comp = get_compare_strategy(a, k)\n        b_comp = get_compare_strategy(b, k)\n\n        # Throw an error if `a` and `b` have both set non-default comparison strategies for `k`\n        # and they're not the same strategy.\n        if a_comp != compare_default && b_comp != compare_default && a_comp != b_comp\n            throw(ArgumentError(\"Cannot compare Platform objects with two different non-default comparison strategies for the same key \\\"$(k)\\\"\"))\n        end\n\n        # Select the custom comparator, if we have one.\n        comparator = a_comp\n        if b_comp != compare_default\n            comparator = b_comp\n        end\n\n        # Call the comparator, passing in which objects requested this comparison (one, the other, or both)\n        # For some comparators this doesn't matter, but for non-symmetrical comparisons, it does.\n        if !comparator(ak, bk, a_comp == comparator, b_comp == comparator)\n            return false\n        end\n    end\n    return true\nend\n\nfunction platforms_match(a::String, b::AbstractPlatform)\n    return platforms_match(parse(Platform, a), b)\nend\nfunction platforms_match(a::AbstractPlatform, b::String)\n    return platforms_match(a, parse(Platform, b))\nend\nplatforms_match(a::String, b::String) = platforms_match(parse(Platform, a), parse(Platform, b))\n\n# Adapters for AbstractString backedge avoidance\nplatforms_match(a::AbstractString, b::AbstractPlatform) = platforms_match(string(a)::String, b)\nplatforms_match(a::AbstractPlatform, b::AbstractString) = platforms_match(a, string(b)::String)\nplatforms_match(a::AbstractString, b::AbstractString) = platforms_match(string(a)::String, string(b)::String)\n\n\n\"\"\"\n    select_platform(download_info::Dict, platform::AbstractPlatform = HostPlatform())\n\nGiven a `download_info` dictionary mapping platforms to some value, choose\nthe value whose key best matches `platform`, returning `nothing` if no matches\ncan be found.\n\nPlatform attributes such as architecture, libc, calling ABI, etc... must all\nmatch exactly, however attributes such as compiler ABI can have wildcards\nwithin them such as `nothing` which matches any version of GCC.\n\"\"\"\nfunction select_platform(download_info::Dict, platform::AbstractPlatform = HostPlatform())\n    ps = collect(filter(p -> platforms_match(p, platform), keys(download_info)))\n\n    if isempty(ps)\n        return nothing\n    end\n\n    # At this point, we may have multiple possibilities.  E.g. if, in the future,\n    # Julia can be built without a direct dependency on libgfortran, we may match\n    # multiple tarballs that vary only within their libgfortran ABI.  To narrow it\n    # down, we just sort by triplet, then pick the last one.  This has the effect\n    # of generally choosing the latest release (e.g. a `libgfortran5` tarball\n    # rather than a `libgfortran3` tarball)\n    p = last(sort(ps, by = p -> triplet(p)))\n    return download_info[p]\nend\n\nend # module\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/OpenBLAS_jll/src/OpenBLAS_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/OpenBLAS_jll.jl\nbaremodule OpenBLAS_jll\nusing Base, Libdl, CompilerSupportLibraries_jll, Base.BinaryPlatforms\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libopenblas\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibopenblas_handle = C_NULL\nlibopenblas_path = \"\"\n\nif arch(HostPlatform()) in (\"x86_64\", \"powerpc64le\")\n    const libsuffix = \"64_\"\nelse\n    const libsuffix = \"\"\nend\n\nif Sys.iswindows()\n    const libopenblas = \"libopenblas$(libsuffix).dll\"\nelseif Sys.isapple()\n    const libopenblas = \"@rpath/libopenblas$(libsuffix).dylib\"\nelse\n    const libopenblas = \"libopenblas$(libsuffix).so\"\nend\n\nfunction __init__()\n    global libopenblas_handle = dlopen(libopenblas)\n    global libopenblas_path = dlpath(libopenblas_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libopenblas_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libopenblas_path() = libopenblas_path\n\nend  # module OpenBLAS_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LinearAlgebra/src/blas.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n\"\"\"\nInterface to BLAS subroutines.\n\"\"\"\nmodule BLAS\n\nimport ..axpy!, ..axpby!\nimport Base: copyto!\nusing Base: require_one_based_indexing\n\nexport\n# Level 1\n    asum,\n    axpy!,\n    axpby!,\n    blascopy!,\n    dotc,\n    dotu,\n    rot!,\n    scal!,\n    scal,\n    nrm2,\n    iamax,\n# Level 2\n    gbmv!,\n    gbmv,\n    gemv!,\n    gemv,\n    hemv!,\n    hemv,\n    hpmv!,\n    sbmv!,\n    sbmv,\n    spmv!,\n    symv!,\n    symv,\n    trsv!,\n    trsv,\n    trmv!,\n    trmv,\n    ger!,\n    syr!,\n    her!,\n# Level 3\n    herk!,\n    herk,\n    her2k!,\n    her2k,\n    gemm!,\n    gemm,\n    symm!,\n    symm,\n    hemm!,\n    hemm,\n    syrk!,\n    syrk,\n    syr2k!,\n    syr2k,\n    trmm!,\n    trmm,\n    trsm!,\n    trsm\n\n\nconst libblas = Base.libblas_name\nconst liblapack = Base.liblapack_name\n\nimport LinearAlgebra\nimport LinearAlgebra: BlasReal, BlasComplex, BlasFloat, BlasInt, DimensionMismatch, checksquare, stride1, chkstride1, axpy!\n\nimport Libdl\n\n# utility routines\nlet lib = C_NULL\nglobal function determine_vendor()\n    if lib == C_NULL\n        lib = something(Libdl.dlopen(libblas; throw_error=false), C_NULL)\n    end\n    vend = :unknown\n    if lib != C_NULL\n        if Libdl.dlsym(lib, :openblas_set_num_threads; throw_error=false) !== nothing\n            vend = :openblas\n        elseif Libdl.dlsym(lib, :openblas_set_num_threads64_; throw_error=false) !== nothing\n            vend = :openblas64\n        elseif Libdl.dlsym(lib, :MKL_Set_Num_Threads; throw_error=false) !== nothing\n            vend = :mkl\n        end\n    end\n    return vend\nend\nend\n\nconst _vendor = determine_vendor()\nvendor() = _vendor\n\nif vendor() === :openblas64\n    macro blasfunc(x)\n        return Expr(:quote, Symbol(x, \"64_\"))\n    end\nelse\n    macro blasfunc(x)\n        return Expr(:quote, x)\n    end\nend\n\nopenblas_get_config() = strip(unsafe_string(ccall((@blasfunc(openblas_get_config), libblas), Ptr{UInt8}, () )))\n\nfunction guess_vendor()\n    # like determine_vendor, but guesses blas in some cases\n    # where determine_vendor returns :unknown\n    ret = vendor()\n    if Sys.isapple() && (ret == :unknown)\n        ret = :osxblas\n    end\n    ret\nend\n\n\n\"\"\"\n    set_num_threads(n::Integer)\n    set_num_threads(::Nothing)\n\nSet the number of threads the BLAS library should use equal to `n::Integer`.\n\nAlso accepts `nothing`, in which case julia tries to guess the default number of threads.\nPassing `nothing` is discouraged and mainly exists for the following reason:\n\nOn exotic variants of BLAS, `nothing` may be returned by `get_num_threads()`.\nThus on exotic variants of BLAS, the following pattern may fail to set the number of threads:\n\n```julia\nold = get_num_threads()\nset_num_threads(1)\n@threads for i in 1:10\n    # single-threaded BLAS calls\nend\nset_num_threads(old)\n```\nBecause `set_num_threads` accepts `nothing`, this code can still run\non exotic variants of BLAS without error. Warnings will be raised instead.\n\n!!! compat \"Julia 1.6\"\n    `set_num_threads(::Nothing)` requires at least Julia 1.6.\n\"\"\"\nset_num_threads(n)::Nothing = _set_num_threads(n)\n\nfunction _set_num_threads(n::Integer; _blas = guess_vendor())\n    if _blas === :openblas || _blas == :openblas64\n        return ccall((@blasfunc(openblas_set_num_threads), libblas), Cvoid, (Cint,), n)\n    elseif _blas === :mkl\n        # MKL may let us set the number of threads in several ways\n        return ccall((:MKL_Set_Num_Threads, libblas), Cvoid, (Cint,), n)\n    elseif _blas === :osxblas\n        # OSX BLAS looks at an environment variable\n        ENV[\"VECLIB_MAXIMUM_THREADS\"] = n\n    else\n        @assert _blas === :unknown\n        @warn \"Failed to set number of BLAS threads.\" maxlog=1\n    end\n    return nothing\nend\n\n_tryparse_env_int(key) = tryparse(Int, get(ENV, key, \"\"))\n\nfunction _set_num_threads(::Nothing; _blas = guess_vendor())\n    n = something(\n        _tryparse_env_int(\"OPENBLAS_NUM_THREADS\"),\n        _tryparse_env_int(\"OMP_NUM_THREADS\"),\n        max(1, Sys.CPU_THREADS \u00f7 2),\n    )\n    _set_num_threads(n; _blas)\nend\n\n\"\"\"\n    get_num_threads()\n\nGet the number of threads the BLAS library is using.\n\nOn exotic variants of `BLAS` this function can fail, which is indicated by returning `nothing`.\n\n!!! compat \"Julia 1.6\"\n    `get_num_threads` requires at least Julia 1.6.\n\"\"\"\nget_num_threads()::Union{Int, Nothing} = _get_num_threads()\n\nfunction _get_num_threads(; _blas = guess_vendor())::Union{Int, Nothing}\n    if _blas === :openblas || _blas === :openblas64\n        return Int(ccall((@blasfunc(openblas_get_num_threads), libblas), Cint, ()))\n    elseif _blas === :mkl\n        return Int(ccall((:mkl_get_max_threads, libblas), Cint, ()))\n    elseif _blas === :osxblas\n        key = \"VECLIB_MAXIMUM_THREADS\"\n        nt = _tryparse_env_int(key)\n        if nt === nothing\n            @warn \"Failed to read environment variable $key\" maxlog=1\n        else\n            return nt\n        end\n    else\n        @assert _blas === :unknown\n    end\n    @warn \"Could not get number of BLAS threads. Returning `nothing` instead.\" maxlog=1\n    return nothing\nend\n\nconst _testmat = [1.0 0.0; 0.0 -1.0]\nfunction check()\n    blas = vendor()\n    if blas === :openblas || blas === :openblas64\n        openblas_config = openblas_get_config()\n        openblas64 = occursin(r\".*USE64BITINT.*\", openblas_config)\n        if Base.USE_BLAS64 != openblas64\n            if !openblas64\n                @error \"\"\"\n                    OpenBLAS was not built with 64bit integer support.\n                    You're seeing this error because Julia was built with USE_BLAS64=1.\n                    Please rebuild Julia with USE_BLAS64=0\"\"\"\n            else\n                @error \"\"\"\n                    Julia was not built with support for OpenBLAS with 64bit integer support.\n                    You're seeing this error because Julia was built with USE_BLAS64=0.\n                    Please rebuild Julia with USE_BLAS64=1\"\"\"\n            end\n            println(\"Quitting.\")\n            exit()\n        end\n    elseif blas === :mkl\n        if Base.USE_BLAS64\n            ENV[\"MKL_INTERFACE_LAYER\"] = \"ILP64\"\n        end\n    end\n\n    #\n    # Check if BlasInt is the expected bitsize, by triggering an error\n    #\n    (_, info) = LinearAlgebra.LAPACK.potrf!('U', _testmat)\n    if info != 2 # mangled info code\n        if info == 2^33\n            error(\"BLAS and LAPACK are compiled with 32-bit integer support, but Julia expects 64-bit integers. Please build Julia with USE_BLAS64=0.\")\n        elseif info == 0\n            error(\"BLAS and LAPACK are compiled with 64-bit integer support but Julia expects 32-bit integers. Please build Julia with USE_BLAS64=1.\")\n        else\n            error(\"The LAPACK library produced an undefined error code. Please verify the installation of BLAS and LAPACK.\")\n        end\n    end\n\nend\n\n\n# Level 1\n## copy\n\n\"\"\"\n    blascopy!(n, X, incx, Y, incy)\n\nCopy `n` elements of array `X` with stride `incx` to array `Y` with stride `incy`. Returns `Y`.\n\"\"\"\nfunction blascopy! end\n\nfor (fname, elty) in ((:dcopy_,:Float64),\n                      (:scopy_,:Float32),\n                      (:zcopy_,:ComplexF64),\n                      (:ccopy_,:ComplexF32))\n    @eval begin\n        # SUBROUTINE DCOPY(N,DX,INCX,DY,INCY)\n        function blascopy!(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, DX, incx, DY, incy)\n            DY\n        end\n    end\nend\n\n\n## rot\n\n\"\"\"\n    rot!(n, X, incx, Y, incy, c, s)\n\nOverwrite `X` with `c*X + s*Y` and `Y` with `-conj(s)*X + c*Y` for the first `n` elements of array `X` with stride `incx` and\nfirst `n` elements of array `Y` with stride `incy`. Returns `X` and `Y`.\n\n!!! compat \"Julia 1.5\"\n    `rot!` requires at least Julia 1.5.\n\"\"\"\nfunction rot! end\n\nfor (fname, elty, cty, sty, lib) in ((:drot_, :Float64, :Float64, :Float64, libblas),\n                                     (:srot_, :Float32, :Float32, :Float32, libblas),\n                                     (:zdrot_, :ComplexF64, :Float64, :Float64, libblas),\n                                     (:csrot_, :ComplexF32, :Float32, :Float32, libblas),\n                                     (:zrot_, :ComplexF64, :Float64, :ComplexF64, liblapack),\n                                     (:crot_, :ComplexF32, :Float32, :ComplexF32, liblapack))\n    @eval begin\n        # SUBROUTINE DROT(N,DX,INCX,DY,INCY,C,S)\n        function rot!(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer, C::$cty, S::$sty)\n            ccall((@blasfunc($fname), $lib), Cvoid,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$cty}, Ref{$sty}),\n                 n, DX, incx, DY, incy, C, S)\n            DX, DY\n        end\n    end\nend\n\n## scal\n\n\"\"\"\n    scal!(n, a, X, incx)\n\nOverwrite `X` with `a*X` for the first `n` elements of array `X` with stride `incx`. Returns `X`.\n\"\"\"\nfunction scal! end\n\n\"\"\"\n    scal(n, a, X, incx)\n\nReturn `X` scaled by `a` for the first `n` elements of array `X` with stride `incx`.\n\"\"\"\nfunction scal end\n\nfor (fname, elty) in ((:dscal_,:Float64),\n                      (:sscal_,:Float32),\n                      (:zscal_,:ComplexF64),\n                      (:cscal_,:ComplexF32))\n    @eval begin\n        # SUBROUTINE DSCAL(N,DA,DX,INCX)\n        function scal!(n::Integer, DA::$elty, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                  (Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                  n, DA, DX, incx)\n            DX\n        end\n    end\nend\nscal(n, DA, DX, incx) = scal!(n, DA, copy(DX), incx)\n\n## dot\n\n\"\"\"\n    dot(n, X, incx, Y, incy)\n\nDot product of two vectors consisting of `n` elements of array `X` with stride `incx` and\n`n` elements of array `Y` with stride `incy`.\n\n# Examples\n```jldoctest\njulia> BLAS.dot(10, fill(1.0, 10), 1, fill(1.0, 20), 2)\n10.0\n```\n\"\"\"\nfunction dot end\n\n\"\"\"\n    dotc(n, X, incx, U, incy)\n\nDot function for two complex vectors, consisting of `n` elements of array `X`\nwith stride `incx` and `n` elements of array `U` with stride `incy`,\nconjugating the first vector.\n\n# Examples\n```jldoctest\njulia> BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n10.0 - 10.0im\n```\n\"\"\"\nfunction dotc end\n\n\"\"\"\n    dotu(n, X, incx, Y, incy)\n\nDot function for two complex vectors consisting of `n` elements of array `X`\nwith stride `incx` and `n` elements of array `Y` with stride `incy`.\n\n# Examples\n```jldoctest\njulia> BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n-10.0 + 10.0im\n```\n\"\"\"\nfunction dotu end\n\nfor (fname, elty) in ((:ddot_,:Float64),\n                      (:sdot_,:Float32))\n    @eval begin\n                #       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,INCY,N\n                # *     ..\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION DX(*),DY(*)\n        function dot(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), $elty,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, DX, incx, DY, incy)\n        end\n    end\nend\nfor (fname, elty) in ((:cblas_zdotc_sub,:ComplexF64),\n                      (:cblas_cdotc_sub,:ComplexF32))\n    @eval begin\n                #       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,INCY,N\n                # *     ..\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION DX(*),DY(*)\n        function dotc(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            result = Ref{$elty}()\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}),\n                 n, DX, incx, DY, incy, result)\n            result[]\n        end\n    end\nend\nfor (fname, elty) in ((:cblas_zdotu_sub,:ComplexF64),\n                      (:cblas_cdotu_sub,:ComplexF32))\n    @eval begin\n                #       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,INCY,N\n                # *     ..\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION DX(*),DY(*)\n        function dotu(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            result = Ref{$elty}()\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}),\n                 n, DX, incx, DY, incy, result)\n            result[]\n        end\n    end\nend\n\nfunction dot(DX::Union{DenseArray{T},AbstractVector{T}}, DY::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasReal\n    require_one_based_indexing(DX, DY)\n    n = length(DX)\n    if n != length(DY)\n        throw(DimensionMismatch(\"dot product arguments have lengths $(length(DX)) and $(length(DY))\"))\n    end\n    return dot(n, DX, stride(DX, 1), DY, stride(DY, 1))\nend\nfunction dotc(DX::Union{DenseArray{T},AbstractVector{T}}, DY::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasComplex\n    require_one_based_indexing(DX, DY)\n    n = length(DX)\n    if n != length(DY)\n        throw(DimensionMismatch(\"dot product arguments have lengths $(length(DX)) and $(length(DY))\"))\n    end\n    return dotc(n, DX, stride(DX, 1), DY, stride(DY, 1))\nend\nfunction dotu(DX::Union{DenseArray{T},AbstractVector{T}}, DY::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasComplex\n    require_one_based_indexing(DX, DY)\n    n = length(DX)\n    if n != length(DY)\n        throw(DimensionMismatch(\"dot product arguments have lengths $(length(DX)) and $(length(DY))\"))\n    end\n    return dotu(n, DX, stride(DX, 1), DY, stride(DY, 1))\nend\n\n## nrm2\n\n\"\"\"\n    nrm2(n, X, incx)\n\n2-norm of a vector consisting of `n` elements of array `X` with stride `incx`.\n\n# Examples\n```jldoctest\njulia> BLAS.nrm2(4, fill(1.0, 8), 2)\n2.0\n\njulia> BLAS.nrm2(1, fill(1.0, 8), 2)\n1.0\n```\n\"\"\"\nfunction nrm2 end\n\nfor (fname, elty, ret_type) in ((:dnrm2_,:Float64,:Float64),\n                                (:snrm2_,:Float32,:Float32),\n                                (:dznrm2_,:ComplexF64,:Float64),\n                                (:scnrm2_,:ComplexF32,:Float32))\n    @eval begin\n        # SUBROUTINE DNRM2(N,X,INCX)\n        function nrm2(n::Integer, X::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas), $ret_type,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, X, incx)\n        end\n    end\nend\nnrm2(x::Union{AbstractVector,DenseArray}) = nrm2(length(x), x, stride1(x))\n\n## asum\n\n\"\"\"\n    asum(n, X, incx)\n\nSum of the magnitudes of the first `n` elements of array `X` with stride `incx`.\n\nFor a real array, the magnitude is the absolute value. For a complex array, the\nmagnitude is the sum of the absolute value of the real part and the absolute value\nof the imaginary part.\n\n# Examples\n```jldoctest\njulia> BLAS.asum(5, fill(1.0im, 10), 2)\n5.0\n\njulia> BLAS.asum(2, fill(1.0im, 10), 5)\n2.0\n```\n\"\"\"\nfunction asum end\n\nfor (fname, elty, ret_type) in ((:dasum_,:Float64,:Float64),\n                                (:sasum_,:Float32,:Float32),\n                                (:dzasum_,:ComplexF64,:Float64),\n                                (:scasum_,:ComplexF32,:Float32))\n    @eval begin\n        # SUBROUTINE ASUM(N, X, INCX)\n        function asum(n::Integer, X::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas), $ret_type,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, X, incx)\n        end\n    end\nend\nasum(x::Union{AbstractVector,DenseArray}) = asum(length(x), x, stride1(x))\n\n## axpy\n\n\"\"\"\n    axpy!(a, X, Y)\n\nOverwrite `Y` with `X*a + Y`, where `a` is a scalar. Return `Y`.\n\n# Examples\n```jldoctest\njulia> x = [1; 2; 3];\n\njulia> y = [4; 5; 6];\n\njulia> BLAS.axpy!(2, x, y)\n3-element Vector{Int64}:\n  6\n  9\n 12\n```\n\"\"\"\nfunction axpy! end\n\nfor (fname, elty) in ((:daxpy_,:Float64),\n                      (:saxpy_,:Float32),\n                      (:zaxpy_,:ComplexF64),\n                      (:caxpy_,:ComplexF32))\n    @eval begin\n                # SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)\n                # DY <- DA*DX + DY\n                #*     .. Scalar Arguments ..\n                #      DOUBLE PRECISION DA\n                #      INTEGER INCX,INCY,N\n                #*     .. Array Arguments ..\n                #      DOUBLE PRECISION DX(*),DY(*)\n        function axpy!(n::Integer, alpha::($elty), dx::Union{Ptr{$elty}, AbstractArray{$elty}}, incx::Integer, dy::Union{Ptr{$elty}, AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, alpha, dx, incx, dy, incy)\n            dy\n        end\n    end\nend\nfunction axpy!(alpha::Number, x::Union{DenseArray{T},StridedVector{T}}, y::Union{DenseArray{T},StridedVector{T}}) where T<:BlasFloat\n    if length(x) != length(y)\n        throw(DimensionMismatch(\"x has length $(length(x)), but y has length $(length(y))\"))\n    end\n    return axpy!(length(x), convert(T,alpha), x, stride(x, 1), y, stride(y, 1))\nend\n\nfunction axpy!(alpha::Number, x::Array{T}, rx::Union{UnitRange{Ti},AbstractRange{Ti}},\n               y::Array{T}, ry::Union{UnitRange{Ti},AbstractRange{Ti}}) where {T<:BlasFloat,Ti<:Integer}\n    if length(rx) != length(ry)\n        throw(DimensionMismatch(\"ranges of differing lengths\"))\n    end\n    if minimum(rx) < 1 || maximum(rx) > length(x)\n        throw(ArgumentError(\"range out of bounds for x, of length $(length(x))\"))\n    end\n    if minimum(ry) < 1 || maximum(ry) > length(y)\n        throw(ArgumentError(\"range out of bounds for y, of length $(length(y))\"))\n    end\n    GC.@preserve x y axpy!(\n        length(rx),\n        convert(T, alpha),\n        pointer(x) + (first(rx) - 1)*sizeof(T),\n        step(rx),\n        pointer(y) + (first(ry) - 1)*sizeof(T),\n        step(ry))\n\n    return y\nend\n\n\"\"\"\n    axpby!(a, X, b, Y)\n\nOverwrite `Y` with `X*a + Y*b`, where `a` and `b` are scalars. Return `Y`.\n\n# Examples\n```jldoctest\njulia> x = [1., 2, 3];\n\njulia> y = [4., 5, 6];\n\njulia> BLAS.axpby!(2., x, 3., y)\n3-element Vector{Float64}:\n 14.0\n 19.0\n 24.0\n```\n\"\"\"\nfunction axpby! end\n\nfor (fname, elty) in ((:daxpby_,:Float64), (:saxpby_,:Float32),\n                      (:zaxpby_,:ComplexF64), (:caxpby_,:ComplexF32))\n    @eval begin\n        # SUBROUTINE DAXPBY(N,DA,DX,INCX,DB,DY,INCY)\n        # DY <- DA*DX + DB*DY\n        #*     .. Scalar Arguments ..\n        #      DOUBLE PRECISION DA,DB\n        #      INTEGER INCX,INCY,N\n        #*     .. Array Arguments ..\n        #      DOUBLE PRECISION DX(*),DY(*)\n        function axpby!(n::Integer, alpha::($elty), dx::Union{Ptr{$elty},\n                        AbstractArray{$elty}}, incx::Integer, beta::($elty),\n                        dy::Union{Ptr{$elty}, AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid, (Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                n, alpha, dx, incx, beta, dy, incy)\n            dy\n        end\n    end\nend\n\nfunction axpby!(alpha::Number, x::Union{DenseArray{T},AbstractVector{T}}, beta::Number, y::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasFloat\n    require_one_based_indexing(x, y)\n    if length(x) != length(y)\n        throw(DimensionMismatch(\"x has length $(length(x)), but y has length $(length(y))\"))\n    end\n    return axpby!(length(x), convert(T, alpha), x, stride(x, 1), convert(T, beta), y, stride(y, 1))\nend\n\n## iamax\nfor (fname, elty) in ((:idamax_,:Float64),\n                      (:isamax_,:Float32),\n                      (:izamax_,:ComplexF64),\n                      (:icamax_,:ComplexF32))\n    @eval begin\n        function iamax(n::Integer, dx::Union{Ptr{$elty}, AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas),BlasInt,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                n, dx, incx)\n        end\n    end\nend\niamax(dx::Union{AbstractVector,DenseArray}) = iamax(length(dx), dx, stride1(dx))\n\n\"\"\"\n    iamax(n, dx, incx)\n    iamax(dx)\n\nFind the index of the element of `dx` with the maximum absolute value. `n` is the length of `dx`, and `incx` is the\nstride. If `n` and `incx` are not provided, they assume default values of `n=length(dx)` and `incx=stride1(dx)`.\n\"\"\"\niamax\n\n# Level 2\n## mv\n### gemv\nfor (fname, elty) in ((:dgemv_,:Float64),\n                      (:sgemv_,:Float32),\n                      (:zgemv_,:ComplexF64),\n                      (:cgemv_,:ComplexF32))\n    @eval begin\n             #SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             #*     .. Scalar Arguments ..\n             #      DOUBLE PRECISION ALPHA,BETA\n             #      INTEGER INCX,INCY,LDA,M,N\n             #      CHARACTER TRANS\n             #*     .. Array Arguments ..\n             #      DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function gemv!(trans::AbstractChar, alpha::Union{($elty), Bool},\n                       A::AbstractVecOrMat{$elty}, X::AbstractVector{$elty},\n                       beta::Union{($elty), Bool}, Y::AbstractVector{$elty})\n            require_one_based_indexing(A, X, Y)\n            m,n = size(A,1),size(A,2)\n            if trans == 'N' && (length(X) != n || length(Y) != m)\n                throw(DimensionMismatch(\"A has dimensions $(size(A)), X has length $(length(X)) and Y has length $(length(Y))\"))\n            elseif trans == 'C' && (length(X) != m || length(Y) != n)\n                throw(DimensionMismatch(\"the adjoint of A has dimensions $n, $m, X has length $(length(X)) and Y has length $(length(Y))\"))\n            elseif trans == 'T' && (length(X) != m || length(Y) != n)\n                throw(DimensionMismatch(\"the transpose of A has dimensions $n, $m, X has length $(length(X)) and Y has length $(length(Y))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Clong),\n                 trans, size(A,1), size(A,2), alpha,\n                 A, max(1,stride(A,2)), X, stride(X,1),\n                 beta, Y, stride(Y,1), 1)\n            Y\n        end\n        function gemv(trans::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, X::AbstractVector{$elty})\n            gemv!(trans, alpha, A, X, zero($elty), similar(X, $elty, size(A, (trans == 'N' ? 1 : 2))))\n        end\n        function gemv(trans::AbstractChar, A::AbstractMatrix{$elty}, X::AbstractVector{$elty})\n            gemv!(trans, one($elty), A, X, zero($elty), similar(X, $elty, size(A, (trans == 'N' ? 1 : 2))))\n        end\n    end\nend\n\n\"\"\"\n    gemv!(tA, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y` or `alpha*A'x + beta*y`\naccording to [`tA`](@ref stdlib-blas-trans).\n`alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\ngemv!\n\n\"\"\"\n    gemv(tA, alpha, A, x)\n\nReturn `alpha*A*x` or `alpha*A'x` according to [`tA`](@ref stdlib-blas-trans).\n`alpha` is a scalar.\n\"\"\"\ngemv(tA, alpha, A, x)\n\n\"\"\"\n    gemv(tA, A, x)\n\nReturn `A*x` or `A'x` according to [`tA`](@ref stdlib-blas-trans).\n\"\"\"\ngemv(tA, A, x)\n\n### (GB) general banded matrix-vector multiplication\n\n\"\"\"\n    gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)\n\nUpdate vector `y` as `alpha*A*x + beta*y` or `alpha*A'*x + beta*y` according to [`trans`](@ref stdlib-blas-trans).\nThe matrix `A` is a general band matrix of dimension `m` by `size(A,2)` with `kl`\nsub-diagonals and `ku` super-diagonals. `alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\nfunction gbmv! end\n\n\"\"\"\n    gbmv(trans, m, kl, ku, alpha, A, x)\n\nReturn `alpha*A*x` or `alpha*A'*x` according to [`trans`](@ref stdlib-blas-trans).\nThe matrix `A` is a general band matrix of dimension `m` by `size(A,2)` with `kl` sub-diagonals and `ku`\nsuper-diagonals, and `alpha` is a scalar.\n\"\"\"\nfunction gbmv end\n\nfor (fname, elty) in ((:dgbmv_,:Float64),\n                      (:sgbmv_,:Float32),\n                      (:zgbmv_,:ComplexF64),\n                      (:cgbmv_,:ComplexF32))\n    @eval begin\n             # SUBROUTINE DGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER INCX,INCY,KL,KU,LDA,M,N\n             #       CHARACTER TRANS\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function gbmv!(trans::AbstractChar, m::Integer, kl::Integer, ku::Integer,\n                       alpha::Union{($elty), Bool}, A::AbstractMatrix{$elty},\n                       x::AbstractVector{$elty}, beta::Union{($elty), Bool},\n                       y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Clong),\n                 trans, m, size(A,2), kl,\n                 ku, alpha, A, max(1,stride(A,2)),\n                 x, stride(x,1), beta, y, stride(y,1), 1)\n            y\n        end\n        function gbmv(trans::AbstractChar, m::Integer, kl::Integer, ku::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            n = size(A,2)\n            leny = trans == 'N' ? m : n\n            gbmv!(trans, m, kl, ku, alpha, A, x, zero($elty), similar(x, $elty, leny))\n        end\n        function gbmv(trans::AbstractChar, m::Integer, kl::Integer, ku::Integer, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            gbmv(trans, m, kl, ku, one($elty), A, x)\n        end\n    end\nend\n\n### symv\n\n\"\"\"\n    symv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y`. `A` is assumed to be symmetric.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\nfunction symv! end\n\nfor (fname, elty, lib) in ((:dsymv_,:Float64,libblas),\n                           (:ssymv_,:Float32,libblas),\n                           (:zsymv_,:ComplexF64,liblapack),\n                           (:csymv_,:ComplexF32,liblapack))\n    # Note that the complex symv are not BLAS but auiliary functions in LAPACK\n    @eval begin\n             #      SUBROUTINE DSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             #     .. Scalar Arguments ..\n             #      DOUBLE PRECISION ALPHA,BETA\n             #      INTEGER INCX,INCY,LDA,N\n             #      CHARACTER UPLO\n             #     .. Array Arguments ..\n             #      DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function symv!(uplo::AbstractChar, alpha::Union{($elty), Bool},\n                       A::AbstractMatrix{$elty}, x::AbstractVector{$elty},\n                       beta::Union{($elty), Bool}, y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            m, n = size(A)\n            if m != n\n                throw(DimensionMismatch(\"matrix A is $m by $n but must be square\"))\n            end\n            if n != length(x)\n                throw(DimensionMismatch(\"A has size $(size(A)), and x has length $(length(x))\"))\n            end\n            if m != length(y)\n                throw(DimensionMismatch(\"A has size $(size(A)), and y has length $(length(y))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), $lib), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Clong),\n                 uplo, n, alpha, A,\n                 max(1,stride(A,2)), x, stride(x,1), beta,\n                 y, stride(y,1), 1)\n            y\n        end\n        function symv(uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n                symv!(uplo, alpha, A, x, zero($elty), similar(x))\n        end\n        function symv(uplo::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            symv(uplo, one($elty), A, x)\n        end\n    end\nend\n\n\"\"\"\n    symv(ul, alpha, A, x)\n\nReturn `alpha*A*x`. `A` is assumed to be symmetric.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` is a scalar.\n\"\"\"\nsymv(ul, alpha, A, x)\n\n\"\"\"\n    symv(ul, A, x)\n\nReturn `A*x`. `A` is assumed to be symmetric.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsymv(ul, A, x)\n\n### hemv\n\"\"\"\n    hemv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y`. `A` is assumed to be Hermitian.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\nfunction hemv! end\n\nfor (fname, elty) in ((:zhemv_,:ComplexF64),\n                      (:chemv_,:ComplexF32))\n    @eval begin\n        function hemv!(uplo::AbstractChar, \u03b1::Union{$elty, Bool}, A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, \u03b2::Union{$elty, Bool}, y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            m, n = size(A)\n            if m != n\n                throw(DimensionMismatch(\"matrix A is $m by $n but must be square\"))\n            end\n            if n != length(x)\n                throw(DimensionMismatch(\"A has size $(size(A)), and x has length $(length(x))\"))\n            end\n            if m != length(y)\n                throw(DimensionMismatch(\"A has size $(size(A)), and y has length $(length(y))\"))\n            end\n            chkstride1(A)\n            lda = max(1, stride(A, 2))\n            incx = stride(x, 1)\n            incy = stride(y, 1)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Clong),\n                uplo, n, \u03b1, A,\n                lda, x, incx, \u03b2,\n                y, incy, 1)\n            y\n        end\n        function hemv(uplo::AbstractChar, \u03b1::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            hemv!(uplo, \u03b1, A, x, zero($elty), similar(x))\n        end\n        function hemv(uplo::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            hemv(uplo, one($elty), A, x)\n        end\n    end\nend\n\n\"\"\"\n    hemv(ul, alpha, A, x)\n\nReturn `alpha*A*x`. `A` is assumed to be Hermitian.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` is a scalar.\n\"\"\"\nhemv(ul, alpha, A, x)\n\n\"\"\"\n    hemv(ul, A, x)\n\nReturn `A*x`. `A` is assumed to be Hermitian.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nhemv(ul, A, x)\n\n### hpmv!, (HP) Hermitian packed matrix-vector operation defined as y := alpha*A*x + beta*y.\nfor (fname, elty) in ((:zhpmv_, :ComplexF64),\n                      (:chpmv_, :ComplexF32))\n    @eval begin\n        # SUBROUTINE ZHPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY)\n        # Y <- ALPHA*AP*X + BETA*Y\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA,BETA\n        #       INTEGER INCX,INCY,N\n        #       CHARACTER UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(N,N),X(N),Y(N)\n        function hpmv!(uplo::AbstractChar,\n                       n::Integer,\n                       \u03b1::$elty,\n                       AP::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       x::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       incx::Integer,\n                       \u03b2::$elty,\n                       y::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       incy::Integer)\n\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                  (Ref{UInt8},     # uplo,\n                   Ref{BlasInt},   # n,\n                   Ref{$elty},     # \u03b1,\n                   Ptr{$elty},     # AP,\n                   Ptr{$elty},     # x,\n                   Ref{BlasInt},   # incx,\n                   Ref{$elty},     # \u03b2,\n                   Ptr{$elty},     # y, output\n                   Ref{BlasInt},   # incy\n                   Clong),         # length of uplo\n                  uplo,\n                  n,\n                  \u03b1,\n                  AP,\n                  x,\n                  incx,\n                  \u03b2,\n                  y,\n                  incy,\n                  1)\n            return y\n        end\n    end\nend\n\nfunction hpmv!(uplo::AbstractChar,\n               \u03b1::Number, AP::Union{DenseArray{T}, AbstractVector{T}}, x::Union{DenseArray{T}, AbstractVector{T}},\n               \u03b2::Number, y::Union{DenseArray{T}, AbstractVector{T}}) where {T <: BlasComplex}\n    require_one_based_indexing(AP, x, y)\n    N = length(x)\n    if N != length(y)\n        throw(DimensionMismatch(\"x has length $(N), but y has length $(length(y))\"))\n    end\n    if 2*length(AP) < N*(N + 1)\n        throw(DimensionMismatch(\"Packed Hermitian matrix A has size smaller than length(x) =  $(N).\"))\n    end\n    return hpmv!(uplo, N, convert(T, \u03b1), AP, x, stride(x, 1), convert(T, \u03b2), y, stride(y, 1))\nend\n\n\"\"\"\n    hpmv!(uplo, \u03b1, AP, x, \u03b2, y)\n\nUpdate vector `y` as `\u03b1*A*x + \u03b2*y`, where `A` is a Hermitian matrix provided\nin packed format `AP`.\n\nWith `uplo = 'U'`, the array AP must contain the upper triangular part of the\nHermitian matrix packed sequentially, column by column, so that `AP[1]`\ncontains `A[1, 1]`, `AP[2]` and `AP[3]` contain `A[1, 2]` and `A[2, 2]`\nrespectively, and so on.\n\nWith `uplo = 'L'`, the array AP must contain the lower triangular part of the\nHermitian matrix packed sequentially, column by column, so that `AP[1]`\ncontains `A[1, 1]`, `AP[2]` and `AP[3]` contain `A[2, 1]` and `A[3, 1]`\nrespectively, and so on.\n\nThe scalar inputs `\u03b1` and `\u03b2` must be complex or real numbers.\n\nThe array inputs `x`, `y` and `AP` must all be of `ComplexF32` or `ComplexF64` type.\n\nReturn the updated `y`.\n\"\"\"\nhpmv!\n\n### sbmv, (SB) symmetric banded matrix-vector multiplication\nfor (fname, elty) in ((:dsbmv_,:Float64),\n                      (:ssbmv_,:Float32))\n    @eval begin\n             #       SUBROUTINE DSBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER INCX,INCY,K,LDA,N\n             #       CHARACTER UPLO\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function sbmv!(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, beta::($elty), y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Clong),\n                 uplo, size(A,2), k, alpha,\n                 A, max(1,stride(A,2)), x, stride(x,1),\n                 beta, y, stride(y,1), 1)\n            y\n        end\n        function sbmv(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            n = size(A,2)\n            sbmv!(uplo, k, alpha, A, x, zero($elty), similar(x, $elty, n))\n        end\n        function sbmv(uplo::AbstractChar, k::Integer, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            sbmv(uplo, k, one($elty), A, x)\n        end\n    end\nend\n\n\"\"\"\n    sbmv(uplo, k, alpha, A, x)\n\nReturn `alpha*A*x` where `A` is a symmetric band matrix of order `size(A,2)` with `k`\nsuper-diagonals stored in the argument `A`.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsbmv(uplo, k, alpha, A, x)\n\n\"\"\"\n    sbmv(uplo, k, A, x)\n\nReturn `A*x` where `A` is a symmetric band matrix of order `size(A,2)` with `k`\nsuper-diagonals stored in the argument `A`.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsbmv(uplo, k, A, x)\n\n\"\"\"\n    sbmv!(uplo, k, alpha, A, x, beta, y)\n\nUpdate vector `y` as `alpha*A*x + beta*y` where `A` is a symmetric band matrix of order\n`size(A,2)` with `k` super-diagonals stored in the argument `A`. The storage layout for `A`\nis described the reference BLAS module, level-2 BLAS at\n<http://www.netlib.org/lapack/explore-html/>.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\nReturn the updated `y`.\n\"\"\"\nsbmv!\n\n### spmv!, (SP) symmetric packed matrix-vector operation defined as y := alpha*A*x + beta*y.\nfor (fname, elty) in ((:dspmv_, :Float64),\n                      (:sspmv_, :Float32))\n    @eval begin\n        # SUBROUTINE DSPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY)\n        # Y <- ALPHA*AP*X + BETA*Y\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA,BETA\n        #       INTEGER INCX,INCY,N\n        #       CHARACTER UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(N,N),X(N),Y(N)\n        function spmv!(uplo::AbstractChar,\n                       n::Integer,\n                       \u03b1::$elty,\n                       AP::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       x::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       incx::Integer,\n                       \u03b2::$elty,\n                       y::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       incy::Integer)\n\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                  (Ref{UInt8},     # uplo,\n                   Ref{BlasInt},   # n,\n                   Ref{$elty},     # \u03b1,\n                   Ptr{$elty},     # AP,\n                   Ptr{$elty},     # x,\n                   Ref{BlasInt},   # incx,\n                   Ref{$elty},     # \u03b2,\n                   Ptr{$elty},     # y, out\n                   Ref{BlasInt},   # incy\n                   Clong),         # length of uplo\n                  uplo,\n                  n,\n                  \u03b1,\n                  AP,\n                  x,\n                  incx,\n                  \u03b2,\n                  y,\n                  incy,\n                  1)\n            return y\n        end\n    end\nend\n\nfunction spmv!(uplo::AbstractChar,\n               \u03b1::Real, AP::Union{DenseArray{T}, AbstractVector{T}}, x::Union{DenseArray{T}, AbstractVector{T}},\n               \u03b2::Real, y::Union{DenseArray{T}, AbstractVector{T}}) where {T <: BlasReal}\n    require_one_based_indexing(AP, x, y)\n    N = length(x)\n    if N != length(y)\n        throw(DimensionMismatch(\"x has length $(N), but y has length $(length(y))\"))\n    end\n    if 2*length(AP) < N*(N + 1)\n        throw(DimensionMismatch(\"Packed symmetric matrix A has size smaller than length(x) = $(N).\"))\n    end\n    return spmv!(uplo, N, convert(T, \u03b1), AP, x, stride(x, 1), convert(T, \u03b2), y, stride(y, 1))\nend\n\n\"\"\"\n    spmv!(uplo, \u03b1, AP, x, \u03b2, y)\n\nUpdate vector `y` as `\u03b1*A*x + \u03b2*y`, where `A` is a symmetric matrix provided\nin packed format `AP`.\n\nWith `uplo = 'U'`, the array AP must contain the upper triangular part of the\nsymmetric matrix packed sequentially, column by column, so that `AP[1]`\ncontains `A[1, 1]`, `AP[2]` and `AP[3]` contain `A[1, 2]` and `A[2, 2]`\nrespectively, and so on.\n\nWith `uplo = 'L'`, the array AP must contain the lower triangular part of the\nsymmetric matrix packed sequentially, column by column, so that `AP[1]`\ncontains `A[1, 1]`, `AP[2]` and `AP[3]` contain `A[2, 1]` and `A[3, 1]`\nrespectively, and so on.\n\nThe scalar inputs `\u03b1` and `\u03b2` must be real.\n\nThe array inputs `x`, `y` and `AP` must all be of `Float32` or `Float64` type.\n\nReturn the updated `y`.\n\"\"\"\nspmv!\n\n### hbmv, (HB) Hermitian banded matrix-vector multiplication\nfor (fname, elty) in ((:zhbmv_,:ComplexF64),\n                      (:chbmv_,:ComplexF32))\n    @eval begin\n             #       SUBROUTINE ZHBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER INCX,INCY,K,LDA,N\n             #       CHARACTER UPLO\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function hbmv!(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, beta::($elty), y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Clong),\n                 uplo, size(A,2), k, alpha,\n                 A, max(1,stride(A,2)), x, stride(x,1),\n                 beta, y, stride(y,1), 1)\n            y\n        end\n        function hbmv(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            n = size(A,2)\n            hbmv!(uplo, k, alpha, A, x, zero($elty), similar(x, $elty, n))\n        end\n        function hbmv(uplo::AbstractChar, k::Integer, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            hbmv(uplo, k, one($elty), A, x)\n        end\n    end\nend\n\n### trmv, Triangular matrix-vector multiplication\n\n\"\"\"\n    trmv(ul, tA, dA, A, b)\n\nReturn `op(A)*b`, where `op` is determined by [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trmv end\n\n\"\"\"\n    trmv!(ul, tA, dA, A, b)\n\nReturn `op(A)*b`, where `op` is determined by [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nThe multiplication occurs in-place on `b`.\n\"\"\"\nfunction trmv! end\n\nfor (fname, elty) in ((:dtrmv_,:Float64),\n                        (:strmv_,:Float32),\n                        (:ztrmv_,:ComplexF64),\n                        (:ctrmv_,:ComplexF32))\n    @eval begin\n                #       SUBROUTINE DTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,LDA,N\n                #       CHARACTER DIAG,TRANS,UPLO\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION A(LDA,*),X(*)\n        function trmv!(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            require_one_based_indexing(A, x)\n            n = checksquare(A)\n            if n != length(x)\n                throw(DimensionMismatch(\"A has size ($n,$n), x has length $(length(x))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong, Clong),\n                 uplo, trans, diag, n,\n                 A, max(1,stride(A,2)), x, max(1,stride(x, 1)), 1, 1, 1)\n            x\n        end\n        function trmv(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            trmv!(uplo, trans, diag, A, copy(x))\n        end\n    end\nend\n\n### trsv, Triangular matrix-vector solve\n\n\"\"\"\n    trsv!(ul, tA, dA, A, b)\n\nOverwrite `b` with the solution to `A*x = b` or one of the other two variants determined by\n[`tA`](@ref stdlib-blas-trans) and [`ul`](@ref stdlib-blas-uplo).\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nReturn the updated `b`.\n\"\"\"\nfunction trsv! end\n\n\"\"\"\n    trsv(ul, tA, dA, A, b)\n\nReturn the solution to `A*x = b` or one of the other two variants determined by\n[`tA`](@ref stdlib-blas-trans) and [`ul`](@ref stdlib-blas-uplo).\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trsv end\n\nfor (fname, elty) in ((:dtrsv_,:Float64),\n                        (:strsv_,:Float32),\n                        (:ztrsv_,:ComplexF64),\n                        (:ctrsv_,:ComplexF32))\n    @eval begin\n                #       SUBROUTINE DTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)\n                #       .. Scalar Arguments ..\n                #       INTEGER INCX,LDA,N\n                #       CHARACTER DIAG,TRANS,UPLO\n                #       .. Array Arguments ..\n                #       DOUBLE PRECISION A(LDA,*),X(*)\n        function trsv!(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            require_one_based_indexing(A, x)\n            n = checksquare(A)\n            if n != length(x)\n                throw(DimensionMismatch(\"size of A is $n != length(x) = $(length(x))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong, Clong),\n                 uplo, trans, diag, n,\n                 A, max(1,stride(A,2)), x, stride(x, 1), 1, 1, 1)\n            x\n        end\n        function trsv(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            trsv!(uplo, trans, diag, A, copy(x))\n        end\n    end\nend\n\n### ger\n\n\"\"\"\n    ger!(alpha, x, y, A)\n\nRank-1 update of the matrix `A` with vectors `x` and `y` as `alpha*x*y' + A`.\n\"\"\"\nfunction ger! end\n\nfor (fname, elty) in ((:dger_,:Float64),\n                      (:sger_,:Float32),\n                      (:zgerc_,:ComplexF64),\n                      (:cgerc_,:ComplexF32))\n    @eval begin\n        function ger!(\u03b1::$elty, x::AbstractVector{$elty}, y::AbstractVector{$elty}, A::AbstractMatrix{$elty})\n            require_one_based_indexing(A, x, y)\n            m, n = size(A)\n            if m != length(x) || n != length(y)\n                throw(DimensionMismatch(\"A has size ($m,$n), x has length $(length(x)), y has length $(length(y))\"))\n            end\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{BlasInt}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty},\n                 Ref{BlasInt}),\n                 m, n, \u03b1, x,\n                 stride(x, 1), y, stride(y, 1), A,\n                 max(1,stride(A,2)))\n            A\n        end\n    end\nend\n\n### syr\n\n\"\"\"\n    syr!(uplo, alpha, x, A)\n\nRank-1 update of the symmetric matrix `A` with vector `x` as `alpha*x*transpose(x) + A`.\n[`uplo`](@ref stdlib-blas-uplo) controls which triangle of `A` is updated. Returns `A`.\n\"\"\"\nfunction syr! end\n\nfor (fname, elty, lib) in ((:dsyr_,:Float64,libblas),\n                           (:ssyr_,:Float32,libblas),\n                           (:zsyr_,:ComplexF64,liblapack),\n                           (:csyr_,:ComplexF32,liblapack))\n    @eval begin\n        function syr!(uplo::AbstractChar, \u03b1::$elty, x::AbstractVector{$elty}, A::AbstractMatrix{$elty})\n            require_one_based_indexing(A, x)\n            n = checksquare(A)\n            if length(x) != n\n                throw(DimensionMismatch(\"A has size ($n,$n), x has length $(length(x))\"))\n            end\n            ccall((@blasfunc($fname), $lib), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 uplo, n, \u03b1, x,\n                 stride(x, 1), A, max(1,stride(A, 2)))\n            A\n        end\n    end\nend\n\n### her\n\n\"\"\"\n    her!(uplo, alpha, x, A)\n\nMethods for complex arrays only. Rank-1 update of the Hermitian matrix `A` with vector `x`\nas `alpha*x*x' + A`.\n[`uplo`](@ref stdlib-blas-uplo) controls which triangle of `A` is updated. Returns `A`.\n\"\"\"\nfunction her! end\n\nfor (fname, elty, relty) in ((:zher_,:ComplexF64, :Float64),\n                             (:cher_,:ComplexF32, :Float32))\n    @eval begin\n        function her!(uplo::AbstractChar, \u03b1::$relty, x::AbstractVector{$elty}, A::AbstractMatrix{$elty})\n            require_one_based_indexing(A, x)\n            n = checksquare(A)\n            if length(x) != n\n                throw(DimensionMismatch(\"A has size ($n,$n), x has length $(length(x))\"))\n            end\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$relty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Clong),\n                 uplo, n, \u03b1, x,\n                 stride(x, 1), A, max(1,stride(A,2)), 1)\n            A\n        end\n    end\nend\n\n# Level 3\n## (GE) general matrix-matrix multiplication\n\n\"\"\"\n    gemm!(tA, tB, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or the other three variants according to\n[`tA`](@ref stdlib-blas-trans) and `tB`. Return the updated `C`.\n\"\"\"\nfunction gemm! end\n\nfor (gemm, elty) in\n        ((:dgemm_,:Float64),\n         (:sgemm_,:Float32),\n         (:zgemm_,:ComplexF64),\n         (:cgemm_,:ComplexF32))\n    @eval begin\n             # SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER K,LDA,LDB,LDC,M,N\n             #       CHARACTER TRANSA,TRANSB\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function gemm!(transA::AbstractChar, transB::AbstractChar,\n                       alpha::Union{($elty), Bool},\n                       A::AbstractVecOrMat{$elty}, B::AbstractVecOrMat{$elty},\n                       beta::Union{($elty), Bool},\n                       C::AbstractVecOrMat{$elty})\n#           if any([stride(A,1), stride(B,1), stride(C,1)] .!= 1)\n#               error(\"gemm!: BLAS module requires contiguous matrix columns\")\n#           end  # should this be checked on every call?\n            require_one_based_indexing(A, B, C)\n            m = size(A, transA == 'N' ? 1 : 2)\n            ka = size(A, transA == 'N' ? 2 : 1)\n            kb = size(B, transB == 'N' ? 1 : 2)\n            n = size(B, transB == 'N' ? 2 : 1)\n            if ka != kb || m != size(C,1) || n != size(C,2)\n                throw(DimensionMismatch(\"A has size ($m,$ka), B has size ($kb,$n), C has size $(size(C))\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($gemm), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Clong, Clong),\n                 transA, transB, m, n,\n                 ka, alpha, A, max(1,stride(A,2)),\n                 B, max(1,stride(B,2)), beta, C,\n                 max(1,stride(C,2)), 1, 1)\n            C\n        end\n        function gemm(transA::AbstractChar, transB::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            gemm!(transA, transB, alpha, A, B, zero($elty), similar(B, $elty, (size(A, transA == 'N' ? 1 : 2), size(B, transB == 'N' ? 2 : 1))))\n        end\n        function gemm(transA::AbstractChar, transB::AbstractChar, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            gemm(transA, transB, one($elty), A, B)\n        end\n    end\nend\n\n\"\"\"\n    gemm(tA, tB, alpha, A, B)\n\nReturn `alpha*A*B` or the other three variants according to [`tA`](@ref stdlib-blas-trans) and `tB`.\n\"\"\"\ngemm(tA, tB, alpha, A, B)\n\n\"\"\"\n    gemm(tA, tB, A, B)\n\nReturn `A*B` or the other three variants according to [`tA`](@ref stdlib-blas-trans) and `tB`.\n\"\"\"\ngemm(tA, tB, A, B)\n\n\n## (SY) symmetric matrix-matrix and matrix-vector multiplication\nfor (mfname, elty) in ((:dsymm_,:Float64),\n                       (:ssymm_,:Float32),\n                       (:zsymm_,:ComplexF64),\n                       (:csymm_,:ComplexF32))\n    @eval begin\n             #     SUBROUTINE DSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             #     .. Scalar Arguments ..\n             #     DOUBLE PRECISION ALPHA,BETA\n             #     INTEGER LDA,LDB,LDC,M,N\n             #     CHARACTER SIDE,UPLO\n             #     .. Array Arguments ..\n             #     DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function symm!(side::AbstractChar, uplo::AbstractChar, alpha::Union{($elty), Bool},\n                       A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty},\n                       beta::Union{($elty), Bool}, C::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B, C)\n            m, n = size(C)\n            j = checksquare(A)\n            if j != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"A has size $(size(A)), C has size ($m,$n)\"))\n            end\n            if size(B,2) != n\n                throw(DimensionMismatch(\"B has second dimension $(size(B,2)) but needs to match second dimension of C, $n\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($mfname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong),\n                 side, uplo, m, n,\n                 alpha, A, max(1,stride(A,2)), B,\n                 max(1,stride(B,2)), beta, C, max(1,stride(C,2)),\n                 1, 1)\n            C\n        end\n        function symm(side::AbstractChar, uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            symm!(side, uplo, alpha, A, B, zero($elty), similar(B))\n        end\n        function symm(side::AbstractChar, uplo::AbstractChar, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            symm(side, uplo, one($elty), A, B)\n        end\n    end\nend\n\n\"\"\"\n    symm(side, ul, alpha, A, B)\n\nReturn `alpha*A*B` or `alpha*B*A` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be symmetric. Only\nthe [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsymm(side, ul, alpha, A, B)\n\n\"\"\"\n    symm(side, ul, A, B)\n\nReturn `A*B` or `B*A` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be symmetric. Only the [`ul`](@ref stdlib-blas-uplo)\ntriangle of `A` is used.\n\"\"\"\nsymm(side, ul, A, B)\n\n\"\"\"\n    symm!(side, ul, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or `alpha*B*A + beta*C` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be symmetric. Only the [`ul`](@ref stdlib-blas-uplo) triangle of\n`A` is used. Return the updated `C`.\n\"\"\"\nsymm!\n\n## (HE) Hermitian matrix-matrix and matrix-vector multiplication\nfor (mfname, elty) in ((:zhemm_,:ComplexF64),\n                       (:chemm_,:ComplexF32))\n    @eval begin\n             #     SUBROUTINE DHEMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             #     .. Scalar Arguments ..\n             #     DOUBLE PRECISION ALPHA,BETA\n             #     INTEGER LDA,LDB,LDC,M,N\n             #     CHARACTER SIDE,UPLO\n             #     .. Array Arguments ..\n             #     DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function hemm!(side::AbstractChar, uplo::AbstractChar, alpha::Union{($elty), Bool},\n                       A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty},\n                       beta::Union{($elty), Bool}, C::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B, C)\n            m, n = size(C)\n            j = checksquare(A)\n            if j != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"A has size $(size(A)), C has size ($m,$n)\"))\n            end\n            if size(B,2) != n\n                throw(DimensionMismatch(\"B has second dimension $(size(B,2)) but needs to match second dimension of C, $n\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($mfname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong),\n                 side, uplo, m, n,\n                 alpha, A, max(1,stride(A,2)), B,\n                 max(1,stride(B,2)), beta, C, max(1,stride(C,2)),\n                 1, 1)\n            C\n        end\n        function hemm(side::AbstractChar, uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            hemm!(side, uplo, alpha, A, B, zero($elty), similar(B))\n        end\n        function hemm(side::AbstractChar, uplo::AbstractChar, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            hemm(side, uplo, one($elty), A, B)\n        end\n    end\nend\n\n\"\"\"\n    hemm(side, ul, alpha, A, B)\n\nReturn `alpha*A*B` or `alpha*B*A` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be Hermitian. Only the [`ul`](@ref stdlib-blas-uplo) triangle\nof `A` is used.\n\"\"\"\nhemm(side, ul, alpha, A, B)\n\n\"\"\"\n    hemm(side, ul, A, B)\n\nReturn `A*B` or `B*A` according to [`side`](@ref stdlib-blas-side). `A` is assumed\nto be Hermitian. Only the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nhemm(side, ul, A, B)\n\n\"\"\"\n    hemm!(side, ul, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or `alpha*B*A + beta*C` according to\n[`side`](@ref stdlib-blas-side). `A` is assumed to be Hermitian. Only the\n[`ul`](@ref stdlib-blas-uplo) triangle of `A` is used. Return the updated `C`.\n\"\"\"\nhemm!\n\n## syrk\n\n\"\"\"\n    syrk!(uplo, trans, alpha, A, beta, C)\n\nRank-k update of the symmetric matrix `C` as `alpha*A*transpose(A) + beta*C` or\n`alpha*transpose(A)*A + beta*C` according to [`trans`](@ref stdlib-blas-trans).\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is used. Returns `C`.\n\"\"\"\nfunction syrk! end\n\n\"\"\"\n    syrk(uplo, trans, alpha, A)\n\nReturns either the upper triangle or the lower triangle of `A`,\naccording to [`uplo`](@ref stdlib-blas-uplo),\nof `alpha*A*transpose(A)` or `alpha*transpose(A)*A`,\naccording to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nfunction syrk end\n\nfor (fname, elty) in ((:dsyrk_,:Float64),\n                      (:ssyrk_,:Float32),\n                      (:zsyrk_,:ComplexF64),\n                      (:csyrk_,:ComplexF32))\n   @eval begin\n       # SUBROUTINE DSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC)\n       # *     .. Scalar Arguments ..\n       #       REAL ALPHA,BETA\n       #       INTEGER K,LDA,LDC,N\n       #       CHARACTER TRANS,UPLO\n       # *     .. Array Arguments ..\n       #       REAL A(LDA,*),C(LDC,*)\n       function syrk!(uplo::AbstractChar, trans::AbstractChar,\n                      alpha::Union{($elty), Bool}, A::AbstractVecOrMat{$elty},\n                      beta::Union{($elty), Bool}, C::AbstractMatrix{$elty})\n           require_one_based_indexing(A, C)\n           n = checksquare(C)\n           nn = size(A, trans == 'N' ? 1 : 2)\n           if nn != n throw(DimensionMismatch(\"C has size ($n,$n), corresponding dimension of A is $nn\")) end\n           k  = size(A, trans == 'N' ? 2 : 1)\n           chkstride1(A)\n           chkstride1(C)\n           ccall((@blasfunc($fname), libblas), Cvoid,\n                 (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                  Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                  Ptr{$elty}, Ref{BlasInt}, Clong, Clong),\n                 uplo, trans, n, k,\n                 alpha, A, max(1,stride(A,2)), beta,\n                 C, max(1,stride(C,2)), 1, 1)\n            C\n        end\n    end\nend\nfunction syrk(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat)\n    T = eltype(A)\n    n = size(A, trans == 'N' ? 1 : 2)\n    syrk!(uplo, trans, convert(T,alpha), A, zero(T), similar(A, T, (n, n)))\nend\nsyrk(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat) = syrk(uplo, trans, one(eltype(A)), A)\n\n\"\"\"\n    herk!(uplo, trans, alpha, A, beta, C)\n\nMethods for complex arrays only. Rank-k update of the Hermitian matrix `C` as\n`alpha*A*A' + beta*C` or `alpha*A'*A + beta*C` according to [`trans`](@ref stdlib-blas-trans).\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is updated. Returns `C`.\n\"\"\"\nfunction herk! end\n\n\"\"\"\n    herk(uplo, trans, alpha, A)\n\nMethods for complex arrays only. Returns the [`uplo`](@ref stdlib-blas-uplo)\ntriangle of `alpha*A*A'` or `alpha*A'*A`, according to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nfunction herk end\n\nfor (fname, elty, relty) in ((:zherk_, :ComplexF64, :Float64),\n                             (:cherk_, :ComplexF32, :Float32))\n   @eval begin\n       # SUBROUTINE CHERK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC)\n       # *     .. Scalar Arguments ..\n       #       REAL ALPHA,BETA\n       #       INTEGER K,LDA,LDC,N\n       #       CHARACTER TRANS,UPLO\n       # *     ..\n       # *     .. Array Arguments ..\n       #       COMPLEX A(LDA,*),C(LDC,*)\n       function herk!(uplo::AbstractChar, trans::AbstractChar,\n                      \u03b1::Union{$relty, Bool}, A::AbstractVecOrMat{$elty},\n                      \u03b2::Union{$relty, Bool}, C::AbstractMatrix{$elty})\n           require_one_based_indexing(A, C)\n           n = checksquare(C)\n           nn = size(A, trans == 'N' ? 1 : 2)\n           if nn != n\n               throw(DimensionMismatch(\"the matrix to update has dimension $n but the implied dimension of the update is $(size(A, trans == 'N' ? 1 : 2))\"))\n           end\n           chkstride1(A)\n           chkstride1(C)\n           k  = size(A, trans == 'N' ? 2 : 1)\n           ccall((@blasfunc($fname), libblas), Cvoid,\n                 (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                  Ref{$relty}, Ptr{$elty}, Ref{BlasInt}, Ref{$relty},\n                  Ptr{$elty}, Ref{BlasInt}, Clong, Clong),\n                 uplo, trans, n, k,\n                 \u03b1, A, max(1,stride(A,2)), \u03b2,\n                 C, max(1,stride(C,2)), 1, 1)\n           C\n       end\n       function herk(uplo::AbstractChar, trans::AbstractChar, \u03b1::$relty, A::AbstractVecOrMat{$elty})\n           n = size(A, trans == 'N' ? 1 : 2)\n           herk!(uplo, trans, \u03b1, A, zero($relty), similar(A, (n,n)))\n       end\n       herk(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat{$elty}) = herk(uplo, trans, one($relty), A)\n   end\nend\n\n## syr2k\nfor (fname, elty) in ((:dsyr2k_,:Float64),\n                      (:ssyr2k_,:Float32),\n                      (:zsyr2k_,:ComplexF64),\n                      (:csyr2k_,:ComplexF32))\n    @eval begin\n             #       SUBROUTINE DSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             #\n             #       .. Scalar Arguments ..\n             #       REAL PRECISION ALPHA,BETA\n             #       INTEGER K,LDA,LDB,LDC,N\n             #       CHARACTER TRANS,UPLO\n             #       ..\n             #       .. Array Arguments ..\n             #       REAL PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function syr2k!(uplo::AbstractChar, trans::AbstractChar,\n                        alpha::($elty), A::AbstractVecOrMat{$elty}, B::AbstractVecOrMat{$elty},\n                        beta::($elty), C::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B, C)\n            n = checksquare(C)\n            nn = size(A, trans == 'N' ? 1 : 2)\n            if nn != n throw(DimensionMismatch(\"C has size ($n,$n), corresponding dimension of A is $nn\")) end\n            k  = size(A, trans == 'N' ? 2 : 1)\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Clong, Clong),\n                 uplo, trans, n, k,\n                 alpha, A, max(1,stride(A,2)), B, max(1,stride(B,2)), beta,\n                 C, max(1,stride(C,2)), 1, 1)\n            C\n        end\n    end\nend\n\n\"\"\"\n    syr2k!(uplo, trans, alpha, A, B, beta, C)\n\nRank-2k update of the symmetric matrix `C` as\n`alpha*A*transpose(B) + alpha*B*transpose(A) + beta*C` or\n`alpha*transpose(A)*B + alpha*transpose(B)*A + beta*C`\naccording to [`trans`](@ref stdlib-blas-trans).\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is used. Returns `C`.\n\"\"\"\nfunction syr2k! end\n\n\"\"\"\n    syr2k(uplo, trans, alpha, A, B)\n\nReturns the [`uplo`](@ref stdlib-blas-uplo) triangle of\n`alpha*A*transpose(B) + alpha*B*transpose(A)` or\n`alpha*transpose(A)*B + alpha*transpose(B)*A`,\naccording to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nfunction syr2k(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat, B::AbstractVecOrMat)\n    T = eltype(A)\n    n = size(A, trans == 'N' ? 1 : 2)\n    syr2k!(uplo, trans, convert(T,alpha), A, B, zero(T), similar(A, T, (n, n)))\nend\n\"\"\"\n    syr2k(uplo, trans, A, B)\n\nReturns the [`uplo`](@ref stdlib-blas-uplo) triangle of `A*transpose(B) + B*transpose(A)`\nor `transpose(A)*B + transpose(B)*A`, according to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nsyr2k(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat, B::AbstractVecOrMat) = syr2k(uplo, trans, one(eltype(A)), A, B)\n\nfor (fname, elty1, elty2) in ((:zher2k_,:ComplexF64,:Float64), (:cher2k_,:ComplexF32,:Float32))\n   @eval begin\n       # SUBROUTINE CHER2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n       #\n       #       .. Scalar Arguments ..\n       #       COMPLEX ALPHA\n       #       REAL BETA\n       #       INTEGER K,LDA,LDB,LDC,N\n       #       CHARACTER TRANS,UPLO\n       #       ..\n       #       .. Array Arguments ..\n       #       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*)\n       function her2k!(uplo::AbstractChar, trans::AbstractChar, alpha::($elty1),\n                       A::AbstractVecOrMat{$elty1}, B::AbstractVecOrMat{$elty1},\n                       beta::($elty2), C::AbstractMatrix{$elty1})\n           require_one_based_indexing(A, B, C)\n           n = checksquare(C)\n           nn = size(A, trans == 'N' ? 1 : 2)\n           if nn != n throw(DimensionMismatch(\"C has size ($n,$n), corresponding dimension of A is $nn\")) end\n           chkstride1(A)\n           chkstride1(B)\n           chkstride1(C)\n           k  = size(A, trans == 'N' ? 2 : 1)\n           ccall((@blasfunc($fname), libblas), Cvoid,\n                 (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                  Ref{$elty1}, Ptr{$elty1}, Ref{BlasInt}, Ptr{$elty1}, Ref{BlasInt},\n                  Ref{$elty2},  Ptr{$elty1}, Ref{BlasInt}, Clong, Clong),\n                 uplo, trans, n, k,\n                 alpha, A, max(1,stride(A,2)), B, max(1,stride(B,2)),\n                 beta, C, max(1,stride(C,2)), 1, 1)\n           C\n       end\n       function her2k(uplo::AbstractChar, trans::AbstractChar, alpha::($elty1), A::AbstractVecOrMat{$elty1}, B::AbstractVecOrMat{$elty1})\n           n = size(A, trans == 'N' ? 1 : 2)\n           her2k!(uplo, trans, alpha, A, B, zero($elty2), similar(A, $elty1, (n,n)))\n       end\n       her2k(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat{$elty1}, B::AbstractVecOrMat{$elty1}) = her2k(uplo, trans, one($elty1), A, B)\n   end\nend\n\n\"\"\"\n    her2k!(uplo, trans, alpha, A, B, beta, C)\n\nRank-2k update of the Hermitian matrix `C` as\n`alpha*A*B' + alpha*B*A' + beta*C` or `alpha*A'*B + alpha*B'*A + beta*C`\naccording to [`trans`](@ref stdlib-blas-trans). The scalar `beta` has to be real.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is used. Returns `C`.\n\"\"\"\nfunction her2k! end\n\n\"\"\"\n    her2k(uplo, trans, alpha, A, B)\n\nReturns the [`uplo`](@ref stdlib-blas-uplo) triangle of `alpha*A*B' + alpha*B*A'`\nor `alpha*A'*B + alpha*B'*A`, according to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nher2k(uplo, trans, alpha, A, B)\n\n\"\"\"\n    her2k(uplo, trans, A, B)\n\nReturns the [`uplo`](@ref stdlib-blas-uplo) triangle of `A*B' + B*A'`\nor `A'*B + B'*A`, according to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nher2k(uplo, trans, A, B)\n\n## (TR) Triangular matrix and vector multiplication and solution\n\n\"\"\"\n    trmm!(side, ul, tA, dA, alpha, A, B)\n\nUpdate `B` as `alpha*A*B` or one of the other three variants determined by\n[`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nReturns the updated `B`.\n\"\"\"\nfunction trmm! end\n\n\"\"\"\n    trmm(side, ul, tA, dA, alpha, A, B)\n\nReturns `alpha*A*B` or one of the other three variants determined by\n[`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trmm end\n\n\"\"\"\n    trsm!(side, ul, tA, dA, alpha, A, B)\n\nOverwrite `B` with the solution to `A*X = alpha*B` or one of the other three variants\ndetermined by [`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nReturns the updated `B`.\n\"\"\"\nfunction trsm! end\n\n\"\"\"\n    trsm(side, ul, tA, dA, alpha, A, B)\n\nReturn the solution to `A*X = alpha*B` or one of the other three variants determined by\ndetermined by [`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trsm end\n\nfor (mmname, smname, elty) in\n        ((:dtrmm_,:dtrsm_,:Float64),\n         (:strmm_,:strsm_,:Float32),\n         (:ztrmm_,:ztrsm_,:ComplexF64),\n         (:ctrmm_,:ctrsm_,:ComplexF32))\n    @eval begin\n        #       SUBROUTINE DTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA\n        #       INTEGER LDA,LDB,M,N\n        #       CHARACTER DIAG,SIDE,TRANSA,UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(LDA,*),B(LDB,*)\n        function trmm!(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar, alpha::Number,\n                       A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B)\n            m, n = size(B)\n            nA = checksquare(A)\n            if nA != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"size of A, $(size(A)), doesn't match $side size of B with dims, $(size(B))\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            ccall((@blasfunc($mmname), libblas), Cvoid,\n                  (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                   Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                   Clong, Clong, Clong, Clong),\n                  side, uplo, transa, diag, m, n,\n                  alpha, A, max(1,stride(A,2)), B, max(1,stride(B,2)),\n                  1, 1, 1, 1)\n            B\n        end\n        function trmm(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar,\n                      alpha::$elty, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            trmm!(side, uplo, transa, diag, alpha, A, copy(B))\n        end\n        #       SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA\n        #       INTEGER LDA,LDB,M,N\n        #       CHARACTER DIAG,SIDE,TRANSA,UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(LDA,*),B(LDB,*)\n        function trsm!(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar,\n                       alpha::$elty, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B)\n            m, n = size(B)\n            k = checksquare(A)\n            if k != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"size of A is ($k,$k), size of B is ($m,$n), side is $side, and transa='$transa'\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            ccall((@blasfunc($smname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{UInt8},\n                 Ref{BlasInt}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong, Clong, Clong),\n                 side, uplo, transa, diag,\n                 m, n, alpha, A,\n                 max(1,stride(A,2)), B, max(1,stride(B,2)),\n                 1, 1, 1, 1)\n            B\n        end\n        function trsm(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar, alpha::$elty, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            trsm!(side, uplo, transa, diag, alpha, A, copy(B))\n        end\n    end\nend\n\nend # module\n\nfunction copyto!(dest::Array{T}, rdest::Union{UnitRange{Ti},AbstractRange{Ti}},\n                 src::Array{T}, rsrc::Union{UnitRange{Ti},AbstractRange{Ti}}) where {T<:BlasFloat,Ti<:Integer}\n    if minimum(rdest) < 1 || maximum(rdest) > length(dest)\n        throw(ArgumentError(\"range out of bounds for dest, of length $(length(dest))\"))\n    end\n    if minimum(rsrc) < 1 || maximum(rsrc) > length(src)\n        throw(ArgumentError(\"range out of bounds for src, of length $(length(src))\"))\n    end\n    if length(rdest) != length(rsrc)\n        throw(DimensionMismatch(\"ranges must be of the same length\"))\n    end\n    GC.@preserve src dest BLAS.blascopy!(\n        length(rsrc),\n        pointer(src) + (first(rsrc) - 1) * sizeof(T),\n        step(rsrc),\n        pointer(dest) + (first(rdest) - 1) * sizeof(T),\n        step(rdest))\n\n    return dest\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LibCURL_jll/src/LibCURL_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/LibCURL_jll.jl\n\nbaremodule LibCURL_jll\nusing Base, Libdl, nghttp2_jll\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libcurl\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibcurl_handle = C_NULL\nlibcurl_path = \"\"\n\nif Sys.iswindows()\n    const libcurl = \"libcurl-4.dll\"\nelseif Sys.isapple()\n    const libcurl = \"@rpath/libcurl.4.dylib\"\nelse\n    const libcurl = \"libcurl.so\"\nend\n\nfunction __init__()\n    global libcurl_handle = dlopen(libcurl)\n    global libcurl_path = dlpath(libcurl_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libcurl_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libcurl_path() = libcurl_path\n\nend  # module LibCURL_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/Libdl/src/Libdl.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule Libdl\n# Just re-export Base.Libc.Libdl:\nexport DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n    dlpath, find_library, dlext, dllist\n\nimport Base.Libc.Libdl: DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n                        RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n                        dlpath, find_library, dlext, dllist\n\nend # module\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/Libdl/test/runtests.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nusing Test\nimport Libdl\n\n# these could fail on an embedded installation\n# but for now, we don't handle that case\ndlls = Libdl.dllist()\n@test !isempty(dlls)\n@test length(dlls) > 3 # at a bare minimum, probably have some version of libstdc, libgcc, libjulia, ...\nif !Sys.iswindows() || Sys.windows_version() >= Sys.WINDOWS_VISTA_VER\n    for dl in dlls\n        if isfile(dl) && (Libdl.dlopen(dl; throw_error=false) !== nothing)\n            @test Base.samefile(Libdl.dlpath(dl), dl)\n        end\n    end\nend\n@test length(filter(dlls) do dl\n      if Base.DARWIN_FRAMEWORK\n          return occursin(Regex(\"^$(Base.DARWIN_FRAMEWORK_NAME)(?:_debug)?\\$\"), basename(dl))\n      else\n          return occursin(Regex(\"^libjulia-internal(?:.*)\\\\.$(Libdl.dlext)(?:\\\\..+)?\\$\"), basename(dl))\n      end\n    end) == 1 # look for something libjulia-like (but only one)\n\n# library handle pointer must not be NULL\n@test_throws ArgumentError Libdl.dlsym(C_NULL, :foo)\n@test_throws ArgumentError Libdl.dlsym_e(C_NULL, :foo)\n\ncd(@__DIR__) do\n\n# Find the library directory by finding the path of libjulia-internal (or libjulia-internal-debug,\n# as the case may be) to get the private library directory\nprivate_libdir = if Base.DARWIN_FRAMEWORK\n    if ccall(:jl_is_debugbuild, Cint, ()) != 0\n        dirname(abspath(Libdl.dlpath(Base.DARWIN_FRAMEWORK_NAME * \"_debug\")))\n    else\n        joinpath(dirname(abspath(Libdl.dlpath(Base.DARWIN_FRAMEWORK_NAME))),\"Frameworks\")\n    end\nelseif ccall(:jl_is_debugbuild, Cint, ()) != 0\n    dirname(abspath(Libdl.dlpath(\"libjulia-internal-debug\")))\nelse\n    dirname(abspath(Libdl.dlpath(\"libjulia-internal\")))\nend\n\n@test !isempty(Libdl.find_library([\"libccalltest\"], [private_libdir]))\n@test !isempty(Libdl.find_library(\"libccalltest\", [private_libdir]))\n@test !isempty(Libdl.find_library(:libccalltest, [private_libdir]))\n\n# dlopen should be able to handle absolute and relative paths, with and without dlext\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\")); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(relpath(joinpath(private_libdir, \"libccalltest\")); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(relpath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(\"./foo\"; throw_error=false)\n        @test dl === nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# unqualified names present in DL_LOAD_PATH\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(\"libccalltest\"; throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(string(\"libccalltest\",\".\",Libdl.dlext); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# path with dlopen-able file first in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, @__DIR__)\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# path with dlopen-able file second in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        push!(Libdl.DL_LOAD_PATH, @__DIR__)\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# test dlpath\nlet dl = C_NULL\n    try\n        path = abspath(joinpath(private_libdir, \"libccalltest\"))\n        dl = Libdl.dlopen(path; throw_error=false)\n        @test dl !== nothing\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            abspath(Libdl.dlpath(path)))\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            string(path,\".\",Libdl.dlext))\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# opening a library that does not exist throws an ErrorException\n@test_throws ErrorException Libdl.dlopen(\"./foo\")\n\n# opening a versioned library that does not exist does not result in adding extension twice\nerr = @test_throws ErrorException Libdl.dlopen(\"./foo.$(Libdl.dlext).0\")\n@test !occursin(\"foo.$(Libdl.dlext).0.$(Libdl.dlext)\", err.value.msg)\nerr = @test_throws ErrorException Libdl.dlopen(\"./foo.$(Libdl.dlext).0.22.1\")\n@test !occursin(\"foo.$(Libdl.dlext).0.22.1.$(Libdl.dlext)\", err.value.msg)\n\n# test dlsym\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\")))\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr !== nothing\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# test do-block dlopen\nLibdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\"))) do dl\n    fptr = Libdl.dlsym(dl, :set_verbose)\n    @test fptr !== nothing\n    @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n    fptr = Libdl.dlsym_e(dl, :set_verbose)\n    @test fptr != C_NULL\n    fptr = Libdl.dlsym_e(dl, :foo)\n    @test fptr == C_NULL\nend\n\n# test dlclose\n# If dl is NULL, jl_dlclose should return -1 and dlclose should return false\n# dlclose should return true on success and false on failure\nlet dl = C_NULL\n    @test -1 == ccall(:jl_dlclose, Cint, (Ptr{Cvoid},), dl)\n    @test !Libdl.dlclose(dl)\n\n    dl = Libdl.dlopen(\"libccalltest\"; throw_error=false)\n    @test dl !== nothing\n\n    @test Libdl.dlclose(dl)\n    @test_skip !Libdl.dlclose(dl)   # Syscall doesn't fail on Win32\nend\n\n# test DL_LOAD_PATH handling and @executable_path expansion\nmktempdir() do dir\n    # Create a `libdcalltest` in a directory that is not on our load path\n    src_path = joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")\n    dst_path = joinpath(dir, \"libdcalltest.$(Libdl.dlext)\")\n    cp(src_path, dst_path)\n\n    # Add an absurdly long entry to the load path to verify it doesn't lead to a buffer overflow\n    push!(Base.DL_LOAD_PATH, joinpath(dir, join(rand('a':'z', 10000))))\n\n    # Add the temporary directors to load path by absolute path\n    push!(Base.DL_LOAD_PATH, dir)\n\n    # Test that we can now open that file\n    Libdl.dlopen(\"libdcalltest\") do dl\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr !== nothing\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    end\n\n    # Skip these tests if the temporary directory is not on the same filesystem\n    # as the BINDIR, as in that case, a relative path will never work.\n    if Base.Filesystem.splitdrive(dir)[1] != Base.Filesystem.splitdrive(Sys.BINDIR)[1]\n        return\n    end\n\n    empty!(Base.DL_LOAD_PATH)\n    push!(Base.DL_LOAD_PATH, joinpath(dir, join(rand('a':'z', 10000))))\n\n    # Add this temporary directory to our load path, now using `@executable_path` to do so.\n    push!(Base.DL_LOAD_PATH, joinpath(\"@executable_path\", relpath(dir, Sys.BINDIR)))\n\n    # Test that we can now open that file\n    Libdl.dlopen(\"libdcalltest\") do dl\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr !== nothing\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    end\nend\n\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/Libdl/docs/src/index.md": "# Dynamic Linker\n\n```@docs\nLibdl.dlopen\nLibdl.dlopen_e\nLibdl.RTLD_NOW\nLibdl.dlsym\nLibdl.dlsym_e\nLibdl.dlclose\nLibdl.dlext\nLibdl.dllist\nLibdl.dlpath\nLibdl.find_library\nLibdl.DL_LOAD_PATH\n```\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/OpenLibm_jll/src/OpenLibm_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/OpenLibm_jll.jl\nbaremodule OpenLibm_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libopenlibm\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibopenlibm_handle = C_NULL\nlibopenlibm_path = \"\"\n\nif Sys.iswindows()\n    const libopenlibm = \"libopenlibm.dll\"\nelseif Sys.isapple()\n    const libopenlibm = \"@rpath/libopenlibm.3.dylib\"\nelse\n    const libopenlibm = \"libopenlibm.so.3\"\nend\n\nfunction __init__()\n    global libopenlibm_handle = dlopen(libopenlibm)\n    global libopenlibm_path = dlpath(libopenlibm_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libopenlibm_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libopenlibm_path() = libopenlibm_path\n\nend  # module OpenLibm_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LibGit2_jll/src/LibGit2_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/LibGit2_jll.jl\n\nbaremodule LibGit2_jll\nusing Base, Libdl, MbedTLS_jll, LibSSH2_jll\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libgit2\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibgit2_handle = C_NULL\nlibgit2_path = \"\"\n\nif Sys.iswindows()\n    const libgit2 = \"libgit2.dll\"\nelseif Sys.isapple()\n    const libgit2 = \"@rpath/libgit2.1.1.dylib\"\nelse\n    const libgit2 = \"libgit2.so.1.1\"\nend\n\nfunction __init__()\n    global libgit2_handle = dlopen(libgit2)\n    global libgit2_path = dlpath(libgit2_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libgit2_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libgit2_path() = libgit2_path\n\nend  # module LibGit2_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/SuiteSparse/src/cholmod.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n# Theoretically CHOLMOD supports both Int32 and Int64 indices on 64-bit.\n# However experience suggests that using both in the same session causes memory\n# leaks, so we restrict indices to be SuiteSparse_long (see cholmod_h.jl).\n# Ref: https://github.com/JuliaLang/julia/issues/12664\n\n# Additionally, only Float64/ComplexF64 are supported in practice.\n# Ref: https://github.com/JuliaLang/julia/issues/25986\n\nmodule CHOLMOD\n\nimport Base: (*), convert, copy, eltype, getindex, getproperty, show, size,\n             IndexStyle, IndexLinear, IndexCartesian, adjoint, axes\nusing Base: require_one_based_indexing\n\nusing LinearAlgebra\nimport LinearAlgebra: (\\),\n                 cholesky, cholesky!, det, diag, ishermitian, isposdef,\n                 issuccess, issymmetric, ldlt, ldlt!, logdet\n\nusing SparseArrays\nusing SparseArrays: getcolptr\nimport Libdl\n\nexport\n    Dense,\n    Factor,\n    Sparse\n\nimport SparseArrays: AbstractSparseMatrix, SparseMatrixCSC, indtype, sparse, spzeros, nnz\n\nimport ..increment, ..increment!, ..decrement, ..decrement!\n\n#########\n# Setup #\n#########\n\ninclude(\"cholmod_h.jl\")\n\nconst CHOLMOD_MIN_VERSION = v\"2.1.1\"\n\nconst common_struct = Vector{Vector{UInt8}}()\n\nconst common_supernodal = Vector{Ptr{Cint}}()\nconst common_final_ll   = Vector{Ptr{Cint}}()\nconst common_print      = Vector{Ptr{Cint}}()\nconst common_itype      = Vector{Ptr{Cint}}()\nconst common_dtype      = Vector{Ptr{Cint}}()\nconst common_nmethods   = Vector{Ptr{Cint}}()\nconst common_postorder  = Vector{Ptr{Cint}}()\n\n### These offsets are defined in SuiteSparse_wrapper.c\nconst common_size = ccall((:jl_cholmod_common_size,:libsuitesparse_wrapper),Int,())\n\nconst cholmod_com_offsets = Vector{Csize_t}(undef, 19)\nccall((:jl_cholmod_common_offsets, :libsuitesparse_wrapper),\n    Nothing, (Ptr{Csize_t},), cholmod_com_offsets)\n\n## macro to generate the name of the C function according to the integer type\nmacro cholmod_name(nm)\n    string(\"cholmod_l_\", nm)\nend\n\nfunction start(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"start\"), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction finish(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"finish\"), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction defaults(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"defaults\"), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nconst build_version_array = Vector{Cint}(undef, 3)\nccall((:jl_cholmod_version, :libsuitesparse_wrapper), Cint, (Ptr{Cint},), build_version_array)\nconst build_version = VersionNumber(build_version_array...)\n\nfunction __init__()\n    try\n        ### Check if the linked library is compatible with the Julia code\n        if Libdl.dlsym_e(Libdl.dlopen(\"libcholmod\"), :cholmod_version) != C_NULL\n            current_version_array = Vector{Cint}(undef, 3)\n            ccall((:cholmod_version, :libcholmod), Cint, (Ptr{Cint},), current_version_array)\n            current_version = VersionNumber(current_version_array...)\n        else # CHOLMOD < 2.1.1 does not include cholmod_version()\n            current_version = v\"0.0.0\"\n        end\n\n\n        if current_version < CHOLMOD_MIN_VERSION\n            @warn \"\"\"\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with a version older than\n                $(CHOLMOD_MIN_VERSION). This might cause Julia to\n                terminate when working with sparse matrix factorizations,\n                e.g. solving systems of equations with \\\\.\n\n                It is recommended that you use Julia with a recent version\n                of CHOLMOD, or download the generic binaries\n                from www.julialang.org, which ship with the correct\n                versions of all dependencies.\n                \"\"\"\n        elseif build_version_array[1] != current_version_array[1]\n            @warn \"\"\"\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with version $current_version.\n                This might cause Julia to terminate when working with\n                sparse matrix factorizations, e.g. solving systems of\n                equations with \\\\.\n\n                It is recommended that you use Julia with the same major\n                version of CHOLMOD as the one used during the build, or\n                download the generic binaries from www.julialang.org,\n                which ship with the correct versions of all dependencies.\n                \"\"\"\n        end\n\n        intsize = Int(ccall((:jl_cholmod_sizeof_long,:libsuitesparse_wrapper),Csize_t,()))\n        if intsize != 4length(IndexTypes)\n            @error \"\"\"\n                 CHOLMOD integer size incompatibility\n\n                 Julia was compiled with a version of CHOLMOD that\n                 supported $(32length(IndexTypes)) bit integers. It is\n                 currently linked with version that supports $(8intsize)\n                 integers. This might cause Julia to terminate when\n                 working with sparse matrix factorizations, e.g. solving\n                 systems of equations with \\\\.\n\n                 This problem can be fixed by modifying the Julia build\n                 configuration or by downloading the OS X or generic\n                 Linux binary from www.julialang.org, which include\n                 the correct versions of all dependencies.\n                 \"\"\"\n        end\n\n        ### Initiate CHOLMOD\n        ### common_struct controls the type of factorization and keeps pointers\n        ### to temporary memory. We need to manage a copy for each thread.\n        nt = Threads.nthreads()\n        resize!(common_struct    , nt)\n        resize!(common_supernodal, nt)\n        resize!(common_final_ll  , nt)\n        resize!(common_print     , nt)\n        resize!(common_itype     , nt)\n        resize!(common_dtype     , nt)\n        resize!(common_nmethods  , nt)\n        resize!(common_postorder , nt)\n        for i in 1:nt\n            common_struct[i] = fill(0xff, common_size)\n\n            common_supernodal[i] = pointer(common_struct[i], cholmod_com_offsets[4] + 1)\n            common_final_ll[i]   = pointer(common_struct[i], cholmod_com_offsets[7] + 1)\n            common_print[i]      = pointer(common_struct[i], cholmod_com_offsets[13] + 1)\n            common_itype[i]      = pointer(common_struct[i], cholmod_com_offsets[18] + 1)\n            common_dtype[i]      = pointer(common_struct[i], cholmod_com_offsets[19] + 1)\n            common_nmethods[i]   = pointer(common_struct[i], cholmod_com_offsets[15] + 1)\n            common_postorder[i]  = pointer(common_struct[i], cholmod_com_offsets[17] + 1)\n\n            start(common_struct[i])              # initializes CHOLMOD\n            set_print_level(common_struct[i], 0) # no printing from CHOLMOD by default\n        end\n\n        # Register gc tracked allocator if CHOLMOD is new enough\n        if current_version >= v\"3.0.0\"\n            cnfg = cglobal((:SuiteSparse_config, :libsuitesparseconfig), Ptr{Cvoid})\n            unsafe_store!(cnfg, cglobal(:jl_malloc, Ptr{Cvoid}), 1)\n            unsafe_store!(cnfg, cglobal(:jl_calloc, Ptr{Cvoid}), 2)\n            unsafe_store!(cnfg, cglobal(:jl_realloc, Ptr{Cvoid}), 3)\n            unsafe_store!(cnfg, cglobal(:jl_free, Ptr{Cvoid}), 4)\n        end\n\n    catch ex\n        @error \"Error during initialization of module CHOLMOD\" exception=ex,catch_backtrace()\n    end\nend\n\nfunction set_print_level(cm::Vector{UInt8}, lev::Integer)\n    unsafe_store!(common_print[Threads.threadid()], lev)\nend\n\n####################\n# Type definitions #\n####################\n\nabstract type SuiteSparseStruct end\n\n# The three core data types for CHOLMOD: Dense, Sparse and Factor.\n# CHOLMOD manages the memory, so the Julia versions only wrap a\n# pointer to a struct.  Therefore finalizers should be registered each\n# time a pointer is returned from CHOLMOD.\n\n# Dense\nstruct C_Dense{T<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    d::Csize_t\n    x::Ptr{T}\n    z::Ptr{Cvoid}\n    xtype::Cint\n    dtype::Cint\nend\n\nmutable struct Dense{Tv<:VTypes} <: DenseMatrix{Tv}\n    ptr::Ptr{C_Dense{Tv}}\n    function Dense{Tv}(ptr::Ptr{C_Dense{Tv}}) where Tv<:VTypes\n        if ptr == C_NULL\n            throw(ArgumentError(\"dense matrix construction failed for \" *\n                \"unknown reasons. Please submit a bug report.\"))\n        end\n        s = unsafe_load(ptr)\n        if s.xtype != xtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"xtype=$(s.xtype) not supported\"))\n        elseif s.dtype != dtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"dtype=$(s.dtype) not supported\"))\n        end\n        A = new(ptr)\n        finalizer(free!, A)\n        return A\n    end\nend\nDense(p::Ptr{C_Dense{Tv}}) where {Tv<:VTypes} = Dense{Tv}(p)\n\n# Sparse\n# allow Cvoid pointer for reading matrices of unknown type from files as in\n# cholmod_read_sparse\nstruct C_Sparse{Tv<:Union{Cvoid, VTypes}} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{SuiteSparse_long}\n    i::Ptr{SuiteSparse_long}\n    nz::Ptr{SuiteSparse_long}\n    x::Ptr{Tv}\n    z::Ptr{Cvoid}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\nmutable struct Sparse{Tv<:VTypes} <: AbstractSparseMatrix{Tv,SuiteSparse_long}\n    ptr::Ptr{C_Sparse{Tv}}\n    function Sparse{Tv}(ptr::Ptr{C_Sparse{Tv}}) where Tv<:VTypes\n        if ptr == C_NULL\n            throw(ArgumentError(\"sparse matrix construction failed for \" *\n                \"unknown reasons. Please submit a bug report.\"))\n        end\n        s = unsafe_load(ptr)\n        if s.itype != ityp(SuiteSparse_long)\n            free!(ptr)\n            throw(CHOLMODException(\"itype=$(s.itype) not supported\"))\n        elseif s.xtype != xtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"xtype=$(s.xtype) not supported\"))\n        elseif s.dtype != dtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"dtype=$(s.dtype) not supported\"))\n        end\n        A = new(ptr)\n        finalizer(free!, A)\n        return A\n    end\nend\nSparse(p::Ptr{C_Sparse{Tv}}) where {Tv<:VTypes} = Sparse{Tv}(p)\n\n# Useful when reading in files, but not type stable\nfunction Sparse(p::Ptr{C_Sparse{Cvoid}})\n    if p == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed for \" *\n                            \"unknown reasons. Please submit a bug report.\"))\n    end\n    s = unsafe_load(p)\n    Tv = s.xtype == REAL ? Float64 : ComplexF64\n    Sparse(convert(Ptr{C_Sparse{Tv}}, p))\nend\n\nBase.unsafe_convert(::Type{Ptr{Tv}}, A::Sparse{Tv}) where {Tv} = getfield(A, :ptr)\n\n# Factor\n# Cvoid is used for pattern-only factors\nstruct C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n    n::Csize_t\n    minor::Csize_t\n    Perm::Ptr{SuiteSparse_long}\n    ColCount::Ptr{SuiteSparse_long}\n    @static if build_version >= v\"2.1.0\"\n        IPerm::Ptr{SuiteSparse_long}  # this pointer was added in version 2.1.0\n    end\n    nzmax::Csize_t\n    p::Ptr{SuiteSparse_long}\n    i::Ptr{SuiteSparse_long}\n    x::Ptr{Tv}\n    z::Ptr{Cvoid}\n    nz::Ptr{SuiteSparse_long}\n    next::Ptr{SuiteSparse_long}\n    prev::Ptr{SuiteSparse_long}\n    nsuper::Csize_t\n    ssize::Csize_t\n    xsize::Csize_t\n    maxcsize::Csize_t\n    maxesize::Csize_t\n    super::Ptr{SuiteSparse_long}\n    pi::Ptr{SuiteSparse_long}\n    px::Ptr{SuiteSparse_long}\n    s::Ptr{SuiteSparse_long}\n    ordering::Cint\n    is_ll::Cint\n    is_super::Cint\n    is_monotonic::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\nend\n\nmutable struct Factor{Tv<:VTypes} <: Factorization{Tv}\n    ptr::Ptr{C_Factor{Tv}}\n    function Factor{Tv}(ptr::Ptr{C_Factor{Tv}}, register_finalizer = true) where Tv\n        if ptr == C_NULL\n            throw(ArgumentError(\"factorization construction failed for \" *\n                \"unknown reasons. Please submit a bug report.\"))\n        end\n        s = unsafe_load(ptr)\n        if s.itype != ityp(SuiteSparse_long)\n            free!(ptr)\n            throw(CHOLMODException(\"itype=$(s.itype) not supported\"))\n        elseif s.xtype != xtyp(Tv) && s.xtype != PATTERN\n            free!(ptr)\n            throw(CHOLMODException(\"xtype=$(s.xtype) not supported\"))\n        elseif s.dtype != dtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"dtype=$(s.dtype) not supported\"))\n        end\n        F = new(ptr)\n        if register_finalizer\n            finalizer(free!, F)\n        end\n        return F\n    end\nend\nFactor(ptr::Ptr{C_Factor{Tv}}) where {Tv<:VTypes} = Factor{Tv}(ptr)\nFactor(x::Factor) = x\n\nBase.adjoint(F::Factor) = Adjoint(F)\nBase.transpose(F::Factor) = Transpose(F)\n\n# All pointer loads should be checked to make sure that SuiteSparse is not called with\n# a C_NULL pointer which could cause a segfault. Pointers are set to null\n# when serialized so this can happen when multiple processes are in use.\nfunction Base.unsafe_convert(::Type{Ptr{T}}, x::Union{Dense,Sparse,Factor}) where T<:SuiteSparseStruct\n    xp = getfield(x, :ptr)\n    if xp == C_NULL\n        throw(ArgumentError(\"pointer to the $T object is null. This can \" *\n            \"happen if the object has been serialized.\"))\n    else\n        return xp\n    end\nend\nBase.pointer(x::Dense{Tv}) where {Tv}  = Base.unsafe_convert(Ptr{C_Dense{Tv}}, x)\nBase.pointer(x::Sparse{Tv}) where {Tv} = Base.unsafe_convert(Ptr{C_Sparse{Tv}}, x)\nBase.pointer(x::Factor{Tv}) where {Tv} = Base.unsafe_convert(Ptr{C_Factor{Tv}}, x)\n\n# FactorComponent, for encoding particular factors from a factorization\nmutable struct FactorComponent{Tv,S} <: AbstractMatrix{Tv}\n    F::Factor{Tv}\n\n    function FactorComponent{Tv,S}(F::Factor{Tv}) where {Tv,S}\n        s = unsafe_load(pointer(F))\n        if s.is_ll != 0\n            if !(S === :L || S === :U || S === :PtL || S === :UP)\n                throw(CHOLMODException(string(S, \" not supported for sparse \",\n                    \"LLt matrices; try :L, :U, :PtL, or :UP\")))\n            end\n        elseif !(S === :L || S === :U || S === :PtL || S === :UP ||\n                S === :D || S === :LD || S === :DU || S === :PtLD || S === :DUP)\n            throw(CHOLMODException(string(S, \" not supported for sparse LDLt \",\n                \"matrices; try :L, :U, :PtL, :UP, :D, :LD, :DU, :PtLD, or :DUP\")))\n        end\n        new(F)\n    end\nend\nfunction FactorComponent(F::Factor{Tv}, sym::Symbol) where Tv\n    FactorComponent{Tv,sym}(F)\nend\n\nFactor(FC::FactorComponent) = Factor(FC.F)\n\n#################\n# Thin wrappers #\n#################\n\n# Dense wrappers\n\n### cholmod_core_h ###\nfunction allocate_dense(m::Integer, n::Integer, d::Integer, ::Type{Tv}) where {Tv<:VTypes}\n    Dense(ccall((@cholmod_name(\"allocate_dense\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Csize_t, Csize_t, Csize_t, Cint, Ptr{Cvoid}),\n                m, n, d, xtyp(Tv), common_struct[Threads.threadid()]))\nend\n\nfunction free!(p::Ptr{C_Dense{Tv}}) where {Tv<:VTypes}\n    @isok ccall((@cholmod_name(\"free_dense\"), :libcholmod), Cint,\n                (Ref{Ptr{C_Dense{Tv}}}, Ptr{Cvoid}),\n                p, common_struct[Threads.threadid()])\nend\nfunction zeros(m::Integer, n::Integer, ::Type{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"zeros\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common_struct[Threads.threadid()]))\nend\nzeros(m::Integer, n::Integer) = zeros(m, n, Float64)\n\nfunction ones(m::Integer, n::Integer, ::Type{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"ones\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common_struct[Threads.threadid()]))\nend\nones(m::Integer, n::Integer) = ones(m, n, Float64)\n\nfunction eye(m::Integer, n::Integer, ::Type{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"eye\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common_struct[Threads.threadid()]))\nend\neye(m::Integer, n::Integer) = eye(m, n, Float64)\neye(n::Integer) = eye(n, n, Float64)\n\nfunction copy(A::Dense{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"copy_dense\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                A, common_struct[Threads.threadid()]))\nend\n\nfunction sort!(S::Sparse{Tv}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"sort\"), :libcholmod), Cint,\n                (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                S, common_struct[Threads.threadid()])\n    return S\nend\n\n### cholmod_matrixops.h ###\nfunction norm_dense(D::Dense{Tv}, p::Integer) where Tv<:VTypes\n    s = unsafe_load(pointer(D))\n    if p == 2\n        if s.ncol > 1\n            throw(ArgumentError(\"2 norm only supported when matrix has one column\"))\n        end\n    elseif p != 0 && p != 1\n        throw(ArgumentError(\"second argument must be either 0 (Inf norm), 1, or 2\"))\n    end\n    ccall((@cholmod_name(\"norm_dense\"), :libcholmod), Cdouble,\n        (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n          D, p, common_struct[Threads.threadid()])\nend\n\n### cholmod_check.h ###\nfunction check_dense(A::Dense{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"check_dense\"), :libcholmod), Cint,\n          (Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n          pointer(A), common_struct[Threads.threadid()]) != 0\nend\n\n# Non-Dense wrappers\n### cholmod_core.h ###\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer,\n        sorted::Bool, packed::Bool, stype::Integer, ::Type{Tv}) where {Tv<:VTypes}\n    Sparse(ccall((@cholmod_name(\"allocate_sparse\"), :libcholmod),\n            Ptr{C_Sparse{Tv}},\n                (Csize_t, Csize_t, Csize_t, Cint,\n                 Cint, Cint, Cint, Ptr{Cvoid}),\n                nrow, ncol, nzmax, sorted,\n                packed, stype, xtyp(Tv), common_struct[Threads.threadid()]))\nend\n\nfunction free!(ptr::Ptr{C_Sparse{Tv}}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"free_sparse\"), :libcholmod), Cint,\n            (Ref{Ptr{C_Sparse{Tv}}}, Ptr{UInt8}),\n                ptr, common_struct[Threads.threadid()])\nend\n\nfunction free!(ptr::Ptr{C_Factor{Tv}}) where Tv<:VTypes\n    # Warning! Important that finalizer doesn't modify the global Common struct.\n    @isok ccall((@cholmod_name(\"free_factor\"), :libcholmod), Cint,\n            (Ref{Ptr{C_Factor{Tv}}}, Ptr{Cvoid}),\n                ptr, common_struct[Threads.threadid()])\nend\n\nfunction aat(A::Sparse{Tv}, fset::Vector{SuiteSparse_long}, mode::Integer) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"aat\"), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Csize_t, Cint, Ptr{UInt8}),\n                A, fset, length(fset), mode, common_struct[Threads.threadid()]))\nend\n\nfunction sparse_to_dense(A::Sparse{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"sparse_to_dense\"),:libcholmod),\n        Ptr{C_Dense{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, common_struct[Threads.threadid()]))\nend\nfunction dense_to_sparse(D::Dense{Tv}, ::Type{SuiteSparse_long}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"dense_to_sparse\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n                D, true, common_struct[Threads.threadid()]))\nend\n\nfunction factor_to_sparse!(F::Factor{Tv}) where Tv<:VTypes\n    ss = unsafe_load(pointer(F))\n    ss.xtype == PATTERN && throw(CHOLMODException(\"only numeric factors are supported\"))\n    Sparse(ccall((@cholmod_name(\"factor_to_sparse\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                F, common_struct[Threads.threadid()]))\nend\n\nfunction change_factor!(F::Factor{Tv}, to_ll::Bool, to_super::Bool, to_packed::Bool,\n                        to_monotonic::Bool) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"change_factor\"),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                xtyp(Tv), to_ll, to_super, to_packed, to_monotonic, F, common_struct[Threads.threadid()])\nend\n\nfunction check_sparse(A::Sparse{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"check_sparse\"),:libcholmod), Cint,\n          (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n           A, common_struct[Threads.threadid()]) != 0\nend\n\nfunction check_factor(F::Factor{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"check_factor\"),:libcholmod), Cint,\n          (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n           F, common_struct[Threads.threadid()]) != 0\nend\n\nfunction nnz(A::Sparse{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"nnz\"),:libcholmod), Int,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, common_struct[Threads.threadid()])\nend\n\nfunction speye(m::Integer, n::Integer, ::Type{Tv}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"speye\"), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common_struct[Threads.threadid()]))\nend\n\nfunction spzeros(m::Integer, n::Integer, nzmax::Integer, ::Type{Tv}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"spzeros\"), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Csize_t, Cint, Ptr{UInt8}),\n             m, n, nzmax, xtyp(Tv), common_struct[Threads.threadid()]))\nend\n\nfunction transpose_(A::Sparse{Tv}, values::Integer) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"transpose\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                A, values, common_struct[Threads.threadid()]))\nend\n\nfunction copy(F::Factor{Tv}) where Tv<:VTypes\n    Factor(ccall((@cholmod_name(\"copy_factor\"),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                F, common_struct[Threads.threadid()]))\nend\nfunction copy(A::Sparse{Tv}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"copy_sparse\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, common_struct[Threads.threadid()]))\nend\nfunction copy(A::Sparse{Tv}, stype::Integer, mode::Integer) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"copy\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Cint, Ptr{UInt8}),\n                A, stype, mode, common_struct[Threads.threadid()]))\nend\n\n### cholmod_check.h ###\nfunction print_sparse(A::Sparse{Tv}, name::String) where Tv<:VTypes\n    isascii(name) || error(\"non-ASCII name: $name\")\n    set_print_level(common_struct[Threads.threadid()], 3)\n    @isok ccall((@cholmod_name(\"print_sparse\"),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                 A, name, common_struct[Threads.threadid()])\n    nothing\nend\nfunction print_factor(F::Factor{Tv}, name::String) where Tv<:VTypes\n    set_print_level(common_struct[Threads.threadid()], 3)\n    @isok ccall((@cholmod_name(\"print_factor\"),:libcholmod), Cint,\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                F, name, common_struct[Threads.threadid()])\n    nothing\nend\n\n### cholmod_matrixops.h ###\nfunction ssmult(A::Sparse{Tv}, B::Sparse{Tv}, stype::Integer,\n        values::Bool, sorted::Bool) where Tv<:VRealTypes\n    lA = unsafe_load(pointer(A))\n    lB = unsafe_load(pointer(B))\n    if lA.ncol != lB.nrow\n        throw(DimensionMismatch(\"inner matrix dimensions do not fit\"))\n    end\n    Sparse(ccall((@cholmod_name(\"ssmult\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Cint,\n                Cint, Ptr{UInt8}),\n             A, B, stype, values,\n                sorted, common_struct[Threads.threadid()]))\nend\n\nfunction norm_sparse(A::Sparse{Tv}, norm::Integer) where Tv<:VTypes\n    if norm != 0 && norm != 1\n        throw(ArgumentError(\"norm argument must be either 0 or 1\"))\n    end\n    ccall((@cholmod_name(\"norm_sparse\"), :libcholmod), Cdouble,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                A, norm, common_struct[Threads.threadid()])\nend\n\nfunction horzcat(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"horzcat\"), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n             A, B, values, common_struct[Threads.threadid()]))\nend\n\nfunction scale!(S::Dense{Tv}, scale::Integer, A::Sparse{Tv}) where Tv<:VRealTypes\n    sS = unsafe_load(pointer(S))\n    sA = unsafe_load(pointer(A))\n    if sS.ncol != 1 && sS.nrow != 1\n        throw(DimensionMismatch(\"first argument must be a vector\"))\n    end\n    if scale == SCALAR && sS.nrow != 1\n        throw(DimensionMismatch(\"scaling argument must have length one\"))\n    elseif scale == ROW && sS.nrow*sS.ncol != sA.nrow\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), \" *\n            \"but matrix has $(sA.nrow) rows.\"))\n    elseif scale == COL && sS.nrow*sS.ncol != sA.ncol\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), \" *\n            \"but matrix has $(sA.ncol) columns\"))\n    elseif scale == SYM\n        if sA.nrow != sA.ncol\n            throw(DimensionMismatch(\"matrix must be square\"))\n        elseif sS.nrow*sS.ncol != sA.nrow\n            throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), \" *\n                \"but matrix has $(sA.ncol) columns and rows\"))\n        end\n    end\n\n    sA = unsafe_load(pointer(A))\n    @isok ccall((@cholmod_name(\"scale\"),:libcholmod), Cint,\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                S, scale, A, common_struct[Threads.threadid()])\n    A\nend\n\nfunction sdmult!(A::Sparse{Tv}, transpose::Bool,\n        \u03b1::Number, \u03b2::Number, X::Dense{Tv}, Y::Dense{Tv}) where Tv<:VTypes\n    m, n = size(A)\n    nc = transpose ? m : n\n    nr = transpose ? n : m\n    if nc != size(X, 1)\n        throw(DimensionMismatch(\"incompatible dimensions, $nc and $(size(X,1))\"))\n    end\n    @isok ccall((@cholmod_name(\"sdmult\"),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint,\n             Ref{ComplexF64}, Ref{ComplexF64},\n             Ptr{C_Dense{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                A, transpose, \u03b1, \u03b2, X, Y, common_struct[Threads.threadid()])\n    Y\nend\n\nfunction vertcat(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"vertcat\"), :libcholmod),\n            Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                A, B, values, common_struct[Threads.threadid()]))\nend\n\nfunction symmetry(A::Sparse{Tv}, option::Integer) where Tv<:VTypes\n    xmatched = Ref{SuiteSparse_long}()\n    pmatched = Ref{SuiteSparse_long}()\n    nzoffdiag = Ref{SuiteSparse_long}()\n    nzdiag = Ref{SuiteSparse_long}()\n    rv = ccall((@cholmod_name(\"symmetry\"), :libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long},\n                Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long}, Ptr{UInt8}),\n                    A, option, xmatched, pmatched,\n                        nzoffdiag, nzdiag, common_struct[Threads.threadid()])\n    rv, xmatched[], pmatched[], nzoffdiag[], nzdiag[]\nend\n\n# cholmod_cholesky.h\n# For analyze, analyze_p, and factorize_p!, the Common argument must be\n# supplied in order to control if the factorization is LLt or LDLt\nfunction analyze(A::Sparse{Tv}, cmmn::Vector{UInt8}) where Tv<:VTypes\n    Factor(ccall((@cholmod_name(\"analyze\"),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, cmmn))\nend\nfunction analyze_p(A::Sparse{Tv}, perm::Vector{SuiteSparse_long},\n                   cmmn::Vector{UInt8}) where Tv<:VTypes\n    length(perm) != size(A,1) && throw(BoundsError())\n    Factor(ccall((@cholmod_name(\"analyze_p\"),:libcholmod),\n            Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long},\n                Csize_t, Ptr{UInt8}),\n                A, perm, C_NULL, 0, cmmn))\nend\nfunction factorize!(A::Sparse{Tv}, F::Factor{Tv}, cmmn::Vector{UInt8}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"factorize\"),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            A, F, cmmn)\n    F\nend\nfunction factorize_p!(A::Sparse{Tv}, \u03b2::Real, F::Factor{Tv}, cmmn::Vector{UInt8}) where Tv<:VTypes\n    # note that \u03b2 is passed as a complex number (double beta[2]),\n    # but the CHOLMOD manual says that only beta[0] (real part) is used\n    @isok ccall((@cholmod_name(\"factorize_p\"),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ref{ComplexF64}, Ptr{SuiteSparse_long}, Csize_t,\n         Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            A, \u03b2, C_NULL, 0, F, cmmn)\n    F\nend\n\nfunction solve(sys::Integer, F::Factor{Tv}, B::Dense{Tv}) where Tv<:VTypes\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. \" *\n            \"LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    if !issuccess(F)\n        s = unsafe_load(pointer(F))\n        if s.is_ll == 1\n            throw(LinearAlgebra.PosDefException(s.minor))\n        else\n            throw(LinearAlgebra.ZeroPivotException(s.minor))\n        end\n    end\n    Dense(ccall((@cholmod_name(\"solve\"),:libcholmod), Ptr{C_Dense{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                sys, F, B, common_struct[Threads.threadid()]))\nend\n\nfunction spsolve(sys::Integer, F::Factor{Tv}, B::Sparse{Tv}) where Tv<:VTypes\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. \" *\n            \"LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    Sparse(ccall((@cholmod_name(\"spsolve\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                sys, F, B, common_struct[Threads.threadid()]))\nend\n\n# Autodetects the types\nfunction read_sparse(file::Libc.FILE, ::Type{SuiteSparse_long})\n    ptr = ccall((@cholmod_name(\"read_sparse\"), :libcholmod),\n        Ptr{C_Sparse{Cvoid}},\n            (Ptr{Cvoid}, Ptr{UInt8}),\n                file.ptr, common_struct[Threads.threadid()])\n    if ptr == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed. Check that input file is valid.\"))\n    end\n    Sparse(ptr)\nend\n\nfunction read_sparse(file::IO, T)\n    cfile = Libc.FILE(file)\n    try return read_sparse(cfile, T)\n    finally close(cfile)\n    end\nend\n\nfunction get_perm(F::Factor)\n    s = unsafe_load(pointer(F))\n    p = unsafe_wrap(Array, s.Perm, s.n, own = false)\n    p .+ 1\nend\nget_perm(FC::FactorComponent) = get_perm(Factor(FC))\n\n#########################\n# High level interfaces #\n#########################\n\n# Conversion/construction\nfunction Dense{T}(A::StridedVecOrMat) where T<:VTypes\n    d = allocate_dense(size(A, 1), size(A, 2), stride(A, 2), T)\n    GC.@preserve d begin\n        s = unsafe_load(pointer(d))\n        for (i, c) in enumerate(eachindex(A))\n            unsafe_store!(s.x, A[c], i)\n        end\n    end\n    d\nend\nfunction Dense{T}(A::Union{Adjoint{<:Any, <:StridedVecOrMat}, Transpose{<:Any, <:StridedVecOrMat}}) where T<:VTypes\n    d = allocate_dense(size(A, 1), size(A, 2), size(A, 1), T)\n    GC.@preserve d begin\n        s = unsafe_load(pointer(d))\n        for (i, c) in enumerate(eachindex(A))\n            unsafe_store!(s.x, A[c], i)\n        end\n    end\n    d\nend\nfunction Dense(A::Union{StridedVecOrMat, Adjoint{<:Any, <:StridedVecOrMat}, Transpose{<:Any, <:StridedVecOrMat}})\n    T = promote_type(eltype(A), Float64)\n    return Dense{T}(A)\nend\nDense(A::Sparse) = sparse_to_dense(A)\n\n# This constructior assumes zero based colptr and rowval\nfunction Sparse(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long}, rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{Tv}, stype) where Tv<:VTypes\n    # checks\n    ## length of input\n    if length(colptr0) <= n\n        throw(ArgumentError(\"length of colptr0 must be at least n + 1 = $(n + 1) but was $(length(colptr0))\"))\n    end\n    if colptr0[n + 1] > length(rowval0)\n        throw(ArgumentError(\"length of rowval0 is $(length(rowval0)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    if colptr0[n + 1] > length(nzval)\n        throw(ArgumentError(\"length of nzval is $(length(nzval)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    ## columns are sorted\n    iss = true\n    for i = 2:length(colptr0)\n        if !issorted(view(rowval0, colptr0[i - 1] + 1:colptr0[i]))\n            iss = false\n            break\n        end\n    end\n\n    o = allocate_sparse(m, n, colptr0[n + 1], iss, true, stype, Tv)\n    s = unsafe_load(pointer(o))\n\n    unsafe_copyto!(s.p, pointer(colptr0), n + 1)\n    unsafe_copyto!(s.i, pointer(rowval0), colptr0[n + 1])\n    unsafe_copyto!(s.x, pointer(nzval) , colptr0[n + 1])\n\n    @isok check_sparse(o)\n\n    return o\nend\n\nfunction Sparse(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long},\n        rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{<:VTypes})\n    o = Sparse(m, n, colptr0, rowval0, nzval, 0)\n\n    # sort indices\n    sort!(o)\n\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\n\nfunction Sparse{Tv}(A::SparseMatrixCSC, stype::Integer) where Tv<:VTypes\n    ## Check length of input. This should never fail but see #20024\n    if length(getcolptr(A)) <= size(A, 2)\n        throw(ArgumentError(\"length of colptr must be at least size(A,2) + 1 = $(size(A, 2) + 1) but was $(length(getcolptr(A)))\"))\n    end\n    if nnz(A) > length(rowvals(A))\n        throw(ArgumentError(\"length of rowval is $(length(rowvals(A))) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n    if nnz(A) > length(nonzeros(A))\n        throw(ArgumentError(\"length of nzval is $(length(nonzeros(A))) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n\n    o = allocate_sparse(size(A, 1), size(A, 2), nnz(A), true, true, stype, Tv)\n    s = unsafe_load(pointer(o))\n    for i = 1:(size(A, 2) + 1)\n        unsafe_store!(s.p, getcolptr(A)[i] - 1, i)\n    end\n    for i = 1:nnz(A)\n        unsafe_store!(s.i, rowvals(A)[i] - 1, i)\n    end\n    if Tv <: Complex && stype != 0\n        # Need to remove any non real elements in the diagonal because, in contrast to\n        # BLAS/LAPACK these are not ignored by CHOLMOD. If even tiny imaginary parts are\n        # present CHOLMOD will fail with a non-positive definite/zero pivot error.\n        for j = 1:size(A, 2)\n            for ip = getcolptr(A)[j]:getcolptr(A)[j + 1] - 1\n                v = nonzeros(A)[ip]\n                unsafe_store!(s.x, rowvals(A)[ip] == j ? Complex(real(v)) : v, ip)\n            end\n        end\n    elseif Tv == eltype(nonzeros(A))\n        unsafe_copyto!(s.x, pointer(nonzeros(A)), nnz(A))\n    else\n        for i = 1:nnz(A)\n            unsafe_store!(s.x, nonzeros(A)[i], i)\n        end\n    end\n\n    @isok check_sparse(o)\n\n    return o\nend\n\n# handle promotion\nfunction Sparse(A::SparseMatrixCSC{Tv,SuiteSparse_long}, stype::Integer) where {Tv}\n    T = promote_type(Tv, Float64)\n    return Sparse{T}(A, stype)\nend\n\n# convert SparseVectors into CHOLMOD Sparse types through a mx1 CSC matrix\nSparse(A::SparseVector) = Sparse(SparseMatrixCSC(A))\nfunction Sparse(A::SparseMatrixCSC)\n    o = Sparse(A, 0)\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\n\nSparse(A::Symmetric{Tv, SparseMatrixCSC{Tv,Ti}}) where {Tv<:Real, Ti} =\n    Sparse(A.data, A.uplo == 'L' ? -1 : 1)\nSparse(A::Hermitian{Tv,SparseMatrixCSC{Tv,Ti}}) where {Tv, Ti} =\n    Sparse(A.data, A.uplo == 'L' ? -1 : 1)\n\nSparse(A::Dense) = dense_to_sparse(A, SuiteSparse_long)\nSparse(L::Factor) = factor_to_sparse!(copy(L))\nfunction Sparse(filename::String)\n    open(filename) do f\n        return read_sparse(f, SuiteSparse_long)\n    end\nend\n\n## conversion back to base Julia types\nfunction Matrix{T}(D::Dense{T}) where T\n    s = unsafe_load(pointer(D))\n    a = Matrix{T}(undef, s.nrow, s.ncol)\n    copyto!(a, D)\nend\n\nBase.copyto!(dest::Base.PermutedDimsArrays.PermutedDimsArray, src::Dense) = _copy!(dest, src) # ambig\nBase.copyto!(dest::Dense{T}, D::Dense{T}) where {T<:VTypes} = _copy!(dest, D)\nBase.copyto!(dest::AbstractArray{T}, D::Dense{T}) where {T<:VTypes} = _copy!(dest, D)\nBase.copyto!(dest::AbstractArray{T,2}, D::Dense{T}) where {T<:VTypes} = _copy!(dest, D)\nBase.copyto!(dest::AbstractArray, D::Dense) = _copy!(dest, D)\n\nfunction _copy!(dest::AbstractArray, D::Dense)\n    require_one_based_indexing(dest)\n    s = unsafe_load(pointer(D))\n    n = s.nrow*s.ncol\n    n <= length(dest) || throw(BoundsError(dest, n))\n    if s.d == s.nrow && isa(dest, Array)\n        unsafe_copyto!(pointer(dest), s.x, s.d*s.ncol)\n    else\n        k = 0\n        for j = 1:s.ncol\n            for i = 1:s.nrow\n                dest[k+=1] = unsafe_load(s.x, i + (j - 1)*s.d)\n            end\n        end\n    end\n    dest\nend\nMatrix(D::Dense{T}) where {T} = Matrix{T}(D)\nfunction Vector{T}(D::Dense{T}) where T\n    if size(D, 2) > 1\n        throw(DimensionMismatch(\"input must be a vector but had $(size(D, 2)) columns\"))\n    end\n    copyto!(Vector{T}(undef, size(D, 1)), D)\nend\nVector(D::Dense{T}) where {T} = Vector{T}(D)\n\nfunction SparseMatrixCSC{Tv,SuiteSparse_long}(A::Sparse{Tv}) where Tv\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        throw(ArgumentError(\"matrix has stype != 0. Convert to matrix \" *\n            \"with stype == 0 before converting to SparseMatrixCSC\"))\n    end\n\n    B = SparseMatrixCSC(s.nrow, s.ncol,\n        increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), own = false)),\n        increment(unsafe_wrap(Array, s.i, (s.nzmax,), own = false)),\n        copy(unsafe_wrap(Array, s.x, (s.nzmax,), own = false)))\n\n    if s.sorted == 0\n        return SparseArrays.sortSparseMatrixCSC!(B)\n    else\n        return B\n    end\nend\n\nfunction Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}(A::Sparse{Float64})\n    s = unsafe_load(pointer(A))\n    if !issymmetric(A)\n        throw(ArgumentError(\"matrix is not symmetric\"))\n    end\n\n    B = Symmetric(SparseMatrixCSC(s.nrow, s.ncol,\n        increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), own = false)),\n        increment(unsafe_wrap(Array, s.i, (s.nzmax,), own = false)),\n        copy(unsafe_wrap(Array, s.x, (s.nzmax,), own = false))), s.stype > 0 ? :U : :L)\n\n    if s.sorted == 0\n        return SparseArrays.sortSparseMatrixCSC!(B.data)\n    else\n        return B\n    end\nend\nconvert(T::Type{Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}}, A::Sparse{Float64}) = T(A)\n\nfunction Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}(A::Sparse{Tv}) where Tv<:VTypes\n    s = unsafe_load(pointer(A))\n    if !ishermitian(A)\n        throw(ArgumentError(\"matrix is not Hermitian\"))\n    end\n\n    B = Hermitian(SparseMatrixCSC(s.nrow, s.ncol,\n        increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), own = false)),\n        increment(unsafe_wrap(Array, s.i, (s.nzmax,), own = false)),\n        copy(unsafe_wrap(Array, s.x, (s.nzmax,), own = false))), s.stype > 0 ? :U : :L)\n\n    if s.sorted == 0\n        return SparseArrays.sortSparseMatrixCSC!(B.data)\n    else\n        return B\n    end\nend\nconvert(T::Type{Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}}, A::Sparse{Tv}) where {Tv<:VTypes} = T(A)\n\nfunction sparse(A::Sparse{Float64}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(pointer(A))\n    if s.stype == 0\n        return SparseMatrixCSC{Float64,SuiteSparse_long}(A)\n    end\n    return Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}(A)\nend\nfunction sparse(A::Sparse{ComplexF64}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(pointer(A))\n    if s.stype == 0\n        return SparseMatrixCSC{ComplexF64,SuiteSparse_long}(A)\n    end\n    return Hermitian{ComplexF64,SparseMatrixCSC{ComplexF64,SuiteSparse_long}}(A)\nend\nfunction sparse(F::Factor)\n    s = unsafe_load(pointer(F))\n    if s.is_ll != 0\n        L = Sparse(F)\n        A = sparse(L*L')\n    else\n        LD = sparse(F.LD)\n        L, d = getLd!(LD)\n        A = (L * Diagonal(d)) * L'\n    end\n    SparseArrays.sortSparseMatrixCSC!(A)\n    p = get_perm(F)\n    if p != [1:s.n;]\n        pinv = Vector{Int}(undef, length(p))\n        for k = 1:length(p)\n            pinv[p[k]] = k\n        end\n        A = A[pinv,pinv]\n    end\n    A\nend\n\nsparse(D::Dense) = sparse(Sparse(D))\n\nfunction sparse(FC::FactorComponent{Tv,:L}) where Tv\n    F = Factor(FC)\n    s = unsafe_load(pointer(F))\n    if s.is_ll == 0\n        throw(CHOLMODException(\"sparse: supported only for :LD on LDLt factorizations\"))\n    end\n    sparse(Sparse(F))\nend\nsparse(FC::FactorComponent{Tv,:LD}) where {Tv} = sparse(Sparse(Factor(FC)))\n\n# Calculate the offset into the stype field of the cholmod_sparse_struct and\n# change the value\nlet offset = fieldoffset(C_Sparse{Float64}, findfirst(name -> name === :stype, fieldnames(C_Sparse{Float64}))::Int)\n    global change_stype!\n    function change_stype!(A::Sparse, i::Integer)\n        unsafe_store!(convert(Ptr{Cint}, pointer(A)), i, div(offset, 4) + 1)\n        return A\n    end\nend\n\nfree!(A::Dense)  = free!(pointer(A))\nfree!(A::Sparse) = free!(pointer(A))\nfree!(F::Factor) = free!(pointer(F))\n\neltype(::Type{Dense{T}}) where {T<:VTypes} = T\neltype(::Type{Factor{T}}) where {T<:VTypes} = T\neltype(::Type{Sparse{T}}) where {T<:VTypes} = T\n\nnnz(F::Factor) = nnz(Sparse(F))\n\nfunction show(io::IO, F::Factor)\n    println(io, typeof(F))\n    showfactor(io, F)\nend\n\nfunction show(io::IO, FC::FactorComponent)\n    println(io, typeof(FC))\n    showfactor(io, Factor(FC))\nend\n\nfunction showfactor(io::IO, F::Factor)\n    s = unsafe_load(pointer(F))\n    print(io, \"\"\"\n        type:    $(s.is_ll!=0 ? \"LLt\" : \"LDLt\")\n        method:  $(s.is_super!=0 ? \"supernodal\" : \"simplicial\")\n        maxnnz:  $(Int(s.nzmax))\n        nnz:     $(nnz(F))\n        success: $(s.minor == size(F, 1))\n        \"\"\")\nend\n\n# getindex not defined for these, so don't use the normal array printer\nshow(io::IO, ::MIME\"text/plain\", FC::FactorComponent) = show(io, FC)\nshow(io::IO, ::MIME\"text/plain\", F::Factor) = show(io, F)\n\nisvalid(A::Dense) = check_dense(A)\nisvalid(A::Sparse) = check_sparse(A)\nisvalid(A::Factor) = check_factor(A)\n\nfunction size(A::Union{Dense,Sparse})\n    s = unsafe_load(pointer(A))\n    return (Int(s.nrow), Int(s.ncol))\nend\nfunction size(F::Factor, i::Integer)\n    if i < 1\n        throw(ArgumentError(\"dimension must be positive\"))\n    end\n    s = unsafe_load(pointer(F))\n    if i <= 2\n        return Int(s.n)\n    end\n    return 1\nend\nsize(F::Factor) = (size(F, 1), size(F, 2))\naxes(A::Union{Dense,Sparse,Factor}) = map(Base.OneTo, size(A))\n\nIndexStyle(::Dense) = IndexLinear()\n\nsize(FC::FactorComponent, i::Integer) = size(FC.F, i)\nsize(FC::FactorComponent) = size(FC.F)\n\nadjoint(FC::FactorComponent{Tv,:L}) where {Tv} = FactorComponent{Tv,:U}(FC.F)\nadjoint(FC::FactorComponent{Tv,:U}) where {Tv} = FactorComponent{Tv,:L}(FC.F)\nadjoint(FC::FactorComponent{Tv,:PtL}) where {Tv} = FactorComponent{Tv,:UP}(FC.F)\nadjoint(FC::FactorComponent{Tv,:UP}) where {Tv} = FactorComponent{Tv,:PtL}(FC.F)\nadjoint(FC::FactorComponent{Tv,:D}) where {Tv} = FC\nadjoint(FC::FactorComponent{Tv,:LD}) where {Tv} = FactorComponent{Tv,:DU}(FC.F)\nadjoint(FC::FactorComponent{Tv,:DU}) where {Tv} = FactorComponent{Tv,:LD}(FC.F)\nadjoint(FC::FactorComponent{Tv,:PtLD}) where {Tv} = FactorComponent{Tv,:DUP}(FC.F)\nadjoint(FC::FactorComponent{Tv,:DUP}) where {Tv} = FactorComponent{Tv,:PtLD}(FC.F)\n\nfunction getindex(A::Dense, i::Integer)\n    s = unsafe_load(pointer(A))\n    0 < i <= s.nrow*s.ncol || throw(BoundsError())\n    unsafe_load(s.x, i)\nend\n\nIndexStyle(::Sparse) = IndexCartesian()\nfunction getindex(A::Sparse{T}, i0::Integer, i1::Integer) where T\n    s = unsafe_load(pointer(A))\n    !(1 <= i0 <= s.nrow && 1 <= i1 <= s.ncol) && throw(BoundsError())\n    s.stype < 0 && i0 < i1 && return conj(A[i1,i0])\n    s.stype > 0 && i0 > i1 && return conj(A[i1,i0])\n\n    r1 = Int(unsafe_load(s.p, i1) + 1)\n    r2 = Int(unsafe_load(s.p, i1 + 1))\n    (r1 > r2) && return zero(T)\n    r1 = Int(searchsortedfirst(unsafe_wrap(Array, s.i, (s.nzmax,), own = false),\n        i0 - 1, r1, r2, Base.Order.Forward))\n    ((r1 > r2) || (unsafe_load(s.i, r1) + 1 != i0)) ? zero(T) : unsafe_load(s.x, r1)\nend\n\n@inline function getproperty(F::Factor, sym::Symbol)\n    if sym === :p\n        return get_perm(F)\n    elseif sym === :ptr\n        return getfield(F, :ptr)\n    else\n        return FactorComponent(F, sym)\n    end\nend\n\nfunction getLd!(S::SparseMatrixCSC)\n    d = Vector{eltype(S)}(undef, size(S, 1))\n    fill!(d, 0)\n    col = 1\n    for k = 1:nnz(S)\n        while k >= getcolptr(S)[col+1]\n            col += 1\n        end\n        if rowvals(S)[k] == col\n            d[col] = nonzeros(S)[k]\n            nonzeros(S)[k] = 1\n        end\n    end\n    S, d\nend\n\n## Multiplication\n(*)(A::Sparse, B::Sparse) = ssmult(A, B, 0, true, true)\n(*)(A::Sparse, B::Dense) = sdmult!(A, false, 1., 0., B, zeros(size(A, 1), size(B, 2)))\n(*)(A::Sparse, B::VecOrMat) = (*)(A, Dense(B))\n\nfunction *(A::Sparse{Tv}, adjB::Adjoint{Tv,Sparse{Tv}}) where Tv<:VRealTypes\n    B = adjB.parent\n    if A !== B\n        aa1 = transpose_(B, 2)\n        ## result of ssmult will have stype==0, contain numerical values and be sorted\n        return ssmult(A, aa1, 0, true, true)\n    end\n\n    ## The A*A' case is handled by cholmod_aat. This routine requires\n    ## A->stype == 0 (storage of upper and lower parts). If necessary\n    ## the matrix A is first converted to stype == 0\n    s = unsafe_load(pointer(A))\n    fset = s.ncol == 0 ? SuiteSparse_long[] : SuiteSparse_long[0:s.ncol-1;]\n    if s.stype != 0\n        aa1 = copy(A, 0, 1)\n        return aat(aa1, fset, 1)\n    else\n        return aat(A, fset, 1)\n    end\nend\n\nfunction *(adjA::Adjoint{<:Any,<:Sparse}, B::Sparse)\n    A = adjA.parent\n    aa1 = transpose_(A, 2)\n    if A === B\n        return *(aa1, adjoint(aa1))\n    end\n    ## result of ssmult will have stype==0, contain numerical values and be sorted\n    return ssmult(aa1, B, 0, true, true)\nend\n\n*(adjA::Adjoint{<:Any,<:Sparse}, B::Dense) =\n    (A = adjA.parent; sdmult!(A, true, 1., 0., B, zeros(size(A, 2), size(B, 2))))\n*(adjA::Adjoint{<:Any,<:Sparse}, B::VecOrMat) =\n    (A = adjA.parent; *(adjoint(A), Dense(B)))\n\n\n## Factorization methods\n\n## Compute that symbolic factorization only\nfunction fact_(A::Sparse{<:VTypes}, cm::Array{UInt8};\n    perm::Union{Nothing,AbstractVector{SuiteSparse_long}}=nothing,\n    postorder::Bool=true, userperm_only::Bool=true)\n\n    sA = unsafe_load(pointer(A))\n    sA.stype == 0 && throw(ArgumentError(\"sparse matrix is not symmetric/Hermitian\"))\n\n    if !postorder\n        unsafe_store!(common_postorder[Threads.threadid()], 0)\n    end\n\n    if perm === nothing || isempty(perm) # TODO: deprecate empty perm\n        F = analyze(A, cm)\n    else # user permutation provided\n        if userperm_only # use perm even if it is worse than AMD\n            unsafe_store!(common_nmethods[Threads.threadid()], 1)\n        end\n        F = analyze_p(A, SuiteSparse_long[p-1 for p in perm], cm)\n    end\n\n    return F\nend\n\nfunction cholesky!(F::Factor{Tv}, A::Sparse{Tv};\n                   shift::Real=0.0, check::Bool = true) where Tv\n    # Makes it an LLt\n    unsafe_store!(common_final_ll[Threads.threadid()], 1)\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, common_struct[Threads.threadid()])\n\n    check && (issuccess(F) || throw(LinearAlgebra.PosDefException(1)))\n    return F\nend\n\n\"\"\"\n    cholesky!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -> CHOLMOD.Factor\n\nCompute the Cholesky (``LL'``) factorization of `A`, reusing the symbolic\nfactorization `F`. `A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/\n[`Hermitian`](@ref) view of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\nSee also [`cholesky`](@ref).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\"\"\"\ncholesky!(F::Factor, A::Union{SparseMatrixCSC{T},\n          SparseMatrixCSC{Complex{T}},\n          Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n          Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n          Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n          shift = 0.0, check::Bool = true) where {T<:Real} =\n    cholesky!(F, Sparse(A); shift = shift, check = check)\n\nfunction cholesky(A::Sparse; shift::Real=0.0, check::Bool = true,\n    perm::Union{Nothing,AbstractVector{SuiteSparse_long}}=nothing)\n\n    cm = defaults(common_struct[Threads.threadid()])\n    set_print_level(cm, 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    cholesky!(F, A; shift = shift, check = check)\n\n    return F\nend\n\n\"\"\"\n    cholesky(A::SparseMatrixCSC; shift = 0.0, check = true, perm = nothing) -> CHOLMOD.Factor\n\nCompute the Cholesky factorization of a sparse positive definite matrix `A`.\n`A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/[`Hermitian`](@ref)\nview of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nIf `perm` is not given, a fill-reducing permutation is used.\n`F = cholesky(A)` is most frequently used to solve systems of equations with `F\\\\b`,\nbut also the methods [`diag`](@ref), [`det`](@ref), and\n[`logdet`](@ref) are defined for `F`.\nYou can also extract individual factors from `F`, using `F.L`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation,\nit's typically preferable to extract \"combined\" factors like `PtL = F.PtL`\n(the equivalent of `P'*L`) and `LtP = F.UP` (the equivalent of `L'*P`).\n\nWhen `check = true`, an error is thrown if the decomposition fails.\nWhen `check = false`, responsibility for checking the decomposition's\nvalidity (via [`issuccess`](@ref)) lies with the user.\n\nSetting the optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is provided,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n# Examples\n\nIn the following example, the fill-reducing permutation used is `[3, 2, 1]`.\nIf `perm` is set to `1:3` to enforce no permutation, the number of nonzero\nelements in the factor is 6.\n```jldoctest\njulia> A = [2 1 1; 1 2 0; 1 0 2]\n3\u00d73 Matrix{Int64}:\n 2  1  1\n 1  2  0\n 1  0  2\n\njulia> C = cholesky(sparse(A))\nSuiteSparse.CHOLMOD.Factor{Float64}\ntype:    LLt\nmethod:  simplicial\nmaxnnz:  5\nnnz:     5\nsuccess: true\n\njulia> C.p\n3-element Vector{Int64}:\n 3\n 2\n 1\n\njulia> L = sparse(C.L);\n\njulia> Matrix(L)\n3\u00d73 Matrix{Float64}:\n 1.41421   0.0       0.0\n 0.0       1.41421   0.0\n 0.707107  0.707107  1.0\n\njulia> L * L' \u2248 A[C.p, C.p]\ntrue\n\njulia> P = sparse(1:3, C.p, ones(3))\n3\u00d73 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n  \u22c5    \u22c5   1.0\n  \u22c5   1.0   \u22c5\n 1.0   \u22c5    \u22c5\n\njulia> P' * L * L' * P \u2248 A\ntrue\n\njulia> C = cholesky(sparse(A), perm=1:3)\nSuiteSparse.CHOLMOD.Factor{Float64}\ntype:    LLt\nmethod:  simplicial\nmaxnnz:  6\nnnz:     6\nsuccess: true\n\njulia> L = sparse(C.L);\n\njulia> Matrix(L)\n3\u00d73 Matrix{Float64}:\n 1.41421    0.0       0.0\n 0.707107   1.22474   0.0\n 0.707107  -0.408248  1.1547\n\njulia> L * L' \u2248 A\ntrue\n```\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\ncholesky(A::Union{SparseMatrixCSC{T}, SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) where {T<:Real} = cholesky(Sparse(A); kws...)\n\n\nfunction ldlt!(F::Factor{Tv}, A::Sparse{Tv};\n               shift::Real=0.0, check::Bool = true) where Tv\n    cm = defaults(common_struct[Threads.threadid()])\n    set_print_level(cm, 0)\n\n    # Makes it an LDLt\n    change_factor!(F, false, false, true, false)\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, cm)\n\n    check && (issuccess(F) || throw(LinearAlgebra.ZeroPivotException(1)))\n    return F\nend\n\n\"\"\"\n    ldlt!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of `A`, reusing the symbolic factorization `F`.\n`A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/[`Hermitian`](@ref)\nview of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\nSee also [`ldlt`](@ref).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\"\"\"\nldlt!(F::Factor, A::Union{SparseMatrixCSC{T},\n    SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    shift = 0.0, check::Bool = true) where {T<:Real} =\n    ldlt!(F, Sparse(A), shift = shift, check = check)\n\nfunction ldlt(A::Sparse; shift::Real=0.0, check::Bool = true,\n    perm::Union{Nothing,AbstractVector{SuiteSparse_long}}=nothing)\n\n    cm = defaults(common_struct[Threads.threadid()])\n    set_print_level(cm, 0)\n\n    # Makes it an LDLt\n    unsafe_store!(common_final_ll[Threads.threadid()], 0)\n    # Really make sure it's an LDLt by avoiding supernodal factorization\n    unsafe_store!(common_supernodal[Threads.threadid()], 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    ldlt!(F, A; shift = shift, check = check)\n\n    return F\nend\n\n\"\"\"\n    ldlt(A::SparseMatrixCSC; shift = 0.0, check = true, perm=nothing) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of a sparse matrix `A`.\n`A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/[`Hermitian`](@ref)\nview of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nA fill-reducing permutation is used. `F = ldlt(A)` is most frequently\nused to solve systems of equations `A*x = b` with `F\\\\b`. The returned\nfactorization object `F` also supports the methods [`diag`](@ref),\n[`det`](@ref), [`logdet`](@ref), and [`inv`](@ref).\nYou can extract individual factors from `F` using `F.L`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*D*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation, it is typically preferable to extract\n\"combined\" factors like `PtL = F.PtL` (the equivalent of\n`P'*L`) and `LtP = F.UP` (the equivalent of `L'*P`).\nThe complete list of supported factors is `:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP`.\n\nWhen `check = true`, an error is thrown if the decomposition fails.\nWhen `check = false`, responsibility for checking the decomposition's\nvalidity (via [`issuccess`](@ref)) lies with the user.\n\nSetting the optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is provided,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\nldlt(A::Union{SparseMatrixCSC{T},SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) where {T<:Real} = ldlt(Sparse(A); kws...)\n\n## Rank updates\n\n\"\"\"\n    lowrankupdowndate!(F::CHOLMOD.Factor, C::Sparse, update::Cint)\n\nUpdate an `LDLt` or `LLt` Factorization `F` of `A` to a factorization of `A \u00b1 C*C'`.\n\nIf sparsity preserving factorization is used, i.e. `L*L' == P*A*P'` then the new\nfactor will be `L*L' == P*A*P' + C'*C`\n\n`update`: `Cint(1)` for `A + CC'`, `Cint(0)` for `A - CC'`\n\"\"\"\nfunction lowrankupdowndate!(F::Factor{Tv}, C::Sparse{Tv}, update::Cint) where Tv<:VTypes\n    lF = unsafe_load(pointer(F))\n    lC = unsafe_load(pointer(C))\n    if lF.n != lC.nrow\n        throw(DimensionMismatch(\"matrix dimensions do not fit\"))\n    end\n    @isok ccall((@cholmod_name(\"updown\"), :libcholmod), Cint,\n        (Cint, Ptr{C_Sparse{Tv}}, Ptr{C_Factor{Tv}}, Ptr{Cvoid}),\n        update, C, F, common_struct[Threads.threadid()])\n    F\nend\n\n#Helper functions for rank updates\nlowrank_reorder(V::AbstractArray,p) = Sparse(sparse(V[p,:]))\nlowrank_reorder(V::AbstractSparseArray,p) = Sparse(V[p,:])\n\n\"\"\"\n    lowrankupdate!(F::CHOLMOD.Factor, C::AbstractArray)\n\nUpdate an `LDLt` or `LLt` Factorization `F` of `A` to a factorization of `A + C*C'`.\n\n`LLt` factorizations are converted to `LDLt`.\n\nSee also [`lowrankupdate`](@ref), [`lowrankdowndate`](@ref), [`lowrankdowndate!`](@ref).\n\"\"\"\nfunction lowrankupdate!(F::Factor{Tv}, V::AbstractArray{Tv}) where Tv<:VTypes\n    #Reorder and copy V to account for permutation\n    C = lowrank_reorder(V, get_perm(F))\n    lowrankupdowndate!(F, C, Cint(1))\nend\n\n\"\"\"\n    lowrankdowndate!(F::CHOLMOD.Factor, C::AbstractArray)\n\nUpdate an `LDLt` or `LLt` Factorization `F` of `A` to a factorization of `A - C*C'`.\n\n`LLt` factorizations are converted to `LDLt`.\n\nSee also [`lowrankdowndate`](@ref), [`lowrankupdate`](@ref), [`lowrankupdate!`](@ref).\n\"\"\"\nfunction lowrankdowndate!(F::Factor{Tv}, V::AbstractArray{Tv}) where Tv<:VTypes\n    #Reorder and copy V to account for permutation\n    C = lowrank_reorder(V, get_perm(F))\n    lowrankupdowndate!(F, C, Cint(0))\nend\n\n\"\"\"\n    lowrankupdate(F::CHOLMOD.Factor, C::AbstractArray) -> FF::CHOLMOD.Factor\n\nGet an `LDLt` Factorization of `A + C*C'` given an `LDLt` or `LLt` factorization `F` of `A`.\n\nThe returned factor is always an `LDLt` factorization.\n\nSee also [`lowrankupdate!`](@ref), [`lowrankdowndate`](@ref), [`lowrankdowndate!`](@ref).\n\"\"\"\nlowrankupdate(F::Factor{Tv}, V::AbstractArray{Tv}) where {Tv<:VTypes} =\n    lowrankupdate!(copy(F), V)\n\n\"\"\"\n    lowrankupdate(F::CHOLMOD.Factor, C::AbstractArray) -> FF::CHOLMOD.Factor\n\nGet an `LDLt` Factorization of `A + C*C'` given an `LDLt` or `LLt` factorization `F` of `A`.\n\nThe returned factor is always an `LDLt` factorization.\n\nSee also [`lowrankdowndate!`](@ref), [`lowrankupdate`](@ref), [`lowrankupdate!`](@ref).\n\"\"\"\nlowrankdowndate(F::Factor{Tv}, V::AbstractArray{Tv}) where {Tv<:VTypes} =\n    lowrankdowndate!(copy(F), V)\n\n## Solvers\n\nfor (T, f) in ((:Dense, :solve), (:Sparse, :spsolve))\n    @eval begin\n        # Solve Lx = b and L'x=b where A = L*L'\n        function (\\)(L::FactorComponent{T,:L}, B::$T) where T\n            ($f)(CHOLMOD_L, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:U}, B::$T) where T\n            ($f)(CHOLMOD_Lt, Factor(L), B)\n        end\n        # Solve PLx = b and L'P'x=b where A = P*L*L'*P'\n        function (\\)(L::FactorComponent{T,:PtL}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_L, F, ($f)(CHOLMOD_P, F, B)) # Confusingly, CHOLMOD_P solves P'x = b\n        end\n        function (\\)(L::FactorComponent{T,:UP}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_Lt, F, B))\n        end\n        # Solve various equations for A = L*D*L' and A = P*L*D*L'*P'\n        function (\\)(L::FactorComponent{T,:D}, B::$T) where T\n            ($f)(CHOLMOD_D, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:LD}, B::$T) where T\n            ($f)(CHOLMOD_LD, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:DU}, B::$T) where T\n            ($f)(CHOLMOD_DLt, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:PtLD}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_LD, F, ($f)(CHOLMOD_P, F, B))\n        end\n        function (\\)(L::FactorComponent{T,:DUP}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_DLt, F, B))\n        end\n    end\nend\n\nSparseVecOrMat{Tv,Ti} = Union{SparseVector{Tv,Ti}, SparseMatrixCSC{Tv,Ti}}\n\nfunction (\\)(L::FactorComponent, b::Vector)\n    reshape(Matrix(L\\Dense(b)), length(b))\nend\nfunction (\\)(L::FactorComponent, B::Matrix)\n    Matrix(L\\Dense(B))\nend\nfunction (\\)(L::FactorComponent, B::SparseVecOrMat)\n    sparse(L\\Sparse(B,0))\nend\n(\\)(L::FactorComponent, B::Adjoint{<:Any,<:SparseMatrixCSC}) = L \\ copy(B)\n(\\)(L::FactorComponent, B::Transpose{<:Any,<:SparseMatrixCSC}) = L \\ copy(B)\n\n\\(adjL::Adjoint{<:Any,<:FactorComponent}, B::Union{VecOrMat,SparseVecOrMat}) = (L = adjL.parent; adjoint(L)\\B)\n\n(\\)(L::Factor{T}, B::Dense{T}) where {T<:VTypes} = solve(CHOLMOD_A, L, B)\n# Explicit typevars are necessary to avoid ambiguities with defs in linalg/factorizations.jl\n# Likewise the two following explicit Vector and Matrix defs (rather than a single VecOrMat)\n(\\)(L::Factor{T}, B::Vector{Complex{T}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n(\\)(L::Factor{T}, B::Matrix{Complex{T}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n(\\)(L::Factor{T}, B::Adjoint{<:Any, <:Matrix{Complex{T}}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n(\\)(L::Factor{T}, B::Transpose{<:Any, <:Matrix{Complex{T}}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n\n(\\)(L::Factor{T}, b::StridedVector) where {T<:VTypes} = Vector(L\\Dense{T}(b))\n(\\)(L::Factor{T}, B::StridedMatrix) where {T<:VTypes} = Matrix(L\\Dense{T}(B))\n(\\)(L::Factor{T}, B::Adjoint{<:Any, <:StridedMatrix}) where {T<:VTypes} = Matrix(L\\Dense{T}(B))\n(\\)(L::Factor{T}, B::Transpose{<:Any, <:StridedMatrix}) where {T<:VTypes} = Matrix(L\\Dense{T}(B))\n\n(\\)(L::Factor, B::Sparse) = spsolve(CHOLMOD_A, L, B)\n# When right hand side is sparse, we have to ensure that the rhs is not marked as symmetric.\n(\\)(L::Factor, B::SparseMatrixCSC) = sparse(spsolve(CHOLMOD_A, L, Sparse(B, 0)))\n(\\)(L::Factor, B::Adjoint{<:Any,<:SparseMatrixCSC}) = L \\ copy(B)\n(\\)(L::Factor, B::Transpose{<:Any,<:SparseMatrixCSC}) = L \\ copy(B)\n(\\)(L::Factor, B::SparseVector) = sparse(spsolve(CHOLMOD_A, L, Sparse(B)))\n\n\\(adjL::Adjoint{<:Any,<:Factor}, B::Dense) = (L = adjL.parent; solve(CHOLMOD_A, L, B))\n\\(adjL::Adjoint{<:Any,<:Factor}, B::Sparse) = (L = adjL.parent; spsolve(CHOLMOD_A, L, B))\n\\(adjL::Adjoint{<:Any,<:Factor}, B::SparseVecOrMat) = (L = adjL.parent; \\(adjoint(L), Sparse(B)))\n\nfunction \\(adjL::Adjoint{<:Any,<:Factor}, b::StridedVector)\n    L = adjL.parent\n    return Vector(solve(CHOLMOD_A, L, Dense(b)))\nend\nfunction \\(adjL::Adjoint{<:Any,<:Factor}, B::StridedMatrix)\n    L = adjL.parent\n    return Matrix(solve(CHOLMOD_A, L, Dense(B)))\nend\n\nconst RealHermSymComplexHermF64SSL = Union{\n    Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n    Hermitian{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n    Hermitian{ComplexF64,SparseMatrixCSC{ComplexF64,SuiteSparse_long}}}\nconst StridedVecOrMatInclAdjAndTrans = Union{StridedVecOrMat, Adjoint{<:Any, <:StridedVecOrMat}, Transpose{<:Any, <:StridedVecOrMat}}\nfunction \\(A::RealHermSymComplexHermF64SSL, B::StridedVecOrMatInclAdjAndTrans)\n    F = cholesky(A; check = false)\n    if issuccess(F)\n        return \\(F, B)\n    else\n        ldlt!(F, A; check = false)\n        if issuccess(F)\n            return \\(F, B)\n        else\n            return \\(lu(SparseMatrixCSC{eltype(A), SuiteSparse_long}(A)), B)\n        end\n    end\nend\nfunction \\(adjA::Adjoint{<:Any,<:RealHermSymComplexHermF64SSL}, B::StridedVecOrMatInclAdjAndTrans)\n    A = adjA.parent\n    F = cholesky(A; check = false)\n    if issuccess(F)\n        return \\(adjoint(F), B)\n    else\n        ldlt!(F, A; check = false)\n        if issuccess(F)\n            return \\(adjoint(F), B)\n        else\n            return \\(adjoint(lu(SparseMatrixCSC{eltype(A), SuiteSparse_long}(A))), B)\n        end\n    end\nend\n\n## Other convenience methods\nfunction diag(F::Factor{Tv}) where Tv\n    f = unsafe_load(pointer(F))\n    fsuper = f.super\n    fpi = f.pi\n    res = Base.zeros(Tv, Int(f.n))\n    xv  = f.x\n    if f.is_super!=0\n        px = f.px\n        pos = 1\n        for i in 1:f.nsuper\n            base = unsafe_load(px, i) + 1\n            res[pos] = unsafe_load(xv, base)\n            pos += 1\n            for j in 1:unsafe_load(fsuper, i + 1) - unsafe_load(fsuper, i) - 1\n                res[pos] = unsafe_load(xv, base + j*(unsafe_load(fpi, i + 1) -\n                    unsafe_load(fpi, i) + 1))\n                pos += 1\n            end\n        end\n    else\n        c0 = f.p\n        r0 = f.i\n        xv = f.x\n        for j in 1:f.n\n            jj = unsafe_load(c0, j) + 1\n            @assert(unsafe_load(r0, jj) == j - 1)\n            res[j] = unsafe_load(xv, jj)\n        end\n    end\n    res\nend\n\nfunction logdet(F::Factor{Tv}) where Tv<:VTypes\n    f = unsafe_load(pointer(F))\n    res = zero(Tv)\n    for d in diag(F); res += log(abs(d)) end\n    f.is_ll != 0 ? 2res : res\nend\n\ndet(L::Factor) = exp(logdet(L))\n\nfunction issuccess(F::Factor)\n    s = unsafe_load(pointer(F))\n    return s.minor == size(F, 1)\nend\n\nfunction isposdef(F::Factor)\n    if issuccess(F)\n        s = unsafe_load(pointer(F))\n        if s.is_ll == 1\n            return true\n        else\n            # try conversion to LLt\n            change_factor!(F, true, s.is_super, true, s.is_monotonic)\n            b = issuccess(F)\n            # convert back\n            change_factor!(F, false, s.is_super, true, s.is_monotonic)\n            return b\n        end\n    else\n        return false\n    end\nend\n\nfunction ishermitian(A::Sparse{Float64})\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        if i < 0\n            throw(CHOLMODException(\"negative value returned from CHOLMOD's symmetry function. This\n                is either because the indices are not sorted or because of a memory error\"))\n        end\n        return i == MM_SYMMETRIC || i == MM_SYMMETRIC_POSDIAG\n    end\nend\nfunction ishermitian(A::Sparse{ComplexF64})\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        if i < 0\n            throw(CHOLMODException(\"negative value returned from CHOLMOD's symmetry function. This\n                is either because the indices are not sorted or because of a memory error\"))\n        end\n        return i == MM_HERMITIAN || i == MM_HERMITIAN_POSDIAG\n    end\nend\n\n(*)(A::Symmetric{Float64,SparseMatrixCSC{Float64,Ti}},\n    B::SparseVecOrMat{Float64,Ti}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::Hermitian{ComplexF64,SparseMatrixCSC{ComplexF64,Ti}},\n    B::SparseVecOrMat{ComplexF64,Ti}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::Hermitian{Float64,SparseMatrixCSC{Float64,Ti}},\n    B::SparseVecOrMat{Float64,Ti}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n\n(*)(A::SparseVecOrMat{Float64,Ti},\n    B::Symmetric{Float64,SparseMatrixCSC{Float64,Ti}}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::SparseVecOrMat{ComplexF64,Ti},\n    B::Hermitian{ComplexF64,SparseMatrixCSC{ComplexF64,Ti}}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::SparseVecOrMat{Float64,Ti},\n    B::Hermitian{Float64,SparseMatrixCSC{Float64,Ti}}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n\nend #module\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LibUnwind_jll/src/LibUnwind_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/LibUnwind_jll.jl\n\nbaremodule LibUnwind_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libunwind\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibunwind_handle = C_NULL\nlibunwind_path = \"\"\n\nconst libunwind = \"libunwind.so.8\"\n\nfunction __init__()\n    # We only do something on Linux/FreeBSD\n    @static if Sys.islinux() || Sys.isfreebsd()\n        global libunwind_handle = dlopen(libunwind)\n        global libunwind_path = dlpath(libunwind_handle)\n        global artifact_dir = dirname(Sys.BINDIR)\n        LIBPATH[] = dirname(libunwind_path)\n        push!(LIBPATH_list, LIBPATH[])\n    end\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = @static (Sys.islinux() || Sys.isfreebsd()) ? true : false\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libunwind_path() = libunwind_path\n\nend  # module LibUnwind_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LibOSXUnwind_jll/src/LibOSXUnwind_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/LibOSXUnwind_jll.jl\n\nbaremodule LibOSXUnwind_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libosxunwind\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibosxunwind_handle = C_NULL\nlibosxunwind_path = \"\"\n\nconst libosxunwind = \"@rpath/libosxunwind.dylib\"\n\nfunction __init__()\n    # We only dlopen something on MacOS\n    @static if Sys.isapple()\n        global libosxunwind_handle = dlopen(libosxunwind)\n        global libosxunwind_path = dlpath(libosxunwind_handle)\n        global artifact_dir = dirname(Sys.BINDIR)\n        LIBPATH[] = dirname(libosxunwind_path)\n        push!(LIBPATH_list, LIBPATH[])\n    end\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = @static Sys.isapple() ? true : false\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libosxunwind_path() = libosxunwind_path\n\nend  # module LibOSXUnwind_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LibSSH2_jll/src/LibSSH2_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/LibSSH2_jll.jl\n\nbaremodule LibSSH2_jll\nusing Base, Libdl, MbedTLS_jll\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libssh2\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibssh2_handle = C_NULL\nlibssh2_path = \"\"\n\nif Sys.iswindows()\n    const libssh2 = \"libssh2.dll\"\nelseif Sys.isapple()\n    const libssh2 = \"@rpath/libssh2.1.dylib\"\nelse\n    const libssh2 = \"libssh2.so.1\"\nend\n\nfunction __init__()\n    global libssh2_handle = dlopen(libssh2)\n    global libssh2_path = dlpath(libssh2_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libssh2_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libssh2_path() = libssh2_path\n\nend  # module LibSSH2_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/Distributed/test/distributed_exec.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nusing Test, Distributed, Random, Serialization, Sockets\nimport Distributed: launch, manage\n\n@test cluster_cookie() isa String\n\ninclude(joinpath(Sys.BINDIR, \"..\", \"share\", \"julia\", \"test\", \"testenv.jl\"))\n\n@test Distributed.extract_imports(:(begin; import Foo, Bar; let; using Baz; end; end)) ==\n      Any[:(import Foo, Bar), :(using Baz)]\n\n# Test a few \"remote\" invocations when no workers are present\n@test remote(myid)() == 1\n@test pmap(identity, 1:100) == [1:100...]\n@test 100 == @distributed (+) for i in 1:100\n        1\n    end\n\naddprocs_with_testenv(4)\n@test nprocs() == 5\n\n# distributed loading of packages\n\n# setup\n@everywhere begin\n    old_act_proj = Base.ACTIVE_PROJECT[]\n    pushfirst!(Base.LOAD_PATH, \"@\")\n    Base.ACTIVE_PROJECT[] = joinpath(Sys.BINDIR, \"..\", \"share\", \"julia\", \"test\", \"TestPkg\")\nend\n\n# cause precompilation of TestPkg to avoid race condition\nBase.compilecache(Base.identify_package(\"TestPkg\"))\n\n@everywhere using TestPkg\n@everywhere using TestPkg\n\n@everywhere begin\n    Base.ACTIVE_PROJECT[] = old_act_proj\n    popfirst!(Base.LOAD_PATH)\nend\n\n@everywhere using Test, Random, LinearAlgebra\n\nid_me = myid()\nid_other = filter(x -> x != id_me, procs())[rand(1:(nprocs()-1))]\n\n# Test role\n@everywhere using Distributed\n@test Distributed.myrole() === :master\nfor wid = workers()\n    wrole = remotecall_fetch(wid) do\n        Distributed.myrole()\n    end\n    @test wrole === :worker\nend\n\n# Test remote()\nlet\n    pool = default_worker_pool()\n\n    count = 0\n    count_condition = Condition()\n\n    function remote_wait(c)\n        @async_logerr begin\n            count += 1\n            remote(take!)(c)\n            count -= 1\n            notify(count_condition)\n        end\n        yield()\n    end\n\n    testchannels = [RemoteChannel() for i in 1:nworkers()]\n    testcount = 0\n    @test isready(pool) == true\n    for c in testchannels\n        @test count == testcount\n        remote_wait(c)\n        testcount += 1\n    end\n    @test count == testcount\n    @test isready(pool) == false\n\n    for c in testchannels\n        @test count == testcount\n        put!(c, \"foo\")\n        testcount -= 1\n        (count == testcount) || wait(count_condition)\n        @test count == testcount\n        @test isready(pool) == true\n    end\n\n    @test count == 0\n\n    for c in testchannels\n        @test count == testcount\n        remote_wait(c)\n        testcount += 1\n    end\n    @test count == testcount\n    @test isready(pool) == false\n\n    for c in reverse(testchannels)\n        @test count == testcount\n        put!(c, \"foo\")\n        testcount -= 1\n        (count == testcount) || wait(count_condition)\n        @test count == testcount\n        @test isready(pool) == true\n    end\n\n    @test count == 0\nend\n\n# Test Futures\nfunction testf(id)\n    f=Future(id)\n    @test isready(f) == false\n    @test f.v === nothing\n    put!(f, :OK)\n    @test isready(f) == true\n    @test f.v !== nothing\n\n    @test_throws ErrorException put!(f, :OK) # Cannot put! to a already set future\n    @test_throws MethodError take!(f) # take! is unsupported on a Future\n\n    @test fetch(f) == :OK\nend\n\ntestf(id_me)\ntestf(id_other)\n\n# Distributed GC tests for Futures\nfunction test_futures_dgc(id)\n    f = remotecall(myid, id)\n    fid = remoteref_id(f)\n\n    # remote value should be deleted after a fetch\n    @test remotecall_fetch(k->(yield();haskey(Distributed.PGRP.refs, k)), id, fid) == true\n    @test f.v === nothing\n    @test fetch(f) == id\n    @test f.v !== nothing\n    yield(); # flush gc msgs\n    @test remotecall_fetch(k->(yield();haskey(Distributed.PGRP.refs, k)), id, fid) == false\n\n\n    # if unfetched, it should be deleted after a finalize\n    f = remotecall(myid, id)\n    fid = remoteref_id(f)\n    @test remotecall_fetch(k->(yield();haskey(Distributed.PGRP.refs, k)), id, fid) == true\n    @test f.v === nothing\n    finalize(f)\n    yield(); # flush gc msgs\n    @test remotecall_fetch(k->(yield();haskey(Distributed.PGRP.refs, k)), id, fid) == false\nend\n\ntest_futures_dgc(id_me)\ntest_futures_dgc(id_other)\n\n# if sent to another worker, it should not be deleted till all references are fetched.\nwid1 = workers()[1]\nwid2 = workers()[2]\nf = remotecall(myid, wid1)\nfid = remoteref_id(f)\n\nfstore = RemoteChannel(wid2)\nput!(fstore, f)\n\n@test fetch(f) == wid1\n@test remotecall_fetch(k->haskey(Distributed.PGRP.refs, k), wid1, fid) == true\nremotecall_fetch(r->(fetch(fetch(r)); yield()), wid2, fstore)\nsleep(0.5) # to ensure that wid2 gc messages have been executed on wid1\n@test remotecall_fetch(k->haskey(Distributed.PGRP.refs, k), wid1, fid) == false\n\n# put! should release remote reference since it would have been cached locally\nf = Future(wid1)\nfid = remoteref_id(f)\n\n# should not be created remotely till accessed\n@test remotecall_fetch(k->haskey(Distributed.PGRP.refs, k), wid1, fid) == false\n# create it remotely\nisready(f)\n\n@test remotecall_fetch(k->haskey(Distributed.PGRP.refs, k), wid1, fid) == true\nput!(f, :OK)\n@test remotecall_fetch(k->haskey(Distributed.PGRP.refs, k), wid1, fid) == false\n@test fetch(f) == :OK\n\n# RemoteException should be thrown on a put! when another process has set the value\nf = Future(wid1)\nfid = remoteref_id(f)\n\nfstore = RemoteChannel(wid2)\nput!(fstore, f) # send f to wid2\nput!(f, :OK) # set value from master\n\n@test remotecall_fetch(k->haskey(Distributed.PGRP.refs, k), wid1, fid) == true\n\ntestval = remotecall_fetch(wid2, fstore) do x\n    try\n        put!(fetch(x), :OK)\n        return 0\n    catch e\n        if isa(e, RemoteException)\n            return 1\n        else\n            return 2\n        end\n    end\nend\n@test testval == 1\n\n# Issue number #25847\n@everywhere function f25847(ref)\n    fetch(ref)\n    return true\nend\n\nf = remotecall_wait(identity, id_other, ones(10))\nrrid = Distributed.RRID(f.whence, f.id)\nremotecall_fetch(f25847, id_other, f)\n@test BitSet([id_me]) == remotecall_fetch(()->Distributed.PGRP.refs[rrid].clientset, id_other)\n\nremotecall_fetch(f25847, id_other, f)\n@test BitSet([id_me]) == remotecall_fetch(()->Distributed.PGRP.refs[rrid].clientset, id_other)\n\nfinalize(f)\nyield() # flush gc msgs\n@test false == remotecall_fetch(chk_rrid->(yield(); haskey(Distributed.PGRP.refs, chk_rrid)), id_other, rrid)\n\n\n# Distributed GC tests for RemoteChannels\nfunction test_remoteref_dgc(id)\n    rr = RemoteChannel(id)\n    put!(rr, :OK)\n    rrid = remoteref_id(rr)\n\n    # remote value should be deleted after finalizing the ref\n    @test remotecall_fetch(k->(yield();haskey(Distributed.PGRP.refs, k)), id, rrid) == true\n    @test fetch(rr) == :OK\n    @test remotecall_fetch(k->(yield();haskey(Distributed.PGRP.refs, k)), id, rrid) == true\n    finalize(rr)\n    yield(); # flush gc msgs\n    @test remotecall_fetch(k->(yield();haskey(Distributed.PGRP.refs, k)), id, rrid) == false\nend\ntest_remoteref_dgc(id_me)\ntest_remoteref_dgc(id_other)\n\n# if sent to another worker, it should not be deleted till the other worker has also finalized.\nlet wid1 = workers()[1],\n    wid2 = workers()[2],\n    rr = RemoteChannel(wid1),\n    rrid = remoteref_id(rr),\n    fstore = RemoteChannel(wid2)\n\n    put!(fstore, rr)\n    @test remotecall_fetch(k -> haskey(Distributed.PGRP.refs, k), wid1, rrid) == true\n    finalize(rr) # finalize locally\n    yield() # flush gc msgs\n    @test remotecall_fetch(k -> haskey(Distributed.PGRP.refs, k), wid1, rrid) == true\n    remotecall_fetch(r -> (finalize(take!(r)); yield(); nothing), wid2, fstore) # finalize remotely\n    sleep(0.5) # to ensure that wid2 messages have been executed on wid1\n    @test remotecall_fetch(k -> haskey(Distributed.PGRP.refs, k), wid1, rrid) == false\nend\n\n# Tests for issue #23109 - should not hang.\nf = @spawnat :any rand(1, 1)\n@Base.Experimental.sync begin\n    for _ in 1:10\n        @async fetch(f)\n    end\nend\n\nwid1, wid2 = workers()[1:2]\nf = @spawnat wid1 rand(1,1)\n@Base.Experimental.sync begin\n    @async fetch(f)\n    @async remotecall_fetch(()->fetch(f), wid2)\nend\n\n\n@test fetch(@spawnat id_other myid()) == id_other\n@test (@fetchfrom id_other myid()) == id_other\n\npids=[]\nfor i in 1:nworkers()\n    push!(pids, @fetch myid())\nend\n@test sort(pids) == sort(workers())\n\n\n# test getindex on Futures and RemoteChannels\nfunction test_indexing(rr)\n    a = rand(5,5)\n    put!(rr, a)\n    @test rr[2,3] == a[2,3]\n    @test rr[] == a\nend\n\ntest_indexing(Future())\ntest_indexing(Future(id_other))\ntest_indexing(RemoteChannel())\ntest_indexing(RemoteChannel(id_other))\n\n# Test ser/deser to non-ClusterSerializer objects.\nfunction test_regular_io_ser(ref::Distributed.AbstractRemoteRef)\n    io = IOBuffer()\n    serialize(io, ref)\n    seekstart(io)\n    ref2 = deserialize(io)\n    for fld in fieldnames(typeof(ref))\n        v = getfield(ref2, fld)\n        if isa(v, Number)\n            @test v === zero(typeof(v))\n        elseif v !== nothing\n            error(string(\"Add test for field \", fld))\n        end\n    end\nend\n\ntest_regular_io_ser(Future())\ntest_regular_io_ser(RemoteChannel())\n\n# Test @distributed load balancing - all processors should get either M or M+1\n# iterations out of the loop range for some M.\nids = @distributed((a,b)->[a;b], for i=1:7; myid(); end)\nworkloads = Int[sum(ids .== i) for i in 2:nprocs()]\n@test maximum(workloads) - minimum(workloads) <= 1\n\n# @distributed reduction should work even with very short ranges\n@test @distributed(+, for i=1:2; i; end) == 3\n\n@test_throws ArgumentError sleep(-1)\n@test_throws ArgumentError timedwait(()->false, 0.1, pollint=-0.5)\n\n# specify pids for pmap\n@test sort(workers()[1:2]) == sort(unique(pmap(x->(sleep(0.1);myid()), WorkerPool(workers()[1:2]), 1:10)))\n\n# Testing buffered  and unbuffered reads\n# This large array should write directly to the socket\na = fill(1, 10^6)\n@test a == remotecall_fetch((x)->x, id_other, a)\n\n# Not a bitstype, should be buffered\ns = [randstring() for x in 1:10^5]\n@test s == remotecall_fetch((x)->x, id_other, s)\n\n#large number of small requests\nnum_small_requests = 10000\n@test fill(id_other, num_small_requests) == [remotecall_fetch(myid, id_other) for i in 1:num_small_requests]\n\n# test parallel sends of large arrays from multiple tasks to the same remote worker\nntasks = 10\nrr_list = [Channel(1) for x in 1:ntasks]\n\nfor rr in rr_list\n    local rr\n    let rr = rr\n        @async try\n            for i in 1:10\n                a = rand(2*10^5)\n                @test a == remotecall_fetch(x->x, id_other, a)\n                yield()\n            end\n            put!(rr, :OK)\n        catch\n            put!(rr, :ERROR)\n        end\n    end\nend\n\n@test [fetch(rr) for rr in rr_list] == [:OK for x in 1:ntasks]\n\nfunction test_channel(c)\n    @test isopen(c) == true\n    put!(c, 1)\n    put!(c, \"Hello\")\n    put!(c, 5.0)\n\n    @test isready(c) == true\n    @test isopen(c) == true\n    @test fetch(c) == 1\n    @test fetch(c) == 1   # Should not have been popped previously\n    @test take!(c) == 1\n    @test take!(c) == \"Hello\"\n    @test fetch(c) == 5.0\n    @test take!(c) == 5.0\n    @test isready(c) == false\n    @test isopen(c) == true\n    close(c)\n    @test isopen(c) == false\nend\n\ntest_channel(Channel(10))\ntest_channel(RemoteChannel(()->Channel(10)))\n\nc=Channel{Int}(1)\n@test_throws MethodError put!(c, \"Hello\")\n\n# test channel iterations\nfunction test_iteration(in_c, out_c)\n    t=@async for v in in_c\n        put!(out_c, v)\n    end\n\n    @test isopen(in_c) == true\n    put!(in_c, 1)\n    @test take!(out_c) == 1\n    put!(in_c, \"Hello\")\n    close(in_c)\n    @test take!(out_c) == \"Hello\"\n    @test isopen(in_c) == false\n    @test_throws InvalidStateException put!(in_c, :foo)\n    yield()\n    @test istaskdone(t) == true\nend\n\ntest_iteration(Channel(10), Channel(10))\n# make sure exceptions propagate when waiting on Tasks\n@test_throws CompositeException (@sync (@async error(\"oops\")))\ntry\n    @sync begin\n        for i in 1:5\n            @async error(i)\n        end\n    end\n    error(\"unexpected\")\ncatch ex\n    @test typeof(ex) == CompositeException\n    @test length(ex) == 5\n    @test typeof(ex.exceptions[1]) == TaskFailedException\n    @test typeof(ex.exceptions[1].task.exception) == ErrorException\n    # test start, next, and done\n    for (i, i_ex) in enumerate(ex)\n        @test i == parse(Int, i_ex.task.exception.msg)\n    end\n    # test showerror\n    err_str = sprint(showerror, ex)\n    err_one_str = sprint(showerror, ex.exceptions[1])\n    @test err_str == err_one_str * \"\\n\\n...and 4 more exceptions.\\n\"\nend\n@test sprint(showerror, CompositeException()) == \"CompositeException()\\n\"\n\nfunction test_remoteexception_thrown(expr)\n    try\n        expr()\n        error(\"unexpected\")\n    catch ex\n        @test typeof(ex) == RemoteException\n        @test typeof(ex.captured) == CapturedException\n        @test typeof(ex.captured.ex) == ErrorException\n        @test ex.captured.ex.msg == \"foobar\"\n    end\nend\n\nfor id in [id_other, id_me]\n    local id\n    test_remoteexception_thrown() do\n        remotecall_fetch(id) do\n            throw(ErrorException(\"foobar\"))\n        end\n    end\n    test_remoteexception_thrown() do\n        remotecall_wait(id) do\n            throw(ErrorException(\"foobar\"))\n        end\n    end\n    test_remoteexception_thrown() do\n        wait(remotecall(id) do\n            throw(ErrorException(\"foobar\"))\n        end)\n    end\nend\n\n# make sure the stackframe from the remote error can be serialized\nlet ex\n    try\n        remotecall_fetch(id_other) do\n            @eval module AModuleLocalToOther\n                foo() = throw(ErrorException(\"A.error\"))\n                foo()\n            end\n        end\n    catch ex\n    end\n    @test (ex::RemoteException).pid == id_other\n    @test ((ex.captured::CapturedException).ex::ErrorException).msg == \"A.error\"\n    bt = ex.captured.processed_bt::Array{Any,1}\n    @test length(bt) > 1\n    frame, repeated = bt[1]::Tuple{Base.StackTraces.StackFrame, Int}\n    @test frame.func == :foo\n    @test frame.linfo === nothing\n    @test repeated == 1\nend\n\n# pmap tests. Needs at least 4 processors dedicated to the below tests. Which we currently have\n# since the distributed tests are now spawned as a separate set.\n\n# Test all combinations of pmap keyword args.\npmap_args = [\n                (:distributed, [:default, false]),\n                (:batch_size, [:default,2]),\n                (:on_error, [:default, e -> (e.msg == \"foobar\" ? true : rethrow())]),\n                (:retry_delays, [:default, fill(0.001, 1000)]),\n                (:retry_check, [:default, (s,e) -> (s,endswith(e.msg,\"foobar\"))]),\n            ]\n\nkwdict = Dict()\nfunction walk_args(i)\n    if i > length(pmap_args)\n        kwargs = []\n        for (k,v) in kwdict\n            if v !== :default\n                push!(kwargs, (k,v))\n            end\n        end\n\n        data = 1:100\n\n        testw = kwdict[:distributed] === false ? [1] : workers()\n\n        if kwdict[:retry_delays] !== :default\n            mapf = x -> iseven(myid()) ? error(\"notfoobar\") : (x*2, myid())\n            results_test = pmap_res -> begin\n                results = [x[1] for x in pmap_res]\n                pids = [x[2] for x in pmap_res]\n                @test results == [2:2:200...]\n                for p in testw\n                    if isodd(p)\n                        @test p in pids\n                    else\n                        @test !(p in pids)\n                    end\n                end\n            end\n        elseif kwdict[:on_error] === :default\n            mapf = x -> (x*2, myid())\n            results_test = pmap_res -> begin\n                results = [x[1] for x in pmap_res]\n                pids = [x[2] for x in pmap_res]\n                @test results == [2:2:200...]\n                for p in testw\n                    @test p in pids\n                end\n            end\n        else\n            mapf = x -> iseven(x) ? error(\"foobar\") : (x*2, myid())\n            results_test = pmap_res -> begin\n                w = testw\n                for (idx,x) in enumerate(data)\n                    if iseven(x)\n                        @test pmap_res[idx] == true\n                    else\n                        @test pmap_res[idx][1] == x*2\n                        @test pmap_res[idx][2] in w\n                    end\n                end\n            end\n        end\n\n        try\n            results_test(pmap(mapf, data; kwargs...))\n        catch\n            println(\"pmap executing with args : \", kwargs)\n            rethrow()\n        end\n\n        return\n    end\n\n    kwdict[pmap_args[i][1]] = pmap_args[i][2][1]\n    walk_args(i+1)\n\n    kwdict[pmap_args[i][1]] = pmap_args[i][2][2]\n    walk_args(i+1)\nend\n\n# Start test for various kw arg combinations\nwalk_args(1)\n\ninclude(joinpath(Sys.BINDIR, \"..\", \"share\", \"julia\", \"test\", \"generic_map_tests.jl\"))\nempty_pool = WorkerPool([myid()])\npmap_fallback = (f, c...) -> pmap(f, empty_pool, c...)\ngeneric_map_tests(pmap_fallback)\n\n# pmap with various types. Test for equivalence with map\nrun_map_equivalence_tests(pmap)\n@test pmap(uppercase, \"Hello World!\") == map(uppercase, \"Hello World!\")\n\n\n# Simple test for pmap throws error\nlet error_thrown = false\n    try\n        pmap(x -> x == 50 ? error(\"foobar\") : x, 1:100)\n    catch e\n        @test e.captured.ex.msg == \"foobar\"\n        error_thrown = true\n    end\n    @test error_thrown\nend\n\n# Test pmap with a generator type iterator\n@test [1:100...] == pmap(x->x, Base.Generator(x->(sleep(0.0001); x), 1:100))\n\n# Test pgenerate\nn = 10\nas = [rand(4,4) for i in 1:n]\nbs = deepcopy(as)\ncs = collect(Distributed.pgenerate(x->(sleep(rand()*0.1); svd(x)), bs))\nsvdas = map(svd, as)\nfor i in 1:n\n    @test cs[i].U \u2248 svdas[i].U\n    @test cs[i].S \u2248 svdas[i].S\n    @test cs[i].V \u2248 svdas[i].V\nend\n\n# Test that the default worker pool cycles through all workers\npmap(_->myid(), 1:nworkers())  # priming run\n@test nworkers() == length(unique(pmap(_->myid(), 1:100)))\n\n# Test same behaviour when executed on a worker\n@test nworkers() == length(unique(remotecall_fetch(()->pmap(_->myid(), 1:100), id_other)))\n\n# Same tests with custom worker pools.\nwp = WorkerPool(workers())\n@test nworkers() == length(unique(pmap(_->myid(), wp, 1:100)))\n@test nworkers() == length(unique(remotecall_fetch(wp->pmap(_->myid(), wp, 1:100), id_other, wp)))\n\n\n# CachingPool tests\nwp = CachingPool(workers())\n@test [1:100...] == pmap(x->x, wp, 1:100)\n\nclear!(wp)\n@test length(wp.map_obj2ref) == 0\n\n# The below block of tests are usually run only on local development systems, since:\n# - tests which print errors\n# - addprocs tests are memory intensive\n# - ssh addprocs requires sshd to be running locally with passwordless login enabled.\n# The test block is enabled by defining env JULIA_TESTFULL=1\n\nDoFullTest = Bool(parse(Int,(get(ENV, \"JULIA_TESTFULL\", \"0\"))))\n\nif DoFullTest\n    println(\"Testing exception printing on remote worker from a `remote_do` call\")\n    println(\"Please ensure the remote error and backtrace is displayed on screen\")\n\n    remote_do(id_other) do\n        throw(ErrorException(\"TESTING EXCEPTION ON REMOTE DO. PLEASE IGNORE\"))\n    end\n    sleep(0.5)  # Give some time for the above error to be printed\n\n    println(\"\\n\\nThe following 'invalid connection credentials' error messages are to be ignored.\")\n    all_w = workers()\n    # Test sending fake data to workers. The worker processes will print an\n    # error message but should not terminate.\n    for w in Distributed.PGRP.workers\n        if isa(w, Distributed.Worker)\n            local s = connect(w.config.host, w.config.port)\n            write(s, randstring(32))\n        end\n    end\n    @test workers() == all_w\n    @test all([p == remotecall_fetch(myid, p) for p in all_w])\n\nif Sys.isunix() # aka have ssh\n    function test_n_remove_pids(new_pids)\n        for p in new_pids\n            w_in_remote = sort(remotecall_fetch(workers, p))\n            try\n                @test intersect(new_pids, w_in_remote) == new_pids\n            catch\n                print(\"p       :     $p\\n\")\n                print(\"newpids :     $new_pids\\n\")\n                print(\"w_in_remote : $w_in_remote\\n\")\n                print(\"intersect   : $(intersect(new_pids, w_in_remote))\\n\\n\\n\")\n                rethrow()\n            end\n        end\n\n        remotecall_fetch(rmprocs, 1, new_pids)\n    end\n\n    print(\"\\n\\nTesting SSHManager. A minimum of 4GB of RAM is recommended.\\n\")\n    print(\"Please ensure: \\n\")\n    print(\"1) sshd is running locally with passwordless login enabled.\\n\")\n    print(\"2) Env variable USER is defined and is the ssh user.\\n\")\n    print(\"3) Port 9300 is not in use.\\n\")\n\n    sshflags = `-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=ERROR `\n    #Issue #9951\n    hosts=[]\n    localhost_aliases = [\"localhost\", string(getipaddr()), \"127.0.0.1\"]\n    num_workers = parse(Int,(get(ENV, \"JULIA_ADDPROCS_NUM\", \"9\")))\n\n    for i in 1:(num_workers/length(localhost_aliases))\n        append!(hosts, localhost_aliases)\n    end\n\n    print(\"\\nTesting SSH addprocs with $(length(hosts)) workers...\\n\")\n    new_pids = addprocs_with_testenv(hosts; sshflags=sshflags)\n    @test length(new_pids) == length(hosts)\n    test_n_remove_pids(new_pids)\n\n    print(\"\\nMixed ssh addprocs with :auto\\n\")\n    new_pids = addprocs_with_testenv([\"localhost\", (\"127.0.0.1\", :auto), \"localhost\"]; sshflags=sshflags)\n    @test length(new_pids) == (2 + Sys.CPU_THREADS)\n    test_n_remove_pids(new_pids)\n\n    print(\"\\nMixed ssh addprocs with numeric counts\\n\")\n    new_pids = addprocs_with_testenv([(\"localhost\", 2), (\"127.0.0.1\", 2), \"localhost\"]; sshflags=sshflags)\n    @test length(new_pids) == 5\n    test_n_remove_pids(new_pids)\n\n    print(\"\\nssh addprocs with tunnel\\n\")\n    new_pids = addprocs_with_testenv([(\"localhost\", num_workers)]; tunnel=true, sshflags=sshflags)\n    @test length(new_pids) == num_workers\n    test_n_remove_pids(new_pids)\n\n    print(\"\\nssh addprocs with tunnel (SSH multiplexing)\\n\")\n    new_pids = addprocs_with_testenv([(\"localhost\", num_workers)]; tunnel=true, multiplex=true, sshflags=sshflags)\n    @test length(new_pids) == num_workers\n    controlpath = joinpath(homedir(), \".ssh\", \"julia-$(ENV[\"USER\"])@localhost:22\")\n    @test issocket(controlpath)\n    test_n_remove_pids(new_pids)\n    @test :ok == timedwait(()->!issocket(controlpath), 10.0; pollint=0.5)\n\n    print(\"\\nAll supported formats for hostname\\n\")\n    h1 = \"localhost\"\n    user = ENV[\"USER\"]\n    h2 = \"$user@$h1\"\n    h3 = \"$h2:22\"\n    h4 = \"$h3 $(string(getipaddr()))\"\n    h5 = \"$h4:9300\"\n\n    new_pids = addprocs_with_testenv([h1, h2, h3, h4, h5]; sshflags=sshflags)\n    @test length(new_pids) == 5\n    test_n_remove_pids(new_pids)\n\n    print(\"\\nkeyword arg exename\\n\")\n    for exename in [`$(joinpath(Sys.BINDIR, Base.julia_exename()))`, \"$(joinpath(Sys.BINDIR, Base.julia_exename()))\"]\n        for addp_func in [()->addprocs_with_testenv([\"localhost\"]; exename=exename, exeflags=test_exeflags, sshflags=sshflags),\n                          ()->addprocs_with_testenv(1; exename=exename, exeflags=test_exeflags)]\n\n            local new_pids = addp_func()\n            @test length(new_pids) == 1\n            test_n_remove_pids(new_pids)\n        end\n    end\n\nend # unix-only\nend # full-test\n\nlet t = @task 42\n    schedule(t, ErrorException(\"\"), error=true)\n    @test_throws TaskFailedException(t) Base.wait(t)\nend\n\n# issue #8207\nlet A = Any[]\n    @distributed (+) for i in (push!(A,1); 1:2)\n        i\n    end\n    @test length(A) == 1\nend\n\n# issue #13168\nfunction f13168(n)\n    val = 0\n    for i = 1:n\n        val += sum(rand(n, n)^2)\n    end\n    return val\nend\nlet t = schedule(@task f13168(100))\n    @test t.state == :runnable\n    @test t.queue !== nothing\n    @test_throws ErrorException schedule(t)\n    yield()\n    @test t.state == :done\n    @test t.queue === nothing\n    @test_throws ErrorException schedule(t)\n    @test isa(fetch(t), Float64)\nend\n\n# issue #13122\n@test remotecall_fetch(identity, workers()[1], C_NULL) === C_NULL\n\n# issue #11062\nfunction t11062()\n    @async v11062 = 1\n    v11062 = 2\nend\n\n@test t11062() == 2\n\n# issue #15406\nv15406 = remotecall_wait(() -> 1, id_other)\nfetch(v15406)\nremotecall_wait(fetch, id_other, v15406)\n\n# Test various forms of remotecall* invocations\n\n@everywhere f_args(v1, v2=0; kw1=0, kw2=0) = v1+v2+kw1+kw2\n\nfunction test_f_args(result, args...; kwargs...)\n    @test fetch(remotecall(args...; kwargs...)) == result\n    @test fetch(remotecall_wait(args...; kwargs...)) == result\n    @test remotecall_fetch(args...; kwargs...) == result\n\n    # A visual test - remote_do should NOT print any errors\n    remote_do(args...; kwargs...)\nend\n\nfor tid in [id_other, id_me, default_worker_pool()]\n    test_f_args(1, f_args, tid, 1)\n    test_f_args(3, f_args, tid, 1, 2)\n    test_f_args(5, f_args, tid, 1; kw1=4)\n    test_f_args(13, f_args, tid, 1; kw1=4, kw2=8)\n    test_f_args(15, f_args, tid, 1, 2; kw1=4, kw2=8)\nend\n\n# Test remote_do\nf=Future(id_me)\nremote_do(fut->put!(fut, myid()), id_me, f)\n@test fetch(f) == id_me\n\nf=Future(id_other)\nremote_do(fut->put!(fut, myid()), id_other, f)\n@test fetch(f) == id_other\n\n# Github issue #29932\nrc_unbuffered = RemoteChannel(()->Channel{Vector{Float64}}(0))\n@test eltype(rc_unbuffered) == Vector{Float64}\n\n@async begin\n    # Trigger direct write (no buffering) of largish array\n    array_sz = Int(Base.SZ_UNBUFFERED_IO/8) + 1\n    largev = zeros(array_sz)\n    for i in 1:10\n        largev[1] = float(i)\n        put!(rc_unbuffered, largev)\n    end\nend\n\n@test remotecall_fetch(rc -> begin\n        for i in 1:10\n            take!(rc)[1] != float(i) && error(\"Failed\")\n        end\n        return :OK\n    end, id_other, rc_unbuffered) == :OK\n\n# github PR #14456\nn = DoFullTest ? 6 : 5\nfor i = 1:10^n\n    fetch(@spawnat myid() myid())\nend\n\n# issue #15451\n@test remotecall_fetch(x->(y->2y)(x)+1, workers()[1], 3) == 7\n\n# issue #16091\nmutable struct T16091 end\nwid = workers()[1]\n@test try\n    remotecall_fetch(()->T16091, wid)\n    false\ncatch ex\n    ((ex::RemoteException).captured::CapturedException).ex === UndefVarError(:T16091)\nend\n@test try\n    remotecall_fetch(identity, wid, T16091)\n    false\ncatch ex\n    ((ex::RemoteException).captured::CapturedException).ex === UndefVarError(:T16091)\nend\n\nf16091a() = 1\nremotecall_fetch(()->eval(:(f16091a() = 2)), wid)\n@test remotecall_fetch(f16091a, wid) === 2\n@test remotecall_fetch((myid)->remotecall_fetch(f16091a, myid), wid, myid()) === 1\n\n# these will only heisen-fail, since it depends on the gensym counter collisions:\nf16091b = () -> 1\nremotecall_fetch(()->eval(:(f16091b = () -> 2)), wid)\n@test remotecall_fetch(f16091b, 2) === 1\n# Global anonymous functions are over-written...\n@test remotecall_fetch((myid)->remotecall_fetch(f16091b, myid), wid, myid()) === 1\n\n# ...while local anonymous functions are by definition, local.\nlet\n    f16091c = () -> 1\n    @test remotecall_fetch(f16091c, 2) === 1\n    @test remotecall_fetch(\n        myid -> begin\n            let\n                f16091c = () -> 2\n                remotecall_fetch(f16091c, myid)\n            end\n        end, wid, myid()) === 2\nend\n\n# issue #16451\nrng=RandomDevice()\nretval = @distributed (+) for _ in 1:10\n    rand(rng)\nend\n@test retval > 0.0 && retval < 10.0\n\nrand(rng)\nretval = @distributed (+) for _ in 1:10\n    rand(rng)\nend\n@test retval > 0.0 && retval < 10.0\n\n# serialization tests\nwrkr1 = workers()[1]\nwrkr2 = workers()[end]\n\n@test remotecall_fetch(p->remotecall_fetch(myid, p), wrkr1, wrkr2) == wrkr2\n\n# Send f to wrkr1 and wrkr2. Then try calling f on wrkr2 from wrkr1\nf_myid = ()->myid()\n@test wrkr1 == remotecall_fetch(f_myid, wrkr1)\n@test wrkr2 == remotecall_fetch(f_myid, wrkr2)\n@test wrkr2 == remotecall_fetch((f, p)->remotecall_fetch(f, p), wrkr1, f_myid, wrkr2)\n\n# Deserialization error recovery test\n# locally defined module, but unavailable on workers\nmodule LocalFoo\n    global foo=1\nend\n\nlet\n    @test_throws RemoteException remotecall_fetch(()->LocalFoo.foo, 2)\n\n    bad_thunk = ()->NonexistantModule.f()\n    @test_throws RemoteException remotecall_fetch(bad_thunk, 2)\n\n    # Test that the stream is still usable\n    @test remotecall_fetch(()->:test,2) == :test\n    ref = remotecall(bad_thunk, 2)\n    @test_throws RemoteException fetch(ref)\nend\n\n# Test calling @everywhere from a module not defined on the workers\nmodule LocalBar\n    using Distributed\n    bar() = @everywhere new_bar()=myid()\nend\nLocalBar.bar()\nfor p in procs()\n    @test p == remotecall_fetch(new_bar, p)\nend\n\n# @everywhere (remotecall_eval) behaviors (#22589)\nlet (p, p2) = filter!(p -> p != myid(), procs())\n    @test (myid() + 1) == @everywhere myid() (myid() + 1)\n    @test (p * 2) == @everywhere p (myid() * 2)\n    @test 1 == @everywhere p defined_on_p = 1\n    @test !@isdefined defined_on_p\n    @test !isdefined(Main, :defined_on_p)\n    @test remotecall_fetch(isdefined, p, Main, :defined_on_p)\n    @test !remotecall_fetch(isdefined, p2, Main, :defined_on_p)\n    @test nothing === @everywhere [p, p] defined_on_p += 1\n    @test 3 === @everywhere p defined_on_p\n    let ref = Ref(0)\n        @test nothing ===\n            @everywhere [myid(), p, myid(), myid(), p] begin\n                Test.@test Main === @__MODULE__\n                $ref[] += 1\n            end\n        @test ref[] == 3\n    end\n    function test_throw_on(procs, msg)\n        try\n            @everywhere procs error($msg)\n            error(\"test failed to throw\")\n        catch excpt\n            if procs isa Int\n                ex = Any[excpt]\n            else\n                ex = (excpt::CompositeException).exceptions\n            end\n            for (p, ex) in zip(procs, ex)\n                local p\n                if procs isa Int || p != myid()\n                    @test (ex::RemoteException).pid == p\n                    ex = ((ex::RemoteException).captured::CapturedException).ex\n                else\n                    ex = (ex::TaskFailedException).task.exception\n                end\n                @test (ex::ErrorException).msg == msg\n            end\n        end\n    end\n    test_throw_on(p, \"everywhere on p\")\n    test_throw_on(myid(), \"everywhere on myid\")\n    test_throw_on([p, myid()], \"everywhere on myid and p\")\n    test_throw_on([p2, p], \"everywhere on p and p2\")\nend\n\n# Test addprocs enable_threaded_blas parameter\n\nconst get_num_threads = function() # anonymous so it will be serialized when called\n    blas = LinearAlgebra.BLAS.vendor()\n    # Wrap in a try to catch unsupported blas versions\n    try\n        if blas == :openblas\n            return ccall((:openblas_get_num_threads, Base.libblas_name), Cint, ())\n        elseif blas == :openblas64\n            return ccall((:openblas_get_num_threads64_, Base.libblas_name), Cint, ())\n        elseif blas == :mkl\n            return ccall((:MKL_Get_Max_Num_Threads, Base.libblas_name), Cint, ())\n        end\n\n        # OSX BLAS looks at an environment variable\n        if Sys.isapple()\n            return tryparse(Cint, get(ENV, \"VECLIB_MAXIMUM_THREADS\", \"1\"))\n        end\n    catch\n    end\n\n    return nothing\nend\n\nfunction get_remote_num_threads(processes_added)\n    return [remotecall_fetch(get_num_threads, proc_id) for proc_id in processes_added]\nend\n\nfunction test_blas_config(pid, expected)\n    for worker in Distributed.PGRP.workers\n        if worker.id == pid\n            @test worker.config.enable_threaded_blas == expected\n            return\n        end\n    end\nend\n\nfunction test_add_procs_threaded_blas()\n    master_blas_thread_count = get_num_threads()\n    if master_blas_thread_count === nothing\n        @warn \"Skipping blas num threads tests due to unsupported blas version\"\n        return\n    end\n    @test master_blas_thread_count <= 8 # check that Base set the environment variable in __init__ before LinearAlgebra dlopen'd it\n\n    # Test with default enable_threaded_blas false\n    processes_added = addprocs_with_testenv(2)\n    for proc_id in processes_added\n        test_blas_config(proc_id, false)\n    end\n\n    # Master thread should not have changed\n    @test get_num_threads() == master_blas_thread_count\n\n    # Threading disabled in children by default\n    thread_counts_by_process = get_remote_num_threads(processes_added)\n    for thread_count in thread_counts_by_process\n        @test thread_count == 1\n    end\n    rmprocs(processes_added)\n\n    processes_added = addprocs_with_testenv(2, enable_threaded_blas=true)\n    for proc_id in processes_added\n        test_blas_config(proc_id, true)\n    end\n\n    @test get_num_threads() == master_blas_thread_count\n\n    # BLAS.set_num_threads(`num`) doesn't  cause get_num_threads to return `num`\n    # depending on the machine, the BLAS version, and BLAS configuration, so\n    # we need a very lenient test.\n    thread_counts_by_process = get_remote_num_threads(processes_added)\n    for thread_count in thread_counts_by_process\n        @test thread_count >= 1\n    end\n    rmprocs(processes_added)\nend\ntest_add_procs_threaded_blas()\n\n#19687\nif false ### TODO: The logic that is supposed to implement this is racy - Disabled for now\n# ensure no race conditions between rmprocs and addprocs\nfor i in 1:5\n    p = addprocs_with_testenv(1)[1]\n    @spawnat p sleep(5)\n    rmprocs(p; waitfor=0)\nend\n\n# Test if a wait has been called on rmprocs(...;waitfor=0), further remotecalls\n# don't throw errors.\nfor i in 1:5\n    p = addprocs_with_testenv(1)[1]\n    np = nprocs()\n    @spawnat p sleep(5)\n    Base.wait(rmprocs(p; waitfor=0))\n    for pid in procs()\n        @test pid == remotecall_fetch(myid, pid)\n    end\n    @test nprocs() == np - 1\nend\n\n# Test that an exception is thrown if workers are unable to be removed within requested time.\nif DoFullTest\n    pids=addprocs_with_testenv(4);\n    @test_throws ErrorException rmprocs(pids; waitfor=0.001);\n    # wait for workers to be removed\n    while any(in(procs()), pids)\n        sleep(0.1)\n    end\nend\nend\n\n# Test addprocs/rmprocs from master node only\nfor f in [ ()->addprocs(1; exeflags=test_exeflags), ()->rmprocs(workers()) ]\n    local f\n    try\n        remotecall_fetch(f, id_other)\n        error(\"Unexpected\")\n    catch ex\n        @test isa(ex, RemoteException)\n        @test ex.captured.ex.msg == \"Only process 1 can add and remove workers\"\n    end\nend\n\n# Test the following addprocs error conditions\n# - invalid host name - github issue #20372\n# - julia exe exiting with an error\n# - timeout reading host:port from worker stdout\n# - host:port not found in worker stdout in the first 1000 lines\n\nstruct ErrorSimulator <: ClusterManager\n    mode\nend\n\nfunction launch(manager::ErrorSimulator, params::Dict, launched::Array, c::Condition)\n    exename = params[:exename]\n    dir = params[:dir]\n\n    cmd = `$(Base.julia_cmd(exename)) --startup-file=no`\n    if manager.mode == :timeout\n        cmd = `$cmd -e \"sleep(10)\"`\n    elseif manager.mode == :ntries\n        cmd = `$cmd -e \"[println(x) for x in 1:1001]\"`\n    elseif manager.mode == :exit\n        cmd = `$cmd -e \"exit(-1)\"`\n    else\n        error(\"Unknown mode\")\n    end\n    io = open(detach(setenv(cmd, dir=dir)))\n\n    wconfig = WorkerConfig()\n    wconfig.process = io\n    wconfig.io = io.out\n    push!(launched, wconfig)\n    notify(c)\nend\n\ntestruns = Any[]\n\nif DoFullTest\n    append!(testruns, [(()->addprocs_with_testenv([\"errorhost20372\"]), \"Unable to read host:port string from worker. Launch command exited with error?\", ())])\nend\n\nappend!(testruns, [\n    (()->addprocs_with_testenv(ErrorSimulator(:exit)), \"Unable to read host:port string from worker. Launch command exited with error?\", ()),\n    (()->addprocs_with_testenv(ErrorSimulator(:ntries)), \"Unexpected output from worker launch command. Host:port string not found.\", ()),\n    (()->addprocs_with_testenv(ErrorSimulator(:timeout)), \"Timed out waiting to read host:port string from worker.\", (\"JULIA_WORKER_TIMEOUT\"=>\"1\",))\n])\n\nfor (addp_testf, expected_errstr, env) in testruns\n    old_stdout = stdout\n    stdout_out, stdout_in = redirect_stdout()\n    stdout_txt = @async filter!(readlines(stdout_out)) do s\n            return !startswith(s, \"\\tFrom worker startup:\\t\")\n        end\n    try\n        withenv(env...) do\n            addp_testf()\n        end\n        error(\"Unexpected\")\n    catch ex\n        redirect_stdout(old_stdout)\n        close(stdout_in)\n        @test isempty(fetch(stdout_txt))\n        @test isa(ex, CompositeException)\n        @test ex.exceptions[1].task.exception.msg == expected_errstr\n    end\nend\n\n\n# Auto serialization of globals from Main.\n# bitstypes\nglobal v1 = 1\n@test remotecall_fetch(()->v1, id_other) == v1\n@test remotecall_fetch(()->isdefined(Main, :v1), id_other)\nfor i in 2:5\n    global v1 = i\n    @test remotecall_fetch(()->v1, id_other) == i\nend\n\n# non-bitstypes\nglobal v2 = zeros(10)\nfor i in 1:5\n    v2[i] = i\n    @test remotecall_fetch(()->v2, id_other) == v2\nend\n\n# Different global bindings to the same object\nglobal v3 = fill(1., 10)\nglobal v4 = v3\n@test remotecall_fetch(()->v3, id_other) == remotecall_fetch(()->v4, id_other)\n@test remotecall_fetch(()->isdefined(Main, :v3), id_other)\n@test remotecall_fetch(()->isdefined(Main, :v4), id_other)\n\n# Global references to Types and Modules should work if they are locally defined\nglobal v5 = Int\nglobal v6 = Distributed\n@test remotecall_fetch(()->v5, id_other) === Int\n@test remotecall_fetch(()->v6, id_other) === Distributed\n\nstruct FooStructLocal end\nmodule FooModLocal end\nv5 = FooStructLocal\nv6 = FooModLocal\n@test_throws RemoteException remotecall_fetch(()->v5, id_other)\n@test_throws RemoteException remotecall_fetch(()->v6, id_other)\n\n@everywhere struct FooStructEverywhere end\n@everywhere module FooModEverywhere end\nv5 = FooStructEverywhere\nv6 = FooModEverywhere\n@test remotecall_fetch(()->v5, id_other) === FooStructEverywhere\n@test remotecall_fetch(()->v6, id_other) === FooModEverywhere\n\n# hash value same but different object instance\nv7 = ones(10)\noid1 = objectid(v7)\nhval1 = hash(v7)\n@test v7 == @fetchfrom id_other v7\nremote_oid1 = @fetchfrom id_other objectid(v7)\n\nv7 = ones(10)\n@test oid1 != objectid(v7)\n@test hval1 == hash(v7)\n@test remote_oid1 != @fetchfrom id_other objectid(v7)\n\n\n# Github issue #31252\nv31252 = :a\n@test :a == @fetchfrom id_other v31252\n\nv31252 = :b\n@test :b == @fetchfrom id_other v31252\n\nv31252 = :a\n@test :a == @fetchfrom id_other v31252\n\n\n# Test that a global is not being repeatedly serialized when\n# a) referenced multiple times in the closure\n# b) hash value has not changed.\n\n@everywhere begin\n    using Serialization\n    global testsercnt_d = Dict()\n    mutable struct TestSerCnt\n        v\n    end\n    import Base.hash, Base.==\n    hash(x::TestSerCnt, h::UInt) = hash(hash(x.v), h)\n    ==(x1::TestSerCnt, x2::TestSerCnt) = (x1.v == x2.v)\n\n    function Serialization.serialize(s::AbstractSerializer, t::TestSerCnt)\n        Serialization.serialize_type(s, TestSerCnt)\n        serialize(s, t.v)\n        global testsercnt_d\n        cnt = get!(testsercnt_d, objectid(t), 0)\n        testsercnt_d[objectid(t)] = cnt+1\n    end\n\n    Serialization.deserialize(s::AbstractSerializer, ::Type{TestSerCnt}) = TestSerCnt(deserialize(s))\nend\n\n# hash value of tsc is not changed\nglobal tsc = TestSerCnt(zeros(10))\nfor i in 1:5\n    remotecall_fetch(()->tsc, id_other)\nend\n# should have been serialized only once\n@test testsercnt_d[objectid(tsc)] == 1\n\n# hash values are changed\nn=5\ntestsercnt_d[objectid(tsc)] = 0\nfor i in 1:n\n    tsc.v[i] = i\n    remotecall_fetch(()->tsc, id_other)\nend\n# should have been serialized as many times as the loop\n@test testsercnt_d[objectid(tsc)] == n\n\n# Multiple references in a closure should be serialized only once.\nglobal mrefs = TestSerCnt(fill(1.,10))\n@test remotecall_fetch(()->(mrefs.v, 2*mrefs.v, 3*mrefs.v), id_other) == (fill(1.,10), fill(2.,10), fill(3.,10))\n@test testsercnt_d[objectid(mrefs)] == 1\n\n\n# nested anon functions\nglobal f1 = x->x\nglobal f2 = x->f1(x)\nv = rand()\n@test remotecall_fetch(f2, id_other, v) == v\n@test remotecall_fetch(x->f2(x), id_other, v) == v\n\n# consts\nconst c1 = fill(1., 10)\n@test remotecall_fetch(()->c1, id_other) == c1\n@test remotecall_fetch(()->isconst(Main, :c1), id_other)\n\n# Test same calls with local vars\nfunction wrapped_var_ser_tests()\n    # bitstypes\n    local lv1 = 1\n    @test remotecall_fetch(()->lv1, id_other) == lv1\n    @test !remotecall_fetch(()->isdefined(Main, :lv1), id_other)\n    for i in 2:5\n        lv1 = i\n        @test remotecall_fetch(()->lv1, id_other) == i\n    end\n\n    # non-bitstypes\n    local lv2 = zeros(10)\n    for i in 1:5\n        lv2[i] = i\n        @test remotecall_fetch(()->lv2, id_other) == lv2\n    end\n\n    # nested anon functions\n    local lf1 = x->x\n    local lf2 = x->lf1(x)\n    v = rand()\n    @test remotecall_fetch(lf2, id_other, v) == v\n    @test remotecall_fetch(x->lf2(x), id_other, v) == v\nend\n\nwrapped_var_ser_tests()\n\n# Test internal data structures being cleaned up upon gc.\nglobal ids_cleanup = fill(1., 6)\nglobal ids_func = ()->ids_cleanup\n\nclust_ser = (Distributed.worker_from_id(id_other)).w_serializer\n@test remotecall_fetch(ids_func, id_other) == ids_cleanup\n\n# TODO Add test for cleanup from `clust_ser.glbs_in_tnobj`\n\n# reported github issues - Mostly tests with globals and various distributed macros\n#2669, #5390\nv2669=10\n@test fetch(@spawnat :any (1+v2669)) == 11\n\n#12367\nrefs = []\nif true\n    n = 10\n    for p in procs()\n        push!(refs, @spawnat p begin\n            @sync for i in 1:n\n                nothing\n            end\n        end)\n    end\nend\nforeach(wait, refs)\n\n#6760\nif true\n    a = 2\n    x = @distributed (vcat) for k=1:2\n        sin(a)\n    end\nend\n@test x == map(_->sin(2), 1:2)\n\nlet thrown = false\n    try\n        remotecall_fetch(sqrt, 2, -1)\n    catch e\n        thrown = true\n        local b = IOBuffer()\n        showerror(b, e)\n        @test occursin(\"sqrt will only return\", String(take!(b)))\n    end\n    @test thrown\nend\n\n# issue #34333\nlet\n    @test fetch(remotecall(Float64, id_other, 1)) == Float64(1)\n    @test fetch(remotecall_wait(Float64, id_other, 1)) == Float64(1)\n    @test remotecall_fetch(Float64, id_other, 1) == Float64(1)\nend\n\n#19463\nfunction foo19463()\n    w1 = workers()[1]\n    w2 = workers()[2]\n    w3 = workers()[3]\n\n    b1 = () -> 1\n    b2 = () -> fetch(@spawnat w1 b1()) + 1\n    b3 = () -> fetch(@spawnat w2 b2()) + 1\n    b4 = () -> fetch(@spawnat w3 b3()) + 1\n    b4()\nend\n@test foo19463() == 4\n\n# Testing clear!\nfunction setup_syms(n, pids)\n    syms = []\n    for i in 1:n\n        symstr = string(\"clrtest\", randstring())\n        sym = Symbol(symstr)\n        eval(:(global $sym = rand()))\n        for p in pids\n            eval(:(@test $sym == remotecall_fetch(()->$sym, $p)))\n            eval(:(@test remotecall_fetch(isdefined, $p, Main, Symbol($symstr))))\n        end\n        push!(syms, sym)\n    end\n    syms\nend\n\nfunction test_clear(syms, pids)\n    for p in pids\n        for sym in syms\n            remote_val = remotecall_fetch(()->getfield(Main, sym), p)\n            @test remote_val === nothing\n            @test remote_val != getfield(Main, sym)\n        end\n    end\nend\n\nsyms = setup_syms(1, [id_other])\nclear!(syms[1], id_other)\ntest_clear(syms, [id_other])\n\nsyms = setup_syms(1, workers())\nclear!(syms[1], workers())\ntest_clear(syms, workers())\n\nsyms = setup_syms(3, [id_other])\nclear!(syms, id_other)\ntest_clear(syms, [id_other])\n\nsyms = setup_syms(3, workers())\nclear!(syms, workers())\ntest_clear(syms, workers())\n\n# Test partial recovery from a deserialization error in CapturedException\ntry\n    expr = quote\n                mutable struct DontExistOn1\n                    x\n                end\n                throw(BoundsError(DontExistOn1(1), 1))\n           end\n\n    remotecall_fetch(()->eval(expr), id_other)\n    error(\"unexpected\")\ncatch ex\n    @test isa(ex.captured.ex.exceptions[1].ex, ErrorException)\n    @test occursin(\"BoundsError\", ex.captured.ex.exceptions[1].ex.msg)\n    @test ex.captured.ex.exceptions[2].ex == UndefVarError(:DontExistOn1)\nend\n\nlet\n    # creates a new worker in a different folder and tries to include file\n    tmp_dir = mktempdir()\n    tmp_dir2 = joinpath(tmp_dir, \"2\")\n    tmp_file = joinpath(tmp_dir2, \"testfile\")\n    tmp_file2 = joinpath(tmp_dir2, \"testfile2\")\n    proc = addprocs_with_testenv(1, dir=tmp_dir)\n    try\n        mkdir(tmp_dir2)\n        write(tmp_file, \"23.32 + 32 + myid() + include(\\\"testfile2\\\")\")\n        write(tmp_file2, \"myid() * 2\")\n        function test_include_fails_to_open_file(fname)\n            try\n                include(fname)\n            catch exc\n                path = joinpath(@__DIR__, fname)\n                @test exc isa SystemError\n                @test exc.prefix == \"opening file $(repr(path))\"\n            end\n        end\n        test_include_fails_to_open_file(\"testfile\")\n        test_include_fails_to_open_file(\"testfile2\")\n        test_include_fails_to_open_file(joinpath(\"2\", \"testfile2\"))\n        @test include(tmp_file) == 58.32\n        @test remotecall_fetch(include, proc[1], joinpath(\"2\", \"testfile\")) == 55.32 + proc[1] * 3\n    finally\n        rmprocs(proc)\n        rm(tmp_file, force=true)\n        rm(tmp_file2, force=true)\n        rm(tmp_dir2, force=true)\n        #rm(tmp_dir, force=true)\n    end\nend\n# cookie and command line option `--worker` tests. remove workers, set cookie and test\nstruct WorkerArgTester <: ClusterManager\n    worker_opt\n    write_cookie\nend\n\nfunction launch(manager::WorkerArgTester, params::Dict, launched::Array, c::Condition)\n    dir = params[:dir]\n    exename = params[:exename]\n    exeflags = params[:exeflags]\n\n    cmd = `$exename $exeflags --bind-to $(Distributed.LPROC.bind_addr) $(manager.worker_opt)`\n    cmd = pipeline(detach(setenv(cmd, dir=dir)))\n    io = open(cmd, \"r+\")\n    manager.write_cookie && Distributed.write_cookie(io)\n\n    wconfig = WorkerConfig()\n    wconfig.process = io\n    wconfig.io = io.out\n    push!(launched, wconfig)\n\n    notify(c)\nend\nmanage(::WorkerArgTester, ::Integer, ::WorkerConfig, ::Symbol) = nothing\n\nnprocs()>1 && rmprocs(workers())\n\nnpids = addprocs_with_testenv(WorkerArgTester(`--worker`, true))\n@test remotecall_fetch(myid, npids[1]) == npids[1]\nrmprocs(npids)\n\ncluster_cookie(\"\")  # An empty string is a valid cookie\nnpids = addprocs_with_testenv(WorkerArgTester(`--worker=`, false))\n@test remotecall_fetch(myid, npids[1]) == npids[1]\nrmprocs(npids)\n\ncluster_cookie(\"foobar\") # custom cookie\nnpids = addprocs_with_testenv(WorkerArgTester(`--worker=foobar`, false))\n@test remotecall_fetch(myid, npids[1]) == npids[1]\n\n# tests for start_worker options to retain stdio (issue #31035)\nstruct RetainStdioTester <: ClusterManager\n    close_stdin::Bool\n    stderr_to_stdout::Bool\nend\n\nfunction launch(manager::RetainStdioTester, params::Dict, launched::Array, c::Condition)\n    dir = params[:dir]\n    exename = params[:exename]\n    exeflags = params[:exeflags]\n\n    jlcmd = \"using Distributed; start_worker(\\\"\\\"; close_stdin=$(manager.close_stdin), stderr_to_stdout=$(manager.stderr_to_stdout));\"\n    cmd = detach(setenv(`$exename $exeflags --bind-to $(Distributed.LPROC.bind_addr) -e $jlcmd`, dir=dir))\n    proc = open(cmd, \"r+\")\n\n    wconfig = WorkerConfig()\n    wconfig.process = proc\n    wconfig.io = proc.out\n    push!(launched, wconfig)\n\n    notify(c)\nend\nmanage(::RetainStdioTester, ::Integer, ::WorkerConfig, ::Symbol) = nothing\n\n\nnprocs()>1 && rmprocs(workers())\ncluster_cookie(\"\")\n\nfor close_stdin in (true, false), stderr_to_stdout in (true, false)\n    local npids = addprocs_with_testenv(RetainStdioTester(close_stdin,stderr_to_stdout))\n    @test remotecall_fetch(myid, npids[1]) == npids[1]\n    @test close_stdin != remotecall_fetch(()->isopen(stdin), npids[1])\n    @test stderr_to_stdout == remotecall_fetch(()->(stderr === stdout), npids[1])\n    rmprocs(npids)\nend\n\n# Issue # 22865\n# Must be run on a new cluster, i.e., all workers must be in the same state.\n@assert nprocs() == 1\np1,p2 = addprocs_with_testenv(2)\n@everywhere f22865(p) = remotecall_fetch(x->x.*2, p, fill(1.,2))\n@test fill(2.,2) == remotecall_fetch(f22865, p1, p2)\nrmprocs(p1, p2)\n\nfunction reuseport_tests()\n    # Run the test on all processes.\n    results = asyncmap(procs()) do p\n        remotecall_fetch(p) do\n            ports_lower = []        # ports of pids lower than myid()\n            ports_higher = []       # ports of pids higher than myid()\n            for w in Distributed.PGRP.workers\n                w.id == myid() && continue\n                port = Sockets._sockname(w.r_stream, true)[2]\n                if (w.id == 1)\n                    # master connects to workers\n                    push!(ports_higher, port)\n                elseif w.id < myid()\n                    push!(ports_lower, port)\n                elseif w.id > myid()\n                    push!(ports_higher, port)\n                end\n            end\n            @assert (length(ports_lower) + length(ports_higher)) == nworkers()\n            for portset in [ports_lower, ports_higher]\n                if (length(portset) > 0) && (length(unique(portset)) != 1)\n                    @warn \"SO_REUSEPORT TESTS FAILED. UNSUPPORTED/OLDER UNIX VERSION?\"\n                    return 0\n                end\n            end\n            return myid()\n        end\n    end\n\n    # Ensure that the code has indeed been successfully executed everywhere\n    @test all(in(results), procs())\nend\n\n# Test that the client port is reused. SO_REUSEPORT may not be supported on\n# all UNIX platforms, Linux kernels prior to 3.9 and older versions of OSX\n@assert nprocs() == 1\naddprocs_with_testenv(4; lazy=false)\nif ccall(:jl_has_so_reuseport, Int32, ()) == 1\n    reuseport_tests()\nelse\n    @info \"SO_REUSEPORT is unsupported, skipping reuseport tests\"\nend\n\n# issue #27933\na27933 = :_not_defined_27933\n@test remotecall_fetch(()->a27933, first(workers())) === a27933\n\n# PR #28651\nfor T in (UInt8, Int8, UInt16, Int16, UInt32, Int32, UInt64)\n    local n = @distributed (+) for i in Base.OneTo(T(10))\n        i\n    end\n    @test n == 55\nend\n\n# issue #28966\nlet code = \"\"\"\n    import Distributed\n    Distributed.addprocs(1)\n    Distributed.@everywhere f() = myid()\n    for w in Distributed.workers()\n        @assert Distributed.remotecall_fetch(f, w) == w\n    end\n    \"\"\"\n    @test success(`$(Base.julia_cmd()) --startup-file=no -e $code`)\nend\n\n# PR 32431: tests for internal Distributed.head_and_tail\nlet (h, t) = Distributed.head_and_tail(1:10, 3)\n    @test h == 1:3\n    @test collect(t) == 4:10\nend\nlet (h, t) = Distributed.head_and_tail(1:10, 0)\n    @test h == []\n    @test collect(t) == 1:10\nend\nlet (h, t) = Distributed.head_and_tail(1:3, 5)\n    @test h == 1:3\n    @test collect(t) == []\nend\nlet (h, t) = Distributed.head_and_tail(1:3, 3)\n    @test h == 1:3\n    @test collect(t) == []\nend\nlet (h, t) = Distributed.head_and_tail(Int[], 3)\n    @test h == []\n    @test collect(t) == []\nend\nlet (h, t) = Distributed.head_and_tail(Int[], 0)\n    @test h == []\n    @test collect(t) == []\nend\n\n# issue #35937\nlet e = @test_throws RemoteException pmap(1) do _\n            wait(@async error(42))\n        end\n    # check that the inner TaskFailedException is correctly formed & can be printed\n    es = sprint(showerror, e.value)\n    @test contains(es, \":\\nTaskFailedException\\nStacktrace:\\n\")\n    @test contains(es, \"\\n\\n    nested task error:\")\n    @test_broken contains(es, \"\\n\\n    nested task error: 42\\n\")\nend\n\n# issue #27429, propagate relative `include` path to workers\n@everywhere include(\"includefile.jl\")\nfor p in procs()\n    @test @fetchfrom(p, i27429) == 27429\nend\n\ninclude(\"splitrange.jl\")\n\n# Run topology tests last after removing all workers, since a given\n# cluster at any time only supports a single topology.\nrmprocs(workers())\ninclude(\"topology.jl\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/PCRE2_jll/src/PCRE2_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/PCRE2_jll.jl\nbaremodule PCRE2_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libpcre2_8\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibpcre2_8_handle = C_NULL\nlibpcre2_8_path = \"\"\n\nif Sys.iswindows()\n    const libpcre2_8 = \"libpcre2-8-0.dll\"\nelseif Sys.isapple()\n    const libpcre2_8 = \"@rpath/libpcre2-8.0.dylib\"\nelse\n    const libpcre2_8 = \"libpcre2-8.so.0\"\nend\n\nfunction __init__()\n    global libpcre2_8_handle = dlopen(libpcre2_8)\n    global libpcre2_8_path = dlpath(libpcre2_8_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libpcre2_8_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libpcre2_8_path() = libpcre2_8_path\n\nend  # module PCRE2_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/nghttp2_jll/src/nghttp2_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/nghttp2_jll.jl\nbaremodule nghttp2_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libnghttp2\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibnghttp2_handle = C_NULL\nlibnghttp2_path = \"\"\n\nif Sys.iswindows()\n    const libnghttp2 = \"libnghttp2-14.dll\"\nelseif Sys.isapple()\n    const libnghttp2 = \"@rpath/libnghttp2.14.dylib\"\nelse\n    const libnghttp2 = \"libnghttp2.so.14\"\nend\n\nfunction __init__()\n    global libnghttp2_handle = dlopen(libnghttp2)\n    global libnghttp2_path = dlpath(libnghttp2_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libnghttp2_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libnghttp2_path() = libnghttp2_path\n\nend  # module nghttp2_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/dSFMT_jll/src/dSFMT_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/dSFMT_jll.jl\n\nbaremodule dSFMT_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libdSFMT\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibdSFMT_handle = C_NULL\nlibdSFMT_path = \"\"\n\nif Sys.iswindows()\n    const libdSFMT = \"libdSFMT.dll\"\nelseif Sys.isapple()\n    const libdSFMT = \"@rpath/libdSFMT.dylib\"\nelse\n    const libdSFMT = \"libdSFMT.so\"\nend\n\nfunction __init__()\n    global libdSFMT_handle = dlopen(libdSFMT)\n    global libdSFMT_path = dlpath(libdSFMT_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libdSFMT_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libdSFMT_path() = libdSFMT_path\n\nend  # module dSFMT_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LibUV_jll/src/LibUV_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/LibUV_jll.jl\n\nbaremodule LibUV_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libuv\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibuv_handle = C_NULL\nlibuv_path = \"\"\n\nif Sys.iswindows()\n    const libuv = \"libuv-2.dll\"\nelseif Sys.isapple()\n    const libuv = \"@rpath/libuv.2.dylib\"\nelse\n    const libuv = \"libuv.so.2\"\nend\n\nfunction __init__()\n    global libuv_handle = dlopen(libuv)\n    global libuv_path = dlpath(libuv_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libuv_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libuv_path() = libuv_path\n\nend  # module LibUV_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/SuiteSparse_jll/src/SuiteSparse_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/SuiteSparse_jll.jl\nbaremodule SuiteSparse_jll\nusing Base, Libdl, OpenBLAS_jll\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libamd, libbtf, libcamd, libccolamd, libcholmod, libcolamd, libklu, libldl, librbio, libspqr, libsuitesparse_wrapper, libsuitesparseconfig, libumfpack\n\n# These get calculated in __init__()\n# Man I can't wait until these are automatically handled by an in-Base JLLWrappers clone.\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibamd_handle = C_NULL\nlibamd_path = \"\"\nlibbtf_handle = C_NULL\nlibbtf_path = \"\"\nlibcamd_handle = C_NULL\nlibcamd_path = \"\"\nlibccolamd_handle = C_NULL\nlibccolamd_path = \"\"\nlibcholmod_handle = C_NULL\nlibcholmod_path = \"\"\nlibcolamd_handle = C_NULL\nlibcolamd_path = \"\"\nlibklu_handle = C_NULL\nlibklu_path = \"\"\nlibldl_handle = C_NULL\nlibldl_path = \"\"\nlibrbio_handle = C_NULL\nlibrbio_path = \"\"\nlibspqr_handle = C_NULL\nlibspqr_path = \"\"\nlibsuitesparse_wrapper_handle = C_NULL\nlibsuitesparse_wrapper_path = \"\"\nlibsuitesparseconfig_handle = C_NULL\nlibsuitesparseconfig_path = \"\"\nlibumfpack_handle = C_NULL\nlibumfpack_path = \"\"\n\nif Sys.iswindows()\n    const libamd = \"libamd.dll\"\n    const libbtf = \"libbtf.dll\"\n    const libcamd = \"libcamd.dll\"\n    const libccolamd = \"libccolamd.dll\"\n    const libcholmod = \"libcholmod.dll\"\n    const libcolamd = \"libcolamd.dll\"\n    const libklu = \"libklu.dll\"\n    const libldl = \"libldl.dll\"\n    const librbio = \"librbio.dll\"\n    const libspqr = \"libspqr.dll\"\n    const libsuitesparse_wrapper = \"libsuitesparse_wrapper.dll\"\n    const libsuitesparseconfig = \"libsuitesparseconfig.dll\"\n    const libumfpack = \"libumfpack.dll\"\nelseif Sys.isapple()\n    const libamd = \"@rpath/libamd.2.dylib\"\n    const libbtf = \"@rpath/libbtf.1.dylib\"\n    const libcamd = \"@rpath/libcamd.2.dylib\"\n    const libccolamd = \"@rpath/libccolamd.2.dylib\"\n    const libcholmod = \"@rpath/libcholmod.3.dylib\"\n    const libcolamd = \"@rpath/libcolamd.2.dylib\"\n    const libklu = \"@rpath/libklu.1.dylib\"\n    const libldl = \"@rpath/libldl.2.dylib\"\n    const librbio = \"@rpath/librbio.2.dylib\"\n    const libspqr = \"@rpath/libspqr.2.dylib\"\n    const libsuitesparse_wrapper = \"@rpath/libsuitesparse_wrapper.dylib\"\n    const libsuitesparseconfig = \"@rpath/libsuitesparseconfig.5.dylib\"\n    const libumfpack = \"@rpath/libumfpack.5.dylib\"\nelse\n    const libamd = \"libamd.so.2\"\n    const libbtf = \"libbtf.so.1\"\n    const libcamd = \"libcamd.so.2\"\n    const libccolamd = \"libccolamd.so.2\"\n    const libcholmod = \"libcholmod.so.3\"\n    const libcolamd = \"libcolamd.so.2\"\n    const libklu = \"libklu.so.1\"\n    const libldl = \"libldl.so.2\"\n    const librbio = \"librbio.so.2\"\n    const libspqr = \"libspqr.so.2\"\n    const libsuitesparse_wrapper = \"libsuitesparse_wrapper.so\"\n    const libsuitesparseconfig = \"libsuitesparseconfig.so.5\"\n    const libumfpack = \"libumfpack.so.5\"\nend\n\nfunction __init__()\n    global libamd_handle = dlopen(libamd)\n    global libamd_path = dlpath(libamd_handle)\n    global libbtf_handle = dlopen(libbtf)\n    global libbtf_path = dlpath(libbtf_handle)\n    global libcamd_handle = dlopen(libcamd)\n    global libcamd_path = dlpath(libcamd_handle)\n    global libccolamd_handle = dlopen(libccolamd)\n    global libccolamd_path = dlpath(libccolamd_handle)\n    global libcholmod_handle = dlopen(libcholmod)\n    global libcholmod_path = dlpath(libcholmod_handle)\n    global libcolamd_handle = dlopen(libcolamd)\n    global libcolamd_path = dlpath(libcolamd_handle)\n    global libklu_handle = dlopen(libklu)\n    global libklu_path = dlpath(libklu_handle)\n    global libldl_handle = dlopen(libldl)\n    global libldl_path = dlpath(libldl_handle)\n    global librbio_handle = dlopen(librbio)\n    global librbio_path = dlpath(librbio_handle)\n    global libspqr_handle = dlopen(libspqr)\n    global libspqr_path = dlpath(libspqr_handle)\n    global libsuitesparse_wrapper_handle = dlopen(libsuitesparse_wrapper)\n    global libsuitesparse_wrapper_path = dlpath(libsuitesparse_wrapper_handle)\n    global libsuitesparseconfig_handle = dlopen(libsuitesparseconfig)\n    global libsuitesparseconfig_path = dlpath(libsuitesparseconfig_handle)\n    global libumfpack_handle = dlopen(libumfpack)\n    global libumfpack_path = dlpath(libumfpack_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libsuitesparse_wrapper_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libamd_path() = libamd_path\nget_libbtf_path() = libbtf_path\nget_libcamd_path() = libcamd_path\nget_libccolamd_path() = libccolamd_path\nget_libcholmod_path() = libcholmod_path\nget_libcolamd_path() = libcolamd_path\nget_libklu_path() = libklu_path\nget_libldl_path() = libldl_path\nget_librbio_path() = librbio_path\nget_libspqr_path() = libspqr_path\nget_libsuitesparse_wrapper_path() = libsuitesparse_wrapper_path\nget_libsuitesparseconfig_path() = libsuitesparseconfig_path\nget_libumfpack_path() = libumfpack_path\n\nend  # module SuiteSparse_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/GMP_jll/src/GMP_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/GMP_jll.jl\nbaremodule GMP_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libgmp, libgmpxx\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibgmp_handle = C_NULL\nlibgmp_path = \"\"\nlibgmpxx_handle = C_NULL\nlibgmpxx_path = \"\"\n\nif Sys.iswindows()\n    const libgmp = \"libgmp-10.dll\"\n    const libgmpxx = \"libgmpxx-4.dll\"\nelseif Sys.isapple()\n    const libgmp = \"@rpath/libgmp.10.dylib\"\n    const libgmpxx = \"@rpath/libgmpxx.4.dylib\"\nelse\n    const libgmp = \"libgmp.so.10\"\n    const libgmpxx = \"libgmpxx.so.4\"\nend\n\nfunction __init__()\n    global libgmp_handle = dlopen(libgmp)\n    global libgmp_path = dlpath(libgmp_handle)\n    global libgmpxx_handle = dlopen(libgmpxx)\n    global libgmpxx_path = dlpath(libgmpxx_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libgmp_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libgmp_path() = libgmp_path\nget_libgmpxx_path() = libgmpxx_path\n\nend  # module GMP_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/MPFR_jll/src/MPFR_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/MPFR_jll.jl\nbaremodule MPFR_jll\nusing Base, Libdl, GMP_jll\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libmpfr\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibmpfr_handle = C_NULL\nlibmpfr_path = \"\"\n\nif Sys.iswindows()\n    const libmpfr = \"libmpfr-6.dll\"\nelseif Sys.isapple()\n    const libmpfr = \"@rpath/libmpfr.6.dylib\"\nelse\n    const libmpfr = \"libmpfr.so.6\"\nend\n\nfunction __init__()\n    global libmpfr_handle = dlopen(libmpfr)\n    global libmpfr_path = dlpath(libmpfr_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libmpfr_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libmpfr_path() = libmpfr_path\n\nend  # module MPFR_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/libLLVM_jll/src/libLLVM_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/libLLVM_jll.jl\n\nbaremodule libLLVM_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libLLVM\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibLLVM_handle = C_NULL\nlibLLVM_path = \"\"\n\nif Sys.iswindows()\n    const libLLVM = \"LLVM.dll\"\nelseif Sys.isapple()\n    const libLLVM = \"@rpath/libLLVM.dylib\"\nelse\n    const libLLVM = \"libLLVM-11jl.so\"\nend\n\nfunction __init__()\n    global libLLVM_handle = dlopen(libLLVM)\n    global libLLVM_path = dlpath(libLLVM_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libLLVM_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libLLVM_path() = libLLVM_path\n\nend  # module libLLVM_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/Zlib_jll/src/Zlib_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/Zlib_jll.jl\nbaremodule Zlib_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libz\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibz_handle = C_NULL\nlibz_path = \"\"\n\nif Sys.iswindows()\n    const libz = \"libz.dll\"\nelseif Sys.isapple()\n    const libz = \"@rpath/libz.1.dylib\"\nelse\n    const libz = \"libz.so.1\"\nend\n\nfunction __init__()\n    global libz_handle = dlopen(libz)\n    global libz_path = dlpath(libz_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libz_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libz_path() = libz_path\n\nend  # module Zlib_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/MbedTLS_jll/src/MbedTLS_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/MbedTLS_jll.jl\n\nbaremodule MbedTLS_jll\nusing Base, Libdl\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libmbedcrypto, libmbedtls, libmbedx509\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibmbedcrypto_handle = C_NULL\nlibmbedcrypto_path = \"\"\nlibmbedtls_handle = C_NULL\nlibmbedtls_path = \"\"\nlibmbedx509_handle = C_NULL\nlibmbedx509_path = \"\"\n\nif Sys.iswindows()\n    const libmbedcrypto = \"libmbedcrypto.dll\"\n    const libmbedtls = \"libmbedtls.dll\"\n    const libmbedx509 = \"libmbedx509.dll\"\nelseif Sys.isapple()\n    const libmbedcrypto = \"@rpath/libmbedcrypto.5.dylib\"\n    const libmbedtls = \"@rpath/libmbedtls.13.dylib\"\n    const libmbedx509 = \"@rpath/libmbedx509.1.dylib\"\nelse\n    const libmbedcrypto = \"libmbedcrypto.so.5\"\n    const libmbedtls = \"libmbedtls.so.13\"\n    const libmbedx509 = \"libmbedx509.so.1\"\nend\n\nfunction __init__()\n    global libmbedcrypto_handle = dlopen(libmbedcrypto)\n    global libmbedcrypto_path = dlpath(libmbedcrypto_handle)\n    global libmbedtls_handle = dlopen(libmbedtls)\n    global libmbedtls_path = dlpath(libmbedtls_handle)\n    global libmbedx509_handle = dlopen(libmbedx509)\n    global libmbedx509_path = dlpath(libmbedx509_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libmbedtls_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libmbedcrypto_path() =libmbedcrypto_path\nget_libmbedtls_path() = libmbedtls_path\nget_libmbedx509_path() = libmbedx509_path\n\nend  # module MbedTLS_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/CompilerSupportLibraries_jll/src/CompilerSupportLibraries_jll.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n## dummy stub for https://github.com/JuliaBinaryWrappers/CompilerSupportLibraries_jll.jl\n\nbaremodule CompilerSupportLibraries_jll\nusing Base, Libdl, Base.BinaryPlatforms\nBase.Experimental.@compiler_options compile=min optimize=0 infer=false\n\nconst PATH_list = String[]\nconst LIBPATH_list = String[]\n\nexport libgfortran, libstdcxx, libgomp\n\n# These get calculated in __init__()\nconst PATH = Ref(\"\")\nconst LIBPATH = Ref(\"\")\nartifact_dir = \"\"\nlibgfortran_handle = C_NULL\nlibgfortran_path = \"\"\nlibstdcxx_handle = C_NULL\nlibstdcxx_path = \"\"\nlibgomp_handle = C_NULL\nlibgomp_path = \"\"\n\nif Sys.iswindows()\n    if arch(HostPlatform()) == \"x86_64\"\n        const libgcc_s = \"libgcc_s_seh-1.dll\"\n    else\n        const libgcc_s = \"libgcc_s_sjlj-1.dll\"\n    end\n    const libgfortran = string(\"libgfortran-\", libgfortran_version(HostPlatform()).major, \".dll\")\n    const libstdcxx = \"libstdc++-6.dll\"\n    const libgomp = \"libgomp-1.dll\"\nelseif Sys.isapple()\n    if arch(HostPlatform()) == \"aarch64\"\n        const libgcc_s = \"@rpath/libgcc_s.2.dylib\"\n    else\n        const libgcc_s = \"@rpath/libgcc_s.1.dylib\"\n    end\n    const libgfortran = string(\"@rpath/\", \"libgfortran.\", libgfortran_version(HostPlatform()).major, \".dylib\")\n    const libstdcxx = \"@rpath/libstdc++.6.dylib\"\n    const libgomp = \"@rpath/libgomp.1.dylib\"\nelse\n    const libgcc_s = \"libgcc_s.so.1\"\n    const libgfortran = string(\"libgfortran.so.\", libgfortran_version(HostPlatform()).major)\n    const libstdcxx = \"libstdc++.so.6\"\n    const libgomp = \"libgomp.so.1\"\nend\n\nfunction __init__()\n    global libgcc_s_handle = dlopen(libgcc_s)\n    global libgcc_s_path = dlpath(libgcc_s_handle)\n    global libgfortran_handle = dlopen(libgfortran)\n    global libgfortran_path = dlpath(libgfortran_handle)\n    global libstdcxx_handle = dlopen(libstdcxx)\n    global libstdcxx_path = dlpath(libstdcxx_handle)\n    global libgomp_handle = dlopen(libgomp)\n    global libgomp_path = dlpath(libgomp_handle)\n    global artifact_dir = dirname(Sys.BINDIR)\n    LIBPATH[] = dirname(libgcc_s_path)\n    push!(LIBPATH_list, LIBPATH[])\nend\n\n# JLLWrappers API compatibility shims.  Note that not all of these will really make sense.\n# For instance, `find_artifact_dir()` won't actually be the artifact directory, because\n# there isn't one.  It instead returns the overall Julia prefix.\nis_available() = true\nfind_artifact_dir() = artifact_dir\ndev_jll() = error(\"stdlib JLLs cannot be dev'ed\")\nbest_wrapper = nothing\nget_libgfortran_path() = libgfortran_path\nget_libstdcxx_path() = libstdcxx_path\nget_libgomp_path() = libgomp_path\n\nend  # module CompilerSupportLibraries_jll\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/test/ccall.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nimport Base.copy, Base.==\nusing Random\nusing InteractiveUtils: code_llvm\n\nimport Libdl\n\n# for cfunction_closure\ninclude(\"testenv.jl\")\n\nconst libccalltest = \"libccalltest\"\n\nconst verbose = false\nccall((:set_verbose, libccalltest), Cvoid, (Int32,), verbose)\n\n@eval function cvarargs()\n    strp = Ref{Ptr{Cchar}}(0)\n    fmt = \"%3.1f\"\n    len = ccall(:asprintf, Cint, (Ptr{Ptr{Cchar}}, Cstring, Cfloat...), strp, fmt, 0.1)\n    str = unsafe_string(strp[], len)\n    Libc.free(strp[])\n    return str\nend\n@test cvarargs() == \"0.1\"\n\n\n# test multiple-type vararg handling (there's no syntax for this currently)\n@eval function foreign_varargs()\n    strp = Ref{Ptr{Cchar}}(0)\n    fmt = \"hi+%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f\\n\"\n    len = $(Expr(:foreigncall, :(:asprintf), Cint,\n        Core.svec(Ptr{Ptr{Cchar}}, Cstring,\n            UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,\n            Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cfloat),\n            2, :(:cdecl),\n            :(Base.unsafe_convert(Ptr{Ptr{Cchar}}, strp)), :(Base.unsafe_convert(Cstring, fmt)),\n            0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,\n            Cfloat(1.1), Cfloat(2.2), Cfloat(3.3), Cfloat(4.4), Cfloat(5.5), Cfloat(6.6), Cfloat(7.7), Cfloat(8.8), Cfloat(9.9),\n            :strp, :fmt))\n    str = unsafe_string(strp[], len)\n    Libc.free(strp[])\n    return str\nend\n@test foreign_varargs() == \"hi+1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-1.1-2.2-3.3-4.4-5.5-6.6-7.7-8.8-9.9\\n\"\n\n\n# Test for proper argument register truncation\nccall_test_func(x) = ccall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n@test ccall_test_func(3) == 1\n@test ccall_test_func(259) == 1\n\n\n# Test for proper round-trip of Ref{T} type\nfunction gen_ccall_echo(x, T, U, ret=nothing)\n    # Construct a noninline function to do all the work, this is necessary\n    # to make sure object x is still valid (rooted as argument)\n    # when loading the pointer.\n    # This works as long as we still keep the argument\n    # rooted but might fail if we are smarter about eliminating dead root.\n\n    # `eval` in global scope to make sure the function is not a closure\n    func_ex = :(ccall((:test_echo_p, libccalltest), $T, ($U,), x))\n    # It is not allowed to allocate after the ccall returns\n    # and before calling `ret`.\n    if ret !== nothing\n        func_ex = :($ret($func_ex))\n    end\n    @gensym func_name\n    @eval @noinline $func_name(x) = $func_ex\n    :($func_name($(esc(x))))\nend\n\nmacro ccall_echo_func(x, T, U)\n    gen_ccall_echo(x, T, U)\nend\nmacro ccall_echo_load(x, T, U)\n    gen_ccall_echo(x, T, U, :unsafe_load)\nend\nmacro ccall_echo_objref(x, T, U)\n    gen_ccall_echo(x, :(Ptr{$T}), U, :unsafe_pointer_to_objref)\nend\n\nmutable struct IntLike\n    x::Int\nend\n@test @ccall_echo_load(132, Ptr{Int}, Ref{Int}) === 132\n@test @ccall_echo_load(Ref(921), Ptr{Int}, Ref{Int}) === 921\n@test @ccall_echo_load(IntLike(993), Ptr{Int}, Ref{IntLike}) === 993\n@test @ccall_echo_load(IntLike(881), Ptr{IntLike}, Ref{IntLike}).x === 881\n@test @ccall_echo_func(532, Int, Int) === 532\nif Sys.WORD_SIZE == 64\n    # this test is valid only for x86_64 and win64\n    @test @ccall_echo_func(164, IntLike, Int).x === 164\nend\n@test @ccall_echo_func(IntLike(828), Int, IntLike) === 828\n@test @ccall_echo_func(913, Any, Any) === 913\n@test @ccall_echo_objref(553, Ptr{Any}, Any) === 553\n@test @ccall_echo_func(124, Ref{Int}, Any) === 124\n@test @ccall_echo_load(422, Ptr{Any}, Ref{Any}) === 422\n@test @ccall_echo_load([383], Ptr{Int}, Ref{Int}) === 383\n@test @ccall_echo_load(Ref([144,172],2), Ptr{Int}, Ref{Int}) === 172\n# @test @ccall_echo_load(Ref([8],1,1), Ptr{Int}, Ref{Int}) === 8\n\n\n## Tests for passing and returning structs\n\nlet a, ci_ary, x\n    a = 20 + 51im\n\n    x = ccall((:ctest, libccalltest), Complex{Int}, (Complex{Int},), a)\n\n    @test x == a + 1 - 2im\n\n    ci_ary = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cptest, libccalltest), Ptr{Complex{Int}},\n                          (Ptr{Complex{Int}},), ci_ary))\n\n    @test x == a + 1 - 2im\n    @test a == 20 + 51im\n\n    x = ccall((:cptest_static, libccalltest), Ptr{Complex{Int}}, (Ref{Complex{Int}},), a)\n    @test unsafe_load(x) == a\n    Libc.free(convert(Ptr{Cvoid}, x))\nend\n\nlet a, b, x\n    a = 2.84 + 5.2im\n\n    x = ccall((:cgtest, libccalltest), ComplexF64, (ComplexF64,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cgptest, libccalltest), Ptr{ComplexF64}, (Ptr{ComplexF64},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 2.84 + 5.2im\nend\n\nlet a, b, x\n    a = 3.34f0 + 53.2f0im\n\n    x = ccall((:cftest, libccalltest), ComplexF32, (ComplexF32,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cfptest, libccalltest), Ptr{ComplexF32}, (Ptr{ComplexF32},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 3.34f0 + 53.2f0im\nend\n\n\n## Tests for native Julia data types\n\nlet a\n    a = 2.84 + 5.2im\n\n    @test_throws MethodError ccall((:cptest, libccalltest), Ptr{Complex{Int}}, (Ptr{Complex{Int}},), a)\nend\n\n\n## Tests for various sized data types (ByVal)\n\nmutable struct Struct1\n    x::Float32\n    y::Float64\nend\nstruct Struct1I\n    x::Float32\n    y::Float64\nend\ncopy(a::Struct1) = Struct1(a.x, a.y)\ncopy(a::Struct1I) = a\n\nfunction test_struct1(::Type{Struct}) where {Struct}\n    a = Struct(352.39422f23, 19.287577)\n    b = Float32(123.456)\n\n    a2 = copy(a)\n    if Struct === Struct1\n        x = ccall((:test_1, libccalltest), Struct1, (Struct1, Float32), a2, b)\n    else\n        x = ccall((:test_1, libccalltest), Struct1I, (Struct1I, Float32), a2, b)\n    end\n\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n\n    @test x.x \u2248 a.x + 1*b\n    @test x.y \u2248 a.y - 2*b\nend\ntest_struct1(Struct1)\ntest_struct1(Struct1I)\n\nlet a, b, x\n    a = Struct1(352.39422f23, 19.287577)\n    b = Float32(123.456)\n    a2 = copy(a)\n\n    x = ccall((:test_1long_a, libccalltest), Struct1, (Int, Int, Int, Struct1, Float32), 2, 3, 4, a2, b)\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n    @test x.x \u2248 a.x + b + 9\n    @test x.y \u2248 a.y - 2*b\n\n    x = ccall((:test_1long_b, libccalltest), Struct1, (Int, Float64, Int, Struct1, Float32), 2, 3, 4, a2, b)\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n    @test x.x \u2248 a.x + b + 9\n    @test x.y \u2248 a.y - 2*b\n\n    x = ccall((:test_1long_c, libccalltest), Struct1, (Int, Float64, Int, Int, Struct1, Float32), 2, 3, 4, 5, a2, b)\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n    @test x.x \u2248 a.x + b + 14\n    @test x.y \u2248 a.y - 2*b\nend\n\nlet a, b, x, y\n    a = Complex{Int32}(Int32(10),Int32(31))\n    b = Int32(42)\n\n    x = ccall((:test_2a, libccalltest), Complex{Int32}, (Complex{Int32}, Int32), a, b)\n    y = ccall((:test_2b, libccalltest), Complex{Int32}, (Complex{Int32},Int32), a, b)\n\n    @test a == Complex{Int32}(Int32(10),Int32(31))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\nend\n\nlet a, b, x, y, z\n    a = Complex{Int64}(Int64(20),Int64(51))\n    b = Int64(42)\n\n    x = ccall((:test_3a, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    y = ccall((:test_3b, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    z = ccall((:test_128, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n\n    @test a == Complex{Int64}(Int64(20),Int64(51))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\n\n    @test z == a + 1*b\nend\n\nmutable struct Struct4\n    x::Int32\n    y::Int32\n    z::Int32\nend\nstruct Struct4I\n    x::Int32\n    y::Int32\n    z::Int32\nend\n\nfunction test_struct4(::Type{Struct}) where {Struct}\n    a = Struct(-512275808,882558299,-2133022131)\n    b = Int32(42)\n\n    if Struct === Struct4\n        x = ccall((:test_4, libccalltest), Struct4, (Struct4, Int32), a, b)\n    else\n        x = ccall((:test_4, libccalltest), Struct4I, (Struct4I, Int32), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct4(Struct4)\ntest_struct4(Struct4I)\n\nmutable struct Struct5\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\nstruct Struct5I\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\n\nfunction test_struct5(::Type{Struct}) where {Struct}\n    a = Struct(1771319039, 406394736, -1269509787, -745020976)\n    b = Int32(42)\n\n    if Struct === Struct5\n        x = ccall((:test_5, libccalltest), Struct5, (Struct5, Int32), a, b)\n    else\n        x = ccall((:test_5, libccalltest), Struct5I, (Struct5I, Int32), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct5(Struct5)\ntest_struct5(Struct5I)\n\nmutable struct Struct6\n    x::Int64\n    y::Int64\n    z::Int64\nend\nstruct Struct6I\n    x::Int64\n    y::Int64\n    z::Int64\nend\n\nfunction test_struct6(::Type{Struct}) where {Struct}\n    a = Struct(-654017936452753226, -5573248801240918230, -983717165097205098)\n    b = Int64(42)\n\n    if Struct === Struct6\n        x = ccall((:test_6, libccalltest), Struct6, (Struct6, Int64), a, b)\n    else\n        x = ccall((:test_6, libccalltest), Struct6I, (Struct6I, Int64), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct6(Struct6)\ntest_struct6(Struct6I)\n\nmutable struct Struct7\n    x::Int64\n    y::Cchar\nend\nstruct Struct7I\n    x::Int64\n    y::Cchar\nend\n\nfunction test_struct7(::Type{Struct}) where {Struct}\n    a = Struct(-384082741977533896, 'h')\n    b = Int8(42)\n\n    if Struct === Struct7\n        x = ccall((:test_7, libccalltest), Struct7, (Struct7, Int8), a, b)\n    else\n        x = ccall((:test_7, libccalltest), Struct7I, (Struct7I, Int8), a, b)\n    end\n\n    @test x.x == a.x+Int(b)*1\n    @test x.y == a.y-Int(b)*2\nend\ntest_struct7(Struct7)\ntest_struct7(Struct7I)\n\nmutable struct Struct8\n    x::Int32\n    y::Cchar\nend\nstruct Struct8I\n    x::Int32\n    y::Cchar\nend\n\nfunction test_struct8(::Type{Struct}) where {Struct}\n    a = Struct(-384082896, 'h')\n    b = Int8(42)\n\n    if Struct === Struct8\n        r8 = ccall((:test_8, libccalltest), Struct8, (Struct8, Int8), a, b)\n    else\n        r8 = ccall((:test_8, libccalltest), Struct8I, (Struct8I, Int8), a, b)\n    end\n\n    @test r8.x == a.x+b*1\n    @test r8.y == a.y-b*2\nend\ntest_struct8(Struct8)\ntest_struct8(Struct8I)\n\nmutable struct Struct9\n    x::Int32\n    y::Int16\nend\nstruct Struct9I\n    x::Int32\n    y::Int16\nend\n\nfunction test_struct9(::Type{Struct}) where {Struct}\n    a = Struct(-394092996, -3840)\n    b = Int16(42)\n\n    if Struct === Struct9\n        x = ccall((:test_9, libccalltest), Struct9, (Struct9, Int16), a, b)\n    else\n        x = ccall((:test_9, libccalltest), Struct9I, (Struct9I, Int16), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\nend\ntest_struct9(Struct9)\ntest_struct9(Struct9I)\n\nmutable struct Struct10\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\nstruct Struct10I\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\n\nfunction test_struct10(::Type{Struct}) where {Struct}\n    a = Struct('0', '1', '2', '3')\n    b = Int8(2)\n\n    if Struct === Struct10\n        x = ccall((:test_10, libccalltest), Struct10, (Struct10, Int8), a, b)\n    else\n        x = ccall((:test_10, libccalltest), Struct10I, (Struct10I, Int8), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct10(Struct10)\ntest_struct10(Struct10I)\n\nmutable struct Struct11\n    x::ComplexF32\nend\nstruct Struct11I\n    x::ComplexF32\nend\n\nfunction test_struct11(::Type{Struct}) where {Struct}\n    a = Struct(0.8877077f0 + 0.4591081f0im)\n    b = Float32(42)\n\n    if Struct === Struct11\n        x = ccall((:test_11, libccalltest), Struct11, (Struct11, Float32), a, b)\n    else\n        x = ccall((:test_11, libccalltest), Struct11I, (Struct11I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct11(Struct11)\ntest_struct11(Struct11I)\n\nmutable struct Struct12\n    x::ComplexF32\n    y::ComplexF32\nend\nstruct Struct12I\n    x::ComplexF32\n    y::ComplexF32\nend\n\nfunction test_struct12(::Type{Struct}) where {Struct}\n    a = Struct(0.8877077f5 + 0.4591081f2im, 0.0004842868f0 - 6982.3265f3im)\n    b = Float32(42)\n\n    if Struct === Struct12\n        x = ccall((:test_12, libccalltest), Struct12, (Struct12, Float32), a, b)\n    else\n        x = ccall((:test_12, libccalltest), Struct12I, (Struct12I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1 - b*2im\n    @test x.y \u2248 a.y + b*3 - b*4im\nend\ntest_struct12(Struct12)\ntest_struct12(Struct12I)\n\nmutable struct Struct13\n    x::ComplexF64\nend\nstruct Struct13I\n    x::ComplexF64\nend\n\nfunction test_struct13(::Type{Struct}) where {Struct}\n    a = Struct(42968.97560380495 - 803.0576845153616im)\n    b = Float64(42)\n\n    if Struct === Struct13\n        x = ccall((:test_13, libccalltest), Struct13, (Struct13, Float64), a, b)\n    else\n        x = ccall((:test_13, libccalltest), Struct13I, (Struct13I, Float64), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct13(Struct13)\ntest_struct13(Struct13I)\n\nmutable struct Struct14\n    x::Float32\n    y::Float32\nend\nstruct Struct14I\n    x::Float32\n    y::Float32\nend\n\nfunction test_struct14(::Type{Struct}) where {Struct}\n    a = Struct(0.024138331f0, 0.89759064f32)\n    b = Float32(42)\n\n    if Struct === Struct14\n        x = ccall((:test_14, libccalltest), Struct14, (Struct14, Float32), a, b)\n    else\n        x = ccall((:test_14, libccalltest), Struct14I, (Struct14I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct14(Struct14)\ntest_struct14(Struct14I)\n\nmutable struct Struct15\n    x::Float64\n    y::Float64\nend\nstruct Struct15I\n    x::Float64\n    y::Float64\nend\n\nfunction test_struct15(::Type{Struct}) where {Struct}\n    a = Struct(4.180997967273657, -0.404218594294923)\n    b = Float64(42)\n\n    if Struct === Struct15\n        x = ccall((:test_15, libccalltest), Struct15, (Struct15, Float64), a, b)\n    else\n        x = ccall((:test_15, libccalltest), Struct15I, (Struct15I, Float64), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct15(Struct15)\ntest_struct15(Struct15I)\n\nmutable struct Struct16\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\nstruct Struct16I\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\n\nfunction test_struct16(::Type{Struct}, quoteplz = false) where {Struct}\n    a = Struct(0.1604656f0, 0.6297606f0, 0.83588994f0,\n               0.6460273620993535, 0.9472692581106656, 0.47328535437352093)\n    b = Float32(42)\n\n    if Struct === Struct16\n        x = ccall((:test_16, libccalltest), Struct16, (Struct16, Float32), a, b)\n    else\n        if quoteplz\n          x = eval(:(ccall((:test_16, libccalltest), Struct16I, (Struct16I, Float32), $(QuoteNode(a)), Float32(42))))\n        else\n          x = ccall((:test_16, libccalltest), Struct16I, (Struct16I, Float32), a, b)\n        end\n    end\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\n    @test x.z \u2248 a.z + b*3\n    @test x.a \u2248 a.a - b*4\n    @test x.b \u2248 a.b + b*5\n    @test x.c \u2248 a.c - b*6\nend\n\ntest_struct16(Struct16, false)\ntest_struct16(Struct16I, false)\ntest_struct16(Struct16I, true)\n\nmutable struct Struct17\n    a::Int8\n    b::Int16\nend\nstruct Struct17I\n    a::Int8\n    b::Int16\nend\n\nfunction test_struct17(::Type{Struct}) where {Struct}\n    a = Struct(2, 10)\n    b = Int8(2)\n\n    if Struct === Struct17\n        x = ccall((:test_17, libccalltest), Struct17, (Struct17, Int8), a, b)\n    else\n        x = ccall((:test_17, libccalltest), Struct17I, (Struct17I, Int8), a, b)\n    end\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\nend\ntest_struct17(Struct17)\ntest_struct17(Struct17I)\n\nmutable struct Struct18\n    a::Int8\n    b::Int8\n    c::Int8\nend\nstruct Struct18I\n    a::Int8\n    b::Int8\n    c::Int8\nend\n\nfunction test_struct18(::Type{Struct}) where {Struct}\n    a = Struct(2, 10, -3)\n    b = Int8(2)\n\n    if Struct === Struct18\n        x = ccall((:test_18, libccalltest), Struct18, (Struct18, Int8), a, b)\n    else\n        x = ccall((:test_18, libccalltest), Struct18I, (Struct18I, Int8), a, b)\n    end\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\n    @test x.c == a.c + b * 3\nend\ntest_struct18(Struct18)\ntest_struct18(Struct18I)\n\nlet a, b, x\n    a = Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\n    b = Int64(1)\n\n    x = ccall((:test_128, libccalltest), Int128, (Int128, Int64), a, b)\n\n    @test x == a + b*1\n    @test a == Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\nend\n\nmutable struct Struct_Big\n    x::Int\n    y::Int\n    z::Int8\nend\nstruct Struct_BigI\n    x::Int\n    y::Int\n    z::Int8\nend\ncopy(a::Struct_Big) = Struct_Big(a.x, a.y, a.z)\ncopy(a::Struct_BigI) = a\n\nfunction test_struct_big(::Type{Struct}) where {Struct}\n    a = Struct(424,-5,Int8('Z'))\n    a2 = copy(a)\n\n    if Struct == Struct_Big\n        x = ccall((:test_big, libccalltest), Struct_Big, (Struct_Big,), a2)\n    else\n        x = ccall((:test_big, libccalltest), Struct_BigI, (Struct_BigI,), a2)\n    end\n\n    @test a2.x == a.x && a2.y == a.y && a2.z == a.z\n    @test x.x == a.x + 1\n    @test x.y == a.y - 2\n    @test x.z == a.z - Int('A')\nend\ntest_struct_big(Struct_Big)\ntest_struct_big(Struct_BigI)\n\nlet a, a2, x\n    a = Struct_Big(424,-5,Int8('Z'))\n    a2 = copy(a)\n    x = ccall((:test_big_long, libccalltest), Struct_Big, (Int, Int, Int, Struct_Big,), 2, 3, 4, a2)\n    @test a2.x == a.x && a2.y == a.y && a2.z == a.z\n    @test x.x == a.x + 10\n    @test x.y == a.y - 2\n    @test x.z == a.z - Int('A')\nend\n\nconst Struct_huge1a = NTuple{8, Int64}\nconst Struct_huge1b = NTuple{9, Int64}\nconst Struct_huge2a = NTuple{8, Cdouble}\nconst Struct_huge2b = NTuple{9, Cdouble}\nmutable struct Struct_huge3a\n    cf::NTuple{3, Complex{Cfloat}}\n    f7::Cfloat\n    f8::Cfloat\nend\nmutable struct Struct_huge3b\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\nend\nmutable struct Struct_huge3c\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\n    r9::Cfloat\nend\nmutable struct Struct_huge4a\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r8::Cdouble\nend\nmutable struct Struct_huge4b\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r89::Complex{Cdouble}\nend\nconst Struct_huge5a = NTuple{8, Complex{Cint}}\nconst Struct_huge5b = NTuple{9, Complex{Cint}}\n\nfunction verify_huge(init, a, b)\n    @test typeof(init) === typeof(a) === typeof(b)\n    verbose && @show (a, b)\n    # make sure a was unmodified\n    for i = 1:nfields(a)\n        @test getfield(init, i) === getfield(a, i)\n    end\n    # make sure b was modified as expected\n    a1, b1 = getfield(a, 1), getfield(b, 1)\n    while isa(a1, Tuple)\n        @test a1[2:end] === b1[2:end]\n        a1 = a1[1]\n        b1 = b1[1]\n    end\n    if isa(a1, VecElement)\n        a1 = a1.value\n        b1 = b1.value\n    end\n    @test oftype(a1, a1 * 39) === b1\n    for i = 2:nfields(a)\n        @test getfield(a, i) === getfield(b, i)\n    end\nend\nmacro test_huge(i, b, init)\n    f = QuoteNode(Symbol(\"test_huge\", i, b))\n    ty = Symbol(\"Struct_huge\", i, b)\n    return quote\n        let a = $ty($(esc(init))...), f\n            f(b) = ccall(($f, libccalltest), $ty, (Cchar, $ty, Cchar), '0' + $i, a, $b[1])\n            #code_llvm(f, typeof((a,)))\n            verify_huge($ty($(esc(init))...), a, f(a))\n        end\n    end\nend\n@test_huge 1 'a' ((1, 2, 3, 4, 5, 6, 7, 8),)\n@test_huge 1 'b' ((1, 2, 3, 4, 5, 6, 7, 8, 9),)\n@test_huge 2 'a' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0),)\n@test_huge 2 'b' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0),)\n@test_huge 3 'a' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im), 7.0, 8.0)\n@test_huge 3 'b' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0)\n@test_huge 3 'c' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0, 9.0)\n@test_huge 4 'a' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0)\n@test_huge 4 'b' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0 + 10.0im)\n@test_huge 5 'a' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im),)\n@test_huge 5 'b' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im, 17 + 17im),)\n\n## cfunction roundtrip\n\nverbose && Libc.flush_cstdio()\n\nif cfunction_closure\nverbose && println(\"Testing cfunction closures: \")\n\n# helper Type for testing that constructors work\n# with cfucntion and that object identity is preserved\nmutable struct IdentityTestKV{K, V}\n    (T::Type{<:IdentityTestKV})(S) = (@test T === S; T)\nend\n\n@noinline function testclosure(f, a::T, permanent::Bool=false, tt::Type{S}=Any) where {T, S}\n    @nospecialize(f, a, tt)\n    # generic API 1\n    cf = @cfunction $f Ref{T} (Ref{T},)\n    GC.gc()\n    @test cf.ptr != C_NULL\n    @test cf.f === f\n    @test (cf._1 == C_NULL) == permanent\n    @test (cf._2 == C_NULL) == permanent\n    @assert cf === Base.cconvert(Ptr{Cvoid}, cf)\n    GC.@preserve cf begin\n        fptr = Base.unsafe_convert(Ptr{Cvoid}, cf)\n        b = ccall(fptr, Ref{T}, (Ref{T},), a)\n    end\n    # generic API 2\n    cf2 = @cfunction $f Any (Ref{S},)\n    GC.gc()\n    @test cf2.ptr != C_NULL\n    @test cf2.f === f\n    @test (cf2._1 == C_NULL) == permanent\n    @test (cf2._2 == C_NULL) == permanent\n    @assert cf2 === Base.cconvert(Ptr{Cvoid}, cf2)\n    GC.@preserve cf2 begin\n        fptr = Base.unsafe_convert(Ptr{Cvoid}, cf2)\n        b = ccall(fptr, Any, (Ref{S},), a)\n    end\n    return b\nend\n\n# We can't (currently) execute some of these signatures (without compile-all),\n# but we can at least look at some of the generated code\nfunction check_code_trampoline(f, t, n::Int)\n    @nospecialize(f, t)\n    @test Base.return_types(f, t) == Any[Any]\n    llvm = sprint(code_llvm, f, t)\n    @test count(x -> true, eachmatch(r\"@jl_get_cfunction_trampoline\\(\", llvm)) == n\nend\ncheck_code_trampoline(testclosure, (Any, Any, Bool, Type), 2)\ncheck_code_trampoline(testclosure, (Any, Int, Bool, Type{Int}), 2)\ncheck_code_trampoline(testclosure, (Any, String, Bool, Type{String}), 2)\ncheck_code_trampoline(testclosure, (typeof(identity), Any, Bool, Type), 2)\ncheck_code_trampoline(testclosure, (typeof(identity), Int, Bool, Type{Int}), 0)\ncheck_code_trampoline(testclosure, (typeof(identity), String, Bool, Type{String}), 0)\n\nfunction g(i)\n    x = -332210 + i\n    y = \"foo\"\n    a(z) = x\n    b(z) = y\n    c(z) = (y = z)\n    IdentityTestVK{V, K} = IdentityTestKV{K, V}\n    @test IdentityTestVK !== IdentityTestKV\n    @test IdentityTestVK == IdentityTestKV\n    for _ = 1:5\n        @test testclosure(a, 23) == -332210 + i\n        @test testclosure(b, \"bar\") == \"foo\"\n        @test testclosure(c, \"bar\") == \"bar\"\n        @test testclosure(b, \"foo\") == \"bar\"\n        @test testclosure(c, \"foo\") == \"foo\"\n        @test testclosure(identity, IdentityTestKV, true) === IdentityTestKV\n        @test testclosure(identity, IdentityTestVK, true) === IdentityTestVK\n        @test testclosure(IdentityTestKV, IdentityTestKV, true) === IdentityTestKV\n        @test testclosure(IdentityTestVK, IdentityTestVK, false) === IdentityTestVK\n    end\nend\ng(1)\ng(2)\ng(3)\n\nverbose && println(\"Testing cfunction roundtrip: \")\n\ncf64 = 2.84+5.2im\ncf32 = 3.34f0+53.2f0im\nci32 = Complex{Int32}(Int32(10), Int32(31))\nci64 = Complex{Int64}(Int64(20), Int64(51))\ns1 = Struct1(352.39422f23, 19.287577)\n==(a::Struct1, b::Struct1) = (a.x == b.x && a.y == b.y)\n\nfor (t, v) in ((Complex{Int32}, :ci32), (Complex{Int64}, :ci64),\n              (ComplexF32, :cf32), (ComplexF64, :cf64), (Struct1, :s1))\n    fname = Symbol(\"foo\", v)\n    fname1 = Symbol(\"foo1\", v)\n    a = copy(@eval $v)\n    verbose && println(t)\n    verbose && println(\"A: \", a)\n    @eval begin\n        global function $fname1(s::$t)\n            verbose && println(\"B: \", s)\n            @test s == $v\n            @test s === $a\n            global c = s\n            return s\n        end\n        global function $fname1(s)\n            @assert false\n        end\n        global function $fname(s::$t)\n            verbose && println(\"B: \", s)\n            @test s == $v\n            if($(t).mutable)\n                @test !(s === $a)\n            end\n            global c = s\n            return s\n        end\n        global function $fname(s)\n            @assert false\n        end\n    end\n    @eval let a = $a, b\n        b = testclosure($fname1, a, true)\n        verbose && println(\"C: \", b)\n        @test b == $v\n        @test b === a\n        @test b === c\n        let cf = @cfunction($fname1, Ref{$t}, (Ref{$t},))\n            b = ccall(cf, Ref{$t}, (Ref{$t},), a)\n        end\n        verbose && println(\"C: \", b)\n        @test b == $v\n        @test b === a\n        @test b === c\n        let cf = @cfunction($fname, $t, ($t,))\n            b = ccall(cf, $t, ($t,), a)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname1, $t, (Ref{$t},))\n            b = ccall(cf, $t, (Ref{$t},), a)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Ref{$t}, ($t,))\n            b = ccall(cf, Ref{$t}, ($t,), a)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Any, (Ref{$t},))\n            b = ccall(cf, Any, (Ref{$t},), $v)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Any, (Ref{Any},))\n            b = ccall(cf, Any, (Ref{Any},), $v)\n        end\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Ref{AbstractString}, (Ref{Any},))\n            @test_throws TypeError ccall(cf, Any, (Ref{Any},), $v)\n        end\n        let cf = @cfunction($fname, AbstractString, (Ref{Any},))\n            @test_throws TypeError ccall(cf, Any, (Ref{Any},), $v)\n        end\n    end\nend\n\nelse\n\n@test_broken \"cfunction: no support for closures on this platform\"\n\nend\n\n# issue 13031\nfoo13031(x) = Cint(1)\nfoo13031p = @cfunction(foo13031, Cint, (Ref{Tuple{}},))\nccall(foo13031p, Cint, (Ref{Tuple{}},), ())\n\nfoo13031(x,y,z) = z\nfoo13031p = @cfunction(foo13031, Cint, (Ref{Tuple{}}, Ref{Tuple{}}, Cint))\nccall(foo13031p, Cint, (Ref{Tuple{}},Ref{Tuple{}},Cint), (), (), 8)\n\n# issue 26078\n\nunstable26078(x) = x > 0 ? x : \"foo\"\nhandle26078 = @cfunction(unstable26078, Int32, (Int32,))\n@test ccall(handle26078, Int32, (Int32,), 1) == 1\n\n# issue 17219\nfunction ccall_reassigned_ptr(ptr::Ptr{Cvoid})\n    ptr = Libdl.dlsym(Libdl.dlopen(libccalltest), \"test_echo_p\")\n    ccall(ptr, Any, (Any,), \"foo\")\nend\n@test ccall_reassigned_ptr(C_NULL) == \"foo\"\n\n# @threadcall functionality\nthreadcall_test_func(x) =\n    @threadcall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n\n@test threadcall_test_func(3) == 1\n@test threadcall_test_func(259) == 1\n\n# issue 17819\n# NOTE: can't use cfunction or reuse ccalltest Struct methods, as those call into the runtime\n@test @threadcall((:threadcall_args, libccalltest), Cint, (Cint, Cint), 1, 2) == 3\n\nlet n=3\n    tids = Culong[]\n    @sync for i in 1:10^n\n        @async push!(tids, @threadcall(:uv_thread_self, Culong, ()))\n    end\n\n    # The work should not be done on the master thread\n    t0 = ccall(:uv_thread_self, Culong, ())\n    @test length(tids) == 10^n\n    for t in tids\n        @test t != t0\n    end\nend\n\n@test ccall(:jl_getpagesize, Clong, ()) == @threadcall(:jl_getpagesize, Clong, ())\n\n# make sure our malloc/realloc/free adapters are thread-safe and repeatable\nfor i = 1:8\n    ptr = @threadcall(:jl_malloc, Ptr{Cint}, (Csize_t,), sizeof(Cint))\n    @test ptr != C_NULL\n    unsafe_store!(ptr, 3)\n    @test unsafe_load(ptr) == 3\n    ptr = @threadcall(:jl_realloc, Ptr{Cint}, (Ptr{Cint}, Csize_t,), ptr, 2 * sizeof(Cint))\n    @test ptr != C_NULL\n    unsafe_store!(ptr, 4, 2)\n    @test unsafe_load(ptr, 1) == 3\n    @test unsafe_load(ptr, 2) == 4\n    @threadcall(:jl_free, Cvoid, (Ptr{Cint},), ptr)\nend\n\n# Pointer finalizer (issue #15408)\nlet A = [1]\n    ccall((:set_c_int, libccalltest), Cvoid, (Cint,), 1)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == 1\n    finalizer(cglobal((:finalizer_cptr, libccalltest), Cvoid), A)\n    finalize(A)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == -1\nend\n\n# Pointer finalizer at exit (PR #19911)\nlet result = read(`$(Base.julia_cmd()) --startup-file=no -e \"A = Ref{Cint}(42); finalizer(cglobal((:c_exit_finalizer, \\\"$libccalltest\\\"), Cvoid), A)\"`, String)\n    @test result == \"c_exit_finalizer: 42, 0\"\nend\n\n# SIMD Registers\n\nconst VecReg{N,T} = NTuple{N,VecElement{T}}\nconst V2xF32 = VecReg{2,Float32}\nconst V4xF32 = VecReg{4,Float32}\nconst V2xF64 = VecReg{2,Float64}\nconst V2xI32 = VecReg{2,Int32}\nconst V4xI32 = VecReg{4,Int32}\n\nstruct Struct_AA64_1\n    v1::Int32\n    v2::Int128\nend\nstruct Struct_AA64_2\n    v1::Float16\n    v2::Float64\nend\n\n# This is a homogenious short vector aggregate\nstruct Struct_AA64_3\n    v1::VecReg{8,Int8}\n    v2::VecReg{2,Float32}\nend\n# This is NOT a homogenious short vector aggregate\nstruct Struct_AA64_4\n    v2::VecReg{2,Float32}\n    v1::VecReg{8,Int16}\nend\n\nmutable struct Struct_huge1_ppc64\n    m::Int64\n    v::V4xF32\nend\n\nmutable struct Struct_huge2_ppc64\n    v1::V4xF32\n    v2::V2xI32\nend\n\nmutable struct Struct_huge3_ppc64\n    v1::V4xF32\n    f::NTuple{4,Float32}\nend\n\nmutable struct Struct_huge4_ppc64\n    v1::V2xF32\n    v2::V2xF64\nend\n\nmutable struct Struct_huge5_ppc64\n    v1::NTuple{9,V4xF32}\nend\n\nmutable struct Struct_huge6_ppc64\n    v1::NTuple{8,V4xF32}\n    v2::V4xF32\nend\n\nmutable struct Struct_huge7_ppc64\n    v1::VecReg{3,Int32}\n    v2::VecReg{3,Int32}\nend\n\nmutable struct Struct_huge1_ppc64_hva\n    v1::NTuple{8,V4xF32}\nend\n\nmutable struct Struct_huge2_ppc64_hva\n    v1::NTuple{2,NTuple{2,V4xF32}}\nend\n\nmutable struct Struct_huge3_ppc64_hva\n    vf1::V4xF32\n    vf2::Tuple{NTuple{2,V4xF32}}\nend\n\nmutable struct Struct_huge4_ppc64_hva\n    v1::V4xI32\n    v2::V4xF32\nend\n\nmutable struct Struct_huge5_ppc64_hva\n    v1::V4xI32\n    v2::V2xF64\nend\n\nif Sys.ARCH === :x86_64\n    function test_sse(a1::V4xF32, a2::V4xF32, a3::V4xF32, a4::V4xF32)\n        ccall((:test_m128, libccalltest), V4xF32, (V4xF32, V4xF32, V4xF32, V4xF32), a1, a2, a3, a4)\n    end\n\n    function test_sse(a1::V4xI32, a2::V4xI32, a3::V4xI32, a4::V4xI32)\n        ccall((:test_m128i, libccalltest), V4xI32, (V4xI32, V4xI32, V4xI32, V4xI32), a1, a2, a3, a4)\n    end\n\n    foo_ams(a1, a2, a3, a4) = VecReg(ntuple(i -> VecElement(a1[i].value + a2[i].value * (a3[i].value - a4[i].value)), 4))\n\n    for s in [Float32, Int32]\n        T = NTuple{4, VecElement{s}}\n        @eval function rt_sse(a1::$T, a2::$T, a3::$T, a4::$T)\n            return ccall(\n                @cfunction(foo_ams, $T, ($T, $T, $T, $T)),\n                $T, ($T, $T, $T, $T),\n                     a1, a2, a3, a4)\n        end\n\n        a1 = VecReg(ntuple(i -> VecElement(s(1i)), 4))\n        a2 = VecReg(ntuple(i -> VecElement(s(2i)), 4))\n        a3 = VecReg(ntuple(i -> VecElement(s(3i)), 4))\n        a4 = VecReg(ntuple(i -> VecElement(s(4i)), 4))\n        r = VecReg(ntuple(i -> VecElement(s(1i + 2i * (3i - 4i))), 4))\n        @test test_sse(a1, a2, a3, a4) == r\n\n        # cfunction round-trip\n        @test rt_sse(a1, a2, a3, a4) == r\n    end\n\nelseif Sys.ARCH === :aarch64\n    for v1 in 1:99:1000, v2 in -100:-1999:-20000\n        @test ccall((:test_aa64_i128_1, libccalltest), Int128,\n                    (Int64, Int128), v1, v2) == v1 * 2 - v2\n    end\n    for v1 in 1:4, v2 in -4:-1, v3_1 in 3:5, v3_2 in 7:9\n        res = ccall((:test_aa64_i128_2, libccalltest), Struct_AA64_1,\n                    (Int64, Int128, Struct_AA64_1),\n                    v1, v2, Struct_AA64_1(v3_1, v3_2))\n        expected = Struct_AA64_1(v1 \u00f7 2 + 1 - v3_1, v2 * 2 - 1 - v3_2)\n        @test res === expected\n    end\n    for v1 in 1:4, v2 in -4:-1, v3 in 3:5, v4 in -(1:3)\n        res = ccall((:test_aa64_fp16_1, libccalltest), Float16,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Float16(v1 + v2 * 2 + v3 * 3 + v4 * 4)\n        @test res === expected\n\n        res = ccall((:test_aa64_fp16_2, libccalltest), Struct_AA64_2,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Struct_AA64_2(v4 / 2 + 1, v1 * 2 + v2 * 4 - v3)\n        @test res === expected\n    end\n    for v1_1 in 1:4, v1_2 in -2:2, v2 in -4:-1, v3_1 in 3:5, v3_2 in 6:8\n        res = ccall((:test_aa64_vec_1, libccalltest),\n                    VecReg{2,Int64},\n                    (VecReg{2,Int32}, Float32, VecReg{2,Int32}),\n                    (VecElement(Int32(v1_1)), VecElement(Int32(v1_2))),\n                    v2, (VecElement(Int32(v3_1)), VecElement(Int32(v3_2))))\n        expected = (VecElement(v1_1 * v2 + v3_1), VecElement(v1_2 * v2 + v3_2))\n        @test res === expected\n    end\n    for v1_11 in 1:4, v1_12 in -2:2, v1_21 in 1:4, v1_22 in -2:2,\n        v2_11 in 1:4, v2_12 in -2:2, v2_21 in 1:4, v2_22 in -2:2\n        v1 = Struct_AA64_3((VecElement(Int8(v1_11)), VecElement(Int8(v1_12)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0))),\n                           (VecElement(Float32(v1_21)),\n                            VecElement(Float32(v1_22))))\n        v2 = Struct_AA64_4((VecElement(Float32(v2_21)),\n                            VecElement(Float32(v2_22))),\n                           (VecElement(Int16(v2_11)), VecElement(Int16(v2_12)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0))))\n        res = ccall((:test_aa64_vec_2, libccalltest),\n                    Struct_AA64_3, (Struct_AA64_3, Struct_AA64_4), v1, v2)\n        expected = Struct_AA64_3((VecElement(Int8(v1_11 + v2_11)),\n                                  VecElement(Int8(v1_12 + v2_12)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0))),\n                                 (VecElement(Float32(v1_21 - v2_21)),\n                                  VecElement(Float32(v1_22 - v2_22))))\n        @test res === expected\n    end\n\nelseif Sys.ARCH === :powerpc64le || Sys.ARCH === :ppc64le\n@test_huge 1 \"_ppc64\" (1, (2.0, 3.0, 4.0, 5.0),)\n@test_huge 2 \"_ppc64\" ((1.0, 2.0, 3.0, 4.0), (11, 12))\n@test_huge 3 \"_ppc64\" ((1, 2, 3, 4), (11.0, 12.0, 13.0, 14.0))\n@test_huge 4 \"_ppc64\" ((1, 2), (11.0, 12.0))\n@test_huge 5 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0),\n                         (41.0, 42.0, 43.0, 44.0)),))\n@test_huge 6 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0)),\n                        (41.0, 42.0, 43.0, 44.0)))\n@test_huge 1 \"_ppc64_hva\" ((((1.0, 2.0, 3.0, 4.0),\n                             (5.0, 6.0, 7.0, 8.0),\n                             (11.0, 12.0, 13.0, 14.0),\n                             (15.0, 16.0, 17.0, 18.0),\n                             (21.0, 22.0, 23.0, 24.0),\n                             (25.0, 26.0, 27.0, 28.0),\n                             (31.0, 32.0, 33.0, 34.0),\n                             (35.0, 36.0, 37.0, 38.0)),))\n@test_huge 2 \"_ppc64_hva\" (((((1.0, 2.0, 3.0, 4.0),\n                              (5.0, 6.0, 7.0, 8.0)),\n                             ((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0))),))\n@test_huge 3 \"_ppc64_hva\" (((1.0, 2.0, 3.0, 4.0),\n                            (((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0)),)))\n@test_huge 4 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0, 13.0, 14.0)))\n@test_huge 5 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0)))\n\n@test 18451 == ccall((:test_ppc64_vec1long, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Struct_huge1_ppc64),\n    1, 2, 3, 4, 5, 6, 7, 8, 9, Struct_huge1_ppc64(18000, (100, 101, 102, 103)))\n\n@test 941 == ccall((:test_ppc64_vec1long_vec, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, V4xF32),\n    11, 12, 13, 14, 15, 16, 17, 18, 19, (200, 201, 202, 203))\n\n@test V4xF32((614232, 614218, 614204, 614190)) ==\n     ccall((:test_ppc64_vec2, libccalltest), V4xF32,\n    (Int64, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32),\n    600000, (4, 3, 2, 1), (5, 4, 3, 2), (6, 5, 4, 3), (7, 6, 5, 4),\n    (14, 13, 12, 11), (15, 14, 13, 12), (16, 15, 14, 13), (17, 16, 15, 14), (18, 17, 16, 15),\n    (1024, 1023, 1022, 1021), (1025, 1024, 1023, 1022), (1026, 1025, 1024, 1023), (1027, 1026, 1025, 1024), (10028, 10027, 10026, 10025))\n\nelseif Sys.ARCH !== :i686 && Sys.ARCH !== :arm # TODO\n@warn \"ccall: no VecReg tests run for this platform\"\n\nend\n\n# Special calling convention for `Array`\nfunction f17204(a)\n    b = similar(a)\n    for i in eachindex(a)\n        b[i] = a[i] + 10\n    end\n    return b\nend\n@test ccall(@cfunction(f17204, Vector{Any}, (Vector{Any},)),\n            Vector{Any}, (Vector{Any},), Any[1:10;]) == Any[11:20;]\n\n# This used to trigger incorrect ccall callee inlining.\n# Not sure if there's a more reliable way to test this.\n# Do not put these in a function.\n@noinline g17413() = rand()\n@inline f17413() = (g17413(); g17413())\nccall((:test_echo_p, libccalltest), Ptr{Cvoid}, (Any,), f17413())\nfor i in 1:3\n    ccall((:test_echo_p, libccalltest), Ptr{Cvoid}, (Any,), f17413())\nend\n\nlet r = Ref{Any}(10)\n    @GC.preserve r begin\n        pa = Base.unsafe_convert(Ptr{Any}, r) # pointer to value\n        pv = Base.unsafe_convert(Ptr{Cvoid}, r) # pointer to data\n        @test Ptr{Cvoid}(pa) != pv\n        @test unsafe_load(pa) === 10\n        @test unsafe_load(Ptr{Ptr{Cvoid}}(pa)) === pv\n        @test unsafe_load(Ptr{Int}(pv)) === 10\n    end\nend\n\nlet r = Ref{Any}(\"123456789\")\n    @GC.preserve r begin\n        pa = Base.unsafe_convert(Ptr{Any}, r) # pointer to value\n        pv = Base.unsafe_convert(Ptr{Cvoid}, r) # pointer to data\n        @test Ptr{Cvoid}(pa) != pv\n        @test unsafe_load(pa) === r[]\n        @test unsafe_load(Ptr{Ptr{Cvoid}}(pa)) === pv\n        @test unsafe_load(Ptr{Int}(pv)) === length(r[])\n    end\nend\n\n\nstruct SpillPint\n    a::Ptr{Cint}\n    b::Ptr{Cint}\nend\nBase.cconvert(::Type{SpillPint}, v::NTuple{2,Cint}) =\n    Base.cconvert(Ref{NTuple{2,Cint}}, v)\nfunction Base.unsafe_convert(::Type{SpillPint}, vr)\n    ptr = Base.unsafe_convert(Ref{NTuple{2,Cint}}, vr)\n    return SpillPint(ptr, ptr + 4)\nend\n\nmacro test_spill_n(n::Int, intargs, floatargs)\n    fname_int = Symbol(:test_spill_int, n)\n    fname_float = Symbol(:test_spill_float, n)\n    quote\n        local ints = $(esc(intargs))\n        local floats = $(esc(intargs))\n        @test ccall(($(QuoteNode(fname_int)), libccalltest), Cint,\n                    ($((:(Ref{Cint}) for j in 1:n)...), SpillPint),\n                    $((:(ints[$j]) for j in 1:n)...),\n                    (ints[$n + 1], ints[$n + 2])) == sum(ints[1:($n + 2)])\n        @test ccall(($(QuoteNode(fname_float)), libccalltest), Float32,\n                    ($((:Float32 for j in 1:n)...), NTuple{2,Float32}),\n                    $((:(floats[$j]) for j in 1:n)...),\n                    (floats[$n + 1], floats[$n + 2])) == sum(floats[1:($n + 2)])\n    end\nend\n\nfor i in 1:100\n    local intargs = rand(1:10000, 14)\n    local int32args = Int32.(intargs)\n    local intsum = sum(intargs)\n    local floatargs = rand(14)\n    local float32args = Float32.(floatargs)\n    local float32sum = sum(float32args)\n    local float64sum = sum(floatargs)\n    @test ccall((:test_long_args_intp, libccalltest), Cint,\n                (Ref{Cint}, Ref{Cint}, Ref{Cint}, Ref{Cint},\n                 Ref{Cint}, Ref{Cint}, Ref{Cint}, Ref{Cint},\n                 Ref{Cint}, Ref{Cint}, Ref{Cint}, Ref{Cint},\n                 Ref{Cint}, Ref{Cint}),\n                intargs[1], intargs[2], intargs[3], intargs[4],\n                intargs[5], intargs[6], intargs[7], intargs[8],\n                intargs[9], intargs[10], intargs[11], intargs[12],\n                intargs[13], intargs[14]) == intsum\n    @test ccall((:test_long_args_int, libccalltest), Cint,\n                (Cint, Cint, Cint, Cint, Cint, Cint, Cint, Cint,\n                 Cint, Cint, Cint, Cint, Cint, Cint),\n                intargs[1], intargs[2], intargs[3], intargs[4],\n                intargs[5], intargs[6], intargs[7], intargs[8],\n                intargs[9], intargs[10], intargs[11], intargs[12],\n                intargs[13], intargs[14]) == intsum\n    @test ccall((:test_long_args_float, libccalltest), Float32,\n                (Float32, Float32, Float32, Float32, Float32, Float32,\n                 Float32, Float32, Float32, Float32, Float32, Float32,\n                 Float32, Float32),\n                floatargs[1], floatargs[2], floatargs[3], floatargs[4],\n                floatargs[5], floatargs[6], floatargs[7], floatargs[8],\n                floatargs[9], floatargs[10], floatargs[11], floatargs[12],\n                floatargs[13], floatargs[14]) \u2248 float32sum\n    @test ccall((:test_long_args_double, libccalltest), Float64,\n                (Float64, Float64, Float64, Float64, Float64, Float64,\n                 Float64, Float64, Float64, Float64, Float64, Float64,\n                 Float64, Float64),\n                floatargs[1], floatargs[2], floatargs[3], floatargs[4],\n                floatargs[5], floatargs[6], floatargs[7], floatargs[8],\n                floatargs[9], floatargs[10], floatargs[11], floatargs[12],\n                floatargs[13], floatargs[14]) \u2248 float64sum\n\n    @test_spill_n 1 int32args float32args\n    @test_spill_n 2 int32args float32args\n    @test_spill_n 3 int32args float32args\n    @test_spill_n 4 int32args float32args\n    @test_spill_n 5 int32args float32args\n    @test_spill_n 6 int32args float32args\n    @test_spill_n 7 int32args float32args\n    @test_spill_n 8 int32args float32args\n    @test_spill_n 9 int32args float32args\n    @test_spill_n 10 int32args float32args\nend\n\n# issue #20835\n@test_throws(ErrorException(\"could not evaluate ccall argument type (it might depend on a local variable)\"),\n             eval(:(f20835(x) = ccall(:fn, Cvoid, (Ptr{typeof(x)},), x))))\n@test_throws(UndefVarError(:Something_not_defined_20835),\n             eval(:(f20835(x) = ccall(:fn, Something_not_defined_20835, (Ptr{typeof(x)},), x))))\n\n@noinline f21104at(::Type{T}) where {T} = ccall(:fn, Cvoid, (Some{T},), Some(0))\n@noinline f21104rt(::Type{T}) where {T} = ccall(:fn, Some{T}, ())\n@test code_llvm(devnull, f21104at, (Type{Float64},)) === nothing\n@test code_llvm(devnull, f21104rt, (Type{Float64},)) === nothing\n@test_throws(ErrorException(\"ccall argument 1 doesn't correspond to a C type\"),\n             f21104at(Float64))\n@test_throws(ErrorException(\"ccall return type doesn't correspond to a C type\"),\n             f21104rt(Float64))\n\n# test for malformed syntax errors\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (), x)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y, z)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y, z)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C), x, y, z)))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,),)))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C), )))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B..., C...), )))\n@test Expr(:error, \"C ABI prohibits vararg without one required argument\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B...,), x)))\n@test Expr(:error, \"only the trailing ccall argument type should have \\\"...\\\"\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (A, B..., C...), a, x)))\n@test Expr(:error, \"only the trailing ccall argument type should have \\\"...\\\"\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (A, B..., C...), a, x, y, z)))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C...), )))\n\n# cfunction on non-function singleton\nstruct CallableSingleton\nend\n(::CallableSingleton)(x, y) = x + y\n@test ccall(@cfunction(CallableSingleton(), Int, (Int, Int)),\n            Int, (Int, Int), 1, 2) === 3\n\n# 19805\nmutable struct callinfos_19805{FUNC_FT<:Function}\n    f :: FUNC_FT\nend\n\nevalf_callback_19805(ci::callinfos_19805{FUNC_FT}) where {FUNC_FT} = ci.f(0.5)::Float64\n\nevalf_callback_c_19805(ci::callinfos_19805{FUNC_FT}) where {FUNC_FT} = @cfunction(\n    evalf_callback_19805, Float64, (callinfos_19805{FUNC_FT},))\n\n@test_throws(ErrorException(\"cfunction argument 1 doesn't correspond to a C type\"),\n             evalf_callback_c_19805( callinfos_19805(sin) ))\n@test_throws(ErrorException(\"cfunction argument 2 doesn't correspond to a C type\"),\n             @cfunction(+, Int, (Int, Nothing)))\n@test_throws(ErrorException(\"cfunction: Vararg syntax not allowed for argument list\"),\n             @cfunction(+, Int, (Vararg{Int},)))\n@test_throws(ErrorException(\"could not evaluate cfunction argument type (it might depend on a local variable)\"),\n             @eval () -> @cfunction(+, Int, (Ref{T}, Ref{T})) where T)\n@test_throws(ErrorException(\"could not evaluate cfunction return type (it might depend on a local variable)\"),\n             @eval () -> @cfunction(+, Ref{T}, (Int, Int)) where T)\n@test_throws(ErrorException(\"cfunction return type Ref{Any} is invalid. Use Any or Ptr{Any} instead.\"),\n             @cfunction(+, Ref{Any}, (Int, Int)))\n\n# test Ref{abstract_type} calling parameter passes a heap box\nabstract type Abstract22734 end\nstruct Bits22734 <: Abstract22734\n    x::Int\n    y::Float64\nend\nfunction cb22734(ptr::Ptr{Cvoid})\n    GC.gc()\n    obj = unsafe_pointer_to_objref(ptr)::Bits22734\n    obj.x + obj.y\nend\nptr22734 = @cfunction(cb22734, Float64, (Ptr{Cvoid},))\nfunction caller22734(ptr)\n    obj = Bits22734(12, 20)\n    ccall(ptr, Float64, (Ref{Abstract22734},), obj)\nend\n@test caller22734(ptr22734) === 32.0\n\n# 26297#issuecomment-371165725\n#   test that the first argument to cglobal is recognized as a tuple literal even through\n#   macro expansion\nmacro cglobal26297(sym)\n    :(cglobal(($(esc(sym)), libccalltest), Cint))\nend\ncglobal26297() = @cglobal26297(:global_var)\n@test cglobal26297() != C_NULL\n\n# issue #26607\nnoop_func_26607 = () -> nothing\nfunction callthis_26607(args)\n    @cfunction(noop_func_26607, Cvoid, ())\n    return nothing\nend\n@test callthis_26607(Int64(0)) === nothing\n@test callthis_26607(Int32(0)) === nothing\n\n# issue #27178 (cfunction special case in inlining)\nmutable struct CallThisFunc27178{FCN_TYPE}\n    fcn::FCN_TYPE\nend\n\ncallback27178(cb::CTF) where CTF<:CallThisFunc27178 = nothing\n@inline make_cfunc27178(cbi::CI) where CI = @cfunction(callback27178, Cvoid, (Ref{CI},))\nget_c_func(fcn::FCN_TYPE) where {FCN_TYPE<:Function} = return make_cfunc27178(CallThisFunc27178(fcn))\n@test isa(get_c_func(sin), Ptr)\n\n# issue #27215\nfunction once_removed()\n    function mycompare(a, b)::Cint\n        return (a < b) ? -1 : ((a > b) ? +1 : 0)\n    end\n    mycompare_c = @cfunction($mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))\nend\n@test isa(once_removed(), Base.CFunction)\n\n# issue #27478\nfunction ccall27478()\n    module_lib = Libdl.dlopen(\"libjulia\")\n    ccall(Libdl.dlsym(module_lib, \"getpid\"), Cint, ())\nend\n@test code_typed(ccall27478, ()) isa Array\n\n# issue #27477\n@eval module Pkg27477\nconst libccalltest = $libccalltest\nend\n\nmodule Test27477\nusing ..Pkg27477\ntest27477() = ccall((:ctest, Pkg27477.libccalltest), Complex{Int}, (Complex{Int},), 1 + 2im)\nend\n\n@test Test27477.test27477() == 2 + 0im\n\n# issue #31073\nlet\n    a = ['0']\n    arr = Vector{Char}(undef, 2)\n    ptr = pointer(arr)\n    elsz = sizeof(Char)\n    na = length(a)\n    nba = na * elsz\n    ptr = eval(:(ccall(:memcpy, Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}, UInt), $(arr), $(a), $(nba))))\n    @test isa(ptr, Ptr{Cvoid})\n    @test arr[1] == '0'\nend\n\n# issue #34061\nlet o_file = tempname(), err = Base.PipeEndpoint()\n    run(pipeline(Cmd(`$(Base.julia_cmd()) --color=no --output-o=$o_file -e '\n        Base.reinit_stdio();\n        f() = ccall((:dne, :does_not_exist), Cvoid, ());\n        f()'`; ignorestatus=true), stderr=err), wait=false)\n    output = read(err, String)\n    @test occursin(\"\"\"ERROR: could not load library \"does_not_exist\"\n    \"\"\", output)\n    @test !isfile(o_file)\nend\n\n# pass NTuple{N,T} as Ptr{T}/Ref{T}\nlet\n    dest = Ref((0,0,0))\n\n    src  = Ref((1,2,3))\n    ccall(:memcpy, Ptr{Cvoid}, (Ptr{Int}, Ptr{Int}, Csize_t), dest, src, 3*sizeof(Int))\n    @test dest[] == (1,2,3)\n\n    src  = Ref((4,5,6))\n    ccall(:memcpy, Ptr{Cvoid}, (Ref{Int}, Ref{Int}, Csize_t), dest, src, 3*sizeof(Int))\n    @test dest[] == (4,5,6)\n\n    src  = (7,8,9)\n    ccall(:memcpy, Ptr{Cvoid}, (Ref{Int}, Ref{Int}, Csize_t), dest, src, 3*sizeof(Int))\n    @test dest[] == (7,8,9)\nend\n\n\n# @ccall macro\nusing Base: ccall_macro_parse, ccall_macro_lower\n@testset \"test basic ccall_macro_parse functionality\" begin\n    callexpr = :(\n        libc.printf(\"%s = %d\\n\"::Cstring ; name::Cstring, value::Cint)::Cvoid\n    )\n    @test ccall_macro_parse(callexpr) == (\n        :((:printf, libc)),               # function\n        :Cvoid,                           # returntype\n        Any[:Cstring, :Cstring, :Cint],   # argument types\n        Any[\"%s = %d\\n\", :name, :value],  # argument symbols\n        1                                 # number of required arguments (for varargs)\n    )\nend\n\n@testset \"ensure the base-case of @ccall works, including library name and pointer interpolation\" begin\n    call = ccall_macro_lower(:ccall, ccall_macro_parse( :( libstring.func(\n        str::Cstring,\n        num1::Cint,\n        num2::Cint\n    )::Cstring))...)\n    @test call == Base.remove_linenums!(\n        quote\n        local arg1root = $(GlobalRef(Base, :cconvert))($(Expr(:escape, :Cstring)), $(Expr(:escape, :str)))\n        local arg1 = $(GlobalRef(Base, :unsafe_convert))($(Expr(:escape, :Cstring)), arg1root)\n        local arg2root = $(GlobalRef(Base, :cconvert))($(Expr(:escape, :Cint)), $(Expr(:escape, :num1)))\n        local arg2 = $(GlobalRef(Base, :unsafe_convert))($(Expr(:escape, :Cint)), arg2root)\n        local arg3root = $(GlobalRef(Base, :cconvert))($(Expr(:escape, :Cint)), $(Expr(:escape, :num2)))\n        local arg3 = $(GlobalRef(Base, :unsafe_convert))($(Expr(:escape, :Cint)), arg3root)\n        $(Expr(:foreigncall,\n               :($(Expr(:escape, :((:func, libstring))))),\n               :($(Expr(:escape, :Cstring))),\n               :($(Expr(:escape, :(($(Expr(:core, :svec)))(Cstring, Cint, Cint))))),\n               0,\n               :(:ccall),\n               :arg1, :arg2, :arg3, :arg1root, :arg2root, :arg3root))\n        end)\n\n    # pointer interpolation\n    call = ccall_macro_lower(:ccall, ccall_macro_parse(:( $(Expr(:$, :fptr))(\"bar\"::Cstring)::Cvoid ))...)\n    @test Base.remove_linenums!(call) == Base.remove_linenums!(\n    quote\n        func = $(Expr(:escape, :fptr))\n        begin\n            if !(func isa Ptr{Cvoid})\n                name = :fptr\n                throw(ArgumentError(\"interpolated function `$(name)` was not a Ptr{Cvoid}, but $(typeof(func))\"))\n            end\n        end\n        local arg1root = $(GlobalRef(Base, :cconvert))($(Expr(:escape, :Cstring)), $(Expr(:escape, \"bar\")))\n        local arg1 = $(GlobalRef(Base, :unsafe_convert))($(Expr(:escape, :Cstring)), arg1root)\n        $(Expr(:foreigncall, :func, :($(Expr(:escape, :Cvoid))), :($(Expr(:escape, :(($(Expr(:core, :svec)))(Cstring))))), 0, :(:ccall), :arg1, :arg1root))\n    end)\n\nend\n\n@testset \"check error paths\" begin\n    # missing return type\n    @test_throws ArgumentError(\"@ccall needs a function signature with a return type\") ccall_macro_parse(:( foo(4.0::Cdouble )))\n    # not a function call\n    @test_throws ArgumentError(\"@ccall has to take a function call\") ccall_macro_parse(:( foo::Type ))\n    # missing type annotations on arguments\n    @test_throws ArgumentError(\"args in @ccall need type annotations. 'x' doesn't have one.\") ccall_macro_parse(:( foo(x)::Cint ))\n    # missing type annotations on varargs arguments\n    @test_throws ArgumentError(\"args in @ccall need type annotations. 'y' doesn't have one.\") ccall_macro_parse(:( foo(x::Cint ; y)::Cint ))\n    # no reqired args on varargs call\n    @test_throws ArgumentError(\"C ABI prohibits vararg without one required argument\") ccall_macro_parse(:( foo(; x::Cint)::Cint ))\n    # not a function pointer\n    @test_throws ArgumentError(\"interpolated function `PROGRAM_FILE` was not a Ptr{Cvoid}, but String\") @ccall $PROGRAM_FILE(\"foo\"::Cstring)::Cvoid\nend\n\n# call some c functions\n@testset \"run @ccall with C standard library functions\" begin\n    @test @ccall(sqrt(4.0::Cdouble)::Cdouble) == 2.0\n\n    str = \"hello\"\n    buf = Ptr{UInt8}(Libc.malloc((length(str) + 1) * sizeof(Cchar)))\n    @ccall strcpy(buf::Cstring, str::Cstring)::Cstring\n    @test unsafe_string(buf) == str\n    Libc.free(buf)\n\n    # test pointer interpolation\n    str_identity = @cfunction(identity, Cstring, (Cstring,))\n    foo = @ccall $str_identity(\"foo\"::Cstring)::Cstring\n    @test unsafe_string(foo) == \"foo\"\n    # test interpolation of an expresison that returns a pointer.\n    foo = @ccall $(@cfunction(identity, Cstring, (Cstring,)))(\"foo\"::Cstring)::Cstring\n    @test unsafe_string(foo) == \"foo\"\n\n    # test of a vararg foreigncall using @ccall\n    strp = Ref{Ptr{Cchar}}(0)\n    fmt = \"hi+%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f\\n\"\n\n    len = @ccall asprintf(\n        strp::Ptr{Ptr{Cchar}},\n        fmt::Cstring,\n        ; # begin varargs\n        0x1::UInt8, 0x2::UInt8, 0x3::UInt8, 0x4::UInt8, 0x5::UInt8, 0x6::UInt8, 0x7::UInt8, 0x8::UInt8, 0x9::UInt8, 0xa::UInt8, 0xb::UInt8, 0xc::UInt8, 0xd::UInt8, 0xe::UInt8, 0xf::UInt8,\n        1.1::Cfloat, 2.2::Cfloat, 3.3::Cfloat, 4.4::Cfloat, 5.5::Cfloat, 6.6::Cfloat, 7.7::Cfloat, 8.8::Cfloat, 9.9::Cfloat,\n    )::Cint\n    str = unsafe_string(strp[], len)\n    @ccall free(strp[]::Cstring)::Cvoid\n    @test str == \"hi+1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-1.1-2.2-3.3-4.4-5.5-6.6-7.7-8.8-9.9\\n\"\nend\n\n\n@testset \"Cwstring\" begin\n    buffer = Array{Cwchar_t}(undef, 100)\n    len = @static if Sys.iswindows()\n            @ccall swprintf_s(buffer::Ptr{Cwchar_t}, length(buffer)::Csize_t, \"\u03b1+%ls=%hhd\"::Cwstring; \"\u03b2\"::Cwstring, 0xf::UInt8)::Cint\n        else\n            @ccall swprintf(buffer::Ptr{Cwchar_t}, length(buffer)::Csize_t, \"\u03b1+%ls=%hhd\"::Cwstring; \"\u03b2\"::Cwstring, 0xf::UInt8)::Cint\n        end\n    Libc.systemerror(\"swprintf\", len < 0)\n    str = GC.@preserve buffer unsafe_string(pointer(buffer), len)\n    @test str == \"\u03b1+\u03b2=15\"\n    str = GC.@preserve buffer unsafe_string(Cwstring(pointer(buffer)))\n    @test str == \"\u03b1+\u03b2=15\"\nend\n\n# issue #36458\ncompute_lib_name() = \"libcc\" * \"alltest\"\nccall_lazy_lib_name(x) = ccall((:testUcharX, compute_lib_name()), Int32, (UInt8,), x % UInt8)\n@test ccall_lazy_lib_name(0) == 0\n@test ccall_lazy_lib_name(3) == 1\nccall_with_undefined_lib() = ccall((:time, xx_nOt_DeFiNeD_xx), Cint, (Ptr{Cvoid},), C_NULL)\n@test_throws UndefVarError(:xx_nOt_DeFiNeD_xx) ccall_with_undefined_lib()\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/generate_precompile.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nif isempty(Base.ARGS) || Base.ARGS[1] !== \"0\"\nSys.__init_build()\n# Prevent this from being put into the Main namespace\n@eval Module() begin\nif !isdefined(Base, :uv_eventloop)\n    Base.reinit_stdio()\nend\nBase.include(@__MODULE__, joinpath(Sys.BINDIR::String, \"..\", \"share\", \"julia\", \"test\", \"testhelpers\", \"FakePTYs.jl\"))\nimport .FakePTYs: open_fake_pty\nusing Base.Meta\n\nCTRL_C = '\\x03'\nUP_ARROW = \"\\e[A\"\nDOWN_ARROW = \"\\e[B\"\n\nhardcoded_precompile_statements = \"\"\"\n# used by Revise.jl\n@assert precompile(Tuple{typeof(Base.parse_cache_header), String})\n@assert precompile(Base.read_dependency_src, (String, String))\n\n# used by Requires.jl\n@assert precompile(Tuple{typeof(get!), Type{Vector{Function}}, Dict{Base.PkgId,Vector{Function}}, Base.PkgId})\n@assert precompile(Tuple{typeof(haskey), Dict{Base.PkgId,Vector{Function}}, Base.PkgId})\n@assert precompile(Tuple{typeof(delete!), Dict{Base.PkgId,Vector{Function}}, Base.PkgId})\n@assert precompile(Tuple{typeof(push!), Vector{Function}, Function})\n\n# miscellaneous\n@assert precompile(Tuple{typeof(Base.require), Base.PkgId})\n@assert precompile(Tuple{typeof(Base.recursive_prefs_merge), Base.Dict{String, Any}})\n@assert precompile(Tuple{typeof(isassigned), Core.SimpleVector, Int})\n@assert precompile(Tuple{typeof(getindex), Core.SimpleVector, Int})\n@assert precompile(Tuple{typeof(Base.Experimental.register_error_hint), Any, Type})\n@assert precompile(Tuple{typeof(Base.display_error), MethodError, Vector{Union{Ptr{Nothing}, Base.InterpreterIP}}})\n@assert precompile(Tuple{typeof(Base.display_error), ErrorException})\n@assert precompile(Tuple{typeof(Base.display_error), BoundsError})\n@assert precompile(Tuple{Core.kwftype(typeof(Type)), NamedTuple{(:sizehint,), Tuple{Int64}}, Type{IOBuffer}})\n@assert precompile(Base.CoreLogging.current_logger_for_env, (Base.CoreLogging.LogLevel, String, Module))\n@assert precompile(Base.CoreLogging.current_logger_for_env, (Base.CoreLogging.LogLevel, Symbol, Module))\n\"\"\"\n\nfor T in (Float16, Float32, Float64), IO in (IOBuffer, IOContext{IOBuffer}, Base.TTY, IOContext{Base.TTY})\n    global hardcoded_precompile_statements\n    hardcoded_precompile_statements *= \"@assert precompile(Tuple{typeof(show), $IO, $T})\\n\"\nend\n\nrepl_script = \"\"\"\n2+2\nprint(\"\")\nprintstyled(\"a\", \"b\")\ndisplay([1])\ndisplay([1 2; 3 4])\n@time 1+1\n; pwd\n$CTRL_C\n? reinterpret\nusing Ra\\t$CTRL_C\n\\\\alpha\\t$CTRL_C\n\\e[200~paste here ;)\\e[201~\"$CTRL_C\n$UP_ARROW$DOWN_ARROW$CTRL_C\n123\\b\\b\\b$CTRL_C\n\\b\\b$CTRL_C\nf(x) = x03\nf(1,2)\n[][1]\ncd(\"complet_path\\t\\t$CTRL_C\n\"\"\"\n\nprecompile_script = \"\"\"\n# NOTE: these were moved to the end of Base.jl. TODO: move back here.\n# # Used by Revise & its dependencies\n# while true  # force inference\n# delete!(push!(Set{Module}(), Base), Main)\n# m = first(methods(+))\n# delete!(push!(Set{Method}(), m), m)\n# empty!(Set())\n# push!(push!(Set{Union{GlobalRef,Symbol}}(), :two), GlobalRef(Base, :two))\n# (setindex!(Dict{String,Base.PkgId}(), Base.PkgId(Base), \"file.jl\"))[\"file.jl\"]\n# (setindex!(Dict{Symbol,Vector{Int}}(), [1], :two))[:two]\n# (setindex!(Dict{Base.PkgId,String}(), \"file.jl\", Base.PkgId(Base)))[Base.PkgId(Base)]\n# (setindex!(Dict{Union{GlobalRef,Symbol}, Vector{Int}}(), [1], :two))[:two]\n# (setindex!(IdDict{Type, Union{Missing, Vector{Tuple{LineNumberNode, Expr}}}}(), missing, Int))[Int]\n# Dict{Symbol, Union{Nothing, Bool, Symbol}}(:one => false)[:one]\n# Dict(Base => [:(1+1)])[Base]\n# Dict(:one => [1])[:one]\n# Dict(\"abc\" => Set())[\"abc\"]\n# pushfirst!([], sum)\n# get(Base.pkgorigins, Base.PkgId(Base), nothing)\n# sort!([1,2,3])\n# unique!([1,2,3])\n# cumsum([1,2,3])\n# append!(Int[], BitSet())\n# isempty(BitSet())\n# delete!(BitSet([1,2]), 3)\n# deleteat!(Int32[1,2,3], [1,3])\n# deleteat!(Any[1,2,3], [1,3])\n# Core.svec(1, 2) == Core.svec(3, 4)\n# # copy(Core.Compiler.retrieve_code_info(Core.Compiler.specialize_method(which(+, (Int, Int)), [Int, Int], Core.svec())))\n# any(t->t[1].line > 1, [(LineNumberNode(2,:none),:(1+1))])\n# break   # end force inference\n# end\n\"\"\"\n\njulia_exepath() = joinpath(Sys.BINDIR::String, Base.julia_exename())\n\nhave_repl =  haskey(Base.loaded_modules,\n                    Base.PkgId(Base.UUID(\"3fa0cd96-eef1-5676-8a61-b3b8758bbffb\"), \"REPL\"))\nif have_repl\n    hardcoded_precompile_statements *= \"\"\"\n    @assert precompile(Tuple{typeof(getproperty), REPL.REPLBackend, Symbol})\n    \"\"\"\nend\n\nDistributed = get(Base.loaded_modules,\n          Base.PkgId(Base.UUID(\"8ba89e20-285c-5b6f-9357-94700520ee1b\"), \"Distributed\"),\n          nothing)\nif Distributed !== nothing\n    hardcoded_precompile_statements *= \"\"\"\n    @assert precompile(Tuple{typeof(Distributed.remotecall),Function,Int,Module,Vararg{Any, 100}})\n    @assert precompile(Tuple{typeof(Distributed.procs)})\n    @assert precompile(Tuple{typeof(Distributed.finalize_ref), Distributed.Future})\n    \"\"\"\n# This is disabled because it doesn't give much benefit\n# and the code in Distributed is poorly typed causing many invalidations\n#=\n    precompile_script *= \"\"\"\n    using Distributed\n    addprocs(2)\n    pmap(x->iseven(x) ? 1 : 0, 1:4)\n    @distributed (+) for i = 1:100 Int(rand(Bool)) end\n    \"\"\"\n=#\nend\n\n\nArtifacts = get(Base.loaded_modules,\n          Base.PkgId(Base.UUID(\"56f22d72-fd6d-98f1-02f0-08ddc0907c33\"), \"Artifacts\"),\n          nothing)\nif Artifacts !== nothing\n    precompile_script *= \"\"\"\n    using Artifacts, Base.BinaryPlatforms, Libdl\n    artifacts_toml = abspath(joinpath(Sys.STDLIB, \"Artifacts\", \"test\", \"Artifacts.toml\"))\n    # cd(() -> (name = \"c_simple\"; @artifact_str(name)), dirname(artifacts_toml))\n    artifacts = Artifacts.load_artifacts_toml(artifacts_toml)\n    platforms = [Artifacts.unpack_platform(e, \"c_simple\", artifacts_toml) for e in artifacts[\"c_simple\"]]\n    best_platform = select_platform(Dict(p => triplet(p) for p in platforms))\n    dlopen(\"libjulia$(ccall(:jl_is_debugbuild, Cint, ()) != 0 ? \"-debug\" : \"\")\", RTLD_LAZY | RTLD_DEEPBIND)\n    \"\"\"\nend\n\n\nPkg = get(Base.loaded_modules,\n          Base.PkgId(Base.UUID(\"44cfe95a-1eb2-52ea-b672-e2afdf69b78f\"), \"Pkg\"),\n          nothing)\n\nif Pkg !== nothing\n    # TODO: Split Pkg precompile script into REPL and script part\n    repl_script *= Pkg.precompile_script\nend\n\nFileWatching = get(Base.loaded_modules,\n          Base.PkgId(Base.UUID(\"7b1f6079-737a-58dc-b8bc-7a2ca5c1b5ee\"), \"FileWatching\"),\n          nothing)\nif FileWatching !== nothing\n    hardcoded_precompile_statements *= \"\"\"\n    @assert precompile(Tuple{typeof(FileWatching.watch_file), String, Float64})\n    @assert precompile(Tuple{typeof(FileWatching.watch_file), String, Int})\n    @assert precompile(Tuple{typeof(FileWatching._uv_hook_close), FileWatching.FileMonitor})\n    \"\"\"\nend\n\nLibdl = get(Base.loaded_modules,\n          Base.PkgId(Base.UUID(\"8f399da3-3557-5675-b5ff-fb832c97cbdb\"), \"Libdl\"),\n          nothing)\nif Libdl !== nothing\n    hardcoded_precompile_statements *= \"\"\"\n    precompile(Tuple{typeof(Libc.Libdl.dlopen), String})\n    \"\"\"\nend\n\nTest = get(Base.loaded_modules,\n          Base.PkgId(Base.UUID(\"8dfed614-e22c-5e08-85e1-65c5234f0b40\"), \"Test\"),\n          nothing)\nif Test !== nothing\n    hardcoded_precompile_statements *= \"\"\"\n    @assert precompile(Tuple{typeof(Test.do_test), Test.ExecutionResult, Any})\n    @assert precompile(Tuple{typeof(Test.testset_beginend), Tuple{String, Expr}, Expr, LineNumberNode})\n    @assert precompile(Tuple{Type{Test.DefaultTestSet}, String})\n    @assert precompile(Tuple{Type{Test.DefaultTestSet}, AbstractString})\n    @assert precompile(Tuple{Core.kwftype(Type{Test.DefaultTestSet}), Any, Type{Test.DefaultTestSet}, AbstractString})\n    @assert precompile(Tuple{typeof(Test.finish), Test.DefaultTestSet})\n    @assert precompile(Tuple{typeof(Test.eval_test), Expr, Expr, LineNumberNode, Bool})\n    @assert precompile(Tuple{typeof(Test._inferred), Expr, Module})\n    @assert precompile(Tuple{typeof(Test.push_testset), Test.DefaultTestSet})\n    @assert precompile(Tuple{typeof(Test.get_alignment), Test.DefaultTestSet, Int})\n    @assert precompile(Tuple{typeof(Test.get_test_result), Any, Any})\n    @assert precompile(Tuple{typeof(Test.do_test_throws), Test.ExecutionResult, Any, Any})\n    @assert precompile(Tuple{typeof(Test.print_counts), Test.DefaultTestSet, Int, Int, Int, Int, Int, Int, Int})\n    @assert precompile(Tuple{typeof(Test._check_testset), Type, Expr})\n    @assert precompile(Tuple{typeof(Test.test_expr!), Any, Any})\n    @assert precompile(Tuple{typeof(Test.test_expr!), Any, Any, Vararg{Any, 100}})\n    @assert precompile(Tuple{typeof(Test.pop_testset)})\n    @assert precompile(Tuple{typeof(Test.match_logs), Function, Tuple{Symbol, Regex}})\n    @assert precompile(Tuple{typeof(Test.match_logs), Function, Tuple{String, Regex}})\n    @assert precompile(Tuple{typeof(Base.CoreLogging.shouldlog), Test.TestLogger, Base.CoreLogging.LogLevel, Module, Symbol, Symbol})\n    @assert precompile(Tuple{typeof(Base.CoreLogging.handle_message), Test.TestLogger, Base.CoreLogging.LogLevel, String, Module, Symbol, Symbol, String, Int})\n    @assert precompile(Tuple{typeof(Core.kwfunc(Base.CoreLogging.handle_message)), typeof((exception=nothing,)), typeof(Base.CoreLogging.handle_message), Test.TestLogger, Base.CoreLogging.LogLevel, String, Module, Symbol, Symbol, String, Int})\n    @assert precompile(Tuple{typeof(Test.detect_ambiguities), Any})\n    @assert precompile(Tuple{typeof(Test.collect_test_logs), Function})\n    @assert precompile(Tuple{typeof(Test.do_broken_test), Test.ExecutionResult, Any})\n    @assert precompile(Tuple{typeof(Test.record), Test.DefaultTestSet, Union{Test.Error, Test.Fail}})\n    @assert precompile(Tuple{typeof(Test.filter_errors), Test.DefaultTestSet})\n    \"\"\"\nend\n\nProfile = get(Base.loaded_modules,\n          Base.PkgId(Base.UUID(\"9abbd945-dff8-562f-b5e8-e1ebf5ef1b79\"), \"Profile\"),\n          nothing)\nif Profile !== nothing\n    hardcoded_precompile_statements *= \"\"\"\n    @assert precompile(Tuple{typeof(Profile.tree!), Profile.StackFrameTree{UInt64}, Vector{UInt64}, Dict{UInt64, Vector{Base.StackTraces.StackFrame}}, Bool, Symbol})\n    \"\"\"\nend\n\nfunction generate_precompile_statements()\n    start_time = time_ns()\n    debug_output = devnull # or stdout\n    sysimg = Base.unsafe_string(Base.JLOptions().image_file)\n\n    # Extract the precompile statements from the precompile file\n    statements = Set{String}()\n\n    # From hardcoded statements\n    for statement in split(hardcoded_precompile_statements::String, '\\n')\n        push!(statements, statement)\n    end\n\n    # Collect statements from running the script\n    mktempdir() do prec_path\n        # Also precompile a package here\n        pkgname = \"__PackagePrecompilationStatementModule\"\n        mkpath(joinpath(prec_path, pkgname, \"src\"))\n        path = joinpath(prec_path, pkgname, \"src\", \"$pkgname.jl\")\n        write(path,\n              \"\"\"\n              module $pkgname\n              end\n              \"\"\")\n        tmp = tempname()\n        s = \"\"\"\n            pushfirst!(DEPOT_PATH, $(repr(prec_path)));\n            Base.PRECOMPILE_TRACE_COMPILE[] = $(repr(tmp));\n            Base.compilecache(Base.PkgId($(repr(pkgname))), $(repr(path)))\n            $precompile_script\n            \"\"\"\n        run(`$(julia_exepath()) -O0 --sysimage $sysimg --startup-file=no -Cnative -e $s`)\n        for statement in split(read(tmp, String), '\\n')\n            push!(statements, statement)\n        end\n    end\n\n    mktemp() do precompile_file, precompile_file_h\n        # Collect statements from running a REPL process and replaying our REPL script\n        pts, ptm = open_fake_pty()\n        blackhole = Sys.isunix() ? \"/dev/null\" : \"nul\"\n        if have_repl\n            cmdargs = ```--color=yes\n                      -e 'import REPL; REPL.Terminals.is_precompiling[] = true'\n                      ```\n        else\n            cmdargs = `-e nothing`\n        end\n        p = withenv(\"JULIA_HISTORY\" => blackhole,\n                    \"JULIA_PROJECT\" => nothing, # remove from environment\n                    \"JULIA_LOAD_PATH\" => Sys.iswindows() ? \"@;@stdlib\" : \"@:@stdlib\",\n                    \"JULIA_PKG_PRECOMPILE_AUTO\" => \"0\",\n                    \"TERM\" => \"\") do\n            run(```$(julia_exepath()) -O0 --trace-compile=$precompile_file --sysimage $sysimg\n                   --cpu-target=native --startup-file=no --color=yes\n                   -e 'import REPL; REPL.Terminals.is_precompiling[] = true'\n                   -i $cmdargs```,\n                   pts, pts, pts; wait=false)\n        end\n        Base.close_stdio(pts)\n        # Prepare a background process to copy output from process until `pts` is closed\n        output_copy = Base.BufferStream()\n        tee = @async try\n            while !eof(ptm)\n                l = readavailable(ptm)\n                write(debug_output, l)\n                Sys.iswindows() && (sleep(0.1); yield(); yield()) # workaround hang - probably a libuv issue?\n                write(output_copy, l)\n            end\n            close(output_copy)\n            close(ptm)\n        catch ex\n            close(output_copy)\n            close(ptm)\n            if !(ex isa Base.IOError && ex.code == Base.UV_EIO)\n                rethrow() # ignore EIO on ptm after pts dies\n            end\n        end\n        # wait for the definitive prompt before start writing to the TTY\n        readuntil(output_copy, \"julia>\")\n        sleep(0.1)\n        readavailable(output_copy)\n        # Input our script\n        if have_repl\n            precompile_lines = split(repl_script::String, '\\n'; keepempty=false)\n            curr = 0\n            for l in precompile_lines\n                sleep(0.1)\n                curr += 1\n                print(\"\\rGenerating REPL precompile statements... $curr/$(length(precompile_lines))\")\n                # consume any other output\n                bytesavailable(output_copy) > 0 && readavailable(output_copy)\n                # push our input\n                write(debug_output, \"\\n#### inputting statement: ####\\n$(repr(l))\\n####\\n\")\n                write(ptm, l, \"\\n\")\n                readuntil(output_copy, \"\\n\")\n                # wait for the next prompt-like to appear\n                # NOTE: this is rather inaccurate because the Pkg REPL mode is a special flower\n                readuntil(output_copy, \"\\n\")\n                readuntil(output_copy, \"> \")\n            end\n            println()\n        end\n        write(ptm, \"exit()\\n\")\n        wait(tee)\n        success(p) || Base.pipeline_error(p)\n        close(ptm)\n        write(debug_output, \"\\n#### FINISHED ####\\n\")\n\n        for statement in split(read(precompile_file, String), '\\n')\n            # Main should be completely clean\n            occursin(\"Main.\", statement) && continue\n            push!(statements, statement)\n        end\n    end\n\n    # Create a staging area where all the loaded packages are available\n    PrecompileStagingArea = Module()\n    for (_pkgid, _mod) in Base.loaded_modules\n        if !(_pkgid.name in (\"Main\", \"Core\", \"Base\"))\n            eval(PrecompileStagingArea, :(const $(Symbol(_mod)) = $_mod))\n        end\n    end\n\n    # Execute the collected precompile statements\n    n_succeeded = 0\n    include_time = @elapsed for statement in sort(collect(statements))\n        # println(statement)\n        # The compiler has problem caching signatures with `Vararg{?, N}`. Replacing\n        # N with a large number seems to work around it.\n        ps = Meta.parse(statement)\n        if isexpr(ps, :call)\n            if isexpr(ps.args[end], :curly)\n                l = ps.args[end]\n                if length(l.args) == 2 && l.args[1] == :Vararg\n                    push!(l.args, 100)\n                end\n            end\n        end\n        try\n            # println(ps)\n            Core.eval(PrecompileStagingArea, ps)\n            n_succeeded += 1\n            print(\"\\rExecuting precompile statements... $n_succeeded/$(length(statements))\")\n        catch\n            # See #28808\n            @error \"Failed to precompile $statement\"\n        end\n    end\n    println()\n    if have_repl\n        # Seems like a reasonable number right now, adjust as needed\n        # comment out if debugging script\n        @assert n_succeeded > 1200\n    end\n\n    tot_time = time_ns() - start_time\n    include_time *= 1e9\n    gen_time = tot_time - include_time\n    println(\"Precompilation complete. Summary:\")\n    print(\"Total \u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"); Base.time_print(tot_time); println()\n    print(\"Generation \u2500\u2500 \"); Base.time_print(gen_time);     print(\" \"); show(IOContext(stdout, :compact=>true), gen_time / tot_time * 100); println(\"%\")\n    print(\"Execution \u2500\u2500\u2500 \"); Base.time_print(include_time); print(\" \"); show(IOContext(stdout, :compact=>true), include_time / tot_time * 100); println(\"%\")\n\n    return\nend\n\ngenerate_precompile_statements()\n\n# As a last step in system image generation,\n# remove some references to build time environment for a more reproducible build.\n@eval Base PROGRAM_FILE = \"\"\n@eval Sys begin\n    BINDIR = \"\"\n    STDLIB = \"\"\nend\nempty!(Base.ARGS)\nempty!(Core.ARGS)\n\nend # @eval\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/doc/src/manual/calling-c-and-fortran-code.md": "# Calling C and Fortran Code\n\nThough most code can be written in Julia, there are many high-quality, mature libraries for numerical\ncomputing already written in C and Fortran. To allow easy use of this existing code, Julia makes\nit simple and efficient to call C and Fortran functions. Julia has a \"no boilerplate\" philosophy:\nfunctions can be called directly from Julia without any \"glue\" code, code generation, or compilation\n-- even from the interactive prompt. This is accomplished just by making an appropriate call with\n[`ccall`](@ref) syntax, which looks like an ordinary function call.\n\nThe code to be called must be available as a shared library. Most C and Fortran libraries ship\ncompiled as shared libraries already, but if you are compiling the code yourself using GCC (or\nClang), you will need to use the `-shared` and `-fPIC` options. The machine instructions generated\nby Julia's JIT are the same as a native C call would be, so the resulting overhead is the same\nas calling a library function from C code. [^1]\n\nShared libraries and functions are referenced by a tuple of the form `(:function, \"library\")`\nor `(\"function\", \"library\")` where `function` is the C-exported function name, and `library` refers\nto the shared library name.  Shared libraries available in the (platform-specific) load path will\nbe resolved by name.  The full path to the library may also be specified.\n\nA function name may be used alone in place of the tuple (just `:function` or `\"function\"`). In\nthis case the name is resolved within the current process. This form can be used to call C library\nfunctions, functions in the Julia runtime, or functions in an application linked to Julia.\n\nBy default, Fortran compilers [generate mangled\nnames](https://en.wikipedia.org/wiki/Name_mangling#Fortran) (for example,\nconverting function names to lowercase or uppercase, often appending an\nunderscore), and so to call a Fortran function via [`ccall`](@ref) you must pass\nthe mangled identifier corresponding to the rule followed by your Fortran\ncompiler.  Also, when calling a Fortran function, all inputs must be passed as\npointers to allocated values on the heap or stack. This applies not only to\narrays and other mutable objects which are normally heap-allocated, but also to\nscalar values such as integers and floats which are normally stack-allocated and\ncommonly passed in registers when using C or Julia calling conventions.\n\nFinally, you can use [`ccall`](@ref) to actually generate a call to the library function. The arguments\nto [`ccall`](@ref) are:\n\n1. A `(:function, \"library\")` pair (most common),\n\n   OR\n\n   a `:function` name symbol or `\"function\"` name string (for symbols in the current process or libc),\n\n   OR\n\n   a function pointer (for example, from `dlsym`).\n\n2. The function's return type\n\n3. A tuple of input types, corresponding to the function signature\n\n4. The actual argument values to be passed to the function, if any; each is a separate parameter.\n\n!!! note\n    The `(:function, \"library\")` pair, return type, and input types must be literal constants\n    (i.e., they can't be variables, but see [Non-constant Function Specifications](@ref) below).\n\n    The remaining parameters are evaluated at compile time, when the containing method is defined.\n\n!!! note\n    See below for how to [map C types to Julia types](@ref mapping-c-types-to-julia).\n\nAs a complete but simple example, the following calls the `clock` function from the standard C\nlibrary on most Unix-derived systems:\n\n```julia-repl\njulia> t = ccall(:clock, Int32, ())\n2292761\n\njulia> t\n2292761\n\njulia> typeof(t)\nInt32\n```\n\n`clock` takes no arguments and returns an [`Int32`](@ref). One common mistake is forgetting that a 1-tuple of\nargument types must be written with a trailing comma. For example, to call the `getenv` function\nto get a pointer to the value of an environment variable, one makes a call like this:\n\n```julia-repl\njulia> path = ccall(:getenv, Cstring, (Cstring,), \"SHELL\")\nCstring(@0x00007fff5fbffc45)\n\njulia> unsafe_string(path)\n\"/bin/bash\"\n```\n\nNote that the argument type tuple must be written as `(Cstring,)`, not `(Cstring)`. This\nis because `(Cstring)` is just the expression `Cstring` surrounded by parentheses, rather than\na 1-tuple containing `Cstring`:\n\n```jldoctest\njulia> (Cstring)\nCstring\n\njulia> (Cstring,)\n(Cstring,)\n```\n\nIn practice, especially when providing reusable functionality, one generally wraps [`ccall`](@ref)\nuses in Julia functions that set up arguments and then check for errors in whatever manner the\nC or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially\nimportant since C and Fortran APIs are notoriously inconsistent about how they indicate error\nconditions. For example, the `getenv` C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from [`env.jl`](https://github.com/JuliaLang/julia/blob/master/base/env.jl):\n\n```julia\nfunction getenv(var::AbstractString)\n    val = ccall(:getenv, Cstring, (Cstring,), var)\n    if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n    end\n    return unsafe_string(val)\nend\n```\n\nThe C `getenv` function indicates an error by returning `NULL`, but other standard C functions\nindicate errors in various different ways, including by returning -1, 0, 1 and other special values.\nThis wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent\nenvironment variable:\n\n```julia-repl\njulia> getenv(\"SHELL\")\n\"/bin/bash\"\n\njulia> getenv(\"FOOBAR\")\ngetenv: undefined variable: FOOBAR\n```\n\nHere is a slightly more complex example that discovers the local machine's hostname.\nIn this example, the networking library code is assumed to be in a shared library named \"libc\".\nIn practice, this function is usually part of the C standard library, and so the \"libc\"\nportion should be omitted, but we wish to show here the usage of this syntax.\n\n```julia\nfunction gethostname()\n    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN\n    err = ccall((:gethostname, \"libc\"), Int32,\n                (Ptr{UInt8}, Csize_t),\n                hostname, sizeof(hostname))\n    Base.systemerror(\"gethostname\", err != 0)\n    hostname[end] = 0 # ensure null-termination\n    return GC.@preserve hostname unsafe_string(pointer(hostname))\nend\n```\n\nThis example first allocates an array of bytes. It then calls the C library function `gethostname`\nto populate the array with the hostname. Finally, it takes a pointer to the hostname buffer, and\nconverts the pointer to a Julia string, assuming that it is a NUL-terminated C string.\n\nIt is common for C libraries to use this pattern of requiring the caller to allocate memory to be\npassed to the callee and populated. Allocation of memory from Julia like this is generally\naccomplished by creating an uninitialized array and passing a pointer to its data to the C function.\nThis is why we don't use the `Cstring` type here: as the array is uninitialized, it could contain\nNUL bytes. Converting to a `Cstring` as part of the [`ccall`](@ref) checks for contained NUL bytes\nand could therefore throw a conversion error.\n\nDeferencing `pointer(hostname)` with `unsafe_string` is an unsafe operation as it requires access to\nthe memory allocated for `hostname` that may have been in the meanwhile garbage collected. The macro\n[`GC.@preserve`](@ref) prevents this from happening and therefore accessing an invalid memory location.\n\n## Creating C-Compatible Julia Function Pointers\n\nIt is possible to pass Julia functions to native C functions that accept function pointer arguments.\nFor example, to match C prototypes of the form:\n\n```c\ntypedef returntype (*functiontype)(argumenttype, ...)\n```\n\nThe macro [`@cfunction`](@ref) generates the C-compatible function pointer for a call to a\nJulia function. The arguments to [`@cfunction`](@ref) are:\n\n1. A Julia function\n2. The function's return type\n3. A tuple of input types, corresponding to the function signature\n\n!!! note\n    As with `ccall`, the return type and tuple of input types must be literal constants.\n\n!!! note\n    Currently, only the platform-default C calling convention is supported. This means that\n    `@cfunction`-generated pointers cannot be used in calls where WINAPI expects a `stdcall`\n    function on 32-bit Windows, but can be used on WIN64 (where `stdcall` is unified with the\n    C calling convention).\n\nA classic example is the standard C library `qsort` function, declared as:\n\n```c\nvoid qsort(void *base, size_t nmemb, size_t size,\n           int (*compare)(const void*, const void*));\n```\n\nThe `base` argument is a pointer to an array of length `nmemb`, with elements of `size` bytes\neach. `compare` is a callback function which takes pointers to two elements `a` and `b` and returns\nan integer less/greater than zero if `a` should appear before/after `b` (or zero if any order\nis permitted).\n\nNow, suppose that we have a 1-d array `A` of values in Julia that we want to sort\nusing the `qsort` function (rather than Julia's built-in `sort` function). Before we consider\ncalling `qsort` and passing arguments, we need to write a comparison function:\n\n```jldoctest mycompare\njulia> function mycompare(a, b)::Cint\n           return (a < b) ? -1 : ((a > b) ? +1 : 0)\n       end\nmycompare (generic function with 1 method)\n```\n\n`qsort` expects a comparison function that return a C `int`, so we annotate the return type\nto be `Cint`.\n\nIn order to pass this function to C, we obtain its address using the macro `@cfunction`:\n\n```jldoctest mycompare\njulia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));\n```\n\n[`@cfunction`](@ref) requires three arguments: the Julia function (`mycompare`), the return type\n(`Cint`), and a literal tuple of the input argument types, in this case to sort an array of `Cdouble`\n([`Float64`](@ref)) elements.\n\nThe final call to `qsort` looks like this:\n\n```jldoctest mycompare\njulia> A = [1.3, -2.7, 4.4, 3.1]\n4-element Vector{Float64}:\n  1.3\n -2.7\n  4.4\n  3.1\n\njulia> ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),\n             A, length(A), sizeof(eltype(A)), mycompare_c)\n\njulia> A\n4-element Vector{Float64}:\n -2.7\n  1.3\n  3.1\n  4.4\n```\n\nAs the example shows, the original Julia array `A` has now been sorted: `[-2.7, 1.3, 3.1, 4.4]`. Note that Julia\n[takes care of converting the array to a `Ptr{Cdouble}`](@ref automatic-type-conversion)), computing\nthe size of the element type in bytes, and so on.\n\nFor fun, try inserting a `println(\"mycompare($a, $b)\")` line into `mycompare`, which will allow\nyou to see the comparisons that `qsort` is performing (and to verify that it is really calling\nthe Julia function that you passed to it).\n\n## [Mapping C Types to Julia](@id mapping-c-types-to-julia)\n\nIt is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies\ncan cause code that works correctly on one system to fail or produce indeterminate results on\na different system.\n\nNote that no C header files are used anywhere in the process of calling C functions: you are responsible\nfor making sure that your Julia types and call signatures accurately reflect those in the C header\nfile.[^2]\n\n### [Automatic Type Conversion](@id automatic-type-conversion)\n\nJulia automatically inserts calls to the [`Base.cconvert`](@ref) function to convert each argument\nto the specified type. For example, the following call:\n\n```julia\nccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64), x, y)\n```\n\nwill behave as if it were written like this:\n\n```julia\nccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64),\n      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n```\n\n[`Base.cconvert`](@ref) normally just calls [`convert`](@ref), but can be defined to return an\narbitrary new object more appropriate for passing to C.\nThis should be used to perform all allocations of memory that will be accessed by the C code.\nFor example, this is used to convert an `Array` of objects (e.g. strings) to an array of pointers.\n\n[`Base.unsafe_convert`](@ref) handles conversion to [`Ptr`](@ref) types. It is considered unsafe because\nconverting an object to a native pointer can hide the object from the garbage collector, causing\nit to be freed prematurely.\n\n### Type Correspondences\n\nFirst, let's review some relevant Julia type terminology:\n\n| Syntax / Keyword              | Example                                     | Description                                                                                                                                                                                                                                                                    |\n|:----------------------------- |:------------------------------------------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `mutable struct`              | `BitSet`                                    | \"Leaf Type\" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no `TypeVars` are allowed) in order for the instance to be constructed.              |\n| `abstract type`               | `Any`, `AbstractArray{T, N}`, `Complex{T}`  | \"Super Type\" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.                                                                                                                                                      |\n| `T{A}`                        | `Vector{Int}`                               | \"Type Parameter\" :: A specialization of a type (typically used for dispatch or storage optimization).                                                                                                                                                                          |\n|                               |                                             | \"TypeVar\" :: The `T` in the type parameter declaration is referred to as a TypeVar (short for type variable).                                                                                                                                                                  |\n| `primitive type`              | `Int`, `Float64`                            | \"Primitive Type\" :: A type with no fields, but a size. It is stored and defined by-value.                                                                                                                                                                                           |\n| `struct`                      | `Pair{Int, Int}`                            | \"Struct\" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.                                                                                                                                                       |\n|                               | `ComplexF64` (`isbits`)                     | \"Is-Bits\"   :: A `primitive type`, or a `struct` type where all fields are other `isbits` types. It is defined by-value, and is stored without a type-tag.                                                                                                                       |\n| `struct ...; end`             | `nothing`                                   | \"Singleton\" :: a Leaf Type or Struct with no fields.                                                                                                                                                                                                                        |\n| `(...)` or `tuple(...)`       | `(1, 2, 3)`                                 | \"Tuple\" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.                                                                                                                                |\n\n### [Bits Types](@id man-bits-types)\n\nThere are several special types to be aware of, as no other type can be defined to behave the\nsame:\n\n  * `Float32`\n\n    Exactly corresponds to the `float` type in C (or `REAL*4` in Fortran).\n\n  * `Float64`\n\n    Exactly corresponds to the `double` type in C (or `REAL*8` in Fortran).\n\n  * `ComplexF32`\n\n    Exactly corresponds to the `complex float` type in C (or `COMPLEX*8` in Fortran).\n\n  * `ComplexF64`\n\n    Exactly corresponds to the `complex double` type in C (or `COMPLEX*16` in Fortran).\n\n  * `Signed`\n\n    Exactly corresponds to the `signed` type annotation in C (or any `INTEGER` type in Fortran).\n    Any Julia type that is not a subtype of [`Signed`](@ref) is assumed to be unsigned.\n\n\n  * `Ref{T}`\n\n    Behaves like a `Ptr{T}` that can manage its memory via the Julia GC.\n\n\n  * `Array{T,N}`\n\n    When an array is passed to C as a `Ptr{T}` argument, it is not reinterpret-cast: Julia requires\n    that the element type of the array matches `T`, and the address of the first element is passed.\n\n    Therefore, if an `Array` contains data in the wrong format, it will have to be explicitly converted\n    using a call such as `trunc(Int32, a)`.\n\n    To pass an array `A` as a pointer of a different type *without* converting the data beforehand\n    (for example, to pass a `Float64` array to a function that operates on uninterpreted bytes), you\n    can declare the argument as `Ptr{Cvoid}`.\n\n    If an array of eltype `Ptr{T}` is passed as a `Ptr{Ptr{T}}` argument, [`Base.cconvert`](@ref)\n    will attempt to first make a null-terminated copy of the array with each element replaced by its\n    [`Base.cconvert`](@ref) version. This allows, for example, passing an `argv` pointer array of type\n    `Vector{String}` to an argument of type `Ptr{Ptr{Cchar}}`.\n\nOn all systems we currently support, basic C/C++ value types may be translated to Julia types\nas follows. Every C type also has a corresponding Julia type with the same name, prefixed by C.\nThis can help when writing portable code (and remembering that an `int` in C is not the same as\nan `Int` in Julia).\n\n\n**System Independent Types**\n\n| C name                                                  | Fortran name             | Standard Julia Alias | Julia Base Type                                                                                                |\n|:------------------------------------------------------- |:------------------------ |:-------------------- |:-------------------------------------------------------------------------------------------------------------- |\n| `unsigned char`                                         | `CHARACTER`              | `Cuchar`             | `UInt8`                                                                                                        |\n| `bool` (_Bool in C99+)                                  |                          | `Cuchar`             | `UInt8`                                                                                                        |\n| `short`                                                 | `INTEGER*2`, `LOGICAL*2` | `Cshort`             | `Int16`                                                                                                        |\n| `unsigned short`                                        |                          | `Cushort`            | `UInt16`                                                                                                       |\n| `int`, `BOOL` (C, typical)                              | `INTEGER*4`, `LOGICAL*4` | `Cint`               | `Int32`                                                                                                        |\n| `unsigned int`                                          |                          | `Cuint`              | `UInt32`                                                                                                       |\n| `long long`                                             | `INTEGER*8`, `LOGICAL*8` | `Clonglong`          | `Int64`                                                                                                        |\n| `unsigned long long`                                    |                          | `Culonglong`         | `UInt64`                                                                                                       |\n| `intmax_t`                                              |                          | `Cintmax_t`          | `Int64`                                                                                                        |\n| `uintmax_t`                                             |                          | `Cuintmax_t`         | `UInt64`                                                                                                       |\n| `float`                                                 | `REAL*4i`                | `Cfloat`             | `Float32`                                                                                                      |\n| `double`                                                | `REAL*8`                 | `Cdouble`            | `Float64`                                                                                                      |\n| `complex float`                                         | `COMPLEX*8`              | `ComplexF32`         | `Complex{Float32}`                                                                                             |\n| `complex double`                                        | `COMPLEX*16`             | `ComplexF64`         | `Complex{Float64}`                                                                                             |\n| `ptrdiff_t`                                             |                          | `Cptrdiff_t`         | `Int`                                                                                                          |\n| `ssize_t`                                               |                          | `Cssize_t`           | `Int`                                                                                                          |\n| `size_t`                                                |                          | `Csize_t`            | `UInt`                                                                                                         |\n| `void`                                                  |                          |                      | `Cvoid`                                                                                                        |\n| `void` and `[[noreturn]]` or `_Noreturn`                |                          |                      | `Union{}`                                                                                                      |\n| `void*`                                                 |                          |                      | `Ptr{Cvoid}` (or similarly `Ref{Cvoid}`)                                                                       |\n| `T*` (where T represents an appropriately defined type) |                          |                      | `Ref{T}` (T may be safely mutated only if T is an isbits type)                                                 |\n| `char*` (or `char[]`, e.g. a string)                    | `CHARACTER*N`            |                      | `Cstring` if NUL-terminated, or `Ptr{UInt8}` if not                                                            |\n| `char**` (or `*char[]`)                                 |                          |                      | `Ptr{Ptr{UInt8}}`                                                                                              |\n| `jl_value_t*` (any Julia Type)                          |                          |                      | `Any`                                                                                                          |\n| `jl_value_t* const*` (a reference to a Julia value)     |                          |                      | `Ref{Any}` (const, since mutation would require a write barrier, which is not possible to insert correctly)    |\n| `va_arg`                                                |                          |                      | Not supported                                                                                                  |\n| `...` (variadic function specification)                 |                          |                      | `T...` (where `T` is one of the above types, when using the `ccall` function)                                  |\n| `...` (variadic function specification)                 |                          |                      | `; va_arg1::T, va_arg2::S, etc.` (only supported with `@ccall` macro)                                          |\n\nThe [`Cstring`](@ref) type is essentially a synonym for `Ptr{UInt8}`, except the conversion to `Cstring`\nthrows an error if the Julia string contains any embedded NUL characters (which would cause the\nstring to be silently truncated if the C routine treats NUL as the terminator).  If you are passing\na `char*` to a C routine that does not assume NUL termination (e.g. because you pass an explicit\nstring length), or if you know for certain that your Julia string does not contain NUL and want\nto skip the check, you can use `Ptr{UInt8}` as the argument type. `Cstring` can also be used as\nthe [`ccall`](@ref) return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve readability of the call.\n\n**System Dependent Types**\n\n| C name          | Standard Julia Alias | Julia Base Type                              |\n|:--------------- |:-------------------- |:-------------------------------------------- |\n| `char`          | `Cchar`              | `Int8` (x86, x86_64), `UInt8` (powerpc, arm) |\n| `long`          | `Clong`              | `Int` (UNIX), `Int32` (Windows)              |\n| `unsigned long` | `Culong`             | `UInt` (UNIX), `UInt32` (Windows)            |\n| `wchar_t`       | `Cwchar_t`           | `Int32` (UNIX), `UInt16` (Windows)           |\n\n!!! note\n    When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated\n    values, so all type correspondences above should contain an additional `Ptr{..}` or\n    `Ref{..}` wrapper around their type specification.\n\n!!! warning\n    For string arguments (`char*`) the Julia type should be `Cstring` (if NUL- terminated data is\n    expected), or either `Ptr{Cchar}` or `Ptr{UInt8}` otherwise (these two pointer types have the same\n    effect), as described above, not `String`. Similarly, for array arguments (`T[]` or `T*`), the\n    Julia type should again be `Ptr{T}`, not `Vector{T}`.\n\n!!! warning\n    Julia's `Char` type is 32 bits, which is not the same as the wide character type (`wchar_t` or\n    `wint_t`) on all platforms.\n\n!!! warning\n    A return type of `Union{}` means the function will not return, i.e., C++11 `[[noreturn]]` or C11\n    `_Noreturn` (e.g. `jl_throw` or `longjmp`). Do not use this for functions that return no value\n    (`void`) but do return, use `Cvoid` instead.\n\n!!! note\n    For `wchar_t*` arguments, the Julia type should be [`Cwstring`](@ref) (if the C routine expects a\n    NUL-terminated string), or `Ptr{Cwchar_t}` otherwise. Note also that UTF-8 string data in Julia is\n    internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without\n    making a copy (but using the `Cwstring` type will cause an error to be thrown if the string itself\n    contains NUL characters).\n\n!!! note\n    C functions that take an argument of type `char**` can be called by using a `Ptr{Ptr{UInt8}}`\n    type within Julia. For example, C functions of the form:\n\n    ```c\n    int main(int argc, char **argv);\n    ```\n\n    can be called via the following Julia code:\n\n    ```julia\n    argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n    ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n    ```\n\n!!! note\n    For Fortran functions taking variable length strings of type `character(len=*)` the string lengths\n    are provided as *hidden arguments*. Type and position of these arguments in the list are compiler\n    specific, where compiler vendors usually default to using `Csize_t` as type and append the hidden\n    arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU),\n    others *optionally* permit placing hidden arguments directly after the character argument (Intel, PGI).\n    For example, Fortran subroutines of the form\n\n    ```fortran\n    subroutine test(str1, str2)\n    character(len=*) :: str1,str2\n    ```\n\n    can be called via the following Julia code, where the lengths are appended\n\n    ```julia\n    str1 = \"foo\"\n    str2 = \"bar\"\n    ccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),\n                        str1, str2, sizeof(str1), sizeof(str2))\n    ```\n\n!!! warning\n    Fortran compilers *may* also add other hidden arguments for pointers, assumed-shape (`:`)\n    and assumed-size (`*`) arrays. Such behaviour can be avoided by using `ISO_C_BINDING` and\n    including `bind(c)` in the definition of the subroutine, which is strongly recommended for\n    interoperable code. In this case there will be no hidden arguments, at the cost of some\n    language features (e.g. only `character(len=1)` will be permitted to pass strings).\n\n!!! note\n    A C function declared to return `Cvoid` will return the value `nothing` in Julia.\n\n### Struct Type Correspondences\n\nComposite types such as `struct` in C or `TYPE` in Fortran90 (or `STRUCTURE` / `RECORD` in some variants\nof F77), can be mirrored in Julia by creating a `struct` definition with the same\nfield layout.\n\nWhen used recursively, `isbits` types are stored inline. All other types are stored as a pointer\nto the data. When mirroring a struct used by-value inside another struct in C, it is imperative\nthat you do not attempt to manually copy the fields over, as this will not preserve the correct\nfield alignment. Instead, declare an `isbits` struct type and use that instead. Unnamed structs\nare not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get an approximation of a `union` if you know, a priori, the field that will have\nthe greatest size (potentially including padding). When translating your fields to Julia, declare\nthe Julia field to be only of that type.\n\nArrays of parameters can be expressed with `NTuple`.  For example, the struct in C notation written as\n\n```c\nstruct B {\n    int A[3];\n};\n\nb_a_2 = B.A[2];\n```\n\ncan be written in Julia as\n\n```julia\nstruct B\n    A::NTuple{3, Cint}\nend\n\nb_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)\n```\n\nArrays of unknown size (C99-compliant variable length structs specified by `[]` or `[0]`) are not directly\nsupported. Often the best way to deal with these is to deal with the byte offsets directly.\nFor example, if a C library declared a proper string type and returned a pointer to it:\n\n```c\nstruct String {\n    int strlen;\n    char data[];\n};\n```\n\nIn Julia, we can access the parts independently to make a copy of that string:\n\n```julia\nstr = from_c::Ptr{Cvoid}\nlen = unsafe_load(Ptr{Cint}(str))\nunsafe_string(str + Core.sizeof(Cint), len)\n```\n\n### Type Parameters\n\nThe type arguments to `ccall` and `@cfunction` are evaluated statically,\nwhen the method containing the usage is defined.\nThey therefore must take the form of a literal tuple, not a variable,\nand cannot reference local variables.\n\nThis may sound like a strange restriction,\nbut remember that since C is not a dynamic language like Julia,\nits functions can only accept argument types with a statically-known, fixed signature.\n\nHowever, while the type layout must be known statically to compute the intended C ABI,\nthe static parameters of the function are considered to be part of this static environment.\nThe static parameters of the function may be used as type parameters in the call signature,\nas long as they don't affect the layout of the type.\nFor example, `f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)`\nis valid, since `Ptr` is always a word-size primitive type.\nBut, `g(x::T) where {T} = ccall(:notvalid, T, (T,), x)`\nis not valid, since the type layout of `T` is not known statically.\n\n### SIMD Values\n\nNote: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.\n\nIf a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding\nJulia type is a homogeneous tuple of `VecElement` that naturally maps to the SIMD type.  Specifically:\n\n>   * The tuple must be the same size as the SIMD type. For example, a tuple representing an `__m128`\n>     on x86 must have a size of 16 bytes.\n>   * The element type of the tuple must be an instance of `VecElement{T}` where `T` is a primitive type that\n>     is 1, 2, 4 or 8 bytes.\n\nFor instance, consider this C routine that uses AVX intrinsics:\n\n```c\n#include <immintrin.h>\n\n__m256 dist( __m256 a, __m256 b ) {\n    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                        _mm256_mul_ps(b, b)));\n}\n```\n\nThe following Julia code calls `dist` using `ccall`:\n\n```julia\nconst m256 = NTuple{8, VecElement{Float32}}\n\na = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))\nb = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))\n\nfunction call_dist(a::m256, b::m256)\n    ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\nend\n\nprintln(call_dist(a,b))\n```\n\nThe host machine must have the requisite SIMD registers.  For example, the code above will not\nwork on hosts without AVX support.\n\n### Memory Ownership\n\n**malloc/free**\n\nMemory allocation and deallocation of such objects must be handled by calls to the appropriate\ncleanup routines in the libraries being used, just like in any C program. Do not try to free an\nobject received from a C library with [`Libc.free`](@ref) in Julia, as this may result in the `free` function\nbeing called via the wrong library and cause the process to abort. The reverse (passing an object\nallocated in Julia to be freed by an external library) is equally invalid.\n\n### When to use T, Ptr{T} and Ref{T}\n\nIn Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared\nto be of type `T` inside the [`ccall`](@ref), as they are passed by value.  For C code accepting\npointers, [`Ref{T}`](@ref) should generally be used for the types of input arguments, allowing the use\nof pointers to memory managed by either Julia or C through the implicit call to [`Base.cconvert`](@ref).\nIn contrast, pointers returned by the C function called should be declared to be of output type\n[`Ptr{T}`](@ref), reflecting that the memory pointed to is managed by C only. Pointers contained in C\nstructs should be represented as fields of type `Ptr{T}` within the corresponding Julia struct\ntypes designed to mimic the internal structure of corresponding C structs.\n\nIn Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type `Ref{T}`, as Fortran passes all variables by\npointers to memory locations. The return type should either be `Cvoid` for\nFortran subroutines, or a `T` for Fortran functions returning the type `T`.\n\n## Mapping C Functions to Julia\n\n### `ccall` / `@cfunction` argument translation guide\n\nFor translating a C argument list to Julia:\n\n  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`,\n    `complex`, `enum` or any of their `typedef` equivalents\n\n      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)\n      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`\n      * argument value will be copied (passed by value)\n  * `struct T` (including typedef to a struct)\n\n      * `T`, where `T` is a Julia leaf type\n      * argument value will be copied (passed by value)\n  * `void*`\n\n      * depends on how this parameter is used, first translate this to the intended pointer type, then\n        determine the Julia equivalent using the remaining rules in this list\n      * this argument may be declared as `Ptr{Cvoid}`, if it really is just an unknown pointer\n  * `jl_value_t*`\n\n      * `Any`\n      * argument value must be a valid Julia object\n  * `jl_value_t* const*`\n\n      * `Ref{Any}`\n      * argument list must be a valid Julia object (or `C_NULL`)\n      * cannot be used for an output parameter, unless the user is able to\n        manage to separate arrange for the object to be GC-preserved\n  * `T*`\n\n      * `Ref{T}`, where `T` is the Julia type corresponding to `T`\n      * argument value will be copied if it is an `inlinealloc` type (which\n        includes `isbits` otherwise, the value must be a valid Julia object\n  * `T (*)(...)` (e.g. a pointer to a function)\n\n      * `Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to\n        create this pointer)\n  * `...` (e.g. a vararg)\n\n      * [for `ccall`]: `T...`, where `T` is the single Julia type of all\n        remaining arguments\n      * [for `@ccall`]: `; va_arg1::T, va_arg2::S, etc`, where `T` and `S` are\n        the Julia type (i.e. separate the regular arguments from varargs with\n        a `;`)\n      * currently unsupported by `@cfunction`\n  * `va_arg`\n\n      * not supported by `ccall` or `@cfunction`\n\n### `ccall` / `@cfunction` return type translation guide\n\nFor translating a C return type to Julia:\n\n  * `void`\n\n      * `Cvoid` (this will return the singleton instance `nothing::Cvoid`)\n  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`,\n    `complex`, `enum` or any of their `typedef` equivalents\n\n      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)\n      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`\n      * argument value will be copied (returned by-value)\n  * `struct T` (including typedef to a struct)\n\n      * `T`, where `T` is a Julia Leaf Type\n      * argument value will be copied (returned by-value)\n  * `void*`\n\n      * depends on how this parameter is used, first translate this to the intended pointer type, then\n        determine the Julia equivalent using the remaining rules in this list\n      * this argument may be declared as `Ptr{Cvoid}`, if it really is just an unknown pointer\n  * `jl_value_t*`\n\n      * `Any`\n      * argument value must be a valid Julia object\n  * `jl_value_t**`\n\n      * `Ptr{Any}` (`Ref{Any}` is invalid as a return type)\n  * `T*`\n\n      * If the memory is already owned by Julia, or is an `isbits` type, and is known to be non-null:\n\n          * `Ref{T}`, where `T` is the Julia type corresponding to `T`\n          * a return type of `Ref{Any}` is invalid, it should either be `Any` (corresponding to\n            `jl_value_t*`) or `Ptr{Any}` (corresponding to `jl_value_t**`)\n          * C **MUST NOT** modify the memory returned via `Ref{T}` if `T` is an `isbits` type\n      * If the memory is owned by C:\n\n          * `Ptr{T}`, where `T` is the Julia type corresponding to `T`\n  * `T (*)(...)` (e.g. a pointer to a function)\n\n      * `Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to create this pointer)\n\n### Passing Pointers for Modifying Inputs\n\nBecause C doesn't support multiple return values, often C functions will take pointers to data\nthat the function will modify. To accomplish this within a [`ccall`](@ref), you need to first\nencapsulate the value inside a [`Ref{T}`](@ref) of the appropriate type. When you pass this `Ref` object\nas an argument, Julia will automatically pass a C pointer to the encapsulated data:\n\n```julia\nwidth = Ref{Cint}(0)\nrange = Ref{Cfloat}(0)\nccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)\n```\n\nUpon return, the contents of `width` and `range` can be retrieved (if they were changed by `foo`)\nby `width[]` and `range[]`; that is, they act like zero-dimensional arrays.\n\n## C Wrapper Examples\n\nLet's start with a simple example of a C wrapper that returns a `Ptr` type:\n\n```julia\nmutable struct gsl_permutation\nend\n\n# The corresponding C signature is\n#     gsl_permutation * gsl_permutation_alloc (size_t n);\nfunction permutation_alloc(n::Integer)\n    output_ptr = ccall(\n        (:gsl_permutation_alloc, :libgsl), # name of C function and library\n        Ptr{gsl_permutation},              # output type\n        (Csize_t,),                        # tuple of input types\n        n                                  # name of Julia variable to pass in\n    )\n    if output_ptr == C_NULL # Could not allocate memory\n        throw(OutOfMemoryError())\n    end\n    return output_ptr\nend\n```\n\nThe [GNU Scientific Library](https://www.gnu.org/software/gsl/) (here assumed to be accessible\nthrough `:libgsl`) defines an opaque pointer, `gsl_permutation *`, as the return type of the C\nfunction `gsl_permutation_alloc`. As user code never has to look inside the `gsl_permutation`\nstruct, the corresponding Julia wrapper simply needs a new type declaration, `gsl_permutation`,\nthat has no internal fields and whose sole purpose is to be placed in the type parameter of a\n`Ptr` type.  The return type of the [`ccall`](@ref) is declared as `Ptr{gsl_permutation}`, since\nthe memory allocated and pointed to by `output_ptr` is controlled by C.\n\nThe input `n` is passed by value, and so the function's input signature is\nsimply declared as `(Csize_t,)` without any `Ref` or `Ptr` necessary. (If the\nwrapper was calling a Fortran function instead, the corresponding function input\nsignature would instead be `(Ref{Csize_t},)`, since Fortran variables are\npassed by pointers.) Furthermore, `n` can be any type that is convertible to a\n`Csize_t` integer; the [`ccall`](@ref) implicitly calls [`Base.cconvert(Csize_t,\nn)`](@ref).\n\nHere is a second example wrapping the corresponding destructor:\n\n```julia\n# The corresponding C signature is\n#     void gsl_permutation_free (gsl_permutation * p);\nfunction permutation_free(p::Ref{gsl_permutation})\n    ccall(\n        (:gsl_permutation_free, :libgsl), # name of C function and library\n        Cvoid,                             # output type\n        (Ref{gsl_permutation},),          # tuple of input types\n        p                                 # name of Julia variable to pass in\n    )\nend\n```\n\nHere, the input `p` is declared to be of type `Ref{gsl_permutation}`, meaning that the memory\nthat `p` points to may be managed by Julia or by C. A pointer to memory allocated by C should\nbe of type `Ptr{gsl_permutation}`, but it is convertible using [`Base.cconvert`](@ref) and therefore\n\nNow if you look closely enough at this example, you may notice that it is incorrect, given our explanation\nabove of preferred declaration types. Do you see it? The function we are calling is going to free the\nmemory. This type of operation cannot be given a Julia object (it will crash or cause memory corruption).\nTherefore, it may be preferable to declare the `p` type as `Ptr{gsl_permutation }`, to make it harder for the\nuser to mistakenly pass another sort of object there than one obtained via `gsl_permutation_alloc`.\n\nIf the C wrapper never expects the user to pass pointers to memory managed by Julia, then using\n`p::Ptr{gsl_permutation}` for the method signature of the wrapper and similarly in the [`ccall`](@ref)\nis also acceptable.\n\nHere is a third example passing Julia arrays:\n\n```julia\n# The corresponding C signature is\n#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n#                                double result_array[])\nfunction sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n    if nmax < nmin\n        throw(DomainError())\n    end\n    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)\n    errorcode = ccall(\n        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library\n        Cint,                               # output type\n        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types\n        nmin, nmax, x, result_array         # names of Julia variables to pass in\n    )\n    if errorcode != 0\n        error(\"GSL error code $errorcode\")\n    end\n    return result_array\nend\n```\n\nThe C function wrapped returns an integer error code; the results of the actual evaluation of\nthe Bessel J function populate the Julia array `result_array`. This variable is declared as a\n`Ref{Cdouble}`, since its memory is allocated and managed by Julia. The implicit call to\n[`Base.cconvert(Ref{Cdouble}, result_array)`](@ref) unpacks\nthe Julia pointer to a Julia array data structure into a form understandable by C.\n\n## Fortran Wrapper Example\n\nThe following example utilizes ccall to call a function in a common Fortran library (libBLAS) to\ncomputes a dot product. Notice that the argument mapping is a bit different here than above, as\nwe need to map from Julia to Fortran.  On every argument type, we specify `Ref` or `Ptr`. This\nmangling convention may be specific to your fortran compiler and operating system, and is likely\nundocumented. However, wrapping each in a `Ref` (or `Ptr`, where equivalent) is a frequent\nrequirement of Fortran compiler implementations:\n\n```julia\nfunction compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n    @assert length(DX) == length(DY)\n    n = length(DX)\n    incx = incy = 1\n    product = ccall((:ddot_, \"libLAPACK\"),\n                    Float64,\n                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),\n                    n, DX, incx, DY, incy)\n    return product\nend\n```\n\n\n## Garbage Collection Safety\n\nWhen passing data to a [`ccall`](@ref), it is best to avoid using the [`pointer`](@ref) function.\nInstead define a convert method and pass the variables directly to the [`ccall`](@ref). [`ccall`](@ref)\nautomatically arranges that all of its arguments will be preserved from garbage collection until\nthe call returns. If a C API will store a reference to memory allocated by Julia, after the [`ccall`](@ref)\nreturns, you must ensure that the object remains visible to the garbage collector. The suggested\nway to do this is to make a global variable of type `Array{Ref,1}` to hold these values, until\nthe C library notifies you that it is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data exists until\nyou have finished using the pointer. Many methods in Julia such as [`unsafe_load`](@ref) and\n[`String`](@ref) make copies of data instead of taking ownership of the buffer, so that it is\nsafe to free (or alter) the original data without affecting Julia. A notable exception is\n[`unsafe_wrap`](@ref) which, for performance reasons, shares (or can be told to take ownership of) the\nunderlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if `a` contained\na reference to `b` and both `a` and `b` are due for garbage collection, there is no guarantee\nthat `b` would be finalized after `a`. If proper finalization of `a` depends on `b` being valid,\nit must be handled in other ways.\n\n## Non-constant Function Specifications\n\nIn some cases, the exact name or path of the needed library is not known in advance and must\nbe computed at run time. To handle such cases, the library component of a `(name, library)`\nspecification can be a function call, e.g. `(:dgemm_, find_blas())`. The call expression will\nbe executed when the `ccall` itself is executed. However, it is assumed that the library\nlocation does not change once it is determined, so the result of the call can be cached and\nreused. Therefore, the number of times the expression executes is unspecified, and returning\ndifferent values for multiple calls results in unspecified behavior.\n\nIf even more flexibility is needed, it is possible\nto use computed values as function names by staging through [`eval`](@ref) as follows:\n\n```\n@eval ccall(($(string(\"a\", \"b\")), \"lib\"), ...\n```\n\nThis expression constructs a name using `string`, then substitutes this name into a new [`ccall`](@ref)\nexpression, which is then evaluated. Keep in mind that `eval` only operates at the top level,\nso within this expression local variables will not be available (unless their values are substituted\nwith `$`). For this reason, `eval` is typically only used to form top-level definitions, for example\nwhen wrapping libraries that contain many similar functions.\nA similar example can be constructed for [`@cfunction`](@ref).\n\nHowever, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep\nreading.\nThe next section discusses how to use indirect calls to efficiently achieve a similar effect.\n\n## Indirect Calls\n\nThe first argument to [`ccall`](@ref) can also be an expression evaluated at run time. In this\ncase, the expression must evaluate to a `Ptr`, which will be used as the address of the native\nfunction to call. This behavior occurs when the first [`ccall`](@ref) argument contains references\nto non-constants, such as local variables, function arguments, or non-constant globals.\n\nFor example, you might look up the function via `dlsym`,\nthen cache it in a shared reference for that session. For example:\n\n```julia\nmacro dlsym(func, lib)\n    z = Ref{Ptr{Cvoid}}(C_NULL)\n    quote\n        let zlocal = $z[]\n            if zlocal == C_NULL\n                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n                $z[] = $zlocal\n            end\n            zlocal\n        end\n    end\nend\n\nmylibvar = Libdl.dlopen(\"mylib\")\nccall(@dlsym(\"myfunc\", mylibvar), Cvoid, ())\n```\n\n## Closure cfunctions\n\nThe first argument to [`@cfunction`](@ref) can be marked with a `$`, in which case\nthe return value will instead be a `struct CFunction` which closes over the argument.\nYou must ensure that this return object is kept alive until all uses of it are done.\nThe contents and code at the cfunction pointer will be erased via a [`finalizer`](@ref)\nwhen this reference is dropped and atexit. This is not usually needed, since this\nfunctionality is not present in C, but can be useful for dealing with ill-designed APIs\nwhich don't provide a separate closure environment parameter.\n\n```julia\nfunction qsort(a::Vector{T}, cmp) where T\n    isbits(T) || throw(ArgumentError(\"this method can only qsort isbits arrays\"))\n    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})\n    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}\n    # (and protected against finalization) by the ccall\n    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),\n        a, length(a), Base.elsize(a), callback)\n    # We could instead use:\n    #    GC.@preserve callback begin\n    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))\n    #    end\n    # if we needed to use it outside of a `ccall`\n    return a\nend\n```\n\n!!! note\n    Closure [`@cfunction`](@ref) rely on LLVM trampolines, which are not available on all\n    platforms (for example ARM and PowerPC).\n\n\n## Closing a Library\n\nIt is sometimes useful to close (unload) a library so that it can be reloaded.\nFor instance, when developing C code for use with Julia, one may need to compile,\ncall the C code from Julia, then close the library, make an edit, recompile,\nand load in the new changes. One can either restart Julia or use the\n`Libdl` functions to manage the library explicitly, such as:\n\n```julia\nlib = Libdl.dlopen(\"./my_lib.so\") # Open the library explicitly.\nsym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.\nccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the same).\nLibdl.dlclose(lib) # Close the library explicitly.\n```\n\nNote that when using `ccall` with the tuple input\n(e.g., `ccall((:my_fcn, \"./my_lib.so\"), ...)`), the library is opened implicitly\nand it may not be explicitly closed.\n\n## Calling Convention\n\nThe second argument to [`ccall`](@ref) can optionally be a calling convention specifier (immediately\npreceding return type). Without any specifier, the platform-default C calling convention is used.\nOther supported conventions are: `stdcall`, `cdecl`, `fastcall`, and `thiscall` (no-op on 64-bit Windows).\nFor example (from `base/libc.jl`) we see the same `gethostname`[`ccall`](@ref) as above, but with the correct\nsignature for Windows:\n\n```julia\nhn = Vector{UInt8}(undef, 256)\nerr = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n```\n\nFor more information, please see the [LLVM Language Reference](http://llvm.org/docs/LangRef.html#calling-conventions).\n\nThere is one additional special calling convention [`llvmcall`](@ref Base.llvmcall),\nwhich allows inserting calls to LLVM intrinsics directly.\nThis can be especially useful when targeting unusual platforms such as GPGPUs.\nFor example, for [CUDA](http://llvm.org/docs/NVPTXUsage.html), we need to be able to read the thread index:\n\n```julia\nccall(\"llvm.nvvm.read.ptx.sreg.tid.x\", llvmcall, Int32, ())\n```\n\nAs with any `ccall`, it is essential to get the argument signature exactly correct.\nAlso, note that there is no compatibility layer that ensures the intrinsic makes\nsense and works on the current target,\nunlike the equivalent Julia functions exposed by `Core.Intrinsics`.\n\n## Accessing Global Variables\n\nGlobal variables exported by native libraries can be accessed by name using the [`cglobal`](@ref)\nfunction. The arguments to [`cglobal`](@ref) are a symbol specification identical to that used\nby [`ccall`](@ref), and a type describing the value stored in the variable:\n\n```julia-repl\njulia> cglobal((:errno, :libc), Int32)\nPtr{Int32} @0x00007f418d0816b8\n```\n\nThe result is a pointer giving the address of the value. The value can be manipulated through\nthis pointer using [`unsafe_load`](@ref) and [`unsafe_store!`](@ref).\n\n!!! note\n    This `errno` symbol may not be found in a library named \"libc\", as this is an implementation detail of\n    your system compiler. Typically standard library symbols should be accessed just by name,\n    allowing the compiler to fill in the correct one.\n    Also, however, the `errno` symbol shown in this example is special in most compilers, and so the value\n    seen here is probably not what you expect or want. Compiling the equivalent code in C on any\n    multi-threaded-capable system would typically actually call a different function (via macro preprocessor\n    overloading), and may give a different result than the legacy value printed here.\n\n## Accessing Data through a Pointer\n\nThe following methods are described as \"unsafe\" because a bad pointer or type declaration can\ncause Julia to terminate abruptly.\n\nGiven a `Ptr{T}`, the contents of type `T` can generally be copied from the referenced memory\ninto a Julia object using `unsafe_load(ptr, [index])`. The index argument is optional (default\nis 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar\nto the behavior of [`getindex`](@ref) and [`setindex!`](@ref) (e.g. `[]` access syntax).\n\nThe return value will be a new object initialized to contain a copy of the contents of the referenced\nmemory. The referenced memory can safely be freed or released.\n\nIf `T` is `Any`, then the memory is assumed to contain a reference to a Julia object (a `jl_value_t*`),\nthe result will be a reference to this object, and the object will not be copied. You must be\ncareful in this case to ensure that the object was always visible to the garbage collector (pointers\ndo not count, but the new reference does) to ensure the memory is not prematurely freed. Note\nthat if the object was not originally allocated by Julia, the new object will never be finalized\nby Julia's garbage collector.  If the `Ptr` itself is actually a `jl_value_t*`, it can be converted\nback to a Julia object reference by [`unsafe_pointer_to_objref(ptr)`](@ref). (Julia values `v`\ncan be converted to `jl_value_t*` pointers, as `Ptr{Cvoid}`, by calling [`pointer_from_objref(v)`](@ref).)\n\nThe reverse operation (writing data to a `Ptr{T}`), can be performed using [`unsafe_store!(ptr, value, [index])`](@ref).\nCurrently, this is only supported for primitive types or other pointer-free (`isbits`) immutable struct\ntypes.\n\nAny operation that throws an error is probably currently unimplemented and should be posted as\na bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (primitive type or immutable struct), the function\n[`unsafe_wrap(Array, ptr,dims, own = false)`](@ref)\nmay be more useful. The final parameter should be true if Julia should \"take ownership\" of the\nunderlying buffer and call `free(ptr)` when the returned `Array` object is finalized.  If the\n`own` parameter is omitted or false, the caller must ensure the buffer remains in existence until\nall access is complete.\n\nArithmetic on the `Ptr` type in Julia (e.g. using `+`) does not behave the same as C's pointer\narithmetic. Adding an integer to a `Ptr` in Julia always moves the pointer by some number of\n*bytes*, not elements. This way, the address values obtained from pointer arithmetic do not depend\non the element types of pointers.\n\n## Thread-safety\n\nSome C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe\nyou'll need to take some extra precautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only *schedule* (via Julia's event loop) the execution of your \"real\"\ncallback. To do this, create an [`AsyncCondition`](@ref Base.AsyncCondition) object and [`wait`](@ref) on it:\n\n```julia\ncond = Base.AsyncCondition()\nwait(cond)\n```\n\nThe callback you pass to C should only execute a [`ccall`](@ref) to `:uv_async_send`, passing\n`cond.handle` as the argument, taking care to avoid any allocations or other interactions with the\nJulia runtime.\n\nNote that events may be coalesced, so multiple calls to `uv_async_send` may result in a single wakeup\nnotification to the condition.\n\n## More About Callbacks\n\nFor more details on how to pass callbacks to C libraries, see this [blog post](https://julialang.org/blog/2013/05/callback).\n\n## C++\n\nFor direct C++ interfacing, see the [Cxx](https://github.com/Keno/Cxx.jl) package. For tools to create C++\nbindings, see the [CxxWrap](https://github.com/JuliaInterop/CxxWrap.jl) package.\n\n\n\n[^1]: Non-library function calls in both C and Julia can be inlined and thus may have\n    even less overhead than calls to shared library functions.\n    The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.\n\n[^2]: The [Clang package](https://github.com/ihnorton/Clang.jl) can be used to auto-generate Julia code\n    from a C header file.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/.git/objects/pack/pack-70931b761d1d1bc49e57dcd2ab9804d02bee62cc.pack",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/.git/objects/pack/pack-70931b761d1d1bc49e57dcd2ab9804d02bee62cc.idx",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/windows/julia.ico",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/windows/julia-banner.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/windows/julia-dots.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/app/julia.icns",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/installresources/logo_hires.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/julia.idraw",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/512.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/256@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/128@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/16@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/32.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/512@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/256.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/128.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/16.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/32@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/doc/src/assets/julia.ico"
    ],
    "total_files": 1630
}